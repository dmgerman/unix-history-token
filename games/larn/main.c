begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	main.c		*/
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"header.h"
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"\nLarn is copyrighted 1986 by Noah Morgan.\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|srcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line counter for showstr()	*/
end_comment

begin_decl_stmt
name|int
name|dropflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if 1 then don't lookforobject() next round */
end_comment

begin_decl_stmt
name|int
name|rmst
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	random monster creation counter		*/
end_comment

begin_decl_stmt
name|int
name|userid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the players login user id number */
end_comment

begin_decl_stmt
name|char
name|nowelcome
init|=
literal|0
decl_stmt|,
name|nomove
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if (nomove) then don't count next iteration as a move */
end_comment

begin_decl_stmt
specifier|static
name|char
name|viewflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	if viewflag then we have done a 99 stay here and don't showcell in the main loop */
end_comment

begin_decl_stmt
name|char
name|restorflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 means restore has been done	*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|cmdhelp
index|[]
init|=
literal|"\ Cmd line format: larn [-slicnh] [-o<optsifle>] [-##] [++]\n\   -s   show the scoreboard\n\   -l   show the logfile (wizard id only)\n\   -i   show scoreboard with inventories of dead characters\n\   -c   create new scoreboard (wizard id only)\n\   -n   suppress welcome message on starting game\n\   -##  specify level of difficulty (example: -5)\n\   -h   print this help text\n\   ++   restore game from checkpoint file\n\   -o<optsfile>   specify .larnopts filename to be used instead of \"~/.larnopts\"\n\ "
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VT100
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|termtypes
index|[]
init|=
block|{
literal|"vt100"
block|,
literal|"vt101"
block|,
literal|"vt102"
block|,
literal|"vt103"
block|,
literal|"vt125"
block|,
literal|"vt131"
block|,
literal|"vt140"
block|,
literal|"vt180"
block|,
literal|"vt220"
block|,
literal|"vt240"
block|,
literal|"vt241"
block|,
literal|"vt320"
block|,
literal|"vt340"
block|,
literal|"vt341"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|VT100
end_endif

begin_comment
comment|/* 	************ 	MAIN PROGRAM 	************  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|hard
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
literal|0
decl_stmt|,
modifier|*
name|ttype
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwe
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
comment|/*  *	first task is to identify the player  */
ifndef|#
directive|ifndef
name|VT100
name|init_term
argument_list|()
expr_stmt|;
comment|/* setup the terminal (find out what type) for termcap */
endif|#
directive|endif
endif|VT100
if|if
condition|(
operator|(
operator|(
name|ptr
operator|=
name|getlogin
argument_list|()
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|*
name|ptr
operator|==
literal|0
operator|)
condition|)
comment|/* try to get login name */
if|if
condition|(
name|pwe
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
condition|)
comment|/* can we get it from /etc/passwd? */
name|ptr
operator|=
name|pwe
operator|->
name|pw_name
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ptr
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|ptr
operator|=
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|noone
label|:
name|write
argument_list|(
literal|2
argument_list|,
literal|"Can't find your logname.  Who Are You?\n"
argument_list|,
literal|39
argument_list|)
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
goto|goto
name|noone
goto|;
if|if
condition|(
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|noone
goto|;
comment|/*  *	second task is to prepare the pathnames the player will need  */
name|strcpy
argument_list|(
name|loginname
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* save loginname of the user for logging purposes */
name|strcpy
argument_list|(
name|logname
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* this will be overwritten with the players name */
if|if
condition|(
operator|(
name|ptr
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|ptr
operator|=
literal|"."
expr_stmt|;
name|strcpy
argument_list|(
name|savefilename
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|savefilename
argument_list|,
literal|"/Larn.sav"
argument_list|)
expr_stmt|;
comment|/* save file name in home directory */
name|sprintf
argument_list|(
name|optsfile
argument_list|,
literal|"%s/.larnopts"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* the .larnopts filename */
comment|/*  *	now malloc the memory for the dungeon  */
name|cell
operator|=
operator|(
expr|struct
name|cel
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cel
argument_list|)
operator|*
operator|(
name|MAXLEVEL
operator|+
name|MAXVLEVEL
operator|)
operator|*
name|MAXX
operator|*
name|MAXY
argument_list|)
expr_stmt|;
if|if
condition|(
name|cell
operator|==
literal|0
condition|)
name|died
argument_list|(
operator|-
literal|285
argument_list|)
expr_stmt|;
comment|/* malloc failure */
name|lpbuf
operator|=
name|malloc
argument_list|(
operator|(
literal|5
operator|*
name|BUFBIG
operator|)
operator|>>
literal|2
argument_list|)
expr_stmt|;
comment|/* output buffer */
name|inbuffer
operator|=
name|malloc
argument_list|(
operator|(
literal|5
operator|*
name|MAXIBUF
operator|)
operator|>>
literal|2
argument_list|)
expr_stmt|;
comment|/* output buffer */
if|if
condition|(
operator|(
name|lpbuf
operator|==
literal|0
operator|)
operator|||
operator|(
name|inbuffer
operator|==
literal|0
operator|)
condition|)
name|died
argument_list|(
operator|-
literal|285
argument_list|)
expr_stmt|;
comment|/* malloc() failure */
name|lcreat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|newgame
argument_list|()
expr_stmt|;
comment|/*	set the initial clock  */
name|hard
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|VT100
comment|/*  *	check terminal type to avoid users who have not vt100 type terminals  */
name|ttype
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|termtypes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ttype
argument_list|,
name|termtypes
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|j
condition|)
block|{
name|lprcat
argument_list|(
literal|"Sorry, Larn needs a VT100 family terminal for all it's features.\n"
argument_list|)
expr_stmt|;
name|lflush
argument_list|()
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
endif|VT100
comment|/*  *	now make scoreboard if it is not there (don't clear)  */
if|if
condition|(
name|stat
argument_list|(
name|scorefile
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
operator|||
name|sb
operator|.
name|st_size
operator|==
literal|0
condition|)
comment|/* not there */
name|makeboard
argument_list|()
expr_stmt|;
comment|/*  *	now process the command line arguments  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'s'
case|:
name|showscores
argument_list|()
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
comment|/* show scoreboard   */
case|case
literal|'l'
case|:
comment|/* show log file     */
name|diedlog
argument_list|()
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
case|case
literal|'i'
case|:
name|showallscores
argument_list|()
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
comment|/* show all scoreboard */
case|case
literal|'c'
case|:
comment|/* anyone with password can create scoreboard */
name|lprcat
argument_list|(
literal|"Preparing to initialize the scoreboard.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpassword
argument_list|()
operator|!=
literal|0
condition|)
comment|/*make new scoreboard*/
block|{
name|makeboard
argument_list|()
expr_stmt|;
name|lprc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|showscores
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|()
expr_stmt|;
case|case
literal|'n'
case|:
comment|/* no welcome msg	*/
name|nowelcome
operator|=
literal|1
expr_stmt|;
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* for hardness */
name|sscanf
argument_list|(
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|hard
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* print out command line arguments */
name|write
argument_list|(
literal|1
argument_list|,
name|cmdhelp
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdhelp
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
case|case
literal|'o'
case|:
comment|/* specify a .larnopts filename */
name|strncpy
argument_list|(
name|optsfile
argument_list|,
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
literal|127
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown option<%s>\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|restorflag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'+'
condition|)
block|{
name|hitflag
operator|=
literal|1
expr_stmt|;
name|restoregame
argument_list|(
name|ckpfile
argument_list|)
expr_stmt|;
comment|/* restore checkpointed game */
block|}
name|i
operator|=
name|argc
expr_stmt|;
block|}
block|}
name|readopts
argument_list|()
expr_stmt|;
comment|/* read the options file if there is one */
ifdef|#
directive|ifdef
name|UIDSCORE
name|userid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
comment|/* obtain the user's effective id number */
else|#
directive|else
else|UIDSCORE
name|userid
operator|=
name|getplid
argument_list|(
name|logname
argument_list|)
expr_stmt|;
comment|/* obtain the players id number */
endif|#
directive|endif
endif|UIDSCORE
if|if
condition|(
name|userid
operator|<
literal|0
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"Can't obtain playerid\n"
argument_list|,
literal|22
argument_list|)
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HIDEBYLINK
comment|/*  *	this section of code causes the program to look like something else to ps  */
if|if
condition|(
name|strcmp
argument_list|(
name|psname
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
comment|/* if a different process name only */
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|access
argument_list|(
name|psname
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* link not there */
if|if
condition|(
name|link
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|psname
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|argv
index|[
literal|0
index|]
operator|=
name|psname
expr_stmt|;
name|execv
argument_list|(
name|psname
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|unlink
argument_list|(
name|psname
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|szero
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* zero the argument to avoid ps snooping */
block|}
endif|#
directive|endif
endif|HIDEBYLINK
if|if
condition|(
name|access
argument_list|(
name|savefilename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
comment|/* restore game if need to */
block|{
name|clear
argument_list|()
expr_stmt|;
name|restorflag
operator|=
literal|1
expr_stmt|;
name|hitflag
operator|=
literal|1
expr_stmt|;
name|restoregame
argument_list|(
name|savefilename
argument_list|)
expr_stmt|;
comment|/* restore last game	*/
block|}
name|sigsetup
argument_list|()
expr_stmt|;
comment|/* trap all needed signals	*/
name|sethard
argument_list|(
name|hard
argument_list|)
expr_stmt|;
comment|/* set up the desired difficulty				*/
name|setupvt100
argument_list|()
expr_stmt|;
comment|/*	setup the terminal special mode				*/
if|if
condition|(
name|c
index|[
name|HP
index|]
operator|==
literal|0
condition|)
comment|/* create new game */
block|{
name|makeplayer
argument_list|()
expr_stmt|;
comment|/*	make the character that will play			*/
name|newcavelevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*	make the dungeon						 	*/
name|predostuff
operator|=
literal|1
expr_stmt|;
comment|/* tell signals that we are in the welcome screen */
if|if
condition|(
name|nowelcome
operator|==
literal|0
condition|)
name|welcome
argument_list|()
expr_stmt|;
comment|/* welcome the player to the game */
block|}
name|drawscreen
argument_list|()
expr_stmt|;
comment|/*	show the initial dungeon					*/
name|predostuff
operator|=
literal|2
expr_stmt|;
comment|/* tell the trap functions that they must do a showplayer() 						from here on */
comment|/* nice(1); */
comment|/* games should be run niced */
name|yrepcount
operator|=
name|hit2flag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|dropflag
operator|==
literal|0
condition|)
name|lookforobject
argument_list|()
expr_stmt|;
comment|/* see if there is an object here	*/
else|else
name|dropflag
operator|=
literal|0
expr_stmt|;
comment|/* don't show it just dropped an item */
if|if
condition|(
name|hitflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
index|[
name|HASTEMONST
index|]
condition|)
name|movemonst
argument_list|()
expr_stmt|;
name|movemonst
argument_list|()
expr_stmt|;
block|}
comment|/*	move the monsters		*/
if|if
condition|(
name|viewflag
operator|==
literal|0
condition|)
name|showcell
argument_list|(
name|playerx
argument_list|,
name|playery
argument_list|)
expr_stmt|;
else|else
name|viewflag
operator|=
literal|0
expr_stmt|;
comment|/*	show stuff around player	*/
if|if
condition|(
name|hit3flag
condition|)
name|flushall
argument_list|()
expr_stmt|;
name|hitflag
operator|=
name|hit3flag
operator|=
literal|0
expr_stmt|;
name|nomove
operator|=
literal|1
expr_stmt|;
name|bot_linex
argument_list|()
expr_stmt|;
comment|/* update bottom line */
while|while
condition|(
name|nomove
condition|)
block|{
if|if
condition|(
name|hit3flag
condition|)
name|flushall
argument_list|()
expr_stmt|;
name|nomove
operator|=
literal|0
expr_stmt|;
name|parse
argument_list|()
expr_stmt|;
block|}
comment|/*	get commands and make moves	*/
name|regen
argument_list|()
expr_stmt|;
comment|/*	regenerate hp and spells			*/
if|if
condition|(
name|c
index|[
name|TIMESTOP
index|]
operator|==
literal|0
condition|)
if|if
condition|(
operator|--
name|rmst
operator|<=
literal|0
condition|)
block|{
name|rmst
operator|=
literal|120
operator|-
operator|(
name|level
operator|<<
literal|2
operator|)
expr_stmt|;
name|fillmonst
argument_list|(
name|makemonst
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* 	showstr()  	show character's inventory  */
end_comment

begin_macro
name|showstr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|number
decl_stmt|;
for|for
control|(
name|number
operator|=
literal|3
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|iven
index|[
name|i
index|]
condition|)
name|number
operator|++
expr_stmt|;
comment|/* count items in inventory */
name|t_setup
argument_list|(
name|number
argument_list|)
expr_stmt|;
name|qshowstr
argument_list|()
expr_stmt|;
name|t_endup
argument_list|(
name|number
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|qshowstr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|sigsav
decl_stmt|;
name|srcount
operator|=
literal|0
expr_stmt|;
name|sigsav
operator|=
name|nosignal
expr_stmt|;
name|nosignal
operator|=
literal|1
expr_stmt|;
comment|/* don't allow ^c etc */
if|if
condition|(
name|c
index|[
name|GOLD
index|]
condition|)
block|{
name|lprintf
argument_list|(
literal|".)   %d gold pieces"
argument_list|,
operator|(
name|long
operator|)
name|c
index|[
name|GOLD
index|]
argument_list|)
expr_stmt|;
name|srcount
operator|++
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|26
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
if|if
condition|(
name|iven
index|[
name|k
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|22
init|;
name|i
operator|<
literal|84
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|k
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|iven
index|[
name|j
index|]
condition|)
name|show3
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
block|}
name|lprintf
argument_list|(
literal|"\nElapsed time is %d.  You have %d mobuls left"
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|gtime
operator|+
literal|99
operator|)
operator|/
literal|100
operator|+
literal|1
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|TIMELIMIT
operator|-
name|gtime
operator|)
operator|/
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|more
argument_list|()
expr_stmt|;
name|nosignal
operator|=
name|sigsav
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	subroutine to clear screen depending on # lines to display  */
end_comment

begin_expr_stmt
name|t_setup
argument_list|(
name|count
argument_list|)
specifier|register
name|int
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|20
condition|)
comment|/* how do we clear the screen? */
block|{
name|cl_up
argument_list|(
literal|79
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|cursor
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|resetscroll
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	subroutine to restore normal display screen depending on t_setup()  */
end_comment

begin_expr_stmt
name|t_endup
argument_list|(
name|count
argument_list|)
specifier|register
name|int
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|18
condition|)
comment|/* how did we clear the screen? */
name|draws
argument_list|(
literal|0
argument_list|,
name|MAXX
argument_list|,
literal|0
argument_list|,
operator|(
name|count
operator|>
name|MAXY
operator|)
condition|?
name|MAXY
else|:
name|count
argument_list|)
expr_stmt|;
else|else
block|{
name|drawscreen
argument_list|()
expr_stmt|;
name|setscroll
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* 	function to show the things player is wearing only  */
end_comment

begin_macro
name|showwear
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|sigsav
decl_stmt|,
name|count
decl_stmt|;
name|sigsav
operator|=
name|nosignal
expr_stmt|;
name|nosignal
operator|=
literal|1
expr_stmt|;
comment|/* don't allow ^c etc */
name|srcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|2
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|26
condition|;
name|j
operator|++
control|)
comment|/* count number of items we will display */
if|if
condition|(
name|i
operator|=
name|iven
index|[
name|j
index|]
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|OLEATHER
case|:
case|case
name|OPLATE
case|:
case|case
name|OCHAIN
case|:
case|case
name|ORING
case|:
case|case
name|OSTUDLEATHER
case|:
case|case
name|OSPLINT
case|:
case|case
name|OPLATEARMOR
case|:
case|case
name|OSSPLATE
case|:
case|case
name|OSHIELD
case|:
name|count
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|t_setup
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|22
init|;
name|i
operator|<
literal|84
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|26
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|iven
index|[
name|j
index|]
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|OLEATHER
case|:
case|case
name|OPLATE
case|:
case|case
name|OCHAIN
case|:
case|case
name|ORING
case|:
case|case
name|OSTUDLEATHER
case|:
case|case
name|OSPLINT
case|:
case|case
name|OPLATEARMOR
case|:
case|case
name|OSSPLATE
case|:
case|case
name|OSHIELD
case|:
name|show3
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|more
argument_list|()
expr_stmt|;
name|nosignal
operator|=
name|sigsav
expr_stmt|;
name|t_endup
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	function to show the things player can wield only  */
end_comment

begin_macro
name|showwield
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|sigsav
decl_stmt|,
name|count
decl_stmt|;
name|sigsav
operator|=
name|nosignal
expr_stmt|;
name|nosignal
operator|=
literal|1
expr_stmt|;
comment|/* don't allow ^c etc */
name|srcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|2
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|26
condition|;
name|j
operator|++
control|)
comment|/* count how many items */
if|if
condition|(
name|i
operator|=
name|iven
index|[
name|j
index|]
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|ODIAMOND
case|:
case|case
name|ORUBY
case|:
case|case
name|OEMERALD
case|:
case|case
name|OSAPPHIRE
case|:
case|case
name|OBOOK
case|:
case|case
name|OCHEST
case|:
case|case
name|OLARNEYE
case|:
case|case
name|ONOTHEFT
case|:
case|case
name|OSPIRITSCARAB
case|:
case|case
name|OCUBEofUNDEAD
case|:
case|case
name|OPOTION
case|:
case|case
name|OSCROLL
case|:
break|break;
default|default:
name|count
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|t_setup
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|22
init|;
name|i
operator|<
literal|84
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|26
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|iven
index|[
name|j
index|]
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|ODIAMOND
case|:
case|case
name|ORUBY
case|:
case|case
name|OEMERALD
case|:
case|case
name|OSAPPHIRE
case|:
case|case
name|OBOOK
case|:
case|case
name|OCHEST
case|:
case|case
name|OLARNEYE
case|:
case|case
name|ONOTHEFT
case|:
case|case
name|OSPIRITSCARAB
case|:
case|case
name|OCUBEofUNDEAD
case|:
case|case
name|OPOTION
case|:
case|case
name|OSCROLL
case|:
break|break;
default|default:
name|show3
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|more
argument_list|()
expr_stmt|;
name|nosignal
operator|=
name|sigsav
expr_stmt|;
name|t_endup
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	function to show the things player can read only  */
end_comment

begin_macro
name|showread
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|sigsav
decl_stmt|,
name|count
decl_stmt|;
name|sigsav
operator|=
name|nosignal
expr_stmt|;
name|nosignal
operator|=
literal|1
expr_stmt|;
comment|/* don't allow ^c etc */
name|srcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|2
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|26
condition|;
name|j
operator|++
control|)
switch|switch
condition|(
name|iven
index|[
name|j
index|]
condition|)
block|{
case|case
name|OBOOK
case|:
case|case
name|OSCROLL
case|:
name|count
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|t_setup
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|22
init|;
name|i
operator|<
literal|84
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|26
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|iven
index|[
name|j
index|]
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|OBOOK
case|:
case|case
name|OSCROLL
case|:
name|show3
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|more
argument_list|()
expr_stmt|;
name|nosignal
operator|=
name|sigsav
expr_stmt|;
name|t_endup
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	function to show the things player can eat only  */
end_comment

begin_macro
name|showeat
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|sigsav
decl_stmt|,
name|count
decl_stmt|;
name|sigsav
operator|=
name|nosignal
expr_stmt|;
name|nosignal
operator|=
literal|1
expr_stmt|;
comment|/* don't allow ^c etc */
name|srcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|2
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|26
condition|;
name|j
operator|++
control|)
switch|switch
condition|(
name|iven
index|[
name|j
index|]
condition|)
block|{
case|case
name|OCOOKIE
case|:
name|count
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|t_setup
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|22
init|;
name|i
operator|<
literal|84
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|26
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|iven
index|[
name|j
index|]
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|OCOOKIE
case|:
name|show3
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|more
argument_list|()
expr_stmt|;
name|nosignal
operator|=
name|sigsav
expr_stmt|;
name|t_endup
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	function to show the things player can quaff only  */
end_comment

begin_macro
name|showquaff
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|sigsav
decl_stmt|,
name|count
decl_stmt|;
name|sigsav
operator|=
name|nosignal
expr_stmt|;
name|nosignal
operator|=
literal|1
expr_stmt|;
comment|/* don't allow ^c etc */
name|srcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|2
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|26
condition|;
name|j
operator|++
control|)
switch|switch
condition|(
name|iven
index|[
name|j
index|]
condition|)
block|{
case|case
name|OPOTION
case|:
name|count
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|t_setup
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|22
init|;
name|i
operator|<
literal|84
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|26
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|iven
index|[
name|j
index|]
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|OPOTION
case|:
name|show3
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|more
argument_list|()
expr_stmt|;
name|nosignal
operator|=
name|sigsav
expr_stmt|;
name|t_endup
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|show1
argument_list|(
name|idx
argument_list|,
name|str2
argument_list|)
specifier|register
name|int
name|idx
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|str2
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|str2
operator|==
literal|0
condition|)
name|lprintf
argument_list|(
literal|"\n%c)   %s"
argument_list|,
name|idx
operator|+
literal|'a'
argument_list|,
name|objectname
index|[
name|iven
index|[
name|idx
index|]
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|str2
index|[
name|ivenarg
index|[
name|idx
index|]
index|]
operator|==
literal|0
condition|)
name|lprintf
argument_list|(
literal|"\n%c)   %s"
argument_list|,
name|idx
operator|+
literal|'a'
argument_list|,
name|objectname
index|[
name|iven
index|[
name|idx
index|]
index|]
argument_list|)
expr_stmt|;
else|else
name|lprintf
argument_list|(
literal|"\n%c)   %s of%s"
argument_list|,
name|idx
operator|+
literal|'a'
argument_list|,
name|objectname
index|[
name|iven
index|[
name|idx
index|]
index|]
argument_list|,
name|str2
index|[
name|ivenarg
index|[
name|idx
index|]
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|show3
argument_list|(
name|index
argument_list|)
specifier|register
name|int
name|index
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|iven
index|[
name|index
index|]
condition|)
block|{
case|case
name|OPOTION
case|:
name|show1
argument_list|(
name|index
argument_list|,
name|potionname
argument_list|)
expr_stmt|;
break|break;
case|case
name|OSCROLL
case|:
name|show1
argument_list|(
name|index
argument_list|,
name|scrollname
argument_list|)
expr_stmt|;
break|break;
case|case
name|OLARNEYE
case|:
case|case
name|OBOOK
case|:
case|case
name|OSPIRITSCARAB
case|:
case|case
name|ODIAMOND
case|:
case|case
name|ORUBY
case|:
case|case
name|OCUBEofUNDEAD
case|:
case|case
name|OEMERALD
case|:
case|case
name|OCHEST
case|:
case|case
name|OCOOKIE
case|:
case|case
name|OSAPPHIRE
case|:
case|case
name|ONOTHEFT
case|:
name|show1
argument_list|(
name|index
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lprintf
argument_list|(
literal|"\n%c)   %s"
argument_list|,
name|index
operator|+
literal|'a'
argument_list|,
name|objectname
index|[
name|iven
index|[
name|index
index|]
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivenarg
index|[
name|index
index|]
operator|>
literal|0
condition|)
name|lprintf
argument_list|(
literal|" + %d"
argument_list|,
operator|(
name|long
operator|)
name|ivenarg
index|[
name|index
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ivenarg
index|[
name|index
index|]
operator|<
literal|0
condition|)
name|lprintf
argument_list|(
literal|" %d"
argument_list|,
operator|(
name|long
operator|)
name|ivenarg
index|[
name|index
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
index|[
name|WIELD
index|]
operator|==
name|index
condition|)
name|lprcat
argument_list|(
literal|" (weapon in hand)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
index|[
name|WEAR
index|]
operator|==
name|index
operator|)
operator|||
operator|(
name|c
index|[
name|SHIELD
index|]
operator|==
name|index
operator|)
condition|)
name|lprcat
argument_list|(
literal|" (being worn)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|srcount
operator|>=
literal|22
condition|)
block|{
name|srcount
operator|=
literal|0
expr_stmt|;
name|more
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* 	subroutine to randomly create monsters if needed  */
end_comment

begin_macro
name|randmonst
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|c
index|[
name|TIMESTOP
index|]
condition|)
return|return;
comment|/*	don't make monsters if time is stopped	*/
if|if
condition|(
operator|--
name|rmst
operator|<=
literal|0
condition|)
block|{
name|rmst
operator|=
literal|120
operator|-
operator|(
name|level
operator|<<
literal|2
operator|)
expr_stmt|;
name|fillmonst
argument_list|(
name|makemonst
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* 	parse()  	get and execute a command  */
end_comment

begin_macro
name|parse
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|flag
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|k
operator|=
name|yylex
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|k
condition|)
comment|/*	get the token from the input and switch on it	*/
block|{
case|case
literal|'h'
case|:
name|moveplayer
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return;
comment|/*	west		*/
case|case
literal|'H'
case|:
name|run
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return;
comment|/*	west		*/
case|case
literal|'l'
case|:
name|moveplayer
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return;
comment|/*	east		*/
case|case
literal|'L'
case|:
name|run
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return;
comment|/*	east		*/
case|case
literal|'j'
case|:
name|moveplayer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
comment|/*	south		*/
case|case
literal|'J'
case|:
name|run
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
comment|/*	south		*/
case|case
literal|'k'
case|:
name|moveplayer
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return;
comment|/*	north		*/
case|case
literal|'K'
case|:
name|run
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return;
comment|/*	north		*/
case|case
literal|'u'
case|:
name|moveplayer
argument_list|(
literal|5
argument_list|)
expr_stmt|;
return|return;
comment|/*	northeast	*/
case|case
literal|'U'
case|:
name|run
argument_list|(
literal|5
argument_list|)
expr_stmt|;
return|return;
comment|/*	northeast	*/
case|case
literal|'y'
case|:
name|moveplayer
argument_list|(
literal|6
argument_list|)
expr_stmt|;
return|return;
comment|/*	northwest	*/
case|case
literal|'Y'
case|:
name|run
argument_list|(
literal|6
argument_list|)
expr_stmt|;
return|return;
comment|/*	northwest	*/
case|case
literal|'n'
case|:
name|moveplayer
argument_list|(
literal|7
argument_list|)
expr_stmt|;
return|return;
comment|/*	southeast	*/
case|case
literal|'N'
case|:
name|run
argument_list|(
literal|7
argument_list|)
expr_stmt|;
return|return;
comment|/*	southeast	*/
case|case
literal|'b'
case|:
name|moveplayer
argument_list|(
literal|8
argument_list|)
expr_stmt|;
return|return;
comment|/*	southwest	*/
case|case
literal|'B'
case|:
name|run
argument_list|(
literal|8
argument_list|)
expr_stmt|;
return|return;
comment|/*	southwest	*/
case|case
literal|'.'
case|:
if|if
condition|(
name|yrepcount
condition|)
name|viewflag
operator|=
literal|1
expr_stmt|;
return|return;
comment|/*	stay here		*/
case|case
literal|'w'
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
name|wield
argument_list|()
expr_stmt|;
return|return;
comment|/*	wield a weapon */
case|case
literal|'W'
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
name|wear
argument_list|()
expr_stmt|;
return|return;
comment|/*	wear armor	*/
case|case
literal|'r'
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
index|[
name|BLINDCOUNT
index|]
condition|)
block|{
name|cursors
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nYou can't read anything when you're blind!"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
index|[
name|TIMESTOP
index|]
operator|==
literal|0
condition|)
name|readscr
argument_list|()
expr_stmt|;
return|return;
comment|/*	to read a scroll	*/
case|case
literal|'q'
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
index|[
name|TIMESTOP
index|]
operator|==
literal|0
condition|)
name|quaff
argument_list|()
expr_stmt|;
return|return;
comment|/*	quaff a potion		*/
case|case
literal|'d'
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
index|[
name|TIMESTOP
index|]
operator|==
literal|0
condition|)
name|dropobj
argument_list|()
expr_stmt|;
return|return;
comment|/*	to drop an object	*/
case|case
literal|'c'
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
name|cast
argument_list|()
expr_stmt|;
return|return;
comment|/*	cast a spell	*/
case|case
literal|'i'
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
name|nomove
operator|=
literal|1
expr_stmt|;
name|showstr
argument_list|()
expr_stmt|;
return|return;
comment|/*	status		*/
case|case
literal|'e'
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
index|[
name|TIMESTOP
index|]
operator|==
literal|0
condition|)
name|eatcookie
argument_list|()
expr_stmt|;
return|return;
comment|/*	to eat a fortune cookie */
case|case
literal|'D'
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
name|seemagic
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nomove
operator|=
literal|1
expr_stmt|;
return|return;
comment|/*	list spells and scrolls */
case|case
literal|'?'
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
name|help
argument_list|()
expr_stmt|;
name|nomove
operator|=
literal|1
expr_stmt|;
return|return;
comment|/*	give the help screen*/
case|case
literal|'S'
case|:
name|clear
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"Saving . . ."
argument_list|)
expr_stmt|;
name|lflush
argument_list|()
expr_stmt|;
name|savegame
argument_list|(
name|savefilename
argument_list|)
expr_stmt|;
name|wizard
operator|=
literal|1
expr_stmt|;
name|died
argument_list|(
operator|-
literal|257
argument_list|)
expr_stmt|;
comment|/*	save the game - doesn't return	*/
case|case
literal|'Z'
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
index|[
name|LEVEL
index|]
operator|>
literal|9
condition|)
block|{
name|oteleport
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|cursors
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nAs yet, you don't have enough experience to use teleportation"
argument_list|)
expr_stmt|;
return|return;
comment|/*	teleport yourself	*/
case|case
literal|'^'
case|:
comment|/* identify traps */
name|flag
operator|=
name|yrepcount
operator|=
literal|0
expr_stmt|;
name|cursors
argument_list|()
expr_stmt|;
name|lprc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|playery
operator|-
literal|1
init|;
name|j
operator|<
name|playery
operator|+
literal|2
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|MAXY
condition|)
break|break;
for|for
control|(
name|i
operator|=
name|playerx
operator|-
literal|1
init|;
name|i
operator|<
name|playerx
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|MAXX
condition|)
break|break;
switch|switch
condition|(
name|item
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
block|{
case|case
name|OTRAPDOOR
case|:
case|case
name|ODARTRAP
case|:
case|case
name|OTRAPARROW
case|:
case|case
name|OTELEPORTER
case|:
name|lprcat
argument_list|(
literal|"\nIts "
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
name|objectname
index|[
name|item
index|[
name|i
index|]
index|[
name|j
index|]
index|]
argument_list|)
expr_stmt|;
name|flag
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
name|lprcat
argument_list|(
literal|"\nNo traps are visible"
argument_list|)
expr_stmt|;
return|return;
if|#
directive|if
name|WIZID
case|case
literal|'_'
case|:
comment|/*	this is the fudge player password for wizard mode*/
name|yrepcount
operator|=
literal|0
expr_stmt|;
name|cursors
argument_list|()
expr_stmt|;
name|nomove
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|userid
operator|!=
name|wisid
condition|)
block|{
name|lprcat
argument_list|(
literal|"Sorry, you are not empowered to be a wizard.\n"
argument_list|)
expr_stmt|;
name|scbr
argument_list|()
expr_stmt|;
comment|/* system("stty -echo cbreak"); */
name|lflush
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|getpassword
argument_list|()
operator|==
literal|0
condition|)
block|{
name|scbr
argument_list|()
expr_stmt|;
comment|/* system("stty -echo cbreak"); */
return|return;
block|}
name|wizard
operator|=
literal|1
expr_stmt|;
name|scbr
argument_list|()
expr_stmt|;
comment|/* system("stty -echo cbreak"); */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|c
index|[
name|i
index|]
operator|=
literal|70
expr_stmt|;
name|iven
index|[
literal|0
index|]
operator|=
name|iven
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|take
argument_list|(
name|OPROTRING
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|take
argument_list|(
name|OLANCE
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|c
index|[
name|WIELD
index|]
operator|=
literal|1
expr_stmt|;
name|c
index|[
name|LANCEDEATH
index|]
operator|=
literal|1
expr_stmt|;
name|c
index|[
name|WEAR
index|]
operator|=
name|c
index|[
name|SHIELD
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|raiseexperience
argument_list|(
literal|6000000L
argument_list|)
expr_stmt|;
name|c
index|[
name|AWARENESS
index|]
operator|+=
literal|25000
expr_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXY
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXX
condition|;
name|j
operator|++
control|)
name|know
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPNUM
condition|;
name|i
operator|++
control|)
name|spelknow
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXSCROLL
condition|;
name|i
operator|++
control|)
name|scrollname
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXPOTION
condition|;
name|i
operator|++
control|)
name|potionname
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXSCROLL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strlen
argument_list|(
name|scrollname
index|[
name|i
index|]
argument_list|)
operator|>
literal|2
condition|)
comment|/* no null items */
block|{
name|item
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|OSCROLL
expr_stmt|;
name|iarg
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|MAXX
operator|-
literal|1
init|;
name|i
operator|>
name|MAXX
operator|-
literal|1
operator|-
name|MAXPOTION
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|strlen
argument_list|(
name|potionname
index|[
name|i
operator|-
name|MAXX
operator|+
name|MAXPOTION
index|]
argument_list|)
operator|>
literal|2
condition|)
comment|/* no null items */
block|{
name|item
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|OPOTION
expr_stmt|;
name|iarg
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|i
operator|-
name|MAXX
operator|+
name|MAXPOTION
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAXY
condition|;
name|i
operator|++
control|)
block|{
name|item
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|iarg
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|MAXY
init|;
name|i
operator|<
name|MAXY
operator|+
name|MAXX
condition|;
name|i
operator|++
control|)
block|{
name|item
index|[
name|i
operator|-
name|MAXY
index|]
index|[
name|MAXY
operator|-
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|iarg
index|[
name|i
operator|-
name|MAXY
index|]
index|[
name|MAXY
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|MAXX
operator|+
name|MAXY
init|;
name|i
operator|<
name|MAXX
operator|+
name|MAXY
operator|+
name|MAXY
condition|;
name|i
operator|++
control|)
block|{
name|item
index|[
name|MAXX
operator|-
literal|1
index|]
index|[
name|i
operator|-
name|MAXX
operator|-
name|MAXY
index|]
operator|=
name|i
expr_stmt|;
name|iarg
index|[
name|MAXX
operator|-
literal|1
index|]
index|[
name|i
operator|-
name|MAXX
operator|-
name|MAXY
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|c
index|[
name|GOLD
index|]
operator|+=
literal|25000
expr_stmt|;
name|drawscreen
argument_list|()
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
literal|'T'
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
name|cursors
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
index|[
name|SHIELD
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
index|[
name|SHIELD
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nYour shield is off"
argument_list|)
expr_stmt|;
name|bottomline
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
index|[
name|WEAR
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
index|[
name|WEAR
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|lprcat
argument_list|(
literal|"\nYour armor is off"
argument_list|)
expr_stmt|;
name|bottomline
argument_list|()
expr_stmt|;
block|}
else|else
name|lprcat
argument_list|(
literal|"\nYou aren't wearing anything"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'g'
case|:
name|cursors
argument_list|()
expr_stmt|;
name|lprintf
argument_list|(
literal|"\nThe stuff you are carrying presently weighs %d pounds"
argument_list|,
operator|(
name|long
operator|)
name|packweight
argument_list|()
argument_list|)
expr_stmt|;
case|case
literal|' '
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
name|nomove
operator|=
literal|1
expr_stmt|;
return|return;
case|case
literal|'v'
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
name|cursors
argument_list|()
expr_stmt|;
name|lprintf
argument_list|(
literal|"\nCaverns of Larn, Version %d.%d, Diff=%d"
argument_list|,
operator|(
name|long
operator|)
name|VERSION
argument_list|,
operator|(
name|long
operator|)
name|SUBVERSION
argument_list|,
operator|(
name|long
operator|)
name|c
index|[
name|HARDGAME
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wizard
condition|)
name|lprcat
argument_list|(
literal|" Wizard"
argument_list|)
expr_stmt|;
name|nomove
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cheat
condition|)
name|lprcat
argument_list|(
literal|" Cheater"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
name|copyright
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Q'
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
name|nomove
operator|=
literal|1
expr_stmt|;
return|return;
comment|/*	quit		*/
case|case
literal|'L'
operator|-
literal|64
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
name|drawscreen
argument_list|()
expr_stmt|;
name|nomove
operator|=
literal|1
expr_stmt|;
return|return;
comment|/*	look		*/
if|#
directive|if
name|WIZID
ifdef|#
directive|ifdef
name|EXTRA
case|case
literal|'A'
case|:
name|yrepcount
operator|=
literal|0
expr_stmt|;
name|nomove
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|wizard
condition|)
block|{
name|diag
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/*	create diagnostic file */
return|return;
endif|#
directive|endif
endif|#
directive|endif
case|case
literal|'P'
case|:
name|cursors
argument_list|()
expr_stmt|;
if|if
condition|(
name|outstanding_taxes
operator|>
literal|0
condition|)
name|lprintf
argument_list|(
literal|"\nYou presently owe %d gp in taxes."
argument_list|,
operator|(
name|long
operator|)
name|outstanding_taxes
argument_list|)
expr_stmt|;
else|else
name|lprcat
argument_list|(
literal|"\nYou do not owe any taxes."
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
block|}
block|}
end_block

begin_macro
name|parse2
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|c
index|[
name|HASTEMONST
index|]
condition|)
name|movemonst
argument_list|()
expr_stmt|;
name|movemonst
argument_list|()
expr_stmt|;
comment|/*	move the monsters		*/
name|randmonst
argument_list|()
expr_stmt|;
name|regen
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|run
argument_list|(
argument|dir
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dir
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|i
condition|)
block|{
name|i
operator|=
name|moveplayer
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|c
index|[
name|HASTEMONST
index|]
condition|)
name|movemonst
argument_list|()
expr_stmt|;
name|movemonst
argument_list|()
expr_stmt|;
name|randmonst
argument_list|()
expr_stmt|;
name|regen
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|hitflag
condition|)
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|showcell
argument_list|(
name|playerx
argument_list|,
name|playery
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* 	function to wield a weapon  */
end_comment

begin_macro
name|wield
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|whatitem
argument_list|(
literal|"wield"
argument_list|)
operator|)
operator|==
literal|'\33'
condition|)
return|return;
if|if
condition|(
name|i
operator|!=
literal|'.'
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|'*'
condition|)
name|showwield
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
operator|==
literal|0
condition|)
block|{
name|ydhi
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
operator|==
name|OPOTION
condition|)
block|{
name|ycwi
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
operator|==
name|OSCROLL
condition|)
block|{
name|ycwi
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
index|[
name|SHIELD
index|]
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
operator|==
name|O2SWORD
operator|)
condition|)
block|{
name|lprcat
argument_list|(
literal|"\nBut one arm is busy with your shield!"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|c
index|[
name|WIELD
index|]
operator|=
name|i
operator|-
literal|'a'
expr_stmt|;
if|if
condition|(
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
operator|==
name|OLANCE
condition|)
name|c
index|[
name|LANCEDEATH
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|c
index|[
name|LANCEDEATH
index|]
operator|=
literal|0
expr_stmt|;
name|bottomline
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* 	common routine to say you don't have an item  */
end_comment

begin_macro
name|ydhi
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cursors
argument_list|()
expr_stmt|;
name|lprintf
argument_list|(
literal|"\nYou don't have item %c!"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ycwi
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cursors
argument_list|()
expr_stmt|;
name|lprintf
argument_list|(
literal|"\nYou can't wield item %c!"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	function to wear armor  */
end_comment

begin_macro
name|wear
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|whatitem
argument_list|(
literal|"wear"
argument_list|)
operator|)
operator|==
literal|'\33'
condition|)
return|return;
if|if
condition|(
name|i
operator|!=
literal|'.'
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|'*'
condition|)
name|showwear
argument_list|()
expr_stmt|;
else|else
switch|switch
condition|(
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
condition|)
block|{
case|case
literal|0
case|:
name|ydhi
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
name|OLEATHER
case|:
case|case
name|OCHAIN
case|:
case|case
name|OPLATE
case|:
case|case
name|OSTUDLEATHER
case|:
case|case
name|ORING
case|:
case|case
name|OSPLINT
case|:
case|case
name|OPLATEARMOR
case|:
case|case
name|OSSPLATE
case|:
if|if
condition|(
name|c
index|[
name|WEAR
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|lprcat
argument_list|(
literal|"\nYou're already wearing some armor"
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
index|[
name|WEAR
index|]
operator|=
name|i
operator|-
literal|'a'
expr_stmt|;
name|bottomline
argument_list|()
expr_stmt|;
return|return;
case|case
name|OSHIELD
case|:
if|if
condition|(
name|c
index|[
name|SHIELD
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|lprcat
argument_list|(
literal|"\nYou are already wearing a shield"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iven
index|[
name|c
index|[
name|WIELD
index|]
index|]
operator|==
name|O2SWORD
condition|)
block|{
name|lprcat
argument_list|(
literal|"\nYour hands are busy with the two handed sword!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
index|[
name|SHIELD
index|]
operator|=
name|i
operator|-
literal|'a'
expr_stmt|;
name|bottomline
argument_list|()
expr_stmt|;
return|return;
default|default:
name|lprcat
argument_list|(
literal|"\nYou can't wear that!"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* 	function to drop an object  */
end_comment

begin_macro
name|dropobj
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|amt
decl_stmt|;
name|p
operator|=
operator|&
name|item
index|[
name|playerx
index|]
index|[
name|playery
index|]
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|whatitem
argument_list|(
literal|"drop"
argument_list|)
operator|)
operator|==
literal|'\33'
condition|)
return|return;
if|if
condition|(
name|i
operator|==
literal|'*'
condition|)
name|showstr
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|i
operator|==
literal|'.'
condition|)
comment|/* drop some gold */
block|{
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|lprcat
argument_list|(
literal|"\nThere's something here already!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lprcat
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|cl_dn
argument_list|(
literal|1
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
literal|"How much gold do you drop? "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|amt
operator|=
name|readnum
argument_list|(
operator|(
name|long
operator|)
name|c
index|[
name|GOLD
index|]
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|amt
operator|>
name|c
index|[
name|GOLD
index|]
condition|)
block|{
name|lprcat
argument_list|(
literal|"\nYou don't have that much!"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|amt
operator|<=
literal|32767
condition|)
block|{
operator|*
name|p
operator|=
name|OGOLDPILE
expr_stmt|;
name|i
operator|=
name|amt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|amt
operator|<=
literal|327670L
condition|)
block|{
operator|*
name|p
operator|=
name|ODGOLD
expr_stmt|;
name|i
operator|=
name|amt
operator|/
literal|10
expr_stmt|;
name|amt
operator|=
literal|10
operator|*
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|amt
operator|<=
literal|3276700L
condition|)
block|{
operator|*
name|p
operator|=
name|OMAXGOLD
expr_stmt|;
name|i
operator|=
name|amt
operator|/
literal|100
expr_stmt|;
name|amt
operator|=
literal|100
operator|*
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|amt
operator|<=
literal|32767000L
condition|)
block|{
operator|*
name|p
operator|=
name|OKGOLD
expr_stmt|;
name|i
operator|=
name|amt
operator|/
literal|1000
expr_stmt|;
name|amt
operator|=
literal|1000
operator|*
name|i
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|=
name|OKGOLD
expr_stmt|;
name|i
operator|=
literal|32767
expr_stmt|;
name|amt
operator|=
literal|32767000L
expr_stmt|;
block|}
name|c
index|[
name|GOLD
index|]
operator|-=
name|amt
expr_stmt|;
name|lprintf
argument_list|(
literal|"You drop %d gold pieces"
argument_list|,
operator|(
name|long
operator|)
name|amt
argument_list|)
expr_stmt|;
name|iarg
index|[
name|playerx
index|]
index|[
name|playery
index|]
operator|=
name|i
expr_stmt|;
name|bottomgold
argument_list|()
expr_stmt|;
name|know
index|[
name|playerx
index|]
index|[
name|playery
index|]
operator|=
literal|0
expr_stmt|;
name|dropflag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|drop_object
argument_list|(
name|i
operator|-
literal|'a'
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	readscr()		Subroutine to read a scroll one is carrying  */
end_comment

begin_macro
name|readscr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|whatitem
argument_list|(
literal|"read"
argument_list|)
operator|)
operator|==
literal|'\33'
condition|)
return|return;
if|if
condition|(
name|i
operator|!=
literal|'.'
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|'*'
condition|)
name|showread
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
operator|==
name|OSCROLL
condition|)
block|{
name|read_scroll
argument_list|(
name|ivenarg
index|[
name|i
operator|-
literal|'a'
index|]
argument_list|)
expr_stmt|;
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
operator|==
name|OBOOK
condition|)
block|{
name|readbook
argument_list|(
name|ivenarg
index|[
name|i
operator|-
literal|'a'
index|]
argument_list|)
expr_stmt|;
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
operator|==
literal|0
condition|)
block|{
name|ydhi
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|lprcat
argument_list|(
literal|"\nThere's nothing on it to read"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	subroutine to eat a cookie one is carrying  */
end_comment

begin_macro
name|eatcookie
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|whatitem
argument_list|(
literal|"eat"
argument_list|)
operator|)
operator|==
literal|'\33'
condition|)
return|return;
if|if
condition|(
name|i
operator|!=
literal|'.'
condition|)
if|if
condition|(
name|i
operator|==
literal|'*'
condition|)
name|showeat
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
operator|==
name|OCOOKIE
condition|)
block|{
name|lprcat
argument_list|(
literal|"\nThe cookie was delicious."
argument_list|)
expr_stmt|;
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|c
index|[
name|BLINDCOUNT
index|]
condition|)
block|{
if|if
condition|(
name|p
operator|=
name|fortune
argument_list|(
name|fortfile
argument_list|)
condition|)
block|{
name|lprcat
argument_list|(
literal|"  Inside you find a scrap of paper that says:\n"
argument_list|)
expr_stmt|;
name|lprcat
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
if|if
condition|(
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
operator|==
literal|0
condition|)
block|{
name|ydhi
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|lprcat
argument_list|(
literal|"\nYou can't eat that!"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	subroutine to quaff a potion one is carrying  */
end_comment

begin_macro
name|quaff
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|whatitem
argument_list|(
literal|"quaff"
argument_list|)
operator|)
operator|==
literal|'\33'
condition|)
return|return;
if|if
condition|(
name|i
operator|!=
literal|'.'
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|'*'
condition|)
name|showquaff
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
operator|==
name|OPOTION
condition|)
block|{
name|quaffpotion
argument_list|(
name|ivenarg
index|[
name|i
operator|-
literal|'a'
index|]
argument_list|)
expr_stmt|;
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iven
index|[
name|i
operator|-
literal|'a'
index|]
operator|==
literal|0
condition|)
block|{
name|ydhi
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|lprcat
argument_list|(
literal|"\nYou wouldn't want to quaff that, would you? "
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* 	function to ask what player wants to do  */
end_comment

begin_macro
name|whatitem
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|cursors
argument_list|()
expr_stmt|;
name|lprintf
argument_list|(
literal|"\nWhat do you want to %s [* for all] ? "
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|'z'
operator|||
operator|(
name|i
operator|<
literal|'a'
operator|&&
name|i
operator|!=
literal|'*'
operator|&&
name|i
operator|!=
literal|'\33'
operator|&&
name|i
operator|!=
literal|'.'
operator|)
condition|)
name|i
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|'\33'
condition|)
name|lprcat
argument_list|(
literal|" aborted"
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/* 	subroutine to get a number from the player 	and allow * to mean return amt, else return the number entered  */
end_comment

begin_function
name|unsigned
name|long
name|readnum
parameter_list|(
name|mx
parameter_list|)
name|long
name|mx
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|long
name|amt
init|=
literal|0
decl_stmt|;
name|sncbr
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'*'
condition|)
name|amt
operator|=
name|mx
expr_stmt|;
comment|/* allow him to say * for all gold */
else|else
while|while
condition|(
name|i
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|'\033'
condition|)
block|{
name|scbr
argument_list|()
expr_stmt|;
name|lprcat
argument_list|(
literal|" aborted"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|i
operator|<=
literal|'9'
operator|)
operator|&&
operator|(
name|i
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|amt
operator|<
literal|99999999
operator|)
condition|)
name|amt
operator|=
name|amt
operator|*
literal|10
operator|+
name|i
operator|-
literal|'0'
expr_stmt|;
name|i
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
name|scbr
argument_list|()
expr_stmt|;
return|return
operator|(
name|amt
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HIDEBYLINK
end_ifdef

begin_comment
comment|/*  *	routine to zero every byte in a string  */
end_comment

begin_expr_stmt
name|szero
argument_list|(
name|str
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|str
condition|)
operator|*
name|str
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|HIDEBYLINK
end_endif

end_unit

