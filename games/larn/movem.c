begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	movem.c (move monster)		Larn is copyrighted 1986 by Noah Morgan.  * $FreeBSD$  *  *	Here are the functions in this file:  *  *	movemonst()		Routine to move the monsters toward the player  *	movemt(x,y)		Function to move a monster at (x,y) -- must determine where  *	mmove(x,y,xd,yd)	Function to actually perform the monster movement  *	movsphere() 		Function to look for and move spheres of annihilation  */
end_comment

begin_include
include|#
directive|include
file|"header.h"
end_include

begin_comment
comment|/*  *	movemonst()		Routine to move the monsters toward the player  *  *	This routine has the responsibility to determine which monsters are to  *	move, and call movemt() to do the move.  *	Returns no value.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|w1
index|[
literal|9
index|]
decl_stmt|,
name|w1x
index|[
literal|9
index|]
decl_stmt|,
name|w1y
index|[
literal|9
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|tmp3
decl_stmt|,
name|tmp4
decl_stmt|,
name|distance
decl_stmt|;
end_decl_stmt

begin_macro
name|movemonst
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|c
index|[
name|TIMESTOP
index|]
condition|)
return|return;
comment|/* no action if time is stopped */
if|if
condition|(
name|c
index|[
name|HASTESELF
index|]
condition|)
if|if
condition|(
operator|(
name|c
index|[
name|HASTESELF
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|spheres
condition|)
name|movsphere
argument_list|()
expr_stmt|;
comment|/* move the spheres of annihilation if any */
if|if
condition|(
name|c
index|[
name|HOLDMONST
index|]
condition|)
return|return;
comment|/* no action if monsters are held */
if|if
condition|(
name|c
index|[
name|AGGRAVATE
index|]
condition|)
comment|/* determine window of monsters to move */
block|{
name|tmp1
operator|=
name|playery
operator|-
literal|5
expr_stmt|;
name|tmp2
operator|=
name|playery
operator|+
literal|6
expr_stmt|;
name|tmp3
operator|=
name|playerx
operator|-
literal|10
expr_stmt|;
name|tmp4
operator|=
name|playerx
operator|+
literal|11
expr_stmt|;
name|distance
operator|=
literal|40
expr_stmt|;
comment|/* depth of intelligent monster movement */
block|}
else|else
block|{
name|tmp1
operator|=
name|playery
operator|-
literal|3
expr_stmt|;
name|tmp2
operator|=
name|playery
operator|+
literal|4
expr_stmt|;
name|tmp3
operator|=
name|playerx
operator|-
literal|5
expr_stmt|;
name|tmp4
operator|=
name|playerx
operator|+
literal|6
expr_stmt|;
name|distance
operator|=
literal|17
expr_stmt|;
comment|/* depth of intelligent monster movement */
block|}
if|if
condition|(
name|level
operator|==
literal|0
condition|)
comment|/* if on outside level monsters can move in perimeter */
block|{
if|if
condition|(
name|tmp1
operator|<
literal|0
condition|)
name|tmp1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmp2
operator|>
name|MAXY
condition|)
name|tmp2
operator|=
name|MAXY
expr_stmt|;
if|if
condition|(
name|tmp3
operator|<
literal|0
condition|)
name|tmp3
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmp4
operator|>
name|MAXX
condition|)
name|tmp4
operator|=
name|MAXX
expr_stmt|;
block|}
else|else
comment|/* if in a dungeon monsters can't be on the perimeter (wall there) */
block|{
if|if
condition|(
name|tmp1
operator|<
literal|1
condition|)
name|tmp1
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tmp2
operator|>
name|MAXY
operator|-
literal|1
condition|)
name|tmp2
operator|=
name|MAXY
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|tmp3
operator|<
literal|1
condition|)
name|tmp3
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tmp4
operator|>
name|MAXX
operator|-
literal|1
condition|)
name|tmp4
operator|=
name|MAXX
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|tmp1
init|;
name|j
operator|<
name|tmp2
condition|;
name|j
operator|++
control|)
comment|/* now reset monster moved flags */
for|for
control|(
name|i
operator|=
name|tmp3
init|;
name|i
operator|<
name|tmp4
condition|;
name|i
operator|++
control|)
name|moved
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|moved
index|[
name|lasthx
index|]
index|[
name|lasthy
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
index|[
name|AGGRAVATE
index|]
operator|||
operator|!
name|c
index|[
name|STEALTH
index|]
condition|)
comment|/* who gets moved? split for efficiency */
block|{
for|for
control|(
name|j
operator|=
name|tmp1
init|;
name|j
operator|<
name|tmp2
condition|;
name|j
operator|++
control|)
comment|/* look thru all locations in window */
for|for
control|(
name|i
operator|=
name|tmp3
init|;
name|i
operator|<
name|tmp4
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mitem
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
comment|/* if there is a monster to move */
if|if
condition|(
name|moved
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|0
condition|)
comment|/* if it has not already been moved */
name|movemt
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* go and move the monster */
block|}
else|else
comment|/* not aggravated and not stealth */
block|{
for|for
control|(
name|j
operator|=
name|tmp1
init|;
name|j
operator|<
name|tmp2
condition|;
name|j
operator|++
control|)
comment|/* look thru all locations in window */
for|for
control|(
name|i
operator|=
name|tmp3
init|;
name|i
operator|<
name|tmp4
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mitem
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
comment|/* if there is a monster to move */
if|if
condition|(
name|moved
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|0
condition|)
comment|/* if it has not already been moved */
if|if
condition|(
name|stealth
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
comment|/* if it is asleep due to stealth */
name|movemt
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* go and move the monster */
block|}
if|if
condition|(
name|mitem
index|[
name|lasthx
index|]
index|[
name|lasthy
index|]
condition|)
comment|/* now move monster last hit by player if not already moved */
block|{
if|if
condition|(
name|moved
index|[
name|lasthx
index|]
index|[
name|lasthy
index|]
operator|==
literal|0
condition|)
comment|/* if it has not already been moved */
block|{
name|movemt
argument_list|(
name|lasthx
argument_list|,
name|lasthy
argument_list|)
expr_stmt|;
name|lasthx
operator|=
name|w1x
index|[
literal|0
index|]
expr_stmt|;
name|lasthy
operator|=
name|w1y
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	movemt(x,y)		Function to move a monster at (x,y) -- must determine where  *		int x,y;  *  *	This routine is responsible for determining where one monster at (x,y) will  *	move to.  Enter with the monsters coordinates in (x,y).  *	Returns no value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tmpitem
decl_stmt|,
name|xl
decl_stmt|,
name|xh
decl_stmt|,
name|yl
decl_stmt|,
name|yh
decl_stmt|;
end_decl_stmt

begin_macro
name|movemt
argument_list|(
argument|i
argument_list|,
argument|j
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|k
decl_stmt|,
name|m
decl_stmt|,
name|z
decl_stmt|,
name|tmp
decl_stmt|,
name|xtmp
decl_stmt|,
name|ytmp
decl_stmt|,
name|monst
decl_stmt|;
switch|switch
condition|(
name|monst
operator|=
name|mitem
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
comment|/* for half speed monsters */
block|{
case|case
name|TROGLODYTE
case|:
case|case
name|HOBGOBLIN
case|:
case|case
name|METAMORPH
case|:
case|case
name|XVART
case|:
case|case
name|INVISIBLESTALKER
case|:
case|case
name|ICELIZARD
case|:
if|if
condition|(
operator|(
name|gtime
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
return|return;
block|}
empty_stmt|;
if|if
condition|(
name|c
index|[
name|SCAREMONST
index|]
condition|)
comment|/* choose destination randomly if scared */
block|{
if|if
condition|(
operator|(
name|xl
operator|=
name|i
operator|+
name|rnd
argument_list|(
literal|3
argument_list|)
operator|-
literal|2
operator|)
operator|<
literal|0
condition|)
name|xl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xl
operator|>=
name|MAXX
condition|)
name|xl
operator|=
name|MAXX
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|yl
operator|=
name|j
operator|+
name|rnd
argument_list|(
literal|3
argument_list|)
operator|-
literal|2
operator|)
operator|<
literal|0
condition|)
name|yl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yl
operator|>=
name|MAXY
condition|)
name|yl
operator|=
name|MAXY
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|item
index|[
name|xl
index|]
index|[
name|yl
index|]
operator|)
operator|!=
name|OWALL
condition|)
if|if
condition|(
name|mitem
index|[
name|xl
index|]
index|[
name|yl
index|]
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|mitem
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
name|VAMPIRE
operator|)
operator|||
operator|(
name|tmpitem
operator|!=
name|OMIRROR
operator|)
condition|)
if|if
condition|(
name|tmp
operator|!=
name|OCLOSEDDOOR
condition|)
name|mmove
argument_list|(
name|i
argument_list|,
name|j
argument_list|,
name|xl
argument_list|,
name|yl
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|monster
index|[
name|monst
index|]
operator|.
name|intelligence
operator|>
literal|10
operator|-
name|c
index|[
name|HARDGAME
index|]
condition|)
comment|/* if smart monster */
comment|/* intelligent movement here -- first setup screen array */
block|{
name|xl
operator|=
name|tmp3
operator|-
literal|2
expr_stmt|;
name|yl
operator|=
name|tmp1
operator|-
literal|2
expr_stmt|;
name|xh
operator|=
name|tmp4
operator|+
literal|2
expr_stmt|;
name|yh
operator|=
name|tmp2
operator|+
literal|2
expr_stmt|;
name|vxy
argument_list|(
operator|&
name|xl
argument_list|,
operator|&
name|yl
argument_list|)
expr_stmt|;
name|vxy
argument_list|(
operator|&
name|xh
argument_list|,
operator|&
name|yh
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|yl
init|;
name|k
operator|<
name|yh
condition|;
name|k
operator|++
control|)
for|for
control|(
name|m
operator|=
name|xl
init|;
name|m
operator|<
name|xh
condition|;
name|m
operator|++
control|)
block|{
switch|switch
condition|(
name|item
index|[
name|m
index|]
index|[
name|k
index|]
condition|)
block|{
case|case
name|OWALL
case|:
case|case
name|OPIT
case|:
case|case
name|OTRAPARROW
case|:
case|case
name|ODARTRAP
case|:
case|case
name|OCLOSEDDOOR
case|:
case|case
name|OTRAPDOOR
case|:
case|case
name|OTELEPORTER
case|:
name|smm
label|:
name|screen
index|[
name|m
index|]
index|[
name|k
index|]
operator|=
literal|127
expr_stmt|;
break|break;
case|case
name|OMIRROR
case|:
if|if
condition|(
name|mitem
index|[
name|m
index|]
index|[
name|k
index|]
operator|==
name|VAMPIRE
condition|)
goto|goto
name|smm
goto|;
default|default:
name|screen
index|[
name|m
index|]
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
name|screen
index|[
name|playerx
index|]
index|[
name|playery
index|]
operator|=
literal|1
expr_stmt|;
comment|/* now perform proximity ripple from playerx,playery to monster */
name|xl
operator|=
name|tmp3
operator|-
literal|1
expr_stmt|;
name|yl
operator|=
name|tmp1
operator|-
literal|1
expr_stmt|;
name|xh
operator|=
name|tmp4
operator|+
literal|1
expr_stmt|;
name|yh
operator|=
name|tmp2
operator|+
literal|1
expr_stmt|;
name|vxy
argument_list|(
operator|&
name|xl
argument_list|,
operator|&
name|yl
argument_list|)
expr_stmt|;
name|vxy
argument_list|(
operator|&
name|xh
argument_list|,
operator|&
name|yh
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
literal|1
init|;
name|tmp
operator|<
name|distance
condition|;
name|tmp
operator|++
control|)
comment|/* only up to 20 squares away */
for|for
control|(
name|k
operator|=
name|yl
init|;
name|k
operator|<
name|yh
condition|;
name|k
operator|++
control|)
for|for
control|(
name|m
operator|=
name|xl
init|;
name|m
operator|<
name|xh
condition|;
name|m
operator|++
control|)
if|if
condition|(
name|screen
index|[
name|m
index|]
index|[
name|k
index|]
operator|==
name|tmp
condition|)
comment|/* if find proximity n advance it */
for|for
control|(
name|z
operator|=
literal|1
init|;
name|z
operator|<
literal|9
condition|;
name|z
operator|++
control|)
comment|/* go around in a circle */
block|{
if|if
condition|(
name|screen
index|[
name|xtmp
operator|=
name|m
operator|+
name|diroffx
index|[
name|z
index|]
index|]
index|[
name|ytmp
operator|=
name|k
operator|+
name|diroffy
index|[
name|z
index|]
index|]
operator|==
literal|0
condition|)
name|screen
index|[
name|xtmp
index|]
index|[
name|ytmp
index|]
operator|=
name|tmp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|xtmp
operator|==
name|i
operator|&&
name|ytmp
operator|==
name|j
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|tmp
operator|<
name|distance
condition|)
comment|/* did find connectivity */
comment|/* now select lowest value around playerx,playery */
for|for
control|(
name|z
operator|=
literal|1
init|;
name|z
operator|<
literal|9
condition|;
name|z
operator|++
control|)
comment|/* go around in a circle */
if|if
condition|(
name|screen
index|[
name|xl
operator|=
name|i
operator|+
name|diroffx
index|[
name|z
index|]
index|]
index|[
name|yl
operator|=
name|j
operator|+
name|diroffy
index|[
name|z
index|]
index|]
operator|==
name|tmp
condition|)
if|if
condition|(
operator|!
name|mitem
index|[
name|xl
index|]
index|[
name|yl
index|]
condition|)
block|{
name|mmove
argument_list|(
name|i
argument_list|,
name|j
argument_list|,
name|w1x
index|[
literal|0
index|]
operator|=
name|xl
argument_list|,
name|w1y
index|[
literal|0
index|]
operator|=
name|yl
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* dumb monsters move here */
name|xl
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|yl
operator|=
name|j
operator|-
literal|1
expr_stmt|;
name|xh
operator|=
name|i
operator|+
literal|2
expr_stmt|;
name|yh
operator|=
name|j
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|playerx
condition|)
name|xl
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|playerx
condition|)
operator|--
name|xh
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|playery
condition|)
name|yl
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|>
name|playery
condition|)
operator|--
name|yh
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|9
condition|;
name|k
operator|++
control|)
name|w1
index|[
name|k
index|]
operator|=
literal|10000
expr_stmt|;
for|for
control|(
name|k
operator|=
name|xl
init|;
name|k
operator|<
name|xh
condition|;
name|k
operator|++
control|)
for|for
control|(
name|m
operator|=
name|yl
init|;
name|m
operator|<
name|yh
condition|;
name|m
operator|++
control|)
comment|/* for each square compute distance to player */
block|{
name|tmp
operator|=
name|k
operator|-
name|i
operator|+
literal|4
operator|+
literal|3
operator|*
operator|(
name|m
operator|-
name|j
operator|)
expr_stmt|;
name|tmpitem
operator|=
name|item
index|[
name|k
index|]
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
name|tmpitem
operator|!=
name|OWALL
operator|||
operator|(
name|k
operator|==
name|playerx
operator|&&
name|m
operator|==
name|playery
operator|)
condition|)
if|if
condition|(
name|mitem
index|[
name|k
index|]
index|[
name|m
index|]
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|mitem
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
name|VAMPIRE
operator|)
operator|||
operator|(
name|tmpitem
operator|!=
name|OMIRROR
operator|)
condition|)
if|if
condition|(
name|tmpitem
operator|!=
name|OCLOSEDDOOR
condition|)
block|{
name|w1
index|[
name|tmp
index|]
operator|=
operator|(
name|playerx
operator|-
name|k
operator|)
operator|*
operator|(
name|playerx
operator|-
name|k
operator|)
operator|+
operator|(
name|playery
operator|-
name|m
operator|)
operator|*
operator|(
name|playery
operator|-
name|m
operator|)
expr_stmt|;
name|w1x
index|[
name|tmp
index|]
operator|=
name|k
expr_stmt|;
name|w1y
index|[
name|tmp
index|]
operator|=
name|m
expr_stmt|;
block|}
block|}
name|tmp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
literal|9
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|w1
index|[
name|tmp
index|]
operator|>
name|w1
index|[
name|k
index|]
condition|)
name|tmp
operator|=
name|k
expr_stmt|;
if|if
condition|(
name|w1
index|[
name|tmp
index|]
operator|<
literal|10000
condition|)
if|if
condition|(
operator|(
name|i
operator|!=
name|w1x
index|[
name|tmp
index|]
operator|)
operator|||
operator|(
name|j
operator|!=
name|w1y
index|[
name|tmp
index|]
operator|)
condition|)
name|mmove
argument_list|(
name|i
argument_list|,
name|j
argument_list|,
name|w1x
index|[
name|tmp
index|]
argument_list|,
name|w1y
index|[
name|tmp
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	mmove(x,y,xd,yd)	Function to actually perform the monster movement  *		int x,y,xd,yd;  *  *	Enter with the from coordinates in (x,y) and the destination coordinates  *	in (xd,yd).  */
end_comment

begin_macro
name|mmove
argument_list|(
argument|aa
argument_list|,
argument|bb
argument_list|,
argument|cc
argument_list|,
argument|dd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|aa
decl_stmt|,
name|bb
decl_stmt|,
name|cc
decl_stmt|,
name|dd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|tmp
decl_stmt|,
name|i
decl_stmt|,
name|flag
decl_stmt|;
name|char
modifier|*
name|who
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
comment|/* set to 1 if monster hit by arrow trap */
if|if
condition|(
operator|(
name|cc
operator|==
name|playerx
operator|)
operator|&&
operator|(
name|dd
operator|==
name|playery
operator|)
condition|)
block|{
name|hitplayer
argument_list|(
name|aa
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|moved
index|[
name|aa
index|]
index|[
name|bb
index|]
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|item
index|[
name|cc
index|]
index|[
name|dd
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
name|OPIT
operator|)
operator|||
operator|(
name|i
operator|==
name|OTRAPDOOR
operator|)
condition|)
switch|switch
condition|(
name|mitem
index|[
name|aa
index|]
index|[
name|bb
index|]
condition|)
block|{
case|case
name|SPIRITNAGA
case|:
case|case
name|PLATINUMDRAGON
case|:
case|case
name|WRAITH
case|:
case|case
name|VAMPIRE
case|:
case|case
name|SILVERDRAGON
case|:
case|case
name|POLTERGEIST
case|:
case|case
name|DEMONLORD
case|:
case|case
name|DEMONLORD
operator|+
literal|1
case|:
case|case
name|DEMONLORD
operator|+
literal|2
case|:
case|case
name|DEMONLORD
operator|+
literal|3
case|:
case|case
name|DEMONLORD
operator|+
literal|4
case|:
case|case
name|DEMONLORD
operator|+
literal|5
case|:
case|case
name|DEMONLORD
operator|+
literal|6
case|:
case|case
name|DEMONPRINCE
case|:
break|break;
default|default:
name|mitem
index|[
name|aa
index|]
index|[
name|bb
index|]
operator|=
literal|0
expr_stmt|;
comment|/* fell in a pit or trapdoor */
block|}
empty_stmt|;
name|tmp
operator|=
name|mitem
index|[
name|cc
index|]
index|[
name|dd
index|]
operator|=
name|mitem
index|[
name|aa
index|]
index|[
name|bb
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|OANNIHILATION
condition|)
block|{
if|if
condition|(
name|tmp
operator|>=
name|DEMONLORD
operator|+
literal|3
condition|)
comment|/* demons dispel spheres */
block|{
name|cursors
argument_list|()
expr_stmt|;
name|lprintf
argument_list|(
literal|"\nThe %s dispels the sphere!"
argument_list|,
name|monster
index|[
name|tmp
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|rmsphere
argument_list|(
name|cc
argument_list|,
name|dd
argument_list|)
expr_stmt|;
comment|/* delete the sphere */
block|}
else|else
name|i
operator|=
name|tmp
operator|=
name|mitem
index|[
name|cc
index|]
index|[
name|dd
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|stealth
index|[
name|cc
index|]
index|[
name|dd
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|hitp
index|[
name|cc
index|]
index|[
name|dd
index|]
operator|=
name|hitp
index|[
name|aa
index|]
index|[
name|bb
index|]
operator|)
operator|<
literal|0
condition|)
name|hitp
index|[
name|cc
index|]
index|[
name|dd
index|]
operator|=
literal|1
expr_stmt|;
name|mitem
index|[
name|aa
index|]
index|[
name|bb
index|]
operator|=
literal|0
expr_stmt|;
name|moved
index|[
name|cc
index|]
index|[
name|dd
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|LEPRECHAUN
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|OGOLDPILE
case|:
case|case
name|OMAXGOLD
case|:
case|case
name|OKGOLD
case|:
case|case
name|ODGOLD
case|:
case|case
name|ODIAMOND
case|:
case|case
name|ORUBY
case|:
case|case
name|OEMERALD
case|:
case|case
name|OSAPPHIRE
case|:
name|item
index|[
name|cc
index|]
index|[
name|dd
index|]
operator|=
literal|0
expr_stmt|;
comment|/* leprechaun takes gold */
block|}
empty_stmt|;
if|if
condition|(
name|tmp
operator|==
name|TROLL
condition|)
comment|/* if a troll regenerate him */
if|if
condition|(
operator|(
name|gtime
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|monster
index|[
name|tmp
index|]
operator|.
name|hitpoints
operator|>
name|hitp
index|[
name|cc
index|]
index|[
name|dd
index|]
condition|)
name|hitp
index|[
name|cc
index|]
index|[
name|dd
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|OTRAPARROW
condition|)
comment|/* arrow hits monster */
block|{
name|who
operator|=
literal|"An arrow"
expr_stmt|;
if|if
condition|(
operator|(
name|hitp
index|[
name|cc
index|]
index|[
name|dd
index|]
operator|-=
name|rnd
argument_list|(
literal|10
argument_list|)
operator|+
name|level
operator|)
operator|<=
literal|0
condition|)
block|{
name|mitem
index|[
name|cc
index|]
index|[
name|dd
index|]
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|flag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|ODARTRAP
condition|)
comment|/* dart hits monster */
block|{
name|who
operator|=
literal|"A dart"
expr_stmt|;
if|if
condition|(
operator|(
name|hitp
index|[
name|cc
index|]
index|[
name|dd
index|]
operator|-=
name|rnd
argument_list|(
literal|6
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|mitem
index|[
name|cc
index|]
index|[
name|dd
index|]
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|flag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|OTELEPORTER
condition|)
comment|/* monster hits teleport trap */
block|{
name|flag
operator|=
literal|3
expr_stmt|;
name|fillmonst
argument_list|(
name|mitem
index|[
name|cc
index|]
index|[
name|dd
index|]
argument_list|)
expr_stmt|;
name|mitem
index|[
name|cc
index|]
index|[
name|dd
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
index|[
name|BLINDCOUNT
index|]
condition|)
return|return;
comment|/* if blind don't show where monsters are	*/
if|if
condition|(
name|know
index|[
name|cc
index|]
index|[
name|dd
index|]
operator|&
literal|1
condition|)
block|{
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag
condition|)
name|cursors
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
literal|1
case|:
name|p
operator|=
literal|"\n%s hits the %s"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|p
operator|=
literal|"\n%s hits and kills the %s"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|p
operator|=
literal|"\nThe %s%s gets teleported"
expr_stmt|;
name|who
operator|=
literal|""
expr_stmt|;
break|break;
block|}
empty_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|lprintf
argument_list|(
name|p
argument_list|,
name|who
argument_list|,
name|monster
index|[
name|tmp
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*	if (yrepcount>1) { know[aa][bb]&= 2;  know[cc][dd]&= 2; return; } */
if|if
condition|(
name|know
index|[
name|aa
index|]
index|[
name|bb
index|]
operator|&
literal|1
condition|)
name|show1cell
argument_list|(
name|aa
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|know
index|[
name|cc
index|]
index|[
name|dd
index|]
operator|&
literal|1
condition|)
name|show1cell
argument_list|(
name|cc
argument_list|,
name|dd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	movsphere() 	Function to look for and move spheres of annihilation  *  *	This function works on the sphere linked list, first duplicating the list  *	(the act of moving changes the list), then processing each sphere in order  *	to move it.  They eat anything in their way, including stairs, volcanic  *	shafts, potions, etc, except for upper level demons, who can dispel  *	spheres.  *	No value is returned.  */
end_comment

begin_define
define|#
directive|define
name|SPHMAX
value|20
end_define

begin_comment
comment|/* maximum number of spheres movsphere can handle */
end_comment

begin_macro
name|movsphere
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|dir
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|struct
name|sphere
modifier|*
name|sp
decl_stmt|,
modifier|*
name|sp2
decl_stmt|;
name|struct
name|sphere
name|sph
index|[
name|SPHMAX
index|]
decl_stmt|;
comment|/* first duplicate sphere list */
for|for
control|(
name|sp
operator|=
literal|0
operator|,
name|x
operator|=
literal|0
operator|,
name|sp2
operator|=
name|spheres
init|;
name|sp2
condition|;
name|sp2
operator|=
name|sp2
operator|->
name|p
control|)
comment|/* look through sphere list */
if|if
condition|(
name|sp2
operator|->
name|lev
operator|==
name|level
condition|)
comment|/* only if this level */
block|{
name|sph
index|[
name|x
index|]
operator|=
operator|*
name|sp2
expr_stmt|;
name|sph
index|[
name|x
operator|++
index|]
operator|.
name|p
operator|=
literal|0
expr_stmt|;
comment|/* copy the struct */
if|if
condition|(
name|x
operator|>
literal|1
condition|)
name|sph
index|[
name|x
operator|-
literal|2
index|]
operator|.
name|p
operator|=
operator|&
name|sph
index|[
name|x
operator|-
literal|1
index|]
expr_stmt|;
comment|/* link pointers */
block|}
if|if
condition|(
name|x
condition|)
name|sp
operator|=
name|sph
expr_stmt|;
comment|/* if any spheres, point to them */
else|else
return|return;
comment|/* no spheres */
for|for
control|(
name|sp
operator|=
name|sph
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|p
control|)
comment|/* look through sphere list */
block|{
name|x
operator|=
name|sp
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|sp
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|item
index|[
name|x
index|]
index|[
name|y
index|]
operator|!=
name|OANNIHILATION
condition|)
continue|continue;
comment|/* not really there */
if|if
condition|(
operator|--
operator|(
name|sp
operator|->
name|lifetime
operator|)
operator|<
literal|0
condition|)
comment|/* has sphere run out of gas? */
block|{
name|rmsphere
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* delete sphere */
continue|continue;
block|}
switch|switch
condition|(
name|rnd
argument_list|(
operator|(
name|int
operator|)
name|max
argument_list|(
literal|7
argument_list|,
name|c
index|[
name|INTELLIGENCE
index|]
operator|>>
literal|1
argument_list|)
argument_list|)
condition|)
comment|/* time to move the sphere */
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
comment|/* change direction to a random one */
name|sp
operator|->
name|dir
operator|=
name|rnd
argument_list|(
literal|8
argument_list|)
expr_stmt|;
default|default:
comment|/* move in normal direction */
name|dir
operator|=
name|sp
operator|->
name|dir
expr_stmt|;
name|len
operator|=
name|sp
operator|->
name|lifetime
expr_stmt|;
name|rmsphere
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|newsphere
argument_list|(
name|x
operator|+
name|diroffx
index|[
name|dir
index|]
argument_list|,
name|y
operator|+
name|diroffy
index|[
name|dir
index|]
argument_list|,
name|dir
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
end_block

end_unit

