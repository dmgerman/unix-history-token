begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)canfield.c	8.1 (Berkeley) 5/31/93";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * The canfield program  *  * Authors:  *	Originally written: Steve Levine  *	Converted to use curses and debugged: Steve Feldman  *	Card counting: Kirk McKusick and Mikey Olson  *	User interface cleanups: Eric Allman and Kirk McKusick  *	Betting by Kirk McKusick  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_define
define|#
directive|define
name|decksize
value|52
end_define

begin_define
define|#
directive|define
name|originrow
value|0
end_define

begin_define
define|#
directive|define
name|origincol
value|0
end_define

begin_define
define|#
directive|define
name|basecol
value|1
end_define

begin_define
define|#
directive|define
name|boxcol
value|42
end_define

begin_define
define|#
directive|define
name|tboxrow
value|2
end_define

begin_define
define|#
directive|define
name|bboxrow
value|17
end_define

begin_define
define|#
directive|define
name|movecol
value|43
end_define

begin_define
define|#
directive|define
name|moverow
value|16
end_define

begin_define
define|#
directive|define
name|msgcol
value|43
end_define

begin_define
define|#
directive|define
name|msgrow
value|15
end_define

begin_define
define|#
directive|define
name|titlecol
value|30
end_define

begin_define
define|#
directive|define
name|titlerow
value|0
end_define

begin_define
define|#
directive|define
name|sidecol
value|1
end_define

begin_define
define|#
directive|define
name|ottlrow
value|6
end_define

begin_define
define|#
directive|define
name|foundcol
value|11
end_define

begin_define
define|#
directive|define
name|foundrow
value|3
end_define

begin_define
define|#
directive|define
name|stockcol
value|2
end_define

begin_define
define|#
directive|define
name|stockrow
value|8
end_define

begin_define
define|#
directive|define
name|fttlcol
value|10
end_define

begin_define
define|#
directive|define
name|fttlrow
value|1
end_define

begin_define
define|#
directive|define
name|taloncol
value|2
end_define

begin_define
define|#
directive|define
name|talonrow
value|13
end_define

begin_define
define|#
directive|define
name|tabrow
value|8
end_define

begin_define
define|#
directive|define
name|ctoprow
value|21
end_define

begin_define
define|#
directive|define
name|cbotrow
value|23
end_define

begin_define
define|#
directive|define
name|cinitcol
value|14
end_define

begin_define
define|#
directive|define
name|cheightcol
value|1
end_define

begin_define
define|#
directive|define
name|cwidthcol
value|4
end_define

begin_define
define|#
directive|define
name|handstatrow
value|21
end_define

begin_define
define|#
directive|define
name|handstatcol
value|7
end_define

begin_define
define|#
directive|define
name|talonstatrow
value|22
end_define

begin_define
define|#
directive|define
name|talonstatcol
value|7
end_define

begin_define
define|#
directive|define
name|stockstatrow
value|23
end_define

begin_define
define|#
directive|define
name|stockstatcol
value|7
end_define

begin_define
define|#
directive|define
name|Ace
value|1
end_define

begin_define
define|#
directive|define
name|Jack
value|11
end_define

begin_define
define|#
directive|define
name|Queen
value|12
end_define

begin_define
define|#
directive|define
name|King
value|13
end_define

begin_define
define|#
directive|define
name|atabcol
value|11
end_define

begin_define
define|#
directive|define
name|btabcol
value|18
end_define

begin_define
define|#
directive|define
name|ctabcol
value|25
end_define

begin_define
define|#
directive|define
name|dtabcol
value|32
end_define

begin_define
define|#
directive|define
name|spades
value|'s'
end_define

begin_define
define|#
directive|define
name|clubs
value|'c'
end_define

begin_define
define|#
directive|define
name|hearts
value|'h'
end_define

begin_define
define|#
directive|define
name|diamonds
value|'d'
end_define

begin_define
define|#
directive|define
name|black
value|'b'
end_define

begin_define
define|#
directive|define
name|red
value|'r'
end_define

begin_define
define|#
directive|define
name|stk
value|1
end_define

begin_define
define|#
directive|define
name|tal
value|2
end_define

begin_define
define|#
directive|define
name|tab
value|3
end_define

begin_define
define|#
directive|define
name|INCRHAND
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
value|{\ 	row -= cheightcol;\ 	if (row< ctoprow) {\ 		row = cbotrow;\ 		col += cwidthcol;\ 	}\ }
end_define

begin_define
define|#
directive|define
name|DECRHAND
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
value|{\ 	row += cheightcol;\ 	if (row> cbotrow) {\ 		row = ctoprow;\ 		col -= cwidthcol;\ 	}\ }
end_define

begin_struct
struct|struct
name|cardtype
block|{
name|char
name|suit
decl_stmt|;
name|char
name|color
decl_stmt|;
name|bool
name|visible
decl_stmt|;
name|bool
name|paid
decl_stmt|;
name|int
name|rank
decl_stmt|;
name|struct
name|cardtype
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NIL
value|((struct cardtype *) -1)
end_define

begin_decl_stmt
name|struct
name|cardtype
modifier|*
name|deck
index|[
name|decksize
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cardtype
name|cards
index|[
name|decksize
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cardtype
modifier|*
name|bottom
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|found
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|tableau
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cardtype
modifier|*
name|talon
decl_stmt|,
modifier|*
name|hand
decl_stmt|,
modifier|*
name|stock
decl_stmt|,
modifier|*
name|basecard
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cardsoff
decl_stmt|,
name|base
decl_stmt|,
name|cinhand
decl_stmt|,
name|taloncnt
decl_stmt|,
name|stockcnt
decl_stmt|,
name|timesthru
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|suitmap
index|[
literal|4
index|]
init|=
block|{
name|spades
block|,
name|clubs
block|,
name|hearts
block|,
name|diamonds
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|colormap
index|[
literal|4
index|]
init|=
block|{
name|black
block|,
name|black
block|,
name|red
block|,
name|red
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|pilemap
index|[
literal|4
index|]
init|=
block|{
name|atabcol
block|,
name|btabcol
block|,
name|ctabcol
block|,
name|dtabcol
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|srcpile
decl_stmt|,
name|destpile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mtforigin
decl_stmt|,
name|tempbase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|coldcol
decl_stmt|,
name|cnewcol
decl_stmt|,
name|coldrow
decl_stmt|,
name|cnewrow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|errmsg
decl_stmt|,
name|done
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|mtfdone
decl_stmt|,
name|Cflag
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSTRUCTIONBOX
value|1
end_define

begin_define
define|#
directive|define
name|BETTINGBOX
value|2
end_define

begin_define
define|#
directive|define
name|NOBOX
value|3
end_define

begin_decl_stmt
name|int
name|status
init|=
name|INSTRUCTIONBOX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Basic betting costs  */
end_comment

begin_define
define|#
directive|define
name|costofhand
value|13
end_define

begin_define
define|#
directive|define
name|costofinspection
value|13
end_define

begin_define
define|#
directive|define
name|costofgame
value|26
end_define

begin_define
define|#
directive|define
name|costofrunthroughhand
value|5
end_define

begin_define
define|#
directive|define
name|costofinformation
value|1
end_define

begin_define
define|#
directive|define
name|secondsperdollar
value|60
end_define

begin_define
define|#
directive|define
name|maxtimecharge
value|3
end_define

begin_define
define|#
directive|define
name|valuepercardup
value|5
end_define

begin_comment
comment|/*  * Variables associated with betting  */
end_comment

begin_struct
struct|struct
name|betinfo
block|{
name|long
name|hand
decl_stmt|;
comment|/* cost of dealing hand */
name|long
name|inspection
decl_stmt|;
comment|/* cost of inspecting hand */
name|long
name|game
decl_stmt|;
comment|/* cost of buying game */
name|long
name|runs
decl_stmt|;
comment|/* cost of running through hands */
name|long
name|information
decl_stmt|;
comment|/* cost of information */
name|long
name|thinktime
decl_stmt|;
comment|/* cost of thinking time */
name|long
name|wins
decl_stmt|;
comment|/* total winnings */
name|long
name|worth
decl_stmt|;
comment|/* net worth after costs */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|betinfo
name|this
decl_stmt|,
name|game
decl_stmt|,
name|total
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|startedgame
init|=
name|FALSE
decl_stmt|,
name|infullgame
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|acctstart
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dbfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|askquit
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|cleanup
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|cleanupboard
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|clearabovemovebox
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|clearbelowmovebox
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|clearmsg
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|clearstat
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|destinerror
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|diffcolor
name|__P
argument_list|(
operator|(
expr|struct
name|cardtype
operator|*
operator|,
expr|struct
name|cardtype
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dumberror
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|finish
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fndbase
name|__P
argument_list|(
operator|(
expr|struct
name|cardtype
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|getcmd
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|initall
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|initdeck
name|__P
argument_list|(
operator|(
expr|struct
name|cardtype
operator|*
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|initgame
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|instruct
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|makeboard
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|movebox
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|movecard
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|movetofound
name|__P
argument_list|(
operator|(
expr|struct
name|cardtype
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|movetotalon
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|notempty
name|__P
argument_list|(
operator|(
expr|struct
name|cardtype
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|printbottombettingbox
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|printbottominstructions
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|printcard
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|cardtype
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|printrank
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|cardtype
operator|*
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|printtopbettingbox
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|printtopinstructions
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|rankhigher
name|__P
argument_list|(
operator|(
expr|struct
name|cardtype
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|ranklower
name|__P
argument_list|(
operator|(
expr|struct
name|cardtype
operator|*
operator|,
expr|struct
name|cardtype
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|removecard
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|samesuit
name|__P
argument_list|(
operator|(
expr|struct
name|cardtype
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|showcards
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|showstat
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|shuffle
name|__P
argument_list|(
operator|(
expr|struct
name|cardtype
operator|*
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|simpletableau
name|__P
argument_list|(
operator|(
expr|struct
name|cardtype
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|startgame
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|suspend
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|tabok
name|__P
argument_list|(
operator|(
expr|struct
name|cardtype
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|tabprint
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|tabtotab
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|transit
name|__P
argument_list|(
operator|(
expr|struct
name|cardtype
operator|*
operator|*
operator|,
expr|struct
name|cardtype
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|updatebettinginfo
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|usedstock
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|usedtalon
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following procedures print the board onto the screen using the  * addressible cursor. The end of these procedures will also be  * separated from the rest of the program.  *  * procedure to set the move command box  */
end_comment

begin_function
name|void
name|movebox
parameter_list|()
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|BETTINGBOX
case|:
name|printtopbettingbox
argument_list|()
expr_stmt|;
break|break;
case|case
name|NOBOX
case|:
name|clearabovemovebox
argument_list|()
expr_stmt|;
break|break;
case|case
name|INSTRUCTIONBOX
case|:
name|printtopinstructions
argument_list|()
expr_stmt|;
break|break;
block|}
name|move
argument_list|(
name|moverow
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|                                  |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|msgrow
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|                                  |"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|BETTINGBOX
case|:
name|printbottombettingbox
argument_list|()
expr_stmt|;
break|break;
case|case
name|NOBOX
case|:
name|clearbelowmovebox
argument_list|()
expr_stmt|;
break|break;
case|case
name|INSTRUCTIONBOX
case|:
name|printbottominstructions
argument_list|()
expr_stmt|;
break|break;
block|}
name|refresh
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print directions above move box  */
end_comment

begin_function
name|void
name|printtopinstructions
parameter_list|()
block|{
name|move
argument_list|(
name|tboxrow
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"*----------------------------------*"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|1
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|         MOVES                    |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|2
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|s# = stock to tableau             |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|3
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|sf = stock to foundation          |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|4
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|t# = talon to tableau             |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|5
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|tf = talon to foundation          |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|6
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|## = tableau to tableau           |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|7
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|#f = tableau to foundation        |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|8
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|ht = hand to talon                |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|9
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|c = toggle card counting          |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|10
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|b = present betting information   |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|11
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|q = quit to end the game          |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|12
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|==================================|"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print the betting box.  */
end_comment

begin_function
name|void
name|printtopbettingbox
parameter_list|()
block|{
name|move
argument_list|(
name|tboxrow
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"*----------------------------------*"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|1
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|Costs        Hand   Game    Total |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|2
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"| Hands                            |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|3
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"| Inspections                      |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|4
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"| Games                            |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|5
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"| Runs                             |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|6
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"| Information                      |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|7
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"| Think time                       |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|8
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|Total Costs                       |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|9
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|Winnings                          |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|10
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|Net Worth                         |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|11
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|Return                            |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|12
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|==================================|"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clear info above move box  */
end_comment

begin_function
name|void
name|clearabovemovebox
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|11
condition|;
name|i
operator|++
control|)
block|{
name|move
argument_list|(
name|tboxrow
operator|+
name|i
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"                                    "
argument_list|)
expr_stmt|;
block|}
name|move
argument_list|(
name|tboxrow
operator|+
literal|12
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"*----------------------------------*"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print instructions below move box  */
end_comment

begin_function
name|void
name|printbottominstructions
parameter_list|()
block|{
name|move
argument_list|(
name|bboxrow
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|Replace # with the number of the  |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|bboxrow
operator|+
literal|1
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|tableau you want.                 |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|bboxrow
operator|+
literal|2
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"*----------------------------------*"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print betting information below move box  */
end_comment

begin_function
name|void
name|printbottombettingbox
parameter_list|()
block|{
name|move
argument_list|(
name|bboxrow
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|x = toggle information box        |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|bboxrow
operator|+
literal|1
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|i = list playing instructions     |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|bboxrow
operator|+
literal|2
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"*----------------------------------*"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clear info below move box  */
end_comment

begin_function
name|void
name|clearbelowmovebox
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|move
argument_list|(
name|bboxrow
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"*----------------------------------*"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|move
argument_list|(
name|bboxrow
operator|+
name|i
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"                                    "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * procedure to put the board on the screen using addressable cursor  */
end_comment

begin_function
name|void
name|makeboard
parameter_list|()
block|{
name|clear
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|titlerow
argument_list|,
name|titlecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=-> CANFIELD<-="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|fttlrow
argument_list|,
name|fttlcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"foundation"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|foundrow
operator|-
literal|1
argument_list|,
name|fttlcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---=  =---=  =---=  =---="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|foundrow
argument_list|,
name|fttlcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|   |  |   |  |   |  |   |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|foundrow
operator|+
literal|1
argument_list|,
name|fttlcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---=  =---=  =---=  =---="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|ottlrow
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"stock     tableau"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|stockrow
operator|-
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|stockrow
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|   |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|stockrow
operator|+
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|-
literal|2
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"talon"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|-
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|   |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|+
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tabrow
operator|-
literal|1
argument_list|,
name|atabcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"-1-    -2-    -3-    -4-"
argument_list|)
expr_stmt|;
name|movebox
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clean up the board for another game  */
end_comment

begin_function
name|void
name|cleanupboard
parameter_list|()
block|{
name|int
name|cnt
decl_stmt|,
name|row
decl_stmt|,
name|col
decl_stmt|;
name|struct
name|cardtype
modifier|*
name|ptr
decl_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
block|{
name|clearstat
argument_list|()
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|stock
operator|,
name|row
operator|=
name|stockrow
init|;
name|ptr
operator|!=
name|NIL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
operator|,
name|row
operator|++
control|)
block|{
name|move
argument_list|(
name|row
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
block|}
name|move
argument_list|(
name|row
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|stockrow
operator|+
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|-
literal|2
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"talon"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|-
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|+
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---="
argument_list|)
expr_stmt|;
block|}
name|move
argument_list|(
name|stockrow
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|   |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|   |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|foundrow
argument_list|,
name|fttlcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|   |  |   |  |   |  |   |"
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|4
condition|;
name|cnt
operator|++
control|)
block|{
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
literal|0
case|:
name|col
operator|=
name|atabcol
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|col
operator|=
name|btabcol
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|col
operator|=
name|ctabcol
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|col
operator|=
name|dtabcol
expr_stmt|;
break|break;
block|}
for|for
control|(
name|ptr
operator|=
name|tableau
index|[
name|cnt
index|]
operator|,
name|row
operator|=
name|tabrow
init|;
name|ptr
operator|!=
name|NIL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
operator|,
name|row
operator|++
control|)
name|removecard
argument_list|(
name|col
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * procedure to create a deck of cards  */
end_comment

begin_function
name|void
name|initdeck
parameter_list|(
name|deck
parameter_list|)
name|struct
name|cardtype
modifier|*
name|deck
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|scnt
decl_stmt|;
name|char
name|s
decl_stmt|;
name|int
name|r
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|scnt
operator|=
literal|0
init|;
name|scnt
operator|<
literal|4
condition|;
name|scnt
operator|++
control|)
block|{
name|s
operator|=
name|suitmap
index|[
name|scnt
index|]
expr_stmt|;
for|for
control|(
name|r
operator|=
name|Ace
init|;
name|r
operator|<=
name|King
condition|;
name|r
operator|++
control|)
block|{
name|deck
index|[
name|i
index|]
operator|=
operator|&
name|cards
index|[
name|i
index|]
expr_stmt|;
name|cards
index|[
name|i
index|]
operator|.
name|rank
operator|=
name|r
expr_stmt|;
name|cards
index|[
name|i
index|]
operator|.
name|suit
operator|=
name|s
expr_stmt|;
name|cards
index|[
name|i
index|]
operator|.
name|color
operator|=
name|colormap
index|[
name|scnt
index|]
expr_stmt|;
name|cards
index|[
name|i
index|]
operator|.
name|next
operator|=
name|NIL
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * procedure to shuffle the deck  */
end_comment

begin_function
name|void
name|shuffle
parameter_list|(
name|deck
parameter_list|)
name|struct
name|cardtype
modifier|*
name|deck
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|cardtype
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|decksize
condition|;
name|i
operator|++
control|)
block|{
name|deck
index|[
name|i
index|]
operator|->
name|visible
operator|=
name|FALSE
expr_stmt|;
name|deck
index|[
name|i
index|]
operator|->
name|paid
operator|=
name|FALSE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|decksize
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|j
operator|=
name|random
argument_list|()
operator|%
name|decksize
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|j
condition|)
block|{
name|temp
operator|=
name|deck
index|[
name|i
index|]
expr_stmt|;
name|deck
index|[
name|i
index|]
operator|=
name|deck
index|[
name|j
index|]
expr_stmt|;
name|deck
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * procedure to remove the card from the board  */
end_comment

begin_function
name|void
name|removecard
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
block|{
name|move
argument_list|(
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * procedure to print the cards on the board  */
end_comment

begin_function
name|void
name|printrank
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|cp
parameter_list|,
name|inverse
parameter_list|)
name|struct
name|cardtype
modifier|*
name|cp
decl_stmt|;
name|bool
name|inverse
decl_stmt|;
block|{
name|move
argument_list|(
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|rank
operator|!=
literal|10
condition|)
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|inverse
condition|)
name|standout
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|rank
condition|)
block|{
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
case|case
literal|8
case|:
case|case
literal|9
case|:
case|case
literal|10
case|:
name|printw
argument_list|(
literal|"%d"
argument_list|,
name|cp
operator|->
name|rank
argument_list|)
expr_stmt|;
break|break;
case|case
name|Ace
case|:
name|addch
argument_list|(
literal|'A'
argument_list|)
expr_stmt|;
break|break;
case|case
name|Jack
case|:
name|addch
argument_list|(
literal|'J'
argument_list|)
expr_stmt|;
break|break;
case|case
name|Queen
case|:
name|addch
argument_list|(
literal|'Q'
argument_list|)
expr_stmt|;
break|break;
case|case
name|King
case|:
name|addch
argument_list|(
literal|'K'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inverse
condition|)
name|standend
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * procedure to print out a card  */
end_comment

begin_function
name|void
name|printcard
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|cp
parameter_list|)
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
name|struct
name|cardtype
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
name|cp
operator|==
name|NIL
condition|)
name|removecard
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|->
name|visible
operator|==
name|FALSE
condition|)
block|{
name|move
argument_list|(
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|" ? "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|inverse
init|=
operator|(
name|cp
operator|->
name|suit
operator|==
literal|'d'
operator|||
name|cp
operator|->
name|suit
operator|==
literal|'h'
operator|)
decl_stmt|;
name|printrank
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|cp
argument_list|,
name|inverse
argument_list|)
expr_stmt|;
if|if
condition|(
name|inverse
condition|)
name|standout
argument_list|()
expr_stmt|;
name|addch
argument_list|(
name|cp
operator|->
name|suit
argument_list|)
expr_stmt|;
if|if
condition|(
name|inverse
condition|)
name|standend
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * procedure to move the top card from one location to the top  * of another location. The pointers always point to the top  * of the piles.  */
end_comment

begin_function
name|void
name|transit
parameter_list|(
name|source
parameter_list|,
name|dest
parameter_list|)
name|struct
name|cardtype
modifier|*
modifier|*
name|source
decl_stmt|,
decl|*
modifier|*
name|dest
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|cardtype
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|*
name|source
expr_stmt|;
operator|*
name|source
operator|=
operator|(
operator|*
name|source
operator|)
operator|->
name|next
expr_stmt|;
name|temp
operator|->
name|next
operator|=
operator|*
name|dest
expr_stmt|;
operator|*
name|dest
operator|=
name|temp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Procedure to set the cards on the foundation base when available.  * Note that it is only called on a foundation pile at the beginning of  * the game, so the pile will have exactly one card in it.  */
end_comment

begin_function
name|void
name|fndbase
parameter_list|(
name|cp
parameter_list|,
name|column
parameter_list|,
name|row
parameter_list|)
name|struct
name|cardtype
modifier|*
modifier|*
name|cp
decl_stmt|;
block|{
name|bool
name|nomore
decl_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
name|NIL
condition|)
do|do
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|)
operator|->
name|rank
operator|==
name|basecard
operator|->
name|rank
condition|)
block|{
name|base
operator|++
expr_stmt|;
name|printcard
argument_list|(
name|pilemap
index|[
name|base
index|]
argument_list|,
name|foundrow
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
name|tableau
index|[
literal|0
index|]
condition|)
name|length
index|[
literal|0
index|]
operator|=
name|length
index|[
literal|0
index|]
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
name|tableau
index|[
literal|1
index|]
condition|)
name|length
index|[
literal|1
index|]
operator|=
name|length
index|[
literal|1
index|]
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
name|tableau
index|[
literal|2
index|]
condition|)
name|length
index|[
literal|2
index|]
operator|=
name|length
index|[
literal|2
index|]
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
name|tableau
index|[
literal|3
index|]
condition|)
name|length
index|[
literal|3
index|]
operator|=
name|length
index|[
literal|3
index|]
operator|-
literal|1
expr_stmt|;
name|transit
argument_list|(
name|cp
argument_list|,
operator|&
name|found
index|[
name|base
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|&
name|talon
condition|)
name|usedtalon
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|&
name|stock
condition|)
name|usedstock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
name|NIL
condition|)
block|{
name|printcard
argument_list|(
name|column
argument_list|,
name|row
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|nomore
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|removecard
argument_list|(
name|column
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|nomore
operator|=
name|TRUE
expr_stmt|;
block|}
name|cardsoff
operator|++
expr_stmt|;
if|if
condition|(
name|infullgame
condition|)
block|{
name|this
operator|.
name|wins
operator|+=
name|valuepercardup
expr_stmt|;
name|game
operator|.
name|wins
operator|+=
name|valuepercardup
expr_stmt|;
name|total
operator|.
name|wins
operator|+=
name|valuepercardup
expr_stmt|;
block|}
block|}
else|else
name|nomore
operator|=
name|TRUE
expr_stmt|;
block|}
do|while
condition|(
name|nomore
operator|==
name|FALSE
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * procedure to initialize the things necessary for the game  */
end_comment

begin_function
name|void
name|initgame
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
block|{
name|deck
index|[
name|i
index|]
operator|->
name|visible
operator|=
name|TRUE
expr_stmt|;
name|deck
index|[
name|i
index|]
operator|->
name|paid
operator|=
name|TRUE
expr_stmt|;
block|}
name|stockcnt
operator|=
literal|13
expr_stmt|;
name|stock
operator|=
name|deck
index|[
literal|12
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|12
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
name|deck
index|[
name|i
index|]
operator|->
name|next
operator|=
name|deck
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|deck
index|[
literal|0
index|]
operator|->
name|next
operator|=
name|NIL
expr_stmt|;
name|found
index|[
literal|0
index|]
operator|=
name|deck
index|[
literal|13
index|]
expr_stmt|;
name|deck
index|[
literal|13
index|]
operator|->
name|next
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|found
index|[
name|i
index|]
operator|=
name|NIL
expr_stmt|;
name|basecard
operator|=
name|found
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|14
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
block|{
name|tableau
index|[
name|i
operator|-
literal|14
index|]
operator|=
name|deck
index|[
name|i
index|]
expr_stmt|;
name|deck
index|[
name|i
index|]
operator|->
name|next
operator|=
name|NIL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|bottom
index|[
name|i
index|]
operator|=
name|tableau
index|[
name|i
index|]
expr_stmt|;
name|length
index|[
name|i
index|]
operator|=
name|tabrow
expr_stmt|;
block|}
name|hand
operator|=
name|deck
index|[
literal|18
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|18
init|;
name|i
operator|<
name|decksize
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|deck
index|[
name|i
index|]
operator|->
name|next
operator|=
name|deck
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|deck
index|[
name|decksize
operator|-
literal|1
index|]
operator|->
name|next
operator|=
name|NIL
expr_stmt|;
name|talon
operator|=
name|NIL
expr_stmt|;
name|base
operator|=
literal|0
expr_stmt|;
name|cinhand
operator|=
literal|34
expr_stmt|;
name|taloncnt
operator|=
literal|0
expr_stmt|;
name|timesthru
operator|=
literal|0
expr_stmt|;
name|cardsoff
operator|=
literal|1
expr_stmt|;
name|coldrow
operator|=
name|ctoprow
expr_stmt|;
name|coldcol
operator|=
name|cinitcol
expr_stmt|;
name|cnewrow
operator|=
name|ctoprow
expr_stmt|;
name|cnewcol
operator|=
name|cinitcol
operator|+
name|cwidthcol
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * procedure to print the beginning cards and to start each game  */
end_comment

begin_function
name|void
name|startgame
parameter_list|()
block|{
name|int
name|j
decl_stmt|;
name|shuffle
argument_list|(
name|deck
argument_list|)
expr_stmt|;
name|initgame
argument_list|()
expr_stmt|;
name|this
operator|.
name|hand
operator|=
name|costofhand
expr_stmt|;
name|game
operator|.
name|hand
operator|+=
name|costofhand
expr_stmt|;
name|total
operator|.
name|hand
operator|+=
name|costofhand
expr_stmt|;
name|this
operator|.
name|inspection
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|game
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|runs
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|information
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|wins
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|thinktime
operator|=
literal|0
expr_stmt|;
name|infullgame
operator|=
name|FALSE
expr_stmt|;
name|startedgame
operator|=
name|FALSE
expr_stmt|;
name|printcard
argument_list|(
name|foundcol
argument_list|,
name|foundrow
argument_list|,
name|found
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|stockcol
argument_list|,
name|stockrow
argument_list|,
name|stock
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|atabcol
argument_list|,
name|tabrow
argument_list|,
name|tableau
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|btabcol
argument_list|,
name|tabrow
argument_list|,
name|tableau
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|ctabcol
argument_list|,
name|tabrow
argument_list|,
name|tableau
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|dtabcol
argument_list|,
name|tabrow
argument_list|,
name|tableau
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|taloncol
argument_list|,
name|talonrow
argument_list|,
name|talon
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|foundrow
operator|-
literal|2
argument_list|,
name|basecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Base"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|foundrow
operator|-
literal|1
argument_list|,
name|basecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Rank"
argument_list|)
expr_stmt|;
name|printrank
argument_list|(
name|basecol
argument_list|,
name|foundrow
argument_list|,
name|found
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|3
condition|;
name|j
operator|++
control|)
name|fndbase
argument_list|(
operator|&
name|tableau
index|[
name|j
index|]
argument_list|,
name|pilemap
index|[
name|j
index|]
argument_list|,
name|tabrow
argument_list|)
expr_stmt|;
name|fndbase
argument_list|(
operator|&
name|stock
argument_list|,
name|stockcol
argument_list|,
name|stockrow
argument_list|)
expr_stmt|;
name|showstat
argument_list|()
expr_stmt|;
comment|/* show card counting info to cheaters */
name|movetotalon
argument_list|()
expr_stmt|;
name|updatebettinginfo
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * procedure to clear the message printed from an error  */
end_comment

begin_function
name|void
name|clearmsg
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|errmsg
operator|==
name|TRUE
condition|)
block|{
name|errmsg
operator|=
name|FALSE
expr_stmt|;
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * procedure to print an error message if the move is not listed  */
end_comment

begin_function
name|void
name|dumberror
parameter_list|()
block|{
name|errmsg
operator|=
name|TRUE
expr_stmt|;
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Not a proper move       "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * procedure to print an error message if the move is not possible  */
end_comment

begin_function
name|void
name|destinerror
parameter_list|()
block|{
name|errmsg
operator|=
name|TRUE
expr_stmt|;
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Error: Can't move there"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * function to see if the source has cards in it  */
end_comment

begin_function
name|bool
name|notempty
parameter_list|(
name|cp
parameter_list|)
name|struct
name|cardtype
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
name|cp
operator|==
name|NIL
condition|)
block|{
name|errmsg
operator|=
name|TRUE
expr_stmt|;
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Error: no cards to move"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * function to see if the rank of one card is less than another  */
end_comment

begin_function
name|bool
name|ranklower
parameter_list|(
name|cp1
parameter_list|,
name|cp2
parameter_list|)
name|struct
name|cardtype
modifier|*
name|cp1
decl_stmt|,
decl|*
name|cp2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|cp2
operator|->
name|rank
operator|==
name|Ace
condition|)
if|if
condition|(
name|cp1
operator|->
name|rank
operator|==
name|King
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
elseif|else
if|if
condition|(
name|cp1
operator|->
name|rank
operator|+
literal|1
operator|==
name|cp2
operator|->
name|rank
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * function to check the cardcolor for moving to a tableau  */
end_comment

begin_function
name|bool
name|diffcolor
parameter_list|(
name|cp1
parameter_list|,
name|cp2
parameter_list|)
name|struct
name|cardtype
modifier|*
name|cp1
decl_stmt|,
decl|*
name|cp2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|cp1
operator|->
name|color
operator|==
name|cp2
operator|->
name|color
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
else|else
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * function to see if the card can move to the tableau  */
end_comment

begin_function
name|bool
name|tabok
parameter_list|(
name|cp
parameter_list|,
name|des
parameter_list|)
name|struct
name|cardtype
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|cp
operator|==
name|stock
operator|)
operator|&&
operator|(
name|tableau
index|[
name|des
index|]
operator|==
name|NIL
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
elseif|else
if|if
condition|(
name|tableau
index|[
name|des
index|]
operator|==
name|NIL
condition|)
if|if
condition|(
name|stock
operator|==
name|NIL
operator|&&
name|cp
operator|!=
name|bottom
index|[
literal|0
index|]
operator|&&
name|cp
operator|!=
name|bottom
index|[
literal|1
index|]
operator|&&
name|cp
operator|!=
name|bottom
index|[
literal|2
index|]
operator|&&
name|cp
operator|!=
name|bottom
index|[
literal|3
index|]
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
elseif|else
if|if
condition|(
name|ranklower
argument_list|(
name|cp
argument_list|,
name|tableau
index|[
name|des
index|]
argument_list|)
operator|&&
name|diffcolor
argument_list|(
name|cp
argument_list|,
name|tableau
index|[
name|des
index|]
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * procedure to turn the cards onto the talon from the deck  */
end_comment

begin_function
name|void
name|movetotalon
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|fin
decl_stmt|;
if|if
condition|(
name|cinhand
operator|<=
literal|3
operator|&&
name|cinhand
operator|>
literal|0
condition|)
block|{
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Hand is now empty        "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cinhand
operator|>=
literal|3
condition|)
name|fin
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|cinhand
operator|>
literal|0
condition|)
name|fin
operator|=
name|cinhand
expr_stmt|;
elseif|else
if|if
condition|(
name|talon
operator|!=
name|NIL
condition|)
block|{
name|timesthru
operator|++
expr_stmt|;
name|errmsg
operator|=
name|TRUE
expr_stmt|;
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
if|if
condition|(
name|timesthru
operator|!=
literal|4
condition|)
block|{
name|printw
argument_list|(
literal|"Talon is now the new hand"
argument_list|)
expr_stmt|;
name|this
operator|.
name|runs
operator|+=
name|costofrunthroughhand
expr_stmt|;
name|game
operator|.
name|runs
operator|+=
name|costofrunthroughhand
expr_stmt|;
name|total
operator|.
name|runs
operator|+=
name|costofrunthroughhand
expr_stmt|;
while|while
condition|(
name|talon
operator|!=
name|NIL
condition|)
block|{
name|transit
argument_list|(
operator|&
name|talon
argument_list|,
operator|&
name|hand
argument_list|)
expr_stmt|;
name|cinhand
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cinhand
operator|>=
literal|3
condition|)
name|fin
operator|=
literal|3
expr_stmt|;
else|else
name|fin
operator|=
name|cinhand
expr_stmt|;
name|taloncnt
operator|=
literal|0
expr_stmt|;
name|coldrow
operator|=
name|ctoprow
expr_stmt|;
name|coldcol
operator|=
name|cinitcol
expr_stmt|;
name|cnewrow
operator|=
name|ctoprow
expr_stmt|;
name|cnewcol
operator|=
name|cinitcol
operator|+
name|cwidthcol
expr_stmt|;
name|clearstat
argument_list|()
expr_stmt|;
name|showstat
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fin
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
name|printw
argument_list|(
literal|"I believe you have lost"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|errmsg
operator|=
name|TRUE
expr_stmt|;
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Talon and hand are empty"
argument_list|)
expr_stmt|;
name|fin
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fin
condition|;
name|i
operator|++
control|)
block|{
name|transit
argument_list|(
operator|&
name|hand
argument_list|,
operator|&
name|talon
argument_list|)
expr_stmt|;
name|INCRHAND
argument_list|(
name|cnewrow
argument_list|,
name|cnewcol
argument_list|)
expr_stmt|;
name|INCRHAND
argument_list|(
name|coldrow
argument_list|,
name|coldcol
argument_list|)
expr_stmt|;
name|removecard
argument_list|(
name|cnewcol
argument_list|,
name|cnewrow
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|fin
operator|-
literal|1
condition|)
name|talon
operator|->
name|visible
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
block|{
if|if
condition|(
name|talon
operator|->
name|paid
operator|==
name|FALSE
operator|&&
name|talon
operator|->
name|visible
operator|==
name|TRUE
condition|)
block|{
name|this
operator|.
name|information
operator|+=
name|costofinformation
expr_stmt|;
name|game
operator|.
name|information
operator|+=
name|costofinformation
expr_stmt|;
name|total
operator|.
name|information
operator|+=
name|costofinformation
expr_stmt|;
name|talon
operator|->
name|paid
operator|=
name|TRUE
expr_stmt|;
block|}
name|printcard
argument_list|(
name|coldcol
argument_list|,
name|coldrow
argument_list|,
name|talon
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fin
operator|!=
literal|0
condition|)
block|{
name|printcard
argument_list|(
name|taloncol
argument_list|,
name|talonrow
argument_list|,
name|talon
argument_list|)
expr_stmt|;
name|cinhand
operator|-=
name|fin
expr_stmt|;
name|taloncnt
operator|+=
name|fin
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
block|{
name|move
argument_list|(
name|handstatrow
argument_list|,
name|handstatcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%3d"
argument_list|,
name|cinhand
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonstatrow
argument_list|,
name|talonstatcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%3d"
argument_list|,
name|taloncnt
argument_list|)
expr_stmt|;
block|}
name|fndbase
argument_list|(
operator|&
name|talon
argument_list|,
name|taloncol
argument_list|,
name|talonrow
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * procedure to print card counting info on screen  */
end_comment

begin_function
name|void
name|showstat
parameter_list|()
block|{
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
name|struct
name|cardtype
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|Cflag
condition|)
return|return;
name|move
argument_list|(
name|talonstatrow
argument_list|,
name|talonstatcol
operator|-
literal|7
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Talon: %3d"
argument_list|,
name|taloncnt
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|handstatrow
argument_list|,
name|handstatcol
operator|-
literal|7
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Hand:  %3d"
argument_list|,
name|cinhand
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|stockstatrow
argument_list|,
name|stockstatcol
operator|-
literal|7
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Stock: %3d"
argument_list|,
name|stockcnt
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
name|coldrow
operator|,
name|col
operator|=
name|coldcol
operator|,
name|ptr
operator|=
name|talon
init|;
name|ptr
operator|!=
name|NIL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|paid
operator|==
name|FALSE
operator|&&
name|ptr
operator|->
name|visible
operator|==
name|TRUE
condition|)
block|{
name|ptr
operator|->
name|paid
operator|=
name|TRUE
expr_stmt|;
name|this
operator|.
name|information
operator|+=
name|costofinformation
expr_stmt|;
name|game
operator|.
name|information
operator|+=
name|costofinformation
expr_stmt|;
name|total
operator|.
name|information
operator|+=
name|costofinformation
expr_stmt|;
block|}
name|printcard
argument_list|(
name|col
argument_list|,
name|row
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|DECRHAND
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|row
operator|=
name|cnewrow
operator|,
name|col
operator|=
name|cnewcol
operator|,
name|ptr
operator|=
name|hand
init|;
name|ptr
operator|!=
name|NIL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|paid
operator|==
name|FALSE
operator|&&
name|ptr
operator|->
name|visible
operator|==
name|TRUE
condition|)
block|{
name|ptr
operator|->
name|paid
operator|=
name|TRUE
expr_stmt|;
name|this
operator|.
name|information
operator|+=
name|costofinformation
expr_stmt|;
name|game
operator|.
name|information
operator|+=
name|costofinformation
expr_stmt|;
name|total
operator|.
name|information
operator|+=
name|costofinformation
expr_stmt|;
block|}
name|INCRHAND
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|col
argument_list|,
name|row
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * procedure to clear card counting info from screen  */
end_comment

begin_function
name|void
name|clearstat
parameter_list|()
block|{
name|int
name|row
decl_stmt|;
name|move
argument_list|(
name|talonstatrow
argument_list|,
name|talonstatcol
operator|-
literal|7
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"          "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|handstatrow
argument_list|,
name|handstatcol
operator|-
literal|7
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"          "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|stockstatrow
argument_list|,
name|stockstatcol
operator|-
literal|7
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"          "
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
name|ctoprow
init|;
name|row
operator|<=
name|cbotrow
condition|;
name|row
operator|++
control|)
block|{
name|move
argument_list|(
name|row
argument_list|,
name|cinitcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%56s"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * procedure to update card counting base  */
end_comment

begin_function
name|void
name|usedtalon
parameter_list|()
block|{
name|removecard
argument_list|(
name|coldcol
argument_list|,
name|coldrow
argument_list|)
expr_stmt|;
name|DECRHAND
argument_list|(
name|coldrow
argument_list|,
name|coldcol
argument_list|)
expr_stmt|;
if|if
condition|(
name|talon
operator|!=
name|NIL
operator|&&
operator|(
name|talon
operator|->
name|visible
operator|==
name|FALSE
operator|)
condition|)
block|{
name|talon
operator|->
name|visible
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
block|{
name|this
operator|.
name|information
operator|+=
name|costofinformation
expr_stmt|;
name|game
operator|.
name|information
operator|+=
name|costofinformation
expr_stmt|;
name|total
operator|.
name|information
operator|+=
name|costofinformation
expr_stmt|;
name|talon
operator|->
name|paid
operator|=
name|TRUE
expr_stmt|;
name|printcard
argument_list|(
name|coldcol
argument_list|,
name|coldrow
argument_list|,
name|talon
argument_list|)
expr_stmt|;
block|}
block|}
name|taloncnt
operator|--
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
block|{
name|move
argument_list|(
name|talonstatrow
argument_list|,
name|talonstatcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%3d"
argument_list|,
name|taloncnt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * procedure to update stock card counting base  */
end_comment

begin_function
name|void
name|usedstock
parameter_list|()
block|{
name|stockcnt
operator|--
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
block|{
name|move
argument_list|(
name|stockstatrow
argument_list|,
name|stockstatcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%3d"
argument_list|,
name|stockcnt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * let 'em know how they lost!  */
end_comment

begin_function
name|void
name|showcards
parameter_list|()
block|{
name|struct
name|cardtype
modifier|*
name|ptr
decl_stmt|;
name|int
name|row
decl_stmt|;
if|if
condition|(
operator|!
name|Cflag
operator|||
name|cardsoff
operator|==
literal|52
condition|)
return|return;
for|for
control|(
name|ptr
operator|=
name|talon
init|;
name|ptr
operator|!=
name|NIL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|ptr
operator|->
name|visible
operator|=
name|TRUE
expr_stmt|;
name|ptr
operator|->
name|paid
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
name|ptr
operator|=
name|hand
init|;
name|ptr
operator|!=
name|NIL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|ptr
operator|->
name|visible
operator|=
name|TRUE
expr_stmt|;
name|ptr
operator|->
name|paid
operator|=
name|TRUE
expr_stmt|;
block|}
name|showstat
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|stockrow
operator|+
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|-
literal|2
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|-
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|+
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|stock
operator|,
name|row
operator|=
name|stockrow
init|;
name|ptr
operator|!=
name|NIL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
operator|,
name|row
operator|++
control|)
block|{
name|move
argument_list|(
name|row
argument_list|,
name|stockcol
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|   |"
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|stockcol
argument_list|,
name|row
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stock
operator|==
name|NIL
condition|)
block|{
name|move
argument_list|(
name|row
argument_list|,
name|stockcol
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|   |"
argument_list|)
expr_stmt|;
name|row
operator|++
expr_stmt|;
block|}
name|move
argument_list|(
name|handstatrow
argument_list|,
name|handstatcol
operator|-
literal|7
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"          "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|row
argument_list|,
name|stockcol
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---="
argument_list|)
expr_stmt|;
if|if
condition|(
name|cardsoff
operator|==
literal|52
condition|)
name|getcmd
argument_list|(
name|moverow
argument_list|,
name|movecol
argument_list|,
literal|"Hit return to exit"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * procedure to update the betting values  */
end_comment

begin_function
name|void
name|updatebettinginfo
parameter_list|()
block|{
name|long
name|thiscosts
decl_stmt|,
name|gamecosts
decl_stmt|,
name|totalcosts
decl_stmt|;
name|double
name|thisreturn
decl_stmt|,
name|gamereturn
decl_stmt|,
name|totalreturn
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|long
name|dollars
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|dollars
operator|=
operator|(
name|now
operator|-
name|acctstart
operator|)
operator|/
name|secondsperdollar
expr_stmt|;
if|if
condition|(
name|dollars
operator|>
literal|0
condition|)
block|{
name|acctstart
operator|+=
name|dollars
operator|*
name|secondsperdollar
expr_stmt|;
if|if
condition|(
name|dollars
operator|>
name|maxtimecharge
condition|)
name|dollars
operator|=
name|maxtimecharge
expr_stmt|;
name|this
operator|.
name|thinktime
operator|+=
name|dollars
expr_stmt|;
name|game
operator|.
name|thinktime
operator|+=
name|dollars
expr_stmt|;
name|total
operator|.
name|thinktime
operator|+=
name|dollars
expr_stmt|;
block|}
name|thiscosts
operator|=
name|this
operator|.
name|hand
operator|+
name|this
operator|.
name|inspection
operator|+
name|this
operator|.
name|game
operator|+
name|this
operator|.
name|runs
operator|+
name|this
operator|.
name|information
operator|+
name|this
operator|.
name|thinktime
expr_stmt|;
name|gamecosts
operator|=
name|game
operator|.
name|hand
operator|+
name|game
operator|.
name|inspection
operator|+
name|game
operator|.
name|game
operator|+
name|game
operator|.
name|runs
operator|+
name|game
operator|.
name|information
operator|+
name|game
operator|.
name|thinktime
expr_stmt|;
name|totalcosts
operator|=
name|total
operator|.
name|hand
operator|+
name|total
operator|.
name|inspection
operator|+
name|total
operator|.
name|game
operator|+
name|total
operator|.
name|runs
operator|+
name|total
operator|.
name|information
operator|+
name|total
operator|.
name|thinktime
expr_stmt|;
name|this
operator|.
name|worth
operator|=
name|this
operator|.
name|wins
operator|-
name|thiscosts
expr_stmt|;
name|game
operator|.
name|worth
operator|=
name|game
operator|.
name|wins
operator|-
name|gamecosts
expr_stmt|;
name|total
operator|.
name|worth
operator|=
name|total
operator|.
name|wins
operator|-
name|totalcosts
expr_stmt|;
name|thisreturn
operator|=
operator|(
operator|(
name|double
operator|)
name|this
operator|.
name|wins
operator|/
operator|(
name|double
operator|)
name|thiscosts
operator|-
literal|1.0
operator|)
operator|*
literal|100.0
expr_stmt|;
name|gamereturn
operator|=
operator|(
operator|(
name|double
operator|)
name|game
operator|.
name|wins
operator|/
operator|(
name|double
operator|)
name|gamecosts
operator|-
literal|1.0
operator|)
operator|*
literal|100.0
expr_stmt|;
name|totalreturn
operator|=
operator|(
operator|(
name|double
operator|)
name|total
operator|.
name|wins
operator|/
operator|(
name|double
operator|)
name|totalcosts
operator|-
literal|1.0
operator|)
operator|*
literal|100.0
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|BETTINGBOX
condition|)
return|return;
name|move
argument_list|(
name|tboxrow
operator|+
literal|2
argument_list|,
name|boxcol
operator|+
literal|13
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%4d%8d%9d"
argument_list|,
name|this
operator|.
name|hand
argument_list|,
name|game
operator|.
name|hand
argument_list|,
name|total
operator|.
name|hand
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|3
argument_list|,
name|boxcol
operator|+
literal|13
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%4d%8d%9d"
argument_list|,
name|this
operator|.
name|inspection
argument_list|,
name|game
operator|.
name|inspection
argument_list|,
name|total
operator|.
name|inspection
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|4
argument_list|,
name|boxcol
operator|+
literal|13
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%4d%8d%9d"
argument_list|,
name|this
operator|.
name|game
argument_list|,
name|game
operator|.
name|game
argument_list|,
name|total
operator|.
name|game
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|5
argument_list|,
name|boxcol
operator|+
literal|13
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%4d%8d%9d"
argument_list|,
name|this
operator|.
name|runs
argument_list|,
name|game
operator|.
name|runs
argument_list|,
name|total
operator|.
name|runs
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|6
argument_list|,
name|boxcol
operator|+
literal|13
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%4d%8d%9d"
argument_list|,
name|this
operator|.
name|information
argument_list|,
name|game
operator|.
name|information
argument_list|,
name|total
operator|.
name|information
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|7
argument_list|,
name|boxcol
operator|+
literal|13
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%4d%8d%9d"
argument_list|,
name|this
operator|.
name|thinktime
argument_list|,
name|game
operator|.
name|thinktime
argument_list|,
name|total
operator|.
name|thinktime
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|8
argument_list|,
name|boxcol
operator|+
literal|13
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%4d%8d%9d"
argument_list|,
name|thiscosts
argument_list|,
name|gamecosts
argument_list|,
name|totalcosts
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|9
argument_list|,
name|boxcol
operator|+
literal|13
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%4d%8d%9d"
argument_list|,
name|this
operator|.
name|wins
argument_list|,
name|game
operator|.
name|wins
argument_list|,
name|total
operator|.
name|wins
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|10
argument_list|,
name|boxcol
operator|+
literal|13
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%4d%8d%9d"
argument_list|,
name|this
operator|.
name|worth
argument_list|,
name|game
operator|.
name|worth
argument_list|,
name|total
operator|.
name|worth
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|11
argument_list|,
name|boxcol
operator|+
literal|13
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%4.0f%%%7.1f%%%8.1f%%"
argument_list|,
name|thisreturn
argument_list|,
name|gamereturn
argument_list|,
name|totalreturn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * procedure to move a card from the stock or talon to the tableau  */
end_comment

begin_function
name|void
name|simpletableau
parameter_list|(
name|cp
parameter_list|,
name|des
parameter_list|)
name|struct
name|cardtype
modifier|*
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|origin
decl_stmt|;
if|if
condition|(
name|notempty
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
name|tabok
argument_list|(
operator|*
name|cp
argument_list|,
name|des
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
name|stock
condition|)
name|origin
operator|=
name|stk
expr_stmt|;
else|else
name|origin
operator|=
name|tal
expr_stmt|;
if|if
condition|(
name|tableau
index|[
name|des
index|]
operator|==
name|NIL
condition|)
name|bottom
index|[
name|des
index|]
operator|=
operator|*
name|cp
expr_stmt|;
name|transit
argument_list|(
name|cp
argument_list|,
operator|&
name|tableau
index|[
name|des
index|]
argument_list|)
expr_stmt|;
name|length
index|[
name|des
index|]
operator|++
expr_stmt|;
name|printcard
argument_list|(
name|pilemap
index|[
name|des
index|]
argument_list|,
name|length
index|[
name|des
index|]
argument_list|,
name|tableau
index|[
name|des
index|]
argument_list|)
expr_stmt|;
name|timesthru
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|origin
operator|==
name|stk
condition|)
block|{
name|usedstock
argument_list|()
expr_stmt|;
name|printcard
argument_list|(
name|stockcol
argument_list|,
name|stockrow
argument_list|,
name|stock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usedtalon
argument_list|()
expr_stmt|;
name|printcard
argument_list|(
name|taloncol
argument_list|,
name|talonrow
argument_list|,
name|talon
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|destinerror
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * print the tableau  */
end_comment

begin_function
name|void
name|tabprint
parameter_list|(
name|sour
parameter_list|,
name|des
parameter_list|)
block|{
name|int
name|dlength
decl_stmt|,
name|slength
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|cardtype
modifier|*
name|tempcard
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tabrow
init|;
name|i
operator|<=
name|length
index|[
name|sour
index|]
condition|;
name|i
operator|++
control|)
name|removecard
argument_list|(
name|pilemap
index|[
name|sour
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dlength
operator|=
name|length
index|[
name|des
index|]
operator|+
literal|1
expr_stmt|;
name|slength
operator|=
name|length
index|[
name|sour
index|]
expr_stmt|;
if|if
condition|(
name|slength
operator|==
name|tabrow
condition|)
name|printcard
argument_list|(
name|pilemap
index|[
name|des
index|]
argument_list|,
name|dlength
argument_list|,
name|tableau
index|[
name|sour
index|]
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|slength
operator|!=
name|tabrow
operator|-
literal|1
condition|)
block|{
name|tempcard
operator|=
name|tableau
index|[
name|sour
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|slength
operator|-
name|tabrow
condition|;
name|i
operator|++
control|)
name|tempcard
operator|=
name|tempcard
operator|->
name|next
expr_stmt|;
name|printcard
argument_list|(
name|pilemap
index|[
name|des
index|]
argument_list|,
name|dlength
argument_list|,
name|tempcard
argument_list|)
expr_stmt|;
name|slength
operator|--
expr_stmt|;
name|dlength
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * procedure to move from the tableau to the tableau  */
end_comment

begin_function
name|void
name|tabtotab
parameter_list|(
name|sour
parameter_list|,
name|des
parameter_list|)
name|int
name|sour
decl_stmt|,
name|des
decl_stmt|;
block|{
name|struct
name|cardtype
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|notempty
argument_list|(
name|tableau
index|[
name|sour
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|tabok
argument_list|(
name|bottom
index|[
name|sour
index|]
argument_list|,
name|des
argument_list|)
condition|)
block|{
name|tabprint
argument_list|(
name|sour
argument_list|,
name|des
argument_list|)
expr_stmt|;
name|temp
operator|=
name|bottom
index|[
name|sour
index|]
expr_stmt|;
name|bottom
index|[
name|sour
index|]
operator|=
name|NIL
expr_stmt|;
if|if
condition|(
name|bottom
index|[
name|des
index|]
operator|==
name|NIL
condition|)
name|bottom
index|[
name|des
index|]
operator|=
name|temp
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|tableau
index|[
name|des
index|]
expr_stmt|;
name|tableau
index|[
name|des
index|]
operator|=
name|tableau
index|[
name|sour
index|]
expr_stmt|;
name|tableau
index|[
name|sour
index|]
operator|=
name|NIL
expr_stmt|;
name|length
index|[
name|des
index|]
operator|=
name|length
index|[
name|des
index|]
operator|+
operator|(
name|length
index|[
name|sour
index|]
operator|-
operator|(
name|tabrow
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|length
index|[
name|sour
index|]
operator|=
name|tabrow
operator|-
literal|1
expr_stmt|;
name|timesthru
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|destinerror
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * functions to see if the card can go onto the foundation  */
end_comment

begin_function
name|bool
name|rankhigher
parameter_list|(
name|cp
parameter_list|,
name|let
parameter_list|)
name|struct
name|cardtype
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
name|found
index|[
name|let
index|]
operator|->
name|rank
operator|==
name|King
condition|)
if|if
condition|(
name|cp
operator|->
name|rank
operator|==
name|Ace
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
elseif|else
if|if
condition|(
name|cp
operator|->
name|rank
operator|-
literal|1
operator|==
name|found
index|[
name|let
index|]
operator|->
name|rank
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * function to determine if two cards are the same suit  */
end_comment

begin_function
name|bool
name|samesuit
parameter_list|(
name|cp
parameter_list|,
name|let
parameter_list|)
name|struct
name|cardtype
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
name|cp
operator|->
name|suit
operator|==
name|found
index|[
name|let
index|]
operator|->
name|suit
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * procedure to move a card to the correct foundation pile  */
end_comment

begin_function
name|void
name|movetofound
parameter_list|(
name|cp
parameter_list|,
name|source
parameter_list|)
name|struct
name|cardtype
modifier|*
modifier|*
name|cp
decl_stmt|;
block|{
name|tempbase
operator|=
literal|0
expr_stmt|;
name|mtfdone
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|notempty
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
do|do
block|{
if|if
condition|(
name|found
index|[
name|tempbase
index|]
operator|!=
name|NIL
condition|)
if|if
condition|(
name|rankhigher
argument_list|(
operator|*
name|cp
argument_list|,
name|tempbase
argument_list|)
operator|&&
name|samesuit
argument_list|(
operator|*
name|cp
argument_list|,
name|tempbase
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
name|stock
condition|)
name|mtforigin
operator|=
name|stk
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
name|talon
condition|)
name|mtforigin
operator|=
name|tal
expr_stmt|;
else|else
name|mtforigin
operator|=
name|tab
expr_stmt|;
name|transit
argument_list|(
name|cp
argument_list|,
operator|&
name|found
index|[
name|tempbase
index|]
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|pilemap
index|[
name|tempbase
index|]
argument_list|,
name|foundrow
argument_list|,
name|found
index|[
name|tempbase
index|]
argument_list|)
expr_stmt|;
name|timesthru
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mtforigin
operator|==
name|stk
condition|)
block|{
name|usedstock
argument_list|()
expr_stmt|;
name|printcard
argument_list|(
name|stockcol
argument_list|,
name|stockrow
argument_list|,
name|stock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mtforigin
operator|==
name|tal
condition|)
block|{
name|usedtalon
argument_list|()
expr_stmt|;
name|printcard
argument_list|(
name|taloncol
argument_list|,
name|talonrow
argument_list|,
name|talon
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|removecard
argument_list|(
name|pilemap
index|[
name|source
index|]
argument_list|,
name|length
index|[
name|source
index|]
argument_list|)
expr_stmt|;
name|length
index|[
name|source
index|]
operator|--
expr_stmt|;
block|}
name|cardsoff
operator|++
expr_stmt|;
if|if
condition|(
name|infullgame
condition|)
block|{
name|this
operator|.
name|wins
operator|+=
name|valuepercardup
expr_stmt|;
name|game
operator|.
name|wins
operator|+=
name|valuepercardup
expr_stmt|;
name|total
operator|.
name|wins
operator|+=
name|valuepercardup
expr_stmt|;
block|}
name|mtfdone
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|tempbase
operator|++
expr_stmt|;
else|else
name|tempbase
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|tempbase
operator|!=
literal|4
operator|)
operator|&&
operator|!
name|mtfdone
condition|)
do|;
if|if
condition|(
operator|!
name|mtfdone
condition|)
name|destinerror
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * procedure to get a command  */
end_comment

begin_function
name|void
name|getcmd
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|,
name|cp
parameter_list|)
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|char
name|cmd
index|[
literal|2
index|]
decl_stmt|,
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|move
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%-24s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
do|do
block|{
name|ch
operator|=
name|getch
argument_list|()
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
condition|)
name|ch
operator|+=
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\f'
condition|)
block|{
name|wrefresh
argument_list|(
name|curscr
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
literal|2
operator|&&
name|ch
operator|!=
name|erasechar
argument_list|()
operator|&&
name|ch
operator|!=
name|killchar
argument_list|()
condition|)
block|{
if|if
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|'\r'
operator|&&
name|ch
operator|!=
literal|' '
condition|)
name|write
argument_list|(
literal|1
argument_list|,
literal|"\007"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|erasechar
argument_list|()
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|printw
argument_list|(
literal|"\b \b"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|killchar
argument_list|()
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|printw
argument_list|(
literal|"\b \b"
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
name|refresh
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\032'
condition|)
block|{
comment|/* Control-Z */
name|suspend
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|row
argument_list|,
name|col
operator|+
name|i
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|cmd
index|[
name|i
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|addch
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|'\r'
operator|&&
name|ch
operator|!=
literal|' '
condition|)
do|;
name|srcpile
operator|=
name|cmd
index|[
literal|0
index|]
expr_stmt|;
name|destpile
operator|=
name|cmd
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Suspend the game (shell escape if no process control on system)  */
end_comment

begin_function
name|void
name|suspend
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|SIGTSTP
name|char
modifier|*
name|sh
decl_stmt|;
endif|#
directive|endif
name|updatebettinginfo
argument_list|()
expr_stmt|;
name|move
argument_list|(
literal|21
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|dbfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|lseek
argument_list|(
name|dbfd
argument_list|,
name|uid
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|betinfo
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|dbfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|total
argument_list|,
sizeof|sizeof
argument_list|(
name|total
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * procedure to evaluate and make the specific moves  */
end_comment

begin_function
name|void
name|movecard
parameter_list|()
block|{
name|int
name|source
decl_stmt|,
name|dest
decl_stmt|;
name|char
name|osrcpile
decl_stmt|,
name|odestpile
decl_stmt|;
name|source
operator|=
literal|0
expr_stmt|;
name|dest
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|FALSE
expr_stmt|;
name|errmsg
operator|=
name|FALSE
expr_stmt|;
do|do
block|{
if|if
condition|(
name|talon
operator|==
name|NIL
operator|&&
name|hand
operator|!=
name|NIL
condition|)
name|movetotalon
argument_list|()
expr_stmt|;
if|if
condition|(
name|cardsoff
operator|==
literal|52
condition|)
block|{
name|refresh
argument_list|()
expr_stmt|;
name|srcpile
operator|=
literal|'q'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|startedgame
condition|)
block|{
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
name|errmsg
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
literal|34
operator|-
name|taloncnt
operator|-
name|cinhand
condition|)
block|{
default|default:
name|errmsg
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printw
argument_list|(
literal|"One card used from talon  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printw
argument_list|(
literal|"Two cards used from talon "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printw
argument_list|(
literal|">3< cards used from talon "
argument_list|)
expr_stmt|;
break|break;
block|}
name|getcmd
argument_list|(
name|moverow
argument_list|,
name|movecol
argument_list|,
literal|"Move:"
argument_list|)
expr_stmt|;
block|}
else|else
name|getcmd
argument_list|(
name|moverow
argument_list|,
name|movecol
argument_list|,
literal|"Move:"
argument_list|)
expr_stmt|;
name|clearmsg
argument_list|()
expr_stmt|;
if|if
condition|(
name|srcpile
operator|>=
literal|'1'
operator|&&
name|srcpile
operator|<=
literal|'4'
condition|)
name|source
operator|=
call|(
name|int
call|)
argument_list|(
name|srcpile
operator|-
literal|'1'
argument_list|)
expr_stmt|;
if|if
condition|(
name|destpile
operator|>=
literal|'1'
operator|&&
name|destpile
operator|<=
literal|'4'
condition|)
name|dest
operator|=
call|(
name|int
call|)
argument_list|(
name|destpile
operator|-
literal|'1'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|startedgame
operator|&&
operator|(
name|srcpile
operator|==
literal|'t'
operator|||
name|srcpile
operator|==
literal|'s'
operator|||
name|srcpile
operator|==
literal|'h'
operator|||
name|srcpile
operator|==
literal|'1'
operator|||
name|srcpile
operator|==
literal|'2'
operator|||
name|srcpile
operator|==
literal|'3'
operator|||
name|srcpile
operator|==
literal|'4'
operator|)
condition|)
block|{
name|startedgame
operator|=
name|TRUE
expr_stmt|;
name|osrcpile
operator|=
name|srcpile
expr_stmt|;
name|odestpile
operator|=
name|destpile
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|BETTINGBOX
condition|)
name|srcpile
operator|=
literal|'y'
expr_stmt|;
else|else
do|do
block|{
name|getcmd
argument_list|(
name|moverow
argument_list|,
name|movecol
argument_list|,
literal|"Inspect game?"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|srcpile
operator|!=
literal|'y'
operator|&&
name|srcpile
operator|!=
literal|'n'
condition|)
do|;
if|if
condition|(
name|srcpile
operator|==
literal|'n'
condition|)
block|{
name|srcpile
operator|=
literal|'q'
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|inspection
operator|+=
name|costofinspection
expr_stmt|;
name|game
operator|.
name|inspection
operator|+=
name|costofinspection
expr_stmt|;
name|total
operator|.
name|inspection
operator|+=
name|costofinspection
expr_stmt|;
name|srcpile
operator|=
name|osrcpile
expr_stmt|;
name|destpile
operator|=
name|odestpile
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|srcpile
condition|)
block|{
case|case
literal|'t'
case|:
if|if
condition|(
name|destpile
operator|==
literal|'f'
operator|||
name|destpile
operator|==
literal|'F'
condition|)
name|movetofound
argument_list|(
operator|&
name|talon
argument_list|,
name|source
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|destpile
operator|>=
literal|'1'
operator|&&
name|destpile
operator|<=
literal|'4'
condition|)
name|simpletableau
argument_list|(
operator|&
name|talon
argument_list|,
name|dest
argument_list|)
expr_stmt|;
else|else
name|dumberror
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|destpile
operator|==
literal|'f'
operator|||
name|destpile
operator|==
literal|'F'
condition|)
name|movetofound
argument_list|(
operator|&
name|stock
argument_list|,
name|source
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|destpile
operator|>=
literal|'1'
operator|&&
name|destpile
operator|<=
literal|'4'
condition|)
name|simpletableau
argument_list|(
operator|&
name|stock
argument_list|,
name|dest
argument_list|)
expr_stmt|;
else|else
name|dumberror
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|destpile
operator|!=
literal|'t'
operator|&&
name|destpile
operator|!=
literal|'T'
condition|)
block|{
name|dumberror
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|infullgame
condition|)
block|{
name|movetotalon
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|BETTINGBOX
condition|)
block|{
do|do
block|{
name|getcmd
argument_list|(
name|moverow
argument_list|,
name|movecol
argument_list|,
literal|"Buy game?"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|srcpile
operator|!=
literal|'y'
operator|&&
name|srcpile
operator|!=
literal|'n'
condition|)
do|;
if|if
condition|(
name|srcpile
operator|==
literal|'n'
condition|)
block|{
name|showcards
argument_list|()
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|infullgame
operator|=
name|TRUE
expr_stmt|;
name|this
operator|.
name|wins
operator|+=
name|valuepercardup
operator|*
name|cardsoff
expr_stmt|;
name|game
operator|.
name|wins
operator|+=
name|valuepercardup
operator|*
name|cardsoff
expr_stmt|;
name|total
operator|.
name|wins
operator|+=
name|valuepercardup
operator|*
name|cardsoff
expr_stmt|;
name|this
operator|.
name|game
operator|+=
name|costofgame
expr_stmt|;
name|game
operator|.
name|game
operator|+=
name|costofgame
expr_stmt|;
name|total
operator|.
name|game
operator|+=
name|costofgame
expr_stmt|;
name|movetotalon
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|showcards
argument_list|()
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|printtopbettingbox
argument_list|()
expr_stmt|;
name|printbottombettingbox
argument_list|()
expr_stmt|;
name|status
operator|=
name|BETTINGBOX
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|clearabovemovebox
argument_list|()
expr_stmt|;
name|clearbelowmovebox
argument_list|()
expr_stmt|;
name|status
operator|=
name|NOBOX
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|printtopinstructions
argument_list|()
expr_stmt|;
name|printbottominstructions
argument_list|()
expr_stmt|;
name|status
operator|=
name|INSTRUCTIONBOX
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|Cflag
operator|=
operator|!
name|Cflag
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
name|showstat
argument_list|()
expr_stmt|;
else|else
name|clearstat
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
if|if
condition|(
name|destpile
operator|==
literal|'f'
operator|||
name|destpile
operator|==
literal|'F'
condition|)
name|movetofound
argument_list|(
operator|&
name|tableau
index|[
name|source
index|]
argument_list|,
name|source
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|destpile
operator|>=
literal|'1'
operator|&&
name|destpile
operator|<=
literal|'4'
condition|)
name|tabtotab
argument_list|(
name|source
argument_list|,
name|dest
argument_list|)
expr_stmt|;
else|else
name|dumberror
argument_list|()
expr_stmt|;
break|break;
default|default:
name|dumberror
argument_list|()
expr_stmt|;
block|}
name|fndbase
argument_list|(
operator|&
name|stock
argument_list|,
name|stockcol
argument_list|,
name|stockrow
argument_list|)
expr_stmt|;
name|fndbase
argument_list|(
operator|&
name|talon
argument_list|,
name|taloncol
argument_list|,
name|talonrow
argument_list|)
expr_stmt|;
name|updatebettinginfo
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|basicinstructions
index|[]
init|=
block|{
literal|"Here are brief instuctions to the game of Canfield:\n\n"
block|,
literal|"     If you have never played solitaire before, it is recom-\n"
block|,
literal|"mended  that  you  consult  a solitaire instruction book. In\n"
block|,
literal|"Canfield, tableau cards may be built on each other  downward\n"
block|,
literal|"in  alternate colors. An entire pile must be moved as a unit\n"
block|,
literal|"in building. Top cards of the piles are available to be able\n"
block|,
literal|"to be played on foundations, but never into empty spaces.\n\n"
block|,
literal|"     Spaces must be filled from the stock. The top  card  of\n"
block|,
literal|"the  stock  also is available to be played on foundations or\n"
block|,
literal|"built on tableau piles. After the stock  is  exhausted,  ta-\n"
block|,
literal|"bleau spaces may be filled from the talon and the player may\n"
block|,
literal|"keep them open until he wishes to use them.\n\n"
block|,
literal|"     Cards are dealt from the hand to the  talon  by  threes\n"
block|,
literal|"and  this  repeats until there are no more cards in the hand\n"
block|,
literal|"or the player quits. To have cards dealt onto the talon  the\n"
block|,
literal|"player  types  'ht'  for his move. Foundation base cards are\n"
block|,
literal|"also automatically moved to the foundation when they  become\n"
block|,
literal|"available.\n\n"
block|,
literal|"push any key when you are finished: "
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bettinginstructions
index|[]
init|=
block|{
literal|"     The rules for betting are  somewhat  less  strict  than\n"
block|,
literal|"those  used in the official version of the game. The initial\n"
block|,
literal|"deal costs $13. You may quit at this point  or  inspect  the\n"
block|,
literal|"game.  Inspection  costs  $13 and allows you to make as many\n"
block|,
literal|"moves as is possible without moving any cards from your hand\n"
block|,
literal|"to  the  talon.  (the initial deal places three cards on the\n"
block|,
literal|"talon; if all these cards are  used,  three  more  are  made\n"
block|,
literal|"available)  Finally, if the game seems interesting, you must\n"
block|,
literal|"pay the final installment of $26.  At  this  point  you  are\n"
block|,
literal|"credited  at the rate of $5 for each card on the foundation;\n"
block|,
literal|"as the game progresses you are credited  with  $5  for  each\n"
block|,
literal|"card  that is moved to the foundation.  Each run through the\n"
block|,
literal|"hand after the first costs $5.  The  card  counting  feature\n"
block|,
literal|"costs  $1  for  each unknown card that is identified. If the\n"
block|,
literal|"information is toggled on, you are only  charged  for  cards\n"
block|,
literal|"that  became  visible  since it was last turned on. Thus the\n"
block|,
literal|"maximum cost of information is $34.  Playing time is charged\n"
block|,
literal|"at a rate of $1 per minute.\n\n"
block|,
literal|"push any key when you are finished: "
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * procedure to printout instructions  */
end_comment

begin_function
name|void
name|instruct
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
name|move
argument_list|(
name|originrow
argument_list|,
name|origincol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"This is the game of solitaire called Canfield.  Do\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"you want instructions for the game?"
argument_list|)
expr_stmt|;
do|do
block|{
name|getcmd
argument_list|(
name|originrow
operator|+
literal|3
argument_list|,
name|origincol
argument_list|,
literal|"y or n?"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|srcpile
operator|!=
literal|'y'
operator|&&
name|srcpile
operator|!=
literal|'n'
condition|)
do|;
if|if
condition|(
name|srcpile
operator|==
literal|'n'
condition|)
return|return;
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|basicinstructions
init|;
operator|*
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|++
control|)
name|printw
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|originrow
argument_list|,
name|origincol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Do you want instructions for betting?"
argument_list|)
expr_stmt|;
do|do
block|{
name|getcmd
argument_list|(
name|originrow
operator|+
literal|2
argument_list|,
name|origincol
argument_list|,
literal|"y or n?"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|srcpile
operator|!=
literal|'y'
operator|&&
name|srcpile
operator|!=
literal|'n'
condition|)
do|;
if|if
condition|(
name|srcpile
operator|==
literal|'n'
condition|)
return|return;
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|bettinginstructions
init|;
operator|*
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|++
control|)
name|printw
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * procedure to initialize the game  */
end_comment

begin_function
name|void
name|initall
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dbfd
operator|<
literal|0
condition|)
return|return;
name|srandomdev
argument_list|()
expr_stmt|;
name|time
argument_list|(
operator|&
name|acctstart
argument_list|)
expr_stmt|;
name|initdeck
argument_list|(
name|deck
argument_list|)
expr_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|i
operator|=
name|lseek
argument_list|(
name|dbfd
argument_list|,
name|uid
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|betinfo
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|dbfd
argument_list|)
expr_stmt|;
name|dbfd
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|read
argument_list|(
name|dbfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|total
argument_list|,
sizeof|sizeof
argument_list|(
name|total
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|dbfd
argument_list|)
expr_stmt|;
name|dbfd
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * procedure to end the game  */
end_comment

begin_function
name|bool
name|finish
parameter_list|()
block|{
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
if|if
condition|(
name|cardsoff
operator|==
literal|52
condition|)
block|{
name|getcmd
argument_list|(
name|moverow
argument_list|,
name|movecol
argument_list|,
literal|"Hit return to exit"
argument_list|)
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|originrow
argument_list|,
name|origincol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"CONGRATULATIONS!\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"You won the game. That is a feat to be proud of.\n"
argument_list|)
expr_stmt|;
name|row
operator|=
name|originrow
operator|+
literal|5
expr_stmt|;
name|col
operator|=
name|origincol
expr_stmt|;
block|}
else|else
block|{
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"You got %d card"
argument_list|,
name|cardsoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|cardsoff
operator|>
literal|1
condition|)
name|printw
argument_list|(
literal|"s"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|" off    "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
name|row
operator|=
name|moverow
expr_stmt|;
name|col
operator|=
name|movecol
expr_stmt|;
block|}
do|do
block|{
name|getcmd
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
literal|"Play again (y or n)?"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|srcpile
operator|!=
literal|'y'
operator|&&
name|srcpile
operator|!=
literal|'n'
condition|)
do|;
name|errmsg
operator|=
name|TRUE
expr_stmt|;
name|clearmsg
argument_list|()
expr_stmt|;
if|if
condition|(
name|srcpile
operator|==
literal|'y'
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
else|else
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * procedure to clean up and exit  */
end_comment

begin_function
name|void
name|cleanup
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|total
operator|.
name|thinktime
operator|+=
literal|1
expr_stmt|;
name|status
operator|=
name|NOBOX
expr_stmt|;
name|updatebettinginfo
argument_list|()
expr_stmt|;
if|if
condition|(
name|dbfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|lseek
argument_list|(
name|dbfd
argument_list|,
name|uid
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|betinfo
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|dbfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|total
argument_list|,
sizeof|sizeof
argument_list|(
name|total
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dbfd
argument_list|)
expr_stmt|;
block|}
name|clear
argument_list|()
expr_stmt|;
name|move
argument_list|(
literal|22
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Field an interrupt.  */
end_comment

begin_function
name|void
name|askquit
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Really wish to quit?    "
argument_list|)
expr_stmt|;
do|do
block|{
name|getcmd
argument_list|(
name|moverow
argument_list|,
name|movecol
argument_list|,
literal|"y or n?"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|srcpile
operator|!=
literal|'y'
operator|&&
name|srcpile
operator|!=
literal|'n'
condition|)
do|;
name|clearmsg
argument_list|()
expr_stmt|;
if|if
condition|(
name|srcpile
operator|==
literal|'y'
condition|)
name|cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|askquit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Can you tell that this used to be a Pascal program?  */
end_comment

begin_function
name|int
name|main
parameter_list|()
block|{
name|dbfd
operator|=
name|open
argument_list|(
name|_PATH_SCORE
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
comment|/* revoke */
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAXLOAD
name|double
name|vec
index|[
literal|3
index|]
decl_stmt|;
name|loadav
argument_list|(
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|vec
index|[
literal|2
index|]
operator|>=
name|MAXLOAD
condition|)
block|{
name|puts
argument_list|(
literal|"The system load is too high.  Try again later."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|askquit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|initscr
argument_list|()
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|initall
argument_list|()
expr_stmt|;
name|instruct
argument_list|()
expr_stmt|;
name|makeboard
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|startgame
argument_list|()
expr_stmt|;
name|movecard
argument_list|()
expr_stmt|;
if|if
condition|(
name|finish
argument_list|()
condition|)
break|break;
if|if
condition|(
name|cardsoff
operator|==
literal|52
condition|)
name|makeboard
argument_list|()
expr_stmt|;
else|else
name|cleanupboard
argument_list|()
expr_stmt|;
block|}
name|cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

