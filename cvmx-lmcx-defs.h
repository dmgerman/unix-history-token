begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-lmcx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon lmcx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_LMCX_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_LMCX_TYPEDEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_BIST_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_BIST_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880000F0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_BIST_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880000F0ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_BIST_RESULT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_BIST_RESULT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880000F8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_BIST_RESULT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880000F8ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_CHAR_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_CHAR_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000220ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_CHAR_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000220ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_CHAR_MASK0
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_CHAR_MASK0(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000228ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_CHAR_MASK0
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000228ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_CHAR_MASK1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_CHAR_MASK1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000230ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_CHAR_MASK1
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000230ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_CHAR_MASK2
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_CHAR_MASK2(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000238ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_CHAR_MASK2
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000238ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_CHAR_MASK3
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_CHAR_MASK3(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000240ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_CHAR_MASK3
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000240ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_CHAR_MASK4
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_CHAR_MASK4(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000318ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_CHAR_MASK4
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000318ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_COMP_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_COMP_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000028ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_COMP_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000028ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_COMP_CTL2
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_COMP_CTL2(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880001B8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_COMP_CTL2
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880001B8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_CONFIG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_CONFIG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000188ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_CONFIG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000188ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_CONTROL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_CONTROL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000190ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_CONTROL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000190ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000010ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000010ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_CTL1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_CTL1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000090ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_CTL1
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000090ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_DCLK_CNT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_DCLK_CNT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880001E0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_DCLK_CNT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880001E0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_DCLK_CNT_HI
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_DCLK_CNT_HI(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000070ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_DCLK_CNT_HI
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000070ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_DCLK_CNT_LO
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_DCLK_CNT_LO(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000068ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_DCLK_CNT_LO
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000068ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_DCLK_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_DCLK_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880000B8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_DCLK_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880000B8ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_DDR2_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_DDR2_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000018ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_DDR2_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000018ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_DDR_PLL_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_DDR_PLL_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000258ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_DDR_PLL_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000258ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_DELAY_CFG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_DELAY_CFG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000088ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_DELAY_CFG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000088ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_DIMMX_PARAMS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_DIMMX_PARAMS(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000270ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_DIMMX_PARAMS
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000270ull) + (((offset)& 1) + ((block_id)& 0) * 0x0ull) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_DIMM_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_DIMM_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000310ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_DIMM_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000310ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_DLL_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_DLL_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880000C0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_DLL_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880000C0ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_DLL_CTL2
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_DLL_CTL2(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880001C8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_DLL_CTL2
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880001C8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_DLL_CTL3
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_DLL_CTL3(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000218ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_DLL_CTL3
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000218ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_DUAL_MEMCFG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_DUAL_MEMCFG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000098ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_DUAL_MEMCFG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000098ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_ECC_SYND
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_ECC_SYND(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000038ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_ECC_SYND
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000038ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_FADR
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_FADR(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000020ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_FADR
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000020ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_IFB_CNT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_IFB_CNT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880001D0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_IFB_CNT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880001D0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_IFB_CNT_HI
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_IFB_CNT_HI(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000050ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_IFB_CNT_HI
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000050ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_IFB_CNT_LO
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_IFB_CNT_LO(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000048ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_IFB_CNT_LO
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000048ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_INT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_INT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880001F0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_INT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880001F0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_INT_EN
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_INT_EN(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880001E8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_INT_EN
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880001E8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_MEM_CFG0
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_MEM_CFG0(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000000ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_MEM_CFG0
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000000ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_MEM_CFG1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_MEM_CFG1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000008ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_MEM_CFG1
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000008ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_MODEREG_PARAMS0
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_MODEREG_PARAMS0(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880001A8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_MODEREG_PARAMS0
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880001A8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_MODEREG_PARAMS1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_MODEREG_PARAMS1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000260ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_MODEREG_PARAMS1
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000260ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_NXM
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_NXM(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880000C8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_NXM
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880000C8ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_OPS_CNT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_OPS_CNT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880001D8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_OPS_CNT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880001D8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_OPS_CNT_HI
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_OPS_CNT_HI(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000060ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_OPS_CNT_HI
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000060ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_OPS_CNT_LO
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_OPS_CNT_LO(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000058ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_OPS_CNT_LO
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000058ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_PHY_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_PHY_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000210ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_PHY_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000210ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_PLL_BWCTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_PLL_BWCTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000040ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_PLL_BWCTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000040ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_PLL_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_PLL_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880000A8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_PLL_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880000A8ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_PLL_STATUS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_PLL_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880000B0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_PLL_STATUS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880000B0ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_READ_LEVEL_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_READ_LEVEL_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000140ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_READ_LEVEL_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000140ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_READ_LEVEL_DBG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_READ_LEVEL_DBG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000148ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_READ_LEVEL_DBG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000148ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_READ_LEVEL_RANKX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_READ_LEVEL_RANKX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000100ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0xC000000ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_READ_LEVEL_RANKX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000100ull) + (((offset)& 3) + ((block_id)& 1) * 0xC000000ull) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_RESET_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_RESET_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000180ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_RESET_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000180ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_RLEVEL_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_RLEVEL_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880002A0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_RLEVEL_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880002A0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_RLEVEL_DBG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_RLEVEL_DBG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880002A8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_RLEVEL_DBG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880002A8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_RLEVEL_RANKX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_RLEVEL_RANKX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000280ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_RLEVEL_RANKX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000280ull) + (((offset)& 3) + ((block_id)& 0) * 0x0ull) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_RODT_COMP_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_RODT_COMP_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880000A0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_RODT_COMP_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880000A0ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_RODT_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_RODT_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000078ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_RODT_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000078ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_RODT_MASK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_RODT_MASK(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000268ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_RODT_MASK
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000268ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_SLOT_CTL0
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_SLOT_CTL0(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880001F8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_SLOT_CTL0
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880001F8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_SLOT_CTL1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_SLOT_CTL1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000200ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_SLOT_CTL1
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000200ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_SLOT_CTL2
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_SLOT_CTL2(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000208ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_SLOT_CTL2
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000208ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_TIMING_PARAMS0
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_TIMING_PARAMS0(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000198ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_TIMING_PARAMS0
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000198ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_TIMING_PARAMS1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_TIMING_PARAMS1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880001A0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_TIMING_PARAMS1
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880001A0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_TRO_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_TRO_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000248ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_TRO_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000248ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_TRO_STAT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_TRO_STAT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000250ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_TRO_STAT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000250ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_WLEVEL_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_WLEVEL_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000300ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_WLEVEL_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000300ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_WLEVEL_DBG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_WLEVEL_DBG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000308ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_WLEVEL_DBG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000308ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_WLEVEL_RANKX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_WLEVEL_RANKX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880002B0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_WLEVEL_RANKX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880002B0ull) + (((offset)& 3) + ((block_id)& 0) * 0x0ull) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_WODT_CTL0
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_WODT_CTL0(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000030ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_WODT_CTL0
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000030ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_WODT_CTL1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_WODT_CTL1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180088000080ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x60000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_WODT_CTL1
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180088000080ull) + ((block_id)& 1) * 0x60000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LMCX_WODT_MASK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LMCX_WODT_MASK(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800880001B0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LMCX_WODT_MASK
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800880001B0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_lmc#_bist_ctl  *  * Notes:  * This controls BiST only for the memories that operate on DCLK.  The normal, chip-wide BiST flow  * controls BiST for the memories that operate on ECLK.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_bist_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_bist_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|start
range|:
literal|1
decl_stmt|;
comment|/**< A 0->1 transition causes BiST to run. */
else|#
directive|else
name|uint64_t
name|start
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_bist_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_bist_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_bist_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_bist_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_bist_ctl_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_bist_ctl
name|cvmx_lmcx_bist_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_bist_result  *  * Notes:  * Access to the internal BiST results  * Each bit is the BiST result of an individual memory (per bit, 0=pass and 1=fail).  */
end_comment

begin_union
union|union
name|cvmx_lmcx_bist_result
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_bist_result_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|csrd2e
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of CSRD2E memory (0=pass, !0=fail) */
name|uint64_t
name|csre2d
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of CSRE2D memory (0=pass, !0=fail) */
name|uint64_t
name|mwf
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of MWF memories (0=pass, !0=fail) */
name|uint64_t
name|mwd
range|:
literal|3
decl_stmt|;
comment|/**< BiST result of MWD memories (0=pass, !0=fail) */
name|uint64_t
name|mwc
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of MWC memories (0=pass, !0=fail) */
name|uint64_t
name|mrf
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of MRF memories (0=pass, !0=fail) */
name|uint64_t
name|mrd
range|:
literal|3
decl_stmt|;
comment|/**< BiST result of MRD memories (0=pass, !0=fail) */
else|#
directive|else
name|uint64_t
name|mrd
range|:
literal|3
decl_stmt|;
name|uint64_t
name|mrf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mwc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mwd
range|:
literal|3
decl_stmt|;
name|uint64_t
name|mwf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csre2d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csrd2e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_lmcx_bist_result_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|mwf
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of MWF memories (0=pass, !0=fail) */
name|uint64_t
name|mwd
range|:
literal|3
decl_stmt|;
comment|/**< BiST result of MWD memories (0=pass, !0=fail) */
name|uint64_t
name|mwc
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of MWC memories (0=pass, !0=fail) */
name|uint64_t
name|mrf
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of MRF memories (0=pass, !0=fail) */
name|uint64_t
name|mrd
range|:
literal|3
decl_stmt|;
comment|/**< BiST result of MRD memories (0=pass, !0=fail) */
else|#
directive|else
name|uint64_t
name|mrd
range|:
literal|3
decl_stmt|;
name|uint64_t
name|mrf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mwc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mwd
range|:
literal|3
decl_stmt|;
name|uint64_t
name|mwf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_lmcx_bist_result_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_bist_result_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_bist_result_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_bist_result_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_bist_result
name|cvmx_lmcx_bist_result_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_char_ctl  *  * LMC_CHAR_CTL = LMC Characterization Control  * This register is an assortment of various control fields needed to charecterize the DDR3 interface  */
end_comment

begin_union
union|union
name|cvmx_lmcx_char_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_char_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Enable characterization */
name|uint64_t
name|sel
range|:
literal|1
decl_stmt|;
comment|/**< Pattern select                                                          0 = PRBS                                                          1 = Programmable pattern */
name|uint64_t
name|prog
range|:
literal|8
decl_stmt|;
comment|/**< Programmable pattern */
name|uint64_t
name|prbs
range|:
literal|32
decl_stmt|;
comment|/**< PRBS Polynomial */
else|#
directive|else
name|uint64_t
name|prbs
range|:
literal|32
decl_stmt|;
name|uint64_t
name|prog
range|:
literal|8
decl_stmt|;
name|uint64_t
name|sel
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_char_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_char_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_char_ctl
name|cvmx_lmcx_char_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_char_mask0  *  * LMC_CHAR_MASK0 = LMC Characterization Mask0  * This register is an assortment of various control fields needed to charecterize the DDR3 interface  */
end_comment

begin_union
union|union
name|cvmx_lmcx_char_mask0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_char_mask0_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Mask for DQ0[63:0] */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_char_mask0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_char_mask0_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_char_mask0
name|cvmx_lmcx_char_mask0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_char_mask1  *  * LMC_CHAR_MASK1 = LMC Characterization Mask1  * This register is an assortment of various control fields needed to charecterize the DDR3 interface  */
end_comment

begin_union
union|union
name|cvmx_lmcx_char_mask1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_char_mask1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|8
decl_stmt|;
comment|/**< Mask for DQ0[71:64] */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_char_mask1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_char_mask1_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_char_mask1
name|cvmx_lmcx_char_mask1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_char_mask2  *  * LMC_CHAR_MASK2 = LMC Characterization Mask2  * This register is an assortment of various control fields needed to charecterize the DDR3 interface  */
end_comment

begin_union
union|union
name|cvmx_lmcx_char_mask2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_char_mask2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Mask for DQ1[63:0] */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_char_mask2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_char_mask2_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_char_mask2
name|cvmx_lmcx_char_mask2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_char_mask3  *  * LMC_CHAR_MASK3 = LMC Characterization Mask3  * This register is an assortment of various control fields needed to charecterize the DDR3 interface  */
end_comment

begin_union
union|union
name|cvmx_lmcx_char_mask3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_char_mask3_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|8
decl_stmt|;
comment|/**< Mask for DQ1[71:64] */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_char_mask3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_char_mask3_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_char_mask3
name|cvmx_lmcx_char_mask3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_char_mask4  *  * LMC_CHAR_MASK4 = LMC Characterization Mask4  * This register is an assortment of various control fields needed to charecterize the DDR3 interface  */
end_comment

begin_union
union|union
name|cvmx_lmcx_char_mask4
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_char_mask4_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
name|uint64_t
name|reset_n_mask
range|:
literal|1
decl_stmt|;
comment|/**< Mask for RESET_L */
name|uint64_t
name|a_mask
range|:
literal|16
decl_stmt|;
comment|/**< Mask for A[15:0] */
name|uint64_t
name|ba_mask
range|:
literal|3
decl_stmt|;
comment|/**< Mask for BA[2:0] */
name|uint64_t
name|we_n_mask
range|:
literal|1
decl_stmt|;
comment|/**< Mask for WE_N */
name|uint64_t
name|cas_n_mask
range|:
literal|1
decl_stmt|;
comment|/**< Mask for CAS_N */
name|uint64_t
name|ras_n_mask
range|:
literal|1
decl_stmt|;
comment|/**< Mask for RAS_N */
name|uint64_t
name|odt1_mask
range|:
literal|2
decl_stmt|;
comment|/**< Mask for ODT1 */
name|uint64_t
name|odt0_mask
range|:
literal|2
decl_stmt|;
comment|/**< Mask for ODT0 */
name|uint64_t
name|cs1_n_mask
range|:
literal|2
decl_stmt|;
comment|/**< Mask for CS1_N */
name|uint64_t
name|cs0_n_mask
range|:
literal|2
decl_stmt|;
comment|/**< Mask for CS0_N */
name|uint64_t
name|cke_mask
range|:
literal|2
decl_stmt|;
comment|/**< Mask for CKE* */
else|#
directive|else
name|uint64_t
name|cke_mask
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cs0_n_mask
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cs1_n_mask
range|:
literal|2
decl_stmt|;
name|uint64_t
name|odt0_mask
range|:
literal|2
decl_stmt|;
name|uint64_t
name|odt1_mask
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ras_n_mask
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cas_n_mask
range|:
literal|1
decl_stmt|;
name|uint64_t
name|we_n_mask
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ba_mask
range|:
literal|3
decl_stmt|;
name|uint64_t
name|a_mask
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reset_n_mask
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_char_mask4_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_char_mask4_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_char_mask4
name|cvmx_lmcx_char_mask4_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_comp_ctl  *  * LMC_COMP_CTL = LMC Compensation control  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_comp_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_comp_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|nctl_csr
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|nctl_clk
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|nctl_cmd
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|nctl_dat
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|pctl_csr
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|pctl_clk
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
name|uint64_t
name|pctl_clk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pctl_csr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|nctl_dat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|nctl_cmd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|nctl_clk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|nctl_csr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_lmcx_comp_ctl_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|nctl_csr
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|nctl_clk
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|nctl_cmd
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|nctl_dat
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|pctl_csr
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|pctl_clk
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|pctl_cmd
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|pctl_dat
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
else|#
directive|else
name|uint64_t
name|pctl_dat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pctl_cmd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pctl_clk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pctl_csr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|nctl_dat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|nctl_cmd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|nctl_clk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|nctl_csr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_lmcx_comp_ctl_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_lmcx_comp_ctl_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_lmcx_comp_ctl_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_lmcx_comp_ctl_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|nctl_csr
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|reserved_20_27
range|:
literal|8
decl_stmt|;
name|uint64_t
name|nctl_dat
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|pctl_csr
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|reserved_5_11
range|:
literal|7
decl_stmt|;
name|uint64_t
name|pctl_dat
range|:
literal|5
decl_stmt|;
comment|/**< Compensation control bits */
else|#
directive|else
name|uint64_t
name|pctl_dat
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_11
range|:
literal|7
decl_stmt|;
name|uint64_t
name|pctl_csr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|nctl_dat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_20_27
range|:
literal|8
decl_stmt|;
name|uint64_t
name|nctl_csr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_lmcx_comp_ctl_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_comp_ctl_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_comp_ctl_cn50xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_comp_ctl_cn50xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_comp_ctl_cn50xx
name|cn58xx
decl_stmt|;
struct|struct
name|cvmx_lmcx_comp_ctl_cn58xxp1
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|nctl_csr
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|reserved_20_27
range|:
literal|8
decl_stmt|;
name|uint64_t
name|nctl_dat
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|pctl_csr
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|reserved_4_11
range|:
literal|8
decl_stmt|;
name|uint64_t
name|pctl_dat
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
else|#
directive|else
name|uint64_t
name|pctl_dat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_11
range|:
literal|8
decl_stmt|;
name|uint64_t
name|pctl_csr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|nctl_dat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_20_27
range|:
literal|8
decl_stmt|;
name|uint64_t
name|nctl_csr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_comp_ctl
name|cvmx_lmcx_comp_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_comp_ctl2  *  * LMC_COMP_CTL2 = LMC Compensation control  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_comp_ctl2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_comp_ctl2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|ddr__ptune
range|:
literal|4
decl_stmt|;
comment|/**< DDR PCTL from compensation circuit                                                          The encoded value provides debug information for the                                                          compensation impedance on P-pullup */
name|uint64_t
name|ddr__ntune
range|:
literal|4
decl_stmt|;
comment|/**< DDR NCTL from compensation circuit                                                          The encoded value provides debug information for the                                                          compensation impedance on N-pulldown */
name|uint64_t
name|m180
range|:
literal|1
decl_stmt|;
comment|/**< Cap impedance at 180 Ohm (instead of 240 Ohm) */
name|uint64_t
name|byp
range|:
literal|1
decl_stmt|;
comment|/**< Bypass mode                                                          When set, PTUNE,NTUNE are the compensation setting.                                                          When clear, DDR_PTUNE,DDR_NTUNE are the compensation setting. */
name|uint64_t
name|ptune
range|:
literal|4
decl_stmt|;
comment|/**< PCTL impedance control in bypass mode */
name|uint64_t
name|ntune
range|:
literal|4
decl_stmt|;
comment|/**< NCTL impedance control in bypass mode */
name|uint64_t
name|rodt_ctl
range|:
literal|4
decl_stmt|;
comment|/**< NCTL RODT impedance control bits                                                          This field controls ODT values during a memory read                                                          on the Octeon side                                                          0000 = No ODT                                                          0001 = 20 ohm                                                          0010 = 30 ohm                                                          0011 = 40 ohm                                                          0100 = 60 ohm                                                          0101 = 120 ohm                                                          0110-1111 = Reserved */
name|uint64_t
name|cmd_ctl
range|:
literal|4
decl_stmt|;
comment|/**< Drive strength control for CMD/A/RESET_L/CKE* drivers                                                          0001 = 24 ohm                                                          0010 = 26.67 ohm                                                          0011 = 30 ohm                                                          0100 = 34.3 ohm                                                          0101 = 40 ohm                                                          0110 = 48 ohm                                                          0111 = 60 ohm                                                          0000,1000-1111 = Reserved */
name|uint64_t
name|ck_ctl
range|:
literal|4
decl_stmt|;
comment|/**< Drive strength control for CK/CS*_L/ODT drivers                                                          0001 = 24 ohm                                                          0010 = 26.67 ohm                                                          0011 = 30 ohm                                                          0100 = 34.3 ohm                                                          0101 = 40 ohm                                                          0110 = 48 ohm                                                          0111 = 60 ohm                                                          0000,1000-1111 = Reserved */
name|uint64_t
name|dqx_ctl
range|:
literal|4
decl_stmt|;
comment|/**< Drive strength control for DQ/DQS drivers                                                          0001 = 24 ohm                                                          0010 = 26.67 ohm                                                          0011 = 30 ohm                                                          0100 = 34.3 ohm                                                          0101 = 40 ohm                                                          0110 = 48 ohm                                                          0111 = 60 ohm                                                          0000,1000-1111 = Reserved */
else|#
directive|else
name|uint64_t
name|dqx_ctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ck_ctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|cmd_ctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rodt_ctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ntune
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ptune
range|:
literal|4
decl_stmt|;
name|uint64_t
name|byp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m180
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr__ntune
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ddr__ptune
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_comp_ctl2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_comp_ctl2_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_comp_ctl2
name|cvmx_lmcx_comp_ctl2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_config  *  * LMC_CONFIG = LMC Configuration Register  *  * This register controls certain parameters of  Memory Configuration  *  * Notes:  * a. Priority order for hardware writes to LMC*_CONFIG/LMC*_FADR/LMC*_ECC_SYND: DED error>= NXM error> SEC error  * b. The self refresh entry sequence(s) power the DLL up/down (depending on LMC*_MODEREG_PARAMS0[DLL])  * when LMC*_CONFIG[SREF_WITH_DLL] is set  * c. Prior to the self-refresh exit sequence, LMC*_MODEREG_PARAMS0 and LMC*_MODEREG_PARAMS1 should be re-programmed (if needed) to the  * appropriate values  *  * LMC Bringup Sequence:  * 1. SW must ensure there are no pending DRAM transactions and that the DDR PLL and the DLL have been initialized.  * 2. Write LMC*_COMP_CTL2, LMC*_CONTROL, LMC*_WODT_MASK, LMC*_DUAL_MEMCFG, LMC*_TIMING_PARAMS0, LMC*_TIMING_PARAMS1,  *    LMC*_MODEREG_PARAMS0, LMC*_MODEREG_PARAMS1, LMC*_RESET_CTL (with DDR3RST=0), LMC*_CONFIG (with INIT_START=0)  *    with appropriate values, if necessary.  * 3. Wait 200us, then write LMC*_RESET_CTL[DDR3RST] = 1.  * 4. Initialize all ranks at once by writing LMC*_CONFIG[RANKMASK][n] = 1, LMC*_CONFIG[INIT_STATUS][n] = 1, and LMC*_CONFIG[INIT_START] = 1  *    where n is a valid rank index for the specific board configuration.  * 5. for each rank n to be write-leveled [  *       if auto write-leveling is desired [  *           write LMC*_CONFIG[RANKMASK][n] = 1, LMC*_WLEVEL_CTL appropriately and LMC*_CONFIG[INIT_START] = 1  *           wait until LMC*_WLEVEL_RANKn[STATUS] = 3  *       ] else [  *           write LMC*_WLEVEL_RANKn with appropriate values  *       ]  *    ]  * 6. for each rank n to be read-leveled [  *       if auto read-leveling is desired [  *           write LMC*_CONFIG[RANKMASK][n] = 1, LMC*_RLEVEL_CTL appropriately and LMC*_CONFIG[INIT_START] = 1  *           wait until LMC*_RLEVEL_RANKn[STATUS] = 3  *       ] else [  *           write LMC*_RLEVEL_RANKn with appropriate values  *       ]  *    ]  */
end_comment

begin_union
union|union
name|cvmx_lmcx_config
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_config_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_59_63
range|:
literal|5
decl_stmt|;
name|uint64_t
name|early_unload_d1_r1
range|:
literal|1
decl_stmt|;
comment|/**< When set, unload the PHY silo one cycle early for Rank 3                                                          reads                                                          The recommended EARLY_UNLOAD_D1_R1 value can be calculated                                                          after the final LMC*_RLEVEL_RANK3[BYTE*] values are                                                          selected (as part of read-leveling initialization).                                                          Then, determine the largest read-leveling setting                                                          for rank 3 (i.e. calculate maxset=MAX(LMC*_RLEVEL_RANK3[BYTEi])                                                          across all i), then set EARLY_UNLOAD_D1_R1                                                          when the low two bits of this largest setting is not                                                          3 (i.e. EARLY_UNLOAD_D1_R1 = (maxset<1:0>!=3)). */
name|uint64_t
name|early_unload_d1_r0
range|:
literal|1
decl_stmt|;
comment|/**< When set, unload the PHY silo one cycle early for Rank 2                                                          reads                                                          The recommended EARLY_UNLOAD_D1_RO value can be calculated                                                          after the final LMC*_RLEVEL_RANK2[BYTE*] values are                                                          selected (as part of read-leveling initialization).                                                          Then, determine the largest read-leveling setting                                                          for rank 2 (i.e. calculate maxset=MAX(LMC*_RLEVEL_RANK2[BYTEi])                                                          across all i), then set EARLY_UNLOAD_D1_RO                                                          when the low two bits of this largest setting is not                                                          3 (i.e. EARLY_UNLOAD_D1_RO = (maxset<1:0>!=3)). */
name|uint64_t
name|early_unload_d0_r1
range|:
literal|1
decl_stmt|;
comment|/**< When set, unload the PHY silo one cycle early for Rank 1                                                          reads                                                          The recommended EARLY_UNLOAD_D0_R1 value can be calculated                                                          after the final LMC*_RLEVEL_RANK1[BYTE*] values are                                                          selected (as part of read-leveling initialization).                                                          Then, determine the largest read-leveling setting                                                          for rank 1 (i.e. calculate maxset=MAX(LMC*_RLEVEL_RANK1[BYTEi])                                                          across all i), then set EARLY_UNLOAD_D0_R1                                                          when the low two bits of this largest setting is not                                                          3 (i.e. EARLY_UNLOAD_D0_R1 = (maxset<1:0>!=3)). */
name|uint64_t
name|early_unload_d0_r0
range|:
literal|1
decl_stmt|;
comment|/**< When set, unload the PHY silo one cycle early for Rank 0                                                          reads.                                                          The recommended EARLY_UNLOAD_D0_R0 value can be calculated                                                          after the final LMC*_RLEVEL_RANK0[BYTE*] values are                                                          selected (as part of read-leveling initialization).                                                          Then, determine the largest read-leveling setting                                                          for rank 0 (i.e. calculate maxset=MAX(LMC*_RLEVEL_RANK0[BYTEi])                                                          across all i), then set EARLY_UNLOAD_D0_R0                                                          when the low two bits of this largest setting is not                                                          3 (i.e. EARLY_UNLOAD_D0_R0 = (maxset<1:0>!=3)). */
name|uint64_t
name|init_status
range|:
literal|4
decl_stmt|;
comment|/**< Indicates status of initialization                                                          INIT_STATUS[n] = 1 implies rank n has been initialized                                                          SW must set necessary INIT_STATUS bits with the                                                          same LMC*_CONFIG write that initiates                                                          power-up/init and self-refresh exit sequences                                                          (if the required INIT_STATUS bits are not already                                                          set before LMC initiates the sequence).                                                          INIT_STATUS determines the chip-selects that assert                                                          during refresh, ZQCS, and precharge power-down and                                                          self-refresh entry/exit SEQUENCE's. */
name|uint64_t
name|mirrmask
range|:
literal|4
decl_stmt|;
comment|/**< Mask determining which ranks are address-mirrored.                                                          MIRRMASK<n> = 1 means Rank n addresses are mirrored                                                          for 0<= n<= 3                                                          A mirrored read/write has these differences:                                                           - DDR_BA<1> is swapped with DDR_BA<0>                                                           - DDR_A<8> is swapped with DDR_A<7>                                                           - DDR_A<6> is swapped with DDR_A<5>                                                           - DDR_A<4> is swapped with DDR_A<3>                                                          When RANK_ENA=0, MIRRMASK<1> and MIRRMASK<3> MBZ */
name|uint64_t
name|rankmask
range|:
literal|4
decl_stmt|;
comment|/**< Mask to select rank to be leveled/initialized.                                                          To write-level/read-level/initialize rank i, set RANKMASK<i>                                                                          RANK_ENA=1               RANK_ENA=0                                                            RANKMASK<0> = DIMM0_CS0                DIMM0_CS0                                                            RANKMASK<1> = DIMM0_CS1                  MBZ                                                            RANKMASK<2> = DIMM1_CS0                DIMM1_CS0                                                            RANKMASK<3> = DIMM1_CS1                  MBZ                                                          For read/write leveling, each rank has to be leveled separately,                                                          so RANKMASK should only have one bit set.                                                          RANKMASK is not used during self-refresh entry/exit and                                                          precharge power-down entry/exit instruction sequences.                                                          When RANK_ENA=0, RANKMASK<1> and RANKMASK<3> MBZ */
name|uint64_t
name|rank_ena
range|:
literal|1
decl_stmt|;
comment|/**< RANK ena (for use with dual-rank DIMMs)                                                          For dual-rank DIMMs, the rank_ena bit will enable                                                          the drive of the CS*_L[1:0] and ODT_<1:0> pins differently based on the                                                          (pbank_lsb-1) address bit.                                                          Write 0 for SINGLE ranked DIMM's. */
name|uint64_t
name|sref_with_dll
range|:
literal|1
decl_stmt|;
comment|/**< Self-refresh entry/exit write MR1 and MR2                                                          When set, self-refresh entry and exit instruction sequences                                                          write MR1 and MR2 (in all ranks). (The writes occur before                                                          self-refresh entry, and after self-refresh exit.)                                                          When clear, self-refresh entry and exit instruction sequences                                                          do not write any registers in the DDR3 parts. */
name|uint64_t
name|early_dqx
range|:
literal|1
decl_stmt|;
comment|/**< Send DQx signals one CK cycle earlier for the case when                                                          the shortest DQx lines have a larger delay than the CK line */
name|uint64_t
name|sequence
range|:
literal|3
decl_stmt|;
comment|/**< Selects the sequence that LMC runs after a 0->1                                                          transition on LMC*_CONFIG[INIT_START].                                                          SEQUENCE=0=power-up/init:                                                            - RANKMASK selects participating ranks (should be all ranks with attached DRAM)                                                            - INIT_STATUS must equal RANKMASK                                                            - DDR_CKE* signals activated (if they weren't already active)                                                            - RDIMM register control words 0-15 will be written to RANKMASK-selected                                                                RDIMM's when LMC(0)_CONTROL[RDIMM_ENA]=1 and corresponding                                                                LMC*_DIMM_CTL[DIMM*_WMASK] bits are set. (Refer to LMC*_DIMM*_PARAMS and                                                                LMC*_DIMM_CTL descriptions below for more details.)                                                            - MR0, MR1, MR2, and MR3 will be written to selected ranks                                                          SEQUENCE=1=read-leveling:                                                            - RANKMASK selects the rank to be read-leveled                                                            - MR3 written to selected rank                                                          SEQUENCE=2=self-refresh entry:                                                            - INIT_STATUS selects participating ranks (should be all ranks with attached DRAM)                                                            - MR1 and MR2 will be written to selected ranks if SREF_WITH_DLL=1                                                            - DDR_CKE* signals de-activated                                                          SEQUENCE=3=self-refresh exit:                                                            - INIT_STATUS must be set to indicate participating ranks (should be all ranks with attached DRAM)                                                            - DDR_CKE* signals activated                                                            - MR0, MR1, MR2, and MR3 will be written to participating ranks if SREF_WITH_DLL=1                                                          SEQUENCE=4=precharge power-down entry:                                                            - INIT_STATUS selects participating ranks (should be all ranks with attached DRAM)                                                            - DDR_CKE* signals de-activated                                                          SEQUENCE=5=precharge power-down exit:                                                            - INIT_STATUS selects participating ranks (should be all ranks with attached DRAM)                                                            - DDR_CKE* signals activated                                                          SEQUENCE=6=write-leveling:                                                            - RANKMASK selects the rank to be write-leveled                                                            - INIT_STATUS must indicate all ranks with attached DRAM                                                            - MR1 and MR2 written to INIT_STATUS-selected ranks                                                          SEQUENCE=7=illegal                                                          Precharge power-down entry and exit SEQUENCE's may also                                                          be automatically generated by the HW when IDLEPOWER!=0.                                                          Self-refresh entry SEQUENCE's may also be automatically                                                          generated by hardware upon a chip warm or soft reset                                                          sequence when LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT] are set.                                                          LMC writes the LMC*_MODEREG_PARAMS0 and LMC*_MODEREG_PARAMS1 CSR field values                                                          to the Mode registers in the DRAM parts (i.e. MR0, MR1, MR2, and MR3) as part of some of these sequences.                                                          Refer to the LMC*_MODEREG_PARAMS0 and LMC*_MODEREG_PARAMS1 descriptions for more details.                                                          If there are two consecutive power-up/init's without                                                          a DRESET assertion between them, LMC asserts DDR_CKE* as part of                                                          the first power-up/init, and continues to assert DDR_CKE*                                                          through the remainder of the first and the second power-up/init.                                                          If DDR_CKE* deactivation and reactivation is needed for                                                          a second power-up/init, a DRESET assertion is required                                                          between the first and the second. */
name|uint64_t
name|ref_zqcs_int
range|:
literal|19
decl_stmt|;
comment|/**< Refresh& ZQCS interval represented in \#of 512 CK cycle                                                          increments. A Refresh sequence is triggered when bits                                                          [24:18] are equal to 0, and a ZQCS sequence is triggered                                                          when [36:18] are equal to 0.                                                          Program [24:18] to RND-DN(tREFI/clkPeriod/512)                                                          Program [36:25] to RND-DN(ZQCS_Interval/clkPeriod/(512*64)). Note                                                          that this value should always be greater than 32, to account for                                                          resistor calibration delays.                                                          000_00000000_00000000: RESERVED                                                          Max Refresh interval = 127 * 512           = 65024 CKs                                                          Max ZQCS interval    = (8*256*256-1) * 512 = 268434944 CKs ~ 335ms for a 800 MHz CK                                                          LMC*_CONFIG[INIT_STATUS] determines which ranks receive                                                          the REF / ZQCS. LMC does not send any refreshes / ZQCS's                                                          when LMC*_CONFIG[INIT_STATUS]=0. */
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< Reset oneshot pulse for refresh counter,                                                          and LMC*_OPS_CNT, LMC*_IFB_CNT, and LMC*_DCLK_CNT                                                          CSR's. SW should write this to a one, then re-write                                                          it to a zero to cause the reset. */
name|uint64_t
name|ecc_adr
range|:
literal|1
decl_stmt|;
comment|/**< Include memory reference address in the ECC calculation                                                          0=disabled, 1=enabled */
name|uint64_t
name|forcewrite
range|:
literal|4
decl_stmt|;
comment|/**< Force the oldest outstanding write to complete after                                                          having waited for 2^FORCEWRITE CK cycles.  0=disabled. */
name|uint64_t
name|idlepower
range|:
literal|3
decl_stmt|;
comment|/**< Enter precharge power-down mode after the memory                                                          controller has been idle for 2^(2+IDLEPOWER) CK cycles.                                                          0=disabled.                                                          This field should only be programmed after initialization.                                                          LMC*_MODEREG_PARAMS0[PPD] determines whether the DRAM DLL                                                          is disabled during the precharge power-down. */
name|uint64_t
name|pbank_lsb
range|:
literal|4
decl_stmt|;
comment|/**< DIMM address bit select                                                          Reverting to the explanation for ROW_LSB,                                                          PBank_LSB would be Row_LSB bit + \#rowbits + \#rankbits                                                          Decoding for pbank_lsb                                                               - 0000:DIMM = mem_adr[28]    / rank = mem_adr[27] (if RANK_ENA)                                                               - 0001:DIMM = mem_adr[29]    / rank = mem_adr[28]      "                                                               - 0010:DIMM = mem_adr[30]    / rank = mem_adr[29]      "                                                               - 0011:DIMM = mem_adr[31]    / rank = mem_adr[30]      "                                                               - 0100:DIMM = mem_adr[32]    / rank = mem_adr[31]      "                                                               - 0101:DIMM = mem_adr[33]    / rank = mem_adr[32]      "                                                               - 0110:DIMM = mem_adr[34]    / rank = mem_adr[33]      "                                                               - 0111:DIMM = 0              / rank = mem_adr[34]      "                                                               - 1000-1111: RESERVED                                                          For example, for a DIMM made of Samsung's k4b1g0846c-f7 1Gb (16M x 8 bit x 8 bank)                                                          DDR3 parts, the column address width = 10, so with                                                          10b of col, 3b of bus, 3b of bank, row_lsb = 16. So, row = mem_adr[29:16]                                                          With rank_ena = 0, pbank_lsb = 2                                                          With rank_ena = 1, pbank_lsb = 3 */
name|uint64_t
name|row_lsb
range|:
literal|3
decl_stmt|;
comment|/**< Row Address bit select                                                          Encoding used to determine which memory address                                                          bit position represents the low order DDR ROW address.                                                          The processor's memory address[34:7] needs to be                                                          translated to DRAM addresses (bnk,row,col,rank and DIMM)                                                          and that is a function of the following:                                                          1. Datapath Width (64)                                                          2. \# Banks (8)                                                          3. \# Column Bits of the memory part - spec'd indirectly                                                          by this register.                                                          4. \# Row Bits of the memory part - spec'd indirectly                                                          5. \# Ranks in a DIMM - spec'd by RANK_ENA                                                          6. \# DIMM's in the system by the register below (PBANK_LSB).                                                          Decoding for row_lsb                                                               - 000: row_lsb = mem_adr[14]                                                               - 001: row_lsb = mem_adr[15]                                                               - 010: row_lsb = mem_adr[16]                                                               - 011: row_lsb = mem_adr[17]                                                               - 100: row_lsb = mem_adr[18]                                                               - 101: row_lsb = mem_adr[19]                                                               - 110: row_lsb = mem_adr[20]                                                               - 111: RESERVED                                                          For example, for a DIMM made of Samsung's k4b1g0846c-f7 1Gb (16M x 8 bit x 8 bank)                                                          DDR3 parts, the column address width = 10, so with                                                          10b of col, 3b of bus, 3b of bank, row_lsb = 16. So, row = mem_adr[29:16] */
name|uint64_t
name|ecc_ena
range|:
literal|1
decl_stmt|;
comment|/**< ECC Enable: When set will enable the 8b ECC                                                          check/correct logic. Should be 1 when used with DIMMs                                                          with ECC. 0, otherwise.                                                          When this mode is turned on, DQ[71:64]                                                          on writes, will contain the ECC code generated for                                                          the 64 bits of data which will                                                          written in the memory and then later on reads, used                                                          to check for Single bit error (which will be auto-                                                          corrected) and Double Bit error (which will be                                                          reported). When not turned on, DQ[71:64]                                                          are driven to 0.  Please refer to SEC_ERR, DED_ERR,                                                          LMC*_FADR, and LMC*_ECC_SYND registers                                                          for diagnostics information when there is an error. */
name|uint64_t
name|init_start
range|:
literal|1
decl_stmt|;
comment|/**< A 0->1 transition starts the DDR memory sequence that is                                                          selected by LMC*_CONFIG[SEQUENCE].  This register is a                                                          oneshot and clears itself each time it is set. */
else|#
directive|else
name|uint64_t
name|init_start
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ecc_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|row_lsb
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pbank_lsb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|idlepower
range|:
literal|3
decl_stmt|;
name|uint64_t
name|forcewrite
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ecc_adr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ref_zqcs_int
range|:
literal|19
decl_stmt|;
name|uint64_t
name|sequence
range|:
literal|3
decl_stmt|;
name|uint64_t
name|early_dqx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sref_with_dll
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rank_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rankmask
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mirrmask
range|:
literal|4
decl_stmt|;
name|uint64_t
name|init_status
range|:
literal|4
decl_stmt|;
name|uint64_t
name|early_unload_d0_r0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|early_unload_d0_r1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|early_unload_d1_r0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|early_unload_d1_r1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_59_63
range|:
literal|5
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_config_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_lmcx_config_cn63xxp1
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_55_63
range|:
literal|9
decl_stmt|;
name|uint64_t
name|init_status
range|:
literal|4
decl_stmt|;
comment|/**< Indicates status of initialization                                                          INIT_STATUS[n] = 1 implies rank n has been initialized                                                          SW must set necessary INIT_STATUS bits with the                                                          same LMC*_CONFIG write that initiates                                                          power-up/init and self-refresh exit sequences                                                          (if the required INIT_STATUS bits are not already                                                          set before LMC initiates the sequence).                                                          INIT_STATUS determines the chip-selects that assert                                                          during refresh, ZQCS, and precharge power-down and                                                          self-refresh entry/exit SEQUENCE's. */
name|uint64_t
name|mirrmask
range|:
literal|4
decl_stmt|;
comment|/**< Mask determining which ranks are address-mirrored.                                                          MIRRMASK<n> = 1 means Rank n addresses are mirrored                                                          for 0<= n<= 3                                                          A mirrored read/write has these differences:                                                           - DDR_BA<1> is swapped with DDR_BA<0>                                                           - DDR_A<8> is swapped with DDR_A<7>                                                           - DDR_A<6> is swapped with DDR_A<5>                                                           - DDR_A<4> is swapped with DDR_A<3>                                                          When RANK_ENA=0, MIRRMASK<1> and MIRRMASK<3> MBZ */
name|uint64_t
name|rankmask
range|:
literal|4
decl_stmt|;
comment|/**< Mask to select rank to be leveled/initialized.                                                          To write-level/read-level/initialize rank i, set RANKMASK<i>                                                                          RANK_ENA=1               RANK_ENA=0                                                            RANKMASK<0> = DIMM0_CS0                DIMM0_CS0                                                            RANKMASK<1> = DIMM0_CS1                  MBZ                                                            RANKMASK<2> = DIMM1_CS0                DIMM1_CS0                                                            RANKMASK<3> = DIMM1_CS1                  MBZ                                                          For read/write leveling, each rank has to be leveled separately,                                                          so RANKMASK should only have one bit set.                                                          RANKMASK is not used during self-refresh entry/exit and                                                          precharge power-down entry/exit instruction sequences.                                                          When RANK_ENA=0, RANKMASK<1> and RANKMASK<3> MBZ */
name|uint64_t
name|rank_ena
range|:
literal|1
decl_stmt|;
comment|/**< RANK ena (for use with dual-rank DIMMs)                                                          For dual-rank DIMMs, the rank_ena bit will enable                                                          the drive of the CS*_L[1:0] and ODT_<1:0> pins differently based on the                                                          (pbank_lsb-1) address bit.                                                          Write 0 for SINGLE ranked DIMM's. */
name|uint64_t
name|sref_with_dll
range|:
literal|1
decl_stmt|;
comment|/**< Self-refresh entry/exit write MR1 and MR2                                                          When set, self-refresh entry and exit instruction sequences                                                          write MR1 and MR2 (in all ranks). (The writes occur before                                                          self-refresh entry, and after self-refresh exit.)                                                          When clear, self-refresh entry and exit instruction sequences                                                          do not write any registers in the DDR3 parts. */
name|uint64_t
name|early_dqx
range|:
literal|1
decl_stmt|;
comment|/**< Send DQx signals one CK cycle earlier for the case when                                                          the shortest DQx lines have a larger delay than the CK line */
name|uint64_t
name|sequence
range|:
literal|3
decl_stmt|;
comment|/**< Selects the sequence that LMC runs after a 0->1                                                          transition on LMC*_CONFIG[INIT_START].                                                          SEQUENCE=0=power-up/init:                                                            - RANKMASK selects participating ranks (should be all ranks with attached DRAM)                                                            - INIT_STATUS must equal RANKMASK                                                            - DDR_CKE* signals activated (if they weren't already active)                                                            - RDIMM register control words 0-15 will be written to RANKMASK-selected                                                                RDIMM's when LMC(0)_CONTROL[RDIMM_ENA]=1 and corresponding                                                                LMC*_DIMM_CTL[DIMM*_WMASK] bits are set. (Refer to LMC*_DIMM*_PARAMS and                                                                LMC*_DIMM_CTL descriptions below for more details.)                                                            - MR0, MR1, MR2, and MR3 will be written to selected ranks                                                          SEQUENCE=1=read-leveling:                                                            - RANKMASK selects the rank to be read-leveled                                                            - MR3 written to selected rank                                                          SEQUENCE=2=self-refresh entry:                                                            - INIT_STATUS selects participating ranks (should be all ranks with attached DRAM)                                                            - MR1 and MR2 will be written to selected ranks if SREF_WITH_DLL=1                                                            - DDR_CKE* signals de-activated                                                          SEQUENCE=3=self-refresh exit:                                                            - INIT_STATUS must be set to indicate participating ranks (should be all ranks with attached DRAM)                                                            - DDR_CKE* signals activated                                                            - MR0, MR1, MR2, and MR3 will be written to participating ranks if SREF_WITH_DLL=1                                                          SEQUENCE=4=precharge power-down entry:                                                            - INIT_STATUS selects participating ranks (should be all ranks with attached DRAM)                                                            - DDR_CKE* signals de-activated                                                          SEQUENCE=5=precharge power-down exit:                                                            - INIT_STATUS selects participating ranks (should be all ranks with attached DRAM)                                                            - DDR_CKE* signals activated                                                          SEQUENCE=6=write-leveling:                                                            - RANKMASK selects the rank to be write-leveled                                                            - INIT_STATUS must indicate all ranks with attached DRAM                                                            - MR1 and MR2 written to INIT_STATUS-selected ranks                                                          SEQUENCE=7=illegal                                                          Precharge power-down entry and exit SEQUENCE's may also                                                          be automatically generated by the HW when IDLEPOWER!=0.                                                          Self-refresh entry SEQUENCE's may also be automatically                                                          generated by hardware upon a chip warm or soft reset                                                          sequence when LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT] are set.                                                          LMC writes the LMC*_MODEREG_PARAMS0 and LMC*_MODEREG_PARAMS1 CSR field values                                                          to the Mode registers in the DRAM parts (i.e. MR0, MR1, MR2, and MR3) as part of some of these sequences.                                                          Refer to the LMC*_MODEREG_PARAMS0 and LMC*_MODEREG_PARAMS1 descriptions for more details.                                                          If there are two consecutive power-up/init's without                                                          a DRESET assertion between them, LMC asserts DDR_CKE* as part of                                                          the first power-up/init, and continues to assert DDR_CKE*                                                          through the remainder of the first and the second power-up/init.                                                          If DDR_CKE* deactivation and reactivation is needed for                                                          a second power-up/init, a DRESET assertion is required                                                          between the first and the second. */
name|uint64_t
name|ref_zqcs_int
range|:
literal|19
decl_stmt|;
comment|/**< Refresh& ZQCS interval represented in \#of 512 CK cycle                                                          increments. A Refresh sequence is triggered when bits                                                          [24:18] are equal to 0, and a ZQCS sequence is triggered                                                          when [36:18] are equal to 0.                                                          Program [24:18] to RND-DN(tREFI/clkPeriod/512)                                                          Program [36:25] to RND-DN(ZQCS_Interval/clkPeriod/(512*64)). Note                                                          that this value should always be greater than 32, to account for                                                          resistor calibration delays.                                                          000_00000000_00000000: RESERVED                                                          Max Refresh interval = 127 * 512           = 65024 CKs                                                          Max ZQCS interval    = (8*256*256-1) * 512 = 268434944 CKs ~ 335ms for a 800 MHz CK                                                          LMC*_CONFIG[INIT_STATUS] determines which ranks receive                                                          the REF / ZQCS. LMC does not send any refreshes / ZQCS's                                                          when LMC*_CONFIG[INIT_STATUS]=0. */
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< Reset oneshot pulse for refresh counter,                                                          and LMC*_OPS_CNT, LMC*_IFB_CNT, and LMC*_DCLK_CNT                                                          CSR's. SW should write this to a one, then re-write                                                          it to a zero to cause the reset. */
name|uint64_t
name|ecc_adr
range|:
literal|1
decl_stmt|;
comment|/**< Include memory reference address in the ECC calculation                                                          0=disabled, 1=enabled */
name|uint64_t
name|forcewrite
range|:
literal|4
decl_stmt|;
comment|/**< Force the oldest outstanding write to complete after                                                          having waited for 2^FORCEWRITE CK cycles.  0=disabled. */
name|uint64_t
name|idlepower
range|:
literal|3
decl_stmt|;
comment|/**< Enter precharge power-down mode after the memory                                                          controller has been idle for 2^(2+IDLEPOWER) CK cycles.                                                          0=disabled.                                                          This field should only be programmed after initialization.                                                          LMC*_MODEREG_PARAMS0[PPD] determines whether the DRAM DLL                                                          is disabled during the precharge power-down. */
name|uint64_t
name|pbank_lsb
range|:
literal|4
decl_stmt|;
comment|/**< DIMM address bit select                                                          Reverting to the explanation for ROW_LSB,                                                          PBank_LSB would be Row_LSB bit + \#rowbits + \#rankbits                                                          Decoding for pbank_lsb                                                               - 0000:DIMM = mem_adr[28]    / rank = mem_adr[27] (if RANK_ENA)                                                               - 0001:DIMM = mem_adr[29]    / rank = mem_adr[28]      "                                                               - 0010:DIMM = mem_adr[30]    / rank = mem_adr[29]      "                                                               - 0011:DIMM = mem_adr[31]    / rank = mem_adr[30]      "                                                               - 0100:DIMM = mem_adr[32]    / rank = mem_adr[31]      "                                                               - 0101:DIMM = mem_adr[33]    / rank = mem_adr[32]      "                                                               - 0110:DIMM = mem_adr[34]    / rank = mem_adr[33]      "                                                               - 0111:DIMM = 0              / rank = mem_adr[34]      "                                                               - 1000-1111: RESERVED                                                          For example, for a DIMM made of Samsung's k4b1g0846c-f7 1Gb (16M x 8 bit x 8 bank)                                                          DDR3 parts, the column address width = 10, so with                                                          10b of col, 3b of bus, 3b of bank, row_lsb = 16. So, row = mem_adr[29:16]                                                          With rank_ena = 0, pbank_lsb = 2                                                          With rank_ena = 1, pbank_lsb = 3 */
name|uint64_t
name|row_lsb
range|:
literal|3
decl_stmt|;
comment|/**< Row Address bit select                                                          Encoding used to determine which memory address                                                          bit position represents the low order DDR ROW address.                                                          The processor's memory address[34:7] needs to be                                                          translated to DRAM addresses (bnk,row,col,rank and DIMM)                                                          and that is a function of the following:                                                          1. Datapath Width (64)                                                          2. \# Banks (8)                                                          3. \# Column Bits of the memory part - spec'd indirectly                                                          by this register.                                                          4. \# Row Bits of the memory part - spec'd indirectly                                                          5. \# Ranks in a DIMM - spec'd by RANK_ENA                                                          6. \# DIMM's in the system by the register below (PBANK_LSB).                                                          Decoding for row_lsb                                                               - 000: row_lsb = mem_adr[14]                                                               - 001: row_lsb = mem_adr[15]                                                               - 010: row_lsb = mem_adr[16]                                                               - 011: row_lsb = mem_adr[17]                                                               - 100: row_lsb = mem_adr[18]                                                               - 101: row_lsb = mem_adr[19]                                                               - 110: row_lsb = mem_adr[20]                                                               - 111: RESERVED                                                          For example, for a DIMM made of Samsung's k4b1g0846c-f7 1Gb (16M x 8 bit x 8 bank)                                                          DDR3 parts, the column address width = 10, so with                                                          10b of col, 3b of bus, 3b of bank, row_lsb = 16. So, row = mem_adr[29:16] */
name|uint64_t
name|ecc_ena
range|:
literal|1
decl_stmt|;
comment|/**< ECC Enable: When set will enable the 8b ECC                                                          check/correct logic. Should be 1 when used with DIMMs                                                          with ECC. 0, otherwise.                                                          When this mode is turned on, DQ[71:64]                                                          on writes, will contain the ECC code generated for                                                          the 64 bits of data which will                                                          written in the memory and then later on reads, used                                                          to check for Single bit error (which will be auto-                                                          corrected) and Double Bit error (which will be                                                          reported). When not turned on, DQ[71:64]                                                          are driven to 0.  Please refer to SEC_ERR, DED_ERR,                                                          LMC*_FADR, and LMC*_ECC_SYND registers                                                          for diagnostics information when there is an error. */
name|uint64_t
name|init_start
range|:
literal|1
decl_stmt|;
comment|/**< A 0->1 transition starts the DDR memory sequence that is                                                          selected by LMC*_CONFIG[SEQUENCE].  This register is a                                                          oneshot and clears itself each time it is set. */
else|#
directive|else
name|uint64_t
name|init_start
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ecc_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|row_lsb
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pbank_lsb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|idlepower
range|:
literal|3
decl_stmt|;
name|uint64_t
name|forcewrite
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ecc_adr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ref_zqcs_int
range|:
literal|19
decl_stmt|;
name|uint64_t
name|sequence
range|:
literal|3
decl_stmt|;
name|uint64_t
name|early_dqx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sref_with_dll
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rank_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rankmask
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mirrmask
range|:
literal|4
decl_stmt|;
name|uint64_t
name|init_status
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_55_63
range|:
literal|9
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_config
name|cvmx_lmcx_config_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_control  *  * LMC_CONTROL = LMC Control  * This register is an assortment of various control fields needed by the memory controller  */
end_comment

begin_union
union|union
name|cvmx_lmcx_control
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_control_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|rodt_bprch
range|:
literal|1
decl_stmt|;
comment|/**< When set, the turn-off time for the ODT pin during a                                                          RD cmd is delayed an additional CK cycle. */
name|uint64_t
name|wodt_bprch
range|:
literal|1
decl_stmt|;
comment|/**< When set, the turn-off time for the ODT pin during a                                                          WR cmd is delayed an additional CK cycle. */
name|uint64_t
name|bprch
range|:
literal|2
decl_stmt|;
comment|/**< Back Porch Enable: When set, the turn-on time for                                                          the default DDR_DQ/DQS drivers is delayed an additional BPRCH                                                          CK cycles.                                                          00 = 0 CKs                                                          01 = 1 CKs                                                          10 = 2 CKs                                                          11 = 3 CKs */
name|uint64_t
name|ext_zqcs_dis
range|:
literal|1
decl_stmt|;
comment|/**< Disable (external) auto-zqcs calibration                                                          When clear, LMC runs external ZQ calibration                                                          every LMC*_CONFIG[REF_ZQCS_INT] CK cycles. */
name|uint64_t
name|int_zqcs_dis
range|:
literal|1
decl_stmt|;
comment|/**< Disable (internal) auto-zqcs calibration                                                          When clear, LMC runs internal ZQ calibration                                                          every LMC*_CONFIG[REF_ZQCS_INT] CK cycles. */
name|uint64_t
name|auto_dclkdis
range|:
literal|1
decl_stmt|;
comment|/**< When 1, LMC will automatically shut off its internal                                                          clock to conserve power when there is no traffic. Note                                                          that this has no effect on the DDR3 PHY and pads clocks. */
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
comment|/**< If (XOR_BANK == 1), then                                                           bank[2:0]=address[9:7] ^ address[14:12]                                                          else                                                           bank[2:0]=address[9:7] */
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of consecutive writes to service before                                                          forcing reads to interrupt. */
name|uint64_t
name|nxm_write_en
range|:
literal|1
decl_stmt|;
comment|/**< NXM Write mode                                                          When clear, LMC discards writes to addresses that don't                                                          exist in the DRAM (as defined by LMC*_NXM configuration).                                                          When set, LMC completes writes to addresses that don't                                                          exist in the DRAM at an aliased address. */
name|uint64_t
name|elev_prio_dis
range|:
literal|1
decl_stmt|;
comment|/**< Disable elevate priority logic.                                                          When set, writes are sent in                                                          regardless of priority information from L2C. */
name|uint64_t
name|inorder_wr
range|:
literal|1
decl_stmt|;
comment|/**< Send writes in order(regardless of priority) */
name|uint64_t
name|inorder_rd
range|:
literal|1
decl_stmt|;
comment|/**< Send reads in order (regardless of priority) */
name|uint64_t
name|throttle_wr
range|:
literal|1
decl_stmt|;
comment|/**< When set, use at most one IFB for writes */
name|uint64_t
name|throttle_rd
range|:
literal|1
decl_stmt|;
comment|/**< When set, use at most one IFB for reads */
name|uint64_t
name|fprch2
range|:
literal|2
decl_stmt|;
comment|/**< Front Porch Enable: When set, the turn-off                                                          time for the default DDR_DQ/DQS drivers is FPRCH2 CKs earlier.                                                          00 = 0 CKs                                                          01 = 1 CKs                                                          10 = 2 CKs                                                          11 = RESERVED */
name|uint64_t
name|pocas
range|:
literal|1
decl_stmt|;
comment|/**< Enable the Posted CAS feature of DDR3.                                                          This bit must be set whenever LMC*_MODEREG_PARAMS0[AL]!=0,                                                          and clear otherwise. */
name|uint64_t
name|ddr2t
range|:
literal|1
decl_stmt|;
comment|/**< Turn on the DDR 2T mode. 2 CK cycle window for CMD and                                                          address. This mode helps relieve setup time pressure                                                          on the Address and command bus which nominally have                                                          a very large fanout. Please refer to Micron's tech                                                          note tn_47_01 titled "DDR2-533 Memory Design Guide                                                          for Two Dimm Unbuffered Systems" for physical details. */
name|uint64_t
name|bwcnt
range|:
literal|1
decl_stmt|;
comment|/**< Bus utilization counter Clear.                                                          Clears the LMC*_OPS_CNT, LMC*_IFB_CNT, and                                                          LMC*_DCLK_CNT registers. SW should first write this                                                          field to a one, then write this field to a zero to                                                          clear the CSR's. */
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
comment|/**< Registered DIMM Enable - When set allows the use                                                          of JEDEC Registered DIMMs which require address and                                                          control bits to be registered in the controller. */
else|#
directive|else
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bwcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr2t
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pocas
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fprch2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|throttle_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|throttle_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|elev_prio_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nxm_write_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
name|uint64_t
name|auto_dclkdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_zqcs_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_zqcs_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bprch
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wodt_bprch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rodt_bprch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_control_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_control_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_control
name|cvmx_lmcx_control_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_ctl  *  * LMC_CTL = LMC Control  * This register is an assortment of various control fields needed by the memory controller  */
end_comment

begin_union
union|union
name|cvmx_lmcx_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ddr__nctl
range|:
literal|4
decl_stmt|;
comment|/**< DDR nctl from compensation circuit                                                          The encoded value on this will adjust the drive strength                                                          of the DDR DQ pulldns. */
name|uint64_t
name|ddr__pctl
range|:
literal|4
decl_stmt|;
comment|/**< DDR pctl from compensation circuit                                                          The encoded value on this will adjust the drive strength                                                          of the DDR DQ pullup. */
name|uint64_t
name|slow_scf
range|:
literal|1
decl_stmt|;
comment|/**< Should be cleared to zero */
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
comment|/**< If (XOR_BANK == 1), then                                                            bank[n:0]=address[n+7:7] ^ address[n+7+5:7+5]                                                          else                                                            bank[n:0]=address[n+7:7]                                                          where n=1 for a 4 bank part and n=2 for an 8 bank part */
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of consecutive writes to service before                                                          allowing reads to interrupt. */
name|uint64_t
name|pll_div2
range|:
literal|1
decl_stmt|;
comment|/**< PLL Div2. */
name|uint64_t
name|pll_bypass
range|:
literal|1
decl_stmt|;
comment|/**< PLL Bypass. */
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
comment|/**< Registered DIMM Enable - When set allows the use                                                          of JEDEC Registered DIMMs which require Write                                                          data to be registered in the controller. */
name|uint64_t
name|r2r_slot
range|:
literal|1
decl_stmt|;
comment|/**< R2R Slot Enable: When set, all read-to-read trans                                                          will slot an additional 1 cycle data bus bubble to                                                          avoid DQ/DQS bus contention. This is only a CYA bit,                                                          in case the "built-in" DIMM and RANK crossing logic                                                          which should auto-detect and perfectly slot                                                          read-to-reads to the same DIMM/RANK. */
name|uint64_t
name|inorder_mwf
range|:
literal|1
decl_stmt|;
comment|/**< Reads as zero */
name|uint64_t
name|inorder_mrf
range|:
literal|1
decl_stmt|;
comment|/**< Always clear to zero */
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fprch2
range|:
literal|1
decl_stmt|;
comment|/**< Front Porch Enable: When set, the turn-off                                                          time for the DDR_DQ/DQS drivers is 1 dclk earlier.                                                          This bit should typically be set. */
name|uint64_t
name|bprch
range|:
literal|1
decl_stmt|;
comment|/**< Back Porch Enable: When set, the turn-on time for                                                          the DDR_DQ/DQS drivers is delayed an additional DCLK                                                          cycle. This should be set to one whenever both SILO_HC                                                          and SILO_QC are set. */
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
comment|/**< SILO Latency: On reads, determines how many additional                                                          dclks to wait (on top of TCL+1+TSKW) before pulling                                                          data out of the pad silos.                                                              - 00: illegal                                                              - 01: 1 dclks                                                              - 10: 2 dclks                                                              - 11: illegal                                                          This should always be set to 1. */
name|uint64_t
name|tskw
range|:
literal|2
decl_stmt|;
comment|/**< This component is a representation of total BOARD                                                          DELAY on DQ (used in the controller to determine the                                                          R->W spacing to avoid DQS/DQ bus conflicts). Enter                                                          the largest of the per byte Board delay                                                              - 00: 0 dclk                                                              - 01: 1 dclks                                                              - 10: 2 dclks                                                              - 11: 3 dclks */
name|uint64_t
name|qs_dic
range|:
literal|2
decl_stmt|;
comment|/**< DDR2 Termination Resistor Setting                                                          A non Zero value in this register                                                          enables the On Die Termination (ODT) in DDR parts.                                                          These two bits are loaded into the RTT                                                          portion of the EMRS register bits A6& A2. If DDR2's                                                          termination (for the memory's DQ/DQS/DM pads) is not                                                          desired, set it to 00. If it is, chose between                                                          01 for 75 ohm and 10 for 150 ohm termination.                                                              00 = ODT Disabled                                                              01 = 75 ohm Termination                                                              10 = 150 ohm Termination                                                              11 = 50 ohm Termination                                                          Octeon, on writes, by default, drives the 4/8 ODT                                                          pins (64/128b mode) based on what the masks                                                          (LMC_WODT_CTL) are programmed to.                                                          LMC_DDR2_CTL->ODT_ENA enables Octeon to drive ODT pins                                                          for READS. LMC_RODT_CTL needs to be programmed based                                                          on the system's needs for ODT. */
name|uint64_t
name|dic
range|:
literal|2
decl_stmt|;
comment|/**< Drive Strength Control:                                                          DIC[0] is                                                          loaded into the Extended Mode Register (EMRS) A1 bit                                                          during initialization.                                                              0 = Normal                                                              1 = Reduced                                                          DIC[1] is used to load into EMRS                                                          bit 10 - DQSN Enable/Disable field. By default, we                                                          program the DDR's to drive the DQSN also. Set it to                                                          1 if DQSN should be Hi-Z.                                                              0 - DQSN Enable                                                              1 - DQSN Disable */
else|#
directive|else
name|uint64_t
name|dic
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qs_dic
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tskw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bprch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fprch2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|inorder_mrf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_mwf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|r2r_slot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pll_bypass
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pll_div2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
name|uint64_t
name|slow_scf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr__pctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ddr__nctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_lmcx_ctl_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ddr__nctl
range|:
literal|4
decl_stmt|;
comment|/**< DDR nctl from compensation circuit                                                          The encoded value on this will adjust the drive strength                                                          of the DDR DQ pulldns. */
name|uint64_t
name|ddr__pctl
range|:
literal|4
decl_stmt|;
comment|/**< DDR pctl from compensation circuit                                                          The encoded value on this will adjust the drive strength                                                          of the DDR DQ pullup. */
name|uint64_t
name|slow_scf
range|:
literal|1
decl_stmt|;
comment|/**< 1=SCF has pass1 latency, 0=SCF has 1 cycle lower latency                                                          when compared to pass1 */
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
comment|/**< If (XOR_BANK == 1), then                                                            bank[n:0]=address[n+7:7] ^ address[n+7+5:7+5]                                                          else                                                            bank[n:0]=address[n+7:7]                                                          where n=1 for a 4 bank part and n=2 for an 8 bank part */
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of consecutive writes to service before                                                          allowing reads to interrupt. */
name|uint64_t
name|pll_div2
range|:
literal|1
decl_stmt|;
comment|/**< PLL Div2. */
name|uint64_t
name|pll_bypass
range|:
literal|1
decl_stmt|;
comment|/**< PLL Bypass. */
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
comment|/**< Registered DIMM Enable - When set allows the use                                                          of JEDEC Registered DIMMs which require Write                                                          data to be registered in the controller. */
name|uint64_t
name|r2r_slot
range|:
literal|1
decl_stmt|;
comment|/**< R2R Slot Enable: When set, all read-to-read trans                                                          will slot an additional 1 cycle data bus bubble to                                                          avoid DQ/DQS bus contention. This is only a CYA bit,                                                          in case the "built-in" DIMM and RANK crossing logic                                                          which should auto-detect and perfectly slot                                                          read-to-reads to the same DIMM/RANK. */
name|uint64_t
name|inorder_mwf
range|:
literal|1
decl_stmt|;
comment|/**< Reads as zero */
name|uint64_t
name|inorder_mrf
range|:
literal|1
decl_stmt|;
comment|/**< Always set to zero */
name|uint64_t
name|dreset
range|:
literal|1
decl_stmt|;
comment|/**< Dclk domain reset.  The reset signal that is used by the                                                          Dclk domain is (DRESET || ECLK_RESET). */
name|uint64_t
name|mode32b
range|:
literal|1
decl_stmt|;
comment|/**< 32b data Path Mode                                                          Set to 1 if we use only 32 DQ pins                                                          0 for 16b DQ mode. */
name|uint64_t
name|fprch2
range|:
literal|1
decl_stmt|;
comment|/**< Front Porch Enable: When set, the turn-off                                                          time for the DDR_DQ/DQS drivers is 1 dclk earlier.                                                          This bit should typically be set. */
name|uint64_t
name|bprch
range|:
literal|1
decl_stmt|;
comment|/**< Back Porch Enable: When set, the turn-on time for                                                          the DDR_DQ/DQS drivers is delayed an additional DCLK                                                          cycle. This should be set to one whenever both SILO_HC                                                          and SILO_QC are set. */
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
comment|/**< SILO Latency: On reads, determines how many additional                                                          dclks to wait (on top of TCL+1+TSKW) before pulling                                                          data out of the pad silos.                                                              - 00: illegal                                                              - 01: 1 dclks                                                              - 10: 2 dclks                                                              - 11: illegal                                                          This should always be set to 1. */
name|uint64_t
name|tskw
range|:
literal|2
decl_stmt|;
comment|/**< This component is a representation of total BOARD                                                          DELAY on DQ (used in the controller to determine the                                                          R->W spacing to avoid DQS/DQ bus conflicts). Enter                                                          the largest of the per byte Board delay                                                              - 00: 0 dclk                                                              - 01: 1 dclks                                                              - 10: 2 dclks                                                              - 11: 3 dclks */
name|uint64_t
name|qs_dic
range|:
literal|2
decl_stmt|;
comment|/**< QS Drive Strength Control (DDR1):& DDR2 Termination Resistor Setting                                                          When in DDR2, a non Zero value in this register                                                          enables the On Die Termination (ODT) in DDR parts.                                                          These two bits are loaded into the RTT                                                          portion of the EMRS register bits A6& A2. If DDR2's                                                          termination (for the memory's DQ/DQS/DM pads) is not                                                          desired, set it to 00. If it is, chose between                                                          01 for 75 ohm and 10 for 150 ohm termination.                                                              00 = ODT Disabled                                                              01 = 75 ohm Termination                                                              10 = 150 ohm Termination                                                              11 = 50 ohm Termination                                                          Octeon, on writes, by default, drives the 8 ODT                                                          pins based on what the masks (LMC_WODT_CTL1& 2)                                                          are programmed to. LMC_DDR2_CTL->ODT_ENA                                                          enables Octeon to drive ODT pins for READS.                                                          LMC_RODT_CTL needs to be programmed based on                                                          the system's needs for ODT. */
name|uint64_t
name|dic
range|:
literal|2
decl_stmt|;
comment|/**< Drive Strength Control:                                                          For DDR-I/II Mode, DIC[0] is                                                          loaded into the Extended Mode Register (EMRS) A1 bit                                                          during initialization. (see DDR-I data sheet EMRS                                                          description)                                                              0 = Normal                                                              1 = Reduced                                                          For DDR-II Mode, DIC[1] is used to load into EMRS                                                          bit 10 - DQSN Enable/Disable field. By default, we                                                          program the DDR's to drive the DQSN also. Set it to                                                          1 if DQSN should be Hi-Z.                                                              0 - DQSN Enable                                                              1 - DQSN Disable */
else|#
directive|else
name|uint64_t
name|dic
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qs_dic
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tskw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bprch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fprch2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mode32b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dreset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_mrf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_mwf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|r2r_slot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pll_bypass
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pll_div2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
name|uint64_t
name|slow_scf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr__pctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ddr__nctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_lmcx_ctl_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_lmcx_ctl_cn38xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ddr__nctl
range|:
literal|4
decl_stmt|;
comment|/**< DDR nctl from compensation circuit                                                          The encoded value on this will adjust the drive strength                                                          of the DDR DQ pulldns. */
name|uint64_t
name|ddr__pctl
range|:
literal|4
decl_stmt|;
comment|/**< DDR pctl from compensation circuit                                                          The encoded value on this will adjust the drive strength                                                          of the DDR DQ pullup. */
name|uint64_t
name|slow_scf
range|:
literal|1
decl_stmt|;
comment|/**< 1=SCF has pass1 latency, 0=SCF has 1 cycle lower latency                                                          when compared to pass1                                                          NOTE - This bit has NO effect in PASS1 */
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
comment|/**< If (XOR_BANK == 1), then                                                            bank[n:0]=address[n+7:7] ^ address[n+7+5:7+5]                                                          else                                                            bank[n:0]=address[n+7:7]                                                          where n=1 for a 4 bank part and n=2 for an 8 bank part */
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of consecutive writes to service before                                                          allowing reads to interrupt. */
name|uint64_t
name|reserved_16_17
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
comment|/**< Registered DIMM Enable - When set allows the use                                                          of JEDEC Registered DIMMs which require Write                                                          data to be registered in the controller. */
name|uint64_t
name|r2r_slot
range|:
literal|1
decl_stmt|;
comment|/**< R2R Slot Enable: When set, all read-to-read trans                                                          will slot an additional 1 cycle data bus bubble to                                                          avoid DQ/DQS bus contention. This is only a CYA bit,                                                          in case the "built-in" DIMM and RANK crossing logic                                                          which should auto-detect and perfectly slot                                                          read-to-reads to the same DIMM/RANK. */
name|uint64_t
name|inorder_mwf
range|:
literal|1
decl_stmt|;
comment|/**< When set, forces LMC_MWF (writes) into strict, in-order                                                          mode.  When clear, writes may be serviced out of order                                                          (optimized to keep multiple banks active).                                                          This bit is ONLY to be set at power-on and                                                          should not be set for normal use.                                                          NOTE: For PASS1, set as follows:                                                              DDR-I -> 1                                                              DDR-II -> 0                                                          For Pass2, this bit is RA0, write ignore (this feature                                                          is permanently disabled) */
name|uint64_t
name|inorder_mrf
range|:
literal|1
decl_stmt|;
comment|/**< When set, forces LMC_MRF (reads) into strict, in-order                                                          mode.  When clear, reads may be serviced out of order                                                          (optimized to keep multiple banks active).                                                          This bit is ONLY to be set at power-on and                                                          should not be set for normal use.                                                          NOTE: For PASS1, set as follows:                                                              DDR-I -> 1                                                              DDR-II -> 0                                                          For Pass2, this bit should be written ZERO for                                                          DDR I& II */
name|uint64_t
name|set_zero
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. Always Set this Bit to Zero */
name|uint64_t
name|mode128b
range|:
literal|1
decl_stmt|;
comment|/**< 128b data Path Mode                                                          Set to 1 if we use all 128 DQ pins                                                          0 for 64b DQ mode. */
name|uint64_t
name|fprch2
range|:
literal|1
decl_stmt|;
comment|/**< Front Porch Enable: When set, the turn-off                                                          time for the DDR_DQ/DQS drivers is 1 dclk earlier.                                                          This bit should typically be set. */
name|uint64_t
name|bprch
range|:
literal|1
decl_stmt|;
comment|/**< Back Porch Enable: When set, the turn-on time for                                                          the DDR_DQ/DQS drivers is delayed an additional DCLK                                                          cycle. This should be set to one whenever both SILO_HC                                                          and SILO_QC are set. */
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
comment|/**< SILO Latency: On reads, determines how many additional                                                          dclks to wait (on top of TCL+1+TSKW) before pulling                                                          data out of the pad silos.                                                              - 00: illegal                                                              - 01: 1 dclks                                                              - 10: 2 dclks                                                              - 11: illegal                                                          This should always be set to 1. */
name|uint64_t
name|tskw
range|:
literal|2
decl_stmt|;
comment|/**< This component is a representation of total BOARD                                                          DELAY on DQ (used in the controller to determine the                                                          R->W spacing to avoid DQS/DQ bus conflicts). Enter                                                          the largest of the per byte Board delay                                                              - 00: 0 dclk                                                              - 01: 1 dclks                                                              - 10: 2 dclks                                                              - 11: 3 dclks */
name|uint64_t
name|qs_dic
range|:
literal|2
decl_stmt|;
comment|/**< QS Drive Strength Control (DDR1):& DDR2 Termination Resistor Setting                                                          When in DDR2, a non Zero value in this register                                                          enables the On Die Termination (ODT) in DDR parts.                                                          These two bits are loaded into the RTT                                                          portion of the EMRS register bits A6& A2. If DDR2's                                                          termination (for the memory's DQ/DQS/DM pads) is not                                                          desired, set it to 00. If it is, chose between                                                          01 for 75 ohm and 10 for 150 ohm termination.                                                              00 = ODT Disabled                                                              01 = 75 ohm Termination                                                              10 = 150 ohm Termination                                                              11 = 50 ohm Termination                                                          Octeon, on writes, by default, drives the 4/8 ODT                                                          pins (64/128b mode) based on what the masks                                                          (LMC_WODT_CTL) are programmed to.                                                          LMC_DDR2_CTL->ODT_ENA enables Octeon to drive ODT pins                                                          for READS. LMC_RODT_CTL needs to be programmed based                                                          on the system's needs for ODT. */
name|uint64_t
name|dic
range|:
literal|2
decl_stmt|;
comment|/**< Drive Strength Control:                                                          For DDR-I/II Mode, DIC[0] is                                                          loaded into the Extended Mode Register (EMRS) A1 bit                                                          during initialization. (see DDR-I data sheet EMRS                                                          description)                                                              0 = Normal                                                              1 = Reduced                                                          For DDR-II Mode, DIC[1] is used to load into EMRS                                                          bit 10 - DQSN Enable/Disable field. By default, we                                                          program the DDR's to drive the DQSN also. Set it to                                                          1 if DQSN should be Hi-Z.                                                              0 - DQSN Enable                                                              1 - DQSN Disable */
else|#
directive|else
name|uint64_t
name|dic
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qs_dic
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tskw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bprch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fprch2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mode128b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|set_zero
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_mrf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_mwf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|r2r_slot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_17
range|:
literal|2
decl_stmt|;
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
name|uint64_t
name|slow_scf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr__pctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ddr__nctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_lmcx_ctl_cn38xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_lmcx_ctl_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ddr__nctl
range|:
literal|4
decl_stmt|;
comment|/**< DDR nctl from compensation circuit                                                          The encoded value on this will adjust the drive strength                                                          of the DDR DQ pulldns. */
name|uint64_t
name|ddr__pctl
range|:
literal|4
decl_stmt|;
comment|/**< DDR pctl from compensation circuit                                                          The encoded value on this will adjust the drive strength                                                          of the DDR DQ pullup. */
name|uint64_t
name|slow_scf
range|:
literal|1
decl_stmt|;
comment|/**< Should be cleared to zero */
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
comment|/**< If (XOR_BANK == 1), then                                                            bank[n:0]=address[n+7:7] ^ address[n+7+5:7+5]                                                          else                                                            bank[n:0]=address[n+7:7]                                                          where n=1 for a 4 bank part and n=2 for an 8 bank part */
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of consecutive writes to service before                                                          allowing reads to interrupt. */
name|uint64_t
name|reserved_17_17
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pll_bypass
range|:
literal|1
decl_stmt|;
comment|/**< PLL Bypass. */
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
comment|/**< Registered DIMM Enable - When set allows the use                                                          of JEDEC Registered DIMMs which require Write                                                          data to be registered in the controller. */
name|uint64_t
name|r2r_slot
range|:
literal|1
decl_stmt|;
comment|/**< R2R Slot Enable: When set, all read-to-read trans                                                          will slot an additional 1 cycle data bus bubble to                                                          avoid DQ/DQS bus contention. This is only a CYA bit,                                                          in case the "built-in" DIMM and RANK crossing logic                                                          which should auto-detect and perfectly slot                                                          read-to-reads to the same DIMM/RANK. */
name|uint64_t
name|inorder_mwf
range|:
literal|1
decl_stmt|;
comment|/**< Reads as zero */
name|uint64_t
name|inorder_mrf
range|:
literal|1
decl_stmt|;
comment|/**< Always clear to zero */
name|uint64_t
name|dreset
range|:
literal|1
decl_stmt|;
comment|/**< Dclk domain reset.  The reset signal that is used by the                                                          Dclk domain is (DRESET || ECLK_RESET). */
name|uint64_t
name|mode32b
range|:
literal|1
decl_stmt|;
comment|/**< 32b data Path Mode                                                          Set to 1 if we use 32 DQ pins                                                          0 for 16b DQ mode. */
name|uint64_t
name|fprch2
range|:
literal|1
decl_stmt|;
comment|/**< Front Porch Enable: When set, the turn-off                                                          time for the DDR_DQ/DQS drivers is 1 dclk earlier.                                                          This bit should typically be set. */
name|uint64_t
name|bprch
range|:
literal|1
decl_stmt|;
comment|/**< Back Porch Enable: When set, the turn-on time for                                                          the DDR_DQ/DQS drivers is delayed an additional DCLK                                                          cycle. This should be set to one whenever both SILO_HC                                                          and SILO_QC are set. */
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
comment|/**< SILO Latency: On reads, determines how many additional                                                          dclks to wait (on top of TCL+1+TSKW) before pulling                                                          data out of the pad silos.                                                              - 00: illegal                                                              - 01: 1 dclks                                                              - 10: 2 dclks                                                              - 11: illegal                                                          This should always be set to 1. */
name|uint64_t
name|tskw
range|:
literal|2
decl_stmt|;
comment|/**< This component is a representation of total BOARD                                                          DELAY on DQ (used in the controller to determine the                                                          R->W spacing to avoid DQS/DQ bus conflicts). Enter                                                          the largest of the per byte Board delay                                                              - 00: 0 dclk                                                              - 01: 1 dclks                                                              - 10: 2 dclks                                                              - 11: 3 dclks */
name|uint64_t
name|qs_dic
range|:
literal|2
decl_stmt|;
comment|/**< DDR2 Termination Resistor Setting                                                          When in DDR2, a non Zero value in this register                                                          enables the On Die Termination (ODT) in DDR parts.                                                          These two bits are loaded into the RTT                                                          portion of the EMRS register bits A6& A2. If DDR2's                                                          termination (for the memory's DQ/DQS/DM pads) is not                                                          desired, set it to 00. If it is, chose between                                                          01 for 75 ohm and 10 for 150 ohm termination.                                                              00 = ODT Disabled                                                              01 = 75 ohm Termination                                                              10 = 150 ohm Termination                                                              11 = 50 ohm Termination                                                          Octeon, on writes, by default, drives the ODT                                                          pins based on what the masks                                                          (LMC_WODT_CTL) are programmed to.                                                          LMC_DDR2_CTL->ODT_ENA enables Octeon to drive ODT pins                                                          for READS. LMC_RODT_CTL needs to be programmed based                                                          on the system's needs for ODT. */
name|uint64_t
name|dic
range|:
literal|2
decl_stmt|;
comment|/**< Drive Strength Control:                                                          DIC[0] is                                                          loaded into the Extended Mode Register (EMRS) A1 bit                                                          during initialization.                                                              0 = Normal                                                              1 = Reduced                                                          DIC[1] is used to load into EMRS                                                          bit 10 - DQSN Enable/Disable field. By default, we                                                          program the DDR's to drive the DQSN also. Set it to                                                          1 if DQSN should be Hi-Z.                                                              0 - DQSN Enable                                                              1 - DQSN Disable */
else|#
directive|else
name|uint64_t
name|dic
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qs_dic
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tskw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bprch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fprch2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mode32b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dreset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_mrf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_mwf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|r2r_slot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pll_bypass
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_17
range|:
literal|1
decl_stmt|;
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
name|uint64_t
name|slow_scf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr__pctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ddr__nctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_lmcx_ctl_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ddr__nctl
range|:
literal|4
decl_stmt|;
comment|/**< DDR nctl from compensation circuit                                                          The encoded value on this will adjust the drive strength                                                          of the DDR DQ pulldns. */
name|uint64_t
name|ddr__pctl
range|:
literal|4
decl_stmt|;
comment|/**< DDR pctl from compensation circuit                                                          The encoded value on this will adjust the drive strength                                                          of the DDR DQ pullup. */
name|uint64_t
name|slow_scf
range|:
literal|1
decl_stmt|;
comment|/**< Always clear to zero */
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
comment|/**< If (XOR_BANK == 1), then                                                            bank[n:0]=address[n+7:7] ^ address[n+7+5:7+5]                                                          else                                                            bank[n:0]=address[n+7:7]                                                          where n=1 for a 4 bank part and n=2 for an 8 bank part */
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of consecutive writes to service before                                                          allowing reads to interrupt. */
name|uint64_t
name|reserved_16_17
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
comment|/**< Registered DIMM Enable - When set allows the use                                                          of JEDEC Registered DIMMs which require Write                                                          data to be registered in the controller. */
name|uint64_t
name|r2r_slot
range|:
literal|1
decl_stmt|;
comment|/**< R2R Slot Enable: When set, all read-to-read trans                                                          will slot an additional 1 cycle data bus bubble to                                                          avoid DQ/DQS bus contention. This is only a CYA bit,                                                          in case the "built-in" DIMM and RANK crossing logic                                                          which should auto-detect and perfectly slot                                                          read-to-reads to the same DIMM/RANK. */
name|uint64_t
name|inorder_mwf
range|:
literal|1
decl_stmt|;
comment|/**< Reads as zero */
name|uint64_t
name|inorder_mrf
range|:
literal|1
decl_stmt|;
comment|/**< Always set to zero */
name|uint64_t
name|dreset
range|:
literal|1
decl_stmt|;
comment|/**< MBZ                                                          THIS IS OBSOLETE.  Use LMC_DLL_CTL[DRESET] instead. */
name|uint64_t
name|mode32b
range|:
literal|1
decl_stmt|;
comment|/**< 32b data Path Mode                                                          Set to 1 if we use only 32 DQ pins                                                          0 for 64b DQ mode. */
name|uint64_t
name|fprch2
range|:
literal|1
decl_stmt|;
comment|/**< Front Porch Enable: When set, the turn-off                                                          time for the DDR_DQ/DQS drivers is 1 dclk earlier.                                                          This bit should typically be set. */
name|uint64_t
name|bprch
range|:
literal|1
decl_stmt|;
comment|/**< Back Porch Enable: When set, the turn-on time for                                                          the DDR_DQ/DQS drivers is delayed an additional DCLK                                                          cycle. This should be set to one whenever both SILO_HC                                                          and SILO_QC are set. */
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
comment|/**< SILO Latency: On reads, determines how many additional                                                          dclks to wait (on top of TCL+1+TSKW) before pulling                                                          data out of the pad silos.                                                              - 00: illegal                                                              - 01: 1 dclks                                                              - 10: 2 dclks                                                              - 11: illegal                                                          This should always be set to 1.                                                          THIS IS OBSOLETE.  Use READ_LEVEL_RANK instead. */
name|uint64_t
name|tskw
range|:
literal|2
decl_stmt|;
comment|/**< This component is a representation of total BOARD                                                          DELAY on DQ (used in the controller to determine the                                                          R->W spacing to avoid DQS/DQ bus conflicts). Enter                                                          the largest of the per byte Board delay                                                              - 00: 0 dclk                                                              - 01: 1 dclks                                                              - 10: 2 dclks                                                              - 11: 3 dclks                                                          THIS IS OBSOLETE.  Use READ_LEVEL_RANK instead. */
name|uint64_t
name|qs_dic
range|:
literal|2
decl_stmt|;
comment|/**< DDR2 Termination Resistor Setting                                                          When in DDR2, a non Zero value in this register                                                          enables the On Die Termination (ODT) in DDR parts.                                                          These two bits are loaded into the RTT                                                          portion of the EMRS register bits A6& A2. If DDR2's                                                          termination (for the memory's DQ/DQS/DM pads) is not                                                          desired, set it to 00. If it is, chose between                                                          01 for 75 ohm and 10 for 150 ohm termination.                                                              00 = ODT Disabled                                                              01 = 75 ohm Termination                                                              10 = 150 ohm Termination                                                              11 = 50 ohm Termination                                                          Octeon, on writes, by default, drives the 4/8 ODT                                                          pins (64/128b mode) based on what the masks                                                          (LMC_WODT_CTL0& 1) are programmed to.                                                          LMC_DDR2_CTL->ODT_ENA enables Octeon to drive ODT pins                                                          for READS. LMC_RODT_CTL needs to be programmed based                                                          on the system's needs for ODT. */
name|uint64_t
name|dic
range|:
literal|2
decl_stmt|;
comment|/**< Drive Strength Control:                                                          DIC[0] is                                                          loaded into the Extended Mode Register (EMRS) A1 bit                                                          during initialization.                                                              0 = Normal                                                              1 = Reduced                                                          DIC[1] is used to load into EMRS                                                          bit 10 - DQSN Enable/Disable field. By default, we                                                          program the DDR's to drive the DQSN also. Set it to                                                          1 if DQSN should be Hi-Z.                                                              0 - DQSN Enable                                                              1 - DQSN Disable */
else|#
directive|else
name|uint64_t
name|dic
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qs_dic
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tskw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bprch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fprch2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mode32b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dreset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_mrf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_mwf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|r2r_slot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_17
range|:
literal|2
decl_stmt|;
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
name|uint64_t
name|slow_scf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr__pctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ddr__nctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_lmcx_ctl_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_ctl_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ctl_cn52xx
name|cn56xxp1
decl_stmt|;
struct|struct
name|cvmx_lmcx_ctl_cn58xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ddr__nctl
range|:
literal|4
decl_stmt|;
comment|/**< DDR nctl from compensation circuit                                                          The encoded value on this will adjust the drive strength                                                          of the DDR DQ pulldns. */
name|uint64_t
name|ddr__pctl
range|:
literal|4
decl_stmt|;
comment|/**< DDR pctl from compensation circuit                                                          The encoded value on this will adjust the drive strength                                                          of the DDR DQ pullup. */
name|uint64_t
name|slow_scf
range|:
literal|1
decl_stmt|;
comment|/**< Should be cleared to zero */
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
comment|/**< If (XOR_BANK == 1), then                                                            bank[n:0]=address[n+7:7] ^ address[n+7+5:7+5]                                                          else                                                            bank[n:0]=address[n+7:7]                                                          where n=1 for a 4 bank part and n=2 for an 8 bank part */
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of consecutive writes to service before                                                          allowing reads to interrupt. */
name|uint64_t
name|reserved_16_17
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
comment|/**< Registered DIMM Enable - When set allows the use                                                          of JEDEC Registered DIMMs which require Write                                                          data to be registered in the controller. */
name|uint64_t
name|r2r_slot
range|:
literal|1
decl_stmt|;
comment|/**< R2R Slot Enable: When set, all read-to-read trans                                                          will slot an additional 1 cycle data bus bubble to                                                          avoid DQ/DQS bus contention. This is only a CYA bit,                                                          in case the "built-in" DIMM and RANK crossing logic                                                          which should auto-detect and perfectly slot                                                          read-to-reads to the same DIMM/RANK. */
name|uint64_t
name|inorder_mwf
range|:
literal|1
decl_stmt|;
comment|/**< Reads as zero */
name|uint64_t
name|inorder_mrf
range|:
literal|1
decl_stmt|;
comment|/**< Always clear to zero */
name|uint64_t
name|dreset
range|:
literal|1
decl_stmt|;
comment|/**< Dclk domain reset.  The reset signal that is used by the                                                          Dclk domain is (DRESET || ECLK_RESET). */
name|uint64_t
name|mode128b
range|:
literal|1
decl_stmt|;
comment|/**< 128b data Path Mode                                                          Set to 1 if we use all 128 DQ pins                                                          0 for 64b DQ mode. */
name|uint64_t
name|fprch2
range|:
literal|1
decl_stmt|;
comment|/**< Front Porch Enable: When set, the turn-off                                                          time for the DDR_DQ/DQS drivers is 1 dclk earlier.                                                          This bit should typically be set. */
name|uint64_t
name|bprch
range|:
literal|1
decl_stmt|;
comment|/**< Back Porch Enable: When set, the turn-on time for                                                          the DDR_DQ/DQS drivers is delayed an additional DCLK                                                          cycle. This should be set to one whenever both SILO_HC                                                          and SILO_QC are set. */
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
comment|/**< SILO Latency: On reads, determines how many additional                                                          dclks to wait (on top of TCL+1+TSKW) before pulling                                                          data out of the pad silos.                                                              - 00: illegal                                                              - 01: 1 dclks                                                              - 10: 2 dclks                                                              - 11: illegal                                                          This should always be set to 1. */
name|uint64_t
name|tskw
range|:
literal|2
decl_stmt|;
comment|/**< This component is a representation of total BOARD                                                          DELAY on DQ (used in the controller to determine the                                                          R->W spacing to avoid DQS/DQ bus conflicts). Enter                                                          the largest of the per byte Board delay                                                              - 00: 0 dclk                                                              - 01: 1 dclks                                                              - 10: 2 dclks                                                              - 11: 3 dclks */
name|uint64_t
name|qs_dic
range|:
literal|2
decl_stmt|;
comment|/**< DDR2 Termination Resistor Setting                                                          A non Zero value in this register                                                          enables the On Die Termination (ODT) in DDR parts.                                                          These two bits are loaded into the RTT                                                          portion of the EMRS register bits A6& A2. If DDR2's                                                          termination (for the memory's DQ/DQS/DM pads) is not                                                          desired, set it to 00. If it is, chose between                                                          01 for 75 ohm and 10 for 150 ohm termination.                                                              00 = ODT Disabled                                                              01 = 75 ohm Termination                                                              10 = 150 ohm Termination                                                              11 = 50 ohm Termination                                                          Octeon, on writes, by default, drives the 4/8 ODT                                                          pins (64/128b mode) based on what the masks                                                          (LMC_WODT_CTL) are programmed to.                                                          LMC_DDR2_CTL->ODT_ENA enables Octeon to drive ODT pins                                                          for READS. LMC_RODT_CTL needs to be programmed based                                                          on the system's needs for ODT. */
name|uint64_t
name|dic
range|:
literal|2
decl_stmt|;
comment|/**< Drive Strength Control:                                                          DIC[0] is                                                          loaded into the Extended Mode Register (EMRS) A1 bit                                                          during initialization.                                                              0 = Normal                                                              1 = Reduced                                                          DIC[1] is used to load into EMRS                                                          bit 10 - DQSN Enable/Disable field. By default, we                                                          program the DDR's to drive the DQSN also. Set it to                                                          1 if DQSN should be Hi-Z.                                                              0 - DQSN Enable                                                              1 - DQSN Disable */
else|#
directive|else
name|uint64_t
name|dic
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qs_dic
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tskw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bprch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fprch2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mode128b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dreset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_mrf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_mwf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|r2r_slot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_17
range|:
literal|2
decl_stmt|;
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
name|uint64_t
name|slow_scf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr__pctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ddr__nctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_lmcx_ctl_cn58xx
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_ctl
name|cvmx_lmcx_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_ctl1  *  * LMC_CTL1 = LMC Control1  * This register is an assortment of various control fields needed by the memory controller  */
end_comment

begin_union
union|union
name|cvmx_lmcx_ctl1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_ctl1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
name|uint64_t
name|ecc_adr
range|:
literal|1
decl_stmt|;
comment|/**< Include memory reference address in the ECC calculation                                                          0=disabled, 1=enabled */
name|uint64_t
name|forcewrite
range|:
literal|4
decl_stmt|;
comment|/**< Force the oldest outstanding write to complete after                                                          having waited for 2^FORCEWRITE cycles.  0=disabled. */
name|uint64_t
name|idlepower
range|:
literal|3
decl_stmt|;
comment|/**< Enter power-down mode after the memory controller has                                                          been idle for 2^(2+IDLEPOWER) cycles.  0=disabled. */
name|uint64_t
name|sequence
range|:
literal|3
decl_stmt|;
comment|/**< Instruction sequence that is run after a 0->1 transition                                                          on LMC_MEM_CFG0[INIT_START].                                                          0=DDR2 power-up/init, 1=read-leveling                                                          2=self-refresh entry, 3=self-refresh exit,                                                          4=power-down entry, 5=power-down exit, 6=7=illegal */
name|uint64_t
name|sil_mode
range|:
literal|1
decl_stmt|;
comment|/**< Read Silo mode.  0=envelope, 1=self-timed. */
name|uint64_t
name|dcc_enable
range|:
literal|1
decl_stmt|;
comment|/**< Duty Cycle Corrector Enable.                                                          0=disable, 1=enable                                                          If the memory part does not support DCC, then this bit                                                          must be set to 0. */
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|data_layout
range|:
literal|2
decl_stmt|;
comment|/**< Logical data layout per DQ byte lane:                                                          In 32b mode, this setting has no effect and the data                                                          layout DQ[35:0] is the following:                                                              [E[3:0], D[31:24], D[23:16], D[15:8], D[7:0]]                                                          In 16b mode, the DQ[35:0] layouts are the following:                                                          0 - [0[3:0], 0[7:0], [0[7:2], E[1:0]], D[15:8], D[7:0]]                                                          1 - [0[3:0], [0[7:2], E[1:0]], D[15:8], D[7:0], 0[7:0]]                                                          2 - [[0[1:0], E[1:0]], D[15:8], D[7:0], 0[7:0], 0[7:0]]                                                          where E means ecc, D means data, and 0 means unused                                                          (ignored on reads and written as 0 on writes) */
else|#
directive|else
name|uint64_t
name|data_layout
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dcc_enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sil_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sequence
range|:
literal|3
decl_stmt|;
name|uint64_t
name|idlepower
range|:
literal|3
decl_stmt|;
name|uint64_t
name|forcewrite
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ecc_adr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_lmcx_ctl1_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|data_layout
range|:
literal|2
decl_stmt|;
comment|/**< Logical data layout per DQ byte lane:                                                          In 32b mode, this setting has no effect and the data                                                          layout DQ[35:0] is the following:                                                              [E[3:0], D[31:24], D[23:16], D[15:8], D[7:0]]                                                          In 16b mode, the DQ[35:0] layouts are the following:                                                          0 - [0[3:0], 0[7:0], [0[7:2], E[1:0]], D[15:8], D[7:0]]                                                          1 - [0[3:0], [0[7:2], E[1:0]], D[15:8], D[7:0], 0[7:0]]                                                          2 - [[0[1:0], E[1:0]], D[15:8], D[7:0], 0[7:0], 0[7:0]]                                                          where E means ecc, D means data, and 0 means unused                                                          (ignored on reads and written as 0 on writes) */
else|#
directive|else
name|uint64_t
name|data_layout
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_lmcx_ctl1_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|sil_mode
range|:
literal|1
decl_stmt|;
comment|/**< Read Silo mode.  0=envelope, 1=self-timed. */
name|uint64_t
name|dcc_enable
range|:
literal|1
decl_stmt|;
comment|/**< Duty Cycle Corrector Enable.                                                          0=disable, 1=enable                                                          If the memory part does not support DCC, then this bit                                                          must be set to 0. */
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|data_layout
range|:
literal|2
decl_stmt|;
comment|/**< Logical data layout per DQ byte lane:                                                          In 32b mode, this setting has no effect and the data                                                          layout DQ[35:0] is the following:                                                              [E[3:0], D[31:24], D[23:16], D[15:8], D[7:0]]                                                          In 16b mode, the DQ[35:0] layouts are the following:                                                          0 - [0[3:0], 0[7:0], [0[7:2], E[1:0]], D[15:8], D[7:0]]                                                          1 - [0[3:0], [0[7:2], E[1:0]], D[15:8], D[7:0], 0[7:0]]                                                          2 - [[0[1:0], E[1:0]], D[15:8], D[7:0], 0[7:0], 0[7:0]]                                                          where E means ecc, D means data, and 0 means unused                                                          (ignored on reads and written as 0 on writes) */
else|#
directive|else
name|uint64_t
name|data_layout
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dcc_enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sil_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_lmcx_ctl1_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
name|uint64_t
name|ecc_adr
range|:
literal|1
decl_stmt|;
comment|/**< Include memory reference address in the ECC calculation                                                          0=disabled, 1=enabled */
name|uint64_t
name|forcewrite
range|:
literal|4
decl_stmt|;
comment|/**< Force the oldest outstanding write to complete after                                                          having waited for 2^FORCEWRITE cycles.  0=disabled. */
name|uint64_t
name|idlepower
range|:
literal|3
decl_stmt|;
comment|/**< Enter power-down mode after the memory controller has                                                          been idle for 2^(2+IDLEPOWER) cycles.  0=disabled. */
name|uint64_t
name|sequence
range|:
literal|3
decl_stmt|;
comment|/**< Instruction sequence that is run after a 0->1 transition                                                          on LMC_MEM_CFG0[INIT_START].                                                          0=DDR2 power-up/init, 1=read-leveling                                                          2=self-refresh entry, 3=self-refresh exit,                                                          4=power-down entry, 5=power-down exit, 6=7=illegal */
name|uint64_t
name|sil_mode
range|:
literal|1
decl_stmt|;
comment|/**< Read Silo mode.  0=envelope, 1=self-timed. */
name|uint64_t
name|dcc_enable
range|:
literal|1
decl_stmt|;
comment|/**< Duty Cycle Corrector Enable.                                                          0=disable, 1=enable                                                          If the memory part does not support DCC, then this bit                                                          must be set to 0. */
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
name|uint64_t
name|dcc_enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sil_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sequence
range|:
literal|3
decl_stmt|;
name|uint64_t
name|idlepower
range|:
literal|3
decl_stmt|;
name|uint64_t
name|forcewrite
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ecc_adr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_lmcx_ctl1_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_ctl1_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ctl1_cn52xx
name|cn56xxp1
decl_stmt|;
struct|struct
name|cvmx_lmcx_ctl1_cn58xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|sil_mode
range|:
literal|1
decl_stmt|;
comment|/**< Read Silo mode.  0=envelope, 1=self-timed. */
name|uint64_t
name|dcc_enable
range|:
literal|1
decl_stmt|;
comment|/**< Duty Cycle Corrector Enable.                                                          0=disable, 1=enable                                                          If the memory part does not support DCC, then this bit                                                          must be set to 0. */
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
name|uint64_t
name|dcc_enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sil_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_lmcx_ctl1_cn58xx
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_ctl1
name|cvmx_lmcx_ctl1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_dclk_cnt  *  * LMC_DCLK_CNT  = Performance Counters  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_dclk_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_dclk_cnt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|dclkcnt
range|:
literal|64
decl_stmt|;
comment|/**< Performance Counter                                                          64-bit counter that increments every CK cycle */
else|#
directive|else
name|uint64_t
name|dclkcnt
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_dclk_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_dclk_cnt
name|cvmx_lmcx_dclk_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_dclk_cnt_hi  *  * LMC_DCLK_CNT_HI  = Performance Counters  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_dclk_cnt_hi
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_dclk_cnt_hi_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|dclkcnt_hi
range|:
literal|32
decl_stmt|;
comment|/**< Performance Counter that counts dclks                                                          Upper 32-bits of a 64-bit counter. */
else|#
directive|else
name|uint64_t
name|dclkcnt_hi
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_dclk_cnt_hi_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_hi_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_hi_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_hi_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_hi_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_hi_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_hi_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_hi_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_hi_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_hi_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_hi_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_dclk_cnt_hi
name|cvmx_lmcx_dclk_cnt_hi_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_dclk_cnt_lo  *  * LMC_DCLK_CNT_LO  = Performance Counters  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_dclk_cnt_lo
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_dclk_cnt_lo_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|dclkcnt_lo
range|:
literal|32
decl_stmt|;
comment|/**< Performance Counter that counts dclks                                                          Lower 32-bits of a 64-bit counter. */
else|#
directive|else
name|uint64_t
name|dclkcnt_lo
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_dclk_cnt_lo_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_lo_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_lo_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_lo_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_lo_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_lo_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_lo_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_lo_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_lo_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_lo_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_cnt_lo_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_dclk_cnt_lo
name|cvmx_lmcx_dclk_cnt_lo_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_dclk_ctl  *  * LMC_DCLK_CTL = LMC DCLK generation control  *  *  * Notes:  * This CSR is only relevant for LMC1. LMC0_DCLK_CTL is not used.  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_dclk_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_dclk_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|off90_ena
range|:
literal|1
decl_stmt|;
comment|/**< 0=use global DCLK (i.e. the PLL) directly for LMC1                                                          1=use the 90 degree DCLK DLL to offset LMC1 DCLK */
name|uint64_t
name|dclk90_byp
range|:
literal|1
decl_stmt|;
comment|/**< 0=90 degree DCLK DLL uses sampled delay from LMC0                                                          1=90 degree DCLK DLL uses DCLK90_VLU                                                          See DCLK90_VLU. */
name|uint64_t
name|dclk90_ld
range|:
literal|1
decl_stmt|;
comment|/**< The 90 degree DCLK DLL samples the delay setting                                                          from LMC0's DLL when this field transitions 0->1 */
name|uint64_t
name|dclk90_vlu
range|:
literal|5
decl_stmt|;
comment|/**< Manual open-loop delay setting.                                                          The LMC1 90 degree DCLK DLL uses DCLK90_VLU rather                                                          than the delay setting sampled from LMC0 when                                                          DCLK90_BYP=1. */
else|#
directive|else
name|uint64_t
name|dclk90_vlu
range|:
literal|5
decl_stmt|;
name|uint64_t
name|dclk90_ld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dclk90_byp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|off90_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_dclk_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dclk_ctl_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_dclk_ctl
name|cvmx_lmcx_dclk_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_ddr2_ctl  *  * LMC_DDR2_CTL = LMC DDR2& DLL Control Register  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_ddr2_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_ddr2_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|bank8
range|:
literal|1
decl_stmt|;
comment|/**< For 8 bank DDR2 parts                                                          1 - DDR2 parts have 8 internal banks (BA is 3 bits                                                          wide).                                                          0 - DDR2 parts have 4 internal banks (BA is 2 bits                                                          wide). */
name|uint64_t
name|burst8
range|:
literal|1
decl_stmt|;
comment|/**< 8-burst mode.                                                          1 - DDR data transfer happens in burst of 8                                                          0 - DDR data transfer happens in burst of 4                                                          BURST8 should be set when DDR2T is set                                                          to minimize the command bandwidth loss. */
name|uint64_t
name|addlat
range|:
literal|3
decl_stmt|;
comment|/**< Additional Latency for posted CAS                                                          When Posted CAS is on, this configures the additional                                                          latency. This should be set to                                                                 1 .. LMC_MEM_CFG1[TRCD]-2                                                          (Note the implication that posted CAS should not                                                          be used when tRCD is two.) */
name|uint64_t
name|pocas
range|:
literal|1
decl_stmt|;
comment|/**< Enable the Posted CAS feature of DDR2. */
name|uint64_t
name|bwcnt
range|:
literal|1
decl_stmt|;
comment|/**< Bus utilization counter Clear.                                                          Clears the LMC_OPS_CNT_*, LMC_IFB_CNT_*, and                                                          LMC_DCLK_CNT_* registers. SW should first write this                                                          field to a one, then write this field to a zero to                                                          clear the CSR's. */
name|uint64_t
name|twr
range|:
literal|3
decl_stmt|;
comment|/**< DDR Write Recovery time (tWR). Last Wr Brst to Pre delay                                                          This is not a direct encoding of the value. Its                                                          programmed as below per DDR2 spec. The decimal number                                                          on the right is RNDUP(tWR(ns) / tCYC(ns))                                                           TYP=15ns                                                              - 000: RESERVED                                                              - 001: 2                                                              - 010: 3                                                              - 011: 4                                                              - 100: 5                                                              - 101: 6                                                              - 110: 7                                                              - 111: 8 */
name|uint64_t
name|silo_hc
range|:
literal|1
decl_stmt|;
comment|/**< Delays the read sample window by a Half Cycle. */
name|uint64_t
name|ddr_eof
range|:
literal|4
decl_stmt|;
comment|/**< Early Fill Counter Init.                                                          L2 needs to know a few cycle before a fill completes so                                                          it can get its Control pipe started (for better overall                                                          performance). This counter contains  an init value which                                                          is a function of Eclk/Dclk ratio to account for the                                                          asynchronous boundary between L2 cache and the DRAM                                                          controller. This init value will                                                          determine when to safely let the L2 know that a fill                                                          termination is coming up.                                                          Set DDR_EOF according to the following rule:                                                          eclkFreq/dclkFreq = dclkPeriod/eclkPeriod = RATIO                                                                 RATIO< 6/6  -> illegal                                                          6/6<= RATIO< 6/5  -> DDR_EOF=3                                                          6/5<= RATIO< 6/4  -> DDR_EOF=3                                                          6/4<= RATIO< 6/3  -> DDR_EOF=2                                                          6/3<= RATIO< 6/2  -> DDR_EOF=1                                                          6/2<= RATIO< 6/1  -> DDR_EOF=0                                                          6/1<= RATIO        -> DDR_EOF=0 */
name|uint64_t
name|tfaw
range|:
literal|5
decl_stmt|;
comment|/**< tFAW - Cycles = RNDUP[tFAW(ns)/tcyc(ns)] - 1                                                          Four Access Window time. Relevant only in DDR2 AND in                                                          8-bank parts.                                                              tFAW = 5'b0 in DDR2-4bank                                                              tFAW = RNDUP[tFAW(ns)/tcyc(ns)] - 1                                                                       in DDR2-8bank */
name|uint64_t
name|crip_mode
range|:
literal|1
decl_stmt|;
comment|/**< Cripple Mode - When set, the LMC allows only                                                          1 inflight transaction (.vs. 8 in normal mode).                                                          This bit is ONLY to be set at power-on and                                                          should not be set for normal use. */
name|uint64_t
name|ddr2t
range|:
literal|1
decl_stmt|;
comment|/**< Turn on the DDR 2T mode. 2 cycle window for CMD and                                                          address. This mode helps relieve setup time pressure                                                          on the Address and command bus which nominally have                                                          a very large fanout. Please refer to Micron's tech                                                          note tn_47_01 titled "DDR2-533 Memory Design Guide                                                          for Two Dimm Unbuffered Systems" for physical details.                                                          BURST8 should be set when DDR2T is set to minimize                                                          add/cmd loss. */
name|uint64_t
name|odt_ena
range|:
literal|1
decl_stmt|;
comment|/**< Enable Obsolete ODT on Reads                                                          Obsolete Read ODT wiggles DDR_ODT_* pins on reads.                                                          Should normally be cleared to zero.                                                          When this is on, the following fields must also be                                                          programmed:                                                              LMC_CTL->QS_DIC - programs the termination value                                                              LMC_RODT_CTL - programs the ODT I/O mask for Reads */
name|uint64_t
name|qdll_ena
range|:
literal|1
decl_stmt|;
comment|/**< DDR Quad DLL Enable: A 0->1 transition on this bit after                                                          DCLK init sequence will reset the DDR 90 DLL. Should                                                          happen at startup before any activity in DDR.                                                          DRESET should be asserted before and for 10 usec                                                          following the 0->1 transition on QDLL_ENA. */
name|uint64_t
name|dll90_vlu
range|:
literal|5
decl_stmt|;
comment|/**< Contains the open loop setting value for the DDR90 delay                                                          line. */
name|uint64_t
name|dll90_byp
range|:
literal|1
decl_stmt|;
comment|/**< DDR DLL90 Bypass: When set, the DDR90 DLL is to be                                                          bypassed and the setting is defined by DLL90_VLU */
name|uint64_t
name|rdqs
range|:
literal|1
decl_stmt|;
comment|/**< DDR2 RDQS mode. When set, configures memory subsystem to                                                          use unidirectional DQS pins. RDQS/DM - Rcv& DQS - Xmit */
name|uint64_t
name|ddr2
range|:
literal|1
decl_stmt|;
comment|/**< Should be set */
else|#
directive|else
name|uint64_t
name|ddr2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdqs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dll90_byp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dll90_vlu
range|:
literal|5
decl_stmt|;
name|uint64_t
name|qdll_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|odt_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr2t
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crip_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tfaw
range|:
literal|5
decl_stmt|;
name|uint64_t
name|ddr_eof
range|:
literal|4
decl_stmt|;
name|uint64_t
name|silo_hc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|twr
range|:
literal|3
decl_stmt|;
name|uint64_t
name|bwcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pocas
range|:
literal|1
decl_stmt|;
name|uint64_t
name|addlat
range|:
literal|3
decl_stmt|;
name|uint64_t
name|burst8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bank8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_lmcx_ddr2_ctl_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|bank8
range|:
literal|1
decl_stmt|;
comment|/**< For 8 bank DDR2 parts                                                          1 - DDR2 parts have 8 internal banks (BA is 3 bits                                                          wide).                                                          0 - DDR2 parts have 4 internal banks (BA is 2 bits                                                          wide). */
name|uint64_t
name|burst8
range|:
literal|1
decl_stmt|;
comment|/**< 8-burst mode.                                                          1 - DDR data transfer happens in burst of 8                                                          0 - DDR data transfer happens in burst of 4                                                          BURST8 should be set when DDR2T is set to minimize                                                          add/cmd bandwidth loss. */
name|uint64_t
name|addlat
range|:
literal|3
decl_stmt|;
comment|/**< Additional Latency for posted CAS                                                          When Posted CAS is on, this configures the additional                                                          latency. This should be set to                                                                 1 .. LMC_MEM_CFG1[TRCD]-2                                                          (Note the implication that posted CAS should not                                                          be used when tRCD is two.) */
name|uint64_t
name|pocas
range|:
literal|1
decl_stmt|;
comment|/**< Enable the Posted CAS feature of DDR2. */
name|uint64_t
name|bwcnt
range|:
literal|1
decl_stmt|;
comment|/**< Bus utilization counter Clear.                                                          Clears the LMC_OPS_CNT_*, LMC_IFB_CNT_*, and                                                          LMC_DCLK_CNT_* registers. SW should first write this                                                          field to a one, then write this field to a zero to                                                          clear the CSR's. */
name|uint64_t
name|twr
range|:
literal|3
decl_stmt|;
comment|/**< DDR Write Recovery time (tWR). Last Wr Brst to Pre delay                                                          This is not a direct encoding of the value. Its                                                          programmed as below per DDR2 spec. The decimal number                                                          on the right is RNDUP(tWR(ns) / tCYC(ns))                                                           TYP=15ns                                                              - 000: RESERVED                                                              - 001: 2                                                              - 010: 3                                                              - 011: 4                                                              - 100: 5                                                              - 101: 6                                                              - 110-111: RESERVED */
name|uint64_t
name|silo_hc
range|:
literal|1
decl_stmt|;
comment|/**< Delays the read sample window by a Half Cycle. */
name|uint64_t
name|ddr_eof
range|:
literal|4
decl_stmt|;
comment|/**< Early Fill Counter Init.                                                          L2 needs to know a few cycle before a fill completes so                                                          it can get its Control pipe started (for better overall                                                          performance). This counter contains  an init value which                                                          is a function of Eclk/Dclk ratio to account for the                                                          asynchronous boundary between L2 cache and the DRAM                                                          controller. This init value will                                                          determine when to safely let the L2 know that a fill                                                          termination is coming up.                                                          DDR_EOF = RNDUP (DCLK period/Eclk Period). If the ratio                                                          is above 3, set DDR_EOF to 3.                                                              DCLK/ECLK period         DDR_EOF                                                                 Less than 1            1                                                                 Less than 2            2                                                                 More than 2            3 */
name|uint64_t
name|tfaw
range|:
literal|5
decl_stmt|;
comment|/**< tFAW - Cycles = RNDUP[tFAW(ns)/tcyc(ns)] - 1                                                          Four Access Window time. Relevant only in                                                          8-bank parts.                                                              TFAW = 5'b0 for DDR2-4bank                                                              TFAW = RNDUP[tFAW(ns)/tcyc(ns)] - 1 in DDR2-8bank */
name|uint64_t
name|crip_mode
range|:
literal|1
decl_stmt|;
comment|/**< Cripple Mode - When set, the LMC allows only                                                          1 inflight transaction (.vs. 8 in normal mode).                                                          This bit is ONLY to be set at power-on and                                                          should not be set for normal use. */
name|uint64_t
name|ddr2t
range|:
literal|1
decl_stmt|;
comment|/**< Turn on the DDR 2T mode. 2 cycle window for CMD and                                                          address. This mode helps relieve setup time pressure                                                          on the Address and command bus which nominally have                                                          a very large fanout. Please refer to Micron's tech                                                          note tn_47_01 titled "DDR2-533 Memory Design Guide                                                          for Two Dimm Unbuffered Systems" for physical details.                                                          BURST8 should be used when DDR2T is set to minimize                                                          add/cmd bandwidth loss. */
name|uint64_t
name|odt_ena
range|:
literal|1
decl_stmt|;
comment|/**< Enable ODT for DDR2 on Reads                                                          When this is on, the following fields must also be                                                          programmed:                                                              LMC_CTL->QS_DIC - programs the termination value                                                              LMC_RODT_CTL - programs the ODT I/O mask for writes                                                          Program as 0 for DDR1 mode and ODT needs to be off                                                          on Octeon Reads */
name|uint64_t
name|qdll_ena
range|:
literal|1
decl_stmt|;
comment|/**< DDR Quad DLL Enable: A 0->1 transition on this bit after                                                          erst deassertion will reset the DDR 90 DLL. Should                                                          happen at startup before any activity in DDR. */
name|uint64_t
name|dll90_vlu
range|:
literal|5
decl_stmt|;
comment|/**< Contains the open loop setting value for the DDR90 delay                                                          line. */
name|uint64_t
name|dll90_byp
range|:
literal|1
decl_stmt|;
comment|/**< DDR DLL90 Bypass: When set, the DDR90 DLL is to be                                                          bypassed and the setting is defined by DLL90_VLU */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr2
range|:
literal|1
decl_stmt|;
comment|/**< DDR2 Enable: When set, configures memory subsystem for                                                          DDR-II SDRAMs. */
else|#
directive|else
name|uint64_t
name|ddr2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dll90_byp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dll90_vlu
range|:
literal|5
decl_stmt|;
name|uint64_t
name|qdll_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|odt_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr2t
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crip_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tfaw
range|:
literal|5
decl_stmt|;
name|uint64_t
name|ddr_eof
range|:
literal|4
decl_stmt|;
name|uint64_t
name|silo_hc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|twr
range|:
literal|3
decl_stmt|;
name|uint64_t
name|bwcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pocas
range|:
literal|1
decl_stmt|;
name|uint64_t
name|addlat
range|:
literal|3
decl_stmt|;
name|uint64_t
name|burst8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bank8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_lmcx_ddr2_ctl_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ddr2_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ddr2_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_lmcx_ddr2_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ddr2_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ddr2_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_ddr2_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ddr2_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_ddr2_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ddr2_ctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_ddr2_ctl
name|cvmx_lmcx_ddr2_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_ddr_pll_ctl  *  * LMC_DDR_PLL_CTL = LMC DDR PLL control  *  *  * Notes:  * DDR PLL Bringup sequence:  * 1.  Write CLKF, DDR_PS_EN, DFM_PS_EN, DIFFAMP, CPS, CPB.  *     If test mode is going to be activated, then also write jtg__ddr_pll_tm_en1, jtg__ddr_pll_tm_en2, jtg__ddr_pll_tm_en3,  *     jtg__ddr_pll_tm_en4, jtg__dfa_pll_tm_en1, jtg__dfa_pll_tm_en2, jtg__dfa_pll_tm_en3, jtg__dfa_pll_tm_en4, JTAG_TEST_MODE  * 2.  Wait 128 ref clock cycles (7680 rclk cycles)  * 3.  Write 1 to RESET_N  * 4.  Wait 1152 ref clocks (1152*16 rclk cycles)  * 5.  Write 0 to  DDR_DIV_RESET and DFM_DIV_RESET  * 6.  Wait 10 ref clock cycles (160 rclk cycles) before bringing up the DDR interface  *     If test mode is going to be activated, wait an additional 8191 ref clocks (8191*16 rclk cycles) to allow PLL  *     clock alignment  */
end_comment

begin_union
union|union
name|cvmx_lmcx_ddr_pll_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_ddr_pll_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
name|uint64_t
name|jtg_test_mode
range|:
literal|1
decl_stmt|;
comment|/**< JTAG Test Mode                                                          Clock alignment between DCLK& REFCLK as well as FCLK&                                                          REFCLK can only be performed after the ddr_pll_divider_reset                                                          is deasserted. SW need to wait atleast 10 reference clock                                                          cycles after deasserting pll_divider_reset before asserting                                                          LMC(0)_DDR_PLL_CTL[JTG_TEST_MODE]. During alignment (which can                                                          take upto 160 microseconds) DCLK and FCLK can exhibit some                                                          high frequency pulses. Therefore, all bring up activities in                                                          that clock domain need to be delayed (when the chip operates                                                          in jtg_test_mode) by about 160 microseconds to ensure that                                                          lock is achieved. */
name|uint64_t
name|dfm_div_reset
range|:
literal|1
decl_stmt|;
comment|/**< DFM postscalar divider reset */
name|uint64_t
name|dfm_ps_en
range|:
literal|3
decl_stmt|;
comment|/**< DFM postscalar divide ratio                                                          Determines the DFM CK speed.                                                          0x0 : Divide LMC+DFM PLL output by 1                                                          0x1 : Divide LMC+DFM PLL output by 2                                                          0x2 : Divide LMC+DFM PLL output by 3                                                          0x3 : Divide LMC+DFM PLL output by 4                                                          0x4 : Divide LMC+DFM PLL output by 6                                                          0x5 : Divide LMC+DFM PLL output by 8                                                          0x6 : Divide LMC+DFM PLL output by 12                                                          0x7 : Divide LMC+DFM PLL output by 12                                                          DFM_PS_EN is not used when DFM_DIV_RESET = 1 */
name|uint64_t
name|ddr_div_reset
range|:
literal|1
decl_stmt|;
comment|/**< DDR postscalar divider reset */
name|uint64_t
name|ddr_ps_en
range|:
literal|3
decl_stmt|;
comment|/**< DDR postscalar divide ratio                                                          Determines the LMC CK speed.                                                          0x0 : Divide LMC+DFM PLL output by 1                                                          0x1 : Divide LMC+DFM PLL output by 2                                                          0x2 : Divide LMC+DFM PLL output by 3                                                          0x3 : Divide LMC+DFM PLL output by 4                                                          0x4 : Divide LMC+DFM PLL output by 6                                                          0x5 : Divide LMC+DFM PLL output by 8                                                          0x6 : Divide LMC+DFM PLL output by 12                                                          0x7 : Divide LMC+DFM PLL output by 12                                                          DDR_PS_EN is not used when DDR_DIV_RESET = 1 */
name|uint64_t
name|diffamp
range|:
literal|4
decl_stmt|;
comment|/**< PLL diffamp input transconductance */
name|uint64_t
name|cps
range|:
literal|3
decl_stmt|;
comment|/**< PLL charge-pump current */
name|uint64_t
name|cpb
range|:
literal|3
decl_stmt|;
comment|/**< PLL charge-pump current */
name|uint64_t
name|reset_n
range|:
literal|1
decl_stmt|;
comment|/**< PLL reset */
name|uint64_t
name|clkf
range|:
literal|7
decl_stmt|;
comment|/**< Multiply reference by CLKF                                                          32<= CLKF<= 64                                                          LMC+DFM PLL frequency = 50 * CLKF                                                          min = 1.6 GHz, max = 3.2 GHz */
else|#
directive|else
name|uint64_t
name|clkf
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reset_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cpb
range|:
literal|3
decl_stmt|;
name|uint64_t
name|cps
range|:
literal|3
decl_stmt|;
name|uint64_t
name|diffamp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ddr_ps_en
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ddr_div_reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dfm_ps_en
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dfm_div_reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jtg_test_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_ddr_pll_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ddr_pll_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_ddr_pll_ctl
name|cvmx_lmcx_ddr_pll_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_delay_cfg  *  * LMC_DELAY_CFG = Open-loop delay line settings  *  *  * Notes:  * The DQ bits add OUTGOING delay only to dq, dqs_[p,n], cb, cbs_[p,n], dqm.  Delay is approximately  * 50-80ps per setting depending on process/voltage.  There is no need to add incoming delay since by  * default all strobe bits are delayed internally by 90 degrees (as was always the case in previous  * passes and past chips.  *  * The CMD add delay to all command bits DDR_RAS, DDR_CAS, DDR_A<15:0>, DDR_BA<2:0>, DDR_n_CS<1:0>_L,  * DDR_WE, DDR_CKE and DDR_ODT_<7:0>. Again, delay is 50-80ps per tap.  *  * The CLK bits add delay to all clock signals DDR_CK_<5:0>_P and DDR_CK_<5:0>_N.  Again, delay is  * 50-80ps per tap.  *  * The usage scenario is the following: There is too much delay on command signals and setup on command  * is not met. The user can then delay the clock until setup is met.  *  * At the same time though, dq/dqs should be delayed because there is also a DDR spec tying dqs with  * clock. If clock is too much delayed with respect to dqs, writes will start to fail.  *  * This scheme should eliminate the board need of adding routing delay to clock signals to make high  * frequencies work.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_delay_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_delay_cfg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
name|uint64_t
name|dq
range|:
literal|5
decl_stmt|;
comment|/**< Setting for DQ  delay line */
name|uint64_t
name|cmd
range|:
literal|5
decl_stmt|;
comment|/**< Setting for CMD delay line */
name|uint64_t
name|clk
range|:
literal|5
decl_stmt|;
comment|/**< Setting for CLK delay line */
else|#
directive|else
name|uint64_t
name|clk
range|:
literal|5
decl_stmt|;
name|uint64_t
name|cmd
range|:
literal|5
decl_stmt|;
name|uint64_t
name|dq
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_delay_cfg_s
name|cn30xx
decl_stmt|;
struct|struct
name|cvmx_lmcx_delay_cfg_cn38xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|dq
range|:
literal|4
decl_stmt|;
comment|/**< Setting for DQ  delay line */
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cmd
range|:
literal|4
decl_stmt|;
comment|/**< Setting for CMD delay line */
name|uint64_t
name|reserved_4_4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clk
range|:
literal|4
decl_stmt|;
comment|/**< Setting for CLK delay line */
else|#
directive|else
name|uint64_t
name|clk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cmd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dq
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_lmcx_delay_cfg_cn38xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_delay_cfg_cn38xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_delay_cfg_cn38xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_delay_cfg_cn38xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_delay_cfg_cn38xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_delay_cfg_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_delay_cfg_cn38xx
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_delay_cfg
name|cvmx_lmcx_delay_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_dimm#_params  *  * LMC_DIMMX_PARAMS = LMC DIMMX Params  * This register contains values to be programmed into each control word in the corresponding (registered) DIMM. The control words allow  * optimization of the device properties for different raw card designs.  *  * Notes:  * LMC only uses this CSR when LMC*_CONTROL[RDIMM_ENA]=1. During a power-up/init sequence, LMC writes  * these fields into the control words in the JEDEC standard SSTE32882 registering clock driver on an  * RDIMM when corresponding LMC*_DIMM_CTL[DIMM*_WMASK] bits are set.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_dimmx_params
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_dimmx_params_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|rc15
range|:
literal|4
decl_stmt|;
comment|/**< RC15, Reserved */
name|uint64_t
name|rc14
range|:
literal|4
decl_stmt|;
comment|/**< RC14, Reserved */
name|uint64_t
name|rc13
range|:
literal|4
decl_stmt|;
comment|/**< RC13, Reserved */
name|uint64_t
name|rc12
range|:
literal|4
decl_stmt|;
comment|/**< RC12, Reserved */
name|uint64_t
name|rc11
range|:
literal|4
decl_stmt|;
comment|/**< RC11, Encoding for RDIMM Operating VDD */
name|uint64_t
name|rc10
range|:
literal|4
decl_stmt|;
comment|/**< RC10, Encoding for RDIMM Operating Speed */
name|uint64_t
name|rc9
range|:
literal|4
decl_stmt|;
comment|/**< RC9 , Power Savings Settings Control Word */
name|uint64_t
name|rc8
range|:
literal|4
decl_stmt|;
comment|/**< RC8 , Additional IBT Settings Control Word */
name|uint64_t
name|rc7
range|:
literal|4
decl_stmt|;
comment|/**< RC7 , Reserved */
name|uint64_t
name|rc6
range|:
literal|4
decl_stmt|;
comment|/**< RC6 , Reserved */
name|uint64_t
name|rc5
range|:
literal|4
decl_stmt|;
comment|/**< RC5 , CK Driver Characterstics Control Word */
name|uint64_t
name|rc4
range|:
literal|4
decl_stmt|;
comment|/**< RC4 , Control Signals Driver Characteristics Control Word */
name|uint64_t
name|rc3
range|:
literal|4
decl_stmt|;
comment|/**< RC3 , CA Signals Driver Characterstics Control Word */
name|uint64_t
name|rc2
range|:
literal|4
decl_stmt|;
comment|/**< RC2 , Timing Control Word */
name|uint64_t
name|rc1
range|:
literal|4
decl_stmt|;
comment|/**< RC1 , Clock Driver Enable Control Word */
name|uint64_t
name|rc0
range|:
literal|4
decl_stmt|;
comment|/**< RC0 , Global Features Control Word */
else|#
directive|else
name|uint64_t
name|rc0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rc1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rc2
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rc3
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rc4
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rc5
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rc6
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rc7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rc8
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rc9
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rc10
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rc11
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rc12
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rc13
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rc14
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rc15
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_dimmx_params_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dimmx_params_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_dimmx_params
name|cvmx_lmcx_dimmx_params_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_dimm_ctl  *  * LMC_DIMM_CTL = LMC DIMM Control  *  *  * Notes:  * This CSR is only used when LMC*_CONTROL[RDIMM_ENA]=1. During a power-up/init sequence, this CSR  * controls LMC's writes to the control words in the JEDEC standard SSTE32882 registering clock driver  * on an RDIMM.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_dimm_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_dimm_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
name|uint64_t
name|parity
range|:
literal|1
decl_stmt|;
comment|/**< Parity */
name|uint64_t
name|tcws
range|:
literal|13
decl_stmt|;
comment|/**< LMC waits for this time period before and after a RDIMM                                                          Control Word Access during a power-up/init SEQUENCE.                                                          TCWS is in multiples of 8 CK cycles.                                                          Set TCWS (CSR field) = RNDUP[tcws(ns)/(8*tCYC(ns))],                                                          where tCWS is the desired time (ns), and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=0x4e0 (equivalent to 15us) when changing                                                          clock timing (RC2.DBA1, RC6.DA4, RC10.DA3, RC10.DA4,                                                          RC11.DA3, and RC11.DA4)                                                          TYP=0x8, otherwise                                                          0x0 = Reserved */
name|uint64_t
name|dimm1_wmask
range|:
literal|16
decl_stmt|;
comment|/**< DIMM1 Write Mask                                                          if (DIMM1_WMASK[n] = 1)                                                              Write DIMM1.RCn */
name|uint64_t
name|dimm0_wmask
range|:
literal|16
decl_stmt|;
comment|/**< DIMM0 Write Mask                                                          if (DIMM0_WMASK[n] = 1)                                                              Write DIMM0.RCn */
else|#
directive|else
name|uint64_t
name|dimm0_wmask
range|:
literal|16
decl_stmt|;
name|uint64_t
name|dimm1_wmask
range|:
literal|16
decl_stmt|;
name|uint64_t
name|tcws
range|:
literal|13
decl_stmt|;
name|uint64_t
name|parity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_dimm_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dimm_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_dimm_ctl
name|cvmx_lmcx_dimm_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_dll_ctl  *  * LMC_DLL_CTL = LMC DLL control and DCLK reset  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_dll_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_dll_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|dreset
range|:
literal|1
decl_stmt|;
comment|/**< Dclk domain reset.  The reset signal that is used by the                                                          Dclk domain is (DRESET || ECLK_RESET). */
name|uint64_t
name|dll90_byp
range|:
literal|1
decl_stmt|;
comment|/**< DDR DLL90 Bypass: When set, the DDR90 DLL is to be                                                          bypassed and the setting is defined by DLL90_VLU */
name|uint64_t
name|dll90_ena
range|:
literal|1
decl_stmt|;
comment|/**< DDR Quad DLL Enable: A 0->1 transition on this bit after                                                          DCLK init sequence resets the DDR 90 DLL. Should                                                          happen at startup before any activity in DDR. QDLL_ENA                                                          must not transition 1->0 outside of a DRESET sequence                                                          (i.e. it must remain 1 until the next DRESET).                                                          DRESET should be asserted before and for 10 usec                                                          following the 0->1 transition on QDLL_ENA. */
name|uint64_t
name|dll90_vlu
range|:
literal|5
decl_stmt|;
comment|/**< Contains the open loop setting value for the DDR90 delay                                                          line. */
else|#
directive|else
name|uint64_t
name|dll90_vlu
range|:
literal|5
decl_stmt|;
name|uint64_t
name|dll90_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dll90_byp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dreset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_dll_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dll_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_dll_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dll_ctl_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_dll_ctl
name|cvmx_lmcx_dll_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_dll_ctl2  *  * LMC_DLL_CTL2 = LMC (Octeon) DLL control and DCLK reset  *  *  * Notes:  * DLL Bringup sequence:  * 1. If not done already, set LMC*_DLL_CTL2 = 0, except when LMC*_DLL_CTL2[DRESET] = 1.  * 2. Write 1 to LMC*_DLL_CTL2[DLL_BRINGUP]  * 3. Wait for 10 CK cycles, then write 1 to LMC*_DLL_CTL2[QUAD_DLL_ENA]. It may not be feasible to count 10 CK cycles, but the  *    idea is to configure the delay line into DLL mode by asserting DLL_BRING_UP earlier than [QUAD_DLL_ENA], even if it is one  *    cycle early. LMC*_DLL_CTL2[QUAD_DLL_ENA] must not change after this point without restarting the LMC and/or DRESET initialization  *    sequence.  * 4. Read L2D_BST0 and wait for the result. (L2D_BST0 is subject to change depending on how it called in o63. It is still ok to go  *    without step 4, since step 5 has enough time)  * 5. Wait 10 us.  * 6. Write 0 to LMC*_DLL_CTL2[DLL_BRINGUP]. LMC*_DLL_CTL2[DLL_BRINGUP] must not change after this point without restarting the LMC  *    and/or DRESET initialization sequence.  * 7. Read L2D_BST0 and wait for the result. (same as step 4, but the idea here is the wait some time before going to step 8, even it  *    is one cycle is fine)  * 8. Write 0 to LMC*_DLL_CTL2[DRESET].  LMC*_DLL_CTL2[DRESET] must not change after this point without restarting the LMC and/or  *    DRESET initialization sequence.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_dll_ctl2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_dll_ctl2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
name|uint64_t
name|dll_bringup
range|:
literal|1
decl_stmt|;
comment|/**< DLL Bringup */
name|uint64_t
name|dreset
range|:
literal|1
decl_stmt|;
comment|/**< Dclk domain reset.  The reset signal that is used by the                                                          Dclk domain is (DRESET || ECLK_RESET). */
name|uint64_t
name|quad_dll_ena
range|:
literal|1
decl_stmt|;
comment|/**< DLL Enable */
name|uint64_t
name|byp_sel
range|:
literal|4
decl_stmt|;
comment|/**< Bypass select                                                          0000 : no byte                                                          0001 : byte 0                                                          - ...                                                          1001 : byte 8                                                          1010 : all bytes                                                          1011-1111 : Reserved */
name|uint64_t
name|byp_setting
range|:
literal|8
decl_stmt|;
comment|/**< Bypass setting                                                          DDR3-1600: 00100010                                                          DDR3-1333: 00110010                                                          DDR3-1066: 01001011                                                          DDR3-800 : 01110101                                                          DDR3-667 : 10010110                                                          DDR3-600 : 10101100 */
else|#
directive|else
name|uint64_t
name|byp_setting
range|:
literal|8
decl_stmt|;
name|uint64_t
name|byp_sel
range|:
literal|4
decl_stmt|;
name|uint64_t
name|quad_dll_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dreset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dll_bringup
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_dll_ctl2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dll_ctl2_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_dll_ctl2
name|cvmx_lmcx_dll_ctl2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_dll_ctl3  *  * LMC_DLL_CTL3 = LMC DLL control and DCLK reset  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_dll_ctl3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_dll_ctl3_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|dll_fast
range|:
literal|1
decl_stmt|;
comment|/**< DLL lock                                                          0 = DLL locked */
name|uint64_t
name|dll90_setting
range|:
literal|8
decl_stmt|;
comment|/**< Encoded DLL settings. Works in conjuction with                                                          DLL90_BYTE_SEL */
name|uint64_t
name|fine_tune_mode
range|:
literal|1
decl_stmt|;
comment|/**< DLL Fine Tune Mode                                                          0 = disabled                                                          1 = enable.                                                          When enabled, calibrate internal PHY DLL every                                                          LMC*_CONFIG[REF_ZQCS_INT] CK cycles. */
name|uint64_t
name|dll_mode
range|:
literal|1
decl_stmt|;
comment|/**< DLL Mode */
name|uint64_t
name|dll90_byte_sel
range|:
literal|4
decl_stmt|;
comment|/**< Observe DLL settings for selected byte                                                          0001 : byte 0                                                          - ...                                                          1001 : byte 8                                                          0000,1010-1111 : Reserved */
name|uint64_t
name|offset_ena
range|:
literal|1
decl_stmt|;
comment|/**< Offset enable                                                          0 = disable                                                          1 = enable */
name|uint64_t
name|load_offset
range|:
literal|1
decl_stmt|;
comment|/**< Load offset                                                          0 : disable                                                          1 : load (generates a 1 cycle pulse to the PHY)                                                          This register is oneshot and clears itself each time                                                          it is set */
name|uint64_t
name|mode_sel
range|:
literal|2
decl_stmt|;
comment|/**< Mode select                                                          00 : reset                                                          01 : write                                                          10 : read                                                          11 : write& read */
name|uint64_t
name|byte_sel
range|:
literal|4
decl_stmt|;
comment|/**< Byte select                                                          0000 : no byte                                                          0001 : byte 0                                                          - ...                                                          1001 : byte 8                                                          1010 : all bytes                                                          1011-1111 : Reserved */
name|uint64_t
name|offset
range|:
literal|6
decl_stmt|;
comment|/**< Write/read offset setting                                                          [4:0] : offset                                                          [5]   : 0 = increment, 1 = decrement                                                          Not a 2's complement value */
else|#
directive|else
name|uint64_t
name|offset
range|:
literal|6
decl_stmt|;
name|uint64_t
name|byte_sel
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mode_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|load_offset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|offset_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dll90_byte_sel
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dll_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fine_tune_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dll90_setting
range|:
literal|8
decl_stmt|;
name|uint64_t
name|dll_fast
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_dll_ctl3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dll_ctl3_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_dll_ctl3
name|cvmx_lmcx_dll_ctl3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_dual_memcfg  *  * LMC_DUAL_MEMCFG = LMC Dual Memory Configuration Register  *  * This register controls certain parameters of Dual Memory Configuration  *  * Notes:  * This register enables the design to have two, separate memory configurations, selected dynamically  * by the reference address.  Note however, that both configurations share  * LMC*_CONTROL[XOR_BANK], LMC*_CONFIG[PBANK_LSB], LMC*_CONFIG[RANK_ENA], and all timing parameters.  * In this description, "config0" refers to the normal memory configuration that is defined by the  * LMC*_CONFIG[ROW_LSB] parameters and "config1" refers to the dual (or second)  * memory configuration that is defined by this register.  *  * Enable mask to chip select mapping is shown below:  *   CS_MASK[3] -> DIMM1_CS_<1>  *   CS_MASK[2] -> DIMM1_CS_<0>  *  *   CS_MASK[1] -> DIMM0_CS_<1>  *   CS_MASK[0] -> DIMM0_CS_<0>  *  *  DIMM n uses the pair of chip selects DIMMn_CS_<1:0>.  *  *  Programming restrictions for CS_MASK:  *    when LMC*_CONFIG[RANK_ENA] == 0, CS_MASK[2n + 1] = CS_MASK[2n]  */
end_comment

begin_union
union|union
name|cvmx_lmcx_dual_memcfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_dual_memcfg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|bank8
range|:
literal|1
decl_stmt|;
comment|/**< See LMC_DDR2_CTL[BANK8] */
name|uint64_t
name|row_lsb
range|:
literal|3
decl_stmt|;
comment|/**< See LMC*_CONFIG[ROW_LSB] */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|cs_mask
range|:
literal|8
decl_stmt|;
comment|/**< Chip select mask.                                                          This mask corresponds to the 8 chip selects for a memory                                                          configuration.  Each reference address will assert one of                                                          the chip selects.  If that chip select has its                                                          corresponding CS_MASK bit set, then the "config1"                                                          parameters are used, otherwise the "config0" parameters                                                          are used.  See additional notes below.                                                          [7:4] */
else|#
directive|else
name|uint64_t
name|cs_mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|row_lsb
range|:
literal|3
decl_stmt|;
name|uint64_t
name|bank8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_dual_memcfg_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dual_memcfg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dual_memcfg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_dual_memcfg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dual_memcfg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_dual_memcfg_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_dual_memcfg_s
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_lmcx_dual_memcfg_cn63xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|row_lsb
range|:
literal|3
decl_stmt|;
comment|/**< See LMC*_CONFIG[ROW_LSB] */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|cs_mask
range|:
literal|8
decl_stmt|;
comment|/**< Chip select mask.                                                          This mask corresponds to the 8 chip selects for a memory                                                          configuration.  Each reference address will assert one of                                                          the chip selects.  If that chip select has its                                                          corresponding CS_MASK bit set, then the "config1"                                                          parameters are used, otherwise the "config0" parameters                                                          are used.  See additional notes below.                                                          [7:4] */
else|#
directive|else
name|uint64_t
name|cs_mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|row_lsb
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_lmcx_dual_memcfg_cn63xx
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_dual_memcfg
name|cvmx_lmcx_dual_memcfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_ecc_synd  *  * LMC_ECC_SYND = MRD ECC Syndromes  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_ecc_synd
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_ecc_synd_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|mrdsyn3
range|:
literal|8
decl_stmt|;
comment|/**< MRD ECC Syndrome Quad3                                                          MRDSYN3 corresponds to DQ[63:0]_c1_p1                                                            where _cC_pP denotes cycle C and phase P */
name|uint64_t
name|mrdsyn2
range|:
literal|8
decl_stmt|;
comment|/**< MRD ECC Syndrome Quad2                                                          MRDSYN2 corresponds to DQ[63:0]_c1_p0                                                            where _cC_pP denotes cycle C and phase P */
name|uint64_t
name|mrdsyn1
range|:
literal|8
decl_stmt|;
comment|/**< MRD ECC Syndrome Quad1                                                          MRDSYN1 corresponds to DQ[63:0]_c0_p1                                                            where _cC_pP denotes cycle C and phase P */
name|uint64_t
name|mrdsyn0
range|:
literal|8
decl_stmt|;
comment|/**< MRD ECC Syndrome Quad0                                                          MRDSYN0 corresponds to DQ[63:0]_c0_p0                                                            where _cC_pP denotes cycle C and phase P */
else|#
directive|else
name|uint64_t
name|mrdsyn0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|mrdsyn1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|mrdsyn2
range|:
literal|8
decl_stmt|;
name|uint64_t
name|mrdsyn3
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_ecc_synd_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ecc_synd_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ecc_synd_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ecc_synd_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_lmcx_ecc_synd_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ecc_synd_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ecc_synd_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_ecc_synd_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ecc_synd_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_ecc_synd_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ecc_synd_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_ecc_synd_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ecc_synd_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_ecc_synd
name|cvmx_lmcx_ecc_synd_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_fadr  *  * LMC_FADR = LMC Failing Address Register (SEC/DED/NXM)  *  * This register only captures the first transaction with ecc/nxm errors. A DED/NXM error can  * over-write this register with its failing addresses if the first error was a SEC. If you write  * LMC*_CONFIG->SEC_ERR/DED_ERR/NXM_ERR then it will clear the error bits and capture the  * next failing address.  *  * If FDIMM is 2 that means the error is in the higher bits DIMM.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_fadr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_fadr_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_lmcx_fadr_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|fdimm
range|:
literal|2
decl_stmt|;
comment|/**< Failing DIMM# */
name|uint64_t
name|fbunk
range|:
literal|1
decl_stmt|;
comment|/**< Failing Rank */
name|uint64_t
name|fbank
range|:
literal|3
decl_stmt|;
comment|/**< Failing Bank[2:0] */
name|uint64_t
name|frow
range|:
literal|14
decl_stmt|;
comment|/**< Failing Row Address[13:0] */
name|uint64_t
name|fcol
range|:
literal|12
decl_stmt|;
comment|/**< Failing Column Start Address[11:0]                                                          Represents the Failing read's starting column address                                                          (and not the exact column address in which the SEC/DED                                                          was detected) */
else|#
directive|else
name|uint64_t
name|fcol
range|:
literal|12
decl_stmt|;
name|uint64_t
name|frow
range|:
literal|14
decl_stmt|;
name|uint64_t
name|fbank
range|:
literal|3
decl_stmt|;
name|uint64_t
name|fbunk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fdimm
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_lmcx_fadr_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_lmcx_fadr_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_lmcx_fadr_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_lmcx_fadr_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_fadr_cn30xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_fadr_cn30xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_fadr_cn30xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_fadr_cn30xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_fadr_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_fadr_cn30xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_lmcx_fadr_cn63xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|fdimm
range|:
literal|2
decl_stmt|;
comment|/**< Failing DIMM# */
name|uint64_t
name|fbunk
range|:
literal|1
decl_stmt|;
comment|/**< Failing Rank */
name|uint64_t
name|fbank
range|:
literal|3
decl_stmt|;
comment|/**< Failing Bank[2:0] */
name|uint64_t
name|frow
range|:
literal|16
decl_stmt|;
comment|/**< Failing Row Address[15:0] */
name|uint64_t
name|fcol
range|:
literal|14
decl_stmt|;
comment|/**< Failing Column Address[13:0]                                                          Technically, represents the address of the 128b data                                                          that had an ecc error, i.e., fcol[0] is always 0. Can                                                          be used in conjuction with LMC*_CONFIG[DED_ERR] to                                                          isolate the 64b chunk of data in error */
else|#
directive|else
name|uint64_t
name|fcol
range|:
literal|14
decl_stmt|;
name|uint64_t
name|frow
range|:
literal|16
decl_stmt|;
name|uint64_t
name|fbank
range|:
literal|3
decl_stmt|;
name|uint64_t
name|fbunk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fdimm
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_lmcx_fadr_cn63xx
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_fadr
name|cvmx_lmcx_fadr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_ifb_cnt  *  * LMC_IFB_CNT  = Performance Counters  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_ifb_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_ifb_cnt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|ifbcnt
range|:
literal|64
decl_stmt|;
comment|/**< Performance Counter                                                          64-bit counter that increments every                                                          CK cycle there is something in the in-flight buffer. */
else|#
directive|else
name|uint64_t
name|ifbcnt
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_ifb_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_ifb_cnt
name|cvmx_lmcx_ifb_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_ifb_cnt_hi  *  * LMC_IFB_CNT_HI  = Performance Counters  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_ifb_cnt_hi
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_ifb_cnt_hi_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ifbcnt_hi
range|:
literal|32
decl_stmt|;
comment|/**< Performance Counter to measure Bus Utilization                                                          Upper 32-bits of 64-bit counter that increments every                                                          cycle there is something in the in-flight buffer. */
else|#
directive|else
name|uint64_t
name|ifbcnt_hi
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_ifb_cnt_hi_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_hi_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_hi_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_hi_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_hi_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_hi_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_hi_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_hi_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_hi_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_hi_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_hi_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_ifb_cnt_hi
name|cvmx_lmcx_ifb_cnt_hi_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_ifb_cnt_lo  *  * LMC_IFB_CNT_LO  = Performance Counters  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_ifb_cnt_lo
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_ifb_cnt_lo_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ifbcnt_lo
range|:
literal|32
decl_stmt|;
comment|/**< Performance Counter                                                          Low 32-bits of 64-bit counter that increments every                                                          cycle there is something in the in-flight buffer. */
else|#
directive|else
name|uint64_t
name|ifbcnt_lo
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_ifb_cnt_lo_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_lo_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_lo_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_lo_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_lo_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_lo_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_lo_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_lo_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_lo_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_lo_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ifb_cnt_lo_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_ifb_cnt_lo
name|cvmx_lmcx_ifb_cnt_lo_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_int  *  * LMC_INT = LMC Interrupt Register  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_int_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|ded_err
range|:
literal|4
decl_stmt|;
comment|/**< Double Error detected (DED) of Rd Data                                                          [0] corresponds to DQ[63:0]_c0_p0                                                          [1] corresponds to DQ[63:0]_c0_p1                                                          [2] corresponds to DQ[63:0]_c1_p0                                                          [3] corresponds to DQ[63:0]_c1_p1                                                          where _cC_pP denotes cycle C and phase P                                                          Write of 1 will clear the corresponding error bit */
name|uint64_t
name|sec_err
range|:
literal|4
decl_stmt|;
comment|/**< Single Error (corrected) of Rd Data                                                          [0] corresponds to DQ[63:0]_c0_p0                                                          [1] corresponds to DQ[63:0]_c0_p1                                                          [2] corresponds to DQ[63:0]_c1_p0                                                          [3] corresponds to DQ[63:0]_c1_p1                                                          where _cC_pP denotes cycle C and phase P                                                          Write of 1 will clear the corresponding error bit */
name|uint64_t
name|nxm_wr_err
range|:
literal|1
decl_stmt|;
comment|/**< Write to non-existent memory                                                          Write of 1 will clear the corresponding error bit */
else|#
directive|else
name|uint64_t
name|nxm_wr_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sec_err
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ded_err
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_int_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_int_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_int
name|cvmx_lmcx_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_int_en  *  * LMC_INT_EN = LMC Interrupt Enable Register  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_int_en_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|intr_ded_ena
range|:
literal|1
decl_stmt|;
comment|/**< ECC Double Error Detect(DED) Interrupt Enable bit                                                          When set, the memory controller raises a processor                                                          interrupt on detecting an uncorrectable Dbl Bit ECC                                                          error. */
name|uint64_t
name|intr_sec_ena
range|:
literal|1
decl_stmt|;
comment|/**< ECC Single Error Correct(SEC) Interrupt Enable bit                                                          When set, the memory controller raises a processor                                                          interrupt on detecting a correctable Single Bit ECC                                                          error. */
name|uint64_t
name|intr_nxm_wr_ena
range|:
literal|1
decl_stmt|;
comment|/**< Non Write Error Interrupt Enable bit                                                          When set, the memory controller raises a processor                                                          interrupt on detecting an non-existent memory write */
else|#
directive|else
name|uint64_t
name|intr_nxm_wr_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|intr_sec_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|intr_ded_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_int_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_int_en_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_int_en
name|cvmx_lmcx_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_mem_cfg0  *  * Specify the RSL base addresses for the block  *  *                  LMC_MEM_CFG0 = LMC Memory Configuration Register0  *  * This register controls certain parameters of  Memory Configuration  */
end_comment

begin_union
union|union
name|cvmx_lmcx_mem_cfg0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_mem_cfg0_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< Reset oneshot pulse for refresh counter,                                                          and LMC_OPS_CNT_*, LMC_IFB_CNT_*, and LMC_DCLK_CNT_*                                                          CSR's. SW should write this to a one, then re-write                                                          it to a zero to cause the reset. */
name|uint64_t
name|silo_qc
range|:
literal|1
decl_stmt|;
comment|/**< Adds a Quarter Cycle granularity to generate                                                          dqs pulse generation for silo.                                                          Combination of Silo_HC and Silo_QC gives the                                                          ability to position the read enable with quarter                                                          cycle resolution. This is applied on all the bytes                                                          uniformly. */
name|uint64_t
name|bunk_ena
range|:
literal|1
decl_stmt|;
comment|/**< Bunk Enable aka RANK ena (for use with dual-rank DIMMs)                                                          For dual-rank DIMMs, the bunk_ena bit will enable                                                          the drive of the CS_N[1:0] pins based on the                                                          (pbank_lsb-1) address bit.                                                          Write 0 for SINGLE ranked DIMM's. */
name|uint64_t
name|ded_err
range|:
literal|4
decl_stmt|;
comment|/**< Double Error detected (DED) of Rd Data                                                          In 128b mode, ecc is calulated on 1 cycle worth of data                                                          [25] corresponds to DQ[63:0], Phase0                                                          [26] corresponds to DQ[127:64], Phase0                                                          [27] corresponds to DQ[63:0], Phase1                                                          [28] corresponds to DQ[127:64], Phase1                                                          In 64b mode, ecc is calculated on 2 cycle worth of data                                                          [25] corresponds to DQ[63:0], Phase0, cycle0                                                          [26] corresponds to DQ[63:0], Phase0, cycle1                                                          [27] corresponds to DQ[63:0], Phase1, cycle0                                                          [28] corresponds to DQ[63:0], Phase1, cycle1                                                          Write of 1 will clear the corresponding error bit */
name|uint64_t
name|sec_err
range|:
literal|4
decl_stmt|;
comment|/**< Single Error (corrected) of Rd Data                                                          In 128b mode, ecc is calulated on 1 cycle worth of data                                                          [21] corresponds to DQ[63:0], Phase0                                                          [22] corresponds to DQ[127:64], Phase0                                                          [23] corresponds to DQ[63:0], Phase1                                                          [24] corresponds to DQ[127:64], Phase1                                                          In 64b mode, ecc is calculated on 2 cycle worth of data                                                          [21] corresponds to DQ[63:0], Phase0, cycle0                                                          [22] corresponds to DQ[63:0], Phase0, cycle1                                                          [23] corresponds to DQ[63:0], Phase1, cycle0                                                          [24] corresponds to DQ[63:0], Phase1, cycle1                                                          Write of 1 will clear the corresponding error bit */
name|uint64_t
name|intr_ded_ena
range|:
literal|1
decl_stmt|;
comment|/**< ECC Double Error Detect(DED) Interrupt Enable bit                                                          When set, the memory controller raises a processor                                                          interrupt on detecting an uncorrectable Dbl Bit ECC                                                          error. */
name|uint64_t
name|intr_sec_ena
range|:
literal|1
decl_stmt|;
comment|/**< ECC Single Error Correct(SEC) Interrupt Enable bit                                                          When set, the memory controller raises a processor                                                          interrupt on detecting a correctable Single Bit ECC                                                          error. */
name|uint64_t
name|tcl
range|:
literal|4
decl_stmt|;
comment|/**< This register is not used */
name|uint64_t
name|ref_int
range|:
literal|6
decl_stmt|;
comment|/**< Refresh interval represented in \#of 512 dclk increments.                                                          Program this to RND-DN(tREFI/clkPeriod/512)                                                             - 000000: RESERVED                                                             - 000001: 1 * 512  = 512 dclks                                                              - ...                                                             - 111111: 63 * 512 = 32256 dclks */
name|uint64_t
name|pbank_lsb
range|:
literal|4
decl_stmt|;
comment|/**< Physical Bank address select                                                                                  Reverting to the explanation for ROW_LSB,                                                                                  PBank_LSB would be Row_LSB bit + \#rowbits                                                                                  + \#rankbits                                                                                  In the 512MB DIMM Example, assuming no rank bits:                                                                                  pbank_lsb=mem_addr[15+13] for 64 b mode                                                                                           =mem_addr[16+13] for 128b mode                                                                                  Hence the parameter                                                          0000:pbank[1:0] = mem_adr[28:27]    / rank = mem_adr[26] (if bunk_ena)                                                          0001:pbank[1:0] = mem_adr[29:28]    / rank = mem_adr[27]      "                                                          0010:pbank[1:0] = mem_adr[30:29]    / rank = mem_adr[28]      "                                                          0011:pbank[1:0] = mem_adr[31:30]    / rank = mem_adr[29]      "                                                          0100:pbank[1:0] = mem_adr[32:31]    / rank = mem_adr[30]      "                                                          0101:pbank[1:0] = mem_adr[33:32]    / rank = mem_adr[31]      "                                                          0110:pbank[1:0] =[1'b0,mem_adr[33]] / rank = mem_adr[32]      "                                                          0111:pbank[1:0] =[2'b0]             / rank = mem_adr[33]      "                                                          1000-1111: RESERVED */
name|uint64_t
name|row_lsb
range|:
literal|3
decl_stmt|;
comment|/**< Encoding used to determine which memory address                                                          bit position represents the low order DDR ROW address.                                                          The processor's memory address[33:7] needs to be                                                          translated to DRAM addresses (bnk,row,col,rank and dimm)                                                          and that is a function of the following:                                                          1. \# Banks (4 or 8) - spec'd by BANK8                                                          2. Datapath Width(64 or 128) - MODE128b                                                          3. \# Ranks in a DIMM - spec'd by BUNK_ENA                                                          4. \# DIMM's in the system                                                          5. \# Column Bits of the memory part - spec'd indirectly                                                          by this register.                                                          6. \# Row Bits of the memory part - spec'd indirectly                                                          by the register below (PBANK_LSB).                                                          Illustration: For Micron's MT18HTF6472A,512MB DDR2                                                          Unbuffered DIMM which uses 256Mb parts (8M x 8 x 4),                                                          \# Banks = 4 -> 2 bits of BA                                                          \# Columns = 1K -> 10 bits of Col                                                          \# Rows = 8K -> 13 bits of Row                                                          Assuming that the total Data width is 128, this is how                                                          we arrive at row_lsb:                                                          Col Address starts from mem_addr[4] for 128b (16Bytes)                                                          dq width or from mem_addr[3] for 64b (8Bytes) dq width                                                          \# col + \# bank = 12. Hence row_lsb is mem_adr[15] for                                                          64bmode or mem_adr[16] for 128b mode. Hence row_lsb                                                          parameter should be set to 001 (64b) or 010 (128b).                                                               - 000: row_lsb = mem_adr[14]                                                               - 001: row_lsb = mem_adr[15]                                                               - 010: row_lsb = mem_adr[16]                                                               - 011: row_lsb = mem_adr[17]                                                               - 100: row_lsb = mem_adr[18]                                                               - 101-111:row_lsb = RESERVED */
name|uint64_t
name|ecc_ena
range|:
literal|1
decl_stmt|;
comment|/**< ECC Enable: When set will enable the 8b ECC                                                          check/correct logic. Should be 1 when used with DIMMs                                                          with ECC. 0, otherwise.                                                          When this mode is turned on, DQ[71:64] and DQ[143:137]                                                          on writes, will contain the ECC code generated for                                                          the lower 64 and upper 64 bits of data which will                                                          written in the memory and then later on reads, used                                                          to check for Single bit error (which will be auto-                                                          corrected) and Double Bit error (which will be                                                          reported). When not turned on, DQ[71:64] and DQ[143:137]                                                          are driven to 0.  Please refer to SEC_ERR, DED_ERR,                                                          LMC_FADR, and LMC_ECC_SYND registers                                                          for diagnostics information when there is an error. */
name|uint64_t
name|init_start
range|:
literal|1
decl_stmt|;
comment|/**< A 0->1 transition starts the DDR memory initialization                                                          sequence. */
else|#
directive|else
name|uint64_t
name|init_start
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ecc_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|row_lsb
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pbank_lsb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ref_int
range|:
literal|6
decl_stmt|;
name|uint64_t
name|tcl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|intr_sec_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|intr_ded_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sec_err
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ded_err
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bunk_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|silo_qc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_mem_cfg0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg0_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg0_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_mem_cfg0
name|cvmx_lmcx_mem_cfg0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_mem_cfg1  *  * LMC_MEM_CFG1 = LMC Memory Configuration Register1  *  * This register controls the External Memory Configuration Timing Parameters. Please refer to the  * appropriate DDR part spec from your memory vendor for the various values in this CSR.  * The details of each of these timing parameters can be found in the JEDEC spec or the vendor  * spec of the memory parts.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_mem_cfg1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_mem_cfg1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|comp_bypass
range|:
literal|1
decl_stmt|;
comment|/**< Compensation bypass. */
name|uint64_t
name|trrd
range|:
literal|3
decl_stmt|;
comment|/**< tRRD cycles: ACT-ACT timing parameter for different                                                          banks. (Represented in tCYC cycles == 1dclks)                                                          TYP=15ns (66MHz=1,167MHz=3,200MHz=3)                                                          For DDR2, TYP=7.5ns                                                             - 000: RESERVED                                                             - 001: 1 tCYC                                                             - 010: 2 tCYC                                                             - 011: 3 tCYC                                                             - 100: 4 tCYC                                                             - 101: 5 tCYC                                                             - 110: 6 tCYC                                                             - 111: 7 tCYC */
name|uint64_t
name|caslat
range|:
literal|3
decl_stmt|;
comment|/**< CAS Latency Encoding which is loaded into each DDR                                                          SDRAM device (MRS[6:4]) upon power-up (INIT_START=1).                                                          (Represented in tCYC cycles == 1 dclks)                                                             000 RESERVED                                                             001 RESERVED                                                             010 2.0 tCYC                                                             011 3.0 tCYC                                                             100 4.0 tCYC                                                             101 5.0 tCYC                                                             110 6.0 tCYC                                                             111 RESERVED                                                          eg). The parameters TSKW, SILO_HC, and SILO_QC can                                                          account for 1/4 cycle granularity in board/etch delays. */
name|uint64_t
name|tmrd
range|:
literal|3
decl_stmt|;
comment|/**< tMRD Cycles                                                          (Represented in dclk tCYC)                                                          For DDR2, its TYP 2*tCYC)                                                              - 000: RESERVED                                                              - 001: 1                                                              - 010: 2                                                              - 011: 3                                                              - 100: 4                                                              - 101-111: RESERVED */
name|uint64_t
name|trfc
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tRFC constraints.                                                          Set TRFC (CSR field) = RNDUP[tRFC(ns)/4*tcyc(ns)],                                                          where tRFC is from the DDR2 spec, and tcyc(ns)                                                          is the DDR clock frequency (not data rate).                                                          For example, with 2Gb, DDR2-667 parts,                                                          typ tRFC=195ns, so TRFC (CSR field) = 0x11.                                                              TRFC (binary): Corresponding tRFC Cycles                                                              ----------------------------------------                                                              - 00000-00001: RESERVED                                                              - 00010: 0-8                                                              - 00011: 9-12                                                              - 00100: 13-16                                                              - ...                                                              - 11110: 117-120                                                              - 11111: 121-124 */
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
comment|/**< tRP Cycles = RNDUP[tRP(ns)/tcyc(ns)]                                                          (Represented in tCYC cycles == 1dclk)                                                          TYP=15ns (66MHz=1,167MHz=3,400MHz=6 for TYP)                                                              - 0000: RESERVED                                                              - 0001: 1                                                              - ...                                                              - 1001: 9                                                              - 1010-1111: RESERVED                                                          When using parts with 8 banks (LMC_DDR2_CTL->BANK8                                                          is 1), load tRP cycles + 1 into this register. */
name|uint64_t
name|twtr
range|:
literal|4
decl_stmt|;
comment|/**< tWTR Cycles = RNDUP[tWTR(ns)/tcyc(ns)]                                                          Last Wr Data to Rd Command time.                                                          (Represented in tCYC cycles == 1dclks)                                                          TYP=15ns (66MHz=1,167MHz=3,400MHz=6, for TYP)                                                              - 0000: RESERVED                                                              - 0001: 1                                                              - ...                                                              - 0111: 7                                                              - 1000-1111: RESERVED */
name|uint64_t
name|trcd
range|:
literal|4
decl_stmt|;
comment|/**< tRCD Cycles = RNDUP[tRCD(ns)/tcyc(ns)]                                                          (Represented in tCYC cycles == 1dclk)                                                          TYP=15ns (66MHz=1,167MHz=3,400MHz=6 for TYP)                                                              - 0000: RESERVED                                                              - 0001: 2 (2 is the smallest value allowed)                                                              - 0002: 2                                                              - ...                                                              - 1001: 9                                                              - 1010-1111: RESERVED                                                          In 2T mode, make this register TRCD-1, not going                                                          below 2. */
name|uint64_t
name|tras
range|:
literal|5
decl_stmt|;
comment|/**< tRAS Cycles = RNDUP[tRAS(ns)/tcyc(ns)]                                                          (Represented in tCYC cycles == 1 dclk)                                                              - 00000-0001: RESERVED                                                              - 00010: 2                                                              - ...                                                              - 11111: 31 */
else|#
directive|else
name|uint64_t
name|tras
range|:
literal|5
decl_stmt|;
name|uint64_t
name|trcd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|twtr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trfc
range|:
literal|5
decl_stmt|;
name|uint64_t
name|tmrd
range|:
literal|3
decl_stmt|;
name|uint64_t
name|caslat
range|:
literal|3
decl_stmt|;
name|uint64_t
name|trrd
range|:
literal|3
decl_stmt|;
name|uint64_t
name|comp_bypass
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_mem_cfg1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg1_s
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_lmcx_mem_cfg1_cn38xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|trrd
range|:
literal|3
decl_stmt|;
comment|/**< tRRD cycles: ACT-ACT timing parameter for different                                                          banks. (Represented in tCYC cycles == 1dclks)                                                          TYP=15ns (66MHz=1,167MHz=3,200MHz=3)                                                          For DDR2, TYP=7.5ns                                                             - 000: RESERVED                                                             - 001: 1 tCYC                                                             - 010: 2 tCYC                                                             - 011: 3 tCYC                                                             - 100: 4 tCYC                                                             - 101: 5 tCYC                                                             - 110-111: RESERVED */
name|uint64_t
name|caslat
range|:
literal|3
decl_stmt|;
comment|/**< CAS Latency Encoding which is loaded into each DDR                                                          SDRAM device (MRS[6:4]) upon power-up (INIT_START=1).                                                          (Represented in tCYC cycles == 1 dclks)                                                             000 RESERVED                                                             001 RESERVED                                                             010 2.0 tCYC                                                             011 3.0 tCYC                                                             100 4.0 tCYC                                                             101 5.0 tCYC                                                             110 6.0 tCYC (DDR2)                                                                 2.5 tCYC (DDR1)                                                             111 RESERVED                                                          eg). The parameters TSKW, SILO_HC, and SILO_QC can                                                          account for 1/4 cycle granularity in board/etch delays. */
name|uint64_t
name|tmrd
range|:
literal|3
decl_stmt|;
comment|/**< tMRD Cycles                                                          (Represented in dclk tCYC)                                                          For DDR2, its TYP 2*tCYC)                                                              - 000: RESERVED                                                              - 001: 1                                                              - 010: 2                                                              - 011: 3                                                              - 100: 4                                                              - 101-111: RESERVED */
name|uint64_t
name|trfc
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tRFC constraints.                                                          Set TRFC (CSR field) = RNDUP[tRFC(ns)/4*tcyc(ns)],                                                          where tRFC is from the DDR2 spec, and tcyc(ns)                                                          is the DDR clock frequency (not data rate).                                                          For example, with 2Gb, DDR2-667 parts,                                                          typ tRFC=195ns, so TRFC (CSR field) = 0x11.                                                              TRFC (binary): Corresponding tRFC Cycles                                                              ----------------------------------------                                                              - 00000-00001: RESERVED                                                              - 00010: 0-8                                                              - 00011: 9-12                                                              - 00100: 13-16                                                              - ...                                                              - 11110: 117-120                                                              - 11111: 121-124 */
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
comment|/**< tRP Cycles = RNDUP[tRP(ns)/tcyc(ns)]                                                          (Represented in tCYC cycles == 1dclk)                                                          TYP=15ns (66MHz=1,167MHz=3,400MHz=6 for TYP)                                                              - 0000: RESERVED                                                              - 0001: 1                                                              - ...                                                              - 0111: 7                                                              - 1000-1111: RESERVED                                                          When using parts with 8 banks (LMC_DDR2_CTL->BANK8                                                          is 1), load tRP cycles + 1 into this register. */
name|uint64_t
name|twtr
range|:
literal|4
decl_stmt|;
comment|/**< tWTR Cycles = RNDUP[tWTR(ns)/tcyc(ns)]                                                          Last Wr Data to Rd Command time.                                                          (Represented in tCYC cycles == 1dclks)                                                          TYP=15ns (66MHz=1,167MHz=3,400MHz=6, for TYP)                                                              - 0000: RESERVED                                                              - 0001: 1                                                              - ...                                                              - 0111: 7                                                              - 1000-1111: RESERVED */
name|uint64_t
name|trcd
range|:
literal|4
decl_stmt|;
comment|/**< tRCD Cycles = RNDUP[tRCD(ns)/tcyc(ns)]                                                          (Represented in tCYC cycles == 1dclk)                                                          TYP=15ns (66MHz=1,167MHz=3,400MHz=6 for TYP)                                                              - 0000: RESERVED                                                              - 0001: 2 (2 is the smallest value allowed)                                                              - 0002: 2                                                              - ...                                                              - 0111: 7                                                              - 1110-1111: RESERVED                                                          In 2T mode, make this register TRCD-1, not going                                                          below 2. */
name|uint64_t
name|tras
range|:
literal|5
decl_stmt|;
comment|/**< tRAS Cycles = RNDUP[tRAS(ns)/tcyc(ns)]                                                          (Represented in tCYC cycles == 1 dclk)                                                          For DDR-I mode:                                                          TYP=45ns (66MHz=3,167MHz=8,400MHz=18                                                              - 00000-0001: RESERVED                                                              - 00010: 2                                                              - ...                                                              - 10100: 20                                                              - 10101-11111: RESERVED */
else|#
directive|else
name|uint64_t
name|tras
range|:
literal|5
decl_stmt|;
name|uint64_t
name|trcd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|twtr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trfc
range|:
literal|5
decl_stmt|;
name|uint64_t
name|tmrd
range|:
literal|3
decl_stmt|;
name|uint64_t
name|caslat
range|:
literal|3
decl_stmt|;
name|uint64_t
name|trrd
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_lmcx_mem_cfg1_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg1_cn38xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg1_cn38xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg1_cn38xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg1_cn38xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg1_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_mem_cfg1_cn38xx
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_mem_cfg1
name|cvmx_lmcx_mem_cfg1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_modereg_params0  *  * Notes:  * These parameters are written into the DDR3 MR0, MR1, MR2 and MR3 registers.  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_modereg_params0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_modereg_params0_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|ppd
range|:
literal|1
decl_stmt|;
comment|/**< DLL Control for precharge powerdown                                                          0 = Slow exit (DLL off)                                                          1 = Fast exit (DLL on)                                                          LMC writes this value to MR0[PPD] in the selected DDR3 parts                                                          during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          This value must equal the MR0[PPD] value in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|wrp
range|:
literal|3
decl_stmt|;
comment|/**< Write recovery for auto precharge                                                          Should be programmed to be equal to or greater than                                                          RNDUP[tWR(ns)/tCYC(ns)]                                                          000 = Reserved                                                          001 = 5                                                          010 = 6                                                          011 = 7                                                          100 = 8                                                          101 = 10                                                          110 = 12                                                          111 = Reserved                                                          LMC writes this value to MR0[WR] in the selected DDR3 parts                                                          during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          This value must equal the MR0[WR] value in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|dllr
range|:
literal|1
decl_stmt|;
comment|/**< DLL Reset                                                          LMC writes this value to MR0[DLL] in the selected DDR3 parts                                                          during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          The MR0[DLL] value must be 0 in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|tm
range|:
literal|1
decl_stmt|;
comment|/**< Test Mode                                                          LMC writes this value to MR0[TM] in the selected DDR3 parts                                                          during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          The MR0[TM] value must be 0 in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|rbt
range|:
literal|1
decl_stmt|;
comment|/**< Read Burst Type                                                          1 = interleaved (fixed)                                                          LMC writes this value to MR0[RBT] in the selected DDR3 parts                                                          during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          The MR0[RBT] value must be 1 in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|cl
range|:
literal|4
decl_stmt|;
comment|/**< CAS Latency                                                          0010 = 5                                                          0100 = 6                                                          0110 = 7                                                          1000 = 8                                                          1010 = 9                                                          1100 = 10                                                          1110 = 11                                                          0000, ???1 = Reserved                                                          LMC writes this value to MR0[CAS Latency / CL] in the selected DDR3 parts                                                          during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          This value must equal the MR0[CAS Latency / CL] value in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|bl
range|:
literal|2
decl_stmt|;
comment|/**< Burst Length                                                          0 = 8 (fixed)                                                          LMC writes this value to MR0[BL] in the selected DDR3 parts                                                          during power-up/init and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          The MR0[BL] value must be 0 in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|qoff
range|:
literal|1
decl_stmt|;
comment|/**< Qoff Enable                                                          0 = enable                                                          1 = disable                                                          LMC writes this value to MR1[Qoff] in the DDR3 parts in the selected ranks                                                          during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK,INIT_STATUS] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].                                                          The MR1[Qoff] value must be 0 in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|tdqs
range|:
literal|1
decl_stmt|;
comment|/**< TDQS Enable                                                          0 = disable                                                          LMC writes this value to MR1[TDQS] in the DDR3 parts in the selected ranks                                                          during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK,INIT_STATUS] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|wlev
range|:
literal|1
decl_stmt|;
comment|/**< Write Leveling Enable                                                          0 = disable                                                          LMC writes MR1[Level]=0 in the DDR3 parts in the selected ranks                                                          during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          (Write-leveling can only be initiated via the                                                          write-leveling instruction sequence.)                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK,INIT_STATUS] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|al
range|:
literal|2
decl_stmt|;
comment|/**< Additive Latency                                                          00 = 0                                                          01 = CL-1                                                          10 = CL-2                                                          11 = Reserved                                                          LMC writes this value to MR1[AL] in the selected DDR3 parts                                                          during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].                                                          This value must equal the MR1[AL] value in all the DDR3                                                          parts attached to all ranks during normal operation.                                                          See also LMC*_CONTROL[POCAS]. */
name|uint64_t
name|dll
range|:
literal|1
decl_stmt|;
comment|/**< DLL Enable                                                          0 = enable                                                          1 = disable.                                                          LMC writes this value to MR1[DLL] in the selected DDR3 parts                                                          during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].                                                          This value must equal the MR1[DLL] value in all the DDR3                                                          parts attached to all ranks during normal operation.                                                          In dll-off mode, CL/CWL must be programmed                                                          equal to 6/6, respectively, as per the DDR3 specifications. */
name|uint64_t
name|mpr
range|:
literal|1
decl_stmt|;
comment|/**< MPR                                                          LMC writes this value to MR3[MPR] in the selected DDR3 parts                                                          during power-up/init, read-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh exit instruction sequences.                                                          (LMC also writes MR3[MPR]=1 at the beginning of the                                                          read-leveling instruction sequence. Read-leveling should only be initiated via the                                                          read-leveling instruction sequence.)                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          The MR3[MPR] value must be 0 in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|mprloc
range|:
literal|2
decl_stmt|;
comment|/**< MPR Location                                                          LMC writes this value to MR3[MPRLoc] in the selected DDR3 parts                                                          during power-up/init, read-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh exit instruction sequences.                                                          (LMC also writes MR3[MPRLoc]=0 at the beginning of the                                                          read-leveling instruction sequence.)                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          The MR3[MPRLoc] value must be 0 in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|cwl
range|:
literal|3
decl_stmt|;
comment|/**< CAS Write Latency                                                          - 000: 5                                                          - 001: 6                                                          - 010: 7                                                          - 011: 8                                                          1xx: Reserved                                                          LMC writes this value to MR2[CWL] in the selected DDR3 parts                                                          during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].                                                          This value must equal the MR2[CWL] value in all the DDR3                                                          parts attached to all ranks during normal operation. */
else|#
directive|else
name|uint64_t
name|cwl
range|:
literal|3
decl_stmt|;
name|uint64_t
name|mprloc
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mpr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dll
range|:
literal|1
decl_stmt|;
name|uint64_t
name|al
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wlev
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tdqs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qoff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bl
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rbt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dllr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wrp
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ppd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_modereg_params0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_modereg_params0_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_modereg_params0
name|cvmx_lmcx_modereg_params0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_modereg_params1  *  * Notes:  * These parameters are written into the DDR3 MR0, MR1, MR2 and MR3 registers.  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_modereg_params1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_modereg_params1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|rtt_nom_11
range|:
literal|3
decl_stmt|;
comment|/**< RTT_NOM Rank 3                                                          LMC writes this value to MR1[Rtt_Nom] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].                                                          Per JEDEC DDR3 specifications, if RTT_Nom is used during writes,                                                          only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6) are allowed.                                                          Otherwise, values MR1[Rtt_Nom] = 4 (RQZ/12) and 5 (RQZ/8) are also allowed. */
name|uint64_t
name|dic_11
range|:
literal|2
decl_stmt|;
comment|/**< Output Driver Impedance Control Rank 3                                                          LMC writes this value to MR1[D.I.C.] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|rtt_wr_11
range|:
literal|2
decl_stmt|;
comment|/**< RTT_WR Rank 3                                                          LMC writes this value to MR2[Rtt_WR] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|srt_11
range|:
literal|1
decl_stmt|;
comment|/**< Self-refresh temperature range Rank 3                                                          LMC writes this value to MR2[SRT] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|asr_11
range|:
literal|1
decl_stmt|;
comment|/**< Auto self-refresh Rank 3                                                          LMC writes this value to MR2[ASR] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|pasr_11
range|:
literal|3
decl_stmt|;
comment|/**< Partial array self-refresh Rank 3                                                          LMC writes this value to MR2[PASR] in the rank 3 (i.e. DIMM1_CS1) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|rtt_nom_10
range|:
literal|3
decl_stmt|;
comment|/**< RTT_NOM Rank 2                                                          LMC writes this value to MR1[Rtt_Nom] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].                                                          Per JEDEC DDR3 specifications, if RTT_Nom is used during writes,                                                          only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6) are allowed.                                                          Otherwise, values MR1[Rtt_Nom] = 4 (RQZ/12) and 5 (RQZ/8) are also allowed. */
name|uint64_t
name|dic_10
range|:
literal|2
decl_stmt|;
comment|/**< Output Driver Impedance Control Rank 2                                                          LMC writes this value to MR1[D.I.C.] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|rtt_wr_10
range|:
literal|2
decl_stmt|;
comment|/**< RTT_WR Rank 2                                                          LMC writes this value to MR2[Rtt_WR] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|srt_10
range|:
literal|1
decl_stmt|;
comment|/**< Self-refresh temperature range Rank 2                                                          LMC writes this value to MR2[SRT] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|asr_10
range|:
literal|1
decl_stmt|;
comment|/**< Auto self-refresh Rank 2                                                          LMC writes this value to MR2[ASR] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|pasr_10
range|:
literal|3
decl_stmt|;
comment|/**< Partial array self-refresh Rank 2                                                          LMC writes this value to MR2[PASR] in the rank 2 (i.e. DIMM1_CS0) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|rtt_nom_01
range|:
literal|3
decl_stmt|;
comment|/**< RTT_NOM Rank 1                                                          LMC writes this value to MR1[Rtt_Nom] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].                                                          Per JEDEC DDR3 specifications, if RTT_Nom is used during writes,                                                          only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6) are allowed.                                                          Otherwise, values MR1[Rtt_Nom] = 4 (RQZ/12) and 5 (RQZ/8) are also allowed. */
name|uint64_t
name|dic_01
range|:
literal|2
decl_stmt|;
comment|/**< Output Driver Impedance Control Rank 1                                                          LMC writes this value to MR1[D.I.C.] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|rtt_wr_01
range|:
literal|2
decl_stmt|;
comment|/**< RTT_WR Rank 1                                                          LMC writes this value to MR2[Rtt_WR] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|srt_01
range|:
literal|1
decl_stmt|;
comment|/**< Self-refresh temperature range Rank 1                                                          LMC writes this value to MR2[SRT] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|asr_01
range|:
literal|1
decl_stmt|;
comment|/**< Auto self-refresh Rank 1                                                          LMC writes this value to MR2[ASR] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|pasr_01
range|:
literal|3
decl_stmt|;
comment|/**< Partial array self-refresh Rank 1                                                          LMC writes this value to MR2[PASR] in the rank 1 (i.e. DIMM0_CS1) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|rtt_nom_00
range|:
literal|3
decl_stmt|;
comment|/**< RTT_NOM Rank 0                                                          LMC writes this value to MR1[Rtt_Nom] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT].                                                          Per JEDEC DDR3 specifications, if RTT_Nom is used during writes,                                                          only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6) are allowed.                                                          Otherwise, values MR1[Rtt_Nom] = 4 (RQZ/12) and 5 (RQZ/8) are also allowed. */
name|uint64_t
name|dic_00
range|:
literal|2
decl_stmt|;
comment|/**< Output Driver Impedance Control Rank 0                                                          LMC writes this value to MR1[D.I.C.] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|rtt_wr_00
range|:
literal|2
decl_stmt|;
comment|/**< RTT_WR Rank 0                                                          LMC writes this value to MR2[Rtt_WR] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|srt_00
range|:
literal|1
decl_stmt|;
comment|/**< Self-refresh temperature range Rank 0                                                          LMC writes this value to MR2[SRT] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|asr_00
range|:
literal|1
decl_stmt|;
comment|/**< Auto self-refresh Rank 0                                                          LMC writes this value to MR2[ASR] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|pasr_00
range|:
literal|3
decl_stmt|;
comment|/**< Partial array self-refresh Rank 0                                                          LMC writes this value to MR2[PASR] in the rank 0 (i.e. DIMM0_CS0) DDR3 parts                                                          when selected during power-up/init, write-leveling, and, if LMC*_CONFIG[SREF_WITH_DLL] is set,                                                          self-refresh entry and exit instruction sequences.                                                          See LMC*_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          LMC*_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
else|#
directive|else
name|uint64_t
name|pasr_00
range|:
literal|3
decl_stmt|;
name|uint64_t
name|asr_00
range|:
literal|1
decl_stmt|;
name|uint64_t
name|srt_00
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtt_wr_00
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dic_00
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rtt_nom_00
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pasr_01
range|:
literal|3
decl_stmt|;
name|uint64_t
name|asr_01
range|:
literal|1
decl_stmt|;
name|uint64_t
name|srt_01
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtt_wr_01
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dic_01
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rtt_nom_01
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pasr_10
range|:
literal|3
decl_stmt|;
name|uint64_t
name|asr_10
range|:
literal|1
decl_stmt|;
name|uint64_t
name|srt_10
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtt_wr_10
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dic_10
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rtt_nom_10
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pasr_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|asr_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|srt_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtt_wr_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dic_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rtt_nom_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_modereg_params1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_modereg_params1_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_modereg_params1
name|cvmx_lmcx_modereg_params1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_nxm  *  * LMC_NXM = LMC non-existent memory  *  *  * Notes:  * Decoding for mem_msb/rank  *      - 0000: mem_msb = mem_adr[25]  *      - 0001: mem_msb = mem_adr[26]  *      - 0010: mem_msb = mem_adr[27]  *      - 0011: mem_msb = mem_adr[28]  *      - 0100: mem_msb = mem_adr[29]  *      - 0101: mem_msb = mem_adr[30]  *      - 0110: mem_msb = mem_adr[31]  *      - 0111: mem_msb = mem_adr[32]  *      - 1000: mem_msb = mem_adr[33]  *      - 1001: mem_msb = mem_adr[34]  *      1010-1111 = Reserved  * For example, for a DIMM made of Samsung's k4b1g0846c-f7 1Gb (16M x 8 bit x 8 bank)  * DDR3 parts, the column address width = 10, so with  * 10b of col, 3b of bus, 3b of bank, row_lsb = 16. So, row = mem_adr[29:16] and  * mem_msb = 4  *  * Note also that addresses greater the max defined space (pbank_msb) are also treated  * as NXM accesses  */
end_comment

begin_union
union|union
name|cvmx_lmcx_nxm
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_nxm_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|mem_msb_d3_r1
range|:
literal|4
decl_stmt|;
comment|/**< Max Row MSB for DIMM3, RANK1/DIMM3 in Single Ranked */
name|uint64_t
name|mem_msb_d3_r0
range|:
literal|4
decl_stmt|;
comment|/**< Max Row MSB for DIMM3, RANK0 */
name|uint64_t
name|mem_msb_d2_r1
range|:
literal|4
decl_stmt|;
comment|/**< Max Row MSB for DIMM2, RANK1/DIMM2 in Single Ranked */
name|uint64_t
name|mem_msb_d2_r0
range|:
literal|4
decl_stmt|;
comment|/**< Max Row MSB for DIMM2, RANK0 */
name|uint64_t
name|mem_msb_d1_r1
range|:
literal|4
decl_stmt|;
comment|/**< Max Row MSB for DIMM1, RANK1/DIMM1 in Single Ranked */
name|uint64_t
name|mem_msb_d1_r0
range|:
literal|4
decl_stmt|;
comment|/**< Max Row MSB for DIMM1, RANK0 */
name|uint64_t
name|mem_msb_d0_r1
range|:
literal|4
decl_stmt|;
comment|/**< Max Row MSB for DIMM0, RANK1/DIMM0 in Single Ranked */
name|uint64_t
name|mem_msb_d0_r0
range|:
literal|4
decl_stmt|;
comment|/**< Max Row MSB for DIMM0, RANK0 */
name|uint64_t
name|cs_mask
range|:
literal|8
decl_stmt|;
comment|/**< Chip select mask.                                                          This mask corresponds to the 8 chip selects for a memory                                                          configuration.  If LMC*_CONFIG[RANK_ENA]==0 then this                                                          mask must be set in pairs because each reference address                                                          will assert a pair of chip selects.  If the chip                                                          select(s) have a corresponding CS_MASK bit set, then the                                                          reference is to non-existent memory (NXM).  LMC will alias a                                                          NXM read reference to use the lowest, legal chip select(s)                                                          and return 0's. LMC normally discards NXM writes, but will                                                          also alias them when LMC*_CONTROL[NXM_WRITE_EN]=1.                                                          CS_MASK<7:4> MBZ in 63xx */
else|#
directive|else
name|uint64_t
name|cs_mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|mem_msb_d0_r0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mem_msb_d0_r1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mem_msb_d1_r0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mem_msb_d1_r1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mem_msb_d2_r0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mem_msb_d2_r1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mem_msb_d3_r0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mem_msb_d3_r1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_lmcx_nxm_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|cs_mask
range|:
literal|8
decl_stmt|;
comment|/**< Chip select mask.                                                          This mask corresponds to the 8 chip selects for a memory                                                          configuration.  If LMC_MEM_CFG0[BUNK_ENA]==0 then this                                                          mask must be set in pairs because each reference address                                                          will assert a pair of chip selects.  If the chip                                                          select(s) have a corresponding CS_MASK bit set, then the                                                          reference is to non-existent memory.  LMC will alias the                                                          reference to use the lowest, legal chip select(s) in                                                          that case. */
else|#
directive|else
name|uint64_t
name|cs_mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_lmcx_nxm_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_nxm_cn52xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_nxm_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_nxm_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_nxm
name|cvmx_lmcx_nxm_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_ops_cnt  *  * LMC_OPS_CNT  = Performance Counters  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_ops_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_ops_cnt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|opscnt
range|:
literal|64
decl_stmt|;
comment|/**< Performance Counter                                                          64-bit counter that increments when the DDR3 data bus                                                          is being used                                                          DRAM bus utilization = LMC*_OPS_CNT/LMC*_DCLK_CNT */
else|#
directive|else
name|uint64_t
name|opscnt
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_ops_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_ops_cnt
name|cvmx_lmcx_ops_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_ops_cnt_hi  *  * LMC_OPS_CNT_HI  = Performance Counters  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_ops_cnt_hi
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_ops_cnt_hi_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|opscnt_hi
range|:
literal|32
decl_stmt|;
comment|/**< Performance Counter to measure Bus Utilization                                                          Upper 32-bits of 64-bit counter                                                            DRAM bus utilization = LMC_OPS_CNT_* /LMC_DCLK_CNT_* */
else|#
directive|else
name|uint64_t
name|opscnt_hi
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_ops_cnt_hi_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_hi_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_hi_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_hi_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_hi_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_hi_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_hi_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_hi_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_hi_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_hi_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_hi_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_ops_cnt_hi
name|cvmx_lmcx_ops_cnt_hi_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_ops_cnt_lo  *  * LMC_OPS_CNT_LO  = Performance Counters  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_ops_cnt_lo
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_ops_cnt_lo_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|opscnt_lo
range|:
literal|32
decl_stmt|;
comment|/**< Performance Counter                                                          Low 32-bits of 64-bit counter                                                            DRAM bus utilization = LMC_OPS_CNT_* /LMC_DCLK_CNT_* */
else|#
directive|else
name|uint64_t
name|opscnt_lo
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_ops_cnt_lo_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_lo_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_lo_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_lo_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_lo_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_lo_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_lo_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_lo_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_lo_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_lo_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_ops_cnt_lo_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_ops_cnt_lo
name|cvmx_lmcx_ops_cnt_lo_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_phy_ctl  *  * LMC_PHY_CTL = LMC PHY Control  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_phy_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_phy_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
name|uint64_t
name|rx_always_on
range|:
literal|1
decl_stmt|;
comment|/**< Disable dynamic DDR3 IO Rx power gating */
name|uint64_t
name|lv_mode
range|:
literal|1
decl_stmt|;
comment|/**< Low Voltage Mode (1.35V) */
name|uint64_t
name|ck_tune1
range|:
literal|1
decl_stmt|;
comment|/**< Clock Tune */
name|uint64_t
name|ck_dlyout1
range|:
literal|4
decl_stmt|;
comment|/**< Clock delay out setting */
name|uint64_t
name|ck_tune0
range|:
literal|1
decl_stmt|;
comment|/**< Clock Tune */
name|uint64_t
name|ck_dlyout0
range|:
literal|4
decl_stmt|;
comment|/**< Clock delay out setting */
name|uint64_t
name|loopback
range|:
literal|1
decl_stmt|;
comment|/**< Loopback enable */
name|uint64_t
name|loopback_pos
range|:
literal|1
decl_stmt|;
comment|/**< Loopback pos mode */
name|uint64_t
name|ts_stagger
range|:
literal|1
decl_stmt|;
comment|/**< TS Staggermode                                                          This mode configures output drivers with 2-stage drive                                                          strength to avoid undershoot issues on the bus when strong                                                          drivers are suddenly turned on. When this mode is asserted,                                                          Octeon will configure output drivers to be weak drivers                                                          (60 ohm output impedance) at the first CK cycle, and                                                          change drivers to the designated drive strengths specified                                                          in $LMC(0)_COMP_CTL2 [CMD_CTL/CK_CTL/DQX_CTL] starting                                                          at the following cycle */
else|#
directive|else
name|uint64_t
name|ts_stagger
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loopback_pos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loopback
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ck_dlyout0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ck_tune0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ck_dlyout1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ck_tune1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lv_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_always_on
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_phy_ctl_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_lmcx_phy_ctl_cn63xxp1
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|lv_mode
range|:
literal|1
decl_stmt|;
comment|/**< Low Voltage Mode (1.35V) */
name|uint64_t
name|ck_tune1
range|:
literal|1
decl_stmt|;
comment|/**< Clock Tune */
name|uint64_t
name|ck_dlyout1
range|:
literal|4
decl_stmt|;
comment|/**< Clock delay out setting */
name|uint64_t
name|ck_tune0
range|:
literal|1
decl_stmt|;
comment|/**< Clock Tune */
name|uint64_t
name|ck_dlyout0
range|:
literal|4
decl_stmt|;
comment|/**< Clock delay out setting */
name|uint64_t
name|loopback
range|:
literal|1
decl_stmt|;
comment|/**< Loopback enable */
name|uint64_t
name|loopback_pos
range|:
literal|1
decl_stmt|;
comment|/**< Loopback pos mode */
name|uint64_t
name|ts_stagger
range|:
literal|1
decl_stmt|;
comment|/**< TS Staggermode                                                          This mode configures output drivers with 2-stage drive                                                          strength to avoid undershoot issues on the bus when strong                                                          drivers are suddenly turned on. When this mode is asserted,                                                          Octeon will configure output drivers to be weak drivers                                                          (60 ohm output impedance) at the first CK cycle, and                                                          change drivers to the designated drive strengths specified                                                          in $LMC(0)_COMP_CTL2 [CMD_CTL/CK_CTL/DQX_CTL] starting                                                          at the following cycle */
else|#
directive|else
name|uint64_t
name|ts_stagger
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loopback_pos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loopback
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ck_dlyout0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ck_tune0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ck_dlyout1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ck_tune1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lv_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_phy_ctl
name|cvmx_lmcx_phy_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_pll_bwctl  *  * LMC_PLL_BWCTL  = DDR PLL Bandwidth Control Register  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_pll_bwctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_pll_bwctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|bwupd
range|:
literal|1
decl_stmt|;
comment|/**< Load this Bandwidth Register value into the PLL */
name|uint64_t
name|bwctl
range|:
literal|4
decl_stmt|;
comment|/**< Bandwidth Control Register for DDR PLL */
else|#
directive|else
name|uint64_t
name|bwctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bwupd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_pll_bwctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_lmcx_pll_bwctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_lmcx_pll_bwctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_lmcx_pll_bwctl_s
name|cn38xxp2
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_pll_bwctl
name|cvmx_lmcx_pll_bwctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_pll_ctl  *  * LMC_PLL_CTL = LMC pll control  *  *  * Notes:  * This CSR is only relevant for LMC0. LMC1_PLL_CTL is not used.  *  * Exactly one of EN2, EN4, EN6, EN8, EN12, EN16 must be set.  *  * The resultant DDR_CK frequency is the DDR2_REF_CLK  * frequency multiplied by:  *  *     (CLKF + 1) / ((CLKR + 1) * EN(2,4,6,8,12,16))  *  * The PLL frequency, which is:  *  *     (DDR2_REF_CLK freq) * ((CLKF + 1) / (CLKR + 1))  *  * must reside between 1.2 and 2.5 GHz. A faster PLL frequency is desirable if there is a choice.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_pll_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_pll_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_30_63
range|:
literal|34
decl_stmt|;
name|uint64_t
name|bypass
range|:
literal|1
decl_stmt|;
comment|/**< PLL Bypass */
name|uint64_t
name|fasten_n
range|:
literal|1
decl_stmt|;
comment|/**< Should be set, especially when CLKF> ~80 */
name|uint64_t
name|div_reset
range|:
literal|1
decl_stmt|;
comment|/**< Analog pll divider reset                                                          De-assert at least 500*(CLKR+1) reference clock                                                          cycles following RESET_N de-assertion. */
name|uint64_t
name|reset_n
range|:
literal|1
decl_stmt|;
comment|/**< Analog pll reset                                                          De-assert at least 5 usec after CLKF, CLKR,                                                          and EN* are set up. */
name|uint64_t
name|clkf
range|:
literal|12
decl_stmt|;
comment|/**< Multiply reference by CLKF + 1                                                          CLKF must be<= 128 */
name|uint64_t
name|clkr
range|:
literal|6
decl_stmt|;
comment|/**< Divide reference by CLKR + 1 */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|en16
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 16 */
name|uint64_t
name|en12
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 12 */
name|uint64_t
name|en8
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 8 */
name|uint64_t
name|en6
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 6 */
name|uint64_t
name|en4
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 4 */
name|uint64_t
name|en2
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 2 */
else|#
directive|else
name|uint64_t
name|en2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en12
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en16
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|clkr
range|:
literal|6
decl_stmt|;
name|uint64_t
name|clkf
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reset_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|div_reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fasten_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bypass
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_30_63
range|:
literal|34
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_lmcx_pll_ctl_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|fasten_n
range|:
literal|1
decl_stmt|;
comment|/**< Should be set, especially when CLKF> ~80 */
name|uint64_t
name|div_reset
range|:
literal|1
decl_stmt|;
comment|/**< Analog pll divider reset                                                          De-assert at least 500*(CLKR+1) reference clock                                                          cycles following RESET_N de-assertion. */
name|uint64_t
name|reset_n
range|:
literal|1
decl_stmt|;
comment|/**< Analog pll reset                                                          De-assert at least 5 usec after CLKF, CLKR,                                                          and EN* are set up. */
name|uint64_t
name|clkf
range|:
literal|12
decl_stmt|;
comment|/**< Multiply reference by CLKF + 1                                                          CLKF must be<= 256 */
name|uint64_t
name|clkr
range|:
literal|6
decl_stmt|;
comment|/**< Divide reference by CLKR + 1 */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|en16
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 16 */
name|uint64_t
name|en12
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 12 */
name|uint64_t
name|en8
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 8 */
name|uint64_t
name|en6
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 6 */
name|uint64_t
name|en4
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 4 */
name|uint64_t
name|en2
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 2 */
else|#
directive|else
name|uint64_t
name|en2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en12
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en16
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|clkr
range|:
literal|6
decl_stmt|;
name|uint64_t
name|clkf
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reset_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|div_reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fasten_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_lmcx_pll_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_pll_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_pll_ctl_cn50xx
name|cn56xx
decl_stmt|;
struct|struct
name|cvmx_lmcx_pll_ctl_cn56xxp1
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|div_reset
range|:
literal|1
decl_stmt|;
comment|/**< Analog pll divider reset                                                          De-assert at least 500*(CLKR+1) reference clock                                                          cycles following RESET_N de-assertion. */
name|uint64_t
name|reset_n
range|:
literal|1
decl_stmt|;
comment|/**< Analog pll reset                                                          De-assert at least 5 usec after CLKF, CLKR,                                                          and EN* are set up. */
name|uint64_t
name|clkf
range|:
literal|12
decl_stmt|;
comment|/**< Multiply reference by CLKF + 1                                                          CLKF must be<= 128 */
name|uint64_t
name|clkr
range|:
literal|6
decl_stmt|;
comment|/**< Divide reference by CLKR + 1 */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|en16
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 16 */
name|uint64_t
name|en12
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 12 */
name|uint64_t
name|en8
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 8 */
name|uint64_t
name|en6
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 6 */
name|uint64_t
name|en4
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 4 */
name|uint64_t
name|en2
range|:
literal|1
decl_stmt|;
comment|/**< Divide output by 2 */
else|#
directive|else
name|uint64_t
name|en2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en12
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en16
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|clkr
range|:
literal|6
decl_stmt|;
name|uint64_t
name|clkf
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reset_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|div_reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xxp1
struct|;
name|struct
name|cvmx_lmcx_pll_ctl_cn56xxp1
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_pll_ctl_cn56xxp1
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_pll_ctl
name|cvmx_lmcx_pll_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_pll_status  *  * LMC_PLL_STATUS = LMC pll status  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_pll_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_pll_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ddr__nctl
range|:
literal|5
decl_stmt|;
comment|/**< DDR nctl from compensation circuit */
name|uint64_t
name|ddr__pctl
range|:
literal|5
decl_stmt|;
comment|/**< DDR pctl from compensation circuit */
name|uint64_t
name|reserved_2_21
range|:
literal|20
decl_stmt|;
name|uint64_t
name|rfslip
range|:
literal|1
decl_stmt|;
comment|/**< Reference clock slip */
name|uint64_t
name|fbslip
range|:
literal|1
decl_stmt|;
comment|/**< Feedback clock slip */
else|#
directive|else
name|uint64_t
name|fbslip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rfslip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_21
range|:
literal|20
decl_stmt|;
name|uint64_t
name|ddr__pctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|ddr__nctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_pll_status_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_pll_status_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_pll_status_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_pll_status_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_pll_status_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_pll_status_s
name|cn58xx
decl_stmt|;
struct|struct
name|cvmx_lmcx_pll_status_cn58xxp1
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|rfslip
range|:
literal|1
decl_stmt|;
comment|/**< Reference clock slip */
name|uint64_t
name|fbslip
range|:
literal|1
decl_stmt|;
comment|/**< Feedback clock slip */
else|#
directive|else
name|uint64_t
name|fbslip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rfslip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_pll_status
name|cvmx_lmcx_pll_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_read_level_ctl  *  * Notes:  * The HW writes and reads the cache block selected by ROW, COL, BNK and the rank as part of a read-leveling sequence for a rank.  * A cache block write is 16 72-bit words. PATTERN selects the write value. For the first 8  * words, the write value is the bit PATTERN<i> duplicated into a 72-bit vector. The write value of  * the last 8 words is the inverse of the write value of the first 8 words.  * See LMC*_READ_LEVEL_RANK*.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_read_level_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_read_level_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|rankmask
range|:
literal|4
decl_stmt|;
comment|/**< Selects ranks to be leveled                                                          to read-level rank i, set RANKMASK<i> */
name|uint64_t
name|pattern
range|:
literal|8
decl_stmt|;
comment|/**< All DQ driven to PATTERN[burst], 0<= burst<= 7                                                          All DQ driven to ~PATTERN[burst-8], 8<= burst<= 15 */
name|uint64_t
name|row
range|:
literal|16
decl_stmt|;
comment|/**< Row    address used to write/read data pattern */
name|uint64_t
name|col
range|:
literal|12
decl_stmt|;
comment|/**< Column address used to write/read data pattern */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bnk
range|:
literal|3
decl_stmt|;
comment|/**< Bank   address used to write/read data pattern */
else|#
directive|else
name|uint64_t
name|bnk
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|col
range|:
literal|12
decl_stmt|;
name|uint64_t
name|row
range|:
literal|16
decl_stmt|;
name|uint64_t
name|pattern
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rankmask
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_read_level_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_read_level_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_read_level_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_read_level_ctl_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_read_level_ctl
name|cvmx_lmcx_read_level_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_read_level_dbg  *  * Notes:  * A given read of LMC*_READ_LEVEL_DBG returns the read-leveling pass/fail results for all possible  * delay settings (i.e. the BITMASK) for only one byte in the last rank that the HW read-leveled.  * LMC*_READ_LEVEL_DBG[BYTE] selects the particular byte.  * To get these pass/fail results for another different rank, you must run the hardware read-leveling  * again. For example, it is possible to get the BITMASK results for every byte of every rank  * if you run read-leveling separately for each rank, probing LMC*_READ_LEVEL_DBG between each  * read-leveling.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_read_level_dbg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_read_level_dbg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|bitmask
range|:
literal|16
decl_stmt|;
comment|/**< Bitmask generated during deskew settings sweep                                                          BITMASK[n]=0 means deskew setting n failed                                                          BITMASK[n]=1 means deskew setting n passed                                                          for 0<= n<= 15 */
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|byte
range|:
literal|4
decl_stmt|;
comment|/**< 0<= BYTE<= 8 */
else|#
directive|else
name|uint64_t
name|byte
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|bitmask
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_read_level_dbg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_read_level_dbg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_read_level_dbg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_read_level_dbg_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_read_level_dbg
name|cvmx_lmcx_read_level_dbg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_read_level_rank#  *  * Notes:  * This is four CSRs per LMC, one per each rank.  * Each CSR is written by HW during a read-leveling sequence for the rank. (HW sets STATUS==3 after HW read-leveling completes for the rank.)  * Each CSR may also be written by SW, but not while a read-leveling sequence is in progress. (HW sets STATUS==1 after a CSR write.)  * Deskew setting is measured in units of 1/4 DCLK, so the above BYTE* values can range over 4 DCLKs.  * SW initiates a HW read-leveling sequence by programming LMC*_READ_LEVEL_CTL and writing INIT_START=1 with SEQUENCE=1.  * See LMC*_READ_LEVEL_CTL.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_read_level_rankx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_read_level_rankx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|status
range|:
literal|2
decl_stmt|;
comment|/**< Indicates status of the read-levelling and where                                                          the BYTE* programmings in<35:0> came from:                                                          0 = BYTE* values are their reset value                                                          1 = BYTE* values were set via a CSR write to this register                                                          2 = read-leveling sequence currently in progress (BYTE* values are unpredictable)                                                          3 = BYTE* values came from a complete read-leveling sequence */
name|uint64_t
name|byte8
range|:
literal|4
decl_stmt|;
comment|/**< Deskew setting */
name|uint64_t
name|byte7
range|:
literal|4
decl_stmt|;
comment|/**< Deskew setting */
name|uint64_t
name|byte6
range|:
literal|4
decl_stmt|;
comment|/**< Deskew setting */
name|uint64_t
name|byte5
range|:
literal|4
decl_stmt|;
comment|/**< Deskew setting */
name|uint64_t
name|byte4
range|:
literal|4
decl_stmt|;
comment|/**< Deskew setting */
name|uint64_t
name|byte3
range|:
literal|4
decl_stmt|;
comment|/**< Deskew setting */
name|uint64_t
name|byte2
range|:
literal|4
decl_stmt|;
comment|/**< Deskew setting */
name|uint64_t
name|byte1
range|:
literal|4
decl_stmt|;
comment|/**< Deskew setting */
name|uint64_t
name|byte0
range|:
literal|4
decl_stmt|;
comment|/**< Deskew setting */
else|#
directive|else
name|uint64_t
name|byte0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|byte1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|byte2
range|:
literal|4
decl_stmt|;
name|uint64_t
name|byte3
range|:
literal|4
decl_stmt|;
name|uint64_t
name|byte4
range|:
literal|4
decl_stmt|;
name|uint64_t
name|byte5
range|:
literal|4
decl_stmt|;
name|uint64_t
name|byte6
range|:
literal|4
decl_stmt|;
name|uint64_t
name|byte7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|byte8
range|:
literal|4
decl_stmt|;
name|uint64_t
name|status
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_read_level_rankx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_read_level_rankx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_read_level_rankx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_read_level_rankx_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_read_level_rankx
name|cvmx_lmcx_read_level_rankx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_reset_ctl  *  * Specify the RSL base addresses for the block  *  *  * Notes:  * DDR3RST - DDR3 DRAM parts have a new RESET#  *   pin that wasn't present in DDR2 parts. The  *   DDR3RST CSR field controls the assertion of  *   the new 63xx pin that attaches to RESET#.  *   When DDR3RST is set, 63xx asserts RESET#.  *   When DDR3RST is clear, 63xx de-asserts  *   RESET#.  *  *   DDR3RST is set on a cold reset. Warm and  *   soft chip resets do not affect the DDR3RST  *   value. Outside of cold reset, only software  *   CSR writes change the DDR3RST value.  *  * DDR3PWARM - Enables preserve mode during a warm  *   reset. When set, the DDR3 controller hardware  *   automatically puts the attached DDR3 DRAM parts  *   into self refresh (see LMC*CONFIG[SEQUENCE] below) at the beginning of a warm  *   reset sequence, provided that the DDR3 controller  *   is up. When clear, the DDR3 controller hardware  *   does not put the attached DDR3 DRAM parts into  *   self-refresh during a warm reset sequence.  *  *   DDR3PWARM is cleared on a cold reset. Warm and  *   soft chip resets do not affect the DDR3PWARM  *   value. Outside of cold reset, only software  *   CSR writes change the DDR3PWARM value.  *  *   Note that if a warm reset follows a soft reset,  *   DDR3PWARM has no effect, as the DDR3 controller  *   is no longer up after any cold/warm/soft  *   reset sequence.  *  * DDR3PSOFT - Enables preserve mode during a soft  *   reset. When set, the DDR3 controller hardware  *   automatically puts the attached DDR3 DRAM parts  *   into self refresh (see LMC*CONFIG[SEQUENCE] below) at the beginning of a soft  *   reset sequence, provided that the DDR3 controller  *   is up. When clear, the DDR3 controller hardware  *   does not put the attached DDR3 DRAM parts into  *   self-refresh during a soft reset sequence.  *  *   DDR3PSOFT is cleared on a cold reset. Warm and  *   soft chip resets do not affect the DDR3PSOFT  *   value. Outside of cold reset, only software  *   CSR writes change the DDR3PSOFT value.  *  * DDR3PSV - May be useful for system software to  *   determine when the DDR3 contents have been  *   preserved.  *  *   Cleared by hardware during a cold reset. Never  *   cleared by hardware during a warm/soft reset.  *   Set by hardware during a warm/soft reset if  *   the hardware automatically put the DDR3 DRAM  *   into self-refresh during the reset sequence.  *  *   Can also be written by software (to any value).  */
end_comment

begin_union
union|union
name|cvmx_lmcx_reset_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_reset_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|ddr3psv
range|:
literal|1
decl_stmt|;
comment|/**< Memory Reset                                                          1 = DDR contents preserved */
name|uint64_t
name|ddr3psoft
range|:
literal|1
decl_stmt|;
comment|/**< Memory Reset                                                          1 = Enable Preserve mode during soft reset */
name|uint64_t
name|ddr3pwarm
range|:
literal|1
decl_stmt|;
comment|/**< Memory Reset                                                          1 = Enable Preserve mode during warm reset */
name|uint64_t
name|ddr3rst
range|:
literal|1
decl_stmt|;
comment|/**< Memory Reset                                                          0 = Reset asserted                                                          1 = Reset de-asserted */
else|#
directive|else
name|uint64_t
name|ddr3rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr3pwarm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr3psoft
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr3psv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_reset_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_reset_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_reset_ctl
name|cvmx_lmcx_reset_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_rlevel_ctl  */
end_comment

begin_union
union|union
name|cvmx_lmcx_rlevel_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_rlevel_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
name|uint64_t
name|delay_unload_3
range|:
literal|1
decl_stmt|;
comment|/**< When set, unload the PHY silo one cycle later                                                          during read-leveling if LMC*_RLEVEL_RANKi[BYTE*<1:0>] = 3                                                          DELAY_UNLOAD_3 should normally be set, particularly at higher speeds. */
name|uint64_t
name|delay_unload_2
range|:
literal|1
decl_stmt|;
comment|/**< When set, unload the PHY silo one cycle later                                                          during read-leveling if LMC*_RLEVEL_RANKi[BYTE*<1:0>] = 2                                                          DELAY_UNLOAD_2 should normally not be set. */
name|uint64_t
name|delay_unload_1
range|:
literal|1
decl_stmt|;
comment|/**< When set, unload the PHY silo one cycle later                                                          during read-leveling if LMC*_RLEVEL_RANKi[BYTE*<1:0>] = 1                                                          DELAY_UNLOAD_1 should normally not be set. */
name|uint64_t
name|delay_unload_0
range|:
literal|1
decl_stmt|;
comment|/**< When set, unload the PHY silo one cycle later                                                          during read-leveling if LMC*_RLEVEL_RANKi[BYTE*<1:0>] = 0                                                          DELAY_UNLOAD_0 should normally not be set. */
name|uint64_t
name|bitmask
range|:
literal|8
decl_stmt|;
comment|/**< Mask to select bit lanes on which read-leveling                                                          feedback is returned when OR_DIS is set to 1 */
name|uint64_t
name|or_dis
range|:
literal|1
decl_stmt|;
comment|/**< Disable or'ing of bits in a byte lane when computing                                                          the read-leveling bitmask                                                          OR_DIS should normally not be set. */
name|uint64_t
name|offset_en
range|:
literal|1
decl_stmt|;
comment|/**< When set, LMC attempts to select the read-leveling                                                          setting that is LMC*RLEVEL_CTL[OFFSET] settings earlier than the                                                          last passing read-leveling setting in the largest                                                          contiguous sequence of passing settings.                                                          When clear, or if the setting selected by LMC*RLEVEL_CTL[OFFSET]                                                          did not pass, LMC selects the middle setting in the                                                          largest contiguous sequence of passing settings,                                                          rounding earlier when necessary. */
name|uint64_t
name|offset
range|:
literal|4
decl_stmt|;
comment|/**< The offset used when LMC*RLEVEL_CTL[OFFSET] is set */
name|uint64_t
name|byte
range|:
literal|4
decl_stmt|;
comment|/**< 0<= BYTE<= 8                                                          Byte index for which bitmask results are saved                                                          in LMC*_RLEVEL_DBG */
else|#
directive|else
name|uint64_t
name|byte
range|:
literal|4
decl_stmt|;
name|uint64_t
name|offset
range|:
literal|4
decl_stmt|;
name|uint64_t
name|offset_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|or_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bitmask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|delay_unload_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|delay_unload_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|delay_unload_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|delay_unload_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_rlevel_ctl_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_lmcx_rlevel_ctl_cn63xxp1
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|offset_en
range|:
literal|1
decl_stmt|;
comment|/**< When set, LMC attempts to select the read-leveling                                                          setting that is LMC*RLEVEL_CTL[OFFSET] settings earlier than the                                                          last passing read-leveling setting in the largest                                                          contiguous sequence of passing settings.                                                          When clear, or if the setting selected by LMC*RLEVEL_CTL[OFFSET]                                                          did not pass, LMC selects the middle setting in the                                                          largest contiguous sequence of passing settings,                                                          rounding earlier when necessary. */
name|uint64_t
name|offset
range|:
literal|4
decl_stmt|;
comment|/**< The offset used when LMC*RLEVEL_CTL[OFFSET] is set */
name|uint64_t
name|byte
range|:
literal|4
decl_stmt|;
comment|/**< 0<= BYTE<= 8                                                          Byte index for which bitmask results are saved                                                          in LMC*_RLEVEL_DBG */
else|#
directive|else
name|uint64_t
name|byte
range|:
literal|4
decl_stmt|;
name|uint64_t
name|offset
range|:
literal|4
decl_stmt|;
name|uint64_t
name|offset_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_rlevel_ctl
name|cvmx_lmcx_rlevel_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_rlevel_dbg  *  * Notes:  * A given read of LMC*_RLEVEL_DBG returns the read-leveling pass/fail results for all possible  * delay settings (i.e. the BITMASK) for only one byte in the last rank that the HW read-leveled.  * LMC*_RLEVEL_CTL[BYTE] selects the particular byte.  *  * To get these pass/fail results for another different rank, you must run the hardware read-leveling  * again. For example, it is possible to get the BITMASK results for every byte of every rank  * if you run read-leveling separately for each rank, probing LMC*_RLEVEL_DBG between each  * read-leveling.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_rlevel_dbg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_rlevel_dbg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|bitmask
range|:
literal|64
decl_stmt|;
comment|/**< Bitmask generated during deskew settings sweep                                                          BITMASK[n]=0 means deskew setting n failed                                                          BITMASK[n]=1 means deskew setting n passed                                                          for 0<= n<= 63 */
else|#
directive|else
name|uint64_t
name|bitmask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_rlevel_dbg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_rlevel_dbg_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_rlevel_dbg
name|cvmx_lmcx_rlevel_dbg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_rlevel_rank#  *  * Notes:  * This is four CSRs per LMC, one per each rank.  *  * Deskew setting is measured in units of 1/4 CK, so the above BYTE* values can range over 16 CKs.  *  * Each CSR is written by HW during a read-leveling sequence for the rank. (HW sets STATUS==3 after HW read-leveling completes for the rank.)  * If HW is unable to find a match per LMC*_RLEVEL_CTL[OFFSET_ENA] and LMC*_RLEVEL_CTL[OFFSET], then HW will set LMC*_RLEVEL_RANKi[BYTE*<5:0>]  * to  0.  *  * Each CSR may also be written by SW, but not while a read-leveling sequence is in progress. (HW sets STATUS==1 after a CSR write.)  *  * SW initiates a HW read-leveling sequence by programming LMC*_RLEVEL_CTL and writing INIT_START=1 with SEQUENCE=1.  * See LMC*_RLEVEL_CTL.  *  * LMC*_RLEVEL_RANKi values for ranks i without attached DRAM should be set such that  * they do not increase the range of possible BYTE values for any byte  * lane. The easiest way to do this is to set  *     LMC*_RLEVEL_RANKi = LMC*_RLEVEL_RANKj,  * where j is some rank with attached DRAM whose LMC*_RLEVEL_RANKj is already fully initialized.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_rlevel_rankx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_rlevel_rankx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
name|uint64_t
name|status
range|:
literal|2
decl_stmt|;
comment|/**< Indicates status of the read-levelling and where                                                          the BYTE* programmings in<35:0> came from:                                                          0 = BYTE* values are their reset value                                                          1 = BYTE* values were set via a CSR write to this register                                                          2 = read-leveling sequence currently in progress (BYTE* values are unpredictable)                                                          3 = BYTE* values came from a complete read-leveling sequence */
name|uint64_t
name|byte8
range|:
literal|6
decl_stmt|;
comment|/**< Deskew setting                                                          When ECC DRAM is not present (i.e. when DRAM is not                                                          attached to chip signals DDR_CBS_0_* and DDR_CB[7:0]),                                                          SW should write BYTE8 to a value that does                                                          not increase the range of possible BYTE* values. The                                                          easiest way to do this is to set                                                          LMC*_RLEVEL_RANK*[BYTE8] = LMC*_RLEVEL_RANK*[BYTE0]                                                          when there is no ECC DRAM, using the final BYTE0 value. */
name|uint64_t
name|byte7
range|:
literal|6
decl_stmt|;
comment|/**< Deskew setting */
name|uint64_t
name|byte6
range|:
literal|6
decl_stmt|;
comment|/**< Deskew setting */
name|uint64_t
name|byte5
range|:
literal|6
decl_stmt|;
comment|/**< Deskew setting */
name|uint64_t
name|byte4
range|:
literal|6
decl_stmt|;
comment|/**< Deskew setting */
name|uint64_t
name|byte3
range|:
literal|6
decl_stmt|;
comment|/**< Deskew setting */
name|uint64_t
name|byte2
range|:
literal|6
decl_stmt|;
comment|/**< Deskew setting */
name|uint64_t
name|byte1
range|:
literal|6
decl_stmt|;
comment|/**< Deskew setting */
name|uint64_t
name|byte0
range|:
literal|6
decl_stmt|;
comment|/**< Deskew setting */
else|#
directive|else
name|uint64_t
name|byte0
range|:
literal|6
decl_stmt|;
name|uint64_t
name|byte1
range|:
literal|6
decl_stmt|;
name|uint64_t
name|byte2
range|:
literal|6
decl_stmt|;
name|uint64_t
name|byte3
range|:
literal|6
decl_stmt|;
name|uint64_t
name|byte4
range|:
literal|6
decl_stmt|;
name|uint64_t
name|byte5
range|:
literal|6
decl_stmt|;
name|uint64_t
name|byte6
range|:
literal|6
decl_stmt|;
name|uint64_t
name|byte7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|byte8
range|:
literal|6
decl_stmt|;
name|uint64_t
name|status
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_rlevel_rankx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_rlevel_rankx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_rlevel_rankx
name|cvmx_lmcx_rlevel_rankx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_rodt_comp_ctl  *  * LMC_RODT_COMP_CTL = LMC Compensation control  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_rodt_comp_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_rodt_comp_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< 0=not enabled, 1=enable */
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|nctl
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
comment|/**< Compensation control bits */
else|#
directive|else
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|nctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_rodt_comp_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_comp_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_comp_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_comp_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_comp_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_comp_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_comp_ctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_rodt_comp_ctl
name|cvmx_lmcx_rodt_comp_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_rodt_ctl  *  * LMC_RODT_CTL = Obsolete LMC Read OnDieTermination control  * See the description in LMC_WODT_CTL1. On Reads, Octeon only supports turning on ODT's in  * the lower 2 DIMM's with the masks as below.  *  * Notes:  * When a given RANK in position N is selected, the RODT _HI and _LO masks for that position are used.  * Mask[3:0] is used for RODT control of the RANKs in positions 3, 2, 1, and 0, respectively.  * In  64b mode, DIMMs are assumed to be ordered in the following order:  *  position 3: [unused        , DIMM1_RANK1_LO]  *  position 2: [unused        , DIMM1_RANK0_LO]  *  position 1: [unused        , DIMM0_RANK1_LO]  *  position 0: [unused        , DIMM0_RANK0_LO]  * In 128b mode, DIMMs are assumed to be ordered in the following order:  *  position 3: [DIMM3_RANK1_HI, DIMM1_RANK1_LO]  *  position 2: [DIMM3_RANK0_HI, DIMM1_RANK0_LO]  *  position 1: [DIMM2_RANK1_HI, DIMM0_RANK1_LO]  *  position 0: [DIMM2_RANK0_HI, DIMM0_RANK0_LO]  */
end_comment

begin_union
union|union
name|cvmx_lmcx_rodt_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_rodt_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|rodt_hi3
range|:
literal|4
decl_stmt|;
comment|/**< Read ODT mask for position 3, data[127:64] */
name|uint64_t
name|rodt_hi2
range|:
literal|4
decl_stmt|;
comment|/**< Read ODT mask for position 2, data[127:64] */
name|uint64_t
name|rodt_hi1
range|:
literal|4
decl_stmt|;
comment|/**< Read ODT mask for position 1, data[127:64] */
name|uint64_t
name|rodt_hi0
range|:
literal|4
decl_stmt|;
comment|/**< Read ODT mask for position 0, data[127:64] */
name|uint64_t
name|rodt_lo3
range|:
literal|4
decl_stmt|;
comment|/**< Read ODT mask for position 3, data[ 63: 0] */
name|uint64_t
name|rodt_lo2
range|:
literal|4
decl_stmt|;
comment|/**< Read ODT mask for position 2, data[ 63: 0] */
name|uint64_t
name|rodt_lo1
range|:
literal|4
decl_stmt|;
comment|/**< Read ODT mask for position 1, data[ 63: 0] */
name|uint64_t
name|rodt_lo0
range|:
literal|4
decl_stmt|;
comment|/**< Read ODT mask for position 0, data[ 63: 0] */
else|#
directive|else
name|uint64_t
name|rodt_lo0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rodt_lo1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rodt_lo2
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rodt_lo3
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rodt_hi0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rodt_hi1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rodt_hi2
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rodt_hi3
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_rodt_ctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_ctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_ctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_rodt_ctl
name|cvmx_lmcx_rodt_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_rodt_mask  *  * LMC_RODT_MASK = LMC Read OnDieTermination mask  * System designers may desire to terminate DQ/DQS lines for higher frequency DDR operations  * especially on a multi-rank system. DDR3 DQ/DQS I/O's have built in  * Termination resistor that can be turned on or off by the controller, after meeting tAOND and tAOF  * timing requirements. Each Rank has its own ODT pin that fans out to all the memory parts  * in that DIMM. System designers may prefer different combinations of ODT ON's for reads  * into different ranks. Octeon supports full programmability by way of the mask register below.  * Each Rank position has its own 8-bit programmable field.  * When the controller does a read to that rank, it sets the 4 ODT pins to the MASK pins below.  * For eg., When doing a read from Rank0, a system designer may desire to terminate the lines  * with the resistor on DIMM0/Rank1. The mask RODT_D0_R0 would then be [00000010].  * Octeon drives the appropriate mask values on the ODT pins by default. If this feature is not  * required, write 0 in this register. Note that, as per the DDR3 specifications, the ODT pin  * for the rank that is being read should always be 0.  *  * Notes:  * When a given RANK is selected, the RODT mask for that RANK is used.  The resulting RODT mask is  * driven to the DIMMs in the following manner:  *             RANK_ENA=1                    RANK_ENA=0  * Mask[3] -> DIMM1_ODT_1                    MBZ  * Mask[2] -> DIMM1_ODT_0                    DIMM1_ODT_0  * Mask[1] -> DIMM0_ODT_1                    MBZ  * Mask[0] -> DIMM0_ODT_0                    DIMM0_ODT_0  *  * LMC always reads entire cache blocks and always reads them via two consecutive  * read CAS operations to the same rank+bank+row spaced exactly 4 CK's apart.  * When a RODT mask bit is set, LMC asserts the OCTEON ODT output  * pin(s) starting (CL - CWL) CK's after the first read CAS operation. Then, OCTEON  * normally continues to assert the ODT output pin(s) for 9+LMC*_CONTROL[RODT_BPRCH] more CK's  * - for a total of 10+LMC*_CONTROL[RODT_BPRCH] CK's for the entire cache block read -  * through the second read CAS operation of the cache block,  * satisfying the 6 CK DDR3 ODTH8 requirements.  * But it is possible for OCTEON to issue two cache block reads separated by as few as  * RtR = 8 or 9 (10 if LMC*_CONTROL[RODT_BPRCH]=1) CK's. In that case, OCTEON asserts the ODT output pin(s)  * for the RODT mask of the first cache block read for RtR CK's, then asserts  * the ODT output pin(s) for the RODT mask of the second cache block read for 10+LMC*_CONTROL[RODT_BPRCH] CK's  * (or less if a third cache block read follows within 8 or 9 (or 10) CK's of this second cache block read).  * Note that it may be necessary to force LMC to space back-to-back cache block reads  * to different ranks apart by at least 10+LMC*_CONTROL[RODT_BPRCH] CK's to prevent DDR3 ODTH8 violations.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_rodt_mask
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_rodt_mask_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|rodt_d3_r1
range|:
literal|8
decl_stmt|;
comment|/**< Read ODT mask DIMM3, RANK1/DIMM3 in SingleRanked                                                          *UNUSED IN 63xx, and MBZ* */
name|uint64_t
name|rodt_d3_r0
range|:
literal|8
decl_stmt|;
comment|/**< Read ODT mask DIMM3, RANK0                                                          *UNUSED IN 63xx, and MBZ* */
name|uint64_t
name|rodt_d2_r1
range|:
literal|8
decl_stmt|;
comment|/**< Read ODT mask DIMM2, RANK1/DIMM2 in SingleRanked                                                          *UNUSED IN 63xx, and MBZ* */
name|uint64_t
name|rodt_d2_r0
range|:
literal|8
decl_stmt|;
comment|/**< Read ODT mask DIMM2, RANK0                                                          *UNUSED IN 63xx, and MBZ* */
name|uint64_t
name|rodt_d1_r1
range|:
literal|8
decl_stmt|;
comment|/**< Read ODT mask DIMM1, RANK1/DIMM1 in SingleRanked                                                          if (RANK_ENA) then                                                              RODT_D1_R1[3] must be 0                                                          else                                                              RODT_D1_R1[3:0] is not used and MBZ                                                          *Upper 4 bits UNUSED IN 63xx, and MBZ* */
name|uint64_t
name|rodt_d1_r0
range|:
literal|8
decl_stmt|;
comment|/**< Read ODT mask DIMM1, RANK0                                                          if (RANK_ENA) then                                                              RODT_D1_RO[2] must be 0                                                          else                                                              RODT_D1_RO[3:2,1] must be 0                                                          *Upper 4 bits UNUSED IN 63xx, and MBZ* */
name|uint64_t
name|rodt_d0_r1
range|:
literal|8
decl_stmt|;
comment|/**< Read ODT mask DIMM0, RANK1/DIMM0 in SingleRanked                                                          if (RANK_ENA) then                                                              RODT_D0_R1[1] must be 0                                                          else                                                              RODT_D0_R1[3:0] is not used and MBZ                                                          *Upper 4 bits UNUSED IN 63xx, and MBZ* */
name|uint64_t
name|rodt_d0_r0
range|:
literal|8
decl_stmt|;
comment|/**< Read ODT mask DIMM0, RANK0                                                          if (RANK_ENA) then                                                              RODT_D0_RO[0] must be 0                                                          else                                                              RODT_D0_RO[1:0,3] must be 0                                                          *Upper 4 bits UNUSED IN 63xx, and MBZ* */
else|#
directive|else
name|uint64_t
name|rodt_d0_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rodt_d0_r1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rodt_d1_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rodt_d1_r1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rodt_d2_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rodt_d2_r1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rodt_d3_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rodt_d3_r1
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_rodt_mask_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_rodt_mask_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_rodt_mask
name|cvmx_lmcx_rodt_mask_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_slot_ctl0  *  * LMC_SLOT_CTL0 = LMC Slot Control0  * This register is an assortment of various control fields needed by the memory controller  *  * Notes:  * If SW has not previously written to this register (since the last DRESET),  * HW updates the fields in this register to the minimum allowed value  * when any of LMC*_RLEVEL_RANKn, LMC*_WLEVEL_RANKn, LMC*_CONTROL and  * LMC*_MODEREG_PARAMS0 CSR's change. Ideally, only read this register  * after LMC has been initialized and LMC*_RLEVEL_RANKn, LMC*_WLEVEL_RANKn  * have valid data.  *  * The interpretation of the fields in this CSR depends on LMC*_CONFIG[DDR2T]:  *  - If LMC*_CONFIG[DDR2T]=1, (FieldValue + 4) is the minimum CK cycles  *    between when the DRAM part registers CAS commands of the 1st and 2nd types  *    from different cache blocks.  *  - If LMC*_CONFIG[DDR2T]=0, (FieldValue + 3) is the minimum CK cycles  *    between when the DRAM part registers CAS commands of the 1st and 2nd types  *    from different cache blocks. FieldValue = 0 is always illegal in this  *    case.  *  * The hardware-calculated minimums are:  *  * min R2R_INIT = 1 - LMC*_CONFIG[DDR2T]  * min R2W_INIT = 5 - LMC*_CONFIG[DDR2T] + (RL + MaxRdSkew) - (WL + MinWrSkew) + LMC*_CONTROL[BPRCH]  * min W2R_INIT = 2 - LMC*_CONFIG[DDR2T] + LMC*_TIMING_PARAMS1[TWTR] + WL  * min W2W_INIT = 1 - LMC*_CONFIG[DDR2T]  *  * where  *  * RL        = CL  + AL (LMC*_MODEREG_PARAMS0[CL] selects CL, LMC*_MODEREG_PARAMS0[AL] selects AL)  * WL        = CWL + AL (LMC*_MODEREG_PARAMS0[CWL] selects CWL)  * MaxRdSkew = max(LMC*_RLEVEL_RANKi[BYTEj]/4) + 1                          (max is across all ranks i (0..3) and bytes j (0..8))  * MinWrSkew = min(LMC*_WLEVEL_RANKi[BYTEj]/8) - LMC*_CONFIG[EARLY_DQX]     (min is across all ranks i (0..3) and bytes j (0..8))  *  * R2W_INIT has 1 CK cycle built in for OCTEON-internal ODT settling/channel turnaround time.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_slot_ctl0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_slot_ctl0_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|w2w_init
range|:
literal|6
decl_stmt|;
comment|/**< Write-to-write spacing control                                                          for back to back accesses to the same rank and DIMM */
name|uint64_t
name|w2r_init
range|:
literal|6
decl_stmt|;
comment|/**< Write-to-read spacing control                                                          for back to back accesses to the same rank and DIMM */
name|uint64_t
name|r2w_init
range|:
literal|6
decl_stmt|;
comment|/**< Read-to-write spacing control                                                          for back to back accesses to the same rank and DIMM */
name|uint64_t
name|r2r_init
range|:
literal|6
decl_stmt|;
comment|/**< Read-to-read spacing control                                                          for back to back accesses to the same rank and DIMM */
else|#
directive|else
name|uint64_t
name|r2r_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|r2w_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|w2r_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|w2w_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_slot_ctl0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_slot_ctl0_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_slot_ctl0
name|cvmx_lmcx_slot_ctl0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_slot_ctl1  *  * LMC_SLOT_CTL1 = LMC Slot Control1  * This register is an assortment of various control fields needed by the memory controller  *  * Notes:  * If SW has not previously written to this register (since the last DRESET),  * HW updates the fields in this register to the minimum allowed value  * when any of LMC*_RLEVEL_RANKn, LMC*_WLEVEL_RANKn, LMC*_CONTROL and  * LMC*_MODEREG_PARAMS0 CSR's change. Ideally, only read this register  * after LMC has been initialized and LMC*_RLEVEL_RANKn, LMC*_WLEVEL_RANKn  * have valid data.  *  * The interpretation of the fields in this CSR depends on LMC*_CONFIG[DDR2T]:  *  - If LMC*_CONFIG[DDR2T]=1, (FieldValue + 4) is the minimum CK cycles  *    between when the DRAM part registers CAS commands of the 1st and 2nd types  *    from different cache blocks.  *  - If LMC*_CONFIG[DDR2T]=0, (FieldValue + 3) is the minimum CK cycles  *    between when the DRAM part registers CAS commands of the 1st and 2nd types  *    from different cache blocks. FieldValue = 0 is always illegal in this  *    case.  *  * The hardware-calculated minimums are:  *  * min R2R_XRANK_INIT = 2 - LMC*_CONFIG[DDR2T] + MaxRdSkew - MinRdSkew  * min R2W_XRANK_INIT = 5 - LMC*_CONFIG[DDR2T] + (RL + MaxRdSkew) - (WL + MinWrSkew) + LMC*_CONTROL[BPRCH]  * min W2R_XRANK_INIT = 3 - LMC*_CONFIG[DDR2T] + MaxWrSkew + LMC*_CONTROL[FPRCH2]  * min W2W_XRANK_INIT = 4 - LMC*_CONFIG[DDR2T] + MaxWrSkew - MinWrSkew  *  * where  *  * RL        = CL  + AL (LMC*_MODEREG_PARAMS0[CL] selects CL, LMC*_MODEREG_PARAMS0[AL] selects AL)  * WL        = CWL + AL (LMC*_MODEREG_PARAMS0[CWL] selects CWL)  * MinRdSkew = min(LMC*_RLEVEL_RANKi[BYTEj]/4)                              (min is across all ranks i (0..3) and bytes j (0..8))  * MaxRdSkew = max(LMC*_RLEVEL_RANKi[BYTEj]/4) + 1                          (max is across all ranks i (0..3) and bytes j (0..8))  * MinWrSkew = min(LMC*_WLEVEL_RANKi[BYTEj]/8) - LMC*_CONFIG[EARLY_DQX]     (min is across all ranks i (0..3) and bytes j (0..8))  * MaxWrSkew = max(LMC*_WLEVEL_RANKi[BYTEj]/8) - LMC*_CONFIG[EARLY_DQX] + 1 (max is across all ranks i (0..3) and bytes j (0..8))  *  * R2W_XRANK_INIT has 1 extra CK cycle built in for OCTEON-internal ODT settling/channel turnaround time.  *  * W2R_XRANK_INIT has 1 extra CK cycle built in for channel turnaround time.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_slot_ctl1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_slot_ctl1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|w2w_xrank_init
range|:
literal|6
decl_stmt|;
comment|/**< Write-to-write spacing control                                                          for back to back accesses across ranks of the same DIMM */
name|uint64_t
name|w2r_xrank_init
range|:
literal|6
decl_stmt|;
comment|/**< Write-to-read spacing control                                                          for back to back accesses across ranks of the same DIMM */
name|uint64_t
name|r2w_xrank_init
range|:
literal|6
decl_stmt|;
comment|/**< Read-to-write spacing control                                                          for back to back accesses across ranks of the same DIMM */
name|uint64_t
name|r2r_xrank_init
range|:
literal|6
decl_stmt|;
comment|/**< Read-to-read spacing control                                                          for back to back accesses across ranks of the same DIMM */
else|#
directive|else
name|uint64_t
name|r2r_xrank_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|r2w_xrank_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|w2r_xrank_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|w2w_xrank_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_slot_ctl1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_slot_ctl1_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_slot_ctl1
name|cvmx_lmcx_slot_ctl1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_slot_ctl2  *  * LMC_SLOT_CTL2 = LMC Slot Control2  * This register is an assortment of various control fields needed by the memory controller  *  * Notes:  * If SW has not previously written to this register (since the last DRESET),  * HW updates the fields in this register to the minimum allowed value  * when any of LMC*_RLEVEL_RANKn, LMC*_WLEVEL_RANKn, LMC*_CONTROL and  * LMC*_MODEREG_PARAMS0 CSR's change. Ideally, only read this register  * after LMC has been initialized and LMC*_RLEVEL_RANKn, LMC*_WLEVEL_RANKn  * have valid data.  *  * The interpretation of the fields in this CSR depends on LMC*_CONFIG[DDR2T]:  *  - If LMC*_CONFIG[DDR2T]=1, (FieldValue + 4) is the minimum CK cycles  *    between when the DRAM part registers CAS commands of the 1st and 2nd types  *    from different cache blocks.  *  - If LMC*_CONFIG[DDR2T]=0, (FieldValue + 3) is the minimum CK cycles  *    between when the DRAM part registers CAS commands of the 1st and 2nd types  *    from different cache blocks. FieldValue = 0 is always illegal in this  *    case.  *  * The hardware-calculated minimums are:  *  * min R2R_XDIMM_INIT = 3 - LMC*_CONFIG[DDR2T] + MaxRdSkew - MinRdSkew  * min R2W_XDIMM_INIT = 6 - LMC*_CONFIG[DDR2T] + (RL + MaxRdSkew) - (WL + MinWrSkew) + LMC*_CONTROL[BPRCH]  * min W2R_XDIMM_INIT = 3 - LMC*_CONFIG[DDR2T] + MaxWrSkew + LMC*_CONTROL[FPRCH2]  * min W2W_XDIMM_INIT = 5 - LMC*_CONFIG[DDR2T] + MaxWrSkew - MinWrSkew  *  * where  *  * RL        = CL  + AL (LMC*_MODEREG_PARAMS0[CL] selects CL, LMC*_MODEREG_PARAMS0[AL] selects AL)  * WL        = CWL + AL (LMC*_MODEREG_PARAMS0[CWL] selects CWL)  * MinRdSkew = min(LMC*_RLEVEL_RANKi[BYTEj]/4)                              (min is across all ranks i (0..3) and bytes j (0..8))  * MaxRdSkew = max(LMC*_RLEVEL_RANKi[BYTEj]/4) + 1                          (max is across all ranks i (0..3) and bytes j (0..8))  * MinWrSkew = min(LMC*_WLEVEL_RANKi[BYTEj]/8) - LMC*_CONFIG[EARLY_DQX]     (min is across all ranks i (0..3) and bytes j (0..8))  * MaxWrSkew = max(LMC*_WLEVEL_RANKi[BYTEj]/8) - LMC*_CONFIG[EARLY_DQX] + 1 (max is across all ranks i (0..3) and bytes j (0..8))  *  * R2W_XDIMM_INIT has 2 extra CK cycles built in for OCTEON-internal ODT settling/channel turnaround time.  *  * R2R_XDIMM_INIT, W2R_XRANK_INIT, W2W_XDIMM_INIT have 1 extra CK cycle built in for channel turnaround time.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_slot_ctl2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_slot_ctl2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|w2w_xdimm_init
range|:
literal|6
decl_stmt|;
comment|/**< Write-to-write spacing control                                                          for back to back accesses across DIMMs */
name|uint64_t
name|w2r_xdimm_init
range|:
literal|6
decl_stmt|;
comment|/**< Write-to-read spacing control                                                          for back to back accesses across DIMMs */
name|uint64_t
name|r2w_xdimm_init
range|:
literal|6
decl_stmt|;
comment|/**< Read-to-write spacing control                                                          for back to back accesses across DIMMs */
name|uint64_t
name|r2r_xdimm_init
range|:
literal|6
decl_stmt|;
comment|/**< Read-to-read spacing control                                                          for back to back accesses across DIMMs */
else|#
directive|else
name|uint64_t
name|r2r_xdimm_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|r2w_xdimm_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|w2r_xdimm_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|w2w_xdimm_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_slot_ctl2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_slot_ctl2_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_slot_ctl2
name|cvmx_lmcx_slot_ctl2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_timing_params0  */
end_comment

begin_union
union|union
name|cvmx_lmcx_timing_params0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_timing_params0_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|trp_ext
range|:
literal|1
decl_stmt|;
comment|/**< Indicates tRP constraints.                                                          Set [TRP_EXT[0:0], TRP[3:0]] (CSR field) = RNDUP[tRP(ns)/tCYC(ns)]                                                          + (RNDUP[tRTP(ns)/tCYC(ns)]-4)-1,                                                          where tRP, tRTP are from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP tRP=10-15ns                                                          TYP tRTP=max(4nCK, 7.5ns) */
name|uint64_t
name|tcksre
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tCKSRE constraints.                                                          Set TCKSRE (CSR field) = RNDUP[tCKSRE(ns)/tCYC(ns)]-1,                                                          where tCKSRE is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(5nCK, 10ns) */
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tRP constraints.                                                          Set TRP (CSR field) = RNDUP[tRP(ns)/tCYC(ns)]                                                          + (RNDUP[tRTP(ns)/tCYC(ns)])-4)-1,                                                          where tRP, tRTP are from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP tRP=10-15ns                                                          TYP tRTP=max(4nCK, 7.5ns) */
name|uint64_t
name|tzqinit
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tZQINIT constraints.                                                          Set TZQINIT (CSR field) = RNDUP[tZQINIT(ns)/(256*tCYC(ns))],                                                          where tZQINIT is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=2 (equivalent to 512) */
name|uint64_t
name|tdllk
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tDLLK constraints.                                                          Set TDLLK (CSR field) = RNDUP[tDLLK(ns)/(256*tCYC(ns))],                                                          where tDLLK is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=2 (equivalent to 512)                                                          This parameter is used in self-refresh exit                                                          and assumed to be greater than tRFC */
name|uint64_t
name|tmod
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tMOD constraints.                                                          Set TMOD (CSR field) = RNDUP[tMOD(ns)/tCYC(ns)]-1,                                                          where tMOD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(12nCK, 15ns) */
name|uint64_t
name|tmrd
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tMRD constraints.                                                          Set TMRD (CSR field) = RNDUP[tMRD(ns)/tCYC(ns)]-1,                                                          where tMRD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=4nCK */
name|uint64_t
name|txpr
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tXPR constraints.                                                          Set TXPR (CSR field) = RNDUP[tXPR(ns)/(16*tCYC(ns))],                                                          where tXPR is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(5nCK, tRFC+10ns) */
name|uint64_t
name|tcke
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tCKE constraints.                                                          Set TCKE (CSR field) = RNDUP[tCKE(ns)/tCYC(ns)]-1,                                                          where tCKE is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(3nCK, 7.5/5.625/5.625/5ns) */
name|uint64_t
name|tzqcs
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tZQCS constraints.                                                          Set TZQCS (CSR field) = RNDUP[tZQCS(ns)/(16*tCYC(ns))],                                                          where tZQCS is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=4 (equivalent to 64) */
name|uint64_t
name|tckeon
range|:
literal|10
decl_stmt|;
comment|/**< Reserved. Should be written to zero. */
else|#
directive|else
name|uint64_t
name|tckeon
range|:
literal|10
decl_stmt|;
name|uint64_t
name|tzqcs
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tcke
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txpr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tmrd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tmod
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tdllk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tzqinit
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tcksre
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trp_ext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_lmcx_timing_params0_cn63xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|trp_ext
range|:
literal|1
decl_stmt|;
comment|/**< Indicates tRP constraints.                                                          Set [TRP_EXT[0:0], TRP[3:0]] (CSR field) = RNDUP[tRP(ns)/tCYC(ns)]                                                          + (RNDUP[tRTP(ns)/tCYC(ns)]-4)-1,                                                          where tRP, tRTP are from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP tRP=10-15ns                                                          TYP tRTP=max(4nCK, 7.5ns) */
name|uint64_t
name|tcksre
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tCKSRE constraints.                                                          Set TCKSRE (CSR field) = RNDUP[tCKSRE(ns)/tCYC(ns)]-1,                                                          where tCKSRE is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(5nCK, 10ns) */
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tRP constraints.                                                          Set [TRP_EXT[0:0], TRP[3:0]] (CSR field) = RNDUP[tRP(ns)/tCYC(ns)]                                                          + (RNDUP[tRTP(ns)/tCYC(ns)])-4)-1,                                                          where tRP, tRTP are from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP tRP=10-15ns                                                          TYP tRTP=max(4nCK, 7.5ns) */
name|uint64_t
name|tzqinit
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tZQINIT constraints.                                                          Set TZQINIT (CSR field) = RNDUP[tZQINIT(ns)/(256*tCYC(ns))],                                                          where tZQINIT is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=2 (equivalent to 512) */
name|uint64_t
name|tdllk
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tDLLK constraints.                                                          Set TDLLK (CSR field) = RNDUP[tDLLK(ns)/(256*tCYC(ns))],                                                          where tDLLK is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=2 (equivalent to 512)                                                          This parameter is used in self-refresh exit                                                          and assumed to be greater than tRFC */
name|uint64_t
name|tmod
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tMOD constraints.                                                          Set TMOD (CSR field) = RNDUP[tMOD(ns)/tCYC(ns)]-1,                                                          where tMOD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(12nCK, 15ns) */
name|uint64_t
name|tmrd
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tMRD constraints.                                                          Set TMRD (CSR field) = RNDUP[tMRD(ns)/tCYC(ns)]-1,                                                          where tMRD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=4nCK */
name|uint64_t
name|txpr
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tXPR constraints.                                                          Set TXPR (CSR field) = RNDUP[tXPR(ns)/(16*tCYC(ns))],                                                          where tXPR is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(5nCK, tRFC+10ns) */
name|uint64_t
name|tcke
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tCKE constraints.                                                          Set TCKE (CSR field) = RNDUP[tCKE(ns)/tCYC(ns)]-1,                                                          where tCKE is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(3nCK, 7.5/5.625/5.625/5ns) */
name|uint64_t
name|tzqcs
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tZQCS constraints.                                                          Set TZQCS (CSR field) = RNDUP[tZQCS(ns)/(16*tCYC(ns))],                                                          where tZQCS is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=4 (equivalent to 64) */
name|uint64_t
name|reserved_0_9
range|:
literal|10
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_9
range|:
literal|10
decl_stmt|;
name|uint64_t
name|tzqcs
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tcke
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txpr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tmrd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tmod
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tdllk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tzqinit
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tcksre
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trp_ext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
struct|struct
name|cvmx_lmcx_timing_params0_cn63xxp1
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
name|uint64_t
name|tcksre
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tCKSRE constraints.                                                          Set TCKSRE (CSR field) = RNDUP[tCKSRE(ns)/tCYC(ns)]-1,                                                          where tCKSRE is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(5nCK, 10ns) */
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tRP constraints.                                                          Set TRP (CSR field) = RNDUP[tRP(ns)/tCYC(ns)]                                                          + (RNDUP[tRTP(ns)/tCYC(ns)])-4)-1,                                                          where tRP, tRTP are from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP tRP=10-15ns                                                          TYP tRTP=max(4nCK, 7.5ns) */
name|uint64_t
name|tzqinit
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tZQINIT constraints.                                                          Set TZQINIT (CSR field) = RNDUP[tZQINIT(ns)/(256*tCYC(ns))],                                                          where tZQINIT is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=2 (equivalent to 512) */
name|uint64_t
name|tdllk
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tDLLK constraints.                                                          Set TDLLK (CSR field) = RNDUP[tDLLK(ns)/(256*tCYC(ns))],                                                          where tDLLK is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=2 (equivalent to 512)                                                          This parameter is used in self-refresh exit                                                          and assumed to be greater than tRFC */
name|uint64_t
name|tmod
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tMOD constraints.                                                          Set TMOD (CSR field) = RNDUP[tMOD(ns)/tCYC(ns)]-1,                                                          where tMOD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(12nCK, 15ns) */
name|uint64_t
name|tmrd
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tMRD constraints.                                                          Set TMRD (CSR field) = RNDUP[tMRD(ns)/tCYC(ns)]-1,                                                          where tMRD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=4nCK */
name|uint64_t
name|txpr
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tXPR constraints.                                                          Set TXPR (CSR field) = RNDUP[tXPR(ns)/(16*tCYC(ns))],                                                          where tXPR is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(5nCK, tRFC+10ns) */
name|uint64_t
name|tcke
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tCKE constraints.                                                          Set TCKE (CSR field) = RNDUP[tCKE(ns)/tCYC(ns)]-1,                                                          where tCKE is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(3nCK, 7.5/5.625/5.625/5ns) */
name|uint64_t
name|tzqcs
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tZQCS constraints.                                                          Set TZQCS (CSR field) = RNDUP[tZQCS(ns)/(16*tCYC(ns))],                                                          where tZQCS is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=4 (equivalent to 64) */
name|uint64_t
name|tckeon
range|:
literal|10
decl_stmt|;
comment|/**< Reserved. Should be written to zero. */
else|#
directive|else
name|uint64_t
name|tckeon
range|:
literal|10
decl_stmt|;
name|uint64_t
name|tzqcs
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tcke
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txpr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tmrd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tmod
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tdllk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tzqinit
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tcksre
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_timing_params0
name|cvmx_lmcx_timing_params0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_timing_params1  */
end_comment

begin_union
union|union
name|cvmx_lmcx_timing_params1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_timing_params1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|tras_ext
range|:
literal|1
decl_stmt|;
comment|/**< Indicates tRAS constraints.                                                          Set [TRAS_EXT[0:0], TRAS[4:0]] (CSR field) = RNDUP[tRAS(ns)/tCYC(ns)]-1,                                                          where tRAS is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=35ns-9*tREFI                                                              - 000000: RESERVED                                                              - 000001: 2 tCYC                                                              - 000010: 3 tCYC                                                              - ...                                                              - 111111: 64 tCYC */
name|uint64_t
name|txpdll
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tXPDLL constraints.                                                          Set TXPDLL (CSR field) = RNDUP[tXPDLL(ns)/tCYC(ns)]-1,                                                          where tXPDLL is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(10nCK, 24ns) */
name|uint64_t
name|tfaw
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tFAW constraints.                                                          Set TFAW (CSR field) = RNDUP[tFAW(ns)/(4*tCYC(ns))],                                                          where tFAW is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=30-40ns */
name|uint64_t
name|twldqsen
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tWLDQSEN constraints.                                                          Set TWLDQSEN (CSR field) = RNDUP[tWLDQSEN(ns)/(4*tCYC(ns))],                                                          where tWLDQSEN is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(25nCK) */
name|uint64_t
name|twlmrd
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tWLMRD constraints.                                                          Set TWLMRD (CSR field) = RNDUP[tWLMRD(ns)/(4*tCYC(ns))],                                                          where tWLMRD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(40nCK) */
name|uint64_t
name|txp
range|:
literal|3
decl_stmt|;
comment|/**< Indicates tXP constraints.                                                          Set TXP (CSR field) = RNDUP[tXP(ns)/tCYC(ns)]-1,                                                          where tXP is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(3nCK, 7.5ns) */
name|uint64_t
name|trrd
range|:
literal|3
decl_stmt|;
comment|/**< Indicates tRRD constraints.                                                          Set TRRD (CSR field) = RNDUP[tRRD(ns)/tCYC(ns)]-2,                                                          where tRRD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(4nCK, 10ns)                                                             - 000: RESERVED                                                             - 001: 3 tCYC                                                             - ...                                                             - 110: 8 tCYC                                                             - 111: 9 tCYC */
name|uint64_t
name|trfc
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tRFC constraints.                                                          Set TRFC (CSR field) = RNDUP[tRFC(ns)/(8*tCYC(ns))],                                                          where tRFC is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=90-350ns                                                               - 00000: RESERVED                                                               - 00001: 8 tCYC                                                               - 00010: 16 tCYC                                                               - 00011: 24 tCYC                                                               - 00100: 32 tCYC                                                               - ...                                                               - 11110: 240 tCYC                                                               - 11111: 248 tCYC */
name|uint64_t
name|twtr
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tWTR constraints.                                                          Set TWTR (CSR field) = RNDUP[tWTR(ns)/tCYC(ns)]-1,                                                          where tWTR is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(4nCK, 7.5ns)                                                              - 0000: RESERVED                                                              - 0001: 2                                                              - ...                                                              - 0111: 8                                                              - 1000-1111: RESERVED */
name|uint64_t
name|trcd
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tRCD constraints.                                                          Set TRCD (CSR field) = RNDUP[tRCD(ns)/tCYC(ns)],                                                          where tRCD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=10-15ns                                                              - 0000: RESERVED                                                              - 0001: 2 (2 is the smallest value allowed)                                                              - 0002: 2                                                              - ...                                                              - 1001: 9                                                              - 1010-1111: RESERVED                                                          In 2T mode, make this register TRCD-1, not going                                                          below 2. */
name|uint64_t
name|tras
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tRAS constraints.                                                          Set TRAS (CSR field) = RNDUP[tRAS(ns)/tCYC(ns)]-1,                                                          where tRAS is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=35ns-9*tREFI                                                              - 00000: RESERVED                                                              - 00001: 2 tCYC                                                              - 00010: 3 tCYC                                                              - ...                                                              - 11111: 32 tCYC */
name|uint64_t
name|tmprr
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tMPRR constraints.                                                          Set TMPRR (CSR field) = RNDUP[tMPRR(ns)/tCYC(ns)]-1,                                                          where tMPRR is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=1nCK */
else|#
directive|else
name|uint64_t
name|tmprr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tras
range|:
literal|5
decl_stmt|;
name|uint64_t
name|trcd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|twtr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trfc
range|:
literal|5
decl_stmt|;
name|uint64_t
name|trrd
range|:
literal|3
decl_stmt|;
name|uint64_t
name|txp
range|:
literal|3
decl_stmt|;
name|uint64_t
name|twlmrd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|twldqsen
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tfaw
range|:
literal|5
decl_stmt|;
name|uint64_t
name|txpdll
range|:
literal|5
decl_stmt|;
name|uint64_t
name|tras_ext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_timing_params1_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_lmcx_timing_params1_cn63xxp1
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
name|uint64_t
name|txpdll
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tXPDLL constraints.                                                          Set TXPDLL (CSR field) = RNDUP[tXPDLL(ns)/tCYC(ns)]-1,                                                          where tXPDLL is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(10nCK, 24ns) */
name|uint64_t
name|tfaw
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tFAW constraints.                                                          Set TFAW (CSR field) = RNDUP[tFAW(ns)/(4*tCYC(ns))],                                                          where tFAW is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=30-40ns */
name|uint64_t
name|twldqsen
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tWLDQSEN constraints.                                                          Set TWLDQSEN (CSR field) = RNDUP[tWLDQSEN(ns)/(4*tCYC(ns))],                                                          where tWLDQSEN is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(25nCK) */
name|uint64_t
name|twlmrd
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tWLMRD constraints.                                                          Set TWLMRD (CSR field) = RNDUP[tWLMRD(ns)/(4*tCYC(ns))],                                                          where tWLMRD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(40nCK) */
name|uint64_t
name|txp
range|:
literal|3
decl_stmt|;
comment|/**< Indicates tXP constraints.                                                          Set TXP (CSR field) = RNDUP[tXP(ns)/tCYC(ns)]-1,                                                          where tXP is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(3nCK, 7.5ns) */
name|uint64_t
name|trrd
range|:
literal|3
decl_stmt|;
comment|/**< Indicates tRRD constraints.                                                          Set TRRD (CSR field) = RNDUP[tRRD(ns)/tCYC(ns)]-2,                                                          where tRRD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(4nCK, 10ns)                                                             - 000: RESERVED                                                             - 001: 3 tCYC                                                             - ...                                                             - 110: 8 tCYC                                                             - 111: 9 tCYC */
name|uint64_t
name|trfc
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tRFC constraints.                                                          Set TRFC (CSR field) = RNDUP[tRFC(ns)/(8*tCYC(ns))],                                                          where tRFC is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=90-350ns                                                               - 00000: RESERVED                                                               - 00001: 8 tCYC                                                               - 00010: 16 tCYC                                                               - 00011: 24 tCYC                                                               - 00100: 32 tCYC                                                               - ...                                                               - 11110: 240 tCYC                                                               - 11111: 248 tCYC */
name|uint64_t
name|twtr
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tWTR constraints.                                                          Set TWTR (CSR field) = RNDUP[tWTR(ns)/tCYC(ns)]-1,                                                          where tWTR is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(4nCK, 7.5ns)                                                              - 0000: RESERVED                                                              - 0001: 2                                                              - ...                                                              - 0111: 8                                                              - 1000-1111: RESERVED */
name|uint64_t
name|trcd
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tRCD constraints.                                                          Set TRCD (CSR field) = RNDUP[tRCD(ns)/tCYC(ns)],                                                          where tRCD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=10-15ns                                                              - 0000: RESERVED                                                              - 0001: 2 (2 is the smallest value allowed)                                                              - 0002: 2                                                              - ...                                                              - 1001: 9                                                              - 1010-1111: RESERVED                                                          In 2T mode, make this register TRCD-1, not going                                                          below 2. */
name|uint64_t
name|tras
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tRAS constraints.                                                          Set TRAS (CSR field) = RNDUP[tRAS(ns)/tCYC(ns)]-1,                                                          where tRAS is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=35ns-9*tREFI                                                              - 00000: RESERVED                                                              - 00001: 2 tCYC                                                              - 00010: 3 tCYC                                                              - ...                                                              - 11111: 32 tCYC */
name|uint64_t
name|tmprr
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tMPRR constraints.                                                          Set TMPRR (CSR field) = RNDUP[tMPRR(ns)/tCYC(ns)]-1,                                                          where tMPRR is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=1nCK */
else|#
directive|else
name|uint64_t
name|tmprr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tras
range|:
literal|5
decl_stmt|;
name|uint64_t
name|trcd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|twtr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trfc
range|:
literal|5
decl_stmt|;
name|uint64_t
name|trrd
range|:
literal|3
decl_stmt|;
name|uint64_t
name|txp
range|:
literal|3
decl_stmt|;
name|uint64_t
name|twlmrd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|twldqsen
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tfaw
range|:
literal|5
decl_stmt|;
name|uint64_t
name|txpdll
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_timing_params1
name|cvmx_lmcx_timing_params1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_tro_ctl  *  * LMC_TRO_CTL = LMC Temperature Ring Osc Control  * This register is an assortment of various control fields needed to control the temperature ring oscillator  *  * Notes:  * To bring up the temperature ring oscillator, write TRESET to 0, and follow by initializing RCLK_CNT to desired  * value  */
end_comment

begin_union
union|union
name|cvmx_lmcx_tro_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_tro_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
name|uint64_t
name|rclk_cnt
range|:
literal|32
decl_stmt|;
comment|/**< rclk counter */
name|uint64_t
name|treset
range|:
literal|1
decl_stmt|;
comment|/**< Reset ring oscillator */
else|#
directive|else
name|uint64_t
name|treset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rclk_cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_tro_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_tro_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_tro_ctl
name|cvmx_lmcx_tro_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_tro_stat  *  * LMC_TRO_STAT = LMC Temperature Ring Osc Status  * This register is an assortment of various control fields needed to control the temperature ring oscillator  */
end_comment

begin_union
union|union
name|cvmx_lmcx_tro_stat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_tro_stat_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ring_cnt
range|:
literal|32
decl_stmt|;
comment|/**< ring counter */
else|#
directive|else
name|uint64_t
name|ring_cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_tro_stat_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_tro_stat_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_tro_stat
name|cvmx_lmcx_tro_stat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_wlevel_ctl  */
end_comment

begin_union
union|union
name|cvmx_lmcx_wlevel_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_wlevel_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
name|uint64_t
name|rtt_nom
range|:
literal|3
decl_stmt|;
comment|/**< RTT_NOM                                                          LMC writes a decoded value to MR1[Rtt_Nom] of the rank during                                                          write leveling. Per JEDEC DDR3 specifications,                                                          only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6)                                                          are allowed during write leveling with output buffer enabled.                                                          000 : LMC writes 001 (RZQ/4)   to MR1[Rtt_Nom]                                                          001 : LMC writes 010 (RZQ/2)   to MR1[Rtt_Nom]                                                          010 : LMC writes 011 (RZQ/6)   to MR1[Rtt_Nom]                                                          011 : LMC writes 100 (RZQ/12)  to MR1[Rtt_Nom]                                                          100 : LMC writes 101 (RZQ/8)   to MR1[Rtt_Nom]                                                          101 : LMC writes 110 (Rsvd)    to MR1[Rtt_Nom]                                                          110 : LMC writes 111 (Rsvd)    to  MR1[Rtt_Nom]                                                          111 : LMC writes 000 (Disabled) to MR1[Rtt_Nom] */
name|uint64_t
name|bitmask
range|:
literal|8
decl_stmt|;
comment|/**< Mask to select bit lanes on which write-leveling                                                          feedback is returned when OR_DIS is set to 1 */
name|uint64_t
name|or_dis
range|:
literal|1
decl_stmt|;
comment|/**< Disable or'ing of bits in a byte lane when computing                                                          the write-leveling bitmask */
name|uint64_t
name|sset
range|:
literal|1
decl_stmt|;
comment|/**< Run write-leveling on the current setting only. */
name|uint64_t
name|lanemask
range|:
literal|9
decl_stmt|;
comment|/**< One-hot mask to select byte lane to be leveled by                                                          the write-leveling sequence                                                          Used with x16 parts where the upper and lower byte                                                          lanes need to be leveled independently */
else|#
directive|else
name|uint64_t
name|lanemask
range|:
literal|9
decl_stmt|;
name|uint64_t
name|sset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|or_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bitmask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rtt_nom
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_wlevel_ctl_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_lmcx_wlevel_ctl_cn63xxp1
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|sset
range|:
literal|1
decl_stmt|;
comment|/**< Run write-leveling on the current setting only. */
name|uint64_t
name|lanemask
range|:
literal|9
decl_stmt|;
comment|/**< One-hot mask to select byte lane to be leveled by                                                          the write-leveling sequence                                                          Used with x16 parts where the upper and lower byte                                                          lanes need to be leveled independently */
else|#
directive|else
name|uint64_t
name|lanemask
range|:
literal|9
decl_stmt|;
name|uint64_t
name|sset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_wlevel_ctl
name|cvmx_lmcx_wlevel_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_wlevel_dbg  *  * Notes:  * A given write of LMC*_WLEVEL_DBG returns the write-leveling pass/fail results for all possible  * delay settings (i.e. the BITMASK) for only one byte in the last rank that the HW write-leveled.  * LMC*_WLEVEL_DBG[BYTE] selects the particular byte.  * To get these pass/fail results for another different rank, you must run the hardware write-leveling  * again. For example, it is possible to get the BITMASK results for every byte of every rank  * if you run write-leveling separately for each rank, probing LMC*_WLEVEL_DBG between each  * write-leveling.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_wlevel_dbg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_wlevel_dbg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|bitmask
range|:
literal|8
decl_stmt|;
comment|/**< Bitmask generated during deskew settings sweep                                                          if LMCX_WLEVEL_CTL[SSET]=0                                                            BITMASK[n]=0 means deskew setting n failed                                                            BITMASK[n]=1 means deskew setting n passed                                                            for 0<= n<= 7                                                            BITMASK contains the first 8 results of the total 16                                                            collected by LMC during the write-leveling sequence                                                          else if LMCX_WLEVEL_CTL[SSET]=1                                                            BITMASK[0]=0 means curr deskew setting failed                                                            BITMASK[0]=1 means curr deskew setting passed */
name|uint64_t
name|byte
range|:
literal|4
decl_stmt|;
comment|/**< 0<= BYTE<= 8 */
else|#
directive|else
name|uint64_t
name|byte
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bitmask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_wlevel_dbg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_wlevel_dbg_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_wlevel_dbg
name|cvmx_lmcx_wlevel_dbg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_wlevel_rank#  *  * Notes:  * This is four CSRs per LMC, one per each rank.  *  * Deskew setting is measured in units of 1/8 CK, so the above BYTE* values can range over 4 CKs.  *  * Assuming LMC*_WLEVEL_CTL[SSET]=0, the BYTE*<2:0> values are not used during write-leveling, and  * they are over-written by the hardware as part of the write-leveling sequence. (HW sets STATUS==3  * after HW write-leveling completes for the rank). SW needs to set BYTE*<4:3> bits.  *  * Each CSR may also be written by SW, but not while a write-leveling sequence is in progress. (HW sets STATUS==1 after a CSR write.)  *  * SW initiates a HW write-leveling sequence by programming LMC*_WLEVEL_CTL and writing RANKMASK and INIT_START=1 with SEQUENCE=6 in LMC*_CONFIG.  * LMC will then step through and accumulate write leveling results for 8 unique delay settings (twice), starting at a delay of  * LMC*_WLEVEL_RANKn[BYTE*<4:3>]*8 CK increasing by 1/8 CK each setting. HW will then set LMC*_WLEVEL_RANKi[BYTE*<2:0>] to indicate the  * first write leveling result of '1' that followed a reslt of '0' during the sequence by searching for a '1100' pattern in the generated  * bitmask, except that LMC will always write LMC*_WLEVEL_RANKi[BYTE*<0>]=0. If HW is unable to find a match for a '1100' pattern, then HW will  * set LMC*_WLEVEL_RANKi[BYTE*<2:0>] to 4.  * See LMC*_WLEVEL_CTL.  *  * LMC*_WLEVEL_RANKi values for ranks i without attached DRAM should be set such that  * they do not increase the range of possible BYTE values for any byte  * lane. The easiest way to do this is to set  *     LMC*_WLEVEL_RANKi = LMC*_WLEVEL_RANKj,  * where j is some rank with attached DRAM whose LMC*_WLEVEL_RANKj is already fully initialized.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_wlevel_rankx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_wlevel_rankx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|status
range|:
literal|2
decl_stmt|;
comment|/**< Indicates status of the write-leveling and where                                                          the BYTE* programmings in<44:0> came from:                                                          0 = BYTE* values are their reset value                                                          1 = BYTE* values were set via a CSR write to this register                                                          2 = write-leveling sequence currently in progress (BYTE* values are unpredictable)                                                          3 = BYTE* values came from a complete write-leveling sequence, irrespective of                                                              which lanes are masked via LMC*WLEVEL_CTL[LANEMASK] */
name|uint64_t
name|byte8
range|:
literal|5
decl_stmt|;
comment|/**< Deskew setting                                                          Bit 0 of BYTE8 must be zero during normal operation.                                                          When ECC DRAM is not present (i.e. when DRAM is not                                                          attached to chip signals DDR_CBS_0_* and DDR_CB[7:0]),                                                          SW should write BYTE8 with a value that does                                                          not increase the range of possible BYTE* values. The                                                          easiest way to do this is to set                                                          LMC*_WLEVEL_RANK*[BYTE8] = LMC*_WLEVEL_RANK*[BYTE0]                                                          when there is no ECC DRAM, using the final BYTE0 value. */
name|uint64_t
name|byte7
range|:
literal|5
decl_stmt|;
comment|/**< Deskew setting                                                          Bit 0 of BYTE7 must be zero during normal operation */
name|uint64_t
name|byte6
range|:
literal|5
decl_stmt|;
comment|/**< Deskew setting                                                          Bit 0 of BYTE6 must be zero during normal operation */
name|uint64_t
name|byte5
range|:
literal|5
decl_stmt|;
comment|/**< Deskew setting                                                          Bit 0 of BYTE5 must be zero during normal operation */
name|uint64_t
name|byte4
range|:
literal|5
decl_stmt|;
comment|/**< Deskew setting                                                          Bit 0 of BYTE4 must be zero during normal operation */
name|uint64_t
name|byte3
range|:
literal|5
decl_stmt|;
comment|/**< Deskew setting                                                          Bit 0 of BYTE3 must be zero during normal operation */
name|uint64_t
name|byte2
range|:
literal|5
decl_stmt|;
comment|/**< Deskew setting                                                          Bit 0 of BYTE2 must be zero during normal operation */
name|uint64_t
name|byte1
range|:
literal|5
decl_stmt|;
comment|/**< Deskew setting                                                          Bit 0 of BYTE1 must be zero during normal operation */
name|uint64_t
name|byte0
range|:
literal|5
decl_stmt|;
comment|/**< Deskew setting                                                          Bit 0 of BYTE0 must be zero during normal operation */
else|#
directive|else
name|uint64_t
name|byte0
range|:
literal|5
decl_stmt|;
name|uint64_t
name|byte1
range|:
literal|5
decl_stmt|;
name|uint64_t
name|byte2
range|:
literal|5
decl_stmt|;
name|uint64_t
name|byte3
range|:
literal|5
decl_stmt|;
name|uint64_t
name|byte4
range|:
literal|5
decl_stmt|;
name|uint64_t
name|byte5
range|:
literal|5
decl_stmt|;
name|uint64_t
name|byte6
range|:
literal|5
decl_stmt|;
name|uint64_t
name|byte7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|byte8
range|:
literal|5
decl_stmt|;
name|uint64_t
name|status
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_wlevel_rankx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_wlevel_rankx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_wlevel_rankx
name|cvmx_lmcx_wlevel_rankx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_wodt_ctl0  *  * LMC_WODT_CTL0 = LMC Write OnDieTermination control  * See the description in LMC_WODT_CTL1.  *  * Notes:  * Together, the LMC_WODT_CTL1 and LMC_WODT_CTL0 CSRs control the write ODT mask.  See LMC_WODT_CTL1.  *  */
end_comment

begin_union
union|union
name|cvmx_lmcx_wodt_ctl0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_wodt_ctl0_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_lmcx_wodt_ctl0_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|wodt_d1_r1
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask DIMM1, RANK1 */
name|uint64_t
name|wodt_d1_r0
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask DIMM1, RANK0 */
name|uint64_t
name|wodt_d0_r1
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask DIMM0, RANK1 */
name|uint64_t
name|wodt_d0_r0
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask DIMM0, RANK0 */
else|#
directive|else
name|uint64_t
name|wodt_d0_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d0_r1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d1_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d1_r1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_lmcx_wodt_ctl0_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_lmcx_wodt_ctl0_cn38xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|wodt_hi3
range|:
literal|4
decl_stmt|;
comment|/**< Write ODT mask for position 3, data[127:64] */
name|uint64_t
name|wodt_hi2
range|:
literal|4
decl_stmt|;
comment|/**< Write ODT mask for position 2, data[127:64] */
name|uint64_t
name|wodt_hi1
range|:
literal|4
decl_stmt|;
comment|/**< Write ODT mask for position 1, data[127:64] */
name|uint64_t
name|wodt_hi0
range|:
literal|4
decl_stmt|;
comment|/**< Write ODT mask for position 0, data[127:64] */
name|uint64_t
name|wodt_lo3
range|:
literal|4
decl_stmt|;
comment|/**< Write ODT mask for position 3, data[ 63: 0] */
name|uint64_t
name|wodt_lo2
range|:
literal|4
decl_stmt|;
comment|/**< Write ODT mask for position 2, data[ 63: 0] */
name|uint64_t
name|wodt_lo1
range|:
literal|4
decl_stmt|;
comment|/**< Write ODT mask for position 1, data[ 63: 0] */
name|uint64_t
name|wodt_lo0
range|:
literal|4
decl_stmt|;
comment|/**< Write ODT mask for position 0, data[ 63: 0] */
else|#
directive|else
name|uint64_t
name|wodt_lo0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|wodt_lo1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|wodt_lo2
range|:
literal|4
decl_stmt|;
name|uint64_t
name|wodt_lo3
range|:
literal|4
decl_stmt|;
name|uint64_t
name|wodt_hi0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|wodt_hi1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|wodt_hi2
range|:
literal|4
decl_stmt|;
name|uint64_t
name|wodt_hi3
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_lmcx_wodt_ctl0_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_lmcx_wodt_ctl0_cn38xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_lmcx_wodt_ctl0_cn30xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_wodt_ctl0_cn30xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_wodt_ctl0_cn30xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_wodt_ctl0_cn30xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_wodt_ctl0_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_lmcx_wodt_ctl0_cn38xx
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_wodt_ctl0
name|cvmx_lmcx_wodt_ctl0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_wodt_ctl1  *  * LMC_WODT_CTL1 = LMC Write OnDieTermination control  * System designers may desire to terminate DQ/DQS/DM lines for higher frequency DDR operations  * (667MHz and faster), especially on a multi-rank system. DDR2 DQ/DM/DQS I/O's have built in  * Termination resistor that can be turned on or off by the controller, after meeting tAOND and tAOF  * timing requirements. Each Rank has its own ODT pin that fans out to all the memory parts  * in that DIMM. System designers may prefer different combinations of ODT ON's for read and write  * into different ranks. Octeon supports full programmability by way of the mask register below.  * Each Rank position has its own 8-bit programmable field.  * When the controller does a write to that rank, it sets the 8 ODT pins to the MASK pins below.  * For eg., When doing a write into Rank0, a system designer may desire to terminate the lines  * with the resistor on Dimm0/Rank1. The mask WODT_D0_R0 would then be [00000010].  * If ODT feature is not desired, the DDR parts can be programmed to not look at these pins by  * writing 0 in QS_DIC. Octeon drives the appropriate mask values on the ODT pins by default.  * If this feature is not required, write 0 in this register.  *  * Notes:  * Together, the LMC_WODT_CTL1 and LMC_WODT_CTL0 CSRs control the write ODT mask.  * When a given RANK is selected, the WODT mask for that RANK is used.  The resulting WODT mask is  * driven to the DIMMs in the following manner:  *            BUNK_ENA=1     BUNK_ENA=0  * Mask[7] -> DIMM3, RANK1    DIMM3  * Mask[6] -> DIMM3, RANK0  * Mask[5] -> DIMM2, RANK1    DIMM2  * Mask[4] -> DIMM2, RANK0  * Mask[3] -> DIMM1, RANK1    DIMM1  * Mask[2] -> DIMM1, RANK0  * Mask[1] -> DIMM0, RANK1    DIMM0  * Mask[0] -> DIMM0, RANK0  */
end_comment

begin_union
union|union
name|cvmx_lmcx_wodt_ctl1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_wodt_ctl1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|wodt_d3_r1
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask DIMM3, RANK1/DIMM3 in SingleRanked */
name|uint64_t
name|wodt_d3_r0
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask DIMM3, RANK0 */
name|uint64_t
name|wodt_d2_r1
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask DIMM2, RANK1/DIMM2 in SingleRanked */
name|uint64_t
name|wodt_d2_r0
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask DIMM2, RANK0 */
else|#
directive|else
name|uint64_t
name|wodt_d2_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d2_r1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d3_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d3_r1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_wodt_ctl1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_lmcx_wodt_ctl1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_lmcx_wodt_ctl1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_lmcx_wodt_ctl1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_lmcx_wodt_ctl1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_lmcx_wodt_ctl1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_wodt_ctl1
name|cvmx_lmcx_wodt_ctl1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_lmc#_wodt_mask  *  * LMC_WODT_MASK = LMC Write OnDieTermination mask  * System designers may desire to terminate DQ/DQS lines for higher frequency DDR operations  * especially on a multi-rank system. DDR3 DQ/DQS I/O's have built in  * Termination resistor that can be turned on or off by the controller, after meeting tAOND and tAOF  * timing requirements. Each Rank has its own ODT pin that fans out to all the memory parts  * in that DIMM. System designers may prefer different combinations of ODT ON's for writes  * into different ranks. Octeon supports full programmability by way of the mask register below.  * Each Rank position has its own 8-bit programmable field.  * When the controller does a write to that rank, it sets the 4 ODT pins to the MASK pins below.  * For eg., When doing a write into Rank0, a system designer may desire to terminate the lines  * with the resistor on DIMM0/Rank1. The mask WODT_D0_R0 would then be [00000010].  * Octeon drives the appropriate mask values on the ODT pins by default. If this feature is not  * required, write 0 in this register.  *  * Notes:  * When a given RANK is selected, the WODT mask for that RANK is used.  The resulting WODT mask is  * driven to the DIMMs in the following manner:  *             RANK_ENA=1                    RANK_ENA=0  * Mask[3] -> DIMM1_ODT_1                     MBZ  * Mask[2] -> DIMM1_ODT_0                     DIMM1_ODT_0  * Mask[1] -> DIMM0_ODT_1                     MBZ  * Mask[0] -> DIMM0_ODT_0                     DIMM0_ODT_0  *  * LMC always writes entire cache blocks and always writes them via two consecutive  * write CAS operations to the same rank+bank+row spaced exactly 4 CK's apart.  * When a WODT mask bit is set, LMC asserts the OCTEON ODT output  * pin(s) starting the same CK as the first write CAS operation. Then, OCTEON  * normally continues to assert the ODT output pin(s) for 9+LMC*_CONTROL[WODT_BPRCH] more CK's  * - for a total of 10+LMC*_CONTROL[WODT_BPRCH] CK's for the entire cache block write -  * through the second write CAS operation of the cache block,  * satisfying the 6 CK DDR3 ODTH8 requirements.  * But it is possible for OCTEON to issue two cache block writes separated by as few as  * WtW = 8 or 9 (10 if LMC*_CONTROL[WODT_BPRCH]=1) CK's. In that case, OCTEON asserts the ODT output pin(s)  * for the WODT mask of the first cache block write for WtW CK's, then asserts  * the ODT output pin(s) for the WODT mask of the second cache block write for 10+LMC*_CONTROL[WODT_BPRCH] CK's  * (or less if a third cache block write follows within 8 or 9 (or 10) CK's of this second cache block write).  * Note that it may be necessary to force LMC to space back-to-back cache block writes  * to different ranks apart by at least 10+LMC*_CONTROL[WODT_BPRCH] CK's to prevent DDR3 ODTH8 violations.  */
end_comment

begin_union
union|union
name|cvmx_lmcx_wodt_mask
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_lmcx_wodt_mask_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|wodt_d3_r1
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask DIMM3, RANK1/DIMM3 in SingleRanked                                                          *UNUSED IN 63xx, and MBZ* */
name|uint64_t
name|wodt_d3_r0
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask DIMM3, RANK0                                                          *UNUSED IN 63xx, and MBZ* */
name|uint64_t
name|wodt_d2_r1
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask DIMM2, RANK1/DIMM2 in SingleRanked                                                          *UNUSED IN 63xx, and MBZ* */
name|uint64_t
name|wodt_d2_r0
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask DIMM2, RANK0                                                          *UNUSED IN 63xx, and MBZ* */
name|uint64_t
name|wodt_d1_r1
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask DIMM1, RANK1/DIMM1 in SingleRanked                                                          if (!RANK_ENA) then WODT_D1_R1[3:0] MBZ                                                          *Upper 4 bits UNUSED IN 63xx, and MBZ* */
name|uint64_t
name|wodt_d1_r0
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask DIMM1, RANK0                                                          if (!RANK_ENA) then WODT_D1_R0[3,1] MBZ                                                          *Upper 4 bits UNUSED IN 63xx, and MBZ* */
name|uint64_t
name|wodt_d0_r1
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask DIMM0, RANK1/DIMM0 in SingleRanked                                                          if (!RANK_ENA) then WODT_D0_R1[3:0] MBZ                                                          *Upper 4 bits UNUSED IN 63xx, and MBZ* */
name|uint64_t
name|wodt_d0_r0
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask DIMM0, RANK0                                                          if (!RANK_ENA) then WODT_D0_R0[3,1] MBZ                                                          *Upper 4 bits UNUSED IN 63xx, and MBZ* */
else|#
directive|else
name|uint64_t
name|wodt_d0_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d0_r1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d1_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d1_r1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d2_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d2_r1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d3_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d3_r1
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_lmcx_wodt_mask_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_lmcx_wodt_mask_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_lmcx_wodt_mask
name|cvmx_lmcx_wodt_mask_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

