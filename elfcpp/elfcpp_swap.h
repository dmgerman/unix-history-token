begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// elfcpp_swap.h -- Handle swapping for elfcpp   -*- C++ -*-
end_comment

begin_comment
comment|// This header file defines basic template classes to efficiently swap
end_comment

begin_comment
comment|// numbers between host form and target form.  When the host and
end_comment

begin_comment
comment|// target have the same endianness, these turn into no-ops.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ELFCPP_SWAP_H
end_ifndef

begin_define
define|#
directive|define
name|ELFCPP_SWAP_H
end_define

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<endian.h>
end_include

begin_include
include|#
directive|include
file|<byteswap.h>
end_include

begin_decl_stmt
name|namespace
name|elfcpp
block|{
comment|// Endian simply indicates whether the host is big endian or not.
struct|struct
name|Endian
block|{
name|public
label|:
comment|// Used for template specializations.
specifier|static
specifier|const
name|bool
name|host_big_endian
init|=
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
decl_stmt|;
block|}
struct|;
comment|// Valtype_base is a template based on size (8, 16, 32, 64) which
comment|// defines the type Valtype as the unsigned integer of the specified
comment|// size.
name|template
operator|<
name|int
name|size
operator|>
expr|struct
name|Valtype_base
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|Valtype_base
operator|<
literal|8
operator|>
block|{
typedef|typedef
name|unsigned
name|char
name|Valtype
typedef|;
block|}
empty_stmt|;
name|template
operator|<
operator|>
expr|struct
name|Valtype_base
operator|<
literal|16
operator|>
block|{
typedef|typedef
name|uint16_t
name|Valtype
typedef|;
block|}
empty_stmt|;
name|template
operator|<
operator|>
expr|struct
name|Valtype_base
operator|<
literal|32
operator|>
block|{
typedef|typedef
name|uint32_t
name|Valtype
typedef|;
block|}
empty_stmt|;
name|template
operator|<
operator|>
expr|struct
name|Valtype_base
operator|<
literal|64
operator|>
block|{
typedef|typedef
name|uint64_t
name|Valtype
typedef|;
block|}
empty_stmt|;
comment|// Convert_endian is a template based on size and on whether the host
comment|// and target have the same endianness.  It defines the type Valtype
comment|// as Valtype_base does, and also defines a function convert_host
comment|// which takes an argument of type Valtype and returns the same value,
comment|// but swapped if the host and target have different endianness.
name|template
operator|<
name|int
name|size
operator|,
name|bool
name|same_endian
operator|>
expr|struct
name|Convert_endian
expr_stmt|;
name|template
operator|<
name|int
name|size
operator|>
expr|struct
name|Convert_endian
operator|<
name|size
operator|,
name|true
operator|>
block|{
typedef|typedef
name|typename
name|Valtype_base
operator|<
name|size
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
specifier|static
specifier|inline
name|Valtype
name|convert_host
argument_list|(
argument|Valtype v
argument_list|)
block|{
return|return
name|v
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
operator|>
expr|struct
name|Convert_endian
operator|<
literal|8
operator|,
name|false
operator|>
block|{
typedef|typedef
name|Valtype_base
operator|<
literal|8
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
specifier|static
specifier|inline
name|Valtype
name|convert_host
argument_list|(
argument|Valtype v
argument_list|)
block|{
return|return
name|v
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
operator|>
expr|struct
name|Convert_endian
operator|<
literal|16
operator|,
name|false
operator|>
block|{
typedef|typedef
name|Valtype_base
operator|<
literal|16
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
specifier|static
specifier|inline
name|Valtype
name|convert_host
argument_list|(
argument|Valtype v
argument_list|)
block|{
return|return
name|bswap_16
argument_list|(
name|v
argument_list|)
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
operator|>
expr|struct
name|Convert_endian
operator|<
literal|32
operator|,
name|false
operator|>
block|{
typedef|typedef
name|Valtype_base
operator|<
literal|32
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
specifier|static
specifier|inline
name|Valtype
name|convert_host
argument_list|(
argument|Valtype v
argument_list|)
block|{
return|return
name|bswap_32
argument_list|(
name|v
argument_list|)
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
operator|>
expr|struct
name|Convert_endian
operator|<
literal|64
operator|,
name|false
operator|>
block|{
typedef|typedef
name|Valtype_base
operator|<
literal|64
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
specifier|static
specifier|inline
name|Valtype
name|convert_host
argument_list|(
argument|Valtype v
argument_list|)
block|{
return|return
name|bswap_64
argument_list|(
name|v
argument_list|)
return|;
block|}
block|}
empty_stmt|;
comment|// Convert is a template based on size and on whether the target is
comment|// big endian.  It defines Valtype and convert_host like
comment|// Convert_endian.  That is, it is just like Convert_endian except in
comment|// the meaning of the second template parameter.
name|template
operator|<
name|int
name|size
operator|,
name|bool
name|big_endian
operator|>
expr|struct
name|Convert
block|{
typedef|typedef
name|typename
name|Valtype_base
operator|<
name|size
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
specifier|static
specifier|inline
name|Valtype
name|convert_host
argument_list|(
argument|Valtype v
argument_list|)
block|{
return|return
name|Convert_endian
operator|<
name|size
operator|,
name|big_endian
operator|==
name|Endian
operator|::
name|host_big_endian
operator|>
operator|::
name|convert_host
argument_list|(
name|v
argument_list|)
return|;
block|}
block|}
empty_stmt|;
comment|// Swap is a template based on size and on whether the target is big
comment|// endian.  It defines the type Valtype and the functions readval and
comment|// writeval.  The functions read and write values of the appropriate
comment|// size out of buffers, swapping them if necessary.  readval and
comment|// writeval are overloaded to take pointers to the appropriate type or
comment|// pointers to unsigned char.
name|template
operator|<
name|int
name|size
operator|,
name|bool
name|big_endian
operator|>
expr|struct
name|Swap
block|{
typedef|typedef
name|typename
name|Valtype_base
operator|<
name|size
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
specifier|static
specifier|inline
name|Valtype
name|readval
argument_list|(
argument|const Valtype* wv
argument_list|)
block|{
return|return
name|Convert
operator|<
name|size
operator|,
name|big_endian
operator|>
operator|::
name|convert_host
argument_list|(
operator|*
name|wv
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|void
name|writeval
argument_list|(
argument|Valtype* wv
argument_list|,
argument|Valtype v
argument_list|)
block|{
operator|*
name|wv
operator|=
name|Convert
operator|<
name|size
block|,
name|big_endian
operator|>
operator|::
name|convert_host
argument_list|(
name|v
argument_list|)
block|; }
specifier|static
specifier|inline
name|Valtype
name|readval
argument_list|(
argument|const unsigned char* wv
argument_list|)
block|{
return|return
name|readval
argument_list|(
name|reinterpret_cast
operator|<
specifier|const
name|Valtype
operator|*
operator|>
operator|(
name|wv
operator|)
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|void
name|writeval
parameter_list|(
name|unsigned
name|char
modifier|*
name|wv
parameter_list|,
name|Valtype
name|v
parameter_list|)
block|{
name|writeval
argument_list|(
name|reinterpret_cast
operator|<
name|Valtype
operator|*
operator|>
operator|(
name|wv
operator|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// We need to specialize the 8-bit version of Swap to avoid
end_comment

begin_comment
comment|// conflicting overloads, since both versions of readval and writeval
end_comment

begin_comment
comment|// will have the same type parameters.
end_comment

begin_expr_stmt
name|template
operator|<
name|bool
name|big_endian
operator|>
expr|struct
name|Swap
operator|<
literal|8
operator|,
name|big_endian
operator|>
block|{
typedef|typedef
name|typename
name|Valtype_base
operator|<
literal|8
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
specifier|static
specifier|inline
name|Valtype
name|readval
argument_list|(
argument|const Valtype* wv
argument_list|)
block|{
return|return
operator|*
name|wv
return|;
block|}
specifier|static
specifier|inline
name|void
name|writeval
argument_list|(
argument|Valtype* wv
argument_list|,
argument|Valtype v
argument_list|)
block|{
operator|*
name|wv
operator|=
name|v
block|; }
end_expr_stmt

begin_comment
unit|};
comment|// Swap_unaligned is a template based on size and on whether the
end_comment

begin_comment
comment|// target is big endian.  It defines the type Valtype and the
end_comment

begin_comment
comment|// functions readval and writeval.  The functions read and write
end_comment

begin_comment
comment|// values of the appropriate size out of buffers which may be
end_comment

begin_comment
comment|// misaligned.
end_comment

begin_expr_stmt
name|template
operator|<
name|int
name|size
operator|,
name|bool
name|big_endian
operator|>
expr|struct
name|Swap_unaligned
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|bool
name|big_endian
operator|>
expr|struct
name|Swap_unaligned
operator|<
literal|8
operator|,
name|big_endian
operator|>
block|{
typedef|typedef
name|typename
name|Valtype_base
operator|<
literal|8
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
specifier|static
specifier|inline
name|Valtype
name|readval
argument_list|(
argument|const unsigned char* wv
argument_list|)
block|{
return|return
operator|*
name|wv
return|;
block|}
specifier|static
specifier|inline
name|void
name|writeval
argument_list|(
argument|unsigned char* wv
argument_list|,
argument|Valtype v
argument_list|)
block|{
operator|*
name|wv
operator|=
name|v
block|; }
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|Swap_unaligned
operator|<
literal|16
operator|,
name|false
operator|>
block|{
typedef|typedef
name|Valtype_base
operator|<
literal|16
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
specifier|static
specifier|inline
name|Valtype
name|readval
argument_list|(
argument|const unsigned char* wv
argument_list|)
block|{
return|return
operator|(
name|wv
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|wv
index|[
literal|0
index|]
return|;
block|}
specifier|static
specifier|inline
name|void
name|writeval
argument_list|(
argument|unsigned char* wv
argument_list|,
argument|Valtype v
argument_list|)
block|{
name|wv
index|[
literal|1
index|]
operator|=
name|v
operator|>>
literal|8
block|;
name|wv
index|[
literal|0
index|]
operator|=
name|v
block|;   }
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|Swap_unaligned
operator|<
literal|16
operator|,
name|true
operator|>
block|{
typedef|typedef
name|Valtype_base
operator|<
literal|16
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
specifier|static
specifier|inline
name|Valtype
name|readval
argument_list|(
argument|const unsigned char* wv
argument_list|)
block|{
return|return
operator|(
name|wv
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|wv
index|[
literal|1
index|]
return|;
block|}
specifier|static
specifier|inline
name|void
name|writeval
argument_list|(
argument|unsigned char* wv
argument_list|,
argument|Valtype v
argument_list|)
block|{
name|wv
index|[
literal|0
index|]
operator|=
name|v
operator|>>
literal|8
block|;
name|wv
index|[
literal|1
index|]
operator|=
name|v
block|;   }
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|Swap_unaligned
operator|<
literal|32
operator|,
name|false
operator|>
block|{
typedef|typedef
name|Valtype_base
operator|<
literal|32
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
specifier|static
specifier|inline
name|Valtype
name|readval
argument_list|(
argument|const unsigned char* wv
argument_list|)
block|{
return|return
operator|(
name|wv
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|wv
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|wv
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|wv
index|[
literal|0
index|]
return|;
block|}
specifier|static
specifier|inline
name|void
name|writeval
argument_list|(
argument|unsigned char* wv
argument_list|,
argument|Valtype v
argument_list|)
block|{
name|wv
index|[
literal|3
index|]
operator|=
name|v
operator|>>
literal|24
block|;
name|wv
index|[
literal|2
index|]
operator|=
name|v
operator|>>
literal|16
block|;
name|wv
index|[
literal|1
index|]
operator|=
name|v
operator|>>
literal|8
block|;
name|wv
index|[
literal|0
index|]
operator|=
name|v
block|;   }
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|Swap_unaligned
operator|<
literal|32
operator|,
name|true
operator|>
block|{
typedef|typedef
name|Valtype_base
operator|<
literal|32
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
specifier|static
specifier|inline
name|Valtype
name|readval
argument_list|(
argument|const unsigned char* wv
argument_list|)
block|{
return|return
operator|(
name|wv
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|wv
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|wv
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|wv
index|[
literal|3
index|]
return|;
block|}
specifier|static
specifier|inline
name|void
name|writeval
argument_list|(
argument|unsigned char* wv
argument_list|,
argument|Valtype v
argument_list|)
block|{
name|wv
index|[
literal|0
index|]
operator|=
name|v
operator|>>
literal|24
block|;
name|wv
index|[
literal|1
index|]
operator|=
name|v
operator|>>
literal|16
block|;
name|wv
index|[
literal|2
index|]
operator|=
name|v
operator|>>
literal|8
block|;
name|wv
index|[
literal|3
index|]
operator|=
name|v
block|;   }
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|Swap_unaligned
operator|<
literal|64
operator|,
name|false
operator|>
block|{
typedef|typedef
name|Valtype_base
operator|<
literal|64
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
specifier|static
specifier|inline
name|Valtype
name|readval
argument_list|(
argument|const unsigned char* wv
argument_list|)
block|{
return|return
operator|(
operator|(
name|static_cast
operator|<
name|Valtype
operator|>
operator|(
name|wv
index|[
literal|7
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
name|static_cast
operator|<
name|Valtype
operator|>
operator|(
name|wv
index|[
literal|6
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
name|static_cast
operator|<
name|Valtype
operator|>
operator|(
name|wv
index|[
literal|5
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
name|static_cast
operator|<
name|Valtype
operator|>
operator|(
name|wv
index|[
literal|4
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
name|static_cast
operator|<
name|Valtype
operator|>
operator|(
name|wv
index|[
literal|3
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|static_cast
operator|<
name|Valtype
operator|>
operator|(
name|wv
index|[
literal|2
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|static_cast
operator|<
name|Valtype
operator|>
operator|(
name|wv
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|static_cast
operator|<
name|Valtype
operator|>
operator|(
name|wv
index|[
literal|0
index|]
operator|)
operator|)
return|;
block|}
specifier|static
specifier|inline
name|void
name|writeval
argument_list|(
argument|unsigned char* wv
argument_list|,
argument|Valtype v
argument_list|)
block|{
name|wv
index|[
literal|7
index|]
operator|=
name|v
operator|>>
literal|56
block|;
name|wv
index|[
literal|6
index|]
operator|=
name|v
operator|>>
literal|48
block|;
name|wv
index|[
literal|5
index|]
operator|=
name|v
operator|>>
literal|40
block|;
name|wv
index|[
literal|4
index|]
operator|=
name|v
operator|>>
literal|32
block|;
name|wv
index|[
literal|3
index|]
operator|=
name|v
operator|>>
literal|24
block|;
name|wv
index|[
literal|2
index|]
operator|=
name|v
operator|>>
literal|16
block|;
name|wv
index|[
literal|1
index|]
operator|=
name|v
operator|>>
literal|8
block|;
name|wv
index|[
literal|0
index|]
operator|=
name|v
block|;   }
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
expr|struct
name|Swap_unaligned
operator|<
literal|64
operator|,
name|true
operator|>
block|{
typedef|typedef
name|Valtype_base
operator|<
literal|64
operator|>
operator|::
name|Valtype
name|Valtype
expr_stmt|;
specifier|static
specifier|inline
name|Valtype
name|readval
argument_list|(
argument|const unsigned char* wv
argument_list|)
block|{
return|return
operator|(
operator|(
name|static_cast
operator|<
name|Valtype
operator|>
operator|(
name|wv
index|[
literal|0
index|]
operator|)
operator|<<
literal|56
operator|)
operator||
operator|(
name|static_cast
operator|<
name|Valtype
operator|>
operator|(
name|wv
index|[
literal|1
index|]
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
name|static_cast
operator|<
name|Valtype
operator|>
operator|(
name|wv
index|[
literal|2
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
name|static_cast
operator|<
name|Valtype
operator|>
operator|(
name|wv
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
name|static_cast
operator|<
name|Valtype
operator|>
operator|(
name|wv
index|[
literal|4
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|static_cast
operator|<
name|Valtype
operator|>
operator|(
name|wv
index|[
literal|5
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|static_cast
operator|<
name|Valtype
operator|>
operator|(
name|wv
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
name|static_cast
operator|<
name|Valtype
operator|>
operator|(
name|wv
index|[
literal|7
index|]
operator|)
operator|)
return|;
block|}
specifier|static
specifier|inline
name|void
name|writeval
argument_list|(
argument|unsigned char* wv
argument_list|,
argument|Valtype v
argument_list|)
block|{
name|wv
index|[
literal|7
index|]
operator|=
name|v
operator|>>
literal|56
block|;
name|wv
index|[
literal|6
index|]
operator|=
name|v
operator|>>
literal|48
block|;
name|wv
index|[
literal|5
index|]
operator|=
name|v
operator|>>
literal|40
block|;
name|wv
index|[
literal|4
index|]
operator|=
name|v
operator|>>
literal|32
block|;
name|wv
index|[
literal|3
index|]
operator|=
name|v
operator|>>
literal|24
block|;
name|wv
index|[
literal|2
index|]
operator|=
name|v
operator|>>
literal|16
block|;
name|wv
index|[
literal|1
index|]
operator|=
name|v
operator|>>
literal|8
block|;
name|wv
index|[
literal|0
index|]
operator|=
name|v
block|;   }
end_expr_stmt

begin_comment
unit|};  }
comment|// End namespace elfcpp.
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// !defined(ELFCPP_SWAP_H)
end_comment

end_unit

