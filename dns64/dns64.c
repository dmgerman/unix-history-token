begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * dns64/dns64.c - DNS64 module  *  * Copyright (c) 2009, ViagÃ©nie. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of ViagÃ©nie nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains a module that performs DNS64 query processing.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"dns64/dns64.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/dns.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/fptr_wlist.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_comment
comment|/******************************************************************************  *                                                                            *  *                             STATIC CONSTANTS                               *  *                                                                            *  ******************************************************************************/
end_comment

begin_comment
comment|/**  * This is the default DNS64 prefix that is used whent he dns64 module is listed  * in module-config but when the dns64-prefix variable is not present.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|DEFAULT_DNS64_PREFIX
index|[]
init|=
literal|"64:ff9b::/96"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Maximum length of a domain name in a PTR query in the .in-addr.arpa tree.  */
end_comment

begin_define
define|#
directive|define
name|MAX_PTR_QNAME_IPV4
value|30
end_define

begin_comment
comment|/**  * Per-query module-specific state. This is usually a dynamically-allocated  * structure, but in our case we only need to store one variable describing the  * state the query is in. So we repurpose the minfo pointer by storing an  * integer in there.  */
end_comment

begin_enum
enum|enum
name|dns64_qstate
block|{
name|DNS64_INTERNAL_QUERY
block|,
comment|/**< Internally-generated query, no DNS64                                   processing. */
name|DNS64_NEW_QUERY
block|,
comment|/**< Query for which we're the first module in                                   line. */
name|DNS64_SUBQUERY_FINISHED
comment|/**< Query for which we generated a sub-query, and                                   for which this sub-query is finished. */
block|}
enum|;
end_enum

begin_comment
comment|/******************************************************************************  *                                                                            *  *                                 STRUCTURES                                 *  *                                                                            *  ******************************************************************************/
end_comment

begin_comment
comment|/**  * This structure contains module configuration information. One instance of  * this structure exists per instance of the module. Normally there is only one  * instance of the module.  */
end_comment

begin_struct
struct|struct
name|dns64_env
block|{
comment|/**      * DNS64 prefix address. We're using a full sockaddr instead of just an      * in6_addr because we can reuse Unbound's generic string parsing functions.      * It will always contain a sockaddr_in6, and only the sin6_addr member will      * ever be used.      */
name|struct
name|sockaddr_storage
name|prefix_addr
decl_stmt|;
comment|/**      * This is always sizeof(sockaddr_in6).      */
name|socklen_t
name|prefix_addrlen
decl_stmt|;
comment|/**      * This is the CIDR length of the prefix. It needs to be between 0 and 96.      */
name|int
name|prefix_net
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/******************************************************************************  *                                                                            *  *                             UTILITY FUNCTIONS                              *  *                                                                            *  ******************************************************************************/
end_comment

begin_comment
comment|/**  * Generic macro for swapping two variables.  *  * \param t Type of the variables. (e.g. int)  * \param a First variable.  * \param b Second variable.  *  * \warning Do not attempt something foolish such as swap(int,a++,b++)!  */
end_comment

begin_define
define|#
directive|define
name|swap
parameter_list|(
name|t
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|do {t x = a; a = b; b = x;} while(0)
end_define

begin_comment
comment|/**  * Reverses a string.  *  * \param begin Points to the first character of the string.  * \param end   Points one past the last character of the string.  */
end_comment

begin_function
specifier|static
name|void
name|reverse
parameter_list|(
name|char
modifier|*
name|begin
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
block|{
while|while
condition|(
name|begin
operator|<
operator|--
name|end
condition|)
block|{
name|swap
argument_list|(
name|char
argument_list|,
operator|*
name|begin
argument_list|,
operator|*
name|end
argument_list|)
expr_stmt|;
operator|++
name|begin
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Convert an unsigned integer to a string. The point of this function is that  * of being faster than sprintf().  *  * \param n The number to be converted.  * \param s The result will be written here. Must be large enough, be careful!  *  * \return The number of characters written.  */
end_comment

begin_function
specifier|static
name|int
name|uitoa
parameter_list|(
name|unsigned
name|n
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|ss
init|=
name|s
decl_stmt|;
do|do
block|{
operator|*
name|ss
operator|++
operator|=
literal|'0'
operator|+
name|n
operator|%
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|/=
literal|10
condition|)
do|;
name|reverse
argument_list|(
name|s
argument_list|,
name|ss
argument_list|)
expr_stmt|;
return|return
name|ss
operator|-
name|s
return|;
block|}
end_function

begin_comment
comment|/**  * Extract an IPv4 address embedded in the IPv6 address \a ipv6 at offset \a  * offset (in bits). Note that bits are not necessarily aligned on bytes so we  * need to be careful.  *  * \param ipv6   IPv6 address represented as a 128-bit array in big-endian  *               order.  * \param offset Index of the MSB of the IPv4 address embedded in the IPv6  *               address.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|extract_ipv4
parameter_list|(
specifier|const
name|uint8_t
name|ipv6
index|[
literal|16
index|]
parameter_list|,
specifier|const
name|int
name|offset
parameter_list|)
block|{
name|uint32_t
name|ipv4
init|=
operator|(
name|uint32_t
operator|)
name|ipv6
index|[
name|offset
operator|/
literal|8
operator|+
literal|0
index|]
operator|<<
operator|(
literal|24
operator|+
operator|(
name|offset
operator|%
literal|8
operator|)
operator|)
operator||
operator|(
name|uint32_t
operator|)
name|ipv6
index|[
name|offset
operator|/
literal|8
operator|+
literal|1
index|]
operator|<<
operator|(
literal|16
operator|+
operator|(
name|offset
operator|%
literal|8
operator|)
operator|)
operator||
operator|(
name|uint32_t
operator|)
name|ipv6
index|[
name|offset
operator|/
literal|8
operator|+
literal|2
index|]
operator|<<
operator|(
literal|8
operator|+
operator|(
name|offset
operator|%
literal|8
operator|)
operator|)
operator||
operator|(
name|uint32_t
operator|)
name|ipv6
index|[
name|offset
operator|/
literal|8
operator|+
literal|3
index|]
operator|<<
operator|(
literal|0
operator|+
operator|(
name|offset
operator|%
literal|8
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|offset
operator|/
literal|8
operator|+
literal|4
operator|<
literal|16
condition|)
name|ipv4
operator||=
operator|(
name|uint32_t
operator|)
name|ipv6
index|[
name|offset
operator|/
literal|8
operator|+
literal|4
index|]
operator|>>
operator|(
literal|8
operator|-
name|offset
operator|%
literal|8
operator|)
expr_stmt|;
return|return
name|ipv4
return|;
block|}
end_function

begin_comment
comment|/**  * Builds the PTR query name corresponding to an IPv4 address. For example,  * given the number 3,464,175,361, this will build the string  * "\03206\03123\0231\011\07in-addr\04arpa".  *  * \param ipv4 IPv4 address represented as an unsigned 32-bit number.  * \param ptr  The result will be written here. Must be large enough, be  *             careful!  *  * \return The number of characters written.  */
end_comment

begin_function
specifier|static
name|size_t
name|ipv4_to_ptr
parameter_list|(
name|uint32_t
name|ipv4
parameter_list|,
name|char
name|ptr
index|[
name|MAX_PTR_QNAME_IPV4
index|]
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|IPV4_PTR_SUFFIX
index|[]
init|=
literal|"\07in-addr\04arpa"
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|c
init|=
name|ptr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|c
operator|=
name|uitoa
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|ipv4
operator|%
literal|256
argument_list|)
argument_list|,
name|c
operator|+
literal|1
argument_list|)
expr_stmt|;
name|c
operator|+=
operator|*
name|c
operator|+
literal|1
expr_stmt|;
name|ipv4
operator|/=
literal|256
expr_stmt|;
block|}
name|memmove
argument_list|(
name|c
argument_list|,
name|IPV4_PTR_SUFFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|IPV4_PTR_SUFFIX
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c
operator|+
sizeof|sizeof
argument_list|(
name|IPV4_PTR_SUFFIX
argument_list|)
operator|-
name|ptr
return|;
block|}
end_function

begin_comment
comment|/**  * Converts an IPv6-related domain name string from a PTR query into an IPv6  * address represented as a 128-bit array.  *  * \param ptr  The domain name. (e.g. "\011[...]\010\012\016\012\03ip6\04arpa")  * \param ipv6 The result will be written here, in network byte order.  *  * \return 1 on success, 0 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|ptr_to_ipv6
parameter_list|(
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
name|uint8_t
name|ipv6
index|[
literal|16
index|]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|ptr
index|[
name|i
operator|++
index|]
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ptr
index|[
name|i
index|]
operator|>=
literal|'0'
operator|&&
name|ptr
index|[
name|i
index|]
operator|<=
literal|'9'
condition|)
block|{
name|x
operator|=
name|ptr
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptr
index|[
name|i
index|]
operator|>=
literal|'a'
operator|&&
name|ptr
index|[
name|i
index|]
operator|<=
literal|'f'
condition|)
block|{
name|x
operator|=
name|ptr
index|[
name|i
index|]
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptr
index|[
name|i
index|]
operator|>=
literal|'A'
operator|&&
name|ptr
index|[
name|i
index|]
operator|<=
literal|'F'
condition|)
block|{
name|x
operator|=
name|ptr
index|[
name|i
index|]
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
name|ipv6
index|[
literal|15
operator|-
name|i
operator|/
literal|4
index|]
operator||=
name|x
operator|<<
operator|(
literal|2
operator|*
operator|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Synthesize an IPv6 address based on an IPv4 address and the DNS64 prefix.  *  * \param prefix_addr DNS64 prefix address.  * \param prefix_net  CIDR length of the DNS64 prefix. Must be between 0 and 96.  * \param a           IPv4 address.  * \param aaaa        IPv6 address. The result will be written here.  */
end_comment

begin_function
specifier|static
name|void
name|synthesize_aaaa
parameter_list|(
specifier|const
name|uint8_t
name|prefix_addr
index|[
literal|16
index|]
parameter_list|,
name|int
name|prefix_net
parameter_list|,
specifier|const
name|uint8_t
name|a
index|[
literal|4
index|]
parameter_list|,
name|uint8_t
name|aaaa
index|[
literal|16
index|]
parameter_list|)
block|{
name|memcpy
argument_list|(
name|aaaa
argument_list|,
name|prefix_addr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|aaaa
index|[
name|prefix_net
operator|/
literal|8
operator|+
literal|0
index|]
operator||=
name|a
index|[
literal|0
index|]
operator|>>
operator|(
literal|0
operator|+
name|prefix_net
operator|%
literal|8
operator|)
expr_stmt|;
name|aaaa
index|[
name|prefix_net
operator|/
literal|8
operator|+
literal|1
index|]
operator||=
name|a
index|[
literal|0
index|]
operator|<<
operator|(
literal|8
operator|-
name|prefix_net
operator|%
literal|8
operator|)
expr_stmt|;
name|aaaa
index|[
name|prefix_net
operator|/
literal|8
operator|+
literal|1
index|]
operator||=
name|a
index|[
literal|1
index|]
operator|>>
operator|(
literal|0
operator|+
name|prefix_net
operator|%
literal|8
operator|)
expr_stmt|;
name|aaaa
index|[
name|prefix_net
operator|/
literal|8
operator|+
literal|2
index|]
operator||=
name|a
index|[
literal|1
index|]
operator|<<
operator|(
literal|8
operator|-
name|prefix_net
operator|%
literal|8
operator|)
expr_stmt|;
name|aaaa
index|[
name|prefix_net
operator|/
literal|8
operator|+
literal|2
index|]
operator||=
name|a
index|[
literal|2
index|]
operator|>>
operator|(
literal|0
operator|+
name|prefix_net
operator|%
literal|8
operator|)
expr_stmt|;
name|aaaa
index|[
name|prefix_net
operator|/
literal|8
operator|+
literal|3
index|]
operator||=
name|a
index|[
literal|2
index|]
operator|<<
operator|(
literal|8
operator|-
name|prefix_net
operator|%
literal|8
operator|)
expr_stmt|;
name|aaaa
index|[
name|prefix_net
operator|/
literal|8
operator|+
literal|3
index|]
operator||=
name|a
index|[
literal|3
index|]
operator|>>
operator|(
literal|0
operator|+
name|prefix_net
operator|%
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|prefix_net
operator|/
literal|8
operator|+
literal|4
operator|<
literal|16
condition|)
comment|/*<-- my beautiful symmetry is destroyed! */
name|aaaa
index|[
name|prefix_net
operator|/
literal|8
operator|+
literal|4
index|]
operator||=
name|a
index|[
literal|3
index|]
operator|<<
operator|(
literal|8
operator|-
name|prefix_net
operator|%
literal|8
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *                                                                            *  *                           DNS64 MODULE FUNCTIONS                           *  *                                                                            *  ******************************************************************************/
end_comment

begin_comment
comment|/**  * This function applies the configuration found in the parsed configuration  * file \a cfg to this instance of the dns64 module. Currently only the DNS64  * prefix (a.k.a. Pref64) is configurable.  *  * \param dns64_env Module-specific global parameters.  * \param cfg       Parsed configuration file.  */
end_comment

begin_function
specifier|static
name|int
name|dns64_apply_cfg
parameter_list|(
name|struct
name|dns64_env
modifier|*
name|dns64_env
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"dns64-prefix: %s"
argument_list|,
name|cfg
operator|->
name|dns64_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|netblockstrtoaddr
argument_list|(
name|cfg
operator|->
name|dns64_prefix
condition|?
name|cfg
operator|->
name|dns64_prefix
else|:
name|DEFAULT_DNS64_PREFIX
argument_list|,
literal|0
argument_list|,
operator|&
name|dns64_env
operator|->
name|prefix_addr
argument_list|,
operator|&
name|dns64_env
operator|->
name|prefix_addrlen
argument_list|,
operator|&
name|dns64_env
operator|->
name|prefix_net
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"cannot parse dns64-prefix netblock: %s"
argument_list|,
name|cfg
operator|->
name|dns64_prefix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|addr_is_ip6
argument_list|(
operator|&
name|dns64_env
operator|->
name|prefix_addr
argument_list|,
name|dns64_env
operator|->
name|prefix_addrlen
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"dns64_prefix is not IPv6: %s"
argument_list|,
name|cfg
operator|->
name|dns64_prefix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|dns64_env
operator|->
name|prefix_net
operator|<
literal|0
operator|||
name|dns64_env
operator|->
name|prefix_net
operator|>
literal|96
condition|)
block|{
name|log_err
argument_list|(
literal|"dns64-prefix length it not between 0 and 96: %s"
argument_list|,
name|cfg
operator|->
name|dns64_prefix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Initializes this instance of the dns64 module.  *  * \param env Global state of all module instances.  * \param id  This instance's ID number.  */
end_comment

begin_function
name|int
name|dns64_init
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|dns64_env
modifier|*
name|dns64_env
init|=
operator|(
expr|struct
name|dns64_env
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dns64_env
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dns64_env
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|env
operator|->
name|modinfo
index|[
name|id
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|dns64_env
expr_stmt|;
if|if
condition|(
operator|!
name|dns64_apply_cfg
argument_list|(
name|dns64_env
argument_list|,
name|env
operator|->
name|cfg
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"dns64: could not apply configuration settings."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Deinitializes this instance of the dns64 module.  *  * \param env Global state of all module instances.  * \param id  This instance's ID number.  */
end_comment

begin_function
name|void
name|dns64_deinit
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|int
name|id
parameter_list|)
block|{
if|if
condition|(
operator|!
name|env
condition|)
return|return;
name|free
argument_list|(
name|env
operator|->
name|modinfo
index|[
name|id
index|]
argument_list|)
expr_stmt|;
name|env
operator|->
name|modinfo
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Handle PTR queries for IPv6 addresses. If the address belongs to the DNS64  * prefix, we must do a PTR query for the corresponding IPv4 address instead.  *  * \param qstate Query state structure.  * \param id     This module instance's ID number.  *  * \return The new state of the query.  */
end_comment

begin_function
specifier|static
name|enum
name|module_ext_state
name|handle_ipv6_ptr
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|dns64_env
modifier|*
name|dns64_env
init|=
operator|(
expr|struct
name|dns64_env
operator|*
operator|)
name|qstate
operator|->
name|env
operator|->
name|modinfo
index|[
name|id
index|]
decl_stmt|;
name|struct
name|module_qstate
modifier|*
name|subq
init|=
name|NULL
decl_stmt|;
name|struct
name|query_info
name|qinfo
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
comment|/* Convert the PTR query string to an IPv6 address. */
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
if|if
condition|(
operator|!
name|ptr_to_ipv6
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qstate
operator|->
name|qinfo
operator|.
name|qname
argument_list|,
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr
argument_list|)
condition|)
return|return
name|module_wait_module
return|;
comment|/* Let other module handle this. */
comment|/*      * If this IPv6 address is not part of our DNS64 prefix, then we don't need      * to do anything. Let another module handle the query.      */
if|if
condition|(
name|addr_in_common
argument_list|(
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|&
name|sin6
argument_list|,
literal|128
argument_list|,
operator|&
name|dns64_env
operator|->
name|prefix_addr
argument_list|,
name|dns64_env
operator|->
name|prefix_net
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
operator|!=
name|dns64_env
operator|->
name|prefix_net
condition|)
return|return
name|module_wait_module
return|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"dns64: rewrite PTR record"
argument_list|)
expr_stmt|;
comment|/*      * Create a new PTR query info for the domain name corresponding to the IPv4      * address corresponding to the IPv6 address corresponding to the original      * PTR query domain name.      */
name|qinfo
operator|=
name|qstate
operator|->
name|qinfo
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|qinfo
operator|.
name|qname
operator|=
name|regional_alloc
argument_list|(
name|qstate
operator|->
name|region
argument_list|,
name|MAX_PTR_QNAME_IPV4
argument_list|)
operator|)
condition|)
return|return
name|module_error
return|;
name|qinfo
operator|.
name|qname_len
operator|=
name|ipv4_to_ptr
argument_list|(
name|extract_ipv4
argument_list|(
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
name|dns64_env
operator|->
name|prefix_net
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|qinfo
operator|.
name|qname
argument_list|)
expr_stmt|;
comment|/* Create the new sub-query. */
name|fptr_ok
argument_list|(
name|fptr_whitelist_modenv_attach_sub
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|attach_sub
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|qstate
operator|->
name|env
operator|->
name|attach_sub
call|)
argument_list|(
name|qstate
argument_list|,
operator|&
name|qinfo
argument_list|,
name|qstate
operator|->
name|query_flags
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|subq
argument_list|)
condition|)
return|return
name|module_error
return|;
if|if
condition|(
name|subq
condition|)
block|{
name|subq
operator|->
name|curmod
operator|=
name|id
expr_stmt|;
name|subq
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_state_initial
expr_stmt|;
name|subq
operator|->
name|minfo
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|module_wait_subquery
return|;
block|}
end_function

begin_comment
comment|/** allocate (special) rrset keys, return 0 on error */
end_comment

begin_function
specifier|static
name|int
name|repinfo_alloc_rrset_keys
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|region
condition|)
block|{
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|)
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
condition|)
block|{
name|memset
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|key
operator|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
return|return
literal|0
return|;
comment|/*	rep->rrsets[i] = alloc_special_obtain(alloc);*/
if|if
condition|(
operator|!
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|module_ext_state
name|generate_type_A_query
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|module_qstate
modifier|*
name|subq
init|=
name|NULL
decl_stmt|;
name|struct
name|query_info
name|qinfo
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"dns64: query A record"
argument_list|)
expr_stmt|;
comment|/* Create a new query info. */
name|qinfo
operator|=
name|qstate
operator|->
name|qinfo
expr_stmt|;
name|qinfo
operator|.
name|qtype
operator|=
name|LDNS_RR_TYPE_A
expr_stmt|;
comment|/* Start the sub-query. */
name|fptr_ok
argument_list|(
name|fptr_whitelist_modenv_attach_sub
argument_list|(
name|qstate
operator|->
name|env
operator|->
name|attach_sub
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|qstate
operator|->
name|env
operator|->
name|attach_sub
call|)
argument_list|(
name|qstate
argument_list|,
operator|&
name|qinfo
argument_list|,
name|qstate
operator|->
name|query_flags
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|subq
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"dns64: sub-query creation failed"
argument_list|)
expr_stmt|;
return|return
name|module_error
return|;
block|}
if|if
condition|(
name|subq
condition|)
block|{
name|subq
operator|->
name|curmod
operator|=
name|id
expr_stmt|;
name|subq
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_state_initial
expr_stmt|;
name|subq
operator|->
name|minfo
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|module_wait_subquery
return|;
block|}
end_function

begin_comment
comment|/**  * Handles the "pass" event for a query. This event is received when a new query  * is received by this module. The query may have been generated internally by  * another module, in which case we don't want to do any special processing  * (this is an interesting discussion topic),  or it may be brand new, e.g.  * received over a socket, in which case we do want to apply DNS64 processing.  *  * \param qstate A structure representing the state of the query that has just  *               received the "pass" event.  * \param id     This module's instance ID.  *  * \return The new state of the query.  */
end_comment

begin_function
specifier|static
name|enum
name|module_ext_state
name|handle_event_pass
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|)
block|{
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
operator|==
name|DNS64_NEW_QUERY
operator|&&
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_PTR
operator|&&
name|qstate
operator|->
name|qinfo
operator|.
name|qname_len
operator|==
literal|74
operator|&&
operator|!
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|qstate
operator|->
name|qinfo
operator|.
name|qname
index|[
literal|64
index|]
argument_list|,
literal|"\03ip6\04arpa"
argument_list|)
condition|)
comment|/* Handle PTR queries for IPv6 addresses. */
return|return
name|handle_ipv6_ptr
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
if|if
condition|(
name|qstate
operator|->
name|env
operator|->
name|cfg
operator|->
name|dns64_synthall
operator|&&
operator|(
name|uintptr_t
operator|)
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
operator|==
name|DNS64_NEW_QUERY
operator|&&
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_AAAA
condition|)
return|return
name|generate_type_A_query
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
comment|/* We are finished when our sub-query is finished. */
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
operator|==
name|DNS64_SUBQUERY_FINISHED
condition|)
return|return
name|module_finished
return|;
comment|/* Otherwise, pass request to next module. */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"dns64: pass to next module"
argument_list|)
expr_stmt|;
return|return
name|module_wait_module
return|;
block|}
end_function

begin_comment
comment|/**  * Handles the "done" event for a query. We need to analyze the response and  * maybe issue a new sub-query for the A record.  *  * \param qstate A structure representing the state of the query that has just  *               received the "pass" event.  * \param id     This module's instance ID.  *  * \return The new state of the query.  */
end_comment

begin_function
specifier|static
name|enum
name|module_ext_state
name|handle_event_moddone
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|)
block|{
comment|/*      * In many cases we have nothing special to do. From most to least common:      *      *   - An internal query.      *   - A query for a record type other than AAAA.      *   - CD FLAG was set on querier      *   - An AAAA query for which an error was returned.      *   - A successful AAAA query with an answer.      */
if|if
condition|(
operator|(
expr|enum
name|dns64_qstate
operator|)
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
operator|==
name|DNS64_INTERNAL_QUERY
operator|||
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|!=
name|LDNS_RR_TYPE_AAAA
operator|||
operator|(
name|qstate
operator|->
name|query_flags
operator|&
name|BIT_CD
operator|)
operator|||
name|qstate
operator|->
name|return_rcode
operator|!=
name|LDNS_RCODE_NOERROR
operator|||
operator|(
name|qstate
operator|->
name|return_msg
operator|&&
name|qstate
operator|->
name|return_msg
operator|->
name|rep
operator|&&
name|reply_find_answer_rrset
argument_list|(
operator|&
name|qstate
operator|->
name|qinfo
argument_list|,
name|qstate
operator|->
name|return_msg
operator|->
name|rep
argument_list|)
operator|)
condition|)
return|return
name|module_finished
return|;
comment|/* So, this is a AAAA noerror/nodata answer */
return|return
name|generate_type_A_query
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * This is the module's main() function. It gets called each time a query  * receives an event which we may need to handle. We respond by updating the  * state of the query.  *  * \param qstate   Structure containing the state of the query.  * \param event    Event that has just been received.  * \param id       This module's instance ID.  * \param outbound State of a DNS query on an authoritative server. We never do  *                 our own queries ourselves (other modules do it for us), so  *                 this is unused.  */
end_comment

begin_function
name|void
name|dns64_operate
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|enum
name|module_ev
name|event
parameter_list|,
name|int
name|id
parameter_list|,
name|struct
name|outbound_entry
modifier|*
name|outbound
parameter_list|)
block|{
operator|(
name|void
operator|)
name|outbound
expr_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"dns64[module %d] operate: extstate:%s event:%s"
argument_list|,
name|id
argument_list|,
name|strextstate
argument_list|(
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
argument_list|)
argument_list|,
name|strmodulevent
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|log_query_info
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"dns64 operate: query"
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|module_event_new
case|:
comment|/* Tag this query as being new and fall through. */
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|DNS64_NEW_QUERY
expr_stmt|;
case|case
name|module_event_pass
case|:
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|handle_event_pass
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|module_event_moddone
case|:
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|handle_event_moddone
argument_list|(
name|qstate
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
default|default:
name|qstate
operator|->
name|ext_state
index|[
name|id
index|]
operator|=
name|module_finished
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dns64_synth_aaaa_data
parameter_list|(
specifier|const
name|struct
name|ub_packed_rrset_key
modifier|*
name|fk
parameter_list|,
specifier|const
name|struct
name|packed_rrset_data
modifier|*
name|fd
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|dk
parameter_list|,
name|struct
name|packed_rrset_data
modifier|*
modifier|*
name|dd_out
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|dns64_env
modifier|*
name|dns64_env
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|dd
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* 	 * Create synthesized AAAA RR set data. We need to allocated extra memory 	 * for the RRs themselves. Each RR has a length, TTL, pointer to wireformat 	 * data, 2 bytes of data length, and 16 bytes of IPv6 address. 	 */
if|if
condition|(
name|fd
operator|->
name|count
operator|>
name|RR_COUNT_MAX
condition|)
block|{
operator|*
name|dd_out
operator|=
name|NULL
expr_stmt|;
return|return;
comment|/* integer overflow protection in alloc */
block|}
if|if
condition|(
operator|!
operator|(
name|dd
operator|=
operator|*
name|dd_out
operator|=
name|regional_alloc
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|packed_rrset_data
argument_list|)
operator|+
name|fd
operator|->
name|count
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
operator|+
literal|2
operator|+
literal|16
operator|)
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Copy attributes from A RR set. */
name|dd
operator|->
name|ttl
operator|=
name|fd
operator|->
name|ttl
expr_stmt|;
name|dd
operator|->
name|count
operator|=
name|fd
operator|->
name|count
expr_stmt|;
name|dd
operator|->
name|rrsig_count
operator|=
literal|0
expr_stmt|;
name|dd
operator|->
name|trust
operator|=
name|fd
operator|->
name|trust
expr_stmt|;
name|dd
operator|->
name|security
operator|=
name|fd
operator|->
name|security
expr_stmt|;
comment|/* 	 * Synthesize AAAA records. Adjust pointers in structure. 	 */
name|dd
operator|->
name|rr_len
operator|=
operator|(
name|size_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|dd
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|packed_rrset_data
argument_list|)
operator|)
expr_stmt|;
name|dd
operator|->
name|rr_data
operator|=
operator|(
name|uint8_t
operator|*
operator|*
operator|)
operator|&
name|dd
operator|->
name|rr_len
index|[
name|dd
operator|->
name|count
index|]
expr_stmt|;
name|dd
operator|->
name|rr_ttl
operator|=
operator|(
name|time_t
operator|*
operator|)
operator|&
name|dd
operator|->
name|rr_data
index|[
name|dd
operator|->
name|count
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fd
operator|->
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fd
operator|->
name|rr_len
index|[
name|i
index|]
operator|!=
literal|6
operator|||
name|fd
operator|->
name|rr_data
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|0
operator|||
name|fd
operator|->
name|rr_data
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|4
condition|)
return|return;
name|dd
operator|->
name|rr_len
index|[
name|i
index|]
operator|=
literal|18
expr_stmt|;
name|dd
operator|->
name|rr_data
index|[
name|i
index|]
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|dd
operator|->
name|rr_ttl
index|[
name|dd
operator|->
name|count
index|]
operator|+
literal|18
operator|*
name|i
expr_stmt|;
name|dd
operator|->
name|rr_data
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dd
operator|->
name|rr_data
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
literal|16
expr_stmt|;
name|synthesize_aaaa
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|dns64_env
operator|->
name|prefix_addr
operator|)
operator|->
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
name|dns64_env
operator|->
name|prefix_net
argument_list|,
operator|&
name|fd
operator|->
name|rr_data
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|,
operator|&
name|dd
operator|->
name|rr_data
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|dd
operator|->
name|rr_ttl
index|[
name|i
index|]
operator|=
name|fd
operator|->
name|rr_ttl
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* 	 * Create synthesized AAAA RR set key. This is mostly just bookkeeping, 	 * nothing interesting here. 	 */
if|if
condition|(
operator|!
name|dk
condition|)
block|{
name|log_err
argument_list|(
literal|"no key"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dk
operator|->
name|rk
operator|.
name|dname
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|regional_alloc_init
argument_list|(
name|region
argument_list|,
name|fk
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|fk
operator|->
name|rk
operator|.
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dk
operator|->
name|rk
operator|.
name|dname
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dk
operator|->
name|rk
operator|.
name|type
operator|=
name|htons
argument_list|(
name|LDNS_RR_TYPE_AAAA
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|dk
operator|->
name|entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dk
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|dk
operator|->
name|entry
operator|.
name|key
operator|=
name|dk
expr_stmt|;
name|dk
operator|->
name|entry
operator|.
name|hash
operator|=
name|rrset_key_hash
argument_list|(
operator|&
name|dk
operator|->
name|rk
argument_list|)
expr_stmt|;
name|dk
operator|->
name|entry
operator|.
name|data
operator|=
name|dd
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Synthesize an AAAA RR set from an A sub-query's answer and add it to the  * original empty response.  *  * \param id     This module's instance ID.  * \param super  Original AAAA query.  * \param qstate A query.  */
end_comment

begin_function
specifier|static
name|void
name|dns64_adjust_a
parameter_list|(
name|int
name|id
parameter_list|,
name|struct
name|module_qstate
modifier|*
name|super
parameter_list|,
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|)
block|{
name|struct
name|dns64_env
modifier|*
name|dns64_env
init|=
operator|(
expr|struct
name|dns64_env
operator|*
operator|)
name|super
operator|->
name|env
operator|->
name|modinfo
index|[
name|id
index|]
decl_stmt|;
name|struct
name|reply_info
modifier|*
name|rep
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|fd
decl_stmt|,
modifier|*
name|dd
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|fk
decl_stmt|,
modifier|*
name|dk
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"converting A answers to AAAA answers"
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|super
operator|->
name|region
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|qstate
operator|->
name|return_msg
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|qstate
operator|->
name|return_msg
operator|->
name|rep
argument_list|)
expr_stmt|;
comment|/* If dns64-synthall is enabled, return_msg is not initialized */
if|if
condition|(
operator|!
name|super
operator|->
name|return_msg
condition|)
block|{
name|super
operator|->
name|return_msg
operator|=
operator|(
expr|struct
name|dns_msg
operator|*
operator|)
name|regional_alloc
argument_list|(
name|super
operator|->
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dns_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|super
operator|->
name|return_msg
condition|)
return|return;
name|memset
argument_list|(
name|super
operator|->
name|return_msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|super
operator|->
name|return_msg
argument_list|)
argument_list|)
expr_stmt|;
name|super
operator|->
name|return_msg
operator|->
name|qinfo
operator|=
name|super
operator|->
name|qinfo
expr_stmt|;
block|}
name|rep
operator|=
name|qstate
operator|->
name|return_msg
operator|->
name|rep
expr_stmt|;
comment|/* 	 * Build the actual reply. 	 */
name|cp
operator|=
name|construct_reply_info_base
argument_list|(
name|super
operator|->
name|region
argument_list|,
name|rep
operator|->
name|flags
argument_list|,
name|rep
operator|->
name|qdcount
argument_list|,
name|rep
operator|->
name|ttl
argument_list|,
name|rep
operator|->
name|prefetch_ttl
argument_list|,
name|rep
operator|->
name|an_numrrsets
argument_list|,
name|rep
operator|->
name|ns_numrrsets
argument_list|,
name|rep
operator|->
name|ar_numrrsets
argument_list|,
name|rep
operator|->
name|rrset_count
argument_list|,
name|rep
operator|->
name|security
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return;
comment|/* allocate ub_key structures special or not */
if|if
condition|(
operator|!
name|repinfo_alloc_rrset_keys
argument_list|(
name|cp
argument_list|,
name|super
operator|->
name|region
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* copy everything and replace A by AAAA */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cp
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|fk
operator|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
name|dk
operator|=
name|cp
operator|->
name|rrsets
index|[
name|i
index|]
expr_stmt|;
name|fd
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|fk
operator|->
name|entry
operator|.
name|data
expr_stmt|;
name|dk
operator|->
name|rk
operator|=
name|fk
operator|->
name|rk
expr_stmt|;
name|dk
operator|->
name|id
operator|=
name|fk
operator|->
name|id
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
operator|&&
name|fk
operator|->
name|rk
operator|.
name|type
operator|==
name|htons
argument_list|(
name|LDNS_RR_TYPE_A
argument_list|)
condition|)
block|{
comment|/* also sets dk->entry.hash */
name|dns64_synth_aaaa_data
argument_list|(
name|fk
argument_list|,
name|fd
argument_list|,
name|dk
argument_list|,
operator|&
name|dd
argument_list|,
name|super
operator|->
name|region
argument_list|,
name|dns64_env
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dd
condition|)
return|return;
comment|/* Delete negative AAAA record from cache stored by 			 * the iterator module */
name|rrset_cache_remove
argument_list|(
name|super
operator|->
name|env
operator|->
name|rrset_cache
argument_list|,
name|dk
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|dk
operator|->
name|rk
operator|.
name|dname_len
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dk
operator|->
name|entry
operator|.
name|hash
operator|=
name|fk
operator|->
name|entry
operator|.
name|hash
expr_stmt|;
name|dk
operator|->
name|rk
operator|.
name|dname
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|regional_alloc_init
argument_list|(
name|super
operator|->
name|region
argument_list|,
name|fk
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|fk
operator|->
name|rk
operator|.
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dk
operator|->
name|rk
operator|.
name|dname
condition|)
return|return;
name|s
operator|=
name|packed_rrset_sizeof
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|dd
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|regional_alloc_init
argument_list|(
name|super
operator|->
name|region
argument_list|,
name|fd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dd
condition|)
return|return;
block|}
name|packed_rrset_ptr_fixup
argument_list|(
name|dd
argument_list|)
expr_stmt|;
name|dk
operator|->
name|entry
operator|.
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|dd
expr_stmt|;
block|}
comment|/* Commit changes. */
name|super
operator|->
name|return_msg
operator|->
name|rep
operator|=
name|cp
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Generate a response for the original IPv6 PTR query based on an IPv4 PTR  * sub-query's response.  *  * \param qstate IPv4 PTR sub-query.  * \param super  Original IPv6 PTR query.  */
end_comment

begin_function
specifier|static
name|void
name|dns64_adjust_ptr
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|struct
name|module_qstate
modifier|*
name|super
parameter_list|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|answer
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"adjusting PTR reply"
argument_list|)
expr_stmt|;
comment|/* Copy the sub-query's reply to the parent. */
if|if
condition|(
operator|!
operator|(
name|super
operator|->
name|return_msg
operator|=
operator|(
expr|struct
name|dns_msg
operator|*
operator|)
name|regional_alloc
argument_list|(
name|super
operator|->
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dns_msg
argument_list|)
argument_list|)
operator|)
condition|)
return|return;
name|super
operator|->
name|return_msg
operator|->
name|qinfo
operator|=
name|super
operator|->
name|qinfo
expr_stmt|;
name|super
operator|->
name|return_msg
operator|->
name|rep
operator|=
name|reply_info_copy
argument_list|(
name|qstate
operator|->
name|return_msg
operator|->
name|rep
argument_list|,
name|NULL
argument_list|,
name|super
operator|->
name|region
argument_list|)
expr_stmt|;
comment|/*      * Adjust the domain name of the answer RR set so that it matches the      * initial query's domain name.      */
name|answer
operator|=
name|reply_find_answer_rrset
argument_list|(
operator|&
name|qstate
operator|->
name|qinfo
argument_list|,
name|super
operator|->
name|return_msg
operator|->
name|rep
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|answer
argument_list|)
expr_stmt|;
name|answer
operator|->
name|rk
operator|.
name|dname
operator|=
name|super
operator|->
name|qinfo
operator|.
name|qname
expr_stmt|;
name|answer
operator|->
name|rk
operator|.
name|dname_len
operator|=
name|super
operator|->
name|qinfo
operator|.
name|qname_len
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This function is called when a sub-query finishes to inform the parent query.  *  * We issue two kinds of sub-queries: PTR and A.  *  * \param qstate State of the sub-query.  * \param id     This module's instance ID.  * \param super  State of the super-query.  */
end_comment

begin_function
name|void
name|dns64_inform_super
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|,
name|struct
name|module_qstate
modifier|*
name|super
parameter_list|)
block|{
name|log_query_info
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"dns64: inform_super, sub is"
argument_list|,
operator|&
name|qstate
operator|->
name|qinfo
argument_list|)
expr_stmt|;
name|log_query_info
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"super is"
argument_list|,
operator|&
name|super
operator|->
name|qinfo
argument_list|)
expr_stmt|;
comment|/* 	 * Signal that the sub-query is finished, no matter whether we are 	 * successful or not. This lets the state machine terminate. 	 */
name|super
operator|->
name|minfo
index|[
name|id
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|DNS64_SUBQUERY_FINISHED
expr_stmt|;
comment|/* If there is no successful answer, we're done. */
if|if
condition|(
name|qstate
operator|->
name|return_rcode
operator|!=
name|LDNS_RCODE_NOERROR
operator|||
operator|!
name|qstate
operator|->
name|return_msg
operator|||
operator|!
name|qstate
operator|->
name|return_msg
operator|->
name|rep
operator|||
operator|!
name|reply_find_answer_rrset
argument_list|(
operator|&
name|qstate
operator|->
name|qinfo
argument_list|,
name|qstate
operator|->
name|return_msg
operator|->
name|rep
argument_list|)
condition|)
return|return;
comment|/* Generate a response suitable for the original query. */
if|if
condition|(
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_A
condition|)
block|{
name|dns64_adjust_a
argument_list|(
name|id
argument_list|,
name|super
argument_list|,
name|qstate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_assert
argument_list|(
name|qstate
operator|->
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_PTR
argument_list|)
expr_stmt|;
name|dns64_adjust_ptr
argument_list|(
name|qstate
argument_list|,
name|super
argument_list|)
expr_stmt|;
block|}
comment|/* Store the generated response in cache. */
if|if
condition|(
operator|!
name|dns_cache_store
argument_list|(
name|super
operator|->
name|env
argument_list|,
operator|&
name|super
operator|->
name|qinfo
argument_list|,
name|super
operator|->
name|return_msg
operator|->
name|rep
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|super
operator|->
name|query_flags
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Clear module-specific data from query state. Since we do not allocate memory,  * it's just a matter of setting a pointer to NULL.  *  * \param qstate Query state.  * \param id     This module's instance ID.  */
end_comment

begin_function
name|void
name|dns64_clear
parameter_list|(
name|struct
name|module_qstate
modifier|*
name|qstate
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|qstate
operator|->
name|minfo
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Returns the amount of global memory that this module uses, not including  * per-query data.  *  * \param env Module environment.  * \param id  This module's instance ID.  */
end_comment

begin_function
name|size_t
name|dns64_get_mem
parameter_list|(
name|struct
name|module_env
modifier|*
name|env
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|dns64_env
modifier|*
name|dns64_env
init|=
operator|(
expr|struct
name|dns64_env
operator|*
operator|)
name|env
operator|->
name|modinfo
index|[
name|id
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|dns64_env
condition|)
return|return
literal|0
return|;
return|return
sizeof|sizeof
argument_list|(
operator|*
name|dns64_env
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * The dns64 function block.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|module_func_block
name|dns64_block
init|=
block|{
literal|"dns64"
block|,
operator|&
name|dns64_init
block|,
operator|&
name|dns64_deinit
block|,
operator|&
name|dns64_operate
block|,
operator|&
name|dns64_inform_super
block|,
operator|&
name|dns64_clear
block|,
operator|&
name|dns64_get_mem
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Function for returning the above function block.  */
end_comment

begin_function
name|struct
name|module_func_block
modifier|*
name|dns64_get_funcblock
parameter_list|()
block|{
return|return
operator|&
name|dns64_block
return|;
block|}
end_function

end_unit

