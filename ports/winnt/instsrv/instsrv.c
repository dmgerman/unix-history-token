begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  File: instsrv.c  *  Purpose: To install a new service and to insert registry entries.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__RPCASYNC_H__
end_ifndef

begin_define
define|#
directive|define
name|__RPCASYNC_H__
end_define

begin_comment
comment|/* Skip asynch rpc inclusion */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|_MSC_VER
operator|<=
literal|1800
end_if

begin_define
define|#
directive|define
name|snprintf
value|_snprintf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PERR
parameter_list|(
name|api
parameter_list|)
value|printf("\n%s: Error %d from %s on line %d",  \                          __FILE__, GetLastError(), api, __LINE__);
end_define

begin_define
define|#
directive|define
name|MSG_FOR_ACCESS_DENIED
value|"You aren't authorized to do this - please see your system Administrator"
end_define

begin_define
define|#
directive|define
name|MSG_1_FOR_BAD_PATH
value|"The fully qualified path name to the .exe must be given, and"
end_define

begin_define
define|#
directive|define
name|MSG_2_FOR_BAD_PATH
value|"  the drive letter must be for a fixed disk (e.g., not a net drive)"
end_define

begin_comment
comment|/* Building an initialised REG_MULTISZ needs a bit of care: The array must be big enough ** to hold the closing double-NUL and should have *exactly* the required size. Since the ** dependencies are fixed here, we take exactly the required 11 bytes: */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|s_acSvcDeps
index|[
literal|11
index|]
init|=
literal|"TcpIp\0Afd\0\0"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* likewise we do with the PPAS API list... */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|s_acPpsDlls
index|[
literal|30
index|]
init|=
literal|"loopback-ppsapi-provider.dll\0\0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SC_HANDLE
name|schService
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SC_HANDLE
name|schSCManager
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ok2
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|DisplayHelp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* --------------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|getServicePath
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
modifier|*
specifier|const
name|argv
parameter_list|,
specifier|const
name|int
name|argc
parameter_list|)
comment|/* MUST be>= 1 !! */
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|s_chars_to_quote
init|=
literal|" []()"
decl_stmt|;
name|size_t
name|minsize
init|=
name|argc
operator|*
literal|3
decl_stmt|;
comment|/* may need separator/NUL + quotes */
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|execPath
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
name|cbuf
decl_stmt|,
modifier|*
name|cpos
decl_stmt|;
comment|/* if just the executable and no dangerous chars, return the exe path. */
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
operator|!
name|strpbrk
argument_list|(
name|execPath
argument_list|,
name|s_chars_to_quote
argument_list|)
condition|)
return|return
name|execPath
return|;
comment|/* calculate buffer size and get the buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|minsize
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cpos
operator|=
name|cbuf
operator|=
name|malloc
argument_list|(
name|minsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|cbuf
condition|)
block|{
name|printf
argument_list|(
literal|"malloc() failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* program name must be quoted in all cases */
operator|*
name|cpos
operator|++
operator|=
literal|'"'
expr_stmt|;
name|strcpy
argument_list|(
name|cpos
argument_list|,
name|execPath
argument_list|)
expr_stmt|;
name|cpos
operator|+=
name|strlen
argument_list|(
name|cpos
argument_list|)
expr_stmt|;
operator|*
name|cpos
operator|++
operator|=
literal|'"'
expr_stmt|;
comment|/* append additional args */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|cpos
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|strpbrk
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|s_chars_to_quote
argument_list|)
condition|)
block|{
comment|/* needs quotes? */
operator|*
name|cpos
operator|++
operator|=
literal|'"'
expr_stmt|;
name|strcpy
argument_list|(
name|cpos
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cpos
operator|+=
name|strlen
argument_list|(
name|cpos
argument_list|)
expr_stmt|;
operator|*
name|cpos
operator|++
operator|=
literal|'"'
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|cpos
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cpos
operator|+=
name|strlen
argument_list|(
name|cpos
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|cpos
operator|=
literal|'\0'
expr_stmt|;
return|return
name|cbuf
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------------------------- */
end_comment

begin_function
name|BOOL
name|validateExeName
parameter_list|(
specifier|const
name|char
modifier|*
name|exePath
parameter_list|)
block|{
name|char
name|rootPath
index|[]
init|=
literal|"?:\\"
decl_stmt|;
comment|/* check for absolute path */
if|if
condition|(
operator|(
literal|':'
operator|!=
name|exePath
index|[
literal|1
index|]
operator|)
operator|||
operator|(
literal|'\\'
operator|!=
name|exePath
index|[
literal|2
index|]
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_1_FOR_BAD_PATH
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
name|MSG_2_FOR_BAD_PATH
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
define|#
directive|define
name|DRIVE_TYPE_INDETERMINATE
value|0
define|#
directive|define
name|ROOT_DIR_DOESNT_EXIST
value|1
comment|/* check drive type -- must be local HDD! */
name|rootPath
index|[
literal|0
index|]
operator|=
name|exePath
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|GetDriveTypeA
argument_list|(
name|rootPath
argument_list|)
condition|)
block|{
case|case
name|DRIVE_FIXED
case|:
comment|// OK
break|break;
case|case
name|ROOT_DIR_DOESNT_EXIST
case|:
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_1_FOR_BAD_PATH
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  the root directory where the .exe is specified to be must exist, and"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
name|MSG_2_FOR_BAD_PATH
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|DRIVE_TYPE_INDETERMINATE
case|:
case|case
name|DRIVE_REMOVABLE
case|:
case|case
name|DRIVE_REMOTE
case|:
case|case
name|DRIVE_CDROM
case|:
case|case
name|DRIVE_RAMDISK
case|:
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_1_FOR_BAD_PATH
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
name|MSG_2_FOR_BAD_PATH
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_1_FOR_BAD_PATH
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
name|MSG_2_FOR_BAD_PATH
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* check if file exists. We just drop the handle. This is a one-shot program! */
if|if
condition|(
name|INVALID_HANDLE_VALUE
operator|==
name|CreateFileA
argument_list|(
name|exePath
argument_list|,
name|GENERIC_READ
argument_list|,
name|FILE_SHARE_READ
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_1_FOR_BAD_PATH
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  the file must exist, and"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
name|MSG_2_FOR_BAD_PATH
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|InstallService
parameter_list|(
name|LPCSTR
name|serviceName
parameter_list|,
name|LPCSTR
name|displayName
parameter_list|,
name|LPCSTR
name|serviceExe
parameter_list|,
name|LPCSTR
name|servDepends
parameter_list|)
block|{
comment|/* create the service now. */
name|schService
operator|=
name|CreateServiceA
argument_list|(
name|schSCManager
argument_list|,
comment|// SCManager database
name|serviceName
argument_list|,
comment|// name of service
name|displayName
argument_list|,
comment|// name to display
name|SERVICE_ALL_ACCESS
argument_list|,
comment|// desired access
name|SERVICE_WIN32_OWN_PROCESS
argument_list|,
comment|// service type
name|SERVICE_AUTO_START
argument_list|,
comment|// start type
name|SERVICE_ERROR_NORMAL
argument_list|,
comment|// error control type
name|serviceExe
argument_list|,
comment|// service's binary
name|NULL
argument_list|,
comment|// no load ordering group
name|NULL
argument_list|,
comment|// no tag identifier
name|servDepends
argument_list|,
comment|// possible dependencies
name|NULL
argument_list|,
comment|// Local System account
name|NULL
argument_list|)
expr_stmt|;
comment|// null password
if|if
condition|(
name|NULL
operator|==
name|schService
condition|)
block|{
switch|switch
condition|(
name|GetLastError
argument_list|()
condition|)
block|{
case|case
name|ERROR_ACCESS_DENIED
case|:
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_FOR_ACCESS_DENIED
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERROR_SERVICE_EXISTS
case|:
name|printf
argument_list|(
literal|"\nThe %s service is already installed"
argument_list|,
name|serviceName
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nRemove it first if you need to re-install a new version\n"
argument_list|)
expr_stmt|;
break|break;
default|default :
name|PERR
argument_list|(
literal|"CreateService"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
name|CloseServiceHandle
argument_list|(
name|schService
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|RemoveService
parameter_list|(
name|LPCSTR
name|serviceName
parameter_list|)
block|{
block|{
define|#
directive|define
name|SZ_ENUM_BUF
value|4096
name|ENUM_SERVICE_STATUS
name|essServiceStatus
index|[
name|SZ_ENUM_BUF
index|]
decl_stmt|;
name|DWORD
name|dwBufSize
init|=
sizeof|sizeof
argument_list|(
name|essServiceStatus
argument_list|)
decl_stmt|;
name|DWORD
name|dwBytesNeeded
init|=
literal|0
decl_stmt|;
name|DWORD
name|dwServicesReturned
init|=
literal|0
decl_stmt|;
name|DWORD
name|dwResumeHandle
init|=
literal|0
decl_stmt|;
name|DWORD
name|dwI
init|=
literal|0
decl_stmt|;
name|BOOLEAN
name|bFound
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|EnumServicesStatusA
argument_list|(
name|schSCManager
argument_list|,
name|SERVICE_WIN32
argument_list|,
name|SERVICE_ACTIVE
argument_list|,
operator|(
name|LPENUM_SERVICE_STATUS
operator|)
operator|&
name|essServiceStatus
argument_list|,
name|dwBufSize
argument_list|,
operator|&
name|dwBytesNeeded
argument_list|,
operator|&
name|dwServicesReturned
argument_list|,
operator|&
name|dwResumeHandle
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|GetLastError
argument_list|()
condition|)
block|{
case|case
name|ERROR_ACCESS_DENIED
case|:
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_FOR_ACCESS_DENIED
argument_list|)
expr_stmt|;
break|break;
default|default :
name|PERR
argument_list|(
literal|"EnumServicesStatus"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
for|for
control|(
name|dwI
operator|=
literal|0
init|;
name|dwI
operator|<
name|dwServicesReturned
condition|;
operator|++
name|dwI
control|)
block|{
if|if
condition|(
literal|0
operator|==
name|_stricmp
argument_list|(
name|essServiceStatus
index|[
name|dwI
index|]
operator|.
name|lpServiceName
argument_list|,
name|serviceName
argument_list|)
condition|)
block|{
name|bFound
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bFound
condition|)
block|{
name|printf
argument_list|(
literal|"\nThe %s service cannot be removed until it has been stopped."
argument_list|,
name|serviceName
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nTo stop the %s service, use the Stop button in the Control"
argument_list|,
name|serviceName
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  Panel Services applet\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|schService
operator|=
name|OpenServiceA
argument_list|(
name|schSCManager
argument_list|,
name|serviceName
argument_list|,
name|SERVICE_ALL_ACCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|schService
condition|)
block|{
switch|switch
condition|(
name|GetLastError
argument_list|()
condition|)
block|{
case|case
name|ERROR_ACCESS_DENIED
case|:
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_FOR_ACCESS_DENIED
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERROR_SERVICE_DOES_NOT_EXIST
case|:
name|printf
argument_list|(
literal|"\nThe %s service is not installed, so cannot be removed\n"
argument_list|,
name|serviceName
argument_list|)
expr_stmt|;
break|break;
default|default :
name|PERR
argument_list|(
literal|"OpenService"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
name|DeleteService
argument_list|(
name|schService
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nDelete of Service \"Network Time Protocol\" was SUCCESSFUL\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|GetLastError
argument_list|()
condition|)
block|{
case|case
name|ERROR_ACCESS_DENIED
case|:
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_FOR_ACCESS_DENIED
argument_list|)
expr_stmt|;
break|break;
default|default :
name|PERR
argument_list|(
literal|"DeleteService"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|addSourceToRegistry
parameter_list|(
specifier|const
name|char
modifier|*
name|pszAppname
parameter_list|,
specifier|const
name|char
modifier|*
name|pszMsgDLL
parameter_list|)
block|{
name|HKEY
name|hk
decl_stmt|;
comment|/* registry key handle */
name|DWORD
name|dwData
decl_stmt|;
name|BOOL
name|bSuccess
decl_stmt|;
name|char
name|regarray
index|[
literal|200
index|]
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* When an application uses the RegisterEventSource or OpenEventLog function to get a        handle of an event log, the event logging service searches for the specified        source name in the registry. You can add a new source name to the registry by        opening a new registry subkey under the Application key and adding registry values        to the new subkey.     */
name|rc
operator|=
name|snprintf
argument_list|(
name|regarray
argument_list|,
sizeof|sizeof
argument_list|(
name|regarray
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
literal|"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\"
argument_list|,
name|pszAppname
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
operator|||
name|rc
operator|>=
sizeof|sizeof
argument_list|(
name|regarray
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"addSourceToRegistry: buffer overrun(app name)"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Create a new key for our application */
name|bSuccess
operator|=
name|RegCreateKeyA
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
name|regarray
argument_list|,
operator|&
name|hk
argument_list|)
expr_stmt|;
if|if
condition|(
name|bSuccess
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|PERR
argument_list|(
literal|"RegCreateKey"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Add the Event-ID message-file name to the subkey. */
name|bSuccess
operator|=
name|RegSetValueExA
argument_list|(
name|hk
argument_list|,
comment|/* subkey handle         */
literal|"EventMessageFile"
argument_list|,
comment|/* value name            */
literal|0
argument_list|,
comment|/* must be zero          */
name|REG_EXPAND_SZ
argument_list|,
comment|/* value type            */
operator|(
name|LPBYTE
operator|)
name|pszMsgDLL
argument_list|,
comment|/* address of value data */
call|(
name|DWORD
call|)
argument_list|(
name|strlen
argument_list|(
name|pszMsgDLL
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* length of value data  */
if|if
condition|(
name|bSuccess
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|PERR
argument_list|(
literal|"RegSetValueEx"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Set the supported types flags and addit to the subkey. */
name|dwData
operator|=
name|EVENTLOG_ERROR_TYPE
operator||
name|EVENTLOG_WARNING_TYPE
operator||
name|EVENTLOG_INFORMATION_TYPE
expr_stmt|;
name|bSuccess
operator|=
name|RegSetValueExA
argument_list|(
name|hk
argument_list|,
comment|/* subkey handle                */
literal|"TypesSupported"
argument_list|,
comment|/* value name                   */
literal|0
argument_list|,
comment|/* must be zero                 */
name|REG_DWORD
argument_list|,
comment|/* value type                   */
operator|(
name|LPBYTE
operator|)
operator|&
name|dwData
argument_list|,
comment|/* address of value data        */
sizeof|sizeof
argument_list|(
name|DWORD
argument_list|)
argument_list|)
expr_stmt|;
comment|/* length of value data         */
if|if
condition|(
name|bSuccess
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|PERR
argument_list|(
literal|"RegSetValueEx"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|RegCloseKey
argument_list|(
name|hk
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|addKeysToRegistry
parameter_list|(
name|void
parameter_list|)
block|{
name|HKEY
name|hk
decl_stmt|;
comment|/* registry key handle */
name|BOOL
name|bSuccess
decl_stmt|;
comment|/* now add the depends on service key */
comment|/* Create a new key for our application */
name|bSuccess
operator|=
name|RegCreateKeyA
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
literal|"SYSTEM\\CurrentControlSet\\Services\\NTP"
argument_list|,
operator|&
name|hk
argument_list|)
expr_stmt|;
if|if
condition|(
name|bSuccess
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|PERR
argument_list|(
literal|"RegCreateKey"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|bSuccess
operator|=
name|RegSetValueExA
argument_list|(
name|hk
argument_list|,
comment|/* subkey handle         */
literal|"PPSProviders"
argument_list|,
comment|/* value name            */
literal|0
argument_list|,
comment|/* must be zero          */
name|REG_MULTI_SZ
argument_list|,
comment|/* value type            */
operator|(
name|LPBYTE
operator|)
name|s_acPpsDlls
argument_list|,
comment|/* address of value data */
operator|(
name|DWORD
operator|)
sizeof|sizeof
argument_list|(
name|s_acPpsDlls
argument_list|)
argument_list|)
expr_stmt|;
comment|/* length of value data  */
if|if
condition|(
name|bSuccess
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|PERR
argument_list|(
literal|"RegSetValueEx"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|RegCloseKey
argument_list|(
name|hk
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|szServiceName
init|=
literal|"NTP"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|szDisplayName
init|=
literal|"Network Time Protocol"
decl_stmt|;
name|BOOL
name|bRemovingService
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
comment|// check if Win32s, if so, display notice and terminate
if|if
condition|(
name|GetVersion
argument_list|()
operator|&
literal|0x80000000
condition|)
block|{
name|MessageBoxA
argument_list|(
name|NULL
argument_list|,
literal|"This application cannot run on Windows 3.1.\n"
literal|"This application will now terminate."
argument_list|,
literal|"NAMED"
argument_list|,
name|MB_OK
operator||
name|MB_ICONSTOP
operator||
name|MB_SETFOREGROUND
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|argc
operator|>=
literal|2
condition|)
name|bRemovingService
operator|=
operator|(
operator|!
name|stricmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"remove"
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bRemovingService
operator|&&
name|argc
operator|!=
literal|2
operator|)
operator|||
operator|(
operator|!
name|bRemovingService
operator|&&
name|argc
operator|<
literal|2
operator|)
condition|)
block|{
name|DisplayHelp
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|bRemovingService
condition|)
block|{
name|p
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
literal|'/'
operator|==
operator|*
name|p
operator|)
operator|||
operator|(
literal|'-'
operator|==
operator|*
name|p
operator|)
operator|||
name|validateExeName
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|DisplayHelp
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|>
literal|256
condition|)
block|{
name|printf
argument_list|(
literal|"\nThe service name cannot be longer than 256 characters\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|schSCManager
operator|=
name|OpenSCManagerA
argument_list|(
name|NULL
argument_list|,
comment|// machine (NULL == local)
name|NULL
argument_list|,
comment|// database (NULL == default)
name|SC_MANAGER_ALL_ACCESS
argument_list|)
expr_stmt|;
comment|// access required
if|if
condition|(
name|NULL
operator|==
name|schSCManager
condition|)
block|{
switch|switch
condition|(
name|GetLastError
argument_list|()
condition|)
block|{
case|case
name|ERROR_ACCESS_DENIED
case|:
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_FOR_ACCESS_DENIED
argument_list|)
expr_stmt|;
break|break;
default|default :
name|PERR
argument_list|(
literal|"OpenSCManager"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bRemovingService
condition|)
name|ok
operator|=
name|RemoveService
argument_list|(
name|szServiceName
argument_list|)
expr_stmt|;
else|else
name|ok
operator|=
name|InstallService
argument_list|(
name|szServiceName
argument_list|,
name|szDisplayName
argument_list|,
name|getServicePath
argument_list|(
name|argv
operator|+
literal|1
argument_list|,
name|argc
operator|-
literal|1
argument_list|)
argument_list|,
name|s_acSvcDeps
argument_list|)
expr_stmt|;
name|CloseServiceHandle
argument_list|(
name|schSCManager
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bRemovingService
condition|)
block|{
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
name|ok
operator|=
name|addSourceToRegistry
argument_list|(
literal|"NTP"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Set the Event-ID message-file name. */
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
name|ok
operator|=
name|addKeysToRegistry
argument_list|()
expr_stmt|;
comment|/* add other stuff */
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
block|{
specifier|static
specifier|const
name|char
name|s_msg
index|[]
init|=
literal|"\nThe \"Network Time Protocol\" service was successfully created.\n"
literal|"\nDon't forget!!! You must now go to the Control Panel and"
literal|"\n  use the Services applet to change the account name and"
literal|"\n  password that the NTP Service will use when"
literal|"\n  it starts."
literal|"\nTo do this: use the Startup button in the Services applet,"
literal|"\n  and (for example) specify the desired account and"
literal|"\n  correct password."
literal|"\nAlso, use the Services applet to ensure this newly installed"
literal|"\n  service starts automatically on bootup.\n"
decl_stmt|;
name|fputs
argument_list|(
name|s_msg
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------------------------- */
end_comment

begin_function
name|void
name|DisplayHelp
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|s_hlpmsg
index|[]
init|=
literal|"Installs or removes the NTP service.\n"
literal|"To install the NTP service,\n"
literal|"type INSTSRV<path> [args]\n"
literal|"Where:\n"
literal|"    path    Absolute path to the NTP service. (ntpd.exe)  You must\n"
literal|"            use a fully qualified path and the drive letter must be for a\n"
literal|"            fixed, local drive.\n\n"
literal|"    args    Additional command line arguments for the service\n"
literal|"For example, INSTSRV i:\\winnt\\system32\\ntpd.exe\n"
literal|"To remove the NTP service,\n"
literal|"type INSTSRV remove \n"
decl_stmt|;
name|fputs
argument_list|(
name|s_hlpmsg
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EOF */
end_comment

end_unit

