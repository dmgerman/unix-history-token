begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  File: instsrv.c  *  Purpose: To install a new service and to insert registry entries.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__RPCASYNC_H__
end_ifndef

begin_define
define|#
directive|define
name|__RPCASYNC_H__
end_define

begin_comment
comment|/* Skip asynch rpc inclusion */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|PERR
parameter_list|(
name|api
parameter_list|)
value|printf("\n%s: Error %d from %s on line %d",  \     __FILE__, GetLastError(), api, __LINE__);
end_define

begin_define
define|#
directive|define
name|MSG_FOR_ACCESS_DENIED
value|"You aren't authorized to do this - please see your system Administrator"
end_define

begin_define
define|#
directive|define
name|MSG_1_FOR_BAD_PATH
value|"The fully qualified path name to the .exe must be given, and"
end_define

begin_define
define|#
directive|define
name|MSG_2_FOR_BAD_PATH
value|"  the drive letter must be for a fixed disk (e.g., not a net drive)"
end_define

begin_decl_stmt
name|SC_HANDLE
name|schService
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SC_HANDLE
name|schSCManager
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ok2
decl_stmt|;
end_decl_stmt

begin_function_decl
name|VOID
name|DisplayHelp
parameter_list|(
name|VOID
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* --------------------------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|InstallService
parameter_list|(
name|LPCTSTR
name|serviceName
parameter_list|,
name|LPCTSTR
name|displayName
parameter_list|,
name|LPCTSTR
name|serviceExe
parameter_list|)
block|{
name|LPCTSTR
name|lpszBinaryPathName
init|=
name|serviceExe
decl_stmt|;
name|TCHAR
name|lpszRootPathName
index|[]
init|=
literal|"?:\\"
decl_stmt|;
if|if
condition|(
operator|(
literal|':'
operator|!=
operator|*
operator|(
name|lpszBinaryPathName
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
literal|'\\'
operator|!=
operator|*
operator|(
name|lpszBinaryPathName
operator|+
literal|2
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_1_FOR_BAD_PATH
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
name|MSG_2_FOR_BAD_PATH
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
define|#
directive|define
name|DRIVE_TYPE_INDETERMINATE
value|0
define|#
directive|define
name|ROOT_DIR_DOESNT_EXIST
value|1
operator|*
name|lpszRootPathName
operator|=
operator|*
operator|(
name|lpszBinaryPathName
operator|+
literal|0
operator|)
expr_stmt|;
switch|switch
condition|(
name|GetDriveType
argument_list|(
name|lpszRootPathName
argument_list|)
condition|)
block|{
case|case
name|DRIVE_FIXED
case|:
block|{
comment|// OK
break|break;
block|}
case|case
name|ROOT_DIR_DOESNT_EXIST
case|:
block|{
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_1_FOR_BAD_PATH
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  the root directory where the .exe is specified to be must exist, and"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
name|MSG_2_FOR_BAD_PATH
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|DRIVE_TYPE_INDETERMINATE
case|:
case|case
name|DRIVE_REMOVABLE
case|:
case|case
name|DRIVE_REMOTE
case|:
case|case
name|DRIVE_CDROM
case|:
case|case
name|DRIVE_RAMDISK
case|:
block|{
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_1_FOR_BAD_PATH
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
name|MSG_2_FOR_BAD_PATH
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
default|default :
block|{
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_1_FOR_BAD_PATH
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
name|MSG_2_FOR_BAD_PATH
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|INVALID_HANDLE_VALUE
operator|==
name|CreateFile
argument_list|(
name|lpszBinaryPathName
argument_list|,
name|GENERIC_READ
argument_list|,
name|FILE_SHARE_READ
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_1_FOR_BAD_PATH
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  the file must exist, and"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
name|MSG_2_FOR_BAD_PATH
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|schService
operator|=
name|CreateService
argument_list|(
name|schSCManager
argument_list|,
comment|// SCManager database
name|serviceName
argument_list|,
comment|// name of service
name|displayName
argument_list|,
comment|// name to display
name|SERVICE_ALL_ACCESS
argument_list|,
comment|// desired access
name|SERVICE_WIN32_OWN_PROCESS
argument_list|,
comment|// service type
name|SERVICE_AUTO_START
argument_list|,
comment|// start type
name|SERVICE_ERROR_NORMAL
argument_list|,
comment|// error control type
name|lpszBinaryPathName
argument_list|,
comment|// service's binary
name|NULL
argument_list|,
comment|// no load ordering group
name|NULL
argument_list|,
comment|// no tag identifier
name|NULL
argument_list|,
comment|// no dependencies
name|NULL
argument_list|,
comment|// Local System account
name|NULL
argument_list|)
expr_stmt|;
comment|// null password
if|if
condition|(
name|NULL
operator|==
name|schService
condition|)
block|{
switch|switch
condition|(
name|GetLastError
argument_list|()
condition|)
block|{
case|case
name|ERROR_ACCESS_DENIED
case|:
block|{
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_FOR_ACCESS_DENIED
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ERROR_SERVICE_EXISTS
case|:
block|{
name|printf
argument_list|(
literal|"\nThe %s service is already installed"
argument_list|,
name|serviceName
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nRemove it first if you need to re-install a new version\n"
argument_list|)
expr_stmt|;
break|break;
block|}
default|default :
block|{
name|PERR
argument_list|(
literal|"CreateService"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
else|else
name|CloseServiceHandle
argument_list|(
name|schService
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|RemoveService
parameter_list|(
name|LPCTSTR
name|serviceName
parameter_list|)
block|{
block|{
define|#
directive|define
name|SZ_ENUM_BUF
value|4096
name|ENUM_SERVICE_STATUS
name|essServiceStatus
index|[
name|SZ_ENUM_BUF
index|]
decl_stmt|;
name|DWORD
name|dwBufSize
init|=
sizeof|sizeof
argument_list|(
name|essServiceStatus
argument_list|)
decl_stmt|;
name|DWORD
name|dwBytesNeeded
init|=
literal|0
decl_stmt|;
name|DWORD
name|dwServicesReturned
init|=
literal|0
decl_stmt|;
name|DWORD
name|dwResumeHandle
init|=
literal|0
decl_stmt|;
name|DWORD
name|dwI
init|=
literal|0
decl_stmt|;
name|BOOLEAN
name|bFound
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|EnumServicesStatus
argument_list|(
name|schSCManager
argument_list|,
name|SERVICE_WIN32
argument_list|,
name|SERVICE_ACTIVE
argument_list|,
operator|(
name|LPENUM_SERVICE_STATUS
operator|)
operator|&
name|essServiceStatus
argument_list|,
name|dwBufSize
argument_list|,
operator|&
name|dwBytesNeeded
argument_list|,
operator|&
name|dwServicesReturned
argument_list|,
operator|&
name|dwResumeHandle
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|GetLastError
argument_list|()
condition|)
block|{
case|case
name|ERROR_ACCESS_DENIED
case|:
block|{
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_FOR_ACCESS_DENIED
argument_list|)
expr_stmt|;
break|break;
block|}
default|default :
block|{
name|PERR
argument_list|(
literal|"EnumServicesStatus"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
for|for
control|(
name|dwI
operator|=
literal|0
init|;
name|dwI
operator|<
name|dwServicesReturned
condition|;
name|dwI
operator|++
control|)
block|{
if|if
condition|(
literal|0
operator|==
name|_stricmp
argument_list|(
name|essServiceStatus
index|[
name|dwI
index|]
operator|.
name|lpServiceName
argument_list|,
name|serviceName
argument_list|)
condition|)
block|{
name|bFound
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bFound
condition|)
block|{
name|printf
argument_list|(
literal|"\nThe %s service cannot be removed until it has been stopped."
argument_list|,
name|serviceName
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nTo stop the %s service, use the Stop button in the Control"
argument_list|,
name|serviceName
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  Panel Services applet\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|schService
operator|=
name|OpenService
argument_list|(
name|schSCManager
argument_list|,
name|serviceName
argument_list|,
name|SERVICE_ALL_ACCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|schService
condition|)
block|{
switch|switch
condition|(
name|GetLastError
argument_list|()
condition|)
block|{
case|case
name|ERROR_ACCESS_DENIED
case|:
block|{
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_FOR_ACCESS_DENIED
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ERROR_SERVICE_DOES_NOT_EXIST
case|:
block|{
name|printf
argument_list|(
literal|"\nThe %s service is not installed, so cannot be removed\n"
argument_list|,
name|serviceName
argument_list|)
expr_stmt|;
break|break;
block|}
default|default :
block|{
name|PERR
argument_list|(
literal|"OpenService"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
name|DeleteService
argument_list|(
name|schService
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nDelete of Service \"Network Time Protocol\" was SUCCESSFUL\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|GetLastError
argument_list|()
condition|)
block|{
case|case
name|ERROR_ACCESS_DENIED
case|:
block|{
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_FOR_ACCESS_DENIED
argument_list|)
expr_stmt|;
break|break;
block|}
default|default :
block|{
name|PERR
argument_list|(
literal|"DeleteService"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|addSourceToRegistry
parameter_list|(
name|LPSTR
name|pszAppname
parameter_list|,
name|LPSTR
name|pszMsgDLL
parameter_list|)
block|{
name|HKEY
name|hk
decl_stmt|;
comment|/* registry key handle */
name|DWORD
name|dwData
decl_stmt|;
name|BOOL
name|bSuccess
decl_stmt|;
name|char
name|regarray
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|lpregarray
init|=
name|regarray
decl_stmt|;
comment|/* When an application uses the RegisterEventSource or OpenEventLog      function to get a handle of an event log, the event loggging service      searches for the specified source name in the registry. You can add a      new source name to the registry by opening a new registry subkey      under the Application key and adding registry values to the new      subkey. */
name|strcpy
argument_list|(
name|lpregarray
argument_list|,
literal|"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|lpregarray
argument_list|,
name|pszAppname
argument_list|)
expr_stmt|;
comment|/* Create a new key for our application */
name|bSuccess
operator|=
name|RegCreateKey
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
name|lpregarray
argument_list|,
operator|&
name|hk
argument_list|)
expr_stmt|;
if|if
condition|(
name|bSuccess
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|PERR
argument_list|(
literal|"RegCreateKey"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Add the Event-ID message-file name to the subkey. */
name|bSuccess
operator|=
name|RegSetValueEx
argument_list|(
name|hk
argument_list|,
comment|/* subkey handle         */
literal|"EventMessageFile"
argument_list|,
comment|/* value name            */
literal|0
argument_list|,
comment|/* must be zero          */
name|REG_EXPAND_SZ
argument_list|,
comment|/* value type            */
operator|(
name|LPBYTE
operator|)
name|pszMsgDLL
argument_list|,
comment|/* address of value data */
call|(
name|DWORD
call|)
argument_list|(
name|strlen
argument_list|(
name|pszMsgDLL
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* length of value data  */
if|if
condition|(
name|bSuccess
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|PERR
argument_list|(
literal|"RegSetValueEx"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Set the supported types flags and addit to the subkey. */
name|dwData
operator|=
name|EVENTLOG_ERROR_TYPE
operator||
name|EVENTLOG_WARNING_TYPE
operator||
name|EVENTLOG_INFORMATION_TYPE
expr_stmt|;
name|bSuccess
operator|=
name|RegSetValueEx
argument_list|(
name|hk
argument_list|,
comment|/* subkey handle                */
literal|"TypesSupported"
argument_list|,
comment|/* value name                   */
literal|0
argument_list|,
comment|/* must be zero                 */
name|REG_DWORD
argument_list|,
comment|/* value type                   */
operator|(
name|LPBYTE
operator|)
operator|&
name|dwData
argument_list|,
comment|/* address of value data        */
sizeof|sizeof
argument_list|(
name|DWORD
argument_list|)
argument_list|)
expr_stmt|;
comment|/* length of value data         */
if|if
condition|(
name|bSuccess
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|PERR
argument_list|(
literal|"RegSetValueEx"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|RegCloseKey
argument_list|(
name|hk
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|addKeysToRegistry
parameter_list|()
block|{
name|HKEY
name|hk
decl_stmt|;
comment|/* registry key handle */
name|BOOL
name|bSuccess
decl_stmt|;
name|char
name|myarray
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|lpmyarray
init|=
name|myarray
decl_stmt|;
name|int
name|arsize
init|=
literal|0
decl_stmt|;
comment|/* now add the depends on service key */
comment|/* Create a new key for our application */
name|bSuccess
operator|=
name|RegCreateKey
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
literal|"SYSTEM\\CurrentControlSet\\Services\\NTP"
argument_list|,
operator|&
name|hk
argument_list|)
expr_stmt|;
if|if
condition|(
name|bSuccess
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|PERR
argument_list|(
literal|"RegCreateKey"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|strcpy
argument_list|(
name|lpmyarray
argument_list|,
literal|"TcpIp"
argument_list|)
expr_stmt|;
name|lpmyarray
operator|=
name|lpmyarray
operator|+
literal|6
expr_stmt|;
name|arsize
operator|=
name|arsize
operator|+
literal|6
expr_stmt|;
name|strcpy
argument_list|(
name|lpmyarray
argument_list|,
literal|"Afd"
argument_list|)
expr_stmt|;
name|lpmyarray
operator|=
name|lpmyarray
operator|+
literal|4
expr_stmt|;
name|arsize
operator|=
name|arsize
operator|+
literal|4
expr_stmt|;
name|arsize
operator|=
name|arsize
operator|+
literal|2
expr_stmt|;
name|strcpy
argument_list|(
name|lpmyarray
argument_list|,
literal|"\0\0"
argument_list|)
expr_stmt|;
name|bSuccess
operator|=
name|RegSetValueEx
argument_list|(
name|hk
argument_list|,
comment|/* subkey handle         */
literal|"DependOnService"
argument_list|,
comment|/* value name            */
literal|0
argument_list|,
comment|/* must be zero          */
name|REG_MULTI_SZ
argument_list|,
comment|/* value type            */
operator|(
name|LPBYTE
operator|)
operator|&
name|myarray
argument_list|,
comment|/* address of value data */
name|arsize
argument_list|)
expr_stmt|;
comment|/* length of value data  */
if|if
condition|(
name|bSuccess
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|PERR
argument_list|(
literal|"RegSetValueEx"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|RegCloseKey
argument_list|(
name|hk
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
define|#
directive|define
name|SZ_NAME_BUF
value|270
comment|// 256 is max, add a little
name|UCHAR
name|ucNameBuf
index|[
name|SZ_NAME_BUF
index|]
init|=
literal|"NTP"
decl_stmt|;
name|LPTSTR
name|lpszServName
init|=
operator|(
name|LPTSTR
operator|)
operator|&
name|ucNameBuf
decl_stmt|;
name|UCHAR
name|ucDNameBuf
index|[
name|SZ_NAME_BUF
index|]
init|=
literal|"Network Time Protocol"
decl_stmt|;
name|LPTSTR
name|lpszDispName
init|=
operator|(
name|LPTSTR
operator|)
operator|&
name|ucDNameBuf
decl_stmt|;
name|UCHAR
name|ucExeNBuf
index|[
name|SZ_NAME_BUF
index|]
init|=
literal|""
decl_stmt|;
name|LPTSTR
name|lpszExeName
init|=
operator|(
name|LPTSTR
operator|)
operator|&
name|ucExeNBuf
decl_stmt|;
name|BOOL
name|bRemovingService
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
comment|// check if Win32s, if so, display notice and terminate
if|if
condition|(
name|GetVersion
argument_list|()
operator|&
literal|0x80000000
condition|)
block|{
name|MessageBox
argument_list|(
name|NULL
argument_list|,
literal|"This application cannot run on Windows 3.1.\n"
literal|"This application will now terminate."
argument_list|,
literal|"NAMED"
argument_list|,
name|MB_OK
operator||
name|MB_ICONSTOP
operator||
name|MB_SETFOREGROUND
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
name|bRemovingService
operator|=
operator|(
operator|!
name|stricmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"remove"
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bRemovingService
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|DisplayHelp
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|p
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
literal|'/'
operator|==
operator|*
name|p
operator|)
operator|||
operator|(
literal|'-'
operator|==
operator|*
name|p
operator|)
condition|)
block|{
name|DisplayHelp
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|>
literal|256
condition|)
block|{
name|printf
argument_list|(
literal|"\nThe service name cannot be longer than 256 characters\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bRemovingService
operator|=
operator|(
operator|!
name|stricmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"remove"
argument_list|)
operator|)
expr_stmt|;
name|schSCManager
operator|=
name|OpenSCManager
argument_list|(
name|NULL
argument_list|,
comment|// machine (NULL == local)
name|NULL
argument_list|,
comment|// database (NULL == default)
name|SC_MANAGER_ALL_ACCESS
argument_list|)
expr_stmt|;
comment|// access required
if|if
condition|(
name|NULL
operator|==
name|schSCManager
condition|)
block|{
switch|switch
condition|(
name|GetLastError
argument_list|()
condition|)
block|{
case|case
name|ERROR_ACCESS_DENIED
case|:
block|{
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|MSG_FOR_ACCESS_DENIED
argument_list|)
expr_stmt|;
break|break;
block|}
default|default :
block|{
name|PERR
argument_list|(
literal|"OpenSCManager"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|bRemovingService
condition|)
block|{
name|ok
operator|=
name|RemoveService
argument_list|(
name|lpszServName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* get the exe name */
name|strcpy
argument_list|(
name|lpszExeName
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ok
operator|=
name|InstallService
argument_list|(
name|lpszServName
argument_list|,
name|lpszDispName
argument_list|,
name|lpszExeName
argument_list|)
expr_stmt|;
block|}
name|CloseServiceHandle
argument_list|(
name|schSCManager
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bRemovingService
condition|)
block|{
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
block|{
comment|/* Set the Event-ID message-file name. */
name|ok
operator|=
name|addSourceToRegistry
argument_list|(
literal|"NTP"
argument_list|,
name|lpszExeName
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
name|ok
operator|=
name|addKeysToRegistry
argument_list|()
expr_stmt|;
else|else
return|return
name|ok
return|;
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\nThe \"Network Time Protocol\" service was successfully created.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nDon't forget!!! You must now go to the Control Panel and"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  use the Services applet to change the account name and"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  password that the NTP Service will use when"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  it starts."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nTo do this: use the Startup button in the Services applet,"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  and (for example) specify the desired account and"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  correct password."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nAlso, use the Services applet to ensure this newly installed"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  service starts automatically on bootup.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
return|return
name|ok
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------------------------- */
end_comment

begin_function
name|VOID
name|DisplayHelp
parameter_list|(
name|VOID
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Installs or removes the NTP service.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"To install the NTP service,\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"type INSTSRV<path> \n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Where:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    path    Absolute path to the NTP service, name.exe.  You must\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"            use a fully qualified path and the drive letter must be for a\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"            fixed, local drive.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"For example, INSTSRV i:\\winnt\\system32\\ntpd.exe\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"To remove the NTP service,\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"type INSTSRV remove \n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EOF */
end_comment

end_unit

