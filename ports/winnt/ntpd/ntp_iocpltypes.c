begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_iocpltypes.c - data structures for overlapped IO  *  * Written by Juergen Perlinger (perlinger@ntp.org) for the NTP project.  * The contents of 'html/copyright.html' apply.  *  * --------------------------------------------------------------------  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_iocplmem.h"
end_include

begin_include
include|#
directive|include
file|"ntp_iocpltypes.h"
end_include

begin_comment
comment|/* * ==================================================================== * Shared lock manipulation * ==================================================================== */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------  * Create new shared lock node. The shared lock is returned with a  * refcount of 1, so the caller owns this immediately. The internal  * lock is NOT aquired, and all IO handles or FDs are set to an  * invalid value.  */
end_comment

begin_function
name|SharedLock_t
modifier|*
name|__fastcall
name|slCreate
parameter_list|(
name|void
modifier|*
name|src
parameter_list|)
block|{
name|SharedLock_t
modifier|*
name|retv
decl_stmt|;
name|retv
operator|=
name|IOCPLPoolAlloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SharedLock_t
argument_list|)
argument_list|,
literal|"Lock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|!=
name|NULL
condition|)
block|{
name|InitializeCriticalSection
argument_list|(
name|retv
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|retv
operator|->
name|refc_count
operator|=
literal|1
expr_stmt|;
name|retv
operator|->
name|rsrc
operator|.
name|any
operator|=
name|src
expr_stmt|;
name|retv
operator|->
name|handles
index|[
literal|0
index|]
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|retv
operator|->
name|handles
index|[
literal|1
index|]
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|retv
operator|->
name|riofd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|retv
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Attach to a lock. This just increments the use count, but does not  * aquire the internal lock. Return a pointer to the lock.  */
end_comment

begin_function
name|SharedLock_t
modifier|*
name|__fastcall
name|slAttach
parameter_list|(
name|SharedLock_t
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
name|InterlockedIncrement
argument_list|(
operator|&
name|lp
operator|->
name|refc_count
argument_list|)
expr_stmt|;
return|return
name|lp
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Detach from a shared lock. If the use count drops to zero, the lock  * is destroyed and released.  * Alwys return NULL.  *  * THE CALLER MUST NOT OWN THE INTERNAL LOCK WHEN DOING THIS!  */
end_comment

begin_function
name|SharedLock_t
modifier|*
name|__fastcall
name|slDetach
parameter_list|(
name|SharedLock_t
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
name|lp
operator|!=
name|NULL
operator|&&
operator|!
name|InterlockedDecrement
argument_list|(
operator|&
name|lp
operator|->
name|refc_count
argument_list|)
condition|)
block|{
name|DeleteCriticalSection
argument_list|(
name|lp
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|lp
argument_list|,
literal|0xFF
argument_list|,
sizeof|sizeof
argument_list|(
name|SharedLock_t
argument_list|)
argument_list|)
expr_stmt|;
name|IOCPLPoolFree
argument_list|(
name|lp
argument_list|,
literal|"Lock"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Attach and aquire the lock for READ access. (This might block)  */
end_comment

begin_function
name|SharedLock_t
modifier|*
name|__fastcall
name|slAttachShared
parameter_list|(
name|SharedLock_t
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|!=
operator|(
name|lp
operator|=
name|slAttach
argument_list|(
name|lp
argument_list|)
operator|)
condition|)
name|EnterCriticalSection
argument_list|(
name|lp
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|lp
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Release the READ lock and detach from shared lock.  * Alwys returns NULL.  *  * THE CALLER MUST OWN THE READ LOCK WHEN DOING THIS.  */
end_comment

begin_function
name|SharedLock_t
modifier|*
name|__fastcall
name|slDetachShared
parameter_list|(
name|SharedLock_t
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
name|LeaveCriticalSection
argument_list|(
name|lp
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|slDetach
argument_list|(
name|lp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Attach and aquire the lock for WRITE access. (This might block)  */
end_comment

begin_function
name|SharedLock_t
modifier|*
name|__fastcall
name|slAttachExclusive
parameter_list|(
name|SharedLock_t
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|!=
operator|(
name|lp
operator|=
name|slAttach
argument_list|(
name|lp
argument_list|)
operator|)
condition|)
name|EnterCriticalSection
argument_list|(
name|lp
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|lp
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Release the WRITE lock and detach from shared lock.  * Alwys returns NULL.  *  * THE CALLER MUST OWN THE WRITE LOCK WHEN DOING THIS.  */
end_comment

begin_function
name|SharedLock_t
modifier|*
name|__fastcall
name|slDetachExclusive
parameter_list|(
name|SharedLock_t
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
name|LeaveCriticalSection
argument_list|(
name|lp
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|slDetach
argument_list|(
name|lp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Predicate function: Is there an attached RIO, and is the RIO in  * active state?  */
end_comment

begin_function
name|BOOL
name|__fastcall
name|slRefClockOK
parameter_list|(
specifier|const
name|SharedLock_t
modifier|*
name|lp
parameter_list|)
block|{
return|return
name|lp
operator|->
name|rsrc
operator|.
name|rio
operator|&&
name|lp
operator|->
name|rsrc
operator|.
name|rio
operator|->
name|active
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Predicate function: Is there an attached interface, and is the  * interface accepting packets?  */
end_comment

begin_function
name|BOOL
name|__fastcall
name|slEndPointOK
parameter_list|(
specifier|const
name|SharedLock_t
modifier|*
name|lp
parameter_list|)
block|{
return|return
name|lp
operator|->
name|rsrc
operator|.
name|ept
operator|&&
operator|!
name|lp
operator|->
name|rsrc
operator|.
name|ept
operator|->
name|ignore_packets
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Enqueue a receive buffer under lock guard, but only if the shared  * lock is still active and a given predicate function holds.  *  * Returns TRUE if buffer was queued, FALSE in all other cases.  *  * !!NOTE!! The buffer is consumed by this call IN ANY CASE,  * independent of the function result!  */
end_comment

begin_function
name|BOOL
name|slQueueLocked
parameter_list|(
name|SharedLock_t
modifier|*
name|lp
parameter_list|,
name|LockPredicateT
name|pred
parameter_list|,
name|recvbuf_t
modifier|*
name|buf
parameter_list|)
block|{
name|BOOL
name|done
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|slAttachShared
argument_list|(
name|lp
argument_list|)
condition|)
block|{
name|done
operator|=
call|(
modifier|*
name|pred
call|)
argument_list|(
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
name|add_full_recv_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|slDetachShared
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|done
condition|)
name|SetEvent
argument_list|(
name|WaitableIoEventHandle
argument_list|)
expr_stmt|;
else|else
name|freerecvbuf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|done
return|;
block|}
end_function

begin_comment
comment|/* ====================================================================  * Alloc& Free of Device context  * ====================================================================  */
end_comment

begin_comment
comment|/* !NOTE! The returned context is already owned by the caller! */
end_comment

begin_function
name|DevCtx_t
modifier|*
name|__fastcall
name|DevCtxAlloc
parameter_list|(
name|void
parameter_list|)
block|{
name|DevCtx_t
modifier|*
name|devCtx
decl_stmt|;
name|u_long
name|slot
decl_stmt|;
comment|/* allocate struct and tag all slots as invalid */
name|devCtx
operator|=
operator|(
name|DevCtx_t
operator|*
operator|)
name|IOCPLPoolAlloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DevCtx_t
argument_list|)
argument_list|,
literal|"DEV ctx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|devCtx
operator|!=
name|NULL
condition|)
block|{
comment|/* The initial COV values make sure there is no busy 		* loop on unused/empty slots. 		*/
name|devCtx
operator|->
name|cov_count
operator|=
literal|1
expr_stmt|;
comment|/* already owned! */
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|PPS_QUEUE_LEN
condition|;
name|slot
operator|++
control|)
name|devCtx
operator|->
name|pps_buff
index|[
name|slot
index|]
operator|.
name|cov_count
operator|=
operator|~
name|slot
expr_stmt|;
block|}
return|return
name|devCtx
return|;
block|}
end_function

begin_function
name|DevCtx_t
modifier|*
name|__fastcall
name|DevCtxAttach
parameter_list|(
name|DevCtx_t
modifier|*
name|devCtx
parameter_list|)
block|{
if|if
condition|(
name|devCtx
operator|!=
name|NULL
condition|)
name|InterlockedIncrement
argument_list|(
operator|&
name|devCtx
operator|->
name|ref_count
argument_list|)
expr_stmt|;
return|return
name|devCtx
return|;
block|}
end_function

begin_function
name|DevCtx_t
modifier|*
name|__fastcall
name|DevCtxDetach
parameter_list|(
name|DevCtx_t
modifier|*
name|devCtx
parameter_list|)
block|{
if|if
condition|(
name|devCtx
operator|&&
operator|!
name|InterlockedDecrement
argument_list|(
operator|&
name|devCtx
operator|->
name|ref_count
argument_list|)
condition|)
name|IOCPLPoolFree
argument_list|(
name|devCtx
argument_list|,
literal|"DEV ctx"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ====================================================================  * Alloc& Free of I/O context  * ====================================================================  */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------  * Allocate a new IO transfer context node and attach it to the lock  * and device context given. (Either or both may be NULL.)  * Returns new node, or NULL on error.  */
end_comment

begin_function
name|IoCtx_t
modifier|*
name|__fastcall
name|IoCtxAlloc
parameter_list|(
name|SharedLock_t
modifier|*
name|lock
parameter_list|,
name|DevCtx_t
modifier|*
name|devCtx
parameter_list|)
block|{
name|IoCtx_t
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
operator|(
name|IoCtx_t
operator|*
operator|)
name|IOCPLPoolAlloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IoCtx_t
argument_list|)
argument_list|,
literal|"IO ctx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|!=
name|NULL
condition|)
block|{
name|ctx
operator|->
name|slock
operator|=
name|slAttach
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|devCtx
operator|=
name|DevCtxAttach
argument_list|(
name|devCtx
argument_list|)
expr_stmt|;
block|}
return|return
name|ctx
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Free an IO transfer context node after detaching it from lock and  * device context.  *  * This does *NOT* free any attache data buffers! Use 'IoCtxRelease()'  * for dropping the node and attached buffers.  */
end_comment

begin_function
name|void
name|__fastcall
name|IoCtxFree
parameter_list|(
name|IoCtx_t
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
condition|)
block|{
name|ctx
operator|->
name|slock
operator|=
name|slDetach
argument_list|(
name|ctx
operator|->
name|slock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|devCtx
operator|=
name|DevCtxDetach
argument_list|(
name|ctx
operator|->
name|devCtx
argument_list|)
expr_stmt|;
name|IOCPLPoolFree
argument_list|(
name|ctx
argument_list|,
literal|"IO ctx"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Free an IO transfer context node after detaching it from lock and  * device context.  *  * Also disposes of any attached data buffers -- the buffer pointers  * should either be a valid reference or NULL.  */
end_comment

begin_function
name|void
name|__fastcall
name|IoCtxRelease
parameter_list|(
name|IoCtx_t
modifier|*
name|ctx
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|dmsg
init|=
literal|"overlapped IO data buffer"
decl_stmt|;
if|if
condition|(
name|ctx
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|flRawMem
condition|)
name|IOCPLPoolFree
argument_list|(
name|ctx
operator|->
name|trans_buf
argument_list|,
name|dmsg
argument_list|)
expr_stmt|;
else|else
name|freerecvbuf
argument_list|(
name|ctx
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
name|IoCtxFree
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Check if any source is attached to shared lock associated with  * this context node.  *  * UNGUARDED -- ONLY CALL UNDER LOCK.  */
end_comment

begin_function
name|BOOL
name|__fastcall
name|IoCtxAlive
parameter_list|(
name|IoCtx_t
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|ctx
operator|&&
name|ctx
operator|->
name|slock
operator|&&
name|ctx
operator|->
name|slock
operator|->
name|rsrc
operator|.
name|any
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * Start an IO operation on a given context object with a specified  * function and buffer.  * This locks the shared lock on the context, checks for the lock  * being active, and only then runs the starter function.  *  * Returns TRUE if the starter was executed successfully, FALSE in  * all other cases.  *  * !!NOTE!! The context object and the buffer are consumed by this  * call IN ANY CASE, independent of the function result!  */
end_comment

begin_function
name|BOOL
name|IoCtxStartLocked
parameter_list|(
name|IoCtx_t
modifier|*
name|lpo
parameter_list|,
name|IoCtxStarterT
name|func
parameter_list|,
name|recvbuf_t
modifier|*
name|buf
parameter_list|)
block|{
name|BOOL
name|done
init|=
name|FALSE
decl_stmt|;
name|SharedLock_t
modifier|*
name|slock
init|=
name|slAttachShared
argument_list|(
name|lpo
operator|->
name|slock
argument_list|)
decl_stmt|;
if|if
condition|(
name|slock
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|lpo
operator|->
name|io
operator|.
name|hnd
operator|==
name|slock
operator|->
name|handles
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|lpo
operator|->
name|io
operator|.
name|hnd
operator|==
name|slock
operator|->
name|handles
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|done
operator|=
call|(
name|func
call|)
argument_list|(
name|lpo
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|lpo
operator|=
name|NULL
expr_stmt|;
comment|/* consumed by 'func' */
block|}
name|slDetachShared
argument_list|(
name|slock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lpo
operator|!=
name|NULL
condition|)
block|{
name|freerecvbuf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|IoCtxFree
argument_list|(
name|lpo
argument_list|)
expr_stmt|;
block|}
return|return
name|done
return|;
block|}
end_function

begin_comment
comment|/* -*- that's all folks -*- */
end_comment

end_unit

