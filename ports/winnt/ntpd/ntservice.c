begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2002  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ntp_stdlib.h>
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntservice.h"
end_include

begin_include
include|#
directive|include
file|"clockstuff.h"
end_include

begin_include
include|#
directive|include
file|"ntp_iocompletionport.h"
end_include

begin_include
include|#
directive|include
file|"ntpd-opts.h"
end_include

begin_include
include|#
directive|include
file|"isc/win32os.h"
end_include

begin_include
include|#
directive|include
file|<ssl_applink.c>
end_include

begin_comment
comment|/*  * Globals  */
end_comment

begin_decl_stmt
specifier|static
name|SERVICE_STATUS_HANDLE
name|hServiceStatus
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BOOL
name|foreground
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BOOL
name|computer_shutting_down
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|glb_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|glb_argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HANDLE
name|hServDoneEvent
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|accept_wildcard_if_for_winnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Forward declarations  */
end_comment

begin_function_decl
name|void
name|uninit_io_completion_port
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ntpdmain
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|WINAPI
name|ServiceControl
parameter_list|(
name|DWORD
name|dwCtrlCode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ntservice_exit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|WRAP_DBG_MALLOC
end_ifdef

begin_function_decl
name|void
modifier|*
name|wrap_dbg_malloc
parameter_list|(
name|size_t
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|int
name|l
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|wrap_dbg_realloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|int
name|l
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|wrap_dbg_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|WINAPI
name|service_main
parameter_list|(
name|DWORD
name|argc
parameter_list|,
name|LPTSTR
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
comment|/* 		 * Let command line parameters from the Windows SCM GUI 		 * override the standard parameters from the ImagePath registry key. 		 */
name|glb_argc
operator|=
name|argc
expr_stmt|;
name|glb_argv
operator|=
name|argv
expr_stmt|;
block|}
name|ntpdmain
argument_list|(
name|glb_argc
argument_list|,
name|glb_argv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the entry point for the executable   * We can call ntpdmain() explicitly or via StartServiceCtrlDispatcher()  * as we need to.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|int
name|argc_after_opts
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv_after_opts
decl_stmt|;
name|ssl_applink
argument_list|()
expr_stmt|;
comment|/* Save the command line parameters */
name|glb_argc
operator|=
name|argc
expr_stmt|;
name|glb_argv
operator|=
name|argv
expr_stmt|;
comment|/* Under original Windows NT we must not discard the wildcard */
comment|/* socket to workaround a bug in NT's getsockname(). */
if|if
condition|(
name|isc_win32os_majorversion
argument_list|()
operator|<=
literal|4
condition|)
name|accept_wildcard_if_for_winnt
operator|=
name|TRUE
expr_stmt|;
name|argc_after_opts
operator|=
name|argc
expr_stmt|;
name|argv_after_opts
operator|=
name|argv
expr_stmt|;
name|parse_cmdline_opts
argument_list|(
operator|&
name|argc_after_opts
argument_list|,
operator|&
name|argv_after_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|QUIT
argument_list|)
operator|||
name|HAVE_OPT
argument_list|(
name|SAVECONFIGQUIT
argument_list|)
operator|||
name|HAVE_OPT
argument_list|(
name|HELP
argument_list|)
ifdef|#
directive|ifdef
name|DEBUG
operator|||
name|OPT_VALUE_SET_DEBUG_LEVEL
operator|!=
literal|0
endif|#
directive|endif
operator|||
name|HAVE_OPT
argument_list|(
name|NOFORK
argument_list|)
condition|)
name|foreground
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|foreground
condition|)
comment|/* run in console window */
name|rc
operator|=
name|ntpdmain
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Start up as service */
name|SERVICE_TABLE_ENTRY
name|dispatchTable
index|[]
init|=
block|{
block|{
name|TEXT
argument_list|(
name|NTP_DISPLAY_NAME
argument_list|)
block|,
name|service_main
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|rc
operator|=
name|StartServiceCtrlDispatcher
argument_list|(
name|dispatchTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
name|rc
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unable to start as service:\n"
literal|"%s\n"
literal|"Use -d, -q, -n, -?, --help or "
literal|"--saveconfigquit to run "
literal|"interactive.\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|ntp_strerror
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the Service by registering it.  */
end_comment

begin_function
name|void
name|ntservice_init
parameter_list|()
block|{
name|char
name|ConsoleTitle
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|foreground
condition|)
block|{
comment|/* Register handler with the SCM */
name|hServiceStatus
operator|=
name|RegisterServiceCtrlHandler
argument_list|(
name|NTP_DISPLAY_NAME
argument_list|,
name|ServiceControl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hServiceStatus
condition|)
block|{
name|NTReportError
argument_list|(
name|NTP_SERVICE_NAME
argument_list|,
literal|"could not register service control handler"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|UpdateSCM
argument_list|(
name|SERVICE_RUNNING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|ConsoleTitle
argument_list|,
sizeof|sizeof
argument_list|(
name|ConsoleTitle
argument_list|)
argument_list|,
literal|"NTP Version %s"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|ConsoleTitle
index|[
sizeof|sizeof
argument_list|(
name|ConsoleTitle
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SetConsoleTitle
argument_list|(
name|ConsoleTitle
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_CRTDBG_MAP_ALLOC
comment|/* ask the runtime to dump memory leaks at exit */
name|_CrtSetDbgFlag
argument_list|(
name|_CRTDBG_ALLOC_MEM_DF
operator||
name|_CRTDBG_LEAK_CHECK_DF
comment|/* report on leaks at exit */
operator||
name|_CRTDBG_CHECK_ALWAYS_DF
comment|/* Check heap every alloc/dealloc */
ifdef|#
directive|ifdef
name|MALLOC_LINT
operator||
name|_CRTDBG_DELAY_FREE_MEM_DF
comment|/* Don't actually free memory */
endif|#
directive|endif
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DOES_NOT_WORK
comment|/* 			 * hart: I haven't seen this work, running ntpd.exe -n from a shell 			 * to both a file and the debugger output window.  Docs indicate it 			 * should cause leak report to go to stderr, but it's only seen if 			 * ntpd runs under a debugger (in the debugger's output), even with 			 * this block of code enabled. 			 */
name|_CrtSetReportFile
argument_list|(
name|_CRT_ERROR
argument_list|,
name|_CRTDBG_FILE_STDERR
argument_list|)
expr_stmt|;
name|_CrtSetReportMode
argument_list|(
name|_CRT_ERROR
argument_list|,
name|_CRTDBG_MODE_FILE
operator||
name|_CRTDBG_MODE_DEBUG
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* using MS debug C runtime heap, _CRTDBG_MAP_ALLOC */
name|atexit
argument_list|(
name|ntservice_exit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to check if the service is stopping  * because the computer is shutting down  */
end_comment

begin_function
name|BOOL
name|ntservice_systemisshuttingdown
parameter_list|()
block|{
return|return
name|computer_shutting_down
return|;
block|}
end_function

begin_function
name|void
name|ntservice_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|uninit_io_completion_port
argument_list|()
expr_stmt|;
name|Sleep
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|//##++
name|reset_winnt_time
argument_list|()
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ntservice: The Network Time Protocol Service is stopping."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foreground
condition|)
block|{
comment|/* service mode, need to have the service_main routine 		 * register with the service control manager that the  		 * service has stopped running, before exiting 		 */
name|UpdateSCM
argument_list|(
name|SERVICE_STOPPED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*   * ServiceControl(): Handles requests from the SCM and passes them on  * to the service.  */
end_comment

begin_function
name|void
name|WINAPI
name|ServiceControl
parameter_list|(
name|DWORD
name|dwCtrlCode
parameter_list|)
block|{
switch|switch
condition|(
name|dwCtrlCode
condition|)
block|{
case|case
name|SERVICE_CONTROL_SHUTDOWN
case|:
name|computer_shutting_down
operator|=
name|TRUE
expr_stmt|;
comment|/* fall through to stop case */
case|case
name|SERVICE_CONTROL_STOP
case|:
if|if
condition|(
name|WaitableExitEventHandle
operator|!=
name|NULL
condition|)
block|{
name|SetEvent
argument_list|(
name|WaitableExitEventHandle
argument_list|)
expr_stmt|;
name|UpdateSCM
argument_list|(
name|SERVICE_STOP_PENDING
argument_list|)
expr_stmt|;
name|Sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|//##++
block|}
return|return;
case|case
name|SERVICE_CONTROL_PAUSE
case|:
case|case
name|SERVICE_CONTROL_CONTINUE
case|:
case|case
name|SERVICE_CONTROL_INTERROGATE
case|:
default|default:
break|break;
block|}
name|UpdateSCM
argument_list|(
name|SERVICE_RUNNING
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Tell the Service Control Manager the state of the service.  */
end_comment

begin_function
name|void
name|UpdateSCM
parameter_list|(
name|DWORD
name|state
parameter_list|)
block|{
name|SERVICE_STATUS
name|ss
decl_stmt|;
specifier|static
name|DWORD
name|dwState
init|=
name|SERVICE_STOPPED
decl_stmt|;
if|if
condition|(
name|hServiceStatus
condition|)
block|{
if|if
condition|(
name|state
condition|)
name|dwState
operator|=
name|state
expr_stmt|;
name|ZERO
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|ss
operator|.
name|dwServiceType
operator||=
name|SERVICE_WIN32_OWN_PROCESS
expr_stmt|;
name|ss
operator|.
name|dwCurrentState
operator|=
name|dwState
expr_stmt|;
name|ss
operator|.
name|dwControlsAccepted
operator|=
name|SERVICE_ACCEPT_STOP
operator||
name|SERVICE_ACCEPT_SHUTDOWN
expr_stmt|;
name|ss
operator|.
name|dwCheckPoint
operator|=
literal|0
expr_stmt|;
name|ss
operator|.
name|dwServiceSpecificExitCode
operator|=
literal|0
expr_stmt|;
name|ss
operator|.
name|dwWin32ExitCode
operator|=
name|NO_ERROR
expr_stmt|;
name|ss
operator|.
name|dwWaitHint
operator|=
name|dwState
operator|==
name|SERVICE_STOP_PENDING
condition|?
literal|5000
else|:
literal|1000
expr_stmt|;
name|SetServiceStatus
argument_list|(
name|hServiceStatus
argument_list|,
operator|&
name|ss
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|BOOL
name|WINAPI
name|OnConsoleEvent
parameter_list|(
name|DWORD
name|dwCtrlType
parameter_list|)
block|{
switch|switch
condition|(
name|dwCtrlType
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
case|case
name|CTRL_BREAK_EVENT
case|:
if|if
condition|(
name|debug
operator|>
literal|0
condition|)
block|{
name|debug
operator|<<=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|debug
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>
literal|8
condition|)
block|{
name|debug
operator|=
literal|0
expr_stmt|;
block|}
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"debug level %d"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
case|case
name|CTRL_BREAK_EVENT
case|:
break|break;
endif|#
directive|endif
case|case
name|CTRL_C_EVENT
case|:
case|case
name|CTRL_CLOSE_EVENT
case|:
case|case
name|CTRL_SHUTDOWN_EVENT
case|:
if|if
condition|(
name|WaitableExitEventHandle
operator|!=
name|NULL
condition|)
block|{
name|SetEvent
argument_list|(
name|WaitableExitEventHandle
argument_list|)
expr_stmt|;
name|Sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|//##++
block|}
break|break;
default|default :
comment|/* pass to next handler */
return|return
name|FALSE
return|;
block|}
comment|/* we've handled it, no more handlers should be called */
return|return
name|TRUE
return|;
block|}
end_function

end_unit

