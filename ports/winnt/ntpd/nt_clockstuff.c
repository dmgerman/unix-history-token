begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Windows NT Clock Routines  *  * Created by Sven Dietrich  sven@inter-yacht.com  *  * New interpolation scheme by Dave Hart<davehart@davehart.com> in  * February 2009 overcomes 500us-1ms inherent jitter with the older  * scheme, first identified by Peter Rosin (nee Ekberg)  *<peda@lysator.liu.se> in 2003 [Bug 216].  *  * Note:  The Windows port of ntpd uses the C99-snprintf replacement for  * (v)snprintf(), also used by msyslog(), which does not understand the  * printf format specifier %I64d, only the more common %lld.  With the  * minimum supported compiler raised to Visual C++ 2005 in ntp-dev in  * August 2011, all MS C runtime routines also understand %lld and %llu.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_comment
comment|/* our private version */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
end_if

begin_comment
comment|/* VS 2005 */
end_comment

begin_include
include|#
directive|include
file|<intrin.h>
end_include

begin_comment
comment|/* for __rdtsc() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_include
include|#
directive|include
file|<timepps.h>
end_include

begin_comment
comment|/*  * ports/winnt/include/timepps.h defines EOPNOTSUPP for compatibility  * with PPSAPI on other platforms.  ports/winnt/include/isc/net.h has  * #define EOPNOTSUPP WSAEOPNOTSUPP, so to avoid a macro redefinition  * warning undefine it.  */
end_comment

begin_undef
undef|#
directive|undef
name|EOPNOTSUPP
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_timer.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"ntp_leapsec.h"
end_include

begin_include
include|#
directive|include
file|"clockstuff.h"
end_include

begin_include
include|#
directive|include
file|"ntservice.h"
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntpd-opts.h"
end_include

begin_decl_stmt
specifier|extern
name|double
name|sys_residual
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* residual from previous adjustment */
end_comment

begin_comment
comment|/*  * Include code to possibly modify the MM timer while the service is active.   */
end_comment

begin_comment
comment|/*  * Whether or not MM timer modifications takes place is still controlled   * by the variable below which is initialized by a default value but   * might be changed depending on a command line switch.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|modify_mm_timer
init|=
name|MM_TIMER_LORES
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MM_TIMER_INTV
value|1
end_define

begin_comment
comment|/* the interval we'd want to set the MM timer to [ms] */
end_comment

begin_decl_stmt
specifier|static
name|UINT
name|wTimerRes
decl_stmt|;
end_decl_stmt

begin_function_decl
name|BOOL
name|init_randfile
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|long
name|last_Adj
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LS_CORR_INTV_SECS
value|2
end_define

begin_comment
comment|/* seconds to apply leap second correction */
end_comment

begin_define
define|#
directive|define
name|LS_CORR_INTV
value|( 1000ul * LS_CORR_INTV_SECS )
end_define

begin_define
define|#
directive|define
name|LS_CORR_LIMIT
value|( 250ul )
end_define

begin_comment
comment|// quarter second
end_comment

begin_typedef
typedef|typedef
union|union
name|ft_ull
block|{
name|FILETIME
name|ft
decl_stmt|;
name|ULONGLONG
name|ull
decl_stmt|;
name|LONGLONG
name|ll
decl_stmt|;
name|LARGE_INTEGER
name|li
decl_stmt|;
block|}
name|FT_ULL
typedef|;
end_typedef

begin_comment
comment|/* leap second stuff */
end_comment

begin_decl_stmt
specifier|static
name|FT_ULL
name|ls_ft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DWORD
name|ls_time_adjustment
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BOOL
name|winnt_time_initialized
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BOOL
name|winnt_use_interpolation
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|clock_thread_id
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|WINAPI
name|GetInterpTimeAsFileTime
parameter_list|(
name|LPFILETIME
name|pft
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|StartClockThread
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tune_ctr_freq
parameter_list|(
name|LONGLONG
parameter_list|,
name|LONGLONG
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|StopClockThread
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|atexit_revert_mm_timer
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|win_time_stepped
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|HANDLE
name|clock_thread
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HANDLE
name|TimerThreadExitRequest
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * interp_time estimates time in 100ns units  * based on a performance counter value given.  * The 2nd parameter indicates if this is  * part of a current time-of-day calculation.  */
end_comment

begin_function_decl
name|ULONGLONG
name|interp_time
parameter_list|(
name|ULONGLONG
parameter_list|,
name|BOOL
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * add_counter_time_pair is called by the  * high priority clock thread with a new  * sample.  */
end_comment

begin_function_decl
name|void
name|add_counter_time_pair
parameter_list|(
name|ULONGLONG
parameter_list|,
name|LONGLONG
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * globals used by the above two functions to   * implement the counter/time history  */
end_comment

begin_define
define|#
directive|define
name|BASELINES_TOT
value|256
end_define

begin_define
define|#
directive|define
name|BASELINES_USED
value|64
end_define

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|newest_baseline
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|newest_baseline_gen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ULONGLONG
name|baseline_counts
index|[
name|BASELINES_TOT
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LONGLONG
name|baseline_times
index|[
name|BASELINES_TOT
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CLOCK_BACK_THRESHOLD
value|100
end_define

begin_comment
comment|/*< 10us unremarkable */
end_comment

begin_decl_stmt
specifier|static
name|ULONGLONG
name|clock_backward_max
init|=
name|CLOCK_BACK_THRESHOLD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|clock_backward_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * A flag set on Windows versions which ignore small time adjustments.  *  * Windows Vista and Windows 7 ignore TimeAdjustment less than 16.  * @note Has to be checked for Windows Server 2008/2012 and Windows 8.  * Ref: http://support.microsoft.com/kb/2537623, bug #2328  */
end_comment

begin_decl_stmt
specifier|static
name|BOOL
name|os_ignores_small_adjustment
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * clockperiod is the period used for SetSystemTimeAdjustment   * slewing calculations but does not necessarily correspond  * to the precision of the OS clock.  Prior to Windows Vista  * (6.0) the two were identical.  In 100ns units.  */
end_comment

begin_decl_stmt
specifier|static
name|DWORD
name|clockperiod
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * os_clock_precision is the observed precision of the OS  * clock, meaning the increment between discrete values. This  * is currently calculated once at startup.  100ns units.  */
end_comment

begin_decl_stmt
specifier|static
name|ULONGLONG
name|os_clock_precision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * NomPerfCtrFreq is from QueryPerformanceFrequency and is the   * number of performance counter beats per second.  PerfCtrFreq  * starts from NomPerfCtrFreq but is maintained using a sliding  * window average based on actual performance counter behavior,  * to allow us to better tolerate powersaving measures that  * alter the effective frequency of the processor cycle counter  * (TSC) which sometimes underlies QueryPerformanceCounter.  *  * Note that the OS is unlikely to be so subtle in its internal  * scheduling of waitable timers, presumably done using the  * performance counter.  Therefore our calculations for  * interpolated time should be based on PerfCtrFreq but our  * calculations for SetWaitableTimer should assume the OS will  * convert from FILETIME 100ns units to performance counter  * beats using the nominal frequency.  */
end_comment

begin_decl_stmt
specifier|volatile
name|ULONGLONG
name|PerfCtrFreq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ULONGLONG
name|NomPerfCtrFreq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * If we're using RDTSC beating at the same rate as  * QueryPerformanceCounter, there is a systemic  * offset we need to account for when using  * counterstamps from serialpps.sys, which are  * always from QPC (actually KeQueryPerformanceCounter).  */
end_comment

begin_decl_stmt
specifier|static
name|LONGLONG
name|QPC_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Substitute RDTSC for QueryPerformanceCounter()?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_pcc
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Restrict threads that call QPC/RDTSC to one CPU?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lock_interp_threads
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ppm_per_adjust_unit is parts per million effect on the OS  * clock per slewing adjustment unit per second.  Per haps.  */
end_comment

begin_decl_stmt
specifier|static
name|DOUBLE
name|ppm_per_adjust_unit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * wintickadj emulates the functionality provided by unix tickadj,  * providing a baseline clock correction if needed to get the  * clock within a few hundred PPM of correct frequency.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|wintickadj
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|choose_interp_counter
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_qpc_built_on_pcc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * performance counter frequency observations  */
end_comment

begin_define
define|#
directive|define
name|TUNE_CTR_DEPTH
value|3
end_define

begin_comment
comment|/* running avg depth */
end_comment

begin_decl_stmt
specifier|static
name|HANDLE
name|ctr_freq_timer
init|=
name|INVALID_HANDLE_VALUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ULONGLONG
name|tune_ctr_freq_max_interval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|tune_ctr_period
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|start_ctr_freq_timer
parameter_list|(
name|ULONGLONG
name|now_time
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|reset_ctr_freq_timer
parameter_list|(
name|ULONGLONG
name|when
parameter_list|,
name|ULONGLONG
name|now
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|reset_ctr_freq_timer_abs
parameter_list|(
name|ULONGLONG
name|when
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* round a Windows time to the next bottom of the second */
end_comment

begin_define
define|#
directive|define
name|ROUND_TO_NEXT_SEC_BOTTOM
parameter_list|(
name|t
parameter_list|)
define|\
value|do {	\ 	(t) += 3 * HECTONANOSECONDS / 2 - 1;	\ 	(t) /= HECTONANOSECONDS;	\ 	(t) *= HECTONANOSECONDS;	\ 	(t) -= HECTONANOSECONDS / 2;	\ } while (0)
end_define

begin_comment
comment|/*  * NT native time format is 100's of nanoseconds since 1601-01-01.  * Helpers for converting between "hectonanoseconds" and the   * performance counter scale from which interpolated time is  * derived.  */
end_comment

begin_define
define|#
directive|define
name|HNS2PERF
parameter_list|(
name|hns
parameter_list|)
value|((hns) * PerfCtrFreq / HECTONANOSECONDS)
end_define

begin_define
define|#
directive|define
name|PERF2HNS
parameter_list|(
name|ctr
parameter_list|)
value|((ctr) * HECTONANOSECONDS / PerfCtrFreq)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
end_if

begin_comment
comment|/* VS 2005 */
end_comment

begin_define
define|#
directive|define
name|get_pcc
parameter_list|()
value|__rdtsc()
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * something like this can be used for a compiler without __rdtsc()  */
end_comment

begin_function
name|ULONGLONG
name|__forceinline
name|get_pcc
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* RDTSC returns in EDX:EAX, same as C compiler */
asm|__asm {
asm|RDTSC
asm|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * perf_ctr() returns the current performance counter value,   * from QueryPerformanceCounter or RDTSC.  */
end_comment

begin_function
name|ULONGLONG
name|WINAPI
name|perf_ctr
parameter_list|(
name|void
parameter_list|)
block|{
name|FT_ULL
name|ft
decl_stmt|;
if|if
condition|(
name|use_pcc
condition|)
return|return
name|get_pcc
argument_list|()
return|;
else|else
block|{
name|QueryPerformanceCounter
argument_list|(
operator|&
name|ft
operator|.
name|li
argument_list|)
expr_stmt|;
return|return
name|ft
operator|.
name|ull
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * init_small_adjustment  *  * Set variable os_ignores_small_adjustment  *  */
end_comment

begin_function
specifier|static
name|void
name|init_small_adjustment
parameter_list|(
name|void
parameter_list|)
block|{
name|OSVERSIONINFO
name|vi
decl_stmt|;
name|memset
argument_list|(
operator|&
name|vi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vi
argument_list|)
argument_list|)
expr_stmt|;
name|vi
operator|.
name|dwOSVersionInfoSize
operator|=
sizeof|sizeof
argument_list|(
name|vi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GetVersionEx
argument_list|(
operator|&
name|vi
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"GetVersionEx failed with error code %d."
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|os_ignores_small_adjustment
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vi
operator|.
name|dwMajorVersion
operator|==
literal|6
operator|&&
name|vi
operator|.
name|dwMinorVersion
operator|==
literal|1
condition|)
block|{
comment|// Windows 7 and Windows Server 2008 R2
comment|//
comment|// Windows 7 is documented as affected.
comment|// Windows Server 2008 R2 is assumed affected.
name|os_ignores_small_adjustment
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vi
operator|.
name|dwMajorVersion
operator|==
literal|6
operator|&&
name|vi
operator|.
name|dwMinorVersion
operator|==
literal|0
condition|)
block|{
comment|// Windows Vista and Windows Server 2008
comment|//
comment|// Windows Vista is documented as affected.
comment|// Windows Server 2008 is assumed affected.
name|os_ignores_small_adjustment
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|os_ignores_small_adjustment
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * choose_interp_counter - select between QueryPerformanceCounter and  *			   the x86 processor cycle counter (TSC).  */
end_comment

begin_function
specifier|static
name|void
name|choose_interp_counter
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ntpd_pcc_freq_text
decl_stmt|;
name|int
name|qpc_built_on_pcc
decl_stmt|;
comment|/* 	 * Regardless of whether we actually use RDTSC, first determine 	 * if QueryPerformanceCounter is built on it, so that we can 	 * decide whether it's prudent to lock QPC-consuming threads to 	 * a particular CPU. 	 */
name|qpc_built_on_pcc
operator|=
name|is_qpc_built_on_pcc
argument_list|()
expr_stmt|;
name|lock_interp_threads
operator|=
name|qpc_built_on_pcc
expr_stmt|;
comment|/* 	 * It's time to make some more permanent knobs, 	 * but for right now the RDTSC aka PCC dance on x86 is: 	 * 	 * 1.  With none of these variables defined, only QPC 	 *     is used because there is no reliable way to 	 *     detect counter frequency variation after ntpd 	 *     startup implemented. 	 * 2.  We need a better knob, but for now if you know 	 *     your RDTSC / CPU frequency is invariant, set 	 *     NTPD_PCC and assuming your QPC is based on the 	 *     PCC as well, RDTSC will be substituted. 	 * 3.  More forcefully, you can jam in a desired exact 	 *     processor frequency, expressed in cycles per 	 *     second by setting NTPD_PCC_FREQ=398125000, for 	 *     example, if yor actual known CPU frequency is 	 *     398.125 MHz, and NTPD_PCC doesn't work because 	 *     QueryPerformanceCounter is implemented using 	 *     another counter.  It is very easy to make ntpd 	 *     fall down if the NTPD_PCC_FREQ value isn't very 	 *     close to the observed RDTSC units per second. 	 * 	 * Items 2 and 3 could probably best be combined into one 	 * new windows-specific command line switch such as 	 *   ntpd --pcc 	 * or 	 *   ntpd --pcc=398125000 	 * 	 * They are currently tied to Windows because that is 	 * the only ntpd port with its own interpolation, and 	 * to x86/x64 because no one has ported the Windows 	 * ntpd port to the sole remaining alternative, Intel 	 * Itanium. 	 */
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|PCCFREQ
argument_list|)
condition|)
name|ntpd_pcc_freq_text
operator|=
name|OPT_ARG
argument_list|(
name|PCCFREQ
argument_list|)
expr_stmt|;
else|else
name|ntpd_pcc_freq_text
operator|=
name|getenv
argument_list|(
literal|"NTPD_PCC_FREQ"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HAVE_OPT
argument_list|(
name|USEPCC
argument_list|)
operator|&&
name|NULL
operator|==
name|ntpd_pcc_freq_text
operator|&&
name|NULL
operator|==
name|getenv
argument_list|(
literal|"NTPD_PCC"
argument_list|)
condition|)
block|{
name|use_pcc
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|qpc_built_on_pcc
operator|&&
name|NULL
operator|==
name|ntpd_pcc_freq_text
condition|)
block|{
name|use_pcc
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|use_pcc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ntpd_pcc_freq_text
operator|!=
name|NULL
condition|)
name|sscanf
argument_list|(
name|ntpd_pcc_freq_text
argument_list|,
literal|"%llu"
argument_list|,
operator|&
name|NomPerfCtrFreq
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"using processor cycle counter "
literal|"%.3f MHz"
argument_list|,
name|NomPerfCtrFreq
operator|/
literal|1e6
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * is_qpc_built_on_pcc - test if QueryPerformanceCounter runs at the  *			 same rate as the processor cycle counter (TSC).  */
end_comment

begin_function
specifier|static
name|int
name|is_qpc_built_on_pcc
parameter_list|(
name|void
parameter_list|)
block|{
name|LONGLONG
name|offset
decl_stmt|;
name|FT_ULL
name|ft1
decl_stmt|;
name|FT_ULL
name|ft2
decl_stmt|;
name|FT_ULL
name|ft3
decl_stmt|;
name|FT_ULL
name|ft4
decl_stmt|;
name|FT_ULL
name|ft5
decl_stmt|;
name|NTP_REQUIRE
argument_list|(
name|NomPerfCtrFreq
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|QueryPerformanceCounter
argument_list|(
operator|&
name|ft1
operator|.
name|li
argument_list|)
expr_stmt|;
name|ft2
operator|.
name|ull
operator|=
name|get_pcc
argument_list|()
expr_stmt|;
name|Sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|QueryPerformanceCounter
argument_list|(
operator|&
name|ft3
operator|.
name|li
argument_list|)
expr_stmt|;
name|Sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ft4
operator|.
name|ull
operator|=
name|get_pcc
argument_list|()
expr_stmt|;
name|Sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|QueryPerformanceCounter
argument_list|(
operator|&
name|ft5
operator|.
name|li
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ft2
operator|.
name|ull
operator|-
name|ft1
operator|.
name|ull
expr_stmt|;
name|ft3
operator|.
name|ull
operator|+=
name|offset
expr_stmt|;
name|ft5
operator|.
name|ull
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|ft2
operator|.
name|ull
operator|<=
name|ft3
operator|.
name|ull
operator|&&
name|ft3
operator|.
name|ull
operator|<=
name|ft4
operator|.
name|ull
operator|&&
name|ft4
operator|.
name|ull
operator|<=
name|ft5
operator|.
name|ull
condition|)
block|{
name|QPC_offset
operator|=
name|offset
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Request Multimedia Timer  */
end_comment

begin_function
name|void
name|set_mm_timer
parameter_list|(
name|int
name|timerres
parameter_list|)
block|{
name|modify_mm_timer
operator|=
name|timerres
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * adj_systime - called once every second to discipline system clock.  * Normally, the offset passed in (parameter now) is in the range  * [-NTP_MAXFREQ, NTP_MAXFREQ].  However, at EVNT_NSET, a much larger  * slew is requested if the initial offset is less than the step  * threshold, in the range [-step, step] where step is the step  * threshold, 128 msec by default.  For the remainder of the frequency  * training interval, adj_systime is called with 0 offset each second  * and slew the large offset at 500 PPM (500 usec/sec).  * Returns 1 if okay, 0 if trouble.  */
end_comment

begin_function
name|int
name|adj_systime
parameter_list|(
name|double
name|now
parameter_list|)
block|{
comment|/* ntp time scale origin as ticks since 1601-01-01 */
specifier|static
specifier|const
name|ULONGLONG
name|HNS_JAN_1900
init|=
literal|94354848000000000ull
decl_stmt|;
specifier|static
name|DWORD
name|ls_start_tick
decl_stmt|;
comment|/* start of slew in 1ms ticks */
specifier|static
name|double
name|adjtime_carry
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
name|u_char
name|isneg
decl_stmt|;
name|BOOL
name|rc
decl_stmt|;
name|long
name|TimeAdjustment
decl_stmt|;
name|SYSTEMTIME
name|st
decl_stmt|;
name|DWORD
name|ls_elapsed
decl_stmt|;
name|FT_ULL
name|curr_ft
decl_stmt|;
name|leap_result_t
name|lsi
decl_stmt|;
comment|/* 	 * Add the residual from the previous adjustment to the new 	 * adjustment, bound and round. 	 */
name|dtemp
operator|=
name|adjtime_carry
operator|+
name|sys_residual
operator|+
name|now
expr_stmt|;
name|adjtime_carry
operator|=
literal|0.
expr_stmt|;
name|sys_residual
operator|=
literal|0.
expr_stmt|;
if|if
condition|(
name|dtemp
operator|<
literal|0
condition|)
block|{
name|isneg
operator|=
name|TRUE
expr_stmt|;
name|dtemp
operator|=
operator|-
name|dtemp
expr_stmt|;
block|}
else|else
block|{
name|isneg
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|dtemp
operator|>
name|NTP_MAXFREQ
condition|)
block|{
name|adjtime_carry
operator|=
name|dtemp
operator|-
name|NTP_MAXFREQ
expr_stmt|;
name|dtemp
operator|=
name|NTP_MAXFREQ
expr_stmt|;
block|}
if|if
condition|(
name|isneg
condition|)
block|{
name|dtemp
operator|=
operator|-
name|dtemp
expr_stmt|;
name|adjtime_carry
operator|=
operator|-
name|adjtime_carry
expr_stmt|;
block|}
name|dtemp
operator|=
name|dtemp
operator|*
literal|1e6
expr_stmt|;
comment|/*  	 * dtemp is in micro seconds. NT uses 100 ns units, 	 * so a unit change in TimeAdjustment corresponds 	 * to slewing 10 ppm on a 100 Hz system. Calculate 	 * the number of 100ns units to add, using OS tick 	 * frequency as per suggestion from Harry Pyle, 	 * and leave the remainder in dtemp 	 */
name|TimeAdjustment
operator|=
call|(
name|long
call|)
argument_list|(
name|dtemp
operator|/
name|ppm_per_adjust_unit
operator|+
operator|(
operator|(
name|isneg
operator|)
condition|?
operator|-
literal|0.5
else|:
literal|0.5
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_ignores_small_adjustment
condition|)
block|{
comment|/* 		 * As the OS ignores adjustments smaller than 16, we need to 		 * leave these small adjustments in sys_residual, causing 		 * the small values to be averaged over time. 		 */
if|if
condition|(
name|TimeAdjustment
operator|>
operator|-
literal|16
operator|&&
name|TimeAdjustment
operator|<
literal|16
condition|)
block|{
name|TimeAdjustment
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|dtemp
operator|-=
name|TimeAdjustment
operator|*
name|ppm_per_adjust_unit
expr_stmt|;
comment|/* If a piping-hot close leap second is pending for the end          * of this day, determine the UTC time stamp when the transition          * must take place. (Calculated in the current leap era!)  	 */
if|if
condition|(
name|leapsec
operator|>=
name|LSPROX_ALERT
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|ls_ft
operator|.
name|ull
operator|&&
name|leapsec_frame
argument_list|(
operator|&
name|lsi
argument_list|)
condition|)
block|{
if|if
condition|(
name|lsi
operator|.
name|tai_diff
operator|>
literal|0
condition|)
block|{
comment|/* A leap second insert is scheduled at the end                                  * of the day. Since we have not yet computed the                                  * time stamp, do it now. Signal electric mode                                  * for this insert. We start processing 1 second early 				 * because we want to slew over 2 seconds.                                  */
name|ls_ft
operator|.
name|ull
operator|=
name|lsi
operator|.
name|ttime
operator|.
name|Q_s
operator|*
name|HECTONANOSECONDS
operator|+
name|HNS_JAN_1900
expr_stmt|;
name|FileTimeToSystemTime
argument_list|(
operator|&
name|ls_ft
operator|.
name|ft
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Detected positive leap second announcement "
literal|"for %04d-%02d-%02d %02d:%02d:%02d UTC"
argument_list|,
name|st
operator|.
name|wYear
argument_list|,
name|st
operator|.
name|wMonth
argument_list|,
name|st
operator|.
name|wDay
argument_list|,
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|)
expr_stmt|;
comment|/* slew starts with last second before insertion! 				 * And we have to tell the core that we deal with it. 				 */
name|ls_ft
operator|.
name|ull
operator|-=
operator|(
name|HECTONANOSECONDS
operator|+
name|HECTONANOSECONDS
operator|/
literal|2
operator|)
expr_stmt|;
name|leapsec_electric
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lsi
operator|.
name|tai_diff
operator|<
literal|0
condition|)
block|{
comment|/* Do not handle negative leap seconds here. If this                                  * happens, let the system step.                                  */
name|leapsec_electric
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* The leap second announcement is gone. Happens primarily after                  * the leap transition, but can also be due to a clock step.                  * Disarm the leap second, but only if there is one scheduled                  * and not currently in progress!                  */
if|if
condition|(
name|ls_ft
operator|.
name|ull
operator|!=
literal|0
operator|&&
name|ls_time_adjustment
operator|==
literal|0
condition|)
block|{
name|ls_ft
operator|.
name|ull
operator|=
literal|0
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Leap second announcement disarmed"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If the time stamp for the next leap second has been set 	 * then check if the leap second must be handled. We use 	 * free-running milliseconds from 'GetTickCount()', which 	 * is documented as not affected by clock and/or speed 	 * adjustments. 	 */
if|if
condition|(
name|ls_ft
operator|.
name|ull
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|ls_time_adjustment
condition|)
block|{
comment|/* has not yet been scheduled */
name|GetSystemTimeAsFileTime
argument_list|(
operator|&
name|curr_ft
operator|.
name|ft
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_ft
operator|.
name|ull
operator|>=
name|ls_ft
operator|.
name|ull
condition|)
block|{
name|ls_ft
operator|.
name|ull
operator|=
name|_UI64_MAX
expr_stmt|;
comment|/* guard against second schedule */
name|ls_time_adjustment
operator|=
name|clockperiod
operator|/
name|LS_CORR_INTV_SECS
expr_stmt|;
name|ls_start_tick
operator|=
name|GetTickCount
argument_list|()
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Started leap second insertion."
argument_list|)
expr_stmt|;
block|}
name|ls_elapsed
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* leap sec adjustment has been scheduled previously */
name|ls_elapsed
operator|=
name|GetTickCount
argument_list|()
operator|-
name|ls_start_tick
expr_stmt|;
block|}
if|if
condition|(
name|ls_time_adjustment
operator|!=
literal|0
condition|)
block|{
comment|/* leap second adjustment is currently active */
if|if
condition|(
name|ls_elapsed
operator|>
operator|(
name|LS_CORR_INTV
operator|-
name|LS_CORR_LIMIT
operator|)
condition|)
block|{
name|ls_time_adjustment
operator|=
literal|0
expr_stmt|;
comment|/* leap second adjustment done */
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Finished leap second insertion."
argument_list|)
expr_stmt|;
block|}
comment|/*  			 * NOTE: While the system time is slewed during the leap second  			 * the interpolation function which is based on the performance  			 * counter does not account for the slew. 			 */
name|TimeAdjustment
operator|-=
name|ls_time_adjustment
expr_stmt|;
block|}
block|}
name|sys_residual
operator|=
name|dtemp
operator|/
literal|1e6
expr_stmt|;
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"adj_systime: %.9f -> %.9f residual %.9f"
operator|,
name|now
operator|,
literal|1e-6
operator|*
operator|(
name|TimeAdjustment
operator|*
name|ppm_per_adjust_unit
operator|)
operator|,
name|sys_residual
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0.
operator|==
name|adjtime_carry
condition|)
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|" adjtime %.9f\n"
operator|,
name|adjtime_carry
operator|)
argument_list|)
expr_stmt|;
comment|/* only adjust the clock if adjustment changes */
name|TimeAdjustment
operator|+=
name|wintickadj
expr_stmt|;
if|if
condition|(
name|last_Adj
operator|!=
name|TimeAdjustment
condition|)
block|{
name|last_Adj
operator|=
name|TimeAdjustment
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"SetSystemTimeAdjustment(%+ld)\n"
operator|,
name|TimeAdjustment
operator|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|SetSystemTimeAdjustment
argument_list|(
name|clockperiod
operator|+
name|TimeAdjustment
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't adjust time: %m"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|init_winnt_time
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|settod
index|[]
init|=
literal|"settimeofday=\"SetSystemTime\""
decl_stmt|;
name|char
name|szMsgPath
index|[
name|MAX_PATH
operator|+
literal|1
index|]
decl_stmt|;
name|HANDLE
name|hToken
init|=
name|INVALID_HANDLE_VALUE
decl_stmt|;
name|TOKEN_PRIVILEGES
name|tkp
decl_stmt|;
name|TIMECAPS
name|tc
decl_stmt|;
name|BOOL
name|noslew
decl_stmt|;
name|DWORD
name|adjclockperiod
decl_stmt|;
name|LARGE_INTEGER
name|Freq
decl_stmt|;
name|FT_ULL
name|initial_hectonanosecs
decl_stmt|;
name|FT_ULL
name|next_hectonanosecs
decl_stmt|;
name|double
name|adjppm
decl_stmt|;
name|double
name|rawadj
decl_stmt|;
name|char
modifier|*
name|pch
decl_stmt|;
if|if
condition|(
name|winnt_time_initialized
condition|)
return|return;
comment|/* 	 * Make sure the service is initialized 	 * before we do anything else 	 */
name|ntservice_init
argument_list|()
expr_stmt|;
comment|/* Set up the Console Handler */
if|if
condition|(
operator|!
name|SetConsoleCtrlHandler
argument_list|(
name|OnConsoleEvent
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't set console control handler: %m"
argument_list|)
expr_stmt|;
block|}
comment|/* Set the Event-ID message-file name. */
if|if
condition|(
operator|!
name|GetModuleFileName
argument_list|(
name|NULL
argument_list|,
name|szMsgPath
argument_list|,
sizeof|sizeof
argument_list|(
name|szMsgPath
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"GetModuleFileName(PGM_EXE_FILE) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize random file before OpenSSL checks */
if|if
condition|(
operator|!
name|init_randfile
argument_list|()
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to initialize .rnd file"
argument_list|)
expr_stmt|;
pragma|#
directive|pragma
name|warning
name|(
name|push
name|)
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
comment|/* conditional expression is constant */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|SIZEOF_TIME_T
operator|!=
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
operator|||
name|SIZEOF_INT
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|||
name|SIZEOF_SIGNED_CHAR
operator|!=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"config.h SIZEOF_* macros wrong, fatal"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
pragma|#
directive|pragma
name|warning
name|(
name|pop
name|)
name|init_small_adjustment
argument_list|()
expr_stmt|;
name|leapsec_electric
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * Get privileges needed for fiddling with the clock 	 */
comment|/* get the current process token handle */
if|if
condition|(
operator|!
name|OpenProcessToken
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|TOKEN_ADJUST_PRIVILEGES
operator||
name|TOKEN_QUERY
argument_list|,
operator|&
name|hToken
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"OpenProcessToken failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* get the LUID for system-time privilege. */
name|LookupPrivilegeValue
argument_list|(
name|NULL
argument_list|,
name|SE_SYSTEMTIME_NAME
argument_list|,
operator|&
name|tkp
operator|.
name|Privileges
index|[
literal|0
index|]
operator|.
name|Luid
argument_list|)
expr_stmt|;
name|tkp
operator|.
name|PrivilegeCount
operator|=
literal|1
expr_stmt|;
comment|/* one privilege to set */
name|tkp
operator|.
name|Privileges
index|[
literal|0
index|]
operator|.
name|Attributes
operator|=
name|SE_PRIVILEGE_ENABLED
expr_stmt|;
comment|/* get set-time privilege for this process. */
name|AdjustTokenPrivileges
argument_list|(
name|hToken
argument_list|,
name|FALSE
argument_list|,
operator|&
name|tkp
argument_list|,
literal|0
argument_list|,
operator|(
name|PTOKEN_PRIVILEGES
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* cannot use return value of AdjustTokenPrivileges. */
comment|/* (success does not indicate all privileges were set) */
if|if
condition|(
name|GetLastError
argument_list|()
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"AdjustTokenPrivileges failed: %m"
argument_list|)
expr_stmt|;
comment|/* later set time call will probably fail */
block|}
name|CloseHandle
argument_list|(
name|hToken
argument_list|)
expr_stmt|;
name|hToken
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
comment|/* 	 * Say how we're setting the time of day 	 */
name|set_sys_var
argument_list|(
name|settod
argument_list|,
sizeof|sizeof
argument_list|(
name|settod
argument_list|)
argument_list|,
name|RO
argument_list|)
expr_stmt|;
comment|/* 	 * ntpd on Windows has always raised its priority, without 	 * requiring -N as on Unix.  Since Windows ntpd doesn't share 	 * the history of unix ntpd of once having no -N and therefore 	 * needing to be invoked under nice, there is no reason to 	 * bring it in line with the Unix version in this regard. 	 * Instsrv assumes ntpd is invoked with no arguments, and 	 * upgrading users would be negatively surprised by the  	 * poor timekeeping if they failed to add -N as part of  	 * upgrading were we to correct this platform difference. 	 */
if|if
condition|(
operator|-
literal|1
operator|==
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
name|NTP_PRIO
argument_list|)
condition|)
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Determine the existing system time slewing */
if|if
condition|(
operator|!
name|GetSystemTimeAdjustment
argument_list|(
operator|&
name|adjclockperiod
argument_list|,
operator|&
name|clockperiod
argument_list|,
operator|&
name|noslew
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"GetSystemTimeAdjustment failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there is no slewing before ntpd, adjclockperiod and clockperiod 	 * will be equal.  Any difference is carried into adj_systime's first 	 * pass as the previous adjustment. 	 */
name|last_Adj
operator|=
name|adjclockperiod
operator|-
name|clockperiod
expr_stmt|;
if|if
condition|(
name|last_Adj
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Clock interrupt period %.3f msec "
literal|"(startup slew %.1f usec/period)"
argument_list|,
name|clockperiod
operator|/
literal|1e4
argument_list|,
name|last_Adj
operator|/
literal|10.
argument_list|)
expr_stmt|;
else|else
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Clock interrupt period %.3f msec"
argument_list|,
name|clockperiod
operator|/
literal|1e4
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the time adjustment resulting from incrementing 	 * units per tick by 1 unit for 1 second  	 */
name|ppm_per_adjust_unit
operator|=
literal|1e6
operator|/
name|clockperiod
expr_stmt|;
name|pch
operator|=
name|getenv
argument_list|(
literal|"NTPD_TICKADJ_PPM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pch
operator|!=
name|NULL
operator|&&
literal|1
operator|==
name|sscanf
argument_list|(
name|pch
argument_list|,
literal|"%lf"
argument_list|,
operator|&
name|adjppm
argument_list|)
condition|)
block|{
name|rawadj
operator|=
name|adjppm
operator|/
name|ppm_per_adjust_unit
expr_stmt|;
name|rawadj
operator|+=
operator|(
name|rawadj
operator|<
literal|0
operator|)
condition|?
operator|-
literal|0.5
else|:
literal|0.5
expr_stmt|;
name|wintickadj
operator|=
operator|(
name|long
operator|)
name|rawadj
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Using NTPD_TICKADJ_PPM %+g ppm (%+ld)"
argument_list|,
name|adjppm
argument_list|,
name|wintickadj
argument_list|)
expr_stmt|;
block|}
comment|/* get the performance counter ticks per second */
if|if
condition|(
operator|!
name|QueryPerformanceFrequency
argument_list|(
operator|&
name|Freq
argument_list|)
operator|||
operator|!
name|Freq
operator|.
name|QuadPart
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"QueryPerformanceFrequency failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|NomPerfCtrFreq
operator|=
name|PerfCtrFreq
operator|=
name|Freq
operator|.
name|QuadPart
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Performance counter frequency %.3f MHz"
argument_list|,
name|PerfCtrFreq
operator|/
literal|1e6
argument_list|)
expr_stmt|;
comment|/* 	 * With a precise system clock, our interpolation decision is 	 * a slam dunk. 	 */
if|if
condition|(
name|NULL
operator|!=
name|pGetSystemTimePreciseAsFileTime
condition|)
block|{
name|winnt_use_interpolation
operator|=
name|FALSE
expr_stmt|;
name|winnt_time_initialized
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
comment|/*  	 * Implement any multimedia timer manipulation requested via -M 	 * option.  This is rumored to be unneeded on Win8 with the 	 * introduction of the precise (interpolated) system clock. 	 */
if|if
condition|(
name|modify_mm_timer
condition|)
block|{
if|if
condition|(
name|timeGetDevCaps
argument_list|(
operator|&
name|tc
argument_list|,
sizeof|sizeof
argument_list|(
name|tc
argument_list|)
argument_list|)
operator|==
name|TIMERR_NOERROR
condition|)
block|{
name|wTimerRes
operator|=
name|min
argument_list|(
name|max
argument_list|(
name|tc
operator|.
name|wPeriodMin
argument_list|,
name|MM_TIMER_INTV
argument_list|)
argument_list|,
name|tc
operator|.
name|wPeriodMax
argument_list|)
expr_stmt|;
name|timeBeginPeriod
argument_list|(
name|wTimerRes
argument_list|)
expr_stmt|;
name|atexit
argument_list|(
name|atexit_revert_mm_timer
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"MM timer resolution: %u..%u msec, set to %u msec"
argument_list|,
name|tc
operator|.
name|wPeriodMin
argument_list|,
name|tc
operator|.
name|wPeriodMax
argument_list|,
name|wTimerRes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Multimedia timer unavailable"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Spin on GetSystemTimeAsFileTime to determine its 	 * granularity.  Prior to Windows Vista this is  	 * typically the same as the clock period. 	 */
name|GetSystemTimeAsFileTime
argument_list|(
operator|&
name|initial_hectonanosecs
operator|.
name|ft
argument_list|)
expr_stmt|;
do|do
block|{
name|GetSystemTimeAsFileTime
argument_list|(
operator|&
name|next_hectonanosecs
operator|.
name|ft
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|initial_hectonanosecs
operator|.
name|ull
operator|==
name|next_hectonanosecs
operator|.
name|ull
condition|)
do|;
name|os_clock_precision
operator|=
name|next_hectonanosecs
operator|.
name|ull
operator|-
name|initial_hectonanosecs
operator|.
name|ull
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Windows clock precision %.3f msec, min. slew %.3f ppm/s"
argument_list|,
name|os_clock_precision
operator|/
literal|1e4
argument_list|,
name|ppm_per_adjust_unit
argument_list|)
expr_stmt|;
name|winnt_time_initialized
operator|=
name|TRUE
expr_stmt|;
name|choose_interp_counter
argument_list|()
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"NTPD_USE_SYSTEM_CLOCK"
argument_list|)
operator|||
operator|(
name|os_clock_precision
operator|<
literal|4
operator|*
literal|10000
operator|&&
operator|!
name|getenv
argument_list|(
literal|"NTPD_USE_INTERP_DANGEROUS"
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"using Windows clock directly"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|winnt_use_interpolation
operator|=
name|TRUE
expr_stmt|;
name|get_sys_time_as_filetime
operator|=
name|GetInterpTimeAsFileTime
expr_stmt|;
name|StartClockThread
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|atexit_revert_mm_timer
parameter_list|(
name|void
parameter_list|)
block|{
name|timeEndPeriod
argument_list|(
name|wTimerRes
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"MM timer resolution reset\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reset_winnt_time
parameter_list|(
name|void
parameter_list|)
block|{
name|SYSTEMTIME
name|st
decl_stmt|;
comment|/* 	 * If we're in the 2-second slew right after a leap second,  	 * we don't want to continue that extreme slew, in that case 	 * disable our slewing and return clock discipline to the  	 * kernel.  Similarly if we are not yet synchronized,  	 * our current slew may not be a good ongoing trim. 	 * Otherwise, our leave in place the last SetSystemTimeAdjustment 	 * as an ongoing frequency correction, better than nothing. 	 * TODO: 	 * Verify this will not call SetSystemTimeAdjustment if 	 * ntpd is running in ntpdate mode. 	 */
if|if
condition|(
name|sys_leap
operator|==
name|LEAP_NOTINSYNC
operator|||
name|ls_time_adjustment
operator|!=
literal|0
condition|)
name|SetSystemTimeAdjustment
argument_list|(
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * Read the current system time, and write it back to 	 * force CMOS update, only if we are exiting because 	 * the computer is shutting down and we are already 	 * synchronized. 	 */
if|if
condition|(
name|ntservice_systemisshuttingdown
argument_list|()
operator|&&
name|sys_leap
operator|!=
name|LEAP_NOTINSYNC
condition|)
block|{
name|GetSystemTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|SetSystemTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|NLOG
argument_list|(
argument|NLOG_SYSEVENT | NLOG_CLOCKINFO
argument_list|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"system is shutting down, CMOS time reset."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * GetSystemTimeAsFileTime() interface clone is used by getclock() in ntpd.  */
end_comment

begin_function
name|void
name|WINAPI
name|GetInterpTimeAsFileTime
parameter_list|(
name|LPFILETIME
name|pft
parameter_list|)
block|{
specifier|static
name|ULONGLONG
name|last_interp_time
decl_stmt|;
name|FT_ULL
name|now_time
decl_stmt|;
name|FT_ULL
name|now_count
decl_stmt|;
name|ULONGLONG
name|clock_backward
decl_stmt|;
comment|/* 	 * Mark a mark ASAP.  The latency to here should be reasonably 	 * deterministic 	 */
name|now_count
operator|.
name|ull
operator|=
name|perf_ctr
argument_list|()
expr_stmt|;
name|now_time
operator|.
name|ull
operator|=
name|interp_time
argument_list|(
name|now_count
operator|.
name|ull
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_interp_time
operator|<=
name|now_time
operator|.
name|ull
condition|)
block|{
name|last_interp_time
operator|=
name|now_time
operator|.
name|ull
expr_stmt|;
block|}
else|else
block|{
name|clock_backward
operator|=
name|last_interp_time
operator|-
name|now_time
operator|.
name|ull
expr_stmt|;
if|if
condition|(
name|clock_backward
operator|>
name|clock_backward_max
condition|)
block|{
name|clock_backward_max
operator|=
name|clock_backward
expr_stmt|;
name|clock_backward_count
operator|++
expr_stmt|;
block|}
name|now_time
operator|.
name|ull
operator|=
name|last_interp_time
expr_stmt|;
block|}
operator|*
name|pft
operator|=
name|now_time
operator|.
name|ft
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * TimerApcFunction is invoked on the high-priority clock  * thread to capture a new  baseline system time and  * performance counter correlation every 43 msec (64Hz   * OS clock precision).  */
end_comment

begin_function
specifier|static
name|void
name|CALLBACK
name|TimerApcFunction
parameter_list|(
name|LPVOID
name|lpArgToCompletionRoutine
parameter_list|,
name|DWORD
name|dwTimerLowValue
parameter_list|,
name|DWORD
name|dwTimerHighValue
parameter_list|)
block|{
specifier|static
name|BOOL
name|ctr_freq_timer_started
init|=
name|FALSE
decl_stmt|;
specifier|static
name|ULONGLONG
name|prev_count
decl_stmt|;
name|ULONGLONG
name|now_time
decl_stmt|;
name|FT_ULL
name|now_count
decl_stmt|;
comment|/* Grab the counter first of all */
name|now_count
operator|.
name|ull
operator|=
name|perf_ctr
argument_list|()
expr_stmt|;
name|now_time
operator|=
operator|(
operator|(
operator|(
name|ULONGLONG
operator|)
name|dwTimerHighValue
operator|<<
literal|32
operator|)
operator||
name|dwTimerLowValue
operator|)
expr_stmt|;
comment|/* 	 * Save this correlation in the history. 	 */
name|add_counter_time_pair
argument_list|(
name|now_count
operator|.
name|ull
argument_list|,
name|now_time
argument_list|)
expr_stmt|;
comment|/* 	 * Once we're synchronized start the counter frequency 	 * tuning timer. 	 */
if|if
condition|(
name|INVALID_HANDLE_VALUE
operator|==
name|ctr_freq_timer
operator|&&
name|LEAP_NOTINSYNC
operator|!=
name|sys_leap
condition|)
name|start_ctr_freq_timer
argument_list|(
name|now_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|WINAPI
name|ClockThread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|LARGE_INTEGER
name|DueTime
decl_stmt|;
name|HANDLE
name|timer
decl_stmt|;
name|double
name|HZ
decl_stmt|;
name|double
name|TimerHz
decl_stmt|;
name|DWORD
name|timer_period_msec
decl_stmt|;
name|DWORD
name|res
decl_stmt|;
name|char
modifier|*
name|ntpd_int_int_text
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|timer
operator|=
name|CreateWaitableTimer
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ntpd_int_int_text
operator|=
name|getenv
argument_list|(
literal|"NTPD_INT_INT"
argument_list|)
expr_stmt|;
name|HZ
operator|=
operator|(
name|double
operator|)
name|HECTONANOSECONDS
operator|/
name|clockperiod
expr_stmt|;
if|if
condition|(
name|HZ
operator|>
literal|63
operator|&&
name|HZ
operator|<
literal|65
condition|)
block|{
name|timer_period_msec
operator|=
literal|43
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HZ
operator|>
literal|98
operator|&&
name|HZ
operator|<
literal|102
condition|)
block|{
name|timer_period_msec
operator|=
literal|27
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ntpd_int_int_text
condition|)
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%.3f Hz system clock may benefit from "
literal|"custom NTPD_INT_INT env var timer interval "
literal|"override between approx. 20 and 50 msecs."
argument_list|,
name|HZ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|timer_period_msec
operator|=
call|(
name|DWORD
call|)
argument_list|(
literal|0.5
operator|+
operator|(
literal|2.752
operator|*
name|clockperiod
operator|/
literal|10000
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ntpd_int_int_text
condition|)
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"unfamiliar %.3f Hz system clock may benefit "
literal|"from custom NTPD_INT_INT env var timer "
literal|"interval override between approx. 20 and 50 "
literal|"msecs."
argument_list|,
name|HZ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntpd_int_int_text
operator|!=
name|NULL
condition|)
block|{
name|timer_period_msec
operator|=
name|atoi
argument_list|(
name|ntpd_int_int_text
argument_list|)
expr_stmt|;
name|timer_period_msec
operator|=
name|max
argument_list|(
literal|9
argument_list|,
name|timer_period_msec
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"using NTPD_INT_INT env var override %u"
argument_list|,
name|timer_period_msec
argument_list|)
expr_stmt|;
block|}
name|TimerHz
operator|=
literal|1e3
operator|/
name|timer_period_msec
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"HZ %.3f using %u msec timer %.3f Hz %d deep"
argument_list|,
name|HZ
argument_list|,
name|timer_period_msec
argument_list|,
name|TimerHz
argument_list|,
name|BASELINES_USED
argument_list|)
expr_stmt|;
comment|/* negative DueTime means relative to now */
name|DueTime
operator|.
name|QuadPart
operator|=
operator|-
operator|(
name|int
operator|)
name|timer_period_msec
expr_stmt|;
name|SetWaitableTimer
argument_list|(
name|timer
argument_list|,
operator|&
name|DueTime
argument_list|,
comment|/* first fire */
name|timer_period_msec
argument_list|,
comment|/* period thereafter */
name|TimerApcFunction
argument_list|,
comment|/* callback routine */
operator|&
name|timer
argument_list|,
comment|/* context for callback */
name|FALSE
argument_list|)
expr_stmt|;
comment|/* do not interfere with power saving */
comment|/* 	 * The clock thread spends the rest of its life in the TimerApcFunction 	 * and ctr_freq_timer_fired timer APC callbacks, which can only occur  	 * while this thread is in an alertable wait.  Note the Ex on  	 * WaitForSingleObjectEx and TRUE for fAlertable.  The wait will return  	 * after each APC callback in which case we simply wait again.  We will 	 * break out of the loop when StopClockThread signals our exit event. 	 */
do|do
name|res
operator|=
name|WaitForSingleObjectEx
argument_list|(
name|TimerThreadExitRequest
argument_list|,
name|INFINITE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
do|while
condition|(
name|WAIT_OBJECT_0
operator|!=
name|res
condition|)
do|;
name|CloseHandle
argument_list|(
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctr_freq_timer
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|CloseHandle
argument_list|(
name|ctr_freq_timer
argument_list|)
expr_stmt|;
name|ctr_freq_timer
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|StartClockThread
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|BOOL
name|done_once
init|=
name|FALSE
decl_stmt|;
name|FT_ULL
name|StartTime
decl_stmt|;
comment|/* init variables with the time now */
name|GetSystemTimeAsFileTime
argument_list|(
operator|&
name|StartTime
operator|.
name|ft
argument_list|)
expr_stmt|;
name|baseline_times
index|[
literal|0
index|]
operator|=
name|StartTime
operator|.
name|ull
expr_stmt|;
name|baseline_counts
index|[
literal|0
index|]
operator|=
name|perf_ctr
argument_list|()
expr_stmt|;
comment|/* init sync objects */
name|TimerThreadExitRequest
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|clock_thread
operator|=
operator|(
name|HANDLE
operator|)
name|_beginthreadex
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|ClockThread
argument_list|,
name|NULL
argument_list|,
name|CREATE_SUSPENDED
argument_list|,
operator|&
name|clock_thread_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock_thread
operator|!=
name|NULL
condition|)
block|{
comment|/* remember the thread priority is only within the process class */
if|if
condition|(
operator|!
name|SetThreadPriority
argument_list|(
name|clock_thread
argument_list|,
name|THREAD_PRIORITY_TIME_CRITICAL
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Error setting thread priority\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|lock_thread_to_processor
argument_list|(
name|clock_thread
argument_list|)
expr_stmt|;
name|ResumeThread
argument_list|(
name|clock_thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|FALSE
operator|==
name|done_once
condition|)
block|{
name|done_once
operator|=
name|TRUE
expr_stmt|;
name|lock_thread_to_processor
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
name|atexit
argument_list|(
name|StopClockThread
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Give the clock thread time to fill its counter/time 		 * sample buffer.  This will underfill the buffer a 		 * bit for sample periods over 43 msec. 		 */
name|Sleep
argument_list|(
name|BASELINES_USED
operator|*
literal|43
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|StopClockThread
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * if the clock thread exit()s this routine 	 * will be called on the clock thread and 	 * we need not (and can't) use the normal 	 * TimerThreadExitRequest event. 	 */
if|if
condition|(
name|GetCurrentThreadId
argument_list|()
operator|!=
name|clock_thread_id
condition|)
block|{
if|if
condition|(
operator|!
name|SetEvent
argument_list|(
name|TimerThreadExitRequest
argument_list|)
operator|||
name|WaitForSingleObject
argument_list|(
name|clock_thread
argument_list|,
literal|2
operator|*
literal|1000
argument_list|)
operator|!=
name|WAIT_OBJECT_0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to stop clock thread."
argument_list|)
expr_stmt|;
block|}
block|}
name|CloseHandle
argument_list|(
name|TimerThreadExitRequest
argument_list|)
expr_stmt|;
name|TimerThreadExitRequest
operator|=
name|NULL
expr_stmt|;
name|CloseHandle
argument_list|(
name|clock_thread
argument_list|)
expr_stmt|;
name|clock_thread
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lock_thread_to_processor
parameter_list|(
name|HANDLE
name|thread
parameter_list|)
block|{
specifier|static
name|DWORD_PTR
name|ProcessAffinityMask
decl_stmt|;
specifier|static
name|DWORD_PTR
name|ThreadAffinityMask
decl_stmt|;
name|DWORD_PTR
name|SystemAffinityMask
decl_stmt|;
name|char
modifier|*
name|cputext
decl_stmt|;
name|unsigned
name|int
name|cpu
decl_stmt|;
if|if
condition|(
operator|!
name|winnt_time_initialized
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"init_winnt_time() must be called before "
literal|"lock_thread_to_processor(), exiting\n"
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|winnt_use_interpolation
condition|)
return|return;
if|if
condition|(
operator|-
literal|1
operator|==
name|lock_interp_threads
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"choose_interp_counter() is not called "
literal|"before lock_thread_to_processor()\n"
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|lock_interp_threads
condition|)
return|return;
comment|/* 	 * Calculate the ThreadAffinityMask we'll use once on the 	 * first invocation. 	 */
if|if
condition|(
operator|!
name|ProcessAffinityMask
condition|)
block|{
comment|/* 		 * Choose which processor to nail the main and clock threads to. 		 * If we have more than one, we simply choose the 2nd. 		 * Randomly choosing from 2 to n would be better, but in 		 * either case with clock and network interrupts more likely 		 * to be serviced by the first procecssor, let's stay away  		 * from it.  QueryPerformanceCounter is not necessarily 		 * consistent across CPUs, hence the need to nail the two 		 * threads involved in QPC-based interpolation to the same 		 * CPU. 		 */
name|GetProcessAffinityMask
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|ProcessAffinityMask
argument_list|,
operator|&
name|SystemAffinityMask
argument_list|)
expr_stmt|;
comment|/* 		 * respect NTPD_CPU environment variable if present 		 * for testing.  NTPD_CPU=0 means use all CPUs, 1-64 		 * means lock threads involved in interpolation to 		 * that CPU.  Default to 2nd if more than 1. 		 */
name|cpu
operator|=
literal|2
expr_stmt|;
name|cputext
operator|=
name|getenv
argument_list|(
literal|"NTPD_CPU"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cputext
condition|)
block|{
name|cpu
operator|=
operator|(
name|unsigned
name|int
operator|)
name|atoi
argument_list|(
name|cputext
argument_list|)
expr_stmt|;
name|cpu
operator|=
name|min
argument_list|(
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|DWORD_PTR
argument_list|)
operator|)
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
comment|/*  		 * Clear all bits except the 2nd.  If we have only one proc 		 * that leaves ThreadAffinityMask zeroed and we won't bother 		 * with SetThreadAffinityMask. 		 */
name|ThreadAffinityMask
operator|=
operator|(
literal|0
operator|==
name|cpu
operator|)
condition|?
literal|0
else|:
operator|(
literal|1
operator|<<
operator|(
name|cpu
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ThreadAffinityMask
operator|&&
operator|!
operator|(
name|ThreadAffinityMask
operator|&
name|ProcessAffinityMask
operator|)
condition|)
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Selected CPU %u (mask %x) is outside "
literal|"process mask %x, using all CPUs.\n"
operator|,
name|cpu
operator|,
name|ThreadAffinityMask
operator|,
name|ProcessAffinityMask
operator|)
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Wiring to processor %u (0 means all) "
literal|"affinity mask %x\n"
operator|,
name|cpu
operator|,
name|ThreadAffinityMask
operator|)
argument_list|)
expr_stmt|;
name|ThreadAffinityMask
operator|&=
name|ProcessAffinityMask
expr_stmt|;
block|}
if|if
condition|(
name|ThreadAffinityMask
operator|&&
operator|!
name|SetThreadAffinityMask
argument_list|(
name|thread
argument_list|,
name|ThreadAffinityMask
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to wire thread to mask %x: %m"
argument_list|,
name|ThreadAffinityMask
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PPSAPI
end_ifdef

begin_function_decl
specifier|static
specifier|inline
name|void
name|ntp_timestamp_from_counter
parameter_list|(
name|l_fp
modifier|*
parameter_list|,
name|ULONGLONG
parameter_list|,
name|ULONGLONG
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * helper routine for serial PPS which returns QueryPerformanceCounter  * timestamp and needs to interpolate it to an NTP timestamp.  */
end_comment

begin_function
name|void
name|pps_ntp_timestamp_from_counter
parameter_list|(
name|ntp_fp_t
modifier|*
name|result
parameter_list|,
name|ULONGLONG
name|Timestamp
parameter_list|,
name|ULONGLONG
name|Counterstamp
parameter_list|)
block|{
comment|/* 	 * convert between equivalent l_fp and PPSAPI ntp_fp_t 	 */
name|ntp_timestamp_from_counter
argument_list|(
operator|(
name|l_fp
operator|*
operator|)
name|result
argument_list|,
name|Timestamp
argument_list|,
name|Counterstamp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ntp_timestamp_from_counter
parameter_list|(
name|l_fp
modifier|*
name|result
parameter_list|,
name|ULONGLONG
name|Timestamp
parameter_list|,
name|ULONGLONG
name|Counterstamp
parameter_list|)
block|{
name|FT_ULL
name|Now
decl_stmt|;
name|FT_ULL
name|Ctr
decl_stmt|;
name|LONGLONG
name|CtrDelta
decl_stmt|;
name|double
name|seconds
decl_stmt|;
name|ULONGLONG
name|InterpTimestamp
decl_stmt|;
if|if
condition|(
name|winnt_use_interpolation
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|Counterstamp
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"ntp_timestamp_from_counter rejecting 0 counter.\n"
operator|)
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
operator|*
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
name|InterpTimestamp
operator|=
name|interp_time
argument_list|(
name|Counterstamp
operator|+
name|QPC_offset
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ! winnt_use_interpolation */
if|if
condition|(
name|NULL
operator|!=
name|pGetSystemTimePreciseAsFileTime
operator|&&
literal|0
operator|!=
name|Counterstamp
condition|)
block|{
name|QueryPerformanceCounter
argument_list|(
operator|&
name|Ctr
operator|.
name|li
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGetSystemTimePreciseAsFileTime
call|)
argument_list|(
operator|&
name|Now
operator|.
name|ft
argument_list|)
expr_stmt|;
name|CtrDelta
operator|=
name|Ctr
operator|.
name|ull
operator|-
name|Counterstamp
expr_stmt|;
name|seconds
operator|=
operator|(
name|double
operator|)
name|CtrDelta
operator|/
name|PerfCtrFreq
expr_stmt|;
name|InterpTimestamp
operator|=
name|Now
operator|.
name|ull
operator|-
call|(
name|ULONGLONG
call|)
argument_list|(
name|seconds
operator|*
name|HECTONANOSECONDS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* have to simply use the driver's system time timestamp */
name|InterpTimestamp
operator|=
name|Timestamp
expr_stmt|;
name|GetSystemTimeAsFileTime
argument_list|(
operator|&
name|Now
operator|.
name|ft
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* convert from 100ns units to NTP fixed point format */
name|InterpTimestamp
operator|-=
name|FILETIME_1970
expr_stmt|;
name|result
operator|->
name|l_ui
operator|=
name|JAN_1970
operator|+
call|(
name|u_int32
call|)
argument_list|(
name|InterpTimestamp
operator|/
name|HECTONANOSECONDS
argument_list|)
expr_stmt|;
name|result
operator|->
name|l_uf
operator|=
call|(
name|u_int32
call|)
argument_list|(
operator|(
name|InterpTimestamp
operator|%
name|HECTONANOSECONDS
operator|)
operator|*
operator|(
name|ULONGLONG
operator|)
name|FRAC
operator|/
name|HECTONANOSECONDS
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PPSAPI */
end_comment

begin_function
name|void
name|win_time_stepped
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * called back by ntp_set_tod after the system 	 * time has been stepped (set). 	 * 	 * We normally prevent the reported time from going backwards 	 * but need to allow it in this case. 	 */
if|if
condition|(
name|FALSE
operator|==
name|winnt_use_interpolation
condition|)
return|return;
comment|/* 	 * Restart the clock thread to get a new baseline 	 * time/counter correlation. 	 */
name|StopClockThread
argument_list|()
expr_stmt|;
comment|/* 	 * newest_baseline_gen is a generation counter 	 * incremented once each time newest_baseline 	 * is reset. 	 */
name|newest_baseline_gen
operator|++
expr_stmt|;
name|clock_backward_max
operator|=
name|CLOCK_BACK_THRESHOLD
expr_stmt|;
name|clock_backward_count
operator|=
literal|0
expr_stmt|;
name|newest_baseline
operator|=
literal|0
expr_stmt|;
name|ZERO
argument_list|(
name|baseline_counts
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|baseline_times
argument_list|)
expr_stmt|;
name|StartClockThread
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * log2ull - log base 2 of a unsigned 64-bit number  */
end_comment

begin_function
name|int
name|log2ull
parameter_list|(
name|ULONGLONG
name|n
parameter_list|)
block|{
specifier|const
name|ULONGLONG
name|one
init|=
literal|1
decl_stmt|;
name|int
name|log
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|n
operator|>=
name|one
operator|<<
literal|32
condition|)
block|{
name|n
operator|>>=
literal|32
expr_stmt|;
name|log
operator|+=
literal|32
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
name|one
operator|<<
literal|16
condition|)
block|{
name|n
operator|>>=
literal|16
expr_stmt|;
name|log
operator|+=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
name|one
operator|<<
literal|8
condition|)
block|{
name|n
operator|>>=
literal|8
expr_stmt|;
name|log
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
name|one
operator|<<
literal|4
condition|)
block|{
name|n
operator|>>=
literal|4
expr_stmt|;
name|log
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
name|one
operator|<<
literal|2
condition|)
block|{
name|n
operator|>>=
literal|2
expr_stmt|;
name|log
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
name|one
operator|<<
literal|1
condition|)
block|{
name|log
operator|+=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
condition|?
name|log
else|:
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ctr_freq_timer_fired is called once a few seconds before  * tune_ctr_period seconds have elapsed, to reset the timer  * and hopefully minimize error due to the system using the  * nominal performance counter frequency to set the timer  * internally, which is typically dozens of PPM from the  * actual performance counter rate.  A few seconds later  * it is called again to observe the counter and estimate the  * counter frequency.  */
end_comment

begin_function
specifier|static
name|void
name|CALLBACK
name|ctr_freq_timer_fired
parameter_list|(
name|LPVOID
name|arg
parameter_list|,
name|DWORD
name|dwTimeLow
parameter_list|,
name|DWORD
name|dwTimeHigh
parameter_list|)
block|{
specifier|static
name|FT_ULL
name|begin_time
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|static
name|FT_ULL
name|begin_count
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|static
name|ULONGLONG
name|next_period_time
init|=
literal|0
decl_stmt|;
specifier|static
name|ULONGLONG
name|report_systemtime
init|=
literal|0
decl_stmt|;
specifier|const
name|ULONGLONG
name|five_minutes
init|=
literal|5ui64
operator|*
literal|60
operator|*
name|HECTONANOSECONDS
decl_stmt|;
name|FT_ULL
name|now_time
decl_stmt|;
name|FT_ULL
name|now_count
decl_stmt|;
if|if
condition|(
operator|!
name|begin_time
operator|.
name|ull
condition|)
block|{
name|begin_count
operator|.
name|ull
operator|=
name|perf_ctr
argument_list|()
expr_stmt|;
name|begin_time
operator|.
name|ft
operator|.
name|dwLowDateTime
operator|=
name|dwTimeLow
expr_stmt|;
name|begin_time
operator|.
name|ft
operator|.
name|dwHighDateTime
operator|=
name|dwTimeHigh
expr_stmt|;
comment|/* 		 * adapt perf ctr observation interval to the 		 * counter frequency 		 */
name|tune_ctr_period
operator|=
literal|22680
operator|/
name|log2ull
argument_list|(
name|NomPerfCtrFreq
argument_list|)
expr_stmt|;
comment|/* 		 * reset timer 2s before period ends to minimize 		 * error from OS timer routines using nominal  		 * performance frequency internally. 		 */
name|tune_ctr_freq_max_interval
operator|=
name|tune_ctr_period
operator|-
literal|2
expr_stmt|;
name|next_period_time
operator|=
name|begin_time
operator|.
name|ull
operator|+
operator|(
name|ULONGLONG
operator|)
name|tune_ctr_period
operator|*
name|HECTONANOSECONDS
expr_stmt|;
name|ROUND_TO_NEXT_SEC_BOTTOM
argument_list|(
name|next_period_time
argument_list|)
expr_stmt|;
name|reset_ctr_freq_timer
argument_list|(
name|next_period_time
argument_list|,
name|begin_time
operator|.
name|ull
argument_list|)
expr_stmt|;
return|return;
block|}
name|now_time
operator|.
name|ft
operator|.
name|dwLowDateTime
operator|=
name|dwTimeLow
expr_stmt|;
name|now_time
operator|.
name|ft
operator|.
name|dwHighDateTime
operator|=
name|dwTimeHigh
expr_stmt|;
if|if
condition|(
name|now_time
operator|.
name|ull
operator|>=
name|next_period_time
condition|)
block|{
name|now_count
operator|.
name|ull
operator|=
name|perf_ctr
argument_list|()
expr_stmt|;
name|tune_ctr_freq
argument_list|(
name|now_count
operator|.
name|ull
operator|-
name|begin_count
operator|.
name|ull
argument_list|,
name|now_time
operator|.
name|ull
operator|-
name|begin_time
operator|.
name|ull
argument_list|)
expr_stmt|;
name|next_period_time
operator|+=
operator|(
name|ULONGLONG
operator|)
name|tune_ctr_period
operator|*
name|HECTONANOSECONDS
expr_stmt|;
name|begin_count
operator|.
name|ull
operator|=
name|now_count
operator|.
name|ull
expr_stmt|;
name|begin_time
operator|.
name|ull
operator|=
name|now_time
operator|.
name|ull
expr_stmt|;
block|}
comment|/*  	 * Log clock backward events no more often than 5 minutes. 	 */
if|if
condition|(
operator|!
name|report_systemtime
condition|)
block|{
name|report_systemtime
operator|=
name|now_time
operator|.
name|ull
operator|+
name|five_minutes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|report_systemtime
operator|<=
name|now_time
operator|.
name|ull
condition|)
block|{
name|report_systemtime
operator|+=
name|five_minutes
expr_stmt|;
if|if
condition|(
name|clock_backward_count
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"clock would have gone backward %d times, "
literal|"max %.1f usec"
argument_list|,
name|clock_backward_count
argument_list|,
name|clock_backward_max
operator|/
literal|10.
argument_list|)
expr_stmt|;
name|clock_backward_max
operator|=
name|CLOCK_BACK_THRESHOLD
expr_stmt|;
name|clock_backward_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|reset_ctr_freq_timer
argument_list|(
name|next_period_time
argument_list|,
name|now_time
operator|.
name|ull
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reset_ctr_freq_timer_abs
parameter_list|(
name|ULONGLONG
name|when
parameter_list|)
block|{
name|FT_ULL
name|fire_time
decl_stmt|;
name|fire_time
operator|.
name|ull
operator|=
name|when
expr_stmt|;
name|SetWaitableTimer
argument_list|(
name|ctr_freq_timer
argument_list|,
operator|&
name|fire_time
operator|.
name|li
argument_list|,
comment|/* first fire */
literal|0
argument_list|,
comment|/* not periodic */
name|ctr_freq_timer_fired
argument_list|,
comment|/* callback routine */
name|NULL
argument_list|,
comment|/* context for callback */
name|FALSE
argument_list|)
expr_stmt|;
comment|/* do not interfere with power saving */
block|}
end_function

begin_function
name|void
name|reset_ctr_freq_timer
parameter_list|(
name|ULONGLONG
name|when
parameter_list|,
name|ULONGLONG
name|now
parameter_list|)
block|{
if|if
condition|(
name|when
operator|-
name|now
operator|>
operator|(
name|tune_ctr_freq_max_interval
operator|*
name|HECTONANOSECONDS
operator|+
name|HECTONANOSECONDS
operator|)
condition|)
name|when
operator|=
name|now
operator|+
name|tune_ctr_freq_max_interval
operator|*
name|HECTONANOSECONDS
expr_stmt|;
name|reset_ctr_freq_timer_abs
argument_list|(
name|when
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|start_ctr_freq_timer
parameter_list|(
name|ULONGLONG
name|now_time
parameter_list|)
block|{
name|ULONGLONG
name|when
decl_stmt|;
name|ctr_freq_timer
operator|=
name|CreateWaitableTimer
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|when
operator|=
name|now_time
expr_stmt|;
name|ROUND_TO_NEXT_SEC_BOTTOM
argument_list|(
name|when
argument_list|)
expr_stmt|;
name|reset_ctr_freq_timer_abs
argument_list|(
name|when
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * tune_ctr_freq is called once per tune_ctr_period seconds  * with a counter difference and time difference.  */
end_comment

begin_function
name|void
name|tune_ctr_freq
parameter_list|(
name|LONGLONG
name|ctr_delta
parameter_list|,
name|LONGLONG
name|time_delta
parameter_list|)
block|{
specifier|static
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|dispcount
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|report_at_count
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|disbelieved
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|static
name|double
name|nom_freq
init|=
literal|0
decl_stmt|;
specifier|static
name|LONGLONG
name|diffs
index|[
name|TUNE_CTR_DEPTH
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|static
name|LONGLONG
name|sum
init|=
literal|0
decl_stmt|;
name|char
name|ctr_freq_eq
index|[
literal|64
index|]
decl_stmt|;
name|LONGLONG
name|delta
decl_stmt|;
name|LONGLONG
name|deltadiff
decl_stmt|;
name|ULONGLONG
name|ObsPerfCtrFreq
decl_stmt|;
name|double
name|freq
decl_stmt|;
name|double
name|this_freq
decl_stmt|;
name|BOOL
name|isneg
decl_stmt|;
comment|/* one-time initialization */
if|if
condition|(
operator|!
name|report_at_count
condition|)
block|{
name|report_at_count
operator|=
literal|24
operator|*
literal|60
operator|*
literal|60
operator|/
name|tune_ctr_period
expr_stmt|;
name|nom_freq
operator|=
name|NomPerfCtrFreq
operator|/
literal|1e6
expr_stmt|;
block|}
comment|/* delta is the per-second observed frequency this time */
name|delta
operator|=
call|(
name|LONGLONG
call|)
argument_list|(
operator|(
name|double
operator|)
name|ctr_delta
operator|*
name|HECTONANOSECONDS
operator|/
name|time_delta
argument_list|)
expr_stmt|;
comment|/* disbelieve any delta more than +/- 976 PPM from nominal */
name|deltadiff
operator|=
name|delta
operator|-
name|NomPerfCtrFreq
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|deltadiff
condition|)
block|{
name|isneg
operator|=
name|TRUE
expr_stmt|;
name|deltadiff
operator|=
operator|-
name|deltadiff
expr_stmt|;
block|}
else|else
block|{
name|isneg
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ULONGLONG
operator|)
name|deltadiff
operator|>
operator|(
name|NomPerfCtrFreq
operator|/
literal|1024
operator|)
condition|)
block|{
name|disbelieved
operator|++
expr_stmt|;
name|dispcount
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ctr delta %s%lld exceeds limit %llu"
argument_list|,
operator|(
name|isneg
operator|)
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|deltadiff
argument_list|,
name|NomPerfCtrFreq
operator|/
literal|1024
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 * collect average over TUNE_CTR_DEPTH samples 		 * for our PerfCtrFreq trimming. 		 */
if|if
condition|(
name|isneg
condition|)
name|deltadiff
operator|=
operator|-
name|deltadiff
expr_stmt|;
name|sum
operator|-=
name|diffs
index|[
name|i
index|]
expr_stmt|;
name|diffs
index|[
name|i
index|]
operator|=
name|deltadiff
expr_stmt|;
name|sum
operator|+=
name|deltadiff
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|COUNTOF
argument_list|(
name|diffs
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|dispcount
operator|++
expr_stmt|;
block|}
name|this_freq
operator|=
name|delta
operator|/
literal|1e6
expr_stmt|;
name|ObsPerfCtrFreq
operator|=
name|NomPerfCtrFreq
operator|+
operator|(
name|sum
operator|/
name|COUNTOF
argument_list|(
name|diffs
argument_list|)
operator|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* #if 0 to disable changing freq used */
comment|/* get rid of ObsPerfCtrFreq when removing the #ifdef */
name|PerfCtrFreq
operator|=
name|ObsPerfCtrFreq
expr_stmt|;
endif|#
directive|endif
name|freq
operator|=
name|PerfCtrFreq
operator|/
literal|1e6
expr_stmt|;
comment|/* 	 * make the performance counter's frequency error from its 	 * nominal rate, expressed in PPM, available via ntpq as 	 * system variable "ctr_frequency".  This is consistent with 	 * "frequency" which is the system clock drift in PPM. 	 */
name|snprintf
argument_list|(
name|ctr_freq_eq
argument_list|,
sizeof|sizeof
argument_list|(
name|ctr_freq_eq
argument_list|)
argument_list|,
literal|"ctr_frequency=%.2f"
argument_list|,
literal|1e6
operator|*
operator|(
name|freq
operator|-
name|nom_freq
operator|)
operator|/
name|nom_freq
argument_list|)
expr_stmt|;
name|set_sys_var
argument_list|(
name|ctr_freq_eq
argument_list|,
name|strlen
argument_list|(
name|ctr_freq_eq
argument_list|)
operator|+
literal|1
argument_list|,
name|RO
operator||
name|DEF
argument_list|)
expr_stmt|;
comment|/*  	 * report observed ctr freq each time the estimate used during 	 * startup moves toward the observed freq from the nominal. 	 */
if|if
condition|(
name|count
operator|>
name|COUNTOF
argument_list|(
name|diffs
argument_list|)
operator|&&
comment|/* (count % COUNTOF(diffs))&& */
comment|/* enables reporting each */
name|dispcount
operator|<
name|report_at_count
condition|)
comment|/* TUNE_CTR_DEPTH samples */
return|return;
name|NLOG
argument_list|(
argument|NLOG_CLOCKINFO
argument_list|)
if|if
condition|(
name|count
operator|<=
name|COUNTOF
argument_list|(
name|diffs
argument_list|)
condition|)
comment|/* moving to observed freq. from nominal (startup) */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
operator|(
name|freq
operator|>
literal|100
operator|)
condition|?
literal|"ctr %.3f MHz %+6.2f PPM using %.3f MHz %+6.2f PPM"
else|:
literal|"ctr %.6f MHz %+6.2f PPM using %.6f MHz %+6.2f PPM"
argument_list|,
name|this_freq
argument_list|,
literal|1e6
operator|*
operator|(
name|this_freq
operator|-
name|nom_freq
operator|)
operator|/
name|nom_freq
argument_list|,
name|freq
argument_list|,
literal|1e6
operator|*
operator|(
name|freq
operator|-
name|nom_freq
operator|)
operator|/
name|nom_freq
argument_list|)
expr_stmt|;
else|else
comment|/* steady state */
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
operator|(
name|freq
operator|>
literal|100
operator|)
condition|?
literal|"ctr %.3f MHz %+.2f PPM"
else|:
literal|"ctr %.6f MHz %+.2f PPM"
argument_list|,
name|freq
argument_list|,
literal|1e6
operator|*
operator|(
name|freq
operator|-
name|nom_freq
operator|)
operator|/
name|nom_freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|disbelieved
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%d ctr samples exceed +/- 976 PPM range gate"
argument_list|,
name|disbelieved
argument_list|)
expr_stmt|;
name|disbelieved
operator|=
literal|0
expr_stmt|;
block|}
name|dispcount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * add_counter_time_pair is called by the  * high priority clock thread with each new  * baseline counter/time correlation.  */
end_comment

begin_function
name|void
name|add_counter_time_pair
parameter_list|(
name|ULONGLONG
name|ctr
parameter_list|,
name|LONGLONG
name|time
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|newest_baseline
operator|+
literal|1
operator|)
operator|%
name|BASELINES_TOT
expr_stmt|;
name|baseline_counts
index|[
name|i
index|]
operator|=
name|ctr
expr_stmt|;
name|baseline_times
index|[
name|i
index|]
operator|=
name|time
expr_stmt|;
name|newest_baseline
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * interp_time estimates NT time in 100ns units  * based on a performance counter value given.  * This must tolerate recent historical counters  * as well as current.  When current is FALSE  * we can't assume ctr is the latest/highest  * seen.  */
end_comment

begin_function
name|ULONGLONG
name|interp_time
parameter_list|(
name|ULONGLONG
name|ctr
parameter_list|,
name|BOOL
name|current
parameter_list|)
block|{
specifier|static
name|__declspec
argument_list|(
argument|thread
argument_list|)
name|int
name|last_newest
operator|=
operator|-
literal|1
expr_stmt|;
specifier|static
name|__declspec
argument_list|(
argument|thread
argument_list|)
name|int
name|last_newest_gen
expr_stmt|;
specifier|static
name|__declspec
argument_list|(
argument|thread
argument_list|)
name|int
name|best_index
expr_stmt|;
name|ULONGLONG
name|this_ctr
decl_stmt|;
name|LONGLONG
name|this_time
decl_stmt|;
name|LONGLONG
name|latest_time
decl_stmt|;
name|LONGLONG
name|ctr_diff
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|i_gen
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* 	 * Use the system time (roughly synchronised to the tick, and 	 * extrapolated using the system performance counter. 	 * 	 * Cache the results per thread and only repeat the 	 * calculation when new data has arrived. 	 */
name|i
operator|=
name|newest_baseline
expr_stmt|;
name|i_gen
operator|=
name|newest_baseline_gen
expr_stmt|;
if|if
condition|(
name|last_newest
operator|==
name|i
operator|&&
name|last_newest_gen
operator|==
name|i_gen
condition|)
block|{
name|this_time
operator|=
name|baseline_times
index|[
name|best_index
index|]
expr_stmt|;
name|ctr_diff
operator|=
name|ctr
operator|-
name|baseline_counts
index|[
name|best_index
index|]
expr_stmt|;
name|this_time
operator|+=
operator|(
name|LONGLONG
operator|)
name|PERF2HNS
argument_list|(
operator|(
name|double
operator|)
name|ctr_diff
argument_list|)
expr_stmt|;
return|return
name|this_time
return|;
block|}
name|last_newest
operator|=
name|i
expr_stmt|;
name|last_newest_gen
operator|=
name|i_gen
expr_stmt|;
name|latest_time
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Run through the history calculating the interpolated  	 * time based on each counter/time correlation in turn, 	 * and believe the latest one.  This is akin to the NTP 	 * protocol minimum delay clock filter.  Errors due to  	 * counter/time correlations with stale time are all  	 * negative. 	 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|BASELINES_USED
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|baseline_times
index|[
name|i
index|]
condition|)
block|{
name|this_time
operator|=
name|baseline_times
index|[
name|i
index|]
expr_stmt|;
name|this_ctr
operator|=
name|baseline_counts
index|[
name|i
index|]
expr_stmt|;
name|ctr_diff
operator|=
name|ctr
operator|-
name|this_ctr
expr_stmt|;
if|if
condition|(
name|current
operator|&&
name|ctr_diff
operator|<
literal|0
condition|)
block|{
comment|/*  				 * The performance counter apparently went  				 * backwards without rolling over.  It might  				 * be nice to complain but we don't want  				 * to do it repeatedly. 				 */
name|ctr_diff
operator|=
literal|0
expr_stmt|;
block|}
name|this_time
operator|+=
operator|(
name|LONGLONG
operator|)
name|PERF2HNS
argument_list|(
operator|(
name|double
operator|)
name|ctr_diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_time
operator|>
name|latest_time
condition|)
block|{
name|latest_time
operator|=
name|this_time
expr_stmt|;
name|best_index
operator|=
name|i
expr_stmt|;
block|}
block|}
name|i
operator|=
name|i
condition|?
operator|(
name|i
operator|-
literal|1
operator|)
else|:
operator|(
name|BASELINES_TOT
operator|-
literal|1
operator|)
expr_stmt|;
block|}
return|return
name|latest_time
return|;
block|}
end_function

end_unit

