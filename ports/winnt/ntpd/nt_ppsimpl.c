begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * nt_ppsimpl.c - PPS API client implementation  *  * Written by Juergen Perlinger (perlinger@ntp.org) for the NTP project.  * The contents of 'html/copyright.html' apply.  * ----------------------------------------------------------------------  * Most of this code is from the the original 'timepps.h' for windows  * where these functions where coded as 'inline'. While this was perhaps  * a convenient thing to do, using this amount of code as 'static inline'  * functions is generally a Bad Idea (tm).  *  * Not to mention that there are some static variables that got duplicated  * into the various modules...  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* offsetof() */
end_comment

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_comment
comment|/* _get_osfhandle() */
end_comment

begin_include
include|#
directive|include
file|"timepps.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"lib_strbuf.h"
end_include

begin_include
include|#
directive|include
file|"ntp_iocpltypes.h"
end_include

begin_include
include|#
directive|include
file|"ntp_iocplmem.h"
end_include

begin_struct
struct|struct
name|InstListNode
block|{
name|struct
name|InstListNode
modifier|*
name|next
decl_stmt|;
name|pps_handle_t
name|ppsu
decl_stmt|;
name|DevCtx_t
modifier|*
name|devu
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ProvListNode
name|ProvListNode_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|InstListNode
modifier|*
name|g_active_units
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ppsapi_provider
modifier|*
name|g_provider_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ppsapi_provider
modifier|*
name|g_curr_provider
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ppsu_register
parameter_list|(
name|pps_handle_t
name|ppsu
parameter_list|,
name|DevCtx_t
modifier|*
name|devu
parameter_list|)
block|{
name|struct
name|InstListNode
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|devu
operator|&&
operator|(
name|node
operator|=
name|IOCPLPoolAlloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|,
literal|"PPS registration"
argument_list|)
operator|)
condition|)
block|{
name|node
operator|->
name|next
operator|=
name|g_active_units
expr_stmt|;
name|node
operator|->
name|ppsu
operator|=
name|ppsu
expr_stmt|;
name|node
operator|->
name|devu
operator|=
name|DevCtxAttach
argument_list|(
name|devu
argument_list|)
expr_stmt|;
name|devu
operator|->
name|pps_active
operator|=
name|TRUE
expr_stmt|;
name|g_active_units
operator|=
name|node
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ppsu_remove
parameter_list|(
name|pps_handle_t
name|ppsu
parameter_list|)
block|{
name|struct
name|InstListNode
modifier|*
modifier|*
name|link
decl_stmt|;
name|struct
name|InstListNode
modifier|*
name|node
decl_stmt|;
name|link
operator|=
operator|&
name|g_active_units
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|node
operator|=
operator|*
name|link
operator|)
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|ppsu
operator|==
name|ppsu
condition|)
block|{
name|node
operator|->
name|devu
operator|->
name|pps_active
operator|=
name|FALSE
expr_stmt|;
name|DevCtxDetach
argument_list|(
name|node
operator|->
name|devu
argument_list|)
expr_stmt|;
operator|*
name|link
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|IOCPLPoolFree
argument_list|(
name|node
argument_list|,
literal|"PPS registration"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|link
operator|=
operator|&
name|node
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|HKEY
name|myRegOpenKey
parameter_list|(
specifier|const
name|char
modifier|*
name|szSubKey
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|s_RegKey
init|=
literal|"SYSTEM\\CurrentControlSet\\services\\NTP"
decl_stmt|;
name|HKEY
name|hkey1
init|=
name|NULL
decl_stmt|;
name|HKEY
name|hkey2
init|=
name|NULL
decl_stmt|;
name|DWORD
name|rc
decl_stmt|;
name|rc
operator|=
name|RegOpenKeyExA
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
name|s_RegKey
argument_list|,
literal|0
argument_list|,
name|KEY_READ
argument_list|,
operator|&
name|hkey1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ERROR_SUCCESS
operator|!=
name|rc
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|szSubKey
operator|&&
operator|*
name|szSubKey
operator|)
condition|)
return|return
name|hkey1
return|;
name|rc
operator|=
name|RegOpenKeyExA
argument_list|(
name|hkey1
argument_list|,
name|szSubKey
argument_list|,
literal|0
argument_list|,
name|KEY_READ
argument_list|,
operator|&
name|hkey2
argument_list|)
expr_stmt|;
name|RegCloseKey
argument_list|(
name|hkey1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ERROR_SUCCESS
operator|!=
name|rc
condition|)
return|return
name|NULL
return|;
return|return
name|hkey2
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|myRegReadMultiString
parameter_list|(
name|HKEY
name|hKey
parameter_list|,
specifier|const
name|char
modifier|*
name|szValue
parameter_list|,
name|DWORD
modifier|*
name|pSize
parameter_list|)
block|{
name|char
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|retv
init|=
name|NULL
decl_stmt|;
name|DWORD
name|rSize
init|=
literal|0
decl_stmt|,
name|rType
init|=
name|REG_NONE
decl_stmt|,
name|rc
decl_stmt|;
comment|/* take two turns: one to get the size, another one to malloc& read */
do|do
block|{
if|if
condition|(
name|rType
operator|!=
name|REG_NONE
condition|)
block|{
name|retv
operator|=
name|malloc
argument_list|(
name|rSize
operator|+=
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|retv
condition|)
goto|goto
name|fail
goto|;
block|}
name|rc
operator|=
name|RegQueryValueExA
argument_list|(
name|hKey
argument_list|,
name|szValue
argument_list|,
name|NULL
argument_list|,
operator|&
name|rType
argument_list|,
name|retv
argument_list|,
operator|&
name|rSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ERROR_SUCCESS
operator|!=
name|rc
operator|||
operator|(
name|REG_SZ
operator|!=
name|rType
operator|&&
name|REG_MULTI_SZ
operator|!=
name|rType
operator|)
condition|)
goto|goto
name|fail
goto|;
block|}
do|while
condition|(
name|NULL
operator|==
name|retv
condition|)
do|;
comment|/* trim trailing NULs and ensure two of them */
name|endp
operator|=
name|retv
operator|+
name|rSize
expr_stmt|;
while|while
condition|(
name|endp
operator|!=
name|retv
operator|&&
name|endp
index|[
operator|-
literal|1
index|]
condition|)
operator|--
name|endp
expr_stmt|;
if|if
condition|(
name|endp
operator|!=
name|retv
condition|)
block|{
name|endp
index|[
literal|0
index|]
operator|=
name|endp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|pSize
condition|)
operator|*
name|pSize
operator|=
call|(
name|DWORD
call|)
argument_list|(
name|endp
operator|-
name|retv
argument_list|)
expr_stmt|;
return|return
name|retv
return|;
block|}
name|fail
label|:
name|free
argument_list|(
name|retv
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|pSize
condition|)
operator|*
name|pSize
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|DWORD
name|myRegReadDWord
parameter_list|(
name|HKEY
name|hKey
parameter_list|,
specifier|const
name|char
modifier|*
name|szValue
parameter_list|,
name|DWORD
name|Default
parameter_list|)
block|{
name|DWORD
name|rc
decl_stmt|,
name|rSize
decl_stmt|,
name|rType
decl_stmt|,
name|rValue
decl_stmt|;
name|rSize
operator|=
sizeof|sizeof
argument_list|(
name|rValue
argument_list|)
expr_stmt|;
name|rc
operator|=
name|RegQueryValueExA
argument_list|(
name|hKey
argument_list|,
name|szValue
argument_list|,
name|NULL
argument_list|,
operator|&
name|rType
argument_list|,
operator|(
name|PBYTE
operator|)
operator|&
name|rValue
argument_list|,
operator|&
name|rSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ERROR_SUCCESS
operator|||
name|rSize
operator|!=
sizeof|sizeof
argument_list|(
name|rValue
argument_list|)
operator|||
name|rType
operator|!=
name|REG_DWORD
condition|)
name|rValue
operator|=
name|Default
expr_stmt|;
return|return
name|rValue
return|;
block|}
end_function

begin_function
specifier|static
name|pps_handle_t
name|internal_create_pps_handle
parameter_list|(
name|void
modifier|*
name|prov_context
parameter_list|)
block|{
name|pps_unit_t
modifier|*
name|punit
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|g_curr_provider
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"create_pps_handle: provider backend called me outside time_pps_create\n"
argument_list|)
expr_stmt|;
else|else
name|punit
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|pps_unit_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|punit
condition|)
block|{
name|punit
operator|->
name|provider
operator|=
name|g_curr_provider
expr_stmt|;
name|punit
operator|->
name|context
operator|=
name|prov_context
expr_stmt|;
name|punit
operator|->
name|magic
operator|=
name|PPSAPI_MAGIC_UNIT
expr_stmt|;
block|}
return|return
operator|(
name|pps_handle_t
operator|)
name|punit
return|;
block|}
end_function

begin_function
specifier|static
name|pps_unit_t
modifier|*
name|unit_from_ppsapi_handle
parameter_list|(
name|pps_handle_t
name|handle
parameter_list|)
block|{
name|pps_unit_t
modifier|*
name|punit
init|=
operator|(
name|pps_unit_t
operator|*
operator|)
name|handle
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|punit
operator|&&
name|PPSAPI_MAGIC_UNIT
operator|==
name|punit
operator|->
name|magic
operator|)
condition|)
name|punit
operator|=
name|NULL
expr_stmt|;
return|return
name|punit
return|;
block|}
end_function

begin_comment
comment|/* ntpd on Windows only looks to errno after finding 'GetLastError()'  * returns NO_ERROR.  To accomodate its use of msyslog in portable code  * such as refclock_atom.c, this implementation always clears the  * Windows error code using 'SetLastError(NO_ERROR)' when returning an  * errno.  This is also a good idea for any non-ntpd clients as they  * should rely only the errno for PPSAPI functions.  */
end_comment

begin_function
specifier|static
name|int
name|set_pps_errno
parameter_list|(
name|int
name|e
parameter_list|)
block|{
name|SetLastError
argument_list|(
name|NO_ERROR
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*Format a Windows errro into a temporary buffer from buffer lib */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fmt_err
parameter_list|(
name|DWORD
name|ec
parameter_list|)
block|{
name|char
modifier|*
name|buff
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|endp
init|=
name|NULL
decl_stmt|;
comment|/* get buffer& format message, ensure termination */
name|LIB_GETBUF
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|FormatMessageA
argument_list|(
name|FORMAT_MESSAGE_FROM_SYSTEM
operator||
name|FORMAT_MESSAGE_IGNORE_INSERTS
argument_list|,
name|NULL
argument_list|,
name|ec
argument_list|,
name|MAKELANGID
argument_list|(
name|LANG_NEUTRAL
argument_list|,
name|SUBLANG_DEFAULT
argument_list|)
argument_list|,
name|buff
argument_list|,
name|LIB_BUFLENGTH
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|buff
index|[
name|LIB_BUFLENGTH
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* strip trailing whitespace& CR/LF stuff& the trailing dot */
name|endp
operator|=
name|buff
operator|+
name|strlen
argument_list|(
name|buff
argument_list|)
expr_stmt|;
while|while
condition|(
name|endp
operator|!=
name|buff
operator|&&
name|endp
index|[
operator|-
literal|1
index|]
operator|<=
literal|' '
condition|)
operator|--
name|endp
expr_stmt|;
if|if
condition|(
name|endp
operator|!=
name|buff
operator|&&
name|endp
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
operator|--
name|endp
expr_stmt|;
operator|*
name|endp
operator|=
literal|'\0'
expr_stmt|;
comment|/* If windows fails to format this, resort to numeric output... */
if|if
condition|(
operator|!
operator|*
name|buff
condition|)
block|{
name|snprintf
argument_list|(
name|buff
argument_list|,
name|LIB_BUFLENGTH
argument_list|,
literal|"(unknown windows error %lu / 0x%08lx)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ec
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ec
argument_list|)
expr_stmt|;
block|}
comment|/* That's it for now... */
return|return
name|buff
return|;
block|}
end_function

begin_comment
comment|/* Cleanup& error return for actual loading steps */
end_comment

begin_function
specifier|static
name|int
name|cleanup_load
parameter_list|(
name|ppsapi_provider
modifier|*
name|prov
parameter_list|,
name|HMODULE
name|hmod
parameter_list|,
name|int
name|errc
parameter_list|)
block|{
comment|/* if possible, decref the library handle */
if|if
condition|(
name|NULL
operator|!=
name|hmod
condition|)
name|FreeLibrary
argument_list|(
name|hmod
argument_list|)
expr_stmt|;
comment|/* if possible, drop our provider structure */
if|if
condition|(
name|prov
condition|)
block|{
name|free
argument_list|(
name|prov
operator|->
name|short_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prov
operator|->
name|full_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prov
argument_list|)
expr_stmt|;
block|}
comment|/* error code pass-through */
return|return
name|errc
return|;
block|}
end_function

begin_comment
comment|/* Get the directory path (!!) of the calling process. We want the true  * 8bit character version, and we should not trust '_pgmptr' or  * '_get_pgmptr()' too much. There's still some doubt around  * 'GetModuleFileNameA()', but all in all this seems to be the most  * reliable solution, even if it's a PITA with the buffer sizes.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_module_path
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|size_t
name|s_smax
init|=
literal|4096
decl_stmt|;
name|char
modifier|*
name|buff
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|lsep
decl_stmt|;
name|DWORD
name|slen
decl_stmt|,
name|nlen
decl_stmt|;
for|for
control|(
name|slen
operator|=
literal|128
init|;
name|slen
operator|<=
name|s_smax
condition|;
name|slen
operator|<<=
literal|1
control|)
block|{
name|buff
operator|=
name|realloc
argument_list|(
name|buff
argument_list|,
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|buff
condition|)
goto|goto
name|fail
goto|;
name|nlen
operator|=
name|GetModuleFileNameA
argument_list|(
name|NULL
argument_list|,
name|buff
argument_list|,
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|nlen
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|nlen
operator|<
name|slen
condition|)
break|break;
block|}
if|if
condition|(
name|slen
operator|>
name|s_smax
condition|)
goto|goto
name|fail
goto|;
name|lsep
operator|=
name|strrchr
argument_list|(
name|buff
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|lsep
condition|)
goto|goto
name|fail
goto|;
operator|*
operator|++
name|lsep
operator|=
literal|'\0'
expr_stmt|;
return|return
name|realloc
argument_list|(
name|buff
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|lsep
operator|-
name|buff
argument_list|)
operator|+
literal|1
argument_list|)
return|;
name|fail
label|:
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_provider_list
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|s_Value
init|=
name|NULL
decl_stmt|;
name|HKEY
name|hKey
decl_stmt|;
name|DWORD
name|rSize
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|op
decl_stmt|;
if|if
condition|(
name|s_Value
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|*
name|s_Value
operator|)
condition|?
name|s_Value
else|:
name|NULL
return|;
comment|/* 	** try registry first 	*/
name|hKey
operator|=
name|myRegOpenKey
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|hKey
condition|)
goto|goto
name|regfail
goto|;
name|s_Value
operator|=
name|myRegReadMultiString
argument_list|(
name|hKey
argument_list|,
literal|"PPSProviders"
argument_list|,
operator|&
name|rSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|s_Value
condition|)
goto|goto
name|regfail
goto|;
comment|/* make sure we have backslashes in the path */
for|for
control|(
name|cp
operator|=
name|s_Value
init|;
name|rSize
condition|;
operator|--
name|rSize
operator|,
operator|++
name|cp
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
operator|*
name|cp
operator|=
literal|'\\'
expr_stmt|;
name|regfail
label|:
if|if
condition|(
name|NULL
operator|!=
name|hKey
condition|)
name|RegCloseKey
argument_list|(
name|hKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_Value
operator|&&
operator|*
name|s_Value
condition|)
return|return
name|s_Value
return|;
comment|/* 	** try environment next. 	*/
name|free
argument_list|(
name|s_Value
argument_list|)
expr_stmt|;
name|s_Value
operator|=
name|NULL
expr_stmt|;
comment|/* try to get env var */
name|cp
operator|=
name|getenv
argument_list|(
literal|"PPSAPI_DLLS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|&&
operator|*
name|cp
operator|)
condition|)
goto|goto
name|envfail
goto|;
comment|/* get size& allocate buffer */
name|rSize
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|s_Value
operator|=
name|malloc
argument_list|(
name|rSize
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_Value
operator|==
name|NULL
condition|)
goto|goto
name|envfail
goto|;
comment|/* copy string value and convert to MULTI_SZ. 	 * Converts sequences of ';' to a single NUL byte, and rplaces 	 * slashes by backslashes on the fly. 	 */
for|for
control|(
name|op
operator|=
name|s_Value
init|;
operator|*
name|cp
condition|;
operator|++
name|cp
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
operator|*
name|op
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|';'
condition|)
block|{
if|if
condition|(
name|op
operator|!=
name|s_Value
operator|&&
name|op
index|[
operator|-
literal|1
index|]
condition|)
operator|*
name|op
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|op
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
block|}
block|}
name|cp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|s_Value
return|;
name|envfail
label|:
name|free
argument_list|(
name|s_Value
argument_list|)
expr_stmt|;
name|s_Value
operator|=
name|calloc
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|s_Value
return|;
block|}
end_function

begin_comment
comment|/* Iteration helper for the provider list. Naked names (without *any*  * path) will be prepended with path to the executable running this  * code. While this was not necessary until Win7, newer versions of  * Windows seem to have tighter restrictions from where to load code, at  * least as long as the binary is not signed.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|provlist_next_item
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|iter
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|s_modpath
comment|/* = NULL */
decl_stmt|;
specifier|static
name|char
name|s_nullstr
index|[
literal|1
index|]
comment|/* = { '\0' } */
decl_stmt|;
specifier|const
name|char
modifier|*
name|phead
decl_stmt|,
modifier|*
name|phold
decl_stmt|;
name|char
modifier|*
name|retv
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|int
comment|/*BOOL*/
name|nodir
decl_stmt|;
name|DWORD
name|slen
decl_stmt|,
name|mlen
decl_stmt|;
comment|/* get next item -- might be start of a new round or the end */
name|again
label|:
if|if
condition|(
operator|*
name|iter
operator|==
name|NULL
condition|)
operator|*
name|iter
operator|=
name|phead
operator|=
name|get_provider_list
argument_list|()
expr_stmt|;
else|else
operator|*
name|iter
operator|=
name|phead
operator|=
operator|*
name|iter
operator|+
name|strlen
argument_list|(
operator|*
name|iter
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|phead
operator|&&
operator|*
name|phead
operator|)
condition|)
block|{
operator|*
name|iter
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Inspect the next section of input string. It must be 	 * either an absolute path or just a name. 	 */
if|if
condition|(
name|isalpha
argument_list|(
operator|(
name|u_char
operator|)
name|phead
index|[
literal|0
index|]
argument_list|)
operator|&&
name|phead
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|phead
index|[
literal|2
index|]
operator|==
literal|'\\'
condition|)
block|{
name|nodir
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|nodir
operator|=
name|TRUE
expr_stmt|;
name|phold
operator|=
name|phead
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|endp
operator|=
name|strpbrk
argument_list|(
name|phold
argument_list|,
literal|"\\:"
argument_list|)
operator|)
condition|)
name|phold
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|phead
operator|!=
name|phold
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"pps api: path component(s) of '%s' ignored, use '%s'"
argument_list|,
name|phead
argument_list|,
name|phold
argument_list|)
expr_stmt|;
name|phead
operator|=
name|phold
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|phead
operator|||
name|strchr
argument_list|(
literal|"\\.:"
argument_list|,
operator|(
name|u_char
operator|)
name|phead
index|[
name|strlen
argument_list|(
name|phead
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|again
goto|;
comment|/* empty or looks like a directory! */
comment|/* Make sure we have a proper module path when we need one. */
if|if
condition|(
name|nodir
operator|&&
name|NULL
operator|==
name|s_modpath
condition|)
block|{
name|s_modpath
operator|=
name|get_module_path
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|s_modpath
condition|)
name|s_modpath
operator|=
name|s_nullstr
expr_stmt|;
block|}
comment|/* Prepare buffer for copy of file name. */
name|slen
operator|=
operator|(
name|DWORD
operator|)
name|strlen
argument_list|(
name|phead
argument_list|)
expr_stmt|;
comment|/* 4GB string should be enough... */
if|if
condition|(
name|nodir
operator|&&
name|NULL
operator|!=
name|s_modpath
condition|)
block|{
comment|/* Prepend full path to executable to the name. */
name|mlen
operator|=
operator|(
name|DWORD
operator|)
name|strlen
argument_list|(
name|s_modpath
argument_list|)
expr_stmt|;
name|endp
operator|=
name|retv
operator|=
name|malloc
argument_list|(
name|mlen
operator|+
name|slen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|endp
condition|)
block|{
name|memcpy
argument_list|(
name|endp
argument_list|,
name|s_modpath
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
name|endp
operator|+=
name|mlen
expr_stmt|;
block|}
block|}
else|else
block|{
name|endp
operator|=
name|retv
operator|=
name|malloc
argument_list|(
name|slen
operator|+
literal|1u
argument_list|)
expr_stmt|;
block|}
comment|/* Copy with conversion from '/' to '\\' */
if|if
condition|(
name|NULL
operator|!=
name|endp
condition|)
block|{
name|memcpy
argument_list|(
name|endp
argument_list|,
name|phead
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|endp
index|[
name|slen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|retv
return|;
block|}
end_function

begin_comment
comment|/* Try to load& init a provider DLL. (NOT a device instance!) */
end_comment

begin_function
specifier|static
name|int
name|load_pps_provider
parameter_list|(
specifier|const
name|char
modifier|*
name|dllpath
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|msgfmt
index|[]
init|=
literal|"load_pps_provider: '%s': %s"
decl_stmt|;
name|char
name|short_name
index|[
literal|16
index|]
decl_stmt|;
name|char
name|full_name
index|[
literal|64
index|]
decl_stmt|;
name|ppsapi_provider
modifier|*
name|prov
init|=
name|NULL
decl_stmt|;
name|HMODULE
name|hmod
init|=
name|NULL
decl_stmt|;
name|pppsapi_prov_init
name|pprov_init
decl_stmt|;
name|int
name|errc
decl_stmt|;
name|prov
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prov
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|prov
condition|)
block|{
name|errc
operator|=
name|errno
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|msgfmt
argument_list|,
name|dllpath
argument_list|,
name|strerror
argument_list|(
name|errc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|errc
return|;
block|}
name|hmod
operator|=
name|LoadLibraryA
argument_list|(
name|dllpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|hmod
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|msgfmt
argument_list|,
name|dllpath
argument_list|,
name|fmt_err
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cleanup_load
argument_list|(
name|prov
argument_list|,
name|hmod
argument_list|,
name|ENOENT
argument_list|)
return|;
block|}
name|pprov_init
operator|=
operator|(
name|pppsapi_prov_init
operator|)
name|GetProcAddress
argument_list|(
name|hmod
argument_list|,
literal|"ppsapi_prov_init"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pprov_init
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|msgfmt
argument_list|,
name|dllpath
argument_list|,
literal|"main entry point not found"
argument_list|)
expr_stmt|;
return|return
name|cleanup_load
argument_list|(
name|prov
argument_list|,
name|hmod
argument_list|,
name|EFAULT
argument_list|)
return|;
block|}
name|prov
operator|->
name|caps
operator|=
call|(
modifier|*
name|pprov_init
call|)
argument_list|(
name|PPSAPI_TIMEPPS_PROV_VER
argument_list|,
operator|&
name|internal_create_pps_handle
argument_list|,
operator|&
name|pps_ntp_timestamp_from_counter
argument_list|,
name|short_name
argument_list|,
sizeof|sizeof
argument_list|(
name|short_name
argument_list|)
argument_list|,
name|full_name
argument_list|,
sizeof|sizeof
argument_list|(
name|full_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prov
operator|->
name|caps
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|msgfmt
argument_list|,
name|dllpath
argument_list|,
literal|"no capabilities"
argument_list|)
expr_stmt|;
return|return
name|cleanup_load
argument_list|(
name|prov
argument_list|,
name|hmod
argument_list|,
name|EACCES
argument_list|)
return|;
block|}
name|prov
operator|->
name|short_name
operator|=
operator|(
operator|*
name|short_name
operator|)
condition|?
name|_strdup
argument_list|(
name|short_name
argument_list|)
else|:
name|NULL
expr_stmt|;
name|prov
operator|->
name|full_name
operator|=
operator|(
operator|*
name|full_name
operator|)
condition|?
name|_strdup
argument_list|(
name|full_name
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|prov
operator|->
name|short_name
operator|||
name|NULL
operator|==
name|prov
operator|->
name|full_name
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|msgfmt
argument_list|,
name|dllpath
argument_list|,
literal|"missing names"
argument_list|)
expr_stmt|;
return|return
name|cleanup_load
argument_list|(
name|prov
argument_list|,
name|hmod
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|prov
operator|->
name|ptime_pps_create
operator|=
operator|(
name|provtime_pps_create
operator|)
name|GetProcAddress
argument_list|(
name|hmod
argument_list|,
literal|"prov_time_pps_create"
argument_list|)
expr_stmt|;
name|prov
operator|->
name|ptime_pps_destroy
operator|=
operator|(
name|provtime_pps_destroy
operator|)
name|GetProcAddress
argument_list|(
name|hmod
argument_list|,
literal|"prov_time_pps_destroy"
argument_list|)
expr_stmt|;
name|prov
operator|->
name|ptime_pps_setparams
operator|=
operator|(
name|provtime_pps_setparams
operator|)
name|GetProcAddress
argument_list|(
name|hmod
argument_list|,
literal|"prov_time_pps_setparams"
argument_list|)
expr_stmt|;
name|prov
operator|->
name|ptime_pps_fetch
operator|=
operator|(
name|provtime_pps_fetch
operator|)
name|GetProcAddress
argument_list|(
name|hmod
argument_list|,
literal|"prov_time_pps_fetch"
argument_list|)
expr_stmt|;
name|prov
operator|->
name|ptime_pps_kcbind
operator|=
operator|(
name|provtime_pps_kcbind
operator|)
name|GetProcAddress
argument_list|(
name|hmod
argument_list|,
literal|"prov_time_pps_kcbind"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|prov
operator|->
name|ptime_pps_create
operator|||
name|NULL
operator|==
name|prov
operator|->
name|ptime_pps_destroy
operator|||
name|NULL
operator|==
name|prov
operator|->
name|ptime_pps_setparams
operator|||
name|NULL
operator|==
name|prov
operator|->
name|ptime_pps_fetch
operator|||
name|NULL
operator|==
name|prov
operator|->
name|ptime_pps_kcbind
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|msgfmt
argument_list|,
name|prov
operator|->
name|short_name
argument_list|,
literal|"missing entry point"
argument_list|)
expr_stmt|;
return|return
name|cleanup_load
argument_list|(
name|prov
argument_list|,
name|hmod
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|prov
operator|->
name|next
operator|=
name|g_provider_list
expr_stmt|;
name|g_provider_list
operator|=
name|prov
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|ppsapi_provider
modifier|*
name|get_first_provider
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|itpos
decl_stmt|;
name|char
modifier|*
name|dll
decl_stmt|;
name|ppsapi_provider
modifier|*
name|prov
decl_stmt|,
modifier|*
name|hold
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* check if we have done our work so far... */
if|if
condition|(
name|g_provider_list
operator|==
name|INVALID_HANDLE_VALUE
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|g_provider_list
operator|!=
name|NULL
condition|)
return|return
name|g_provider_list
return|;
name|itpos
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|dll
operator|=
name|provlist_next_item
argument_list|(
operator|&
name|itpos
argument_list|)
operator|)
condition|)
block|{
name|err
operator|=
name|load_pps_provider
argument_list|(
name|dll
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"time_pps_create: load failed (%s) --> %d / %s"
argument_list|,
name|dll
argument_list|,
name|err
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"time_pps_create: loaded '%s'"
argument_list|,
name|dll
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dll
argument_list|)
expr_stmt|;
block|}
comment|/* reverse the list, possibly mark as EMPTY */
name|prov
operator|=
name|g_provider_list
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|prov
condition|)
block|{
name|g_provider_list
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|hold
operator|=
name|prov
expr_stmt|;
name|prov
operator|=
name|hold
operator|->
name|next
expr_stmt|;
name|hold
operator|->
name|next
operator|=
name|g_provider_list
expr_stmt|;
name|g_provider_list
operator|=
name|hold
expr_stmt|;
block|}
do|while
condition|(
name|prov
condition|)
do|;
name|prov
operator|=
name|g_provider_list
expr_stmt|;
block|}
else|else
block|{
name|g_provider_list
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
block|}
return|return
name|prov
return|;
block|}
end_function

begin_function
name|int
name|time_pps_create
parameter_list|(
name|int
name|filedes
parameter_list|,
comment|/* device file descriptor */
name|pps_handle_t
modifier|*
name|phandle
comment|/* returned handle */
parameter_list|)
block|{
name|HANDLE
name|winhandle
decl_stmt|;
name|ppsapi_provider
modifier|*
name|prov
decl_stmt|;
name|pps_handle_t
name|ppshandle
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|phandle
condition|)
return|return
name|set_pps_errno
argument_list|(
name|EFAULT
argument_list|)
return|;
name|winhandle
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|filedes
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_HANDLE_VALUE
operator|==
name|winhandle
condition|)
return|return
name|set_pps_errno
argument_list|(
name|EBADF
argument_list|)
return|;
comment|/* Hand off to each provider in turn until one returns a PPS 	 * handle or they've all declined. 	 * 	 * [Bug 3139] Since we potentially tried a series of DLLs, it's 	 * a good question what the returned error should be if all of 	 * them failed; Returning the error from the last attempt is as 	 * good as any but for single DLL (which is the normal case) 	 * this provides slightly more information. 	 */
name|err
operator|=
name|ENOEXEC
expr_stmt|;
name|prov
operator|=
name|get_first_provider
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|prov
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"time_pps_create: %s"
argument_list|,
literal|"no providers available"
argument_list|)
expr_stmt|;
return|return
name|set_pps_errno
argument_list|(
name|err
argument_list|)
return|;
block|}
else|else
do|do
block|{
name|ppshandle
operator|=
literal|0
expr_stmt|;
name|g_curr_provider
operator|=
name|prov
expr_stmt|;
name|err
operator|=
call|(
modifier|*
name|prov
operator|->
name|ptime_pps_create
call|)
argument_list|(
name|winhandle
argument_list|,
operator|&
name|ppshandle
argument_list|)
expr_stmt|;
name|g_curr_provider
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|ppshandle
condition|)
block|{
operator|*
name|phandle
operator|=
name|ppshandle
expr_stmt|;
name|ppsu_register
argument_list|(
name|ppshandle
argument_list|,
name|serial_devctx
argument_list|(
name|winhandle
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"time_pps_create: provider '%s' failed: %d / %s"
argument_list|,
name|prov
operator|->
name|short_name
argument_list|,
name|err
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|NULL
operator|!=
operator|(
name|prov
operator|=
name|prov
operator|->
name|next
operator|)
condition|)
do|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"time_pps_create: %s"
argument_list|,
literal|"all providers failed"
argument_list|)
expr_stmt|;
return|return
name|set_pps_errno
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|time_pps_destroy
parameter_list|(
name|pps_handle_t
name|handle
parameter_list|)
block|{
name|pps_unit_t
modifier|*
name|punit
init|=
name|unit_from_ppsapi_handle
argument_list|(
name|handle
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* Check for valid arguments */
if|if
condition|(
name|NULL
operator|==
name|punit
condition|)
return|return
name|set_pps_errno
argument_list|(
name|EBADF
argument_list|)
return|;
comment|/* Call provider. Note the handle is gone anyway... */
name|ppsu_remove
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|err
operator|=
call|(
modifier|*
name|punit
operator|->
name|provider
operator|->
name|ptime_pps_destroy
call|)
argument_list|(
name|punit
argument_list|,
name|punit
operator|->
name|context
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|punit
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|set_pps_errno
argument_list|(
name|err
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|time_pps_setparams
parameter_list|(
name|pps_handle_t
name|handle
parameter_list|,
specifier|const
name|pps_params_t
modifier|*
name|params
parameter_list|)
block|{
name|pps_unit_t
modifier|*
name|punit
init|=
name|unit_from_ppsapi_handle
argument_list|(
name|handle
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* Check for valid arguments */
if|if
condition|(
name|NULL
operator|==
name|punit
condition|)
return|return
name|set_pps_errno
argument_list|(
name|EBADF
argument_list|)
return|;
if|if
condition|(
name|NULL
operator|==
name|params
condition|)
return|return
name|set_pps_errno
argument_list|(
name|EFAULT
argument_list|)
return|;
comment|/* Call provider */
name|err
operator|=
call|(
modifier|*
name|punit
operator|->
name|provider
operator|->
name|ptime_pps_setparams
call|)
argument_list|(
name|punit
argument_list|,
name|punit
operator|->
name|context
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|set_pps_errno
argument_list|(
name|err
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|time_pps_getparams
parameter_list|(
name|pps_handle_t
name|handle
parameter_list|,
name|pps_params_t
modifier|*
name|params_buf
parameter_list|)
block|{
name|pps_unit_t
modifier|*
name|punit
init|=
name|unit_from_ppsapi_handle
argument_list|(
name|handle
argument_list|)
decl_stmt|;
comment|/* Check for valid arguments */
name|punit
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|punit
condition|)
return|return
name|set_pps_errno
argument_list|(
name|EBADF
argument_list|)
return|;
if|if
condition|(
name|NULL
operator|==
name|params_buf
condition|)
return|return
name|set_pps_errno
argument_list|(
name|EFAULT
argument_list|)
return|;
comment|/* Copy out parameters */
operator|*
name|params_buf
operator|=
name|punit
operator|->
name|params
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|time_pps_getcap
parameter_list|(
name|pps_handle_t
name|handle
parameter_list|,
name|int
modifier|*
name|pmode
parameter_list|)
block|{
name|pps_unit_t
modifier|*
name|punit
init|=
name|unit_from_ppsapi_handle
argument_list|(
name|handle
argument_list|)
decl_stmt|;
comment|/* Check for valid arguments */
if|if
condition|(
name|NULL
operator|==
name|punit
condition|)
return|return
name|set_pps_errno
argument_list|(
name|EBADF
argument_list|)
return|;
if|if
condition|(
name|NULL
operator|==
name|pmode
condition|)
return|return
name|set_pps_errno
argument_list|(
name|EFAULT
argument_list|)
return|;
comment|/* Copy out capabilities */
operator|*
name|pmode
operator|=
name|punit
operator|->
name|provider
operator|->
name|caps
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|time_pps_fetch
parameter_list|(
name|pps_handle_t
name|handle
parameter_list|,
specifier|const
name|int
name|tsformat
parameter_list|,
name|pps_info_t
modifier|*
name|pinfo
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|ptimeout
parameter_list|)
block|{
name|pps_unit_t
modifier|*
name|punit
init|=
name|unit_from_ppsapi_handle
argument_list|(
name|handle
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* Check for valid arguments */
if|if
condition|(
name|NULL
operator|==
name|punit
condition|)
return|return
name|set_pps_errno
argument_list|(
name|EBADF
argument_list|)
return|;
if|if
condition|(
name|NULL
operator|==
name|pinfo
condition|)
return|return
name|set_pps_errno
argument_list|(
name|EFAULT
argument_list|)
return|;
comment|/* Fetch timestamps */
name|err
operator|=
call|(
modifier|*
name|punit
operator|->
name|provider
operator|->
name|ptime_pps_fetch
call|)
argument_list|(
name|punit
argument_list|,
name|punit
operator|->
name|context
argument_list|,
name|tsformat
argument_list|,
name|pinfo
argument_list|,
name|ptimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|set_pps_errno
argument_list|(
name|err
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|time_pps_kcbind
parameter_list|(
name|pps_handle_t
name|handle
parameter_list|,
specifier|const
name|int
name|kernel_consumer
parameter_list|,
specifier|const
name|int
name|edge
parameter_list|,
specifier|const
name|int
name|tsformat
parameter_list|)
block|{
name|pps_unit_t
modifier|*
name|punit
init|=
name|unit_from_ppsapi_handle
argument_list|(
name|handle
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* Check for valid arguments */
if|if
condition|(
name|NULL
operator|==
name|punit
condition|)
return|return
name|set_pps_errno
argument_list|(
name|EBADF
argument_list|)
return|;
comment|/* Call provider */
name|err
operator|=
call|(
modifier|*
name|punit
operator|->
name|provider
operator|->
name|ptime_pps_kcbind
call|)
argument_list|(
name|punit
argument_list|,
name|punit
operator|->
name|context
argument_list|,
name|kernel_consumer
argument_list|,
name|edge
argument_list|,
name|tsformat
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|set_pps_errno
argument_list|(
name|err
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* -*- that's all folks! -*- */
end_comment

end_unit

