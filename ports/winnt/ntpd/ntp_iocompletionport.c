begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ----------------------------------------------------------------------- This is the IO completion port handling for async/overlapped IO on Windows>= Win2000.  Some notes on the implementation:  + Only one thread is used to serve the IO completion port, for several   reasons:    * First, there seems to be (have been?) trouble that locked up NTPD     when more than one thread was used for IOCPL.    * Second, for the sake of the time stamp interpolation the threads     must run on the same CPU as the time interpolation thread. This     makes using more than one thread useless, as they would compete for     the same core and create contention.  + Some IO operations need a possibly lengthy post-processing. Emulating   the UN*X line discipline is currently the only but prominent example.   To avoid the processing in the time-critical IOCPL thread, longer   processing is offloaded the worker thread pool.  + A fact that seems not as well-known as it should be is that all   resources passed to an overlapped IO operation must be considered   owned by the OS until the result has been fetched/dequeued. This   includes all overlapped structures and buffers involved, so cleaning   up on shutdown must be carefully constructed. (This includes closing   all the IO handles and waiting for the results to be dequeued.   'CancleIo()' cannot be used since it's broken beyond repair.)    If this is not possible, then all resources should be dropped into   oblivion -- otherwise "bad things (tm)" are bound to happen.    Using a private heap that is silently dropped but not deleted is a   good way to avoid cluttering memory stats with IO context related   objects. Leak tracing becomes more interesting, though.   The current implementation is based on the work of Danny Mayer who improved the original implementation and Dave Hart who improved on the serial I/O routines. The true roots of this file seem to be shrouded by the mist of time...   This version still provides the 'user space PPS' emulation feature.  Juergen Perlinger (perlinger@ntp.org) Feb 2012  ----------------------------------------------------------------------- */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_IO_COMPLETION_PORT
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_request.h"
end_include

begin_include
include|#
directive|include
file|"ntp_iocompletionport.h"
end_include

begin_include
include|#
directive|include
file|"ntp_iocplmem.h"
end_include

begin_include
include|#
directive|include
file|"ntp_iocpltypes.h"
end_include

begin_define
define|#
directive|define
name|CONTAINEROF
parameter_list|(
name|p
parameter_list|,
name|type
parameter_list|,
name|member
parameter_list|)
define|\
value|((type *)((char *)(p) - offsetof(type, member)))
end_define

begin_enum
enum|enum
name|io_packet_handling
block|{
name|PKT_OK
block|,
name|PKT_DROP
block|,
name|PKT_SOCKET_ERROR
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|st_packet_handling
index|[
literal|3
index|]
init|=
block|{
literal|"accepted"
block|,
literal|"dropped"
literal|"error"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * local function definitions  */
end_comment

begin_function_decl
specifier|static
name|void
name|ntpd_addremove_semaphore
parameter_list|(
name|HANDLE
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_serial_recv_time
parameter_list|(
name|recvbuf_t
modifier|*
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Initiate/Request async IO operations */
end_comment

begin_function_decl
specifier|static
name|BOOL
name|__fastcall
name|QueueSerialWait
parameter_list|(
name|IoCtx_t
modifier|*
parameter_list|,
name|recvbuf_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOL
name|__fastcall
name|QueueSerialRead
parameter_list|(
name|IoCtx_t
modifier|*
parameter_list|,
name|recvbuf_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOL
name|__fastcall
name|QueueRawSerialRead
parameter_list|(
name|IoCtx_t
modifier|*
parameter_list|,
name|recvbuf_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOL
name|__fastcall
name|QueueSocketRecv
parameter_list|(
name|IoCtx_t
modifier|*
parameter_list|,
name|recvbuf_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* High-level IO callback functions */
end_comment

begin_function_decl
specifier|static
name|void
name|OnSocketRecv
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|OnSocketSend
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|OnSerialWaitComplete
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|OnSerialReadComplete
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|OnRawSerialReadComplete
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|OnSerialWriteComplete
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* worker pool offload functions */
end_comment

begin_function_decl
specifier|static
name|DWORD
name|WINAPI
name|OnSerialReadWorker
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* keep a list to traverse to free memory on debug builds */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|free_io_completion_port_mem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|HANDLE
name|WaitableExitEventHandle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HANDLE
name|WaitableIoEventHandle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HANDLE
name|hndIOCPLPort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HANDLE
name|hMainThread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HANDLE
name|hMainRpcDone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BOOL
name|DoPPShack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DWORD
name|ActiveWaitHandles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HANDLE
name|WaitHandles
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * -------------------------------------------------------------------  * Windows 2000 bluescreens with bugcheck 0x76 PROCESS_HAS_LOCKED_PAGES  * at ntpd process termination when using more than one pending  * receive per socket.  A runtime version test during startup will  * allow using more on newer versions of Windows.  *  * perlinger@ntp.org: Considering the quirks fixed in the overlapped  * IO handling in recent years, it could even be that this is no longer  * an issue. Testing this might be tricky -- who runs a Win2k system  * in the year 2016?  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|s_SockRecvSched
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* possibly adjusted later */
end_comment

begin_comment
comment|/*  * -------------------------------------------------------------------  * The IO completion thread and support functions  *  * There is only one completion thread, because it is locked to the same  * core as the time interpolation. Having more than one causes core  * contention and is not useful.  * -------------------------------------------------------------------  */
end_comment

begin_decl_stmt
specifier|static
name|HANDLE
name|hIoCompletionThread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UINT
name|tidCompletionThread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * The IO completion worker thread  *  * Note that this thread does not enter an alertable wait state and that  * the only waiting point is the IO completion port. If stopping this  * thread with a special queued result packet does not work,  * 'TerminateThread()' is the only remaining weapon in the arsenal. A  * dangerous weapon -- it's like SIGKILL.  */
end_comment

begin_function
specifier|static
name|unsigned
name|WINAPI
name|iocompletionthread
parameter_list|(
name|void
modifier|*
name|NotUsed
parameter_list|)
block|{
name|DWORD
name|err
decl_stmt|;
name|DWORD
name|octets
decl_stmt|;
name|ULONG_PTR
name|key
decl_stmt|;
name|OVERLAPPED
modifier|*
name|pol
decl_stmt|;
name|IoCtx_t
modifier|*
name|lpo
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|NotUsed
argument_list|)
expr_stmt|;
comment|/* Socket and refclock receive call gettimeofday() so the I/O 	 * thread needs to be on the same processor as the main and 	 * timing threads to ensure consistent QueryPerformanceCounter() 	 * results. 	 * 	 * This gets seriously into the way of efficient thread pooling 	 * on multi-core systems. 	 */
name|lock_thread_to_processor
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Set the thread priority high enough so I/O will pre-empt 	 * normal recv packet processing, but not higher than the timer 	 * sync thread. 	 */
if|if
condition|(
operator|!
name|SetThreadPriority
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|,
name|THREAD_PRIORITY_ABOVE_NORMAL
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't set thread priority: %m"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|GetQueuedCompletionStatus
argument_list|(
name|hndIOCPLPort
argument_list|,
operator|&
name|octets
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|pol
argument_list|,
name|INFINITE
argument_list|)
condition|)
block|{
name|err
operator|=
name|ERROR_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pol
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"Overlapped IO Thread Exiting\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* fail */
block|}
name|lpo
operator|=
name|CONTAINEROF
argument_list|(
name|pol
argument_list|,
name|IoCtx_t
argument_list|,
name|ol
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
argument_list|)
expr_stmt|;
name|lpo
operator|->
name|byteCount
operator|=
name|octets
expr_stmt|;
name|lpo
operator|->
name|errCode
operator|=
name|err
expr_stmt|;
name|handler_calls
operator|++
expr_stmt|;
call|(
modifier|*
name|lpo
operator|->
name|onIoDone
call|)
argument_list|(
name|key
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Create/initialise the I/O creation port  */
end_comment

begin_function
name|void
name|init_io_completion_port
parameter_list|(
name|void
parameter_list|)
block|{
name|OSVERSIONINFO
name|vi
decl_stmt|;
specifier|const
name|char
modifier|*
name|envp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|atexit
argument_list|(
operator|&
name|free_io_completion_port_mem
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TODO: this should not be done via environment; 	 * It would be much better to have this as proper config option. 	 * (The same is true for the PPS API DLL list...) 	 */
if|if
condition|(
name|NULL
operator|!=
operator|(
name|envp
operator|=
name|getenv
argument_list|(
literal|"PPSAPI_HACK"
argument_list|)
operator|)
condition|)
comment|/* check for [Tt]{rue}, [Yy]{es}, or '1' as first char*/
name|DoPPShack
operator|=
operator|!
operator|!
name|strchr
argument_list|(
literal|"yYtT1"
argument_list|,
operator|(
name|u_char
operator|)
operator|*
name|envp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|NULL
operator|!=
operator|(
name|envp
operator|=
name|getenv
argument_list|(
literal|"PPSAPI_DLLS"
argument_list|)
operator|)
condition|)
comment|/* any non-empty list disables PPS hack */
name|DoPPShack
operator|=
operator|!
operator|*
name|envp
expr_stmt|;
else|else
comment|/* otherwise use the PPS hack */
name|DoPPShack
operator|=
name|TRUE
expr_stmt|;
name|memset
argument_list|(
operator|&
name|vi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vi
argument_list|)
argument_list|)
expr_stmt|;
name|vi
operator|.
name|dwOSVersionInfoSize
operator|=
sizeof|sizeof
argument_list|(
name|vi
argument_list|)
expr_stmt|;
comment|/* For windows 7 and above, schedule more than one receive */
if|if
condition|(
name|GetVersionEx
argument_list|(
operator|&
name|vi
argument_list|)
operator|&&
name|vi
operator|.
name|dwMajorVersion
operator|>=
literal|6
condition|)
name|s_SockRecvSched
operator|=
literal|4
expr_stmt|;
comment|/* Create the context pool first. */
name|IOCPLPoolInit
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Create the event used to signal an IO event */
name|WaitableIoEventHandle
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|WaitableIoEventHandle
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't create I/O event handle: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Create the event used to signal an exit event */
name|WaitableExitEventHandle
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|WaitableExitEventHandle
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't create exit event handle: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hMainRpcDone
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hMainRpcDone
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't create RPC sync handle: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Create the IO completion port */
name|hndIOCPLPort
operator|=
name|CreateIoCompletionPort
argument_list|(
name|INVALID_HANDLE_VALUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hndIOCPLPort
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't create I/O completion port: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the Wait Handles table */
name|WaitHandles
index|[
literal|0
index|]
operator|=
name|WaitableIoEventHandle
expr_stmt|;
name|WaitHandles
index|[
literal|1
index|]
operator|=
name|WaitableExitEventHandle
expr_stmt|;
comment|/* exit request */
name|WaitHandles
index|[
literal|2
index|]
operator|=
name|WaitableTimerHandle
expr_stmt|;
name|ActiveWaitHandles
operator|=
literal|3
expr_stmt|;
comment|/* Supply ntp_worker.c with function to add or remove a 	 * semaphore to the ntpd I/O loop which is signalled by a worker 	 * when a response is ready.  The callback is invoked in the 	 * parent. 	 */
name|addremove_io_semaphore
operator|=
operator|&
name|ntpd_addremove_semaphore
expr_stmt|;
comment|/* Create a true handle for the main thread (APC processing) */
name|DuplicateHandle
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|GetCurrentThread
argument_list|()
argument_list|,
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|hMainThread
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
expr_stmt|;
comment|/* Have one thread servicing I/O. See rationale in front matter. */
name|hIoCompletionThread
operator|=
operator|(
name|HANDLE
operator|)
name|_beginthreadex
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|iocompletionthread
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|tidCompletionThread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * completion port teardown  */
end_comment

begin_function
name|void
name|uninit_io_completion_port
parameter_list|(
name|void
parameter_list|)
block|{
name|DWORD
name|rc
decl_stmt|;
comment|/* do noting if completion port already gone. */
if|if
condition|(
name|hndIOCPLPort
operator|==
name|NULL
condition|)
return|return;
comment|/* Service thread seems running. Terminate him with grace 	 * first and force later... 	 */
if|if
condition|(
name|tidCompletionThread
operator|!=
name|GetCurrentThreadId
argument_list|()
condition|)
block|{
name|PostQueuedCompletionStatus
argument_list|(
name|hndIOCPLPort
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|WaitForSingleObject
argument_list|(
name|hIoCompletionThread
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|WAIT_TIMEOUT
condition|)
block|{
comment|/* Thread lost. Kill off with TerminateThread. */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"IO completion thread refuses to terminate"
argument_list|)
expr_stmt|;
name|TerminateThread
argument_list|(
name|hIoCompletionThread
argument_list|,
operator|~
literal|0UL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* close the additional main thread handle */
if|if
condition|(
name|hMainThread
condition|)
block|{
name|CloseHandle
argument_list|(
name|hMainThread
argument_list|)
expr_stmt|;
name|hMainThread
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* stop using the memory pool */
name|IOCPLPoolDone
argument_list|()
expr_stmt|;
comment|/* now reap all handles... */
name|CloseHandle
argument_list|(
name|hIoCompletionThread
argument_list|)
expr_stmt|;
name|hIoCompletionThread
operator|=
name|NULL
expr_stmt|;
name|CloseHandle
argument_list|(
name|hndIOCPLPort
argument_list|)
expr_stmt|;
name|hndIOCPLPort
operator|=
name|NULL
expr_stmt|;
name|CloseHandle
argument_list|(
name|hMainRpcDone
argument_list|)
expr_stmt|;
name|hMainRpcDone
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * external worker thread support (wait handle stuff)  *  * !Attention!  *  *  - This function must only be called from the main thread. Changing  *    a set of wait handles while someone is waiting on it creates  *    undefined behaviour. Also there's no provision for mutual  *    exclusion when accessing global values.   *  *  - It's not possible to register a handle that is already in the table.  */
end_comment

begin_function
specifier|static
name|void
name|ntpd_addremove_semaphore
parameter_list|(
name|HANDLE
name|sem
parameter_list|,
name|int
name|remove
parameter_list|)
block|{
name|DWORD
name|hi
decl_stmt|;
comment|/* search for a matching entry first. */
for|for
control|(
name|hi
operator|=
literal|3
init|;
name|hi
operator|<
name|ActiveWaitHandles
condition|;
name|hi
operator|++
control|)
if|if
condition|(
name|sem
operator|==
name|WaitHandles
index|[
name|hi
index|]
condition|)
break|break;
if|if
condition|(
name|remove
condition|)
block|{
comment|/* If found, eventually swap with last entry to keep 		 * the table dense. 		 */
if|if
condition|(
name|hi
operator|<
name|ActiveWaitHandles
condition|)
block|{
name|ActiveWaitHandles
operator|--
expr_stmt|;
if|if
condition|(
name|hi
operator|<
name|ActiveWaitHandles
condition|)
name|WaitHandles
index|[
name|hi
index|]
operator|=
name|WaitHandles
index|[
name|ActiveWaitHandles
index|]
expr_stmt|;
name|WaitHandles
index|[
name|ActiveWaitHandles
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Make sure the entry is not found and there is enough 		 * room, then append to the table array. 		 */
if|if
condition|(
name|hi
operator|>=
name|ActiveWaitHandles
condition|)
block|{
name|INSIST
argument_list|(
name|ActiveWaitHandles
operator|<
name|COUNTOF
argument_list|(
name|WaitHandles
argument_list|)
argument_list|)
expr_stmt|;
name|WaitHandles
index|[
name|ActiveWaitHandles
index|]
operator|=
name|sem
expr_stmt|;
name|ActiveWaitHandles
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|free_io_completion_port_mem
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* At the moment, do absolutely nothing. Returning memory here 	 * requires NO PENDING OVERLAPPED OPERATIONS AT ALL at this 	 * point in time, and as long we cannot be reasonable sure about 	 * that the simple advice is: 	 * 	 * HANDS OFF! 	 */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_function
name|void
name|iocpl_notify
parameter_list|(
name|IoHndPad_T
modifier|*
name|iopad
parameter_list|,
name|void
function_decl|(
modifier|*
name|pfunc
function_decl|)
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
parameter_list|,
name|UINT_PTR
name|fdn
parameter_list|)
block|{
name|IoCtx_t
name|xf
decl_stmt|;
name|memset
argument_list|(
operator|&
name|xf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xf
argument_list|)
argument_list|)
expr_stmt|;
name|xf
operator|.
name|iopad
operator|=
name|iopad
expr_stmt|;
name|xf
operator|.
name|ppswake
operator|=
name|hMainRpcDone
expr_stmt|;
name|xf
operator|.
name|onIoDone
operator|=
name|pfunc
expr_stmt|;
name|xf
operator|.
name|io
operator|.
name|sfd
operator|=
name|fdn
expr_stmt|;
name|PostQueuedCompletionStatus
argument_list|(
name|hndIOCPLPort
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|xf
operator|.
name|ol
argument_list|)
expr_stmt|;
name|WaitForSingleObject
argument_list|(
name|xf
operator|.
name|ppswake
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * APC callback for scheduling interface scans.  *  * We get an error when trying to send if the network interface is  * gone or has lost link. Rescan interfaces to catch on sooner, but no  * more often than once per minute.  Once ntpd is able to detect  * changes without polling this should be unnecessary.  */
end_comment

begin_function
specifier|static
name|void
name|WINAPI
name|apcOnUnexpectedNetworkError
parameter_list|(
name|ULONG_PTR
name|arg
parameter_list|)
block|{
specifier|static
name|u_long
name|time_next_ifscan_after_error
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_next_ifscan_after_error
operator|<
name|current_time
condition|)
block|{
name|time_next_ifscan_after_error
operator|=
name|current_time
operator|+
literal|60
expr_stmt|;
name|timer_interfacetimeout
argument_list|(
name|current_time
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"UnexpectedNetworkError: interface may be down\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  *  * Prelude to madness -- common error checking code  *  * -------------------------------------------------------------------  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|NTstrerror
parameter_list|(
name|int
name|err
parameter_list|,
name|BOOL
modifier|*
name|bfreebuf
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|LogIoError
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|HANDLE
name|hnd
parameter_list|,
name|DWORD
name|err
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|rmsg
init|=
literal|"LogIoError (unknown source)"
decl_stmt|;
comment|/* -*- format& print the error message -*- 	 * We have to resort to the low level error formatting functions 	 * here, since the error code can come from an overlapped result. 	 * Relying the value to be the same as the 'GetLastError()' 	 * result at this point of execution is shaky at best, and using 	 * 'SetLastError()' to force it seems too nasty. 	 */
name|BOOL
name|dynbuf
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|msgbuf
init|=
name|NTstrerror
argument_list|(
name|err
argument_list|,
operator|&
name|dynbuf
argument_list|)
decl_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: hnd=%p, err=%u, '%s'"
argument_list|,
operator|(
name|msg
condition|?
name|msg
else|:
name|rmsg
operator|)
argument_list|,
name|hnd
argument_list|,
name|err
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynbuf
condition|)
name|LocalFree
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * synchronous IO request result check (network& serial)  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|BOOL
name|IoResultCheck
parameter_list|(
name|DWORD
name|err
parameter_list|,
name|IoCtx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|6
argument_list|,
operator|(
literal|"in IoResultCheck err = %d\n"
operator|,
name|err
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
comment|/* The first ones are no real errors. */
case|case
name|ERROR_SUCCESS
case|:
comment|/* all is good */
case|case
name|ERROR_IO_PENDING
case|:
comment|/* callback pending */
break|break;
comment|/* this defers the error processing to the main thread 		 * and continues silently. 		 */
case|case
name|ERROR_UNEXP_NET_ERR
case|:
if|if
condition|(
name|hMainThread
condition|)
block|{
name|QueueUserAPC
argument_list|(
name|apcOnUnexpectedNetworkError
argument_list|,
name|hMainThread
argument_list|,
name|ctx
operator|->
name|io
operator|.
name|sfd
argument_list|)
expr_stmt|;
block|}
name|IoCtxRelease
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
default|default:
name|LogIoError
argument_list|(
name|msg
argument_list|,
name|ctx
operator|->
name|io
operator|.
name|hnd
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* the next ones go silently -- only clean-up is done */
case|case
name|ERROR_INVALID_PARAMETER
case|:
comment|/* handle already closed (clock)*/
case|case
name|WSAENOTSOCK
case|:
comment|/* handle already closed (socket)*/
name|IoCtxRelease
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * IO callback context check -- serial (non-network) data streams  *  * Attention: deletes the IO context when the clock is dead!  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|RIO_t
modifier|*
name|getRioFromIoCtx
parameter_list|(
name|IoCtx_t
modifier|*
name|ctx
parameter_list|,
name|ULONG_PTR
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
comment|/* Make sure the key matches the context info in the shared 	 * lock, the check for errors. If the error indicates the 	 * operation was cancelled, let the operation fail silently. 	 */
name|RIO_t
modifier|*
name|rio
init|=
name|NULL
decl_stmt|;
name|IoHndPad_T
modifier|*
name|iopad
init|=
name|ctx
operator|->
name|iopad
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|iopad
condition|)
block|{
name|rio
operator|=
name|iopad
operator|->
name|rsrc
operator|.
name|rio
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|iopad
operator|->
name|rsrc
operator|.
name|key
condition|)
name|rio
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|->
name|io
operator|.
name|hnd
operator|!=
name|iopad
operator|->
name|handles
index|[
literal|0
index|]
condition|)
name|rio
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rio
operator|!=
name|NULL
condition|)
switch|switch
condition|(
name|ctx
operator|->
name|errCode
condition|)
block|{
comment|/* When we got cancelled, don't spill messages */
case|case
name|ERROR_INVALID_PARAMETER
case|:
comment|/* handle already closed (clock) */
case|case
name|ERROR_OPERATION_ABORTED
case|:
comment|/* handle closed while wait      */
case|case
name|WSAENOTSOCK
case|:
comment|/* handle already closed (sock?) */
name|ctx
operator|->
name|errCode
operator|=
name|ERROR_SUCCESS
expr_stmt|;
name|rio
operator|=
name|NULL
expr_stmt|;
case|case
name|ERROR_SUCCESS
case|:
comment|/* all is good */
break|break;
default|default:
comment|/* log error, but return -- caller has to handle this! */
name|LogIoError
argument_list|(
name|msg
argument_list|,
name|ctx
operator|->
name|io
operator|.
name|hnd
argument_list|,
name|ctx
operator|->
name|errCode
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rio
operator|==
name|NULL
condition|)
name|IoCtxRelease
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|rio
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * IO callback context check -- network sockets  *  * Attention: deletes the IO context when the endpoint is dead!  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|endpt
modifier|*
name|getEndptFromIoCtx
parameter_list|(
name|IoCtx_t
modifier|*
name|ctx
parameter_list|,
name|ULONG_PTR
name|key
parameter_list|)
block|{
comment|/* Make sure the key matches the context info in the shared 	 * lock, then check for errors. If the error indicates the 	 * operation was cancelled, let the operation fail silently. 	 * 	 * !Note! Since we use the lowest bit of the key to distinguish 	 * between regular and broadcast socket, we must make sure the 	 * LSB is not used in the reverse-link check. Hence we shift 	 * it out in both the input key and the registered source. 	 */
name|endpt
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
name|IoHndPad_T
modifier|*
name|iopad
init|=
name|ctx
operator|->
name|iopad
decl_stmt|;
if|if
condition|(
name|iopad
operator|!=
name|NULL
condition|)
block|{
name|ep
operator|=
name|iopad
operator|->
name|rsrc
operator|.
name|ept
expr_stmt|;
if|if
condition|(
operator|(
name|key
operator|>>
literal|1
operator|)
operator|!=
operator|(
name|iopad
operator|->
name|rsrc
operator|.
name|key
operator|>>
literal|1
operator|)
condition|)
name|ep
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|->
name|io
operator|.
name|hnd
operator|!=
name|iopad
operator|->
name|handles
index|[
name|key
operator|&
literal|1
index|]
condition|)
name|ep
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|IoCtxRelease
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|ep
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|socketErrorCheck
parameter_list|(
name|IoCtx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|oval
decl_stmt|,
name|olen
decl_stmt|;
comment|/* getsockopt params */
name|int
name|retCode
decl_stmt|;
switch|switch
condition|(
name|ctx
operator|->
name|errCode
condition|)
block|{
case|case
name|ERROR_SUCCESS
case|:
comment|/* all is good */
name|retCode
operator|=
name|PKT_OK
expr_stmt|;
break|break;
case|case
name|ERROR_UNEXP_NET_ERR
case|:
if|if
condition|(
name|hMainThread
condition|)
name|QueueUserAPC
argument_list|(
name|apcOnUnexpectedNetworkError
argument_list|,
name|hMainThread
argument_list|,
name|ctx
operator|->
name|io
operator|.
name|sfd
argument_list|)
expr_stmt|;
case|case
name|ERROR_INVALID_PARAMETER
case|:
comment|/* handle already closed (clock?)*/
case|case
name|ERROR_OPERATION_ABORTED
case|:
comment|/* handle closed while wait      */
case|case
name|WSAENOTSOCK
case|:
comment|/* handle already closed (sock)  */
name|retCode
operator|=
name|PKT_SOCKET_ERROR
expr_stmt|;
break|break;
comment|/* [Bug 3019] is hard to squash. 	 * We should not get this, but we do, unfortunately. Obviously 	 * Windows insists in terminating one overlapped I/O request 	 * when it receives a TTL-expired ICMP message, and since the 	 * write that caused it is long finished, this unfortunately 	 * hits the pending receive. 	 * 	 * The only way out seems to be to silently ignore this error 	 * and restart another round, in the hope this condition does 	 * not prevail. Clear any pending socket level errors, too. 	 */
case|case
name|ERROR_HOST_UNREACHABLE
case|:
name|oval
operator|=
literal|0
expr_stmt|;
name|olen
operator|=
sizeof|sizeof
argument_list|(
name|oval
argument_list|)
expr_stmt|;
name|getsockopt
argument_list|(
name|ctx
operator|->
name|io
operator|.
name|sfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|oval
argument_list|,
operator|&
name|olen
argument_list|)
expr_stmt|;
name|retCode
operator|=
name|PKT_DROP
expr_stmt|;
break|break;
comment|/* [Bug 3110] On POSIX systems, reading UDP data into too small 	 * a buffers silently truncates the message. Under Windows the 	 * data is also truncated, but it blarts loudly about that. 	 * Just pretend all is well, and all will be well. 	 * 	 * Note: We accept the truncated packet -- this is consistent with the 	 * POSIX / UNIX case where we have no notification about this at all. 	 */
case|case
name|ERROR_MORE_DATA
case|:
comment|/* Too Much data for Buffer	 */
case|case
name|WSAEMSGSIZE
case|:
name|retCode
operator|=
name|PKT_OK
expr_stmt|;
comment|/* or PKT_DROP ??? */
break|break;
comment|/* For any other error, log the error, clear the byte count, but 	 * return the endpoint. This prevents processing the packet and 	 * keeps the read-chain running -- otherwise NTPD will play 	 * dead duck! 	 */
default|default:
name|LogIoError
argument_list|(
name|msg
argument_list|,
name|ctx
operator|->
name|io
operator|.
name|hnd
argument_list|,
name|ctx
operator|->
name|errCode
argument_list|)
expr_stmt|;
name|retCode
operator|=
name|PKT_DROP
expr_stmt|;
break|break;
block|}
return|return
name|retCode
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * Part 1 -- COMM event handling  *  * This is the initial step for serial line input: wait for COM event.  * We always check for DCD changes (for user-mode PPS time stamps) and  * either a flag char (line feed, for line mode emulation) or any  * input character (raw mode). In the callback we decide if we just  * have to go on with waiting, or if there is data we must read.  * Depending on the mode, we either queue a raw read or a 'regular'  * read request.  *  * !Note! Currently on single IO context circles through the WAIT,  * READ and PROCESS stages. For better performance, it might make  * sense to have on cycle for the wait, spinning off new read requests  * when there is data. There are actually two problems that must be  * solved:  *  - We would need a queue on post-processing.  *  - We have to take care of the order of read results. While the  *    IOCPL queue guarantees delivery in the order of enque, the  *    order of enque is not guaranteed once multiple reads are in  *    flight.  *  * So, for the time being, we have one request cycling...  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|BOOL
name|__fastcall
name|QueueSerialWait
parameter_list|(
name|IoCtx_t
modifier|*
name|lpo
parameter_list|,
name|recvbuf_t
modifier|*
name|buff
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"QueueSerialWait: cannot wait for COM event"
decl_stmt|;
name|BOOL
name|rc
decl_stmt|;
name|lpo
operator|->
name|onIoDone
operator|=
name|OnSerialWaitComplete
expr_stmt|;
name|lpo
operator|->
name|recv_buf
operator|=
name|buff
expr_stmt|;
name|lpo
operator|->
name|flRawMem
operator|=
literal|0
expr_stmt|;
name|buff
operator|->
name|fd
operator|=
name|lpo
operator|->
name|iopad
operator|->
name|riofd
expr_stmt|;
comment|/* keep receive position for continuation of partial lines! */
name|rc
operator|=
name|WaitCommEvent
argument_list|(
name|lpo
operator|->
name|io
operator|.
name|hnd
argument_list|,
operator|&
name|lpo
operator|->
name|aux
operator|.
name|com_events
argument_list|,
operator|&
name|lpo
operator|->
name|ol
argument_list|)
expr_stmt|;
return|return
name|rc
operator|||
name|IoResultCheck
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|lpo
argument_list|,
name|msg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
end_comment

begin_function
specifier|static
name|void
name|OnSerialWaitComplete
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"OnSerialWaitComplete: wait for COM event failed"
decl_stmt|;
name|DevCtx_t
modifier|*
name|dev
decl_stmt|;
name|PPSDataEx_t
modifier|*
name|ppsbuf
decl_stmt|;
name|DWORD
name|modem_status
decl_stmt|;
name|u_long
name|covc
decl_stmt|;
comment|/* Make sure this RIO is not closed. */
if|if
condition|(
name|NULL
operator|==
name|getRioFromIoCtx
argument_list|(
name|lpo
argument_list|,
name|key
argument_list|,
name|msg
argument_list|)
condition|)
return|return;
comment|/* start next IO and leave if we hit an error */
if|if
condition|(
name|lpo
operator|->
name|errCode
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|memset
argument_list|(
operator|&
name|lpo
operator|->
name|aux
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lpo
operator|->
name|aux
argument_list|)
argument_list|)
expr_stmt|;
name|IoCtxStartChecked
argument_list|(
name|lpo
argument_list|,
name|QueueSerialWait
argument_list|,
name|lpo
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|~
operator|(
name|EV_RXFLAG
operator||
name|EV_RLSD
operator||
name|EV_RXCHAR
operator|)
operator|&
name|lpo
operator|->
name|aux
operator|.
name|com_events
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WaitCommEvent returned unexpected mask %x"
argument_list|,
name|lpo
operator|->
name|aux
operator|.
name|com_events
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Take note of changes on DCD; 'user mode PPS hack'. 	 * perlinger@ntp.org suggested a way of solving several problems 	 * with this code that makes a lot of sense: move to a putative 	 * dcdpps-ppsapi-provider.dll. 	 * 	 * perlinger@ntp.org: It came out as loopback-ppsapi-provider 	 * (because it loops back into NTPD), but I had to maintain the 	 * old hack for backward compatibility. 	 */
if|if
condition|(
name|EV_RLSD
operator|&
name|lpo
operator|->
name|aux
operator|.
name|com_events
condition|)
block|{
name|modem_status
operator|=
literal|0
expr_stmt|;
name|GetCommModemStatus
argument_list|(
name|lpo
operator|->
name|io
operator|.
name|hnd
argument_list|,
operator|&
name|modem_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|dev
operator|=
name|lpo
operator|->
name|devCtx
operator|)
condition|)
block|{
comment|/* PPS-context available -- use it! */
if|if
condition|(
name|MS_RLSD_ON
operator|&
name|modem_status
condition|)
block|{
name|dev
operator|->
name|pps_data
operator|.
name|cc_assert
operator|++
expr_stmt|;
name|dev
operator|->
name|pps_data
operator|.
name|ts_assert
operator|=
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"upps-real: fd %d DCD PPS Rise at %s\n"
operator|,
name|lpo
operator|->
name|iopad
operator|->
name|rsrc
operator|.
name|rio
operator|->
name|fd
operator|,
name|ulfptoa
argument_list|(
operator|&
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
argument_list|,
literal|6
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|pps_data
operator|.
name|cc_clear
operator|++
expr_stmt|;
name|dev
operator|->
name|pps_data
operator|.
name|ts_clear
operator|=
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"upps-real: fd %d DCD PPS Fall at %s\n"
operator|,
name|lpo
operator|->
name|iopad
operator|->
name|rsrc
operator|.
name|rio
operator|->
name|fd
operator|,
name|ulfptoa
argument_list|(
operator|&
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
argument_list|,
literal|6
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Update PPS buffer, writing from low to high, with index 			 * update as last action. We use interlocked ops and a 			 * volatile data destination to avoid reordering on compiler 			 * and CPU level. The interlocked instruction act as full 			 * barriers -- we need only release semantics, but we don't 			 * have them before VS2010. 			 */
name|covc
operator|=
name|dev
operator|->
name|cov_count
operator|+
literal|1u
expr_stmt|;
name|ppsbuf
operator|=
name|dev
operator|->
name|pps_buff
operator|+
operator|(
name|covc
operator|&
name|PPS_QUEUE_MSK
operator|)
expr_stmt|;
name|InterlockedExchange
argument_list|(
operator|(
name|PLONG
operator|)
operator|&
name|ppsbuf
operator|->
name|cov_count
argument_list|,
name|covc
argument_list|)
expr_stmt|;
name|ppsbuf
operator|->
name|data
operator|=
name|dev
operator|->
name|pps_data
expr_stmt|;
name|InterlockedExchange
argument_list|(
operator|(
name|PLONG
operator|)
operator|&
name|dev
operator|->
name|cov_count
argument_list|,
name|covc
argument_list|)
expr_stmt|;
block|}
comment|/* perlinger@ntp.org, 2012-11-19 		 * It can be argued that once you have the PPS API active, you can 		 * disable the old pps hack. This would give a behaviour that's much 		 * more like the behaviour under a UN*Xish OS. On the other hand, it 		 * will give a nasty surprise for people which have until now happily 		 * taken the pps hack for granted, and after the first complaint, I have 		 * decided to keep the old implementation unconditionally. So here it is: 		 * 		 * backward compat: 'usermode-pps-hack' 		 */
if|if
condition|(
operator|(
name|MS_RLSD_ON
operator|&
name|modem_status
operator|)
operator|&&
name|DoPPShack
condition|)
block|{
name|lpo
operator|->
name|aux
operator|.
name|DCDSTime
operator|=
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
expr_stmt|;
name|lpo
operator|->
name|aux
operator|.
name|flTsDCDS
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"upps-hack: fd %d DCD PPS Rise at %s\n"
operator|,
name|lpo
operator|->
name|iopad
operator|->
name|rsrc
operator|.
name|rio
operator|->
name|fd
operator|,
name|ulfptoa
argument_list|(
operator|&
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
argument_list|,
literal|6
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If IO ready, read data. Go back waiting else. */
if|if
condition|(
name|EV_RXFLAG
operator|&
name|lpo
operator|->
name|aux
operator|.
name|com_events
condition|)
block|{
comment|/* line discipline */
name|lpo
operator|->
name|aux
operator|.
name|FlagTime
operator|=
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
expr_stmt|;
name|lpo
operator|->
name|aux
operator|.
name|flTsFlag
operator|=
literal|1
expr_stmt|;
name|IoCtxStartChecked
argument_list|(
name|lpo
argument_list|,
name|QueueSerialRead
argument_list|,
name|lpo
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EV_RXCHAR
operator|&
name|lpo
operator|->
name|aux
operator|.
name|com_events
condition|)
block|{
comment|/* raw discipline */
name|lpo
operator|->
name|aux
operator|.
name|FlagTime
operator|=
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
expr_stmt|;
name|lpo
operator|->
name|aux
operator|.
name|flTsFlag
operator|=
literal|1
expr_stmt|;
name|IoCtxStartChecked
argument_list|(
name|lpo
argument_list|,
name|QueueRawSerialRead
argument_list|,
name|lpo
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* idle... */
name|IoCtxStartChecked
argument_list|(
name|lpo
argument_list|,
name|QueueSerialWait
argument_list|,
name|lpo
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * common for both modes  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|BOOL
name|__fastcall
name|QueueSerialReadCommon
parameter_list|(
name|IoCtx_t
modifier|*
name|lpo
parameter_list|,
name|recvbuf_t
modifier|*
name|buff
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"QueueSerialRead: cannot schedule device read"
decl_stmt|;
name|BOOL
name|rc
decl_stmt|;
comment|/* 'lpo->onIoDone' must be set already! */
name|lpo
operator|->
name|recv_buf
operator|=
name|buff
expr_stmt|;
name|lpo
operator|->
name|flRawMem
operator|=
literal|0
expr_stmt|;
comment|/* 'buff->recv_length' must be set already! */
name|buff
operator|->
name|fd
operator|=
name|lpo
operator|->
name|iopad
operator|->
name|riofd
expr_stmt|;
name|buff
operator|->
name|dstadr
operator|=
name|NULL
expr_stmt|;
name|buff
operator|->
name|receiver
operator|=
name|process_refclock_packet
expr_stmt|;
name|buff
operator|->
name|recv_peer
operator|=
name|lpo
operator|->
name|iopad
operator|->
name|rsrc
operator|.
name|rio
operator|->
name|srcclock
expr_stmt|;
name|rc
operator|=
name|ReadFile
argument_list|(
name|lpo
operator|->
name|io
operator|.
name|hnd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buff
operator|->
name|recv_buffer
operator|+
name|buff
operator|->
name|recv_length
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
operator|->
name|recv_buffer
argument_list|)
operator|-
name|buff
operator|->
name|recv_length
argument_list|,
name|NULL
argument_list|,
operator|&
name|lpo
operator|->
name|ol
argument_list|)
expr_stmt|;
return|return
name|rc
operator|||
name|IoResultCheck
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|lpo
argument_list|,
name|msg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * Part 2 -- line discipline emulation  *  * Ideally this should *not* be done in the IO completion thread.  * We use a worker pool thread to offload the low-level processing.  * -------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * Start& Queue a serial read for line discipline emulation.  */
end_comment

begin_function
specifier|static
name|BOOL
name|__fastcall
name|QueueSerialRead
parameter_list|(
name|IoCtx_t
modifier|*
name|lpo
parameter_list|,
name|recvbuf_t
modifier|*
name|buff
parameter_list|)
block|{
name|lpo
operator|->
name|onIoDone
operator|=
operator|&
name|OnSerialReadComplete
expr_stmt|;
comment|/* keep 'buff->recv_length' for line continuation! */
return|return
name|QueueSerialReadCommon
argument_list|(
name|lpo
argument_list|,
name|buff
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * IO completion thread callback. Takes a time stamp and offloads the  * real work to the worker pool ASAP.  */
end_comment

begin_function
specifier|static
name|void
name|OnSerialReadComplete
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"OnSerialReadComplete: read from device failed"
decl_stmt|;
comment|/* Make sure this RIO is not closed. */
if|if
condition|(
name|NULL
operator|==
name|getRioFromIoCtx
argument_list|(
name|lpo
argument_list|,
name|key
argument_list|,
name|msg
argument_list|)
condition|)
return|return;
comment|/* start next IO and leave if we hit an error */
if|if
condition|(
name|lpo
operator|->
name|errCode
operator|!=
name|ERROR_SUCCESS
condition|)
goto|goto
name|wait_again
goto|;
comment|/* Offload to worker pool, if there is data */
if|if
condition|(
name|lpo
operator|->
name|byteCount
operator|==
literal|0
condition|)
goto|goto
name|wait_again
goto|;
if|if
condition|(
name|QueueUserWorkItem
argument_list|(
operator|&
name|OnSerialReadWorker
argument_list|,
name|lpo
argument_list|,
name|WT_EXECUTEDEFAULT
argument_list|)
condition|)
return|return;
comment|/* successful regular exit! */
comment|/* croak as we're throwing away data */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't offload to worker thread, will skip data: %m"
argument_list|)
expr_stmt|;
name|wait_again
label|:
comment|/* make sure the read is issued again */
name|memset
argument_list|(
operator|&
name|lpo
operator|->
name|aux
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lpo
operator|->
name|aux
argument_list|)
argument_list|)
expr_stmt|;
name|IoCtxStartChecked
argument_list|(
name|lpo
argument_list|,
name|QueueSerialWait
argument_list|,
name|lpo
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * Worker pool offload function -- avoid lengthy operations in the IO  * completion thread (affects timing...)  *  * This function does the real work of emulating the UN*X line  * discipline. Since this involves allocation of additional buffers and  * string parsing/copying, it is offloaded to the worker thread pool so  * the IO completion thread can resume faster.  *  * !!ATTENTION!!  * This function runs on an arbitrary worker thread. The resource  * management with regard to IO is synchronised only between the main  * thread and the IO worker thread, so decisions about queueing and  * starting new IO must be made by either of them.  *  * Since the IO thread sticks in the IOCPL queue and is not alertable,  * we could either use the APC queue to the main thread or the IOCPL  * queue to the IO thread.  *  * We separate the effort -- filtering based on the RIO state is done  * by the main thread, restarting the IO by the IO thread to reduce  * delays.  */
end_comment

begin_comment
comment|/* -------------------------------------------------------------------  * IOCPL deferred bouncer -- start a new serial wait from IOCPL thread  */
end_comment

begin_function
specifier|static
name|void
name|OnDeferredStartWait
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
name|IoCtxStartChecked
argument_list|(
name|lpo
argument_list|,
name|QueueSerialWait
argument_list|,
name|lpo
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * APC deferred bouncer -- put buffer to receive queueor eventually  * discard it if source is already disabled. Runs in the context  * of the main thread exclusively.  */
end_comment

begin_function
specifier|static
name|void
name|WINAPI
name|OnEnqueAPC
parameter_list|(
name|ULONG_PTR
name|arg
parameter_list|)
block|{
name|recvbuf_t
modifier|*
name|buff
init|=
operator|(
name|recvbuf_t
operator|*
operator|)
name|arg
decl_stmt|;
name|IoHndPad_T
modifier|*
name|iopad
init|=
operator|(
name|IoHndPad_T
operator|*
operator|)
name|buff
operator|->
name|recv_peer
decl_stmt|;
name|RIO_t
modifier|*
name|rio
init|=
name|iopad
operator|->
name|rsrc
operator|.
name|rio
decl_stmt|;
comment|/* Down below we make a nasty hack to transport the iopad 	 * pointer in the buffer so we can avoid another temporary 	 * allocation. We must undo this here. 	*/
if|if
condition|(
name|NULL
operator|!=
name|rio
condition|)
block|{
comment|/* OK, refclock still attached */
name|buff
operator|->
name|recv_peer
operator|=
name|rio
operator|->
name|srcclock
expr_stmt|;
if|if
condition|(
name|iohpQueueLocked
argument_list|(
name|iopad
argument_list|,
name|iohpRefClockOK
argument_list|,
name|buff
argument_list|)
condition|)
operator|++
name|rio
operator|->
name|srcclock
operator|->
name|received
expr_stmt|;
block|}
else|else
block|{
comment|/* refclock detached while in flight... */
name|freerecvbuf
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
name|iohpDetach
argument_list|(
name|iopad
argument_list|)
expr_stmt|;
comment|/* one unit owned by this callback! */
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * worker pool thread worker doing the string processing  */
end_comment

begin_function
specifier|static
name|DWORD
name|WINAPI
name|OnSerialReadWorker
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|IoCtx_t
modifier|*
name|lpo
init|=
operator|(
name|IoCtx_t
operator|*
operator|)
name|ctx
decl_stmt|;
name|IoHndPad_T
modifier|*
name|iop
init|=
name|lpo
operator|->
name|iopad
decl_stmt|;
name|recvbuf_t
modifier|*
name|buff
init|=
name|lpo
operator|->
name|recv_buf
decl_stmt|;
name|recvbuf_t
modifier|*
name|obuf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|sptr
decl_stmt|,
modifier|*
name|send
decl_stmt|,
modifier|*
name|dptr
decl_stmt|;
name|BOOL
name|eol
decl_stmt|;
name|int
name|ch
decl_stmt|;
comment|/* We should never gat a zero-byte read here. If we do, nothing 	 * really bad happens, just a useless rescan of data we have 	 * already processed. But somethings not quite right in logic 	 * and we croak loudly in debug builds. 	 */
name|DEBUG_INSIST
argument_list|(
name|lpo
operator|->
name|byteCount
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Account for additional input and then mimic the UNIX line 	 * discipline. This is an implict state machine -- the 	 * implementation is very low-level to gather speed. 	 */
name|buff
operator|->
name|recv_length
operator|+=
operator|(
name|int
operator|)
name|lpo
operator|->
name|byteCount
expr_stmt|;
name|sptr
operator|=
operator|(
name|char
operator|*
operator|)
name|buff
operator|->
name|recv_buffer
expr_stmt|;
name|send
operator|=
name|sptr
operator|+
name|buff
operator|->
name|recv_length
expr_stmt|;
if|if
condition|(
name|sptr
operator|==
name|send
condition|)
goto|goto
name|st_read_fresh
goto|;
name|st_new_obuf
label|:
comment|/* Get new receive buffer to store the line. */
name|obuf
operator|=
name|get_free_recv_buffer_alloc
argument_list|()
expr_stmt|;
name|obuf
operator|->
name|fd
operator|=
name|buff
operator|->
name|fd
expr_stmt|;
name|obuf
operator|->
name|receiver
operator|=
name|buff
operator|->
name|receiver
expr_stmt|;
name|obuf
operator|->
name|dstadr
operator|=
name|NULL
expr_stmt|;
name|obuf
operator|->
name|recv_peer
operator|=
name|buff
operator|->
name|recv_peer
expr_stmt|;
name|set_serial_recv_time
argument_list|(
name|obuf
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
name|st_copy_start
label|:
comment|/* Copy data to new buffer, convert CR to LF on the fly. 	 * Stop after either. 	 */
name|dptr
operator|=
operator|(
name|char
operator|*
operator|)
name|obuf
operator|->
name|recv_buffer
expr_stmt|;
do|do
block|{
name|ch
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
if|if
condition|(
literal|'\r'
operator|==
name|ch
condition|)
name|ch
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|dptr
operator|++
operator|=
name|ch
expr_stmt|;
name|eol
operator|=
operator|(
literal|'\n'
operator|==
name|ch
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|eol
operator|||
name|sptr
operator|==
name|send
operator|)
condition|)
do|;
name|obuf
operator|->
name|recv_length
operator|=
call|(
name|int
call|)
argument_list|(
name|dptr
operator|-
operator|(
name|char
operator|*
operator|)
name|obuf
operator|->
name|recv_buffer
argument_list|)
expr_stmt|;
comment|/* If we're not at EOL, we need more data to continue the line. 	 * But this can only be done if there's more room in the buffer; 	 * if we have already reached the maximum size, treat the whole 	 * buffer as part of a mega-line and pass it on. 	 */
if|if
condition|(
operator|!
name|eol
condition|)
block|{
if|if
condition|(
name|obuf
operator|->
name|recv_length
operator|<
sizeof|sizeof
argument_list|(
name|obuf
operator|->
name|recv_buffer
argument_list|)
condition|)
goto|goto
name|st_read_more
goto|;
else|else
goto|goto
name|st_pass_buffer
goto|;
block|}
comment|/* if we should drop empty lines, do it here. */
if|if
condition|(
name|obuf
operator|->
name|recv_length
operator|<
literal|2
operator|&&
name|iop
operator|->
name|flDropEmpty
condition|)
block|{
name|obuf
operator|->
name|recv_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sptr
operator|!=
name|send
condition|)
goto|goto
name|st_copy_start
goto|;
else|else
goto|goto
name|st_read_more
goto|;
block|}
if|if
condition|(
operator|!
name|iop
operator|->
name|flFirstSeen
condition|)
block|{
name|iop
operator|->
name|flFirstSeen
operator|=
literal|1
expr_stmt|;
name|obuf
operator|->
name|recv_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sptr
operator|!=
name|send
condition|)
goto|goto
name|st_copy_start
goto|;
else|else
goto|goto
name|st_read_more
goto|;
block|}
name|st_pass_buffer
label|:
comment|/* if we arrive here, we can spin off another text line to the 	 * receive queue. We use a hack to supplant the RIO pointer in 	 * the receive buffer with the IOPAD to save us a temporary 	 * workspace allocation. Note the callback owns one refcount 	 * unit to keep the IOPAD alive! Also checking that the RIO in 	 * the IOPAD matches the RIO in the buffer is dangerous: That 	 * pointer is manipulated by the other threads! 	 */
name|obuf
operator|->
name|recv_peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|iohpAttach
argument_list|(
name|lpo
operator|->
name|iopad
argument_list|)
expr_stmt|;
name|QueueUserAPC
argument_list|(
name|OnEnqueAPC
argument_list|,
name|hMainThread
argument_list|,
operator|(
name|ULONG_PTR
operator|)
name|obuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sptr
operator|!=
name|send
condition|)
goto|goto
name|st_new_obuf
goto|;
name|buff
operator|->
name|recv_length
operator|=
literal|0
expr_stmt|;
goto|goto
name|st_read_fresh
goto|;
name|st_read_more
label|:
comment|/* read more data into current OBUF, which is valid and will 	 * replace BUFF. 	 */
name|lpo
operator|->
name|recv_buf
operator|=
name|obuf
expr_stmt|;
name|freerecvbuf
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|st_read_fresh
label|:
comment|/* Start next round. This is deferred to the IOCPL thread, as 	 * read access to the IOPAD is unsafe from a worker thread 	 * for anything but the flags. If the IOCPL handle is gone, 	 * just mop up the pieces. 	 */
name|lpo
operator|->
name|onIoDone
operator|=
name|OnDeferredStartWait
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hndIOCPLPort
operator|&&
name|PostQueuedCompletionStatus
argument_list|(
name|hndIOCPLPort
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|lpo
operator|->
name|ol
argument_list|)
operator|)
condition|)
name|IoCtxRelease
argument_list|(
name|lpo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * Part 3 -- raw data input  *  * Raw data processing is fast enough to do without offloading to the  * worker pool, so this is rather short'n sweet...  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|BOOL
name|__fastcall
name|QueueRawSerialRead
parameter_list|(
name|IoCtx_t
modifier|*
name|lpo
parameter_list|,
name|recvbuf_t
modifier|*
name|buff
parameter_list|)
block|{
name|lpo
operator|->
name|onIoDone
operator|=
name|OnRawSerialReadComplete
expr_stmt|;
name|buff
operator|->
name|recv_length
operator|=
literal|0
expr_stmt|;
return|return
name|QueueSerialReadCommon
argument_list|(
name|lpo
argument_list|,
name|buff
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * IO completion thread callback. Takes a time stamp and offloads the  * real work to the worker pool ASAP.  */
end_comment

begin_function
specifier|static
name|void
name|OnRawSerialReadComplete
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"OnRawSerialReadComplete: read from device failed"
decl_stmt|;
name|recvbuf_t
modifier|*
name|buff
init|=
name|lpo
operator|->
name|recv_buf
decl_stmt|;
name|RIO_t
modifier|*
name|rio
init|=
name|getRioFromIoCtx
argument_list|(
name|lpo
argument_list|,
name|key
argument_list|,
name|msg
argument_list|)
decl_stmt|;
comment|/* Make sure this RIO is not closed. */
if|if
condition|(
name|rio
operator|==
name|NULL
condition|)
return|return;
comment|/* start next IO and leave if we hit an error */
if|if
condition|(
name|lpo
operator|->
name|errCode
operator|==
name|ERROR_SUCCESS
operator|&&
name|lpo
operator|->
name|byteCount
operator|>
literal|0
condition|)
block|{
name|buff
operator|->
name|recv_length
operator|=
operator|(
name|int
operator|)
name|lpo
operator|->
name|byteCount
expr_stmt|;
name|set_serial_recv_time
argument_list|(
name|buff
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
name|iohpQueueLocked
argument_list|(
name|lpo
operator|->
name|iopad
argument_list|,
name|iohpRefClockOK
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|buff
operator|=
name|get_free_recv_buffer_alloc
argument_list|()
expr_stmt|;
block|}
name|IoCtxStartChecked
argument_list|(
name|lpo
argument_list|,
name|QueueSerialWait
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_serial_recv_time
parameter_list|(
name|recvbuf_t
modifier|*
name|obuf
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
comment|/* Time stamp assignment is interesting.  If we 	 * have a DCD stamp, we use it, otherwise we use 	 * the FLAG char event time, and if that is also 	 * not / no longer available we use the arrival 	 * time. 	 */
if|if
condition|(
name|lpo
operator|->
name|aux
operator|.
name|flTsDCDS
condition|)
name|obuf
operator|->
name|recv_time
operator|=
name|lpo
operator|->
name|aux
operator|.
name|DCDSTime
expr_stmt|;
elseif|else
if|if
condition|(
name|lpo
operator|->
name|aux
operator|.
name|flTsFlag
condition|)
name|obuf
operator|->
name|recv_time
operator|=
name|lpo
operator|->
name|aux
operator|.
name|FlagTime
expr_stmt|;
else|else
name|obuf
operator|->
name|recv_time
operator|=
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
expr_stmt|;
name|lpo
operator|->
name|aux
operator|.
name|flTsDCDS
operator|=
name|lpo
operator|->
name|aux
operator|.
name|flTsFlag
operator|=
literal|0
expr_stmt|;
comment|/* use only once! */
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * Part 4 -- Overlapped serial output  *  * Again, no need to offload any work.  * -------------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * async_write, clone of write(), used by some reflock drivers  */
end_comment

begin_function
name|int
name|async_write
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|count
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"async_write: cannot schedule device write"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|dmsg
init|=
literal|"overlapped IO data buffer"
decl_stmt|;
name|IoCtx_t
modifier|*
name|lpo
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|buff
init|=
name|NULL
decl_stmt|;
name|HANDLE
name|hnd
init|=
name|NULL
decl_stmt|;
name|BOOL
name|rc
decl_stmt|;
name|hnd
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|hnd
operator|==
name|INVALID_HANDLE_VALUE
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|buff
operator|=
name|IOCPLPoolMemDup
argument_list|(
name|data
argument_list|,
name|count
argument_list|,
name|dmsg
argument_list|)
operator|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|lpo
operator|=
name|IoCtxAlloc
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
goto|goto
name|fail
goto|;
name|lpo
operator|->
name|io
operator|.
name|hnd
operator|=
name|hnd
expr_stmt|;
name|lpo
operator|->
name|onIoDone
operator|=
name|OnSerialWriteComplete
expr_stmt|;
name|lpo
operator|->
name|trans_buf
operator|=
name|buff
expr_stmt|;
name|lpo
operator|->
name|flRawMem
operator|=
literal|1
expr_stmt|;
name|rc
operator|=
name|WriteFile
argument_list|(
name|lpo
operator|->
name|io
operator|.
name|hnd
argument_list|,
name|lpo
operator|->
name|trans_buf
argument_list|,
name|count
argument_list|,
name|NULL
argument_list|,
operator|&
name|lpo
operator|->
name|ol
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|||
name|IoResultCheck
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|lpo
argument_list|,
name|msg
argument_list|)
condition|)
return|return
name|count
return|;
comment|/* normal/success return */
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|-
literal|1
return|;
name|fail
label|:
name|IoCtxFree
argument_list|(
name|lpo
argument_list|)
expr_stmt|;
name|IOCPLPoolFree
argument_list|(
name|buff
argument_list|,
name|dmsg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|OnSerialWriteComplete
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
comment|/* This is really trivial: Let 'getRioFromIoCtx()' do all the 	 * error processing, and it returns with a valid RIO, just 	 * drop the complete context. 	 */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"OnSerialWriteComplete: serial output failed"
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|getRioFromIoCtx
argument_list|(
name|lpo
argument_list|,
name|key
argument_list|,
name|msg
argument_list|)
condition|)
name|IoCtxRelease
argument_list|(
name|lpo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * Part 5 -- read PPS time stamps  *  * -------------------------------------------------------------------  */
end_comment

begin_macro
name|__declspec
argument_list|(
argument|dllexport
argument_list|)
end_macro

begin_function
name|void
modifier|*
name|__stdcall
name|ntp_pps_attach_device
parameter_list|(
name|HANDLE
name|hndIo
parameter_list|)
block|{
name|DevCtx_t
modifier|*
name|dev
init|=
name|NULL
decl_stmt|;
name|dev
operator|=
name|DevCtxAttach
argument_list|(
name|serial_devctx
argument_list|(
name|hndIo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|dev
condition|)
name|SetLastError
argument_list|(
name|ERROR_INVALID_HANDLE
argument_list|)
expr_stmt|;
return|return
name|dev
return|;
block|}
end_function

begin_macro
name|__declspec
argument_list|(
argument|dllexport
argument_list|)
end_macro

begin_function
name|void
name|__stdcall
name|ntp_pps_detach_device
parameter_list|(
name|DevCtx_t
modifier|*
name|dev
parameter_list|)
block|{
name|DevCtxDetach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|__declspec
argument_list|(
argument|dllexport
argument_list|)
end_macro

begin_function
name|BOOL
name|__stdcall
name|ntp_pps_read
parameter_list|(
name|DevCtx_t
modifier|*
name|dev
parameter_list|,
name|PPSData_t
modifier|*
name|data
parameter_list|,
name|size_t
name|dlen
parameter_list|)
block|{
name|u_long
name|guard
decl_stmt|,
name|covc
decl_stmt|;
name|int
name|repc
decl_stmt|;
name|PPSDataEx_t
modifier|*
name|ppsbuf
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|SetLastError
argument_list|(
name|ERROR_INVALID_HANDLE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|data
operator|==
name|NULL
operator|||
name|dlen
operator|!=
sizeof|sizeof
argument_list|(
name|PPSData_t
argument_list|)
condition|)
block|{
name|SetLastError
argument_list|(
name|ERROR_INVALID_PARAMETER
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Reading from shared memory in a lock-free fashion can be 	 * a bit tricky, since we have to read the components in the 	 * opposite direction from the write, and the compiler must 	 * not reorder the read sequence. 	 * We use interlocked ops and a volatile data source to avoid 	 * reordering on compiler and CPU level. The interlocked 	 * instruction act as full barriers -- we need only acquire 	 * semantics, but we don't have them before VS2010. 	 */
name|repc
operator|=
literal|3
expr_stmt|;
do|do
block|{
name|covc
operator|=
name|InterlockedExchangeAdd
argument_list|(
operator|(
name|PLONG
operator|)
operator|&
name|dev
operator|->
name|cov_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ppsbuf
operator|=
name|dev
operator|->
name|pps_buff
operator|+
operator|(
name|covc
operator|&
name|PPS_QUEUE_MSK
operator|)
expr_stmt|;
operator|*
name|data
operator|=
name|ppsbuf
operator|->
name|data
expr_stmt|;
name|guard
operator|=
name|InterlockedExchangeAdd
argument_list|(
operator|(
name|PLONG
operator|)
operator|&
name|ppsbuf
operator|->
name|cov_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|guard
operator|^=
name|covc
expr_stmt|;
block|}
do|while
condition|(
name|guard
operator|&&
operator|~
name|guard
operator|&&
operator|--
name|repc
condition|)
do|;
if|if
condition|(
name|guard
condition|)
block|{
name|SetLastError
argument_list|(
name|ERROR_INVALID_DATA
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * register and unregister refclock IOs with the IO engine  * --------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* Add a reference clock data structures I/O handles to  * the I/O completion port. Return FALSE if any error,  * TRUE on success  */
end_comment

begin_function
name|BOOL
name|io_completion_port_add_clock_io
parameter_list|(
name|RIO_t
modifier|*
name|rio
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msgh
init|=
literal|"io_completion_port_add_clock_io"
decl_stmt|;
name|IoCtx_t
modifier|*
name|lpo
decl_stmt|;
name|HANDLE
name|h
decl_stmt|;
name|IoHndPad_T
modifier|*
name|iopad
init|=
name|NULL
decl_stmt|;
comment|/* preset to clear state for error cleanup:*/
name|rio
operator|->
name|ioreg_ctx
operator|=
name|NULL
expr_stmt|;
name|rio
operator|->
name|device_ctx
operator|=
name|NULL
expr_stmt|;
name|h
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|rio
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: COM port FD not valid"
argument_list|,
name|msgh
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|rio
operator|->
name|ioreg_ctx
operator|=
name|iopad
operator|=
name|iohpCreate
argument_list|(
name|rio
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: Failed to create shared lock"
argument_list|,
name|msgh
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|iopad
operator|->
name|handles
index|[
literal|0
index|]
operator|=
name|h
expr_stmt|;
name|iopad
operator|->
name|riofd
operator|=
name|rio
operator|->
name|fd
expr_stmt|;
name|iopad
operator|->
name|rsrc
operator|.
name|rio
operator|=
name|rio
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rio
operator|->
name|device_ctx
operator|=
name|DevCtxAttach
argument_list|(
name|serial_devctx
argument_list|(
name|h
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: Failed to allocate device context"
argument_list|,
name|msgh
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|lpo
operator|=
name|IoCtxAlloc
argument_list|(
name|iopad
argument_list|,
name|rio
operator|->
name|device_ctx
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%: Failed to allocate IO context"
argument_list|,
name|msgh
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
name|CreateIoCompletionPort
argument_list|(
name|h
argument_list|,
name|hndIOCPLPort
argument_list|,
operator|(
name|ULONG_PTR
operator|)
name|rio
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: Can't add COM port to i/o completion port: %m"
argument_list|,
name|msgh
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|lpo
operator|->
name|io
operator|.
name|hnd
operator|=
name|h
expr_stmt|;
name|memset
argument_list|(
operator|&
name|lpo
operator|->
name|aux
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lpo
operator|->
name|aux
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|QueueSerialWait
argument_list|(
name|lpo
argument_list|,
name|get_free_recv_buffer_alloc
argument_list|()
argument_list|)
return|;
name|fail
label|:
name|rio
operator|->
name|ioreg_ctx
operator|=
name|iohpDetach
argument_list|(
name|rio
operator|->
name|ioreg_ctx
argument_list|)
expr_stmt|;
name|rio
operator|->
name|device_ctx
operator|=
name|DevCtxDetach
argument_list|(
name|rio
operator|->
name|device_ctx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|OnSerialDetach
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
comment|/* Make sure the key matches the context info in the shared 	* lock, the check for errors. If the error indicates the 	* operation was cancelled, let the operation fail silently. 	*/
name|IoHndPad_T
modifier|*
name|iopad
init|=
name|lpo
operator|->
name|iopad
decl_stmt|;
name|INSIST
argument_list|(
name|NULL
operator|!=
name|iopad
argument_list|)
expr_stmt|;
if|if
condition|(
name|iopad
operator|->
name|handles
index|[
literal|0
index|]
operator|==
name|lpo
operator|->
name|io
operator|.
name|hnd
condition|)
block|{
name|iopad
operator|->
name|handles
index|[
literal|0
index|]
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|iopad
operator|->
name|handles
index|[
literal|1
index|]
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|iopad
operator|->
name|rsrc
operator|.
name|rio
operator|=
name|NULL
expr_stmt|;
name|iopad
operator|->
name|riofd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|SetEvent
argument_list|(
name|lpo
operator|->
name|ppswake
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|io_completion_port_remove_clock_io
parameter_list|(
name|RIO_t
modifier|*
name|rio
parameter_list|)
block|{
name|IoHndPad_T
modifier|*
name|iopad
init|=
operator|(
name|IoHndPad_T
operator|*
operator|)
name|rio
operator|->
name|ioreg_ctx
decl_stmt|;
name|INSIST
argument_list|(
name|hndIOCPLPort
operator|&&
name|hMainRpcDone
argument_list|)
expr_stmt|;
if|if
condition|(
name|iopad
condition|)
name|iocpl_notify
argument_list|(
name|iopad
argument_list|,
name|OnSerialDetach
argument_list|,
name|_get_osfhandle
argument_list|(
name|rio
operator|->
name|fd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Socket IO stuff  * -------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* Queue a receiver on a socket. Returns 0 if no buffer can be queued   *  *  Note: As per the WINSOCK documentation, we use WSARecvFrom. Using  *	  ReadFile() is less efficient. Also, WSARecvFrom delivers  *	  the remote network address. With ReadFile, getting this  *	  becomes a chore.  */
end_comment

begin_function
specifier|static
name|BOOL
name|__fastcall
name|QueueSocketRecv
parameter_list|(
name|IoCtx_t
modifier|*
name|lpo
parameter_list|,
name|recvbuf_t
modifier|*
name|buff
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"QueueSocketRecv: cannot schedule socket receive"
decl_stmt|;
name|WSABUF
name|wsabuf
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|lpo
operator|->
name|onIoDone
operator|=
name|OnSocketRecv
expr_stmt|;
name|lpo
operator|->
name|recv_buf
operator|=
name|buff
expr_stmt|;
name|lpo
operator|->
name|flRawMem
operator|=
literal|0
expr_stmt|;
name|lpo
operator|->
name|ioFlags
operator|=
literal|0
expr_stmt|;
name|buff
operator|->
name|fd
operator|=
name|lpo
operator|->
name|io
operator|.
name|sfd
expr_stmt|;
name|buff
operator|->
name|recv_srcadr_len
operator|=
sizeof|sizeof
argument_list|(
name|buff
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
name|buff
operator|->
name|receiver
operator|=
name|receive
expr_stmt|;
name|buff
operator|->
name|dstadr
operator|=
name|lpo
operator|->
name|iopad
operator|->
name|rsrc
operator|.
name|ept
expr_stmt|;
name|wsabuf
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buff
operator|->
name|recv_buffer
expr_stmt|;
name|wsabuf
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buff
operator|->
name|recv_buffer
argument_list|)
expr_stmt|;
name|rc
operator|=
name|WSARecvFrom
argument_list|(
name|lpo
operator|->
name|io
operator|.
name|sfd
argument_list|,
operator|&
name|wsabuf
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|lpo
operator|->
name|ioFlags
argument_list|,
operator|&
name|buff
operator|->
name|recv_srcadr
operator|.
name|sa
argument_list|,
operator|&
name|buff
operator|->
name|recv_srcadr_len
argument_list|,
operator|&
name|lpo
operator|->
name|ol
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|!
name|rc
operator|||
name|IoResultCheck
argument_list|(
operator|(
name|DWORD
operator|)
name|WSAGetLastError
argument_list|()
argument_list|,
name|lpo
argument_list|,
name|msg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|OnSocketRecv
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"OnSocketRecv: receive from socket failed"
decl_stmt|;
name|recvbuf_t
modifier|*
name|buff
init|=
name|NULL
decl_stmt|;
name|IoHndPad_T
modifier|*
name|iopad
init|=
name|NULL
decl_stmt|;
name|endpt
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* order is important -- check first, then get endpoint! */
name|rc
operator|=
name|socketErrorCheck
argument_list|(
name|lpo
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|ep
operator|=
name|getEndptFromIoCtx
argument_list|(
name|lpo
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/* Make sure this endpoint is not closed. */
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return;
comment|/* We want to start a new read before we process the buffer. 	 * Since we must not use the context object once it is in 	 * another IO, we go through some pains to read everything 	 * before going out for another read request. 	 * We also need an extra hold to the IOPAD structure. 	 */
name|iopad
operator|=
name|iohpAttach
argument_list|(
name|lpo
operator|->
name|iopad
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|PKT_OK
operator|&&
name|lpo
operator|->
name|byteCount
operator|>
literal|0
condition|)
block|{
comment|/* keep input buffer, create new one for IO */
name|buff
operator|=
name|lpo
operator|->
name|recv_buf
expr_stmt|;
name|lpo
operator|->
name|recv_buf
operator|=
name|get_free_recv_buffer_alloc
argument_list|()
expr_stmt|;
name|buff
operator|->
name|recv_time
operator|=
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
expr_stmt|;
name|buff
operator|->
name|recv_length
operator|=
operator|(
name|int
operator|)
name|lpo
operator|->
name|byteCount
expr_stmt|;
block|}
comment|/* Note: else we use the current buffer again */
if|if
condition|(
name|rc
operator|!=
name|PKT_SOCKET_ERROR
condition|)
block|{
name|IoCtxStartChecked
argument_list|(
name|lpo
argument_list|,
name|QueueSocketRecv
argument_list|,
name|lpo
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|freerecvbuf
argument_list|(
name|lpo
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
name|IoCtxFree
argument_list|(
name|lpo
argument_list|)
expr_stmt|;
block|}
comment|/* below this, any usage of 'lpo' is invalid! */
comment|/* If we have a buffer, do some bookkeeping and other chores, 	 * then feed it to the input queue. And we can be sure we have 	 * a packet here, so we can update the stats. 	 */
if|if
condition|(
name|buff
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|buff
operator|->
name|recv_srcadr_len
operator|<=
sizeof|sizeof
argument_list|(
name|buff
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%sfd %d %s recv packet mode is %d\n"
operator|,
operator|(
name|MODE_BROADCAST
operator|==
name|get_packet_mode
argument_list|(
name|buff
argument_list|)
operator|)
condition|?
literal|" **** Broadcast "
else|:
literal|""
operator|,
operator|(
name|int
operator|)
name|buff
operator|->
name|fd
operator|,
name|stoa
argument_list|(
operator|&
name|buff
operator|->
name|recv_srcadr
argument_list|)
operator|,
name|get_packet_mode
argument_list|(
name|buff
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iohpEndPointOK
argument_list|(
name|iopad
argument_list|)
condition|)
block|{
name|InterlockedIncrement
argument_list|(
operator|&
name|ep
operator|->
name|received
argument_list|)
expr_stmt|;
name|InterlockedIncrement
argument_list|(
operator|&
name|packets_received
argument_list|)
expr_stmt|;
name|InterlockedIncrement
argument_list|(
operator|&
name|handler_pkts
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"Received %d bytes fd %d in buffer %p from %s, state = %s\n"
operator|,
name|buff
operator|->
name|recv_length
operator|,
operator|(
name|int
operator|)
name|buff
operator|->
name|fd
operator|,
name|buff
operator|,
name|stoa
argument_list|(
operator|&
name|buff
operator|->
name|recv_srcadr
argument_list|)
operator|,
name|st_packet_handling
index|[
name|rc
index|]
operator|)
argument_list|)
expr_stmt|;
name|iohpQueueLocked
argument_list|(
name|iopad
argument_list|,
name|iohpEndPointOK
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
name|iohpDetach
argument_list|(
name|iopad
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|OnSocketSend
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
comment|/* this is somewhat easier: */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"OnSocketSend: send to socket failed"
decl_stmt|;
name|IoHndPad_T
modifier|*
name|iopad
init|=
name|NULL
decl_stmt|;
name|endpt
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* order is important -- check first, then get endpoint! */
name|rc
operator|=
name|socketErrorCheck
argument_list|(
name|lpo
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|ep
operator|=
name|getEndptFromIoCtx
argument_list|(
name|lpo
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/* Make sure this endpoint is not closed. */
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|rc
operator|!=
name|PKT_OK
condition|)
block|{
name|InterlockedIncrement
argument_list|(
operator|&
name|ep
operator|->
name|notsent
argument_list|)
expr_stmt|;
name|InterlockedDecrement
argument_list|(
operator|&
name|ep
operator|->
name|sent
argument_list|)
expr_stmt|;
name|InterlockedIncrement
argument_list|(
operator|&
name|packets_notsent
argument_list|)
expr_stmt|;
name|InterlockedDecrement
argument_list|(
operator|&
name|packets_sent
argument_list|)
expr_stmt|;
block|}
name|IoCtxRelease
argument_list|(
name|lpo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * register and de-register interface endpoints with the IO engine  * --------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|OnInterfaceDetach
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
name|IoHndPad_T
modifier|*
name|iopad
init|=
name|lpo
operator|->
name|iopad
decl_stmt|;
name|INSIST
argument_list|(
name|NULL
operator|!=
name|iopad
argument_list|)
expr_stmt|;
name|iopad
operator|->
name|handles
index|[
literal|0
index|]
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|iopad
operator|->
name|handles
index|[
literal|1
index|]
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|iopad
operator|->
name|rsrc
operator|.
name|ept
operator|=
name|NULL
expr_stmt|;
name|SetEvent
argument_list|(
name|lpo
operator|->
name|ppswake
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_function
name|BOOL
name|io_completion_port_add_interface
parameter_list|(
name|endpt
modifier|*
name|ep
parameter_list|)
block|{
comment|/* Registering an endpoint is simple: allocate a shared lock for 	 * the enpoint and return if the allocation was successful. 	 */
name|ep
operator|->
name|ioreg_ctx
operator|=
name|iohpCreate
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|ep
operator|->
name|ioreg_ctx
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_function
name|void
name|io_completion_port_remove_interface
parameter_list|(
name|endpt
modifier|*
name|ep
parameter_list|)
block|{
comment|/* Removing an endpoint is simple, too: Lock the shared lock 	 * for write access, then invalidate the handles and the 	 * endpoint pointer. Do an additional detach and leave the 	 * write lock. 	 */
name|IoHndPad_T
modifier|*
name|iopad
init|=
operator|(
name|IoHndPad_T
operator|*
operator|)
name|ep
operator|->
name|ioreg_ctx
decl_stmt|;
name|INSIST
argument_list|(
name|hndIOCPLPort
operator|&&
name|hMainRpcDone
argument_list|)
expr_stmt|;
if|if
condition|(
name|iopad
condition|)
name|iocpl_notify
argument_list|(
name|iopad
argument_list|,
name|OnInterfaceDetach
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * register and de-register sockets for an endpoint  * --------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|OnSocketDetach
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
name|IoHndPad_T
modifier|*
name|iopad
init|=
name|lpo
operator|->
name|iopad
decl_stmt|;
name|INSIST
argument_list|(
name|NULL
operator|!=
name|iopad
argument_list|)
expr_stmt|;
if|if
condition|(
name|iopad
operator|->
name|handles
index|[
literal|0
index|]
operator|==
name|lpo
operator|->
name|io
operator|.
name|hnd
condition|)
name|iopad
operator|->
name|handles
index|[
literal|0
index|]
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
if|if
condition|(
name|iopad
operator|->
name|handles
index|[
literal|1
index|]
operator|==
name|lpo
operator|->
name|io
operator|.
name|hnd
condition|)
name|iopad
operator|->
name|handles
index|[
literal|1
index|]
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|SetEvent
argument_list|(
name|lpo
operator|->
name|ppswake
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a socket handle to the I/O completion port, and send  * NTP_RECVS_PER_SOCKET receive requests to the kernel.  */
end_comment

begin_function
name|BOOL
name|io_completion_port_add_socket
parameter_list|(
name|SOCKET
name|sfd
parameter_list|,
name|endpt
modifier|*
name|ep
parameter_list|,
name|BOOL
name|bcast
parameter_list|)
block|{
comment|/* Assume the endpoint is already registered. Set the socket 	 * handle into the proper slot, and then start up the IO engine. 	 */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"Can't add socket to i/o completion port"
decl_stmt|;
name|IoCtx_t
modifier|*
name|lpo
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|ULONG_PTR
name|key
decl_stmt|;
name|IoHndPad_T
modifier|*
name|iopad
init|=
name|NULL
decl_stmt|;
name|key
operator|=
operator|(
operator|(
name|ULONG_PTR
operator|)
name|ep
operator|&
operator|~
operator|(
name|ULONG_PTR
operator|)
literal|1u
operator|)
operator|+
operator|!
operator|!
name|bcast
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|iopad
operator|=
operator|(
name|IoHndPad_T
operator|*
operator|)
name|ep
operator|->
name|ioreg_ctx
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"io_completion_port_add_socket: endpt = %p not registered, exiting"
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|endpt
modifier|*
name|rep
init|=
name|iopad
operator|->
name|rsrc
operator|.
name|ept
decl_stmt|;
name|iopad
operator|->
name|handles
index|[
operator|!
operator|!
name|bcast
index|]
operator|=
operator|(
name|HANDLE
operator|)
name|sfd
expr_stmt|;
name|INSIST
argument_list|(
name|rep
operator|==
name|ep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|==
name|CreateIoCompletionPort
argument_list|(
operator|(
name|HANDLE
operator|)
name|sfd
argument_list|,
name|hndIOCPLPort
argument_list|,
name|key
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %m"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|n
operator|=
name|s_SockRecvSched
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
block|{
if|if
condition|(
name|NULL
operator|==
operator|(
name|lpo
operator|=
name|IoCtxAlloc
argument_list|(
name|ep
operator|->
name|ioreg_ctx
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: no read buffer: %m"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|lpo
operator|->
name|io
operator|.
name|sfd
operator|=
name|sfd
expr_stmt|;
if|if
condition|(
operator|!
name|QueueSocketRecv
argument_list|(
name|lpo
argument_list|,
name|get_free_recv_buffer_alloc
argument_list|()
argument_list|)
condition|)
goto|goto
name|fail
goto|;
block|}
return|return
name|TRUE
return|;
name|fail
label|:
name|ep
operator|->
name|ioreg_ctx
operator|=
name|iohpDetach
argument_list|(
name|ep
operator|->
name|ioreg_ctx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_function
name|void
name|io_completion_port_remove_socket
parameter_list|(
name|SOCKET
name|fd
parameter_list|,
name|endpt
modifier|*
name|ep
parameter_list|)
block|{
comment|/* Lock the shared lock for write, then search the given 	 * socket handle and replace it with an invalid handle value. 	 */
name|IoHndPad_T
modifier|*
name|iopad
init|=
operator|(
name|IoHndPad_T
operator|*
operator|)
name|ep
operator|->
name|ioreg_ctx
decl_stmt|;
name|INSIST
argument_list|(
name|hndIOCPLPort
operator|&&
name|hMainRpcDone
argument_list|)
expr_stmt|;
if|if
condition|(
name|iopad
condition|)
name|iocpl_notify
argument_list|(
name|iopad
argument_list|,
name|OnSocketDetach
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * I/O API functions for endpoints / interfaces  * --------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* io_completion_port_sendto() -- sendto() replacement for Windows  *  * Returns len after successful send.  * Returns -1 for any error, with the error code available via  *	msyslog() %m, or GetLastError().  */
end_comment

begin_function
name|int
name|io_completion_port_sendto
parameter_list|(
name|endpt
modifier|*
name|ep
parameter_list|,
name|SOCKET
name|sfd
parameter_list|,
name|void
modifier|*
name|pkt
parameter_list|,
name|size_t
name|len
parameter_list|,
name|sockaddr_u
modifier|*
name|dest
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"sendto: cannot schedule socket send"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|dmsg
init|=
literal|"overlapped IO data buffer"
decl_stmt|;
name|IoCtx_t
modifier|*
name|lpo
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|dbuf
init|=
name|NULL
decl_stmt|;
name|WSABUF
name|wsabuf
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|INT_MAX
condition|)
name|len
operator|=
name|INT_MAX
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|dbuf
operator|=
name|IOCPLPoolMemDup
argument_list|(
name|pkt
argument_list|,
name|len
argument_list|,
name|dmsg
argument_list|)
operator|)
condition|)
goto|goto
name|fail
goto|;
comment|/* We register the IO operation against the shared lock here. 	 * This is not strictly necessary, since the callback does not 	 * access the endpoint structure in any way... 	 */
if|if
condition|(
name|NULL
operator|==
operator|(
name|lpo
operator|=
name|IoCtxAlloc
argument_list|(
name|ep
operator|->
name|ioreg_ctx
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
goto|goto
name|fail
goto|;
name|lpo
operator|->
name|onIoDone
operator|=
name|OnSocketSend
expr_stmt|;
name|lpo
operator|->
name|trans_buf
operator|=
name|dbuf
expr_stmt|;
name|lpo
operator|->
name|flRawMem
operator|=
literal|1
expr_stmt|;
name|lpo
operator|->
name|io
operator|.
name|sfd
operator|=
name|sfd
expr_stmt|;
name|wsabuf
operator|.
name|buf
operator|=
operator|(
name|void
operator|*
operator|)
name|lpo
operator|->
name|trans_buf
expr_stmt|;
name|wsabuf
operator|.
name|len
operator|=
operator|(
name|DWORD
operator|)
name|len
expr_stmt|;
name|rc
operator|=
name|WSASendTo
argument_list|(
name|sfd
argument_list|,
operator|&
name|wsabuf
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|dest
operator|->
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
name|dest
argument_list|)
argument_list|,
operator|&
name|lpo
operator|->
name|ol
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|||
name|IoResultCheck
argument_list|(
operator|(
name|DWORD
operator|)
name|WSAGetLastError
argument_list|()
argument_list|,
name|lpo
argument_list|,
name|msg
argument_list|)
condition|)
return|return
operator|(
name|int
operator|)
name|len
return|;
comment|/* normal/success return */
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|-
literal|1
return|;
name|fail
label|:
name|IoCtxFree
argument_list|(
name|lpo
argument_list|)
expr_stmt|;
name|IOCPLPoolFree
argument_list|(
name|dbuf
argument_list|,
name|dmsg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * GetReceivedBuffers  * Note that this is in effect the main loop for processing requests  * both send and receive. This should be reimplemented  */
end_comment

begin_function
name|int
name|GetReceivedBuffers
parameter_list|(
name|void
parameter_list|)
block|{
name|DWORD
name|index
decl_stmt|;
name|HANDLE
name|ready
decl_stmt|;
name|int
name|errcode
decl_stmt|;
name|BOOL
name|dynbuf
decl_stmt|;
name|BOOL
name|have_packet
decl_stmt|;
name|char
modifier|*
name|msgbuf
decl_stmt|;
name|have_packet
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|have_packet
condition|)
block|{
name|index
operator|=
name|WaitForMultipleObjectsEx
argument_list|(
name|ActiveWaitHandles
argument_list|,
name|WaitHandles
argument_list|,
name|FALSE
argument_list|,
name|INFINITE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|WAIT_OBJECT_0
operator|+
literal|0
case|:
comment|/* Io event */
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"IoEvent occurred\n"
operator|)
argument_list|)
expr_stmt|;
name|have_packet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|WAIT_OBJECT_0
operator|+
literal|1
case|:
comment|/* exit request */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|WAIT_OBJECT_0
operator|+
literal|2
case|:
comment|/* timer */
name|timer
argument_list|()
expr_stmt|;
break|break;
case|case
name|WAIT_IO_COMPLETION
case|:
comment|/* there might be something after APC */
name|have_packet
operator|=
operator|!
operator|!
name|full_recvbuffs
argument_list|()
expr_stmt|;
break|break;
case|case
name|WAIT_TIMEOUT
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WaitForMultipleObjectsEx INFINITE timed out."
argument_list|)
expr_stmt|;
break|break;
case|case
name|WAIT_FAILED
case|:
name|dynbuf
operator|=
name|FALSE
expr_stmt|;
name|errcode
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|msgbuf
operator|=
name|NTstrerror
argument_list|(
name|errcode
argument_list|,
operator|&
name|dynbuf
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WaitForMultipleObjectsEx Failed: Errcode = %n, msg = %s"
argument_list|,
name|errcode
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynbuf
condition|)
name|LocalFree
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DEBUG_INSIST
argument_list|(
operator|(
name|index
operator|-
name|WAIT_OBJECT_0
operator|)
operator|<
name|ActiveWaitHandles
argument_list|)
expr_stmt|;
name|ready
operator|=
name|WaitHandles
index|[
name|index
operator|-
name|WAIT_OBJECT_0
index|]
expr_stmt|;
name|handle_blocking_resp_sem
argument_list|(
name|ready
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
return|return
operator|(
name|full_recvbuffs
argument_list|()
operator|)
return|;
comment|/* get received buffers */
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*defined(HAVE_IO_COMPLETION_PORT) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|NonEmptyCompilationUnit
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!defined(HAVE_IO_COMPLETION_PORT) */
end_comment

end_unit

