begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ----------------------------------------------------------------------- This is the IO completion port handling for async/overlapped IO on Windows>= Win2000.  Some notes on the implementation:  + Only one thread is used to serve the IO completion port, for several   reasons:    * First, there seems to be (have been?) trouble that locked up NTPD     when more than one thread was used for IOCPL.    * Second, for the sake of the time stamp interpolation the threads     must run on the same CPU as the time interpolation thread. This     makes using more than one thread useless, as they would compete for     the same core and create contention.  + Some IO operations need a possibly lengthy postprocessing. Emulating   the UN*X line discipline is currently the only but prominent example.   To avoid the processing in the time-critical IOCPL thread, longer   processing is offloaded the worker thread pool.  + A fact that seems not as well-known as it should be is that all   ressources passed to an overlapped IO operation must be considered   owned by the OS until the result has been fetched/dequeued. This   includes all overlapped structures and buffers involved, so cleaning   up on shutdown must be carefully constructed. (This includes closing   all the IO handles and waiting for the results to be dequeued.   'CancleIo()' cannot be used since it's broken beyond repair.)    If this is not possible, then all ressources should be dropped into   oblivion -- otherwise "bad things (tm)" are bound to happen.    Using a private heap that is silently dropped but not deleted is a   good way to avoid cluttering memory stats with IO context related   objects. Leak tracing becomes more interesting, though.   The current implementation is based on the work of Danny Mayer who improved the original implementation and Dave Hart who improved on the serial I/O routines. The true roots of this file seem to be shrouded by the mist of time...   This version still provides the 'user space PPS' emulation feature.  Juergen Perlinger (perlinger@ntp.org) Feb 2012  ----------------------------------------------------------------------- */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_IO_COMPLETION_PORT
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_machine.h"
end_include

begin_include
include|#
directive|include
file|"ntp_iocompletionport.h"
end_include

begin_include
include|#
directive|include
file|"ntp_request.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_lists.h"
end_include

begin_define
define|#
directive|define
name|CONTAINEROF
parameter_list|(
name|p
parameter_list|,
name|type
parameter_list|,
name|member
parameter_list|)
define|\
value|((type *)((char *)(p) - offsetof(type, member)))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|push
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|201
name|)
end_pragma

begin_comment
comment|/* nonstd extension nameless union */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ---------------------------------------------------------------------  * storage type for PPS data (DCD change counts& times)  * ---------------------------------------------------------------------  */
end_comment

begin_struct
struct|struct
name|PpsData
block|{
name|u_long
name|cc_assert
decl_stmt|;
name|u_long
name|cc_clear
decl_stmt|;
name|l_fp
name|ts_assert
decl_stmt|;
name|l_fp
name|ts_clear
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|PpsData
name|PPSData_t
typedef|;
end_typedef

begin_struct
struct|struct
name|PpsDataEx
block|{
name|u_long
name|cov_count
decl_stmt|;
name|PPSData_t
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
specifier|volatile
name|struct
name|PpsDataEx
name|PPSDataEx_t
typedef|;
end_typedef

begin_comment
comment|/*  * ---------------------------------------------------------------------  * device context; uses reference counting to avoid nasty surprises.  * Currently this stores only the PPS time stamps, but it could be  * easily extended.  * ---------------------------------------------------------------------  */
end_comment

begin_define
define|#
directive|define
name|PPS_QUEUE_LEN
value|8u
end_define

begin_comment
comment|/* must be power of two! */
end_comment

begin_define
define|#
directive|define
name|PPS_QUEUE_MSK
value|(PPS_QUEUE_LEN-1)
end_define

begin_comment
comment|/* mask for easy MOD ops */
end_comment

begin_struct
struct|struct
name|DeviceContext
block|{
specifier|volatile
name|long
name|ref_count
decl_stmt|;
specifier|volatile
name|u_long
name|cov_count
decl_stmt|;
name|PPSData_t
name|pps_data
decl_stmt|;
name|PPSDataEx_t
name|pps_buff
index|[
name|PPS_QUEUE_LEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|DeviceContext
name|DevCtx_t
typedef|;
end_typedef

begin_comment
comment|/*  * ---------------------------------------------------------------------  * I/O context structure  *  * This is an extended overlapped structure. Some fields are only used  * for serial I/O, others are used for all operations. The serial I/O is  * more interesting since the same context object is used for waiting,  * actual I/O and possibly offload processing in a worker thread until  * a complete operation cycle is done.  *  * In this case the I/O context is used to gather all the bits that are  * finally needed for the processing of the buffer.  * ---------------------------------------------------------------------  */
end_comment

begin_comment
comment|//struct IoCtx;
end_comment

begin_typedef
typedef|typedef
name|struct
name|IoCtx
name|IoCtx_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|refclockio
name|RIO_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|IoCompleteFunc
function_decl|)
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|IoCtx
block|{
name|OVERLAPPED
name|ol
decl_stmt|;
comment|/* 'kernel' part of the context	*/
union|union
block|{
name|recvbuf_t
modifier|*
name|recv_buf
decl_stmt|;
comment|/* incoming -> buffer structure	*/
name|void
modifier|*
name|trans_buf
decl_stmt|;
comment|/* outgoing -> char array	*/
name|PPSData_t
modifier|*
name|pps_buf
decl_stmt|;
comment|/* for reading PPS seq/stamps	*/
name|HANDLE
name|ppswake
decl_stmt|;
comment|/* pps wakeup for attach	*/
block|}
union|;
name|IoCompleteFunc
name|onIoDone
decl_stmt|;
comment|/* HL callback to execute	*/
name|RIO_t
modifier|*
name|rio
decl_stmt|;
comment|/* RIO backlink (for offload)	*/
name|DevCtx_t
modifier|*
name|devCtx
decl_stmt|;
name|l_fp
name|DCDSTime
decl_stmt|;
comment|/* PPS-hack: time of DCD ON	*/
name|l_fp
name|FlagTime
decl_stmt|;
comment|/* timestamp of flag/event char */
name|l_fp
name|RecvTime
decl_stmt|;
comment|/* timestamp of callback        */
name|DWORD
name|errCode
decl_stmt|;
comment|/* error code of last I/O	*/
name|DWORD
name|byteCount
decl_stmt|;
comment|/* byte count     "             */
name|DWORD
name|com_events
decl_stmt|;
comment|/* buffer for COM events	*/
name|unsigned
name|int
name|flRawMem
range|:
literal|1
decl_stmt|;
comment|/* buffer is raw memory -> free */
name|unsigned
name|int
name|flTsDCDS
range|:
literal|1
decl_stmt|;
comment|/* DCDSTime valid?		*/
name|unsigned
name|int
name|flTsFlag
range|:
literal|1
decl_stmt|;
comment|/* FlagTime valid?		*/
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|pop
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * local function definitions  */
end_comment

begin_function_decl
specifier|static
name|void
name|ntpd_addremove_semaphore
parameter_list|(
name|HANDLE
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|set_serial_recv_time
parameter_list|(
name|recvbuf_t
modifier|*
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Initiate/Request async IO operations */
end_comment

begin_function_decl
specifier|static
name|BOOL
name|QueueSerialWait
parameter_list|(
name|RIO_t
modifier|*
parameter_list|,
name|recvbuf_t
modifier|*
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOL
name|QueueSerialRead
parameter_list|(
name|RIO_t
modifier|*
parameter_list|,
name|recvbuf_t
modifier|*
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOL
name|QueueRawSerialRead
parameter_list|(
name|RIO_t
modifier|*
parameter_list|,
name|recvbuf_t
modifier|*
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOL
name|QueueSocketRecv
parameter_list|(
name|SOCKET
parameter_list|,
name|recvbuf_t
modifier|*
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* High-level IO callback functions */
end_comment

begin_function_decl
specifier|static
name|void
name|OnSocketRecv
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|OnSerialWaitComplete
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|OnSerialReadComplete
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|OnRawSerialReadComplete
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|OnSerialWriteComplete
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* worker pool offload functions */
end_comment

begin_function_decl
specifier|static
name|DWORD
name|WINAPI
name|OnSerialReadWorker
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* keep a list to traverse to free memory on debug builds */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|free_io_completion_port_mem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|HANDLE
name|WaitableExitEventHandle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HANDLE
name|WaitableIoEventHandle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HANDLE
name|hIoCompletionPort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DWORD
name|ActiveWaitHandles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HANDLE
name|WaitHandles
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * -------------------------------------------------------------------  * We make a pool of our own for IO context objects -- the are owned by  * the system until a completion result is pulled from the queue, and  * they seriously go into the way of memory tracking until we can safely  * cancel an IO request.  * -------------------------------------------------------------------  */
end_comment

begin_decl_stmt
specifier|static
name|HANDLE
name|hHeapHandle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * Create a new heap for IO context objects  */
end_comment

begin_function
specifier|static
name|void
name|IoCtxPoolInit
parameter_list|(
name|size_t
name|initObjs
parameter_list|)
block|{
name|hHeapHandle
operator|=
name|HeapCreate
argument_list|(
literal|0
argument_list|,
name|initObjs
operator|*
sizeof|sizeof
argument_list|(
name|IoCtx_t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hHeapHandle
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't initialize Heap: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  *  * Delete the IO context heap  *  * Since we do not know what callbacks are pending, we just drop the  * pool into oblivion. New allocs and frees will fail from this moment,  * but we simply don't care. At least the normal heap dump stats will  * show no leaks from IO context blocks. On the downside, we have to  * track them ourselves if something goes wrong.  */
end_comment

begin_function
specifier|static
name|void
name|IoCtxPoolDone
parameter_list|(
name|void
parameter_list|)
block|{
name|hHeapHandle
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * Alloc& Free on local heap  *  * When the heap handle is NULL, these both will fail; Alloc with a NULL  * return and Free silently.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|__fastcall
name|LocalPoolAlloc
parameter_list|(
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|desc
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
comment|/* Windows heaps can't grok zero byte allocation. 	 * We just get one byte. 	 */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hHeapHandle
operator|!=
name|NULL
condition|)
name|ptr
operator|=
name|HeapAlloc
argument_list|(
name|hHeapHandle
argument_list|,
name|HEAP_ZERO_MEMORY
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|=
name|NULL
expr_stmt|;
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"Allocate '%s', heap=%p, ptr=%p\n"
operator|,
name|desc
operator|,
name|hHeapHandle
operator|,
name|ptr
operator|)
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__fastcall
name|LocalPoolFree
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|desc
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|3
argument_list|,
operator|(
literal|"Free '%s', heap=%p, ptr=%p\n"
operator|,
name|desc
operator|,
name|hHeapHandle
operator|,
name|ptr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
operator|&&
name|hHeapHandle
operator|!=
name|NULL
condition|)
name|HeapFree
argument_list|(
name|hHeapHandle
argument_list|,
literal|0
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * Alloc& Free of Device context  *  * When the heap handle is NULL, these both will fail; Alloc with a NULL  * return and Free silently.  */
end_comment

begin_function
specifier|static
name|DevCtx_t
modifier|*
name|__fastcall
name|DevCtxAlloc
parameter_list|(
name|void
parameter_list|)
block|{
name|DevCtx_t
modifier|*
name|devCtx
decl_stmt|;
name|u_long
name|slot
decl_stmt|;
comment|/* allocate struct and tag all slots as invalid */
name|devCtx
operator|=
operator|(
name|DevCtx_t
operator|*
operator|)
name|LocalPoolAlloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DevCtx_t
argument_list|)
argument_list|,
literal|"DEV ctx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|devCtx
operator|!=
name|NULL
condition|)
block|{
comment|/* The initial COV values make sure there is no busy 		 * loop on unused/empty slots. 		 */
name|devCtx
operator|->
name|cov_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|PPS_QUEUE_LEN
condition|;
name|slot
operator|++
control|)
name|devCtx
operator|->
name|pps_buff
index|[
name|slot
index|]
operator|.
name|cov_count
operator|=
operator|~
name|slot
expr_stmt|;
block|}
return|return
name|devCtx
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__fastcall
name|DevCtxFree
parameter_list|(
name|DevCtx_t
modifier|*
name|devCtx
parameter_list|)
block|{
comment|/* this would be the place to get rid of managed ressources. */
name|LocalPoolFree
argument_list|(
name|devCtx
argument_list|,
literal|"DEV ctx"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|DevCtx_t
modifier|*
name|__fastcall
name|DevCtxAttach
parameter_list|(
name|DevCtx_t
modifier|*
name|devCtx
parameter_list|)
block|{
if|if
condition|(
name|devCtx
operator|!=
name|NULL
condition|)
name|InterlockedIncrement
argument_list|(
operator|&
name|devCtx
operator|->
name|ref_count
argument_list|)
expr_stmt|;
return|return
name|devCtx
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__fastcall
name|DevCtxDetach
parameter_list|(
name|DevCtx_t
modifier|*
name|devCtx
parameter_list|)
block|{
if|if
condition|(
name|devCtx
operator|&&
operator|!
name|InterlockedDecrement
argument_list|(
operator|&
name|devCtx
operator|->
name|ref_count
argument_list|)
condition|)
name|DevCtxFree
argument_list|(
name|devCtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * Alloc& Free of I/O context  *  * When the heap handle is NULL, these both will fail; Alloc with a NULL  * return and Free silently.  */
end_comment

begin_function
specifier|static
name|IoCtx_t
modifier|*
name|__fastcall
name|IoCtxAlloc
parameter_list|(
name|DevCtx_t
modifier|*
name|devCtx
parameter_list|)
block|{
name|IoCtx_t
modifier|*
name|ioCtx
decl_stmt|;
name|ioCtx
operator|=
operator|(
name|IoCtx_t
operator|*
operator|)
name|LocalPoolAlloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IoCtx_t
argument_list|)
argument_list|,
literal|"IO ctx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioCtx
operator|!=
name|NULL
condition|)
name|ioCtx
operator|->
name|devCtx
operator|=
name|DevCtxAttach
argument_list|(
name|devCtx
argument_list|)
expr_stmt|;
return|return
name|ioCtx
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__fastcall
name|IoCtxFree
parameter_list|(
name|IoCtx_t
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
condition|)
name|DevCtxDetach
argument_list|(
name|ctx
operator|->
name|devCtx
argument_list|)
expr_stmt|;
name|LocalPoolFree
argument_list|(
name|ctx
argument_list|,
literal|"IO ctx"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__fastcall
name|IoCtxReset
parameter_list|(
name|IoCtx_t
modifier|*
name|ctx
parameter_list|)
block|{
name|RIO_t
modifier|*
name|rio
decl_stmt|;
name|DevCtx_t
modifier|*
name|dev
decl_stmt|;
if|if
condition|(
name|ctx
condition|)
block|{
name|rio
operator|=
name|ctx
operator|->
name|rio
expr_stmt|;
name|dev
operator|=
name|ctx
operator|->
name|devCtx
expr_stmt|;
name|ZERO
argument_list|(
operator|*
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|rio
operator|=
name|rio
expr_stmt|;
name|ctx
operator|->
name|devCtx
operator|=
name|dev
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * The IO completion thread and support functions  *  * There is only one completion thread, because it is locked to the same  * core as the time interpolation. Having more than one causes core  * contention and is not useful.  * -------------------------------------------------------------------  */
end_comment

begin_decl_stmt
specifier|static
name|HANDLE
name|hIoCompletionThread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UINT
name|tidCompletionThread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * The IO completion worker thread  *  * Note that this thread does not enter an alertable wait state and that  * the only waiting point is the IO completion port. If stopping this  * thread with a special queued result packet does not work,  * 'TerminateThread()' is the only remaining weapon in the arsenal. A  * dangerous weapon -- it's like SIGKILL.  */
end_comment

begin_function
specifier|static
name|unsigned
name|WINAPI
name|iocompletionthread
parameter_list|(
name|void
modifier|*
name|NotUsed
parameter_list|)
block|{
name|DWORD
name|err
decl_stmt|;
name|DWORD
name|octets
decl_stmt|;
name|ULONG_PTR
name|key
decl_stmt|;
name|OVERLAPPED
modifier|*
name|pol
decl_stmt|;
name|IoCtx_t
modifier|*
name|lpo
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|NotUsed
argument_list|)
expr_stmt|;
comment|/* 	 * Socket and refclock receive call gettimeofday() so the I/O 	 * thread needs to be on the same processor as the main and 	 * timing threads to ensure consistent QueryPerformanceCounter() 	 * results. 	 * 	 * This gets seriously into the way of efficient thread pooling 	 * on multicore systems. 	 */
name|lock_thread_to_processor
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 	 * Set the thread priority high enough so I/O will preempt 	 * normal recv packet processing, but not higher than the timer 	 * sync thread. 	 */
if|if
condition|(
operator|!
name|SetThreadPriority
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|,
name|THREAD_PRIORITY_ABOVE_NORMAL
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't set thread priority: %m"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|GetQueuedCompletionStatus
argument_list|(
name|hIoCompletionPort
argument_list|,
operator|&
name|octets
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|pol
argument_list|,
name|INFINITE
argument_list|)
condition|)
block|{
name|err
operator|=
name|ERROR_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|==
name|pol
condition|)
block|{
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"Overlapped IO Thread Exiting\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* fail */
block|}
name|lpo
operator|=
name|CONTAINEROF
argument_list|(
name|pol
argument_list|,
name|IoCtx_t
argument_list|,
name|ol
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|lpo
operator|->
name|RecvTime
argument_list|)
expr_stmt|;
name|lpo
operator|->
name|byteCount
operator|=
name|octets
expr_stmt|;
name|lpo
operator|->
name|errCode
operator|=
name|err
expr_stmt|;
name|handler_calls
operator|++
expr_stmt|;
call|(
modifier|*
name|lpo
operator|->
name|onIoDone
call|)
argument_list|(
name|key
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Create/initialise the I/O creation port  */
end_comment

begin_function
name|void
name|init_io_completion_port
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|atexit
argument_list|(
operator|&
name|free_io_completion_port_mem
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create the context pool first. */
name|IoCtxPoolInit
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Create the event used to signal an IO event */
name|WaitableIoEventHandle
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|WaitableIoEventHandle
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't create I/O event handle: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Create the event used to signal an exit event */
name|WaitableExitEventHandle
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|WaitableExitEventHandle
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't create exit event handle: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Create the IO completion port */
name|hIoCompletionPort
operator|=
name|CreateIoCompletionPort
argument_list|(
name|INVALID_HANDLE_VALUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hIoCompletionPort
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't create I/O completion port: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the Wait Handles table */
name|WaitHandles
index|[
literal|0
index|]
operator|=
name|WaitableIoEventHandle
expr_stmt|;
name|WaitHandles
index|[
literal|1
index|]
operator|=
name|WaitableExitEventHandle
expr_stmt|;
comment|/* exit request */
name|WaitHandles
index|[
literal|2
index|]
operator|=
name|WaitableTimerHandle
expr_stmt|;
name|ActiveWaitHandles
operator|=
literal|3
expr_stmt|;
comment|/* 	 * Supply ntp_worker.c with function to add or remove a 	 * semaphore to the ntpd I/O loop which is signalled by a worker 	 * when a response is ready.  The callback is invoked in the 	 * parent. 	 */
name|addremove_io_semaphore
operator|=
operator|&
name|ntpd_addremove_semaphore
expr_stmt|;
comment|/* 	 * Have one thread servicing I/O. See rationale in front matter.  	 */
name|hIoCompletionThread
operator|=
operator|(
name|HANDLE
operator|)
name|_beginthreadex
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|iocompletionthread
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|tidCompletionThread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * completion port teardown  */
end_comment

begin_function
name|void
name|uninit_io_completion_port
parameter_list|(
name|void
parameter_list|)
block|{
name|DWORD
name|rc
decl_stmt|;
comment|/* do noting if completion port already gone. */
if|if
condition|(
name|NULL
operator|==
name|hIoCompletionPort
condition|)
return|return;
comment|/* 	 * Service thread seems running. Terminate him with grace 	 * first and force later... 	 */
if|if
condition|(
name|tidCompletionThread
operator|!=
name|GetCurrentThreadId
argument_list|()
condition|)
block|{
name|PostQueuedCompletionStatus
argument_list|(
name|hIoCompletionPort
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|WaitForSingleObject
argument_list|(
name|hIoCompletionThread
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|WAIT_TIMEOUT
condition|)
block|{
comment|/* Thread lost. Kill off with TerminateThread. */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"IO completion thread refuses to terminate"
argument_list|)
expr_stmt|;
name|TerminateThread
argument_list|(
name|hIoCompletionThread
argument_list|,
operator|~
literal|0UL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* stop using the memory pool */
name|IoCtxPoolDone
argument_list|()
expr_stmt|;
comment|/* now reap all handles... */
name|CloseHandle
argument_list|(
name|hIoCompletionThread
argument_list|)
expr_stmt|;
name|hIoCompletionThread
operator|=
name|NULL
expr_stmt|;
name|CloseHandle
argument_list|(
name|hIoCompletionPort
argument_list|)
expr_stmt|;
name|hIoCompletionPort
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * external worker thread support (wait handle stuff)  *  * !Attention!  *  *  - This function must only be called from the main thread. Changing  *    a set of wait handles while someone is waiting on it creates  *    undefined behaviour. Also there's no provision for mutual  *    exclusion when accessing global values.   *  *  - It's not possible to register a handle that is already in the table.  */
end_comment

begin_function
specifier|static
name|void
name|ntpd_addremove_semaphore
parameter_list|(
name|HANDLE
name|sem
parameter_list|,
name|int
name|remove
parameter_list|)
block|{
name|DWORD
name|hi
decl_stmt|;
comment|/* search for a matching entry first. */
for|for
control|(
name|hi
operator|=
literal|3
init|;
name|hi
operator|<
name|ActiveWaitHandles
condition|;
name|hi
operator|++
control|)
if|if
condition|(
name|sem
operator|==
name|WaitHandles
index|[
name|hi
index|]
condition|)
break|break;
if|if
condition|(
name|remove
condition|)
block|{
comment|/* 		 * If found, eventually swap with last entry to keep 		 * the table dense. 		 */
if|if
condition|(
name|hi
operator|<
name|ActiveWaitHandles
condition|)
block|{
name|ActiveWaitHandles
operator|--
expr_stmt|;
if|if
condition|(
name|hi
operator|<
name|ActiveWaitHandles
condition|)
name|WaitHandles
index|[
name|hi
index|]
operator|=
name|WaitHandles
index|[
name|ActiveWaitHandles
index|]
expr_stmt|;
name|WaitHandles
index|[
name|ActiveWaitHandles
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Make sure the entry is not found and there is enough 		 * room, then append to the table array. 		 */
if|if
condition|(
name|hi
operator|>=
name|ActiveWaitHandles
condition|)
block|{
name|NTP_INSIST
argument_list|(
name|ActiveWaitHandles
operator|<
name|COUNTOF
argument_list|(
name|WaitHandles
argument_list|)
argument_list|)
expr_stmt|;
name|WaitHandles
index|[
name|ActiveWaitHandles
index|]
operator|=
name|sem
expr_stmt|;
name|ActiveWaitHandles
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|free_io_completion_port_mem
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * At the moment, do absolutely nothing. Returning memory here 	 * requires NO PENDING OVERLAPPED OPERATIONS AT ALL at this 	 * point in time, and as long we cannot be reasonable sure about 	 * that the simple advice is: 	 * 	 * HANDS OFF! 	 */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * Prelude -- common error checking code  * -------------------------------------------------------------------  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|NTstrerror
parameter_list|(
name|int
name|err
parameter_list|,
name|BOOL
modifier|*
name|bfreebuf
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|BOOL
name|IoResultCheck
parameter_list|(
name|DWORD
name|err
parameter_list|,
name|IoCtx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|char
modifier|*
name|msgbuf
decl_stmt|;
name|BOOL
name|dynbuf
decl_stmt|;
comment|/* If the clock is not / no longer active, assume 	 * 'ERROR_OPERATION_ABORTED' and do the necessary cleanup. 	 */
if|if
condition|(
name|ctx
operator|->
name|rio
operator|&&
operator|!
name|ctx
operator|->
name|rio
operator|->
name|active
condition|)
name|err
operator|=
name|ERROR_OPERATION_ABORTED
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
comment|/* The first ones are no real errors. */
case|case
name|ERROR_SUCCESS
case|:
comment|/* all is good */
case|case
name|ERROR_IO_PENDING
case|:
comment|/* callback pending */
return|return
name|TRUE
return|;
comment|/* the next ones go silently -- only cleanup is done */
case|case
name|ERROR_INVALID_PARAMETER
case|:
comment|/* handle already closed */
case|case
name|ERROR_OPERATION_ABORTED
case|:
comment|/* handle closed while wait */
break|break;
default|default:
comment|/* 		 * We have to resort to the low level error formatting 		 * functions here, since the error code can be an 		 * overlapped result. Relying the value to be the same 		 * as the 'GetLastError()' result at this point of 		 * execution is shaky at best, and using SetLastError() 		 * to force it seems too nasty. 		 */
name|msgbuf
operator|=
name|NTstrerror
argument_list|(
name|err
argument_list|,
operator|&
name|dynbuf
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: err=%u, '%s'"
argument_list|,
name|msg
argument_list|,
name|err
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynbuf
condition|)
name|LocalFree
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If we end here, we have to mop up the buffer and context */
if|if
condition|(
name|ctx
operator|->
name|flRawMem
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|trans_buf
condition|)
name|free
argument_list|(
name|ctx
operator|->
name|trans_buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ctx
operator|->
name|recv_buf
condition|)
name|freerecvbuf
argument_list|(
name|ctx
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
block|}
name|IoCtxFree
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * Part 1 -- COMM event handling  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|BOOL
name|QueueSerialWait
parameter_list|(
name|RIO_t
modifier|*
name|rio
parameter_list|,
name|recvbuf_t
modifier|*
name|buff
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
name|BOOL
name|rc
decl_stmt|;
name|lpo
operator|->
name|onIoDone
operator|=
name|OnSerialWaitComplete
expr_stmt|;
name|lpo
operator|->
name|recv_buf
operator|=
name|buff
expr_stmt|;
name|lpo
operator|->
name|flRawMem
operator|=
literal|0
expr_stmt|;
name|lpo
operator|->
name|rio
operator|=
name|rio
expr_stmt|;
name|buff
operator|->
name|fd
operator|=
name|rio
operator|->
name|fd
expr_stmt|;
name|rc
operator|=
name|WaitCommEvent
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|rio
operator|->
name|fd
argument_list|)
argument_list|,
operator|&
name|lpo
operator|->
name|com_events
argument_list|,
operator|&
name|lpo
operator|->
name|ol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
return|return
name|IoResultCheck
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|lpo
argument_list|,
literal|"Can't wait on Refclock"
argument_list|)
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
end_comment

begin_function
specifier|static
name|void
name|OnSerialWaitComplete
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
name|RIO_t
modifier|*
name|rio
decl_stmt|;
name|DevCtx_t
modifier|*
name|dev
decl_stmt|;
name|recvbuf_t
modifier|*
name|buff
decl_stmt|;
name|PPSDataEx_t
modifier|*
name|ppsbuf
decl_stmt|;
name|DWORD
name|modem_status
decl_stmt|;
name|u_long
name|covc
decl_stmt|;
comment|/* check and bail out if operation failed */
if|if
condition|(
operator|!
name|IoResultCheck
argument_list|(
name|lpo
operator|->
name|errCode
argument_list|,
name|lpo
argument_list|,
literal|"WaitCommEvent failed"
argument_list|)
condition|)
return|return;
comment|/* get& validate context and buffer. */
name|rio
operator|=
operator|(
name|RIO_t
operator|*
operator|)
name|key
expr_stmt|;
name|buff
operator|=
name|lpo
operator|->
name|recv_buf
expr_stmt|;
name|dev
operator|=
name|lpo
operator|->
name|devCtx
expr_stmt|;
name|NTP_INSIST
argument_list|(
name|rio
operator|==
name|lpo
operator|->
name|rio
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|~
operator|(
name|EV_RXFLAG
operator||
name|EV_RLSD
operator||
name|EV_RXCHAR
operator|)
operator|&
name|lpo
operator|->
name|com_events
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WaitCommEvent returned unexpected mask %x"
argument_list|,
name|lpo
operator|->
name|com_events
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Take note of changes on DCD; 'user mode PPS hack'. 	 * perlinger@ntp.org suggested a way of solving several problems with 	 * this code that makes a lot of sense: move to a putative 	 * dcdpps-ppsapi-provider.dll. 	 */
if|if
condition|(
name|EV_RLSD
operator|&
name|lpo
operator|->
name|com_events
condition|)
block|{
name|modem_status
operator|=
literal|0
expr_stmt|;
name|GetCommModemStatus
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|rio
operator|->
name|fd
argument_list|)
argument_list|,
operator|&
name|modem_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
comment|/* PPS-context available -- use it! */
if|if
condition|(
name|MS_RLSD_ON
operator|&
name|modem_status
condition|)
block|{
name|dev
operator|->
name|pps_data
operator|.
name|cc_assert
operator|++
expr_stmt|;
name|dev
operator|->
name|pps_data
operator|.
name|ts_assert
operator|=
name|lpo
operator|->
name|RecvTime
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"upps-real: fd %d DCD PPS Rise at %s\n"
operator|,
name|rio
operator|->
name|fd
operator|,
name|ulfptoa
argument_list|(
operator|&
name|lpo
operator|->
name|RecvTime
argument_list|,
literal|6
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|pps_data
operator|.
name|cc_clear
operator|++
expr_stmt|;
name|dev
operator|->
name|pps_data
operator|.
name|ts_clear
operator|=
name|lpo
operator|->
name|RecvTime
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"upps-real: fd %d DCD PPS Fall at %s\n"
operator|,
name|rio
operator|->
name|fd
operator|,
name|ulfptoa
argument_list|(
operator|&
name|lpo
operator|->
name|RecvTime
argument_list|,
literal|6
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 			** Update PPS buffer, writing from low to high, with index 			** update as last action. We use interlocked ops and a 			** volatile data destination to avoid reordering on compiler 			** and CPU level. The interlocked instruction act as full 			** barriers -- we need only release semantics, but we don't 			** have them before VS2010. 			*/
name|covc
operator|=
name|dev
operator|->
name|cov_count
operator|+
literal|1u
expr_stmt|;
name|ppsbuf
operator|=
name|dev
operator|->
name|pps_buff
operator|+
operator|(
name|covc
operator|&
name|PPS_QUEUE_MSK
operator|)
expr_stmt|;
name|InterlockedExchange
argument_list|(
operator|(
name|PLONG
operator|)
operator|&
name|ppsbuf
operator|->
name|cov_count
argument_list|,
name|covc
argument_list|)
expr_stmt|;
name|ppsbuf
operator|->
name|data
operator|=
name|dev
operator|->
name|pps_data
expr_stmt|;
name|InterlockedExchange
argument_list|(
operator|(
name|PLONG
operator|)
operator|&
name|dev
operator|->
name|cov_count
argument_list|,
name|covc
argument_list|)
expr_stmt|;
block|}
comment|/* perlinger@ntp.org, 2012-11-19 		It can be argued that once you have the PPS API active, you can 		disable the old pps hack. This would give a behaviour that's much 		more like the behaviour under a UN*Xish OS. On the other hand, it 		will give a nasty surprise for people which have until now happily 		taken the pps hack for granted, and after the first complaint, I have 		decided to keep the old implementation unconditionally. So here it is:  		/* backward compat: 'usermode-pps-hack' */
if|if
condition|(
name|MS_RLSD_ON
operator|&
name|modem_status
condition|)
block|{
name|lpo
operator|->
name|DCDSTime
operator|=
name|lpo
operator|->
name|RecvTime
expr_stmt|;
name|lpo
operator|->
name|flTsDCDS
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"upps-hack: fd %d DCD PPS Rise at %s\n"
operator|,
name|rio
operator|->
name|fd
operator|,
name|ulfptoa
argument_list|(
operator|&
name|lpo
operator|->
name|RecvTime
argument_list|,
literal|6
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If IO ready, read data. Go back waiting else. */
if|if
condition|(
name|EV_RXFLAG
operator|&
name|lpo
operator|->
name|com_events
condition|)
block|{
comment|/* line discipline */
name|lpo
operator|->
name|FlagTime
operator|=
name|lpo
operator|->
name|RecvTime
expr_stmt|;
name|lpo
operator|->
name|flTsFlag
operator|=
literal|1
expr_stmt|;
name|QueueSerialRead
argument_list|(
name|rio
argument_list|,
name|buff
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EV_RXCHAR
operator|&
name|lpo
operator|->
name|com_events
condition|)
block|{
comment|/* raw discipline */
name|lpo
operator|->
name|FlagTime
operator|=
name|lpo
operator|->
name|RecvTime
expr_stmt|;
name|lpo
operator|->
name|flTsFlag
operator|=
literal|1
expr_stmt|;
name|QueueRawSerialRead
argument_list|(
name|rio
argument_list|,
name|buff
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* idle... */
name|QueueSerialWait
argument_list|(
name|rio
argument_list|,
name|buff
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * Part 2 -- line discipline emulation  *  * Ideally this should *not* be done in the IO completion thread.  * We use a worker pool thread to offload the low-level processing.  * -------------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * Start& Queue a serial read for line discipline emulation.  */
end_comment

begin_function
specifier|static
name|BOOL
name|QueueSerialRead
parameter_list|(
name|RIO_t
modifier|*
name|rio
parameter_list|,
name|recvbuf_t
modifier|*
name|buff
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
name|BOOL
name|rc
decl_stmt|;
name|lpo
operator|->
name|onIoDone
operator|=
operator|&
name|OnSerialReadComplete
expr_stmt|;
name|lpo
operator|->
name|recv_buf
operator|=
name|buff
expr_stmt|;
name|lpo
operator|->
name|flRawMem
operator|=
literal|0
expr_stmt|;
name|lpo
operator|->
name|rio
operator|=
name|rio
expr_stmt|;
name|buff
operator|->
name|fd
operator|=
name|rio
operator|->
name|fd
expr_stmt|;
name|rc
operator|=
name|ReadFile
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|rio
operator|->
name|fd
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buff
operator|->
name|recv_buffer
operator|+
name|buff
operator|->
name|recv_length
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
operator|->
name|recv_buffer
argument_list|)
operator|-
name|buff
operator|->
name|recv_length
argument_list|,
name|NULL
argument_list|,
operator|&
name|lpo
operator|->
name|ol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
return|return
name|IoResultCheck
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|lpo
argument_list|,
literal|"Can't read from Refclock"
argument_list|)
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * IO completion thread callback. Takes a time stamp and offloads the  * real work to the worker pool ASAP.  */
end_comment

begin_function
specifier|static
name|void
name|OnSerialReadComplete
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
name|RIO_t
modifier|*
name|rio
decl_stmt|;
name|recvbuf_t
modifier|*
name|buff
decl_stmt|;
comment|/* check and bail out if operation failed */
if|if
condition|(
operator|!
name|IoResultCheck
argument_list|(
name|lpo
operator|->
name|errCode
argument_list|,
name|lpo
argument_list|,
literal|"Read from Refclock failed"
argument_list|)
condition|)
return|return;
comment|/* get& validate context and buffer. */
name|rio
operator|=
name|lpo
operator|->
name|rio
expr_stmt|;
name|buff
operator|=
name|lpo
operator|->
name|recv_buf
expr_stmt|;
name|NTP_INSIST
argument_list|(
operator|(
name|ULONG_PTR
operator|)
name|rio
operator|==
name|key
argument_list|)
expr_stmt|;
comment|/* Offload to worker pool */
if|if
condition|(
operator|!
name|QueueUserWorkItem
argument_list|(
operator|&
name|OnSerialReadWorker
argument_list|,
name|lpo
argument_list|,
name|WT_EXECUTEDEFAULT
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't offload to worker thread, will skip data: %m"
argument_list|)
expr_stmt|;
name|IoCtxReset
argument_list|(
name|lpo
argument_list|)
expr_stmt|;
name|buff
operator|->
name|recv_length
operator|=
literal|0
expr_stmt|;
name|QueueSerialWait
argument_list|(
name|rio
argument_list|,
name|buff
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * Worker pool offload function -- avoid lengthy operations in the IO  * completion thread (affects timing...)  *  * This function does the real work of emulating the UN*X line  * discipline. Since this involves allocation of additional buffers and  * string parsing/copying, it is offloaded to the worker thread pool so  * the IO completion thread can resume faster.  */
end_comment

begin_function
specifier|static
name|DWORD
name|WINAPI
name|OnSerialReadWorker
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|IoCtx_t
modifier|*
name|lpo
decl_stmt|;
name|recvbuf_t
modifier|*
name|buff
decl_stmt|,
modifier|*
name|obuf
decl_stmt|;
name|RIO_t
modifier|*
name|rio
decl_stmt|;
name|char
modifier|*
name|sptr
decl_stmt|,
modifier|*
name|send
decl_stmt|,
modifier|*
name|dptr
decl_stmt|;
name|BOOL
name|eol
decl_stmt|;
name|char
name|ch
decl_stmt|;
comment|/* Get context back */
name|lpo
operator|=
operator|(
name|IoCtx_t
operator|*
operator|)
name|ctx
expr_stmt|;
name|buff
operator|=
name|lpo
operator|->
name|recv_buf
expr_stmt|;
name|rio
operator|=
name|lpo
operator|->
name|rio
expr_stmt|;
comment|/* 	 * ignore 0 bytes read due to closure on fd. 	 * Eat the first line of input as it's possibly partial. 	 */
if|if
condition|(
name|lpo
operator|->
name|byteCount
operator|&&
name|rio
operator|->
name|recvcount
operator|++
condition|)
block|{
comment|/* account for additional input */
name|buff
operator|->
name|recv_length
operator|+=
operator|(
name|int
operator|)
name|lpo
operator|->
name|byteCount
expr_stmt|;
comment|/* 		 * Now mimic the Unix line discipline.  		 */
name|sptr
operator|=
operator|(
name|char
operator|*
operator|)
name|buff
operator|->
name|recv_buffer
expr_stmt|;
name|send
operator|=
name|sptr
operator|+
name|buff
operator|->
name|recv_length
expr_stmt|;
name|obuf
operator|=
name|NULL
expr_stmt|;
name|dptr
operator|=
name|NULL
expr_stmt|;
comment|/* hack #1: eat away leading CR/LF if here is any */
while|while
condition|(
name|sptr
operator|!=
name|send
condition|)
block|{
name|ch
operator|=
operator|*
name|sptr
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|'\r'
condition|)
break|break;
name|sptr
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|sptr
operator|!=
name|send
condition|)
block|{
comment|/* get new buffer to store line */
name|obuf
operator|=
name|get_free_recv_buffer_alloc
argument_list|()
expr_stmt|;
name|obuf
operator|->
name|fd
operator|=
name|rio
operator|->
name|fd
expr_stmt|;
name|obuf
operator|->
name|receiver
operator|=
operator|&
name|process_refclock_packet
expr_stmt|;
name|obuf
operator|->
name|dstadr
operator|=
name|NULL
expr_stmt|;
name|obuf
operator|->
name|recv_peer
operator|=
name|rio
operator|->
name|srcclock
expr_stmt|;
name|set_serial_recv_time
argument_list|(
name|obuf
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
comment|/* 			 * Copy data to new buffer, convert CR to LF on 			 * the fly.  Stop after either. 			 */
name|dptr
operator|=
operator|(
name|char
operator|*
operator|)
name|obuf
operator|->
name|recv_buffer
expr_stmt|;
name|eol
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|sptr
operator|!=
name|send
operator|&&
operator|!
name|eol
condition|)
block|{
name|ch
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
if|if
condition|(
literal|'\r'
operator|==
name|ch
condition|)
block|{
name|ch
operator|=
literal|'\n'
expr_stmt|;
block|}
operator|*
name|dptr
operator|++
operator|=
name|ch
expr_stmt|;
name|eol
operator|=
operator|(
literal|'\n'
operator|==
name|ch
operator|)
expr_stmt|;
block|}
name|obuf
operator|->
name|recv_length
operator|=
call|(
name|int
call|)
argument_list|(
name|dptr
operator|-
operator|(
name|char
operator|*
operator|)
name|obuf
operator|->
name|recv_buffer
argument_list|)
expr_stmt|;
comment|/* 			 * If NL found, push this buffer and prepare to 			 * get a new one. 			 */
if|if
condition|(
name|eol
condition|)
block|{
name|add_full_recv_buffer
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|SetEvent
argument_list|(
name|WaitableIoEventHandle
argument_list|)
expr_stmt|;
name|obuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 		 * If we still have an output buffer, continue to fill 		 * it again. 		 */
if|if
condition|(
name|obuf
condition|)
block|{
name|obuf
operator|->
name|recv_length
operator|=
call|(
name|int
call|)
argument_list|(
name|dptr
operator|-
operator|(
name|char
operator|*
operator|)
name|obuf
operator|->
name|recv_buffer
argument_list|)
expr_stmt|;
name|freerecvbuf
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|buff
operator|=
name|obuf
expr_stmt|;
block|}
else|else
block|{
comment|/* clear the current buffer, continue */
name|buff
operator|->
name|recv_length
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|buff
operator|->
name|recv_length
operator|=
literal|0
expr_stmt|;
block|}
name|IoCtxReset
argument_list|(
name|lpo
argument_list|)
expr_stmt|;
name|QueueSerialWait
argument_list|(
name|rio
argument_list|,
name|buff
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * Part 3 -- raw data input  *  * Raw data processing is fast enough to do without offloading to the  * worker pool, so this is rather short'n sweet...  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|BOOL
name|QueueRawSerialRead
parameter_list|(
name|RIO_t
modifier|*
name|rio
parameter_list|,
name|recvbuf_t
modifier|*
name|buff
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
name|BOOL
name|rc
decl_stmt|;
name|lpo
operator|->
name|onIoDone
operator|=
name|OnRawSerialReadComplete
expr_stmt|;
name|lpo
operator|->
name|recv_buf
operator|=
name|buff
expr_stmt|;
name|lpo
operator|->
name|flRawMem
operator|=
literal|0
expr_stmt|;
name|lpo
operator|->
name|rio
operator|=
name|rio
expr_stmt|;
name|buff
operator|->
name|fd
operator|=
name|rio
operator|->
name|fd
expr_stmt|;
name|rc
operator|=
name|ReadFile
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|rio
operator|->
name|fd
argument_list|)
argument_list|,
name|buff
operator|->
name|recv_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
operator|->
name|recv_buffer
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|lpo
operator|->
name|ol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
return|return
name|IoResultCheck
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|lpo
argument_list|,
literal|"Can't read raw from Refclock"
argument_list|)
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|OnRawSerialReadComplete
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
name|RIO_t
modifier|*
name|rio
decl_stmt|;
name|recvbuf_t
modifier|*
name|buff
decl_stmt|;
comment|/* check and bail out if operation failed */
if|if
condition|(
operator|!
name|IoResultCheck
argument_list|(
name|lpo
operator|->
name|errCode
argument_list|,
name|lpo
argument_list|,
literal|"Raw read from Refclock failed"
argument_list|)
condition|)
return|return;
comment|/* get& validate context and buffer. */
name|rio
operator|=
name|lpo
operator|->
name|rio
expr_stmt|;
name|buff
operator|=
name|lpo
operator|->
name|recv_buf
expr_stmt|;
name|NTP_INSIST
argument_list|(
operator|(
name|ULONG_PTR
operator|)
name|rio
operator|==
name|key
argument_list|)
expr_stmt|;
comment|/* ignore 0 bytes read. */
if|if
condition|(
name|lpo
operator|->
name|byteCount
operator|>
literal|0
condition|)
block|{
name|buff
operator|->
name|recv_length
operator|=
operator|(
name|int
operator|)
name|lpo
operator|->
name|byteCount
expr_stmt|;
name|buff
operator|->
name|dstadr
operator|=
name|NULL
expr_stmt|;
name|buff
operator|->
name|receiver
operator|=
name|process_refclock_packet
expr_stmt|;
name|buff
operator|->
name|recv_peer
operator|=
name|rio
operator|->
name|srcclock
expr_stmt|;
name|set_serial_recv_time
argument_list|(
name|buff
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
name|add_full_recv_buffer
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|SetEvent
argument_list|(
name|WaitableIoEventHandle
argument_list|)
expr_stmt|;
name|buff
operator|=
name|get_free_recv_buffer_alloc
argument_list|()
expr_stmt|;
block|}
name|buff
operator|->
name|recv_length
operator|=
literal|0
expr_stmt|;
name|QueueSerialWait
argument_list|(
name|rio
argument_list|,
name|buff
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|set_serial_recv_time
parameter_list|(
name|recvbuf_t
modifier|*
name|obuf
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
comment|/* 	 * Time stamp assignment is interesting.  If we 	 * have a DCD stamp, we use it, otherwise we use 	 * the FLAG char event time, and if that is also 	 * not / no longer available we use the arrival 	 * time. 	 */
if|if
condition|(
name|lpo
operator|->
name|flTsDCDS
condition|)
name|obuf
operator|->
name|recv_time
operator|=
name|lpo
operator|->
name|DCDSTime
expr_stmt|;
elseif|else
if|if
condition|(
name|lpo
operator|->
name|flTsFlag
condition|)
name|obuf
operator|->
name|recv_time
operator|=
name|lpo
operator|->
name|FlagTime
expr_stmt|;
else|else
name|obuf
operator|->
name|recv_time
operator|=
name|lpo
operator|->
name|RecvTime
expr_stmt|;
name|lpo
operator|->
name|flTsDCDS
operator|=
name|lpo
operator|->
name|flTsFlag
operator|=
literal|0
expr_stmt|;
comment|/* use only once... */
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * Part 4 -- Overlapped serial output  *  * Again, no need to offload any work.  * -------------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * async_write, clone of write(), used by some reflock drivers  */
end_comment

begin_function
name|int
name|async_write
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|count
parameter_list|)
block|{
name|IoCtx_t
modifier|*
name|lpo
decl_stmt|;
name|BOOL
name|rc
decl_stmt|;
name|lpo
operator|=
name|IoCtxAlloc
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lpo
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
literal|"async_write: out of memory\n"
operator|)
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|lpo
operator|->
name|onIoDone
operator|=
name|OnSerialWriteComplete
expr_stmt|;
name|lpo
operator|->
name|trans_buf
operator|=
name|emalloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|lpo
operator|->
name|flRawMem
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|lpo
operator|->
name|trans_buf
argument_list|,
name|data
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|rc
operator|=
name|WriteFile
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
argument_list|,
name|lpo
operator|->
name|trans_buf
argument_list|,
name|count
argument_list|,
name|NULL
argument_list|,
operator|&
name|lpo
operator|->
name|ol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|&&
operator|!
name|IoResultCheck
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|lpo
argument_list|,
literal|"Can't write to Refclock"
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|OnSerialWriteComplete
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
comment|/* set RIO and force silent cleanup if no error */
name|lpo
operator|->
name|rio
operator|=
operator|(
name|RIO_t
operator|*
operator|)
name|key
expr_stmt|;
if|if
condition|(
name|ERROR_SUCCESS
operator|==
name|lpo
operator|->
name|errCode
condition|)
name|lpo
operator|->
name|errCode
operator|=
name|ERROR_OPERATION_ABORTED
expr_stmt|;
name|IoResultCheck
argument_list|(
name|lpo
operator|->
name|errCode
argument_list|,
name|lpo
argument_list|,
literal|"Write to Refclock failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * Part 5 -- read PPS time stamps  *  * -------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* The dummy read procedure is used for getting the device context  * into the IO completion thread, using the IO completion queue for  * transport. There are other ways to accomplish what we need here,  * but using the IO machine is handy and avoids a lot of trouble.  */
end_comment

begin_function
specifier|static
name|void
name|OnPpsDummyRead
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
name|RIO_t
modifier|*
name|rio
decl_stmt|;
name|rio
operator|=
operator|(
name|RIO_t
operator|*
operator|)
name|key
expr_stmt|;
name|lpo
operator|->
name|devCtx
operator|=
name|DevCtxAttach
argument_list|(
name|rio
operator|->
name|device_context
argument_list|)
expr_stmt|;
name|SetEvent
argument_list|(
name|lpo
operator|->
name|ppswake
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|__declspec
argument_list|(
argument|dllexport
argument_list|)
end_macro

begin_function
name|void
modifier|*
name|__stdcall
name|ntp_pps_attach_device
parameter_list|(
name|HANDLE
name|hndIo
parameter_list|)
block|{
name|IoCtx_t
name|myIoCtx
decl_stmt|;
name|HANDLE
name|myEvt
decl_stmt|;
name|DevCtx_t
modifier|*
name|dev
decl_stmt|;
name|DWORD
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|isserialhandle
argument_list|(
name|hndIo
argument_list|)
condition|)
block|{
name|SetLastError
argument_list|(
name|ERROR_INVALID_HANDLE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ZERO
argument_list|(
name|myIoCtx
argument_list|)
expr_stmt|;
name|dev
operator|=
name|NULL
expr_stmt|;
name|myEvt
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|myEvt
condition|)
goto|goto
name|done
goto|;
name|myIoCtx
operator|.
name|ppswake
operator|=
name|myEvt
expr_stmt|;
name|myIoCtx
operator|.
name|onIoDone
operator|=
name|OnPpsDummyRead
expr_stmt|;
name|rc
operator|=
name|ReadFile
argument_list|(
name|hndIo
argument_list|,
operator|&
name|myIoCtx
operator|.
name|byteCount
argument_list|,
literal|0
argument_list|,
operator|&
name|myIoCtx
operator|.
name|byteCount
argument_list|,
operator|&
name|myIoCtx
operator|.
name|ol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|&&
operator|(
name|GetLastError
argument_list|()
operator|!=
name|ERROR_IO_PENDING
operator|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|WaitForSingleObject
argument_list|(
name|myEvt
argument_list|,
name|INFINITE
argument_list|)
operator|==
name|WAIT_OBJECT_0
condition|)
if|if
condition|(
name|NULL
operator|==
operator|(
name|dev
operator|=
name|myIoCtx
operator|.
name|devCtx
operator|)
condition|)
name|SetLastError
argument_list|(
name|ERROR_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|done
label|:
name|rc
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|CloseHandle
argument_list|(
name|myEvt
argument_list|)
expr_stmt|;
name|SetLastError
argument_list|(
name|rc
argument_list|)
expr_stmt|;
return|return
name|dev
return|;
block|}
end_function

begin_macro
name|__declspec
argument_list|(
argument|dllexport
argument_list|)
end_macro

begin_function
name|void
name|__stdcall
name|ntp_pps_detach_device
parameter_list|(
name|DevCtx_t
modifier|*
name|dev
parameter_list|)
block|{
name|DevCtxDetach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|__declspec
argument_list|(
argument|dllexport
argument_list|)
end_macro

begin_function
name|BOOL
name|__stdcall
name|ntp_pps_read
parameter_list|(
name|DevCtx_t
modifier|*
name|dev
parameter_list|,
name|PPSData_t
modifier|*
name|data
parameter_list|,
name|size_t
name|dlen
parameter_list|)
block|{
name|u_long
name|guard
decl_stmt|,
name|covc
decl_stmt|;
name|int
name|repc
decl_stmt|;
name|PPSDataEx_t
modifier|*
name|ppsbuf
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|SetLastError
argument_list|(
name|ERROR_INVALID_HANDLE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|data
operator|==
name|NULL
operator|||
name|dlen
operator|!=
sizeof|sizeof
argument_list|(
name|PPSData_t
argument_list|)
condition|)
block|{
name|SetLastError
argument_list|(
name|ERROR_INVALID_PARAMETER
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 	** Reading from shared memory in a lock-free fashion can be 	** a bit tricky, since we have to read the components in the 	** opposite direction from the write, and the compiler must 	** not reorder the read sequence. 	** We use interlocked ops and a volatile data source to avoid 	** reordering on compiler and CPU level. The interlocked 	** instruction act as full barriers -- we need only aquire 	** semantics, but we don't have them before VS2010. 	*/
name|repc
operator|=
literal|3
expr_stmt|;
do|do
block|{
name|InterlockedExchange
argument_list|(
operator|(
name|PLONG
operator|)
operator|&
name|covc
argument_list|,
name|dev
operator|->
name|cov_count
argument_list|)
expr_stmt|;
name|ppsbuf
operator|=
name|dev
operator|->
name|pps_buff
operator|+
operator|(
name|covc
operator|&
name|PPS_QUEUE_MSK
operator|)
expr_stmt|;
operator|*
name|data
operator|=
name|ppsbuf
operator|->
name|data
expr_stmt|;
name|InterlockedExchange
argument_list|(
operator|(
name|PLONG
operator|)
operator|&
name|guard
argument_list|,
name|ppsbuf
operator|->
name|cov_count
argument_list|)
expr_stmt|;
name|guard
operator|^=
name|covc
expr_stmt|;
block|}
do|while
condition|(
name|guard
operator|&&
operator|~
name|guard
operator|&&
operator|--
name|repc
condition|)
do|;
if|if
condition|(
name|guard
condition|)
block|{
name|SetLastError
argument_list|(
name|ERROR_INVALID_DATA
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Add a reference clock data structures I/O handles to  * the I/O completion port. Return 1 if any error.  */
end_comment

begin_function
name|int
name|io_completion_port_add_clock_io
parameter_list|(
name|RIO_t
modifier|*
name|rio
parameter_list|)
block|{
name|IoCtx_t
modifier|*
name|lpo
decl_stmt|;
name|DevCtx_t
modifier|*
name|dev
decl_stmt|;
name|recvbuf_t
modifier|*
name|buff
decl_stmt|;
name|HANDLE
name|h
decl_stmt|;
name|h
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|rio
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|CreateIoCompletionPort
argument_list|(
name|h
argument_list|,
name|hIoCompletionPort
argument_list|,
operator|(
name|ULONG_PTR
operator|)
name|rio
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't add COM port to i/o completion port: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|dev
operator|=
name|DevCtxAlloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|dev
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't allocate device context for i/o completion port: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|rio
operator|->
name|device_context
operator|=
name|DevCtxAttach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|lpo
operator|=
name|IoCtxAlloc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|lpo
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't allocate heap for completion port: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|buff
operator|=
name|get_free_recv_buffer_alloc
argument_list|()
expr_stmt|;
name|buff
operator|->
name|recv_length
operator|=
literal|0
expr_stmt|;
name|QueueSerialWait
argument_list|(
name|rio
argument_list|,
name|buff
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|io_completion_port_remove_clock_io
parameter_list|(
name|RIO_t
modifier|*
name|rio
parameter_list|)
block|{
if|if
condition|(
name|rio
condition|)
name|DevCtxDetach
argument_list|(
operator|(
name|DevCtx_t
operator|*
operator|)
name|rio
operator|->
name|device_context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Queue a receiver on a socket. Returns 0 if no buffer can be queued   *  *  Note: As per the winsock documentation, we use WSARecvFrom. Using  *	  ReadFile() is less efficient.  */
end_comment

begin_function
specifier|static
name|BOOL
name|QueueSocketRecv
parameter_list|(
name|SOCKET
name|s
parameter_list|,
name|recvbuf_t
modifier|*
name|buff
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
name|WSABUF
name|wsabuf
decl_stmt|;
name|DWORD
name|Flags
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|lpo
operator|->
name|onIoDone
operator|=
name|OnSocketRecv
expr_stmt|;
name|lpo
operator|->
name|recv_buf
operator|=
name|buff
expr_stmt|;
name|lpo
operator|->
name|flRawMem
operator|=
literal|0
expr_stmt|;
name|lpo
operator|->
name|rio
operator|=
name|NULL
expr_stmt|;
name|Flags
operator|=
literal|0
expr_stmt|;
name|buff
operator|->
name|fd
operator|=
name|s
expr_stmt|;
name|buff
operator|->
name|recv_srcadr_len
operator|=
sizeof|sizeof
argument_list|(
name|buff
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
name|wsabuf
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buff
operator|->
name|recv_buffer
expr_stmt|;
name|wsabuf
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buff
operator|->
name|recv_buffer
argument_list|)
expr_stmt|;
name|rc
operator|=
name|WSARecvFrom
argument_list|(
name|buff
operator|->
name|fd
argument_list|,
operator|&
name|wsabuf
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|Flags
argument_list|,
operator|&
name|buff
operator|->
name|recv_srcadr
operator|.
name|sa
argument_list|,
operator|&
name|buff
operator|->
name|recv_srcadr_len
argument_list|,
operator|&
name|lpo
operator|->
name|ol
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOCKET_ERROR
operator|==
name|rc
condition|)
return|return
name|IoResultCheck
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|lpo
argument_list|,
literal|"Can't read from Socket"
argument_list|)
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|OnSocketRecv
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
name|recvbuf_t
modifier|*
name|buff
decl_stmt|;
name|recvbuf_t
modifier|*
name|newbuff
decl_stmt|;
name|struct
name|interface
modifier|*
name|inter
init|=
operator|(
expr|struct
name|interface
operator|*
operator|)
name|key
decl_stmt|;
name|NTP_REQUIRE
argument_list|(
name|NULL
operator|!=
name|lpo
argument_list|)
expr_stmt|;
name|NTP_REQUIRE
argument_list|(
name|NULL
operator|!=
name|lpo
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
comment|/* check and bail out if operation failed */
if|if
condition|(
operator|!
name|IoResultCheck
argument_list|(
name|lpo
operator|->
name|errCode
argument_list|,
name|lpo
argument_list|,
literal|"Read from Socket failed"
argument_list|)
condition|)
return|return;
comment|/* 	 * Convert the overlapped pointer back to a recvbuf pointer. 	 * Fetch items that are lost when the context is queued again. 	 */
name|buff
operator|=
name|lpo
operator|->
name|recv_buf
expr_stmt|;
name|buff
operator|->
name|recv_time
operator|=
name|lpo
operator|->
name|RecvTime
expr_stmt|;
name|buff
operator|->
name|recv_length
operator|=
operator|(
name|int
operator|)
name|lpo
operator|->
name|byteCount
expr_stmt|;
comment|/* 	 * Get a new recv buffer for the replacement socket receive 	 */
name|newbuff
operator|=
name|get_free_recv_buffer_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|newbuff
condition|)
block|{
name|QueueSocketRecv
argument_list|(
name|inter
operator|->
name|fd
argument_list|,
name|newbuff
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IoCtxFree
argument_list|(
name|lpo
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't add I/O request to socket"
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%sfd %d %s recv packet mode is %d\n"
operator|,
operator|(
name|MODE_BROADCAST
operator|==
name|get_packet_mode
argument_list|(
name|buff
argument_list|)
operator|)
condition|?
literal|" **** Broadcast "
else|:
literal|""
operator|,
operator|(
name|int
operator|)
name|buff
operator|->
name|fd
operator|,
name|stoa
argument_list|(
operator|&
name|buff
operator|->
name|recv_srcadr
argument_list|)
operator|,
name|get_packet_mode
argument_list|(
name|buff
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we keep it add some info to the structure 	 */
if|if
condition|(
name|buff
operator|->
name|recv_length
operator|&&
operator|!
name|inter
operator|->
name|ignore_packets
condition|)
block|{
name|NTP_INSIST
argument_list|(
name|buff
operator|->
name|recv_srcadr_len
operator|<=
sizeof|sizeof
argument_list|(
name|buff
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
name|buff
operator|->
name|receiver
operator|=
operator|&
name|receive
expr_stmt|;
name|buff
operator|->
name|dstadr
operator|=
name|inter
expr_stmt|;
name|packets_received
operator|++
expr_stmt|;
name|handler_pkts
operator|++
expr_stmt|;
name|inter
operator|->
name|received
operator|++
expr_stmt|;
name|add_full_recv_buffer
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"Received %d bytes fd %d in buffer %p from %s\n"
operator|,
name|buff
operator|->
name|recv_length
operator|,
operator|(
name|int
operator|)
name|buff
operator|->
name|fd
operator|,
name|buff
operator|,
name|stoa
argument_list|(
operator|&
name|buff
operator|->
name|recv_srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Now signal we have something to process 		 */
name|SetEvent
argument_list|(
name|WaitableIoEventHandle
argument_list|)
expr_stmt|;
block|}
else|else
name|freerecvbuf
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a socket handle to the I/O completion port, and send   * NTP_RECVS_PER_SOCKET recv requests to the kernel.  */
end_comment

begin_function
name|int
name|io_completion_port_add_socket
parameter_list|(
name|SOCKET
name|fd
parameter_list|,
name|struct
name|interface
modifier|*
name|inter
parameter_list|)
block|{
name|IoCtx_t
modifier|*
name|lpo
decl_stmt|;
name|recvbuf_t
modifier|*
name|buff
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
name|CreateIoCompletionPort
argument_list|(
operator|(
name|HANDLE
operator|)
name|fd
argument_list|,
name|hIoCompletionPort
argument_list|,
operator|(
name|ULONG_PTR
operator|)
name|inter
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't add socket to i/o completion port: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* 	 * Windows 2000 bluescreens with bugcheck 0x76 	 * PROCESS_HAS_LOCKED_PAGES at ntpd process 	 * termination when using more than one pending 	 * receive per socket.  A runtime version test 	 * would allow using more on newer versions 	 * of Windows. 	 */
define|#
directive|define
name|WINDOWS_RECVS_PER_SOCKET
value|1
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|WINDOWS_RECVS_PER_SOCKET
condition|;
name|n
operator|++
control|)
block|{
name|buff
operator|=
name|get_free_recv_buffer_alloc
argument_list|()
expr_stmt|;
name|lpo
operator|=
name|IoCtxAlloc
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lpo
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't allocate IO completion context: %m"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|QueueSocketRecv
argument_list|(
name|fd
argument_list|,
name|buff
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * io_completion_port_sendto() -- sendto() replacement for Windows  *  * Returns len after successful send.  * Returns -1 for any error, with the error code available via  *	msyslog() %m, or GetLastError().  */
end_comment

begin_function
name|int
name|io_completion_port_sendto
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|pkt
parameter_list|,
name|size_t
name|len
parameter_list|,
name|sockaddr_u
modifier|*
name|dest
parameter_list|)
block|{
specifier|static
name|u_long
name|time_next_ifscan_after_error
decl_stmt|;
name|WSABUF
name|wsabuf
decl_stmt|;
name|DWORD
name|octets_sent
decl_stmt|;
name|DWORD
name|Result
decl_stmt|;
name|int
name|errval
decl_stmt|;
name|int
name|AddrLen
decl_stmt|;
name|wsabuf
operator|.
name|buf
operator|=
operator|(
name|void
operator|*
operator|)
name|pkt
expr_stmt|;
name|wsabuf
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|AddrLen
operator|=
name|SOCKLEN
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|octets_sent
operator|=
literal|0
expr_stmt|;
name|Result
operator|=
name|WSASendTo
argument_list|(
name|fd
argument_list|,
operator|&
name|wsabuf
argument_list|,
literal|1
argument_list|,
operator|&
name|octets_sent
argument_list|,
literal|0
argument_list|,
operator|&
name|dest
operator|->
name|sa
argument_list|,
name|AddrLen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|errval
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|SOCKET_ERROR
operator|==
name|Result
condition|)
block|{
if|if
condition|(
name|ERROR_UNEXP_NET_ERR
operator|==
name|errval
condition|)
block|{
comment|/* 			 * We get this error when trying to send if the 			 * network interface is gone or has lost link. 			 * Rescan interfaces to catch on sooner, but no 			 * more often than once per minute.  Once ntpd 			 * is able to detect changes without polling 			 * this should be unneccessary 			 */
if|if
condition|(
name|time_next_ifscan_after_error
operator|<
name|current_time
condition|)
block|{
name|time_next_ifscan_after_error
operator|=
name|current_time
operator|+
literal|60
expr_stmt|;
name|timer_interfacetimeout
argument_list|(
name|current_time
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"sendto unexpected network error, interface may be down\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WSASendTo(%s) error %m"
argument_list|,
name|stoa
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SetLastError
argument_list|(
name|errval
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|len
operator|!=
operator|(
name|int
operator|)
name|octets_sent
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WSASendTo(%s) sent %u of %d octets"
argument_list|,
name|stoa
argument_list|(
name|dest
argument_list|)
argument_list|,
name|octets_sent
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SetLastError
argument_list|(
name|ERROR_BAD_LENGTH
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"sendto %s %d octets\n"
operator|,
name|stoa
argument_list|(
name|dest
argument_list|)
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * GetReceivedBuffers  * Note that this is in effect the main loop for processing requests  * both send and receive. This should be reimplemented  */
end_comment

begin_function
name|int
name|GetReceivedBuffers
parameter_list|()
block|{
name|DWORD
name|index
decl_stmt|;
name|HANDLE
name|ready
decl_stmt|;
name|int
name|have_packet
decl_stmt|;
name|have_packet
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|have_packet
condition|)
block|{
name|index
operator|=
name|WaitForMultipleObjects
argument_list|(
name|ActiveWaitHandles
argument_list|,
name|WaitHandles
argument_list|,
name|FALSE
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|WAIT_OBJECT_0
operator|+
literal|0
case|:
comment|/* Io event */
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"IoEvent occurred\n"
operator|)
argument_list|)
expr_stmt|;
name|have_packet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|WAIT_OBJECT_0
operator|+
literal|1
case|:
comment|/* exit request */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|WAIT_OBJECT_0
operator|+
literal|2
case|:
comment|/* timer */
name|timer
argument_list|()
expr_stmt|;
break|break;
case|case
name|WAIT_IO_COMPLETION
case|:
comment|/* loop */
break|break;
case|case
name|WAIT_TIMEOUT
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WaitForMultipleObjects INFINITE timed out."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|WAIT_FAILED
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WaitForMultipleObjects Failed: Error: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DEBUG_INSIST
argument_list|(
operator|(
name|index
operator|-
name|WAIT_OBJECT_0
operator|)
operator|<
name|ActiveWaitHandles
argument_list|)
expr_stmt|;
name|ready
operator|=
name|WaitHandles
index|[
name|index
operator|-
name|WAIT_OBJECT_0
index|]
expr_stmt|;
name|handle_blocking_resp_sem
argument_list|(
name|ready
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
return|return
operator|(
name|full_recvbuffs
argument_list|()
operator|)
return|;
comment|/* get received buffers */
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|NonEmptyCompilationUnit
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

