begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ----------------------------------------------------------------------- This is the IO completion port handling for async/overlapped IO on Windows>= Win2000.  Some notes on the implementation:  + Only one thread is used to serve the IO completion port, for several   reasons:    * First, there seems to be (have been?) trouble that locked up NTPD     when more than one thread was used for IOCPL.    * Second, for the sake of the time stamp interpolation the threads     must run on the same CPU as the time interpolation thread. This     makes using more than one thread useless, as they would compete for     the same core and create contention.  + Some IO operations need a possibly lengthy post-processing. Emulating   the UN*X line discipline is currently the only but prominent example.   To avoid the processing in the time-critical IOCPL thread, longer   processing is offloaded the worker thread pool.  + A fact that seems not as well-known as it should be is that all   resources passed to an overlapped IO operation must be considered   owned by the OS until the result has been fetched/dequeued. This   includes all overlapped structures and buffers involved, so cleaning   up on shutdown must be carefully constructed. (This includes closing   all the IO handles and waiting for the results to be dequeued.   'CancleIo()' cannot be used since it's broken beyond repair.)    If this is not possible, then all resources should be dropped into   oblivion -- otherwise "bad things (tm)" are bound to happen.    Using a private heap that is silently dropped but not deleted is a   good way to avoid cluttering memory stats with IO context related   objects. Leak tracing becomes more interesting, though.   The current implementation is based on the work of Danny Mayer who improved the original implementation and Dave Hart who improved on the serial I/O routines. The true roots of this file seem to be shrouded by the mist of time...   This version still provides the 'user space PPS' emulation feature.  Juergen Perlinger (perlinger@ntp.org) Feb 2012  ----------------------------------------------------------------------- */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_IO_COMPLETION_PORT
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_request.h"
end_include

begin_include
include|#
directive|include
file|"ntp_iocompletionport.h"
end_include

begin_include
include|#
directive|include
file|"ntp_iocplmem.h"
end_include

begin_include
include|#
directive|include
file|"ntp_iocpltypes.h"
end_include

begin_define
define|#
directive|define
name|CONTAINEROF
parameter_list|(
name|p
parameter_list|,
name|type
parameter_list|,
name|member
parameter_list|)
define|\
value|((type *)((char *)(p) - offsetof(type, member)))
end_define

begin_comment
comment|/*  * local function definitions  */
end_comment

begin_function_decl
specifier|static
name|void
name|ntpd_addremove_semaphore
parameter_list|(
name|HANDLE
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_serial_recv_time
parameter_list|(
name|recvbuf_t
modifier|*
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Initiate/Request async IO operations */
end_comment

begin_function_decl
specifier|static
name|BOOL
name|__fastcall
name|QueueSerialWait
parameter_list|(
name|IoCtx_t
modifier|*
parameter_list|,
name|recvbuf_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOL
name|__fastcall
name|QueueSerialRead
parameter_list|(
name|IoCtx_t
modifier|*
parameter_list|,
name|recvbuf_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOL
name|__fastcall
name|QueueRawSerialRead
parameter_list|(
name|IoCtx_t
modifier|*
parameter_list|,
name|recvbuf_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOL
name|__fastcall
name|QueueSocketRecv
parameter_list|(
name|IoCtx_t
modifier|*
parameter_list|,
name|recvbuf_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* High-level IO callback functions */
end_comment

begin_function_decl
specifier|static
name|void
name|OnSocketRecv
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|OnSocketSend
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|OnSerialWaitComplete
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|OnSerialReadComplete
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|OnRawSerialReadComplete
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|OnSerialWriteComplete
parameter_list|(
name|ULONG_PTR
parameter_list|,
name|IoCtx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* worker pool offload functions */
end_comment

begin_function_decl
specifier|static
name|DWORD
name|WINAPI
name|OnSerialReadWorker
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* keep a list to traverse to free memory on debug builds */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|free_io_completion_port_mem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|HANDLE
name|WaitableExitEventHandle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HANDLE
name|WaitableIoEventHandle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HANDLE
name|hndIOCPLPort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HANDLE
name|hMainThread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DWORD
name|ActiveWaitHandles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HANDLE
name|WaitHandles
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * -------------------------------------------------------------------  * Windows 2000 bluescreens with bugcheck 0x76 PROCESS_HAS_LOCKED_PAGES  * at ntpd process termination when using more than one pending  * receive per socket.  A runtime version test during startup will  * allow using more on newer versions of Windows.  *  * perlinger@ntp.org: Considering the quirks fixed in the overlapped  * IO handling in recent years, it could even be that this is no longer  * an issue. Testing this might be tricky -- who runs a Win2k system  * in the year 2016?  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|s_SockRecvSched
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* possibly adjusted later */
end_comment

begin_comment
comment|/*  * -------------------------------------------------------------------  * The IO completion thread and support functions  *  * There is only one completion thread, because it is locked to the same  * core as the time interpolation. Having more than one causes core  * contention and is not useful.  * -------------------------------------------------------------------  */
end_comment

begin_decl_stmt
specifier|static
name|HANDLE
name|hIoCompletionThread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UINT
name|tidCompletionThread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * The IO completion worker thread  *  * Note that this thread does not enter an alertable wait state and that  * the only waiting point is the IO completion port. If stopping this  * thread with a special queued result packet does not work,  * 'TerminateThread()' is the only remaining weapon in the arsenal. A  * dangerous weapon -- it's like SIGKILL.  */
end_comment

begin_function
specifier|static
name|unsigned
name|WINAPI
name|iocompletionthread
parameter_list|(
name|void
modifier|*
name|NotUsed
parameter_list|)
block|{
name|DWORD
name|err
decl_stmt|;
name|DWORD
name|octets
decl_stmt|;
name|ULONG_PTR
name|key
decl_stmt|;
name|OVERLAPPED
modifier|*
name|pol
decl_stmt|;
name|IoCtx_t
modifier|*
name|lpo
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|NotUsed
argument_list|)
expr_stmt|;
comment|/* Socket and refclock receive call gettimeofday() so the I/O 	 * thread needs to be on the same processor as the main and 	 * timing threads to ensure consistent QueryPerformanceCounter() 	 * results. 	 * 	 * This gets seriously into the way of efficient thread pooling 	 * on multi-core systems. 	 */
name|lock_thread_to_processor
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Set the thread priority high enough so I/O will pre-empt 	 * normal recv packet processing, but not higher than the timer 	 * sync thread. 	 */
if|if
condition|(
operator|!
name|SetThreadPriority
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|,
name|THREAD_PRIORITY_ABOVE_NORMAL
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't set thread priority: %m"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|GetQueuedCompletionStatus
argument_list|(
name|hndIOCPLPort
argument_list|,
operator|&
name|octets
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|pol
argument_list|,
name|INFINITE
argument_list|)
condition|)
block|{
name|err
operator|=
name|ERROR_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pol
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"Overlapped IO Thread Exiting\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* fail */
block|}
name|lpo
operator|=
name|CONTAINEROF
argument_list|(
name|pol
argument_list|,
name|IoCtx_t
argument_list|,
name|ol
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
argument_list|)
expr_stmt|;
name|lpo
operator|->
name|byteCount
operator|=
name|octets
expr_stmt|;
name|lpo
operator|->
name|errCode
operator|=
name|err
expr_stmt|;
name|handler_calls
operator|++
expr_stmt|;
call|(
modifier|*
name|lpo
operator|->
name|onIoDone
call|)
argument_list|(
name|key
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Create/initialise the I/O creation port  */
end_comment

begin_function
name|void
name|init_io_completion_port
parameter_list|(
name|void
parameter_list|)
block|{
name|OSVERSIONINFO
name|vi
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|atexit
argument_list|(
operator|&
name|free_io_completion_port_mem
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|vi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vi
argument_list|)
argument_list|)
expr_stmt|;
name|vi
operator|.
name|dwOSVersionInfoSize
operator|=
sizeof|sizeof
argument_list|(
name|vi
argument_list|)
expr_stmt|;
comment|/* For windows 7 and above, schedule more than one receive */
if|if
condition|(
name|GetVersionEx
argument_list|(
operator|&
name|vi
argument_list|)
operator|&&
name|vi
operator|.
name|dwMajorVersion
operator|>=
literal|6
condition|)
name|s_SockRecvSched
operator|=
literal|4
expr_stmt|;
comment|/* Create the context pool first. */
name|IOCPLPoolInit
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Create the event used to signal an IO event */
name|WaitableIoEventHandle
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|WaitableIoEventHandle
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't create I/O event handle: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Create the event used to signal an exit event */
name|WaitableExitEventHandle
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|WaitableExitEventHandle
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't create exit event handle: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Create the IO completion port */
name|hndIOCPLPort
operator|=
name|CreateIoCompletionPort
argument_list|(
name|INVALID_HANDLE_VALUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hndIOCPLPort
operator|==
name|NULL
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't create I/O completion port: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the Wait Handles table */
name|WaitHandles
index|[
literal|0
index|]
operator|=
name|WaitableIoEventHandle
expr_stmt|;
name|WaitHandles
index|[
literal|1
index|]
operator|=
name|WaitableExitEventHandle
expr_stmt|;
comment|/* exit request */
name|WaitHandles
index|[
literal|2
index|]
operator|=
name|WaitableTimerHandle
expr_stmt|;
name|ActiveWaitHandles
operator|=
literal|3
expr_stmt|;
comment|/* Supply ntp_worker.c with function to add or remove a 	 * semaphore to the ntpd I/O loop which is signalled by a worker 	 * when a response is ready.  The callback is invoked in the 	 * parent. 	 */
name|addremove_io_semaphore
operator|=
operator|&
name|ntpd_addremove_semaphore
expr_stmt|;
comment|/* Create a true handle for the main thread (APC processing) */
name|DuplicateHandle
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|GetCurrentThread
argument_list|()
argument_list|,
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|hMainThread
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
expr_stmt|;
comment|/* Have one thread servicing I/O. See rationale in front matter. */
name|hIoCompletionThread
operator|=
operator|(
name|HANDLE
operator|)
name|_beginthreadex
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|iocompletionthread
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|tidCompletionThread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * completion port teardown  */
end_comment

begin_function
name|void
name|uninit_io_completion_port
parameter_list|(
name|void
parameter_list|)
block|{
name|DWORD
name|rc
decl_stmt|;
comment|/* do noting if completion port already gone. */
if|if
condition|(
name|hndIOCPLPort
operator|==
name|NULL
condition|)
return|return;
comment|/* Service thread seems running. Terminate him with grace 	 * first and force later... 	 */
if|if
condition|(
name|tidCompletionThread
operator|!=
name|GetCurrentThreadId
argument_list|()
condition|)
block|{
name|PostQueuedCompletionStatus
argument_list|(
name|hndIOCPLPort
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|WaitForSingleObject
argument_list|(
name|hIoCompletionThread
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|WAIT_TIMEOUT
condition|)
block|{
comment|/* Thread lost. Kill off with TerminateThread. */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"IO completion thread refuses to terminate"
argument_list|)
expr_stmt|;
name|TerminateThread
argument_list|(
name|hIoCompletionThread
argument_list|,
operator|~
literal|0UL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* close the additional main thread handle */
if|if
condition|(
name|hMainThread
condition|)
block|{
name|CloseHandle
argument_list|(
name|hMainThread
argument_list|)
expr_stmt|;
name|hMainThread
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* stop using the memory pool */
name|IOCPLPoolDone
argument_list|()
expr_stmt|;
comment|/* now reap all handles... */
name|CloseHandle
argument_list|(
name|hIoCompletionThread
argument_list|)
expr_stmt|;
name|hIoCompletionThread
operator|=
name|NULL
expr_stmt|;
name|CloseHandle
argument_list|(
name|hndIOCPLPort
argument_list|)
expr_stmt|;
name|hndIOCPLPort
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * external worker thread support (wait handle stuff)  *  * !Attention!  *  *  - This function must only be called from the main thread. Changing  *    a set of wait handles while someone is waiting on it creates  *    undefined behaviour. Also there's no provision for mutual  *    exclusion when accessing global values.   *  *  - It's not possible to register a handle that is already in the table.  */
end_comment

begin_function
specifier|static
name|void
name|ntpd_addremove_semaphore
parameter_list|(
name|HANDLE
name|sem
parameter_list|,
name|int
name|remove
parameter_list|)
block|{
name|DWORD
name|hi
decl_stmt|;
comment|/* search for a matching entry first. */
for|for
control|(
name|hi
operator|=
literal|3
init|;
name|hi
operator|<
name|ActiveWaitHandles
condition|;
name|hi
operator|++
control|)
if|if
condition|(
name|sem
operator|==
name|WaitHandles
index|[
name|hi
index|]
condition|)
break|break;
if|if
condition|(
name|remove
condition|)
block|{
comment|/* If found, eventually swap with last entry to keep 		 * the table dense. 		 */
if|if
condition|(
name|hi
operator|<
name|ActiveWaitHandles
condition|)
block|{
name|ActiveWaitHandles
operator|--
expr_stmt|;
if|if
condition|(
name|hi
operator|<
name|ActiveWaitHandles
condition|)
name|WaitHandles
index|[
name|hi
index|]
operator|=
name|WaitHandles
index|[
name|ActiveWaitHandles
index|]
expr_stmt|;
name|WaitHandles
index|[
name|ActiveWaitHandles
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Make sure the entry is not found and there is enough 		 * room, then append to the table array. 		 */
if|if
condition|(
name|hi
operator|>=
name|ActiveWaitHandles
condition|)
block|{
name|INSIST
argument_list|(
name|ActiveWaitHandles
operator|<
name|COUNTOF
argument_list|(
name|WaitHandles
argument_list|)
argument_list|)
expr_stmt|;
name|WaitHandles
index|[
name|ActiveWaitHandles
index|]
operator|=
name|sem
expr_stmt|;
name|ActiveWaitHandles
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|free_io_completion_port_mem
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* At the moment, do absolutely nothing. Returning memory here 	 * requires NO PENDING OVERLAPPED OPERATIONS AT ALL at this 	 * point in time, and as long we cannot be reasonable sure about 	 * that the simple advice is: 	 * 	 * HANDS OFF! 	 */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * -------------------------------------------------------------------  * APC callback for scheduling interface scans.  *  * We get an error when trying to send if the network interface is  * gone or has lost link. Rescan interfaces to catch on sooner, but no  * more often than once per minute.  Once ntpd is able to detect  * changes without polling this should be unnecessary.  */
end_comment

begin_function
specifier|static
name|void
name|WINAPI
name|apcOnUnexpectedNetworkError
parameter_list|(
name|ULONG_PTR
name|arg
parameter_list|)
block|{
specifier|static
name|u_long
name|time_next_ifscan_after_error
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_next_ifscan_after_error
operator|<
name|current_time
condition|)
block|{
name|time_next_ifscan_after_error
operator|=
name|current_time
operator|+
literal|60
expr_stmt|;
name|timer_interfacetimeout
argument_list|(
name|current_time
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"UnexpectedNetworkError: interface may be down\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  *  * Prelude to madness -- common error checking code  *  * -------------------------------------------------------------------  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|NTstrerror
parameter_list|(
name|int
name|err
parameter_list|,
name|BOOL
modifier|*
name|bfreebuf
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|LogIoError
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|HANDLE
name|hnd
parameter_list|,
name|DWORD
name|err
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|rmsg
init|=
literal|"LogIoError (unknown source)"
decl_stmt|;
comment|/* -*- format& print the error message -*- 	 * We have to resort to the low level error formatting functions 	 * here, since the error code can come from an overlapped result. 	 * Relying the value to be the same as the 'GetLastError()' 	 * result at this point of execution is shaky at best, and using 	 * 'SetLastError()' to force it seems too nasty. 	 */
name|BOOL
name|dynbuf
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|msgbuf
init|=
name|NTstrerror
argument_list|(
name|err
argument_list|,
operator|&
name|dynbuf
argument_list|)
decl_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: hnd=%p, err=%u, '%s'"
argument_list|,
operator|(
name|msg
condition|?
name|msg
else|:
name|rmsg
operator|)
argument_list|,
name|hnd
argument_list|,
name|err
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynbuf
condition|)
name|LocalFree
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * synchronous IO request result check (network& serial)  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|BOOL
name|IoResultCheck
parameter_list|(
name|DWORD
name|err
parameter_list|,
name|IoCtx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
comment|/* The first ones are no real errors. */
case|case
name|ERROR_SUCCESS
case|:
comment|/* all is good */
case|case
name|ERROR_IO_PENDING
case|:
comment|/* callback pending */
break|break;
comment|/* this defers the error processing to the main thread 		 * and continues silently. 		 */
case|case
name|ERROR_UNEXP_NET_ERR
case|:
if|if
condition|(
name|hMainThread
condition|)
block|{
name|QueueUserAPC
argument_list|(
name|apcOnUnexpectedNetworkError
argument_list|,
name|hMainThread
argument_list|,
name|ctx
operator|->
name|io
operator|.
name|sfd
argument_list|)
expr_stmt|;
block|}
name|IoCtxRelease
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
default|default:
name|LogIoError
argument_list|(
name|msg
argument_list|,
name|ctx
operator|->
name|io
operator|.
name|hnd
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* the next ones go silently -- only clean-up is done */
case|case
name|ERROR_INVALID_PARAMETER
case|:
comment|/* handle already closed (clock)*/
case|case
name|WSAENOTSOCK
case|:
comment|/* handle already closed (socket)*/
name|IoCtxRelease
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * IO callback context check -- serial (non-network) data streams  *  * Attention: deletes the IO context when the clock is dead!  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|RIO_t
modifier|*
name|getRioFromIoCtx
parameter_list|(
name|IoCtx_t
modifier|*
name|ctx
parameter_list|,
name|ULONG_PTR
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
comment|/* Make sure the key matches the context info in the shared 	 * lock, the check for errors. If the error indicates the 	 * operation was cancelled, let the operation fail silently. 	 */
name|RIO_t
modifier|*
name|rio
init|=
name|NULL
decl_stmt|;
name|SharedLock_t
modifier|*
name|slock
init|=
name|slAttachShared
argument_list|(
name|ctx
operator|->
name|slock
argument_list|)
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|slock
condition|)
block|{
name|rio
operator|=
name|slock
operator|->
name|rsrc
operator|.
name|rio
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|slock
operator|->
name|rsrc
operator|.
name|key
condition|)
name|rio
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|->
name|io
operator|.
name|hnd
operator|!=
name|slock
operator|->
name|handles
index|[
literal|0
index|]
condition|)
name|rio
operator|=
name|NULL
expr_stmt|;
name|slDetachShared
argument_list|(
name|slock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rio
operator|!=
name|NULL
condition|)
switch|switch
condition|(
name|ctx
operator|->
name|errCode
condition|)
block|{
comment|/* When we got cancelled, don't spill messages */
case|case
name|ERROR_INVALID_PARAMETER
case|:
comment|/* handle already closed (clock) */
case|case
name|ERROR_OPERATION_ABORTED
case|:
comment|/* handle closed while wait      */
case|case
name|WSAENOTSOCK
case|:
comment|/* handle already closed (sock?) */
name|ctx
operator|->
name|errCode
operator|=
name|ERROR_SUCCESS
expr_stmt|;
name|rio
operator|=
name|NULL
expr_stmt|;
case|case
name|ERROR_SUCCESS
case|:
comment|/* all is good */
break|break;
default|default:
comment|/* log error, but return -- caller has to handle this! */
name|LogIoError
argument_list|(
name|msg
argument_list|,
name|ctx
operator|->
name|io
operator|.
name|hnd
argument_list|,
name|ctx
operator|->
name|errCode
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rio
operator|==
name|NULL
condition|)
name|IoCtxRelease
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|rio
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------  * IO callback context check -- network sockets  *  * Attention: deletes the IO context when the endpoint is dead!  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|endpt
modifier|*
name|getEndptFromIoCtx
parameter_list|(
name|IoCtx_t
modifier|*
name|ctx
parameter_list|,
name|ULONG_PTR
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
comment|/* Make sure the key matches the context info in the shared 	 * lock, the check for errors. If the error indicates the 	 * operation was cancelled, let the operation fail silently. 	 * 	 * !Note! Since we use the lowest bit of the key to distinguish 	 * between regular and broadcast socket, we must make sure the 	 * LSB is not used in the reverse-link check. Hence we shift 	 * it out in both the input key and the registered source. 	 */
name|endpt
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
name|SharedLock_t
modifier|*
name|slock
init|=
name|slAttachShared
argument_list|(
name|ctx
operator|->
name|slock
argument_list|)
decl_stmt|;
if|if
condition|(
name|slock
operator|!=
name|NULL
condition|)
block|{
name|ep
operator|=
name|slock
operator|->
name|rsrc
operator|.
name|ept
expr_stmt|;
if|if
condition|(
operator|(
name|key
operator|>>
literal|1
operator|)
operator|!=
operator|(
name|slock
operator|->
name|rsrc
operator|.
name|key
operator|>>
literal|1
operator|)
condition|)
name|ep
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|->
name|io
operator|.
name|hnd
operator|!=
name|slock
operator|->
name|handles
index|[
name|key
operator|&
literal|1
index|]
condition|)
name|ep
operator|=
name|NULL
expr_stmt|;
name|slDetachShared
argument_list|(
name|slock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
switch|switch
condition|(
name|ctx
operator|->
name|errCode
condition|)
block|{
case|case
name|ERROR_UNEXP_NET_ERR
case|:
if|if
condition|(
name|hMainThread
condition|)
name|QueueUserAPC
argument_list|(
name|apcOnUnexpectedNetworkError
argument_list|,
name|hMainThread
argument_list|,
name|ctx
operator|->
name|io
operator|.
name|sfd
argument_list|)
expr_stmt|;
case|case
name|ERROR_INVALID_PARAMETER
case|:
comment|/* handle already closed (clock?)*/
case|case
name|ERROR_OPERATION_ABORTED
case|:
comment|/* handle closed while wait      */
case|case
name|WSAENOTSOCK
case|:
comment|/* handle already closed (sock)  */
name|ctx
operator|->
name|errCode
operator|=
name|ERROR_SUCCESS
expr_stmt|;
name|ep
operator|=
name|NULL
expr_stmt|;
case|case
name|ERROR_SUCCESS
case|:
comment|/* all is good */
break|break;
default|default:
comment|/* log error, but return -- caller has to handle this! */
name|LogIoError
argument_list|(
name|msg
argument_list|,
name|ctx
operator|->
name|io
operator|.
name|hnd
argument_list|,
name|ctx
operator|->
name|errCode
argument_list|)
expr_stmt|;
name|ep
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|NULL
operator|==
name|ep
condition|)
name|IoCtxRelease
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|ep
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * Part 1 -- COMM event handling  *  * This is the initial step for serial line input: wait for COM event.  * We always check for DCD changes (for user-mode PPS time stamps) and  * either a flag char (line feed, for line mode emulation) or any  * input character (raw mode). In the callback we decide if we just  * have to go on with waiting, or if there is data we must read.  * Depending on the mode, we either queue a raw read or a 'regular'  * read request.  *  * !Note! Currently on single IO context circles through the WAIT,  * READ and PROCESS stages. For better performance, it might make  * sense to have on cycle for the wait, spinning off new read requests  * when there is data. There are actually two problems that must be  * solved:  *  - We would need a queue on post-processing.  *  - We have to take care of the order of read results. While the  *    IOCPL queue guarantees delivery in the order of enque, the  *    order of enque is not guaranteed once multiple reads are in  *    flight.  *  * So, for the time being, we have one request cycling...  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|BOOL
name|__fastcall
name|QueueSerialWait
parameter_list|(
name|IoCtx_t
modifier|*
name|lpo
parameter_list|,
name|recvbuf_t
modifier|*
name|buff
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"QueueSerialWait: cannot wait for COM event"
decl_stmt|;
name|BOOL
name|rc
decl_stmt|;
name|memset
argument_list|(
operator|&
name|lpo
operator|->
name|aux
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lpo
operator|->
name|aux
argument_list|)
argument_list|)
expr_stmt|;
name|lpo
operator|->
name|onIoDone
operator|=
name|OnSerialWaitComplete
expr_stmt|;
name|lpo
operator|->
name|recv_buf
operator|=
name|buff
expr_stmt|;
name|lpo
operator|->
name|flRawMem
operator|=
literal|0
expr_stmt|;
name|buff
operator|->
name|fd
operator|=
name|lpo
operator|->
name|slock
operator|->
name|riofd
expr_stmt|;
comment|/* keep receive position for continuation of partial lines! */
name|rc
operator|=
name|WaitCommEvent
argument_list|(
name|lpo
operator|->
name|io
operator|.
name|hnd
argument_list|,
operator|&
name|lpo
operator|->
name|aux
operator|.
name|com_events
argument_list|,
operator|&
name|lpo
operator|->
name|ol
argument_list|)
expr_stmt|;
return|return
name|rc
operator|||
name|IoResultCheck
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|lpo
argument_list|,
name|msg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
end_comment

begin_function
specifier|static
name|void
name|OnSerialWaitComplete
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"OnSerialWaitComplete: wait for COM event failed"
decl_stmt|;
name|DevCtx_t
modifier|*
name|dev
decl_stmt|;
name|PPSDataEx_t
modifier|*
name|ppsbuf
decl_stmt|;
name|DWORD
name|modem_status
decl_stmt|;
name|u_long
name|covc
decl_stmt|;
comment|/* Make sure this RIO is not closed. */
if|if
condition|(
name|NULL
operator|==
name|getRioFromIoCtx
argument_list|(
name|lpo
argument_list|,
name|key
argument_list|,
name|msg
argument_list|)
condition|)
return|return;
comment|/* start next IO and leave if we hit an error */
if|if
condition|(
name|lpo
operator|->
name|errCode
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|IoCtxStartLocked
argument_list|(
name|lpo
argument_list|,
name|QueueSerialWait
argument_list|,
name|lpo
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|~
operator|(
name|EV_RXFLAG
operator||
name|EV_RLSD
operator||
name|EV_RXCHAR
operator|)
operator|&
name|lpo
operator|->
name|aux
operator|.
name|com_events
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WaitCommEvent returned unexpected mask %x"
argument_list|,
name|lpo
operator|->
name|aux
operator|.
name|com_events
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Take note of changes on DCD; 'user mode PPS hack'. 	 * perlinger@ntp.org suggested a way of solving several problems 	 * with this code that makes a lot of sense: move to a putative 	 * dcdpps-ppsapi-provider.dll. 	 * 	 * perlinger@ntp.org: It came out as loopback-ppsapi-provider 	 * (because it loops back into NTPD), but I had to maintain the 	 * old hack for backward compatibility. 	 */
if|if
condition|(
name|EV_RLSD
operator|&
name|lpo
operator|->
name|aux
operator|.
name|com_events
condition|)
block|{
name|modem_status
operator|=
literal|0
expr_stmt|;
name|GetCommModemStatus
argument_list|(
name|lpo
operator|->
name|io
operator|.
name|hnd
argument_list|,
operator|&
name|modem_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|dev
operator|=
name|lpo
operator|->
name|devCtx
operator|)
condition|)
block|{
comment|/* PPS-context available -- use it! */
if|if
condition|(
name|MS_RLSD_ON
operator|&
name|modem_status
condition|)
block|{
name|dev
operator|->
name|pps_data
operator|.
name|cc_assert
operator|++
expr_stmt|;
name|dev
operator|->
name|pps_data
operator|.
name|ts_assert
operator|=
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"upps-real: fd %d DCD PPS Rise at %s\n"
operator|,
name|lpo
operator|->
name|slock
operator|->
name|rsrc
operator|.
name|rio
operator|->
name|fd
operator|,
name|ulfptoa
argument_list|(
operator|&
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
argument_list|,
literal|6
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|pps_data
operator|.
name|cc_clear
operator|++
expr_stmt|;
name|dev
operator|->
name|pps_data
operator|.
name|ts_clear
operator|=
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"upps-real: fd %d DCD PPS Fall at %s\n"
operator|,
name|lpo
operator|->
name|slock
operator|->
name|rsrc
operator|.
name|rio
operator|->
name|fd
operator|,
name|ulfptoa
argument_list|(
operator|&
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
argument_list|,
literal|6
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Update PPS buffer, writing from low to high, with index 			 * update as last action. We use interlocked ops and a 			 * volatile data destination to avoid reordering on compiler 			 * and CPU level. The interlocked instruction act as full 			 * barriers -- we need only release semantics, but we don't 			 * have them before VS2010. 			 */
name|covc
operator|=
name|dev
operator|->
name|cov_count
operator|+
literal|1u
expr_stmt|;
name|ppsbuf
operator|=
name|dev
operator|->
name|pps_buff
operator|+
operator|(
name|covc
operator|&
name|PPS_QUEUE_MSK
operator|)
expr_stmt|;
name|InterlockedExchange
argument_list|(
operator|(
name|PLONG
operator|)
operator|&
name|ppsbuf
operator|->
name|cov_count
argument_list|,
name|covc
argument_list|)
expr_stmt|;
name|ppsbuf
operator|->
name|data
operator|=
name|dev
operator|->
name|pps_data
expr_stmt|;
name|InterlockedExchange
argument_list|(
operator|(
name|PLONG
operator|)
operator|&
name|dev
operator|->
name|cov_count
argument_list|,
name|covc
argument_list|)
expr_stmt|;
block|}
comment|/* perlinger@ntp.org, 2012-11-19 		 * It can be argued that once you have the PPS API active, you can 		 * disable the old pps hack. This would give a behaviour that's much 		 * more like the behaviour under a UN*Xish OS. On the other hand, it 		 * will give a nasty surprise for people which have until now happily 		 * taken the pps hack for granted, and after the first complaint, I have 		 * decided to keep the old implementation unconditionally. So here it is: 		 * 		 * backward compat: 'usermode-pps-hack' 		 */
if|if
condition|(
name|MS_RLSD_ON
operator|&
name|modem_status
condition|)
block|{
name|lpo
operator|->
name|aux
operator|.
name|DCDSTime
operator|=
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
expr_stmt|;
name|lpo
operator|->
name|aux
operator|.
name|flTsDCDS
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"upps-hack: fd %d DCD PPS Rise at %s\n"
operator|,
name|lpo
operator|->
name|slock
operator|->
name|rsrc
operator|.
name|rio
operator|->
name|fd
operator|,
name|ulfptoa
argument_list|(
operator|&
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
argument_list|,
literal|6
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If IO ready, read data. Go back waiting else. */
if|if
condition|(
name|EV_RXFLAG
operator|&
name|lpo
operator|->
name|aux
operator|.
name|com_events
condition|)
block|{
comment|/* line discipline */
name|lpo
operator|->
name|aux
operator|.
name|FlagTime
operator|=
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
expr_stmt|;
name|lpo
operator|->
name|aux
operator|.
name|flTsFlag
operator|=
literal|1
expr_stmt|;
name|IoCtxStartLocked
argument_list|(
name|lpo
argument_list|,
name|QueueSerialRead
argument_list|,
name|lpo
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EV_RXCHAR
operator|&
name|lpo
operator|->
name|aux
operator|.
name|com_events
condition|)
block|{
comment|/* raw discipline */
name|lpo
operator|->
name|aux
operator|.
name|FlagTime
operator|=
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
expr_stmt|;
name|lpo
operator|->
name|aux
operator|.
name|flTsFlag
operator|=
literal|1
expr_stmt|;
name|IoCtxStartLocked
argument_list|(
name|lpo
argument_list|,
name|QueueRawSerialRead
argument_list|,
name|lpo
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* idle... */
name|IoCtxStartLocked
argument_list|(
name|lpo
argument_list|,
name|QueueSerialWait
argument_list|,
name|lpo
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * common for both modes  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|BOOL
name|__fastcall
name|QueueSerialReadCommon
parameter_list|(
name|IoCtx_t
modifier|*
name|lpo
parameter_list|,
name|recvbuf_t
modifier|*
name|buff
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"QueueSerialRead: cannot schedule device read"
decl_stmt|;
name|BOOL
name|rc
decl_stmt|;
comment|/* 'lpo->onIoDone' must be set already! */
name|lpo
operator|->
name|recv_buf
operator|=
name|buff
expr_stmt|;
name|lpo
operator|->
name|flRawMem
operator|=
literal|0
expr_stmt|;
comment|/* 'buff->recv_length' must be set already! */
name|buff
operator|->
name|fd
operator|=
name|lpo
operator|->
name|slock
operator|->
name|riofd
expr_stmt|;
name|buff
operator|->
name|dstadr
operator|=
name|NULL
expr_stmt|;
name|buff
operator|->
name|receiver
operator|=
name|process_refclock_packet
expr_stmt|;
name|buff
operator|->
name|recv_peer
operator|=
name|lpo
operator|->
name|slock
operator|->
name|rsrc
operator|.
name|rio
operator|->
name|srcclock
expr_stmt|;
name|rc
operator|=
name|ReadFile
argument_list|(
name|lpo
operator|->
name|io
operator|.
name|hnd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buff
operator|->
name|recv_buffer
operator|+
name|buff
operator|->
name|recv_length
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
operator|->
name|recv_buffer
argument_list|)
operator|-
name|buff
operator|->
name|recv_length
argument_list|,
name|NULL
argument_list|,
operator|&
name|lpo
operator|->
name|ol
argument_list|)
expr_stmt|;
return|return
name|rc
operator|||
name|IoResultCheck
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|lpo
argument_list|,
name|msg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * Part 2 -- line discipline emulation  *  * Ideally this should *not* be done in the IO completion thread.  * We use a worker pool thread to offload the low-level processing.  * -------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * Start& Queue a serial read for line discipline emulation.  */
end_comment

begin_function
specifier|static
name|BOOL
name|__fastcall
name|QueueSerialRead
parameter_list|(
name|IoCtx_t
modifier|*
name|lpo
parameter_list|,
name|recvbuf_t
modifier|*
name|buff
parameter_list|)
block|{
name|lpo
operator|->
name|onIoDone
operator|=
operator|&
name|OnSerialReadComplete
expr_stmt|;
comment|/* keep 'buff->recv_length' for line continuation! */
return|return
name|QueueSerialReadCommon
argument_list|(
name|lpo
argument_list|,
name|buff
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * IO completion thread callback. Takes a time stamp and offloads the  * real work to the worker pool ASAP.  */
end_comment

begin_function
specifier|static
name|void
name|OnSerialReadComplete
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"OnSerialReadComplete: read from device failed"
decl_stmt|;
comment|/* Make sure this RIO is not closed. */
if|if
condition|(
name|NULL
operator|==
name|getRioFromIoCtx
argument_list|(
name|lpo
argument_list|,
name|key
argument_list|,
name|msg
argument_list|)
condition|)
return|return;
comment|/* start next IO and leave if we hit an error */
if|if
condition|(
name|lpo
operator|->
name|errCode
operator|!=
name|ERROR_SUCCESS
condition|)
goto|goto
name|wait_again
goto|;
comment|/* Offload to worker pool, if there is data */
if|if
condition|(
name|lpo
operator|->
name|byteCount
operator|==
literal|0
condition|)
goto|goto
name|wait_again
goto|;
if|if
condition|(
name|QueueUserWorkItem
argument_list|(
operator|&
name|OnSerialReadWorker
argument_list|,
name|lpo
argument_list|,
name|WT_EXECUTEDEFAULT
argument_list|)
condition|)
return|return;
comment|/* successful regular exit! */
comment|/* croak as we're throwing away data */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't offload to worker thread, will skip data: %m"
argument_list|)
expr_stmt|;
name|wait_again
label|:
comment|/* make sure the read is issued again */
name|IoCtxStartLocked
argument_list|(
name|lpo
argument_list|,
name|QueueSerialWait
argument_list|,
name|lpo
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * Worker pool offload function -- avoid lengthy operations in the IO  * completion thread (affects timing...)  *  * This function does the real work of emulating the UN*X line  * discipline. Since this involves allocation of additional buffers and  * string parsing/copying, it is offloaded to the worker thread pool so  * the IO completion thread can resume faster.  *  * !!ATTENTION!!  * This function runs on an arbitrary worker thread, and not under the  * protection of the shared lock! Accessing the RIO structure must set  * the lock explicitely!  */
end_comment

begin_function
specifier|static
name|DWORD
name|WINAPI
name|OnSerialReadWorker
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|IoCtx_t
modifier|*
name|lpo
decl_stmt|;
name|SharedLock_t
modifier|*
name|slock
decl_stmt|;
name|recvbuf_t
modifier|*
name|buff
decl_stmt|,
modifier|*
name|obuf
decl_stmt|;
name|char
modifier|*
name|sptr
decl_stmt|,
modifier|*
name|send
decl_stmt|,
modifier|*
name|dptr
decl_stmt|;
name|BOOL
name|eol
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|BOOL
name|active
decl_stmt|;
name|u_long
name|rcvcnt
decl_stmt|;
name|RIO_t
modifier|*
name|rio
decl_stmt|;
comment|/* Get context back */
name|lpo
operator|=
operator|(
name|IoCtx_t
operator|*
operator|)
name|ctx
expr_stmt|;
name|buff
operator|=
name|lpo
operator|->
name|recv_buf
expr_stmt|;
comment|/* query the lock structure under mutual exclusion */
name|active
operator|=
name|FALSE
expr_stmt|;
name|rcvcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|slock
operator|=
name|slAttachShared
argument_list|(
name|lpo
operator|->
name|slock
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|NULL
operator|!=
operator|(
name|rio
operator|=
name|slock
operator|->
name|rsrc
operator|.
name|rio
operator|)
condition|)
block|{
name|active
operator|=
name|TRUE
expr_stmt|;
name|rcvcnt
operator|=
name|InterlockedIncrement
argument_list|(
operator|&
name|rio
operator|->
name|recvcount
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|slDetachShared
argument_list|(
name|slock
argument_list|)
expr_stmt|;
block|}
comment|/* bail out if we're disconnected now */
if|if
condition|(
operator|!
name|active
condition|)
block|{
name|IoCtxRelease
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Ignore zero-byte reads due to closure on fd. 	 * Eat the first line of input as it's possibly partial. 	 */
if|if
condition|(
name|lpo
operator|->
name|byteCount
operator|&&
name|rcvcnt
condition|)
block|{
comment|/* account for additional input */
name|buff
operator|->
name|recv_length
operator|+=
operator|(
name|int
operator|)
name|lpo
operator|->
name|byteCount
expr_stmt|;
comment|/* 		 * Now mimic the Unix line discipline. 		 */
name|sptr
operator|=
operator|(
name|char
operator|*
operator|)
name|buff
operator|->
name|recv_buffer
expr_stmt|;
name|send
operator|=
name|sptr
operator|+
name|buff
operator|->
name|recv_length
expr_stmt|;
name|obuf
operator|=
name|NULL
expr_stmt|;
name|dptr
operator|=
name|NULL
expr_stmt|;
comment|/* hack #1: eat away leading CR/LF if there is any */
while|while
condition|(
name|sptr
operator|!=
name|send
condition|)
block|{
name|ch
operator|=
operator|*
name|sptr
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|'\r'
condition|)
break|break;
name|sptr
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|sptr
operator|!=
name|send
condition|)
block|{
comment|/* get new buffer to store line */
name|obuf
operator|=
name|get_free_recv_buffer_alloc
argument_list|()
expr_stmt|;
name|obuf
operator|->
name|fd
operator|=
name|buff
operator|->
name|fd
expr_stmt|;
name|obuf
operator|->
name|receiver
operator|=
name|buff
operator|->
name|receiver
expr_stmt|;
name|obuf
operator|->
name|dstadr
operator|=
name|NULL
expr_stmt|;
name|obuf
operator|->
name|recv_peer
operator|=
name|buff
operator|->
name|recv_peer
expr_stmt|;
name|set_serial_recv_time
argument_list|(
name|obuf
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
comment|/* Copy data to new buffer, convert CR to LF on 			 * the fly.  Stop after either. 			 */
name|dptr
operator|=
operator|(
name|char
operator|*
operator|)
name|obuf
operator|->
name|recv_buffer
expr_stmt|;
name|eol
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|sptr
operator|!=
name|send
operator|&&
operator|!
name|eol
condition|)
block|{
name|ch
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
if|if
condition|(
literal|'\r'
operator|==
name|ch
condition|)
name|ch
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|dptr
operator|++
operator|=
name|ch
expr_stmt|;
name|eol
operator|=
operator|(
literal|'\n'
operator|==
name|ch
operator|)
expr_stmt|;
block|}
name|obuf
operator|->
name|recv_length
operator|=
call|(
name|int
call|)
argument_list|(
name|dptr
operator|-
operator|(
name|char
operator|*
operator|)
name|obuf
operator|->
name|recv_buffer
argument_list|)
expr_stmt|;
comment|/* If NL found, push this buffer and prepare to 			 * get a new one. Be prepared for concurrent 			 * removal of the clock... 			 */
if|if
condition|(
name|eol
condition|)
block|{
name|slQueueLocked
argument_list|(
name|lpo
operator|->
name|slock
argument_list|,
name|slRefClockOK
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
name|obuf
operator|=
name|NULL
expr_stmt|;
comment|/* consumed in any case */
block|}
block|}
comment|/* If we still have an output buffer, prepare it to be 		 * used for added input from the ComPort. Otherwise 		 * use the current input buffer again. 		 */
if|if
condition|(
name|obuf
condition|)
block|{
name|obuf
operator|->
name|recv_length
operator|=
call|(
name|int
call|)
argument_list|(
name|dptr
operator|-
operator|(
name|char
operator|*
operator|)
name|obuf
operator|->
name|recv_buffer
argument_list|)
expr_stmt|;
name|freerecvbuf
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|buff
operator|=
name|obuf
expr_stmt|;
block|}
else|else
block|{
comment|/* clear the current buffer, continue */
name|buff
operator|->
name|recv_length
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|buff
operator|->
name|recv_length
operator|=
literal|0
expr_stmt|;
block|}
comment|/* start next round -- must hold the lock during that! */
name|IoCtxStartLocked
argument_list|(
name|lpo
argument_list|,
name|QueueSerialWait
argument_list|,
name|buff
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * Part 3 -- raw data input  *  * Raw data processing is fast enough to do without offloading to the  * worker pool, so this is rather short'n sweet...  * -------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|BOOL
name|__fastcall
name|QueueRawSerialRead
parameter_list|(
name|IoCtx_t
modifier|*
name|lpo
parameter_list|,
name|recvbuf_t
modifier|*
name|buff
parameter_list|)
block|{
name|lpo
operator|->
name|onIoDone
operator|=
name|OnRawSerialReadComplete
expr_stmt|;
name|buff
operator|->
name|recv_length
operator|=
literal|0
expr_stmt|;
return|return
name|QueueSerialReadCommon
argument_list|(
name|lpo
argument_list|,
name|buff
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  * IO completion thread callback. Takes a time stamp and offloads the  * real work to the worker pool ASAP.  */
end_comment

begin_function
specifier|static
name|void
name|OnRawSerialReadComplete
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"OnRawSerialReadComplete: read from device failed"
decl_stmt|;
name|recvbuf_t
modifier|*
name|buff
init|=
name|lpo
operator|->
name|recv_buf
decl_stmt|;
name|RIO_t
modifier|*
name|rio
init|=
name|getRioFromIoCtx
argument_list|(
name|lpo
argument_list|,
name|key
argument_list|,
name|msg
argument_list|)
decl_stmt|;
comment|/* Make sure this RIO is not closed. */
if|if
condition|(
name|rio
operator|==
name|NULL
condition|)
return|return;
comment|/* start next IO and leave if we hit an error */
if|if
condition|(
name|lpo
operator|->
name|errCode
operator|==
name|ERROR_SUCCESS
operator|&&
name|lpo
operator|->
name|byteCount
operator|>
literal|0
condition|)
block|{
name|buff
operator|->
name|recv_length
operator|=
operator|(
name|int
operator|)
name|lpo
operator|->
name|byteCount
expr_stmt|;
name|set_serial_recv_time
argument_list|(
name|buff
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
name|slQueueLocked
argument_list|(
name|lpo
operator|->
name|slock
argument_list|,
name|slRefClockOK
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|buff
operator|=
name|get_free_recv_buffer_alloc
argument_list|()
expr_stmt|;
block|}
name|IoCtxStartLocked
argument_list|(
name|lpo
argument_list|,
name|QueueSerialWait
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_serial_recv_time
parameter_list|(
name|recvbuf_t
modifier|*
name|obuf
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
comment|/* Time stamp assignment is interesting.  If we 	 * have a DCD stamp, we use it, otherwise we use 	 * the FLAG char event time, and if that is also 	 * not / no longer available we use the arrival 	 * time. 	 */
if|if
condition|(
name|lpo
operator|->
name|aux
operator|.
name|flTsDCDS
condition|)
name|obuf
operator|->
name|recv_time
operator|=
name|lpo
operator|->
name|aux
operator|.
name|DCDSTime
expr_stmt|;
elseif|else
if|if
condition|(
name|lpo
operator|->
name|aux
operator|.
name|flTsFlag
condition|)
name|obuf
operator|->
name|recv_time
operator|=
name|lpo
operator|->
name|aux
operator|.
name|FlagTime
expr_stmt|;
else|else
name|obuf
operator|->
name|recv_time
operator|=
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
expr_stmt|;
name|lpo
operator|->
name|aux
operator|.
name|flTsDCDS
operator|=
name|lpo
operator|->
name|aux
operator|.
name|flTsFlag
operator|=
literal|0
expr_stmt|;
comment|/* use only once! */
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * Part 4 -- Overlapped serial output  *  * Again, no need to offload any work.  * -------------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * async_write, clone of write(), used by some reflock drivers  */
end_comment

begin_function
name|int
name|async_write
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|count
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"async_write: cannot schedule device write"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|dmsg
init|=
literal|"overlapped IO data buffer"
decl_stmt|;
name|IoCtx_t
modifier|*
name|lpo
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|buff
init|=
name|NULL
decl_stmt|;
name|HANDLE
name|hnd
init|=
name|NULL
decl_stmt|;
name|BOOL
name|rc
decl_stmt|;
name|hnd
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|hnd
operator|==
name|INVALID_HANDLE_VALUE
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|buff
operator|=
name|IOCPLPoolMemDup
argument_list|(
name|data
argument_list|,
name|count
argument_list|,
name|dmsg
argument_list|)
operator|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|lpo
operator|=
name|IoCtxAlloc
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
goto|goto
name|fail
goto|;
name|lpo
operator|->
name|io
operator|.
name|hnd
operator|=
name|hnd
expr_stmt|;
name|lpo
operator|->
name|onIoDone
operator|=
name|OnSerialWriteComplete
expr_stmt|;
name|lpo
operator|->
name|trans_buf
operator|=
name|buff
expr_stmt|;
name|lpo
operator|->
name|flRawMem
operator|=
literal|1
expr_stmt|;
name|rc
operator|=
name|WriteFile
argument_list|(
name|lpo
operator|->
name|io
operator|.
name|hnd
argument_list|,
name|lpo
operator|->
name|trans_buf
argument_list|,
name|count
argument_list|,
name|NULL
argument_list|,
operator|&
name|lpo
operator|->
name|ol
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|||
name|IoResultCheck
argument_list|(
name|GetLastError
argument_list|()
argument_list|,
name|lpo
argument_list|,
name|msg
argument_list|)
condition|)
return|return
name|count
return|;
comment|/* normal/success return */
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|-
literal|1
return|;
name|fail
label|:
name|IoCtxFree
argument_list|(
name|lpo
argument_list|)
expr_stmt|;
name|IOCPLPoolFree
argument_list|(
name|buff
argument_list|,
name|dmsg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|OnSerialWriteComplete
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
comment|/* This is really trivial: Let 'getRioFromIoCtx()' do all the 	 * error processing, and it returns with a valid RIO, just 	 * drop the complete context. 	 */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"OnSerialWriteComplete: serial output failed"
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|getRioFromIoCtx
argument_list|(
name|lpo
argument_list|,
name|key
argument_list|,
name|msg
argument_list|)
condition|)
name|IoCtxRelease
argument_list|(
name|lpo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Serial IO stuff  *  * Part 5 -- read PPS time stamps  *  * -------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* The dummy read procedure is used for getting the device context  * into the IO completion thread, using the IO completion queue for  * transport. There are other ways to accomplish what we need here,  * but using the IO machine is handy and avoids a lot of trouble.  */
end_comment

begin_function
specifier|static
name|void
name|OnPpsDummyRead
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
name|RIO_t
modifier|*
name|rio
decl_stmt|;
name|rio
operator|=
operator|(
name|RIO_t
operator|*
operator|)
name|key
expr_stmt|;
name|lpo
operator|->
name|devCtx
operator|=
name|DevCtxAttach
argument_list|(
name|rio
operator|->
name|device_ctx
argument_list|)
expr_stmt|;
name|SetEvent
argument_list|(
name|lpo
operator|->
name|ppswake
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|__declspec
argument_list|(
argument|dllexport
argument_list|)
end_macro

begin_function
name|void
modifier|*
name|__stdcall
name|ntp_pps_attach_device
parameter_list|(
name|HANDLE
name|hndIo
parameter_list|)
block|{
name|IoCtx_t
name|myIoCtx
decl_stmt|;
name|HANDLE
name|myEvt
decl_stmt|;
name|DevCtx_t
modifier|*
name|dev
decl_stmt|;
name|DWORD
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|isserialhandle
argument_list|(
name|hndIo
argument_list|)
condition|)
block|{
name|SetLastError
argument_list|(
name|ERROR_INVALID_HANDLE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ZERO
argument_list|(
name|myIoCtx
argument_list|)
expr_stmt|;
name|dev
operator|=
name|NULL
expr_stmt|;
name|myEvt
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|myEvt
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|myIoCtx
operator|.
name|ppswake
operator|=
name|myEvt
expr_stmt|;
name|myIoCtx
operator|.
name|onIoDone
operator|=
name|OnPpsDummyRead
expr_stmt|;
name|rc
operator|=
name|ReadFile
argument_list|(
name|hndIo
argument_list|,
operator|&
name|myIoCtx
operator|.
name|byteCount
argument_list|,
literal|0
argument_list|,
operator|&
name|myIoCtx
operator|.
name|byteCount
argument_list|,
operator|&
name|myIoCtx
operator|.
name|ol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|&&
operator|(
name|GetLastError
argument_list|()
operator|!=
name|ERROR_IO_PENDING
operator|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|WaitForSingleObject
argument_list|(
name|myEvt
argument_list|,
name|INFINITE
argument_list|)
operator|==
name|WAIT_OBJECT_0
condition|)
if|if
condition|(
name|NULL
operator|==
operator|(
name|dev
operator|=
name|myIoCtx
operator|.
name|devCtx
operator|)
condition|)
name|SetLastError
argument_list|(
name|ERROR_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|done
label|:
name|rc
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|CloseHandle
argument_list|(
name|myEvt
argument_list|)
expr_stmt|;
name|SetLastError
argument_list|(
name|rc
argument_list|)
expr_stmt|;
return|return
name|dev
return|;
block|}
end_function

begin_macro
name|__declspec
argument_list|(
argument|dllexport
argument_list|)
end_macro

begin_function
name|void
name|__stdcall
name|ntp_pps_detach_device
parameter_list|(
name|DevCtx_t
modifier|*
name|dev
parameter_list|)
block|{
name|DevCtxDetach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|__declspec
argument_list|(
argument|dllexport
argument_list|)
end_macro

begin_function
name|BOOL
name|__stdcall
name|ntp_pps_read
parameter_list|(
name|DevCtx_t
modifier|*
name|dev
parameter_list|,
name|PPSData_t
modifier|*
name|data
parameter_list|,
name|size_t
name|dlen
parameter_list|)
block|{
name|u_long
name|guard
decl_stmt|,
name|covc
decl_stmt|;
name|int
name|repc
decl_stmt|;
name|PPSDataEx_t
modifier|*
name|ppsbuf
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|SetLastError
argument_list|(
name|ERROR_INVALID_HANDLE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|data
operator|==
name|NULL
operator|||
name|dlen
operator|!=
sizeof|sizeof
argument_list|(
name|PPSData_t
argument_list|)
condition|)
block|{
name|SetLastError
argument_list|(
name|ERROR_INVALID_PARAMETER
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Reading from shared memory in a lock-free fashion can be 	 * a bit tricky, since we have to read the components in the 	 * opposite direction from the write, and the compiler must 	 * not reorder the read sequence. 	 * We use interlocked ops and a volatile data source to avoid 	 * reordering on compiler and CPU level. The interlocked 	 * instruction act as full barriers -- we need only acquire 	 * semantics, but we don't have them before VS2010. 	 */
name|repc
operator|=
literal|3
expr_stmt|;
do|do
block|{
name|covc
operator|=
name|InterlockedExchangeAdd
argument_list|(
operator|(
name|PLONG
operator|)
operator|&
name|dev
operator|->
name|cov_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ppsbuf
operator|=
name|dev
operator|->
name|pps_buff
operator|+
operator|(
name|covc
operator|&
name|PPS_QUEUE_MSK
operator|)
expr_stmt|;
operator|*
name|data
operator|=
name|ppsbuf
operator|->
name|data
expr_stmt|;
name|guard
operator|=
name|InterlockedExchangeAdd
argument_list|(
operator|(
name|PLONG
operator|)
operator|&
name|ppsbuf
operator|->
name|cov_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|guard
operator|^=
name|covc
expr_stmt|;
block|}
do|while
condition|(
name|guard
operator|&&
operator|~
name|guard
operator|&&
operator|--
name|repc
condition|)
do|;
if|if
condition|(
name|guard
condition|)
block|{
name|SetLastError
argument_list|(
name|ERROR_INVALID_DATA
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * register and unregister refclock IOs with the IO engine  * --------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* Add a reference clock data structures I/O handles to  * the I/O completion port. Return FALSE if any error,  * TRUE on success  */
end_comment

begin_function
name|BOOL
name|io_completion_port_add_clock_io
parameter_list|(
name|RIO_t
modifier|*
name|rio
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msgh
init|=
literal|"io_completion_port_add_clock_io"
decl_stmt|;
name|IoCtx_t
modifier|*
name|lpo
decl_stmt|;
name|HANDLE
name|h
decl_stmt|;
name|SharedLock_t
modifier|*
name|slock
init|=
name|NULL
decl_stmt|;
comment|/* preset to clear state for error cleanup:*/
name|rio
operator|->
name|ioreg_ctx
operator|=
name|NULL
expr_stmt|;
name|rio
operator|->
name|device_ctx
operator|=
name|NULL
expr_stmt|;
name|h
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|rio
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: COM port FD not valid"
argument_list|,
name|msgh
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|rio
operator|->
name|ioreg_ctx
operator|=
name|slock
operator|=
name|slCreate
argument_list|(
name|rio
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: Failed to create shared lock"
argument_list|,
name|msgh
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|slock
operator|->
name|handles
index|[
literal|0
index|]
operator|=
name|h
expr_stmt|;
name|slock
operator|->
name|riofd
operator|=
name|rio
operator|->
name|fd
expr_stmt|;
name|slock
operator|->
name|rsrc
operator|.
name|rio
operator|=
name|rio
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rio
operator|->
name|device_ctx
operator|=
name|DevCtxAlloc
argument_list|()
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: Failed to allocate device context"
argument_list|,
name|msgh
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|lpo
operator|=
name|IoCtxAlloc
argument_list|(
name|slock
argument_list|,
name|rio
operator|->
name|device_ctx
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%: Failed to allocate IO context"
argument_list|,
name|msgh
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
name|CreateIoCompletionPort
argument_list|(
name|h
argument_list|,
name|hndIOCPLPort
argument_list|,
operator|(
name|ULONG_PTR
operator|)
name|rio
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: Can't add COM port to i/o completion port: %m"
argument_list|,
name|msgh
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|lpo
operator|->
name|io
operator|.
name|hnd
operator|=
name|h
expr_stmt|;
return|return
name|QueueSerialWait
argument_list|(
name|lpo
argument_list|,
name|get_free_recv_buffer_alloc
argument_list|()
argument_list|)
return|;
name|fail
label|:
name|rio
operator|->
name|ioreg_ctx
operator|=
name|slDetach
argument_list|(
name|rio
operator|->
name|ioreg_ctx
argument_list|)
expr_stmt|;
name|rio
operator|->
name|device_ctx
operator|=
name|DevCtxDetach
argument_list|(
name|rio
operator|->
name|device_ctx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_function
name|void
name|io_completion_port_remove_clock_io
parameter_list|(
name|RIO_t
modifier|*
name|rio
parameter_list|)
block|{
name|SharedLock_t
modifier|*
name|slock
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|rio
operator|&&
name|NULL
operator|!=
operator|(
name|slock
operator|=
name|slAttachExclusive
argument_list|(
name|rio
operator|->
name|ioreg_ctx
argument_list|)
operator|)
condition|)
block|{
name|slDetach
argument_list|(
name|slock
argument_list|)
expr_stmt|;
name|slock
operator|->
name|handles
index|[
literal|0
index|]
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|slock
operator|->
name|handles
index|[
literal|1
index|]
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|slock
operator|->
name|rsrc
operator|.
name|rio
operator|=
name|NULL
expr_stmt|;
name|slock
operator|->
name|riofd
operator|=
operator|-
literal|1
expr_stmt|;
name|rio
operator|->
name|device_ctx
operator|=
name|DevCtxDetach
argument_list|(
name|rio
operator|->
name|device_ctx
argument_list|)
expr_stmt|;
name|rio
operator|->
name|ioreg_ctx
operator|=
name|slDetachExclusive
argument_list|(
name|slock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * -------------------------------------------------------------------  * Socket IO stuff  * -------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* Queue a receiver on a socket. Returns 0 if no buffer can be queued   *  *  Note: As per the WINSOCK documentation, we use WSARecvFrom. Using  *	  ReadFile() is less efficient. Also, WSARecvFrom delivers  *	  the remote network address. With ReadFile, getting this  *	  becomes a chore.  */
end_comment

begin_function
specifier|static
name|BOOL
name|__fastcall
name|QueueSocketRecv
parameter_list|(
name|IoCtx_t
modifier|*
name|lpo
parameter_list|,
name|recvbuf_t
modifier|*
name|buff
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"QueueSocketRecv: cannot schedule socket receive"
decl_stmt|;
name|WSABUF
name|wsabuf
decl_stmt|;
name|DWORD
name|Flags
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|lpo
operator|->
name|onIoDone
operator|=
name|OnSocketRecv
expr_stmt|;
name|lpo
operator|->
name|recv_buf
operator|=
name|buff
expr_stmt|;
name|lpo
operator|->
name|flRawMem
operator|=
literal|0
expr_stmt|;
name|buff
operator|->
name|fd
operator|=
name|lpo
operator|->
name|io
operator|.
name|sfd
expr_stmt|;
name|buff
operator|->
name|recv_srcadr_len
operator|=
sizeof|sizeof
argument_list|(
name|buff
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
name|buff
operator|->
name|receiver
operator|=
name|receive
expr_stmt|;
name|buff
operator|->
name|dstadr
operator|=
name|lpo
operator|->
name|slock
operator|->
name|rsrc
operator|.
name|ept
expr_stmt|;
name|wsabuf
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buff
operator|->
name|recv_buffer
expr_stmt|;
name|wsabuf
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buff
operator|->
name|recv_buffer
argument_list|)
expr_stmt|;
name|Flags
operator|=
literal|0
expr_stmt|;
comment|/* in/out parameter, must be valid! */
name|rc
operator|=
name|WSARecvFrom
argument_list|(
name|lpo
operator|->
name|io
operator|.
name|sfd
argument_list|,
operator|&
name|wsabuf
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|Flags
argument_list|,
operator|&
name|buff
operator|->
name|recv_srcadr
operator|.
name|sa
argument_list|,
operator|&
name|buff
operator|->
name|recv_srcadr_len
argument_list|,
operator|&
name|lpo
operator|->
name|ol
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|!
name|rc
operator|||
name|IoResultCheck
argument_list|(
operator|(
name|DWORD
operator|)
name|WSAGetLastError
argument_list|()
argument_list|,
name|lpo
argument_list|,
name|msg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|OnSocketRecv
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"OnSocketRecv: receive from socket failed"
decl_stmt|;
name|recvbuf_t
modifier|*
name|buff
init|=
name|NULL
decl_stmt|;
name|SharedLock_t
modifier|*
name|slock
init|=
name|NULL
decl_stmt|;
comment|/* Make sure this endpoint is not closed. */
name|endpt
modifier|*
name|ep
init|=
name|getEndptFromIoCtx
argument_list|(
name|lpo
argument_list|,
name|key
argument_list|,
name|msg
argument_list|)
decl_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return;
comment|/* We want to start a new read before we process the buffer. 	 * Since we must not use the context object once it is in 	 * another IO, we go through some pains to read everything 	 * before going out for another read request. 	 * We also need an extra hold to the SLOCK structure. 	 */
name|slock
operator|=
name|slAttach
argument_list|(
name|lpo
operator|->
name|slock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lpo
operator|->
name|errCode
operator|==
name|ERROR_SUCCESS
operator|&&
name|lpo
operator|->
name|byteCount
operator|>
literal|0
condition|)
block|{
comment|/* keep input buffer, create new one for IO */
name|buff
operator|=
name|lpo
operator|->
name|recv_buf
expr_stmt|;
name|lpo
operator|->
name|recv_buf
operator|=
name|get_free_recv_buffer_alloc
argument_list|()
expr_stmt|;
name|buff
operator|->
name|recv_time
operator|=
name|lpo
operator|->
name|aux
operator|.
name|RecvTime
expr_stmt|;
name|buff
operator|->
name|recv_length
operator|=
operator|(
name|int
operator|)
name|lpo
operator|->
name|byteCount
expr_stmt|;
block|}
comment|/* Note: else we use the current buffer again */
name|IoCtxStartLocked
argument_list|(
name|lpo
argument_list|,
name|QueueSocketRecv
argument_list|,
name|lpo
operator|->
name|recv_buf
argument_list|)
expr_stmt|;
comment|/* below this, any usage of 'lpo' is invalid! */
comment|/* If we have a buffer, do some bookkeeping and other chores, 	 * then feed it to the input queue. And we can be sure we have 	 * a packet here, so we can update the stats. 	 */
if|if
condition|(
name|buff
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|buff
operator|->
name|recv_srcadr_len
operator|<=
sizeof|sizeof
argument_list|(
name|buff
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%sfd %d %s recv packet mode is %d\n"
operator|,
operator|(
name|MODE_BROADCAST
operator|==
name|get_packet_mode
argument_list|(
name|buff
argument_list|)
operator|)
condition|?
literal|" **** Broadcast "
else|:
literal|""
operator|,
operator|(
name|int
operator|)
name|buff
operator|->
name|fd
operator|,
name|stoa
argument_list|(
operator|&
name|buff
operator|->
name|recv_srcadr
argument_list|)
operator|,
name|get_packet_mode
argument_list|(
name|buff
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|slAttachShared
argument_list|(
name|slock
argument_list|)
condition|)
block|{
name|BOOL
name|epOK
init|=
name|slEndPointOK
argument_list|(
name|slock
argument_list|)
decl_stmt|;
if|if
condition|(
name|epOK
condition|)
name|InterlockedIncrement
argument_list|(
operator|&
name|slock
operator|->
name|rsrc
operator|.
name|ept
operator|->
name|received
argument_list|)
expr_stmt|;
name|slDetachShared
argument_list|(
name|slock
argument_list|)
expr_stmt|;
if|if
condition|(
name|epOK
condition|)
block|{
name|InterlockedIncrement
argument_list|(
operator|&
name|packets_received
argument_list|)
expr_stmt|;
name|InterlockedIncrement
argument_list|(
operator|&
name|handler_pkts
argument_list|)
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
literal|"Received %d bytes fd %d in buffer %p from %s\n"
operator|,
name|buff
operator|->
name|recv_length
operator|,
operator|(
name|int
operator|)
name|buff
operator|->
name|fd
operator|,
name|buff
operator|,
name|stoa
argument_list|(
operator|&
name|buff
operator|->
name|recv_srcadr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|slQueueLocked
argument_list|(
name|slock
argument_list|,
name|slEndPointOK
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
name|slDetach
argument_list|(
name|slock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|OnSocketSend
parameter_list|(
name|ULONG_PTR
name|key
parameter_list|,
name|IoCtx_t
modifier|*
name|lpo
parameter_list|)
block|{
comment|/* this is somewhat easier: */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"OnSocketRecv: send to socket failed"
decl_stmt|;
name|SharedLock_t
modifier|*
name|slock
init|=
name|NULL
decl_stmt|;
name|endpt
modifier|*
name|ep
init|=
name|getEndptFromIoCtx
argument_list|(
name|lpo
argument_list|,
name|key
argument_list|,
name|msg
argument_list|)
decl_stmt|;
comment|/* Make sure this endpoint is not closed. */
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|lpo
operator|->
name|errCode
operator|!=
name|ERROR_SUCCESS
condition|)
name|slock
operator|=
name|slAttachShared
argument_list|(
name|lpo
operator|->
name|slock
argument_list|)
expr_stmt|;
if|if
condition|(
name|slock
condition|)
block|{
name|BOOL
name|epOK
init|=
name|slEndPointOK
argument_list|(
name|slock
argument_list|)
decl_stmt|;
if|if
condition|(
name|epOK
condition|)
block|{
name|InterlockedIncrement
argument_list|(
operator|&
name|slock
operator|->
name|rsrc
operator|.
name|ept
operator|->
name|notsent
argument_list|)
expr_stmt|;
name|InterlockedDecrement
argument_list|(
operator|&
name|slock
operator|->
name|rsrc
operator|.
name|ept
operator|->
name|sent
argument_list|)
expr_stmt|;
block|}
name|slDetachShared
argument_list|(
name|slock
argument_list|)
expr_stmt|;
if|if
condition|(
name|epOK
condition|)
block|{
name|InterlockedIncrement
argument_list|(
operator|&
name|packets_notsent
argument_list|)
expr_stmt|;
name|InterlockedDecrement
argument_list|(
operator|&
name|packets_sent
argument_list|)
expr_stmt|;
block|}
block|}
name|IoCtxRelease
argument_list|(
name|lpo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * register and de-register interface endpoints with the IO engine  * --------------------------------------------------------------------  */
end_comment

begin_function
name|BOOL
name|io_completion_port_add_interface
parameter_list|(
name|endpt
modifier|*
name|ep
parameter_list|)
block|{
comment|/* Registering an endpoint is simple: allocate a shared lock for 	 * the enpoint and return if the allocation was successful. 	 */
name|ep
operator|->
name|ioreg_ctx
operator|=
name|slCreate
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|ep
operator|->
name|ioreg_ctx
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_function
name|void
name|io_completion_port_remove_interface
parameter_list|(
name|endpt
modifier|*
name|ep
parameter_list|)
block|{
comment|/* Removing an endpoint is simple, too: Lock the shared lock 	 * for write access, then invalidate the handles and the 	 * endpoint pointer. Do an additional detach and leave the 	 * write lock. 	 */
name|SharedLock_t
modifier|*
name|slock
init|=
name|slAttachExclusive
argument_list|(
name|ep
operator|->
name|ioreg_ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|slock
operator|!=
name|NULL
condition|)
block|{
name|slDetach
argument_list|(
name|slock
argument_list|)
expr_stmt|;
name|slock
operator|->
name|handles
index|[
literal|0
index|]
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|slock
operator|->
name|handles
index|[
literal|1
index|]
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|slock
operator|->
name|rsrc
operator|.
name|ept
operator|=
name|NULL
expr_stmt|;
name|ep
operator|->
name|ioreg_ctx
operator|=
name|slDetachExclusive
argument_list|(
name|slock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * register and de-register sockets for an endpoint  * --------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* Add a socket handle to the I/O completion port, and send   * NTP_RECVS_PER_SOCKET receive requests to the kernel.  */
end_comment

begin_function
name|BOOL
name|io_completion_port_add_socket
parameter_list|(
name|SOCKET
name|sfd
parameter_list|,
name|endpt
modifier|*
name|ep
parameter_list|,
name|BOOL
name|bcast
parameter_list|)
block|{
comment|/* Assume the endpoint is already registered. Set the socket 	 * handle into the proper slot, and then start up the IO engine. 	 */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"Can't add socket to i/o completion port"
decl_stmt|;
name|IoCtx_t
modifier|*
name|lpo
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|ULONG_PTR
name|key
decl_stmt|;
name|SharedLock_t
modifier|*
name|slock
init|=
name|NULL
decl_stmt|;
name|key
operator|=
operator|(
operator|(
name|ULONG_PTR
operator|)
name|ep
operator|&
operator|~
operator|(
name|ULONG_PTR
operator|)
literal|1u
operator|)
operator|+
operator|!
operator|!
name|bcast
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|slock
operator|=
name|slAttachExclusive
argument_list|(
name|ep
operator|->
name|ioreg_ctx
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"io_completion_port_add_socket: endpt = %p not registered, exiting"
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|endpt
modifier|*
name|rep
init|=
name|slock
operator|->
name|rsrc
operator|.
name|ept
decl_stmt|;
name|slock
operator|->
name|handles
index|[
operator|!
operator|!
name|bcast
index|]
operator|=
operator|(
name|HANDLE
operator|)
name|sfd
expr_stmt|;
name|slDetachExclusive
argument_list|(
name|slock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rep
operator|==
name|ep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|==
name|CreateIoCompletionPort
argument_list|(
operator|(
name|HANDLE
operator|)
name|sfd
argument_list|,
name|hndIOCPLPort
argument_list|,
name|key
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %m"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|n
operator|=
name|s_SockRecvSched
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
block|{
if|if
condition|(
name|NULL
operator|==
operator|(
name|lpo
operator|=
name|IoCtxAlloc
argument_list|(
name|ep
operator|->
name|ioreg_ctx
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: no read buffer: %m"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|lpo
operator|->
name|io
operator|.
name|sfd
operator|=
name|sfd
expr_stmt|;
if|if
condition|(
operator|!
name|QueueSocketRecv
argument_list|(
name|lpo
argument_list|,
name|get_free_recv_buffer_alloc
argument_list|()
argument_list|)
condition|)
goto|goto
name|fail
goto|;
block|}
return|return
name|TRUE
return|;
name|fail
label|:
name|ep
operator|->
name|ioreg_ctx
operator|=
name|slDetach
argument_list|(
name|ep
operator|->
name|ioreg_ctx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------- */
end_comment

begin_function
name|void
name|io_completion_port_remove_socket
parameter_list|(
name|SOCKET
name|fd
parameter_list|,
name|endpt
modifier|*
name|ep
parameter_list|)
block|{
comment|/* Lock the shared lock for write, then search the given 	 * socket handle and replace it with an invalid handle value. 	 */
name|SharedLock_t
modifier|*
name|lp
init|=
name|slAttachExclusive
argument_list|(
name|ep
operator|->
name|ioreg_ctx
argument_list|)
decl_stmt|;
name|HANDLE
name|sh
init|=
operator|(
name|HANDLE
operator|)
name|fd
decl_stmt|;
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lp
operator|->
name|handles
index|[
literal|0
index|]
operator|==
name|sh
condition|)
name|lp
operator|->
name|handles
index|[
literal|0
index|]
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
elseif|else
if|if
condition|(
name|lp
operator|->
name|handles
index|[
literal|1
index|]
operator|==
name|sh
condition|)
name|lp
operator|->
name|handles
index|[
literal|1
index|]
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|slDetachExclusive
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * I/O API functions for endpoints / interfaces  * --------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* io_completion_port_sendto() -- sendto() replacement for Windows  *  * Returns len after successful send.  * Returns -1 for any error, with the error code available via  *	msyslog() %m, or GetLastError().  */
end_comment

begin_function
name|int
name|io_completion_port_sendto
parameter_list|(
name|endpt
modifier|*
name|ep
parameter_list|,
name|SOCKET
name|sfd
parameter_list|,
name|void
modifier|*
name|pkt
parameter_list|,
name|size_t
name|len
parameter_list|,
name|sockaddr_u
modifier|*
name|dest
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
init|=
literal|"sendto: cannot schedule socket send"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|dmsg
init|=
literal|"overlapped IO data buffer"
decl_stmt|;
name|IoCtx_t
modifier|*
name|lpo
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|dbuf
init|=
name|NULL
decl_stmt|;
name|WSABUF
name|wsabuf
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|INT_MAX
condition|)
name|len
operator|=
name|INT_MAX
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|dbuf
operator|=
name|IOCPLPoolMemDup
argument_list|(
name|pkt
argument_list|,
name|len
argument_list|,
name|dmsg
argument_list|)
operator|)
condition|)
goto|goto
name|fail
goto|;
comment|/* We register the IO operation against the shared lock here. 	 * This is not strictly necessary, since the callback does not 	 * access the endpoint structure in any way... 	 */
if|if
condition|(
name|NULL
operator|==
operator|(
name|lpo
operator|=
name|IoCtxAlloc
argument_list|(
name|ep
operator|->
name|ioreg_ctx
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
goto|goto
name|fail
goto|;
name|lpo
operator|->
name|onIoDone
operator|=
name|OnSocketSend
expr_stmt|;
name|lpo
operator|->
name|trans_buf
operator|=
name|dbuf
expr_stmt|;
name|lpo
operator|->
name|flRawMem
operator|=
literal|1
expr_stmt|;
name|lpo
operator|->
name|io
operator|.
name|sfd
operator|=
name|sfd
expr_stmt|;
name|wsabuf
operator|.
name|buf
operator|=
operator|(
name|void
operator|*
operator|)
name|lpo
operator|->
name|trans_buf
expr_stmt|;
name|wsabuf
operator|.
name|len
operator|=
operator|(
name|DWORD
operator|)
name|len
expr_stmt|;
name|rc
operator|=
name|WSASendTo
argument_list|(
name|sfd
argument_list|,
operator|&
name|wsabuf
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|dest
operator|->
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
name|dest
argument_list|)
argument_list|,
operator|&
name|lpo
operator|->
name|ol
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|||
name|IoResultCheck
argument_list|(
operator|(
name|DWORD
operator|)
name|WSAGetLastError
argument_list|()
argument_list|,
name|lpo
argument_list|,
name|msg
argument_list|)
condition|)
return|return
operator|(
name|int
operator|)
name|len
return|;
comment|/* normal/success return */
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|-
literal|1
return|;
name|fail
label|:
name|IoCtxFree
argument_list|(
name|lpo
argument_list|)
expr_stmt|;
name|IOCPLPoolFree
argument_list|(
name|dbuf
argument_list|,
name|dmsg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * GetReceivedBuffers  * Note that this is in effect the main loop for processing requests  * both send and receive. This should be reimplemented  */
end_comment

begin_function
name|int
name|GetReceivedBuffers
parameter_list|(
name|void
parameter_list|)
block|{
name|DWORD
name|index
decl_stmt|;
name|HANDLE
name|ready
decl_stmt|;
name|int
name|have_packet
decl_stmt|;
name|have_packet
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|have_packet
condition|)
block|{
name|index
operator|=
name|WaitForMultipleObjectsEx
argument_list|(
name|ActiveWaitHandles
argument_list|,
name|WaitHandles
argument_list|,
name|FALSE
argument_list|,
name|INFINITE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|WAIT_OBJECT_0
operator|+
literal|0
case|:
comment|/* Io event */
name|DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"IoEvent occurred\n"
operator|)
argument_list|)
expr_stmt|;
name|have_packet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|WAIT_OBJECT_0
operator|+
literal|1
case|:
comment|/* exit request */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|WAIT_OBJECT_0
operator|+
literal|2
case|:
comment|/* timer */
name|timer
argument_list|()
expr_stmt|;
break|break;
case|case
name|WAIT_IO_COMPLETION
case|:
comment|/* loop */
break|break;
case|case
name|WAIT_TIMEOUT
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WaitForMultipleObjects INFINITE timed out."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|WAIT_FAILED
case|:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"WaitForMultipleObjects Failed: Error: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DEBUG_INSIST
argument_list|(
operator|(
name|index
operator|-
name|WAIT_OBJECT_0
operator|)
operator|<
name|ActiveWaitHandles
argument_list|)
expr_stmt|;
name|ready
operator|=
name|WaitHandles
index|[
name|index
operator|-
name|WAIT_OBJECT_0
index|]
expr_stmt|;
name|handle_blocking_resp_sem
argument_list|(
name|ready
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
return|return
operator|(
name|full_recvbuffs
argument_list|()
operator|)
return|;
comment|/* get received buffers */
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*defined(HAVE_IO_COMPLETION_PORT) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|NonEmptyCompilationUnit
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!defined(HAVE_IO_COMPLETION_PORT) */
end_comment

end_unit

