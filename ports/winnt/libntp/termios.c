begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This file implements system calls that are not compatible with UNIX */
end_comment

begin_comment
comment|/* Moved to libntp/termios.c */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_tty.h"
end_include

begin_include
include|#
directive|include
file|"lib_strbuf.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"win32_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_iocplmem.h"
end_include

begin_include
include|#
directive|include
file|"ntp_iocpltypes.h"
end_include

begin_comment
comment|/* -------------------------------------------------------------------  * COM port management  *  * com port handling needs some special functionality, especially for  * PPS support. There are things that are shared by the Windows Kernel  * on device level, not handle level. These include IOCPL membership,  * event wait slot, ... It's also no so simple to open a device a  * second time, and so we must manage the handles on open com ports  * in userland. Well, partially.  */
end_comment

begin_define
define|#
directive|define
name|MAX_SERIAL
value|255
end_define

begin_comment
comment|/* COM1: - COM255: */
end_comment

begin_define
define|#
directive|define
name|MAX_COMDUP
value|8
end_define

begin_comment
comment|/* max. allowed number of dupes per device */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|comhandles_tag
block|{
name|uint16_t
name|unit
decl_stmt|;
comment|/* COMPORT number		*/
name|uint16_t
name|nhnd
decl_stmt|;
comment|/* number of open handles	*/
name|char
modifier|*
name|comName
decl_stmt|;
comment|/* windows device name		*/
name|DevCtx_t
modifier|*
name|devCtx
decl_stmt|;
comment|/* shared device context	*/
name|HANDLE
name|htab
index|[
name|MAX_COMDUP
index|]
decl_stmt|;
comment|/* OS handles	*/
block|}
name|comhandles
typedef|;
end_typedef

begin_decl_stmt
name|comhandles
modifier|*
modifier|*
name|tab_comh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device data table		*/
end_comment

begin_decl_stmt
name|size_t
name|num_comh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current used array size	*/
end_comment

begin_decl_stmt
name|size_t
name|max_comh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current allocated array size	*/
end_comment

begin_comment
comment|/* lookup a COM unit by a handle  * Scans all used units for a matching handle. Returns the slot  * or NULL on failure.  *  * If 'phidx' is given, the index in the slots handle table that  * holds the handle is also returned.  *  * This a simple 2d table scan. But since we don't expect to have  * hundreds of com ports open, this should be no problem.  */
end_comment

begin_function
specifier|static
name|comhandles
modifier|*
name|lookup_com_handle
parameter_list|(
name|HANDLE
name|h
parameter_list|,
name|size_t
modifier|*
name|phidx
parameter_list|)
block|{
name|size_t
name|tidx
decl_stmt|,
name|hidx
decl_stmt|;
name|comhandles
modifier|*
name|slot
decl_stmt|;
for|for
control|(
name|tidx
operator|=
literal|0
init|;
name|tidx
operator|<
name|num_comh
condition|;
operator|++
name|tidx
control|)
block|{
name|slot
operator|=
name|tab_comh
index|[
name|tidx
index|]
expr_stmt|;
for|for
control|(
name|hidx
operator|=
literal|0
init|;
name|hidx
operator|<
name|slot
operator|->
name|nhnd
condition|;
operator|++
name|hidx
control|)
block|{
if|if
condition|(
name|slot
operator|->
name|htab
index|[
name|hidx
index|]
operator|==
name|h
condition|)
block|{
if|if
condition|(
name|phidx
operator|!=
name|NULL
condition|)
operator|*
name|phidx
operator|=
name|hidx
expr_stmt|;
return|return
name|slot
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* lookup the list of COM units by unit number. This will always return  * a valid location -- eventually the table gets expanded, and a new  * entry is returned. In that case, the structure is set up with all  * entries valid and *no* file handles yet.  */
end_comment

begin_function
specifier|static
name|comhandles
modifier|*
name|insert_com_unit
parameter_list|(
name|uint16_t
name|unit
parameter_list|)
block|{
name|size_t
name|tidx
decl_stmt|;
name|comhandles
modifier|*
name|slot
decl_stmt|;
comment|/* search for matching entry and return if found */
for|for
control|(
name|tidx
operator|=
literal|0
init|;
name|tidx
operator|<
name|num_comh
condition|;
operator|++
name|tidx
control|)
if|if
condition|(
name|tab_comh
index|[
name|tidx
index|]
operator|->
name|unit
operator|==
name|unit
condition|)
return|return
name|tab_comh
index|[
name|tidx
index|]
return|;
comment|/* search failed. make sure we can add a new slot */
if|if
condition|(
name|num_comh
operator|>=
name|max_comh
condition|)
block|{
comment|/* round up to next multiple of 4 */
name|max_comh
operator|=
operator|(
name|num_comh
operator|+
literal|4
operator|)
operator|&
operator|~
operator|(
name|size_t
operator|)
literal|3
expr_stmt|;
name|tab_comh
operator|=
name|erealloc
argument_list|(
name|tab_comh
argument_list|,
name|max_comh
operator|*
sizeof|sizeof
argument_list|(
name|tab_comh
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* create a new slot and populate it. */
name|slot
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
name|comhandles
argument_list|)
argument_list|)
expr_stmt|;
name|LIB_GETBUF
argument_list|(
name|slot
operator|->
name|comName
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|slot
operator|->
name|comName
argument_list|,
name|LIB_BUFLENGTH
argument_list|,
literal|"\\\\.\\COM%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|slot
operator|->
name|comName
operator|=
name|estrdup
argument_list|(
name|slot
operator|->
name|comName
argument_list|)
expr_stmt|;
name|slot
operator|->
name|devCtx
operator|=
name|DevCtxAlloc
argument_list|()
expr_stmt|;
name|slot
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
comment|/* plug it into table and return it */
name|tab_comh
index|[
name|num_comh
operator|++
index|]
operator|=
name|slot
expr_stmt|;
return|return
name|slot
return|;
block|}
end_function

begin_comment
comment|/* remove a COM slot from the table and destroy it. */
end_comment

begin_function
specifier|static
name|void
name|remove_com_slot
parameter_list|(
name|comhandles
modifier|*
name|slot
comment|/* must be valid! */
parameter_list|)
block|{
name|size_t
name|tidx
decl_stmt|;
for|for
control|(
name|tidx
operator|=
literal|0
init|;
name|tidx
operator|<
name|num_comh
condition|;
operator|++
name|tidx
control|)
if|if
condition|(
name|tab_comh
index|[
name|tidx
index|]
operator|==
name|slot
condition|)
block|{
name|tab_comh
index|[
name|tidx
index|]
operator|=
name|tab_comh
index|[
operator|--
name|num_comh
index|]
expr_stmt|;
break|break;
block|}
name|DevCtxDetach
argument_list|(
name|slot
operator|->
name|devCtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|slot
operator|->
name|comName
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fetch the stored device context block.  * This does NOT step the reference counter!  */
end_comment

begin_function
name|DevCtx_t
modifier|*
name|serial_devctx
parameter_list|(
name|HANDLE
name|h
parameter_list|)
block|{
name|comhandles
modifier|*
name|slot
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|INVALID_HANDLE_VALUE
operator|!=
name|h
operator|&&
name|NULL
operator|!=
name|h
condition|)
name|slot
operator|=
name|lookup_com_handle
argument_list|(
name|h
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|!=
name|slot
operator|)
condition|?
name|slot
operator|->
name|devCtx
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * common_serial_open ensures duplicate opens of the same port  * work by duplicating the handle for the 2nd open, allowing  * refclock_atom to share a GPS refclock's comm port.  */
end_comment

begin_function
name|HANDLE
name|common_serial_open
parameter_list|(
specifier|const
name|char
modifier|*
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|pwindev
parameter_list|)
block|{
name|HANDLE
name|handle
decl_stmt|;
name|size_t
name|unit
decl_stmt|;
specifier|const
name|char
modifier|*
name|pch
decl_stmt|;
name|comhandles
modifier|*
name|slot
decl_stmt|;
comment|/* 	 * This is odd, but we'll take any unix device path 	 * by looking for the initial '/' and strip off everything 	 * before the final digits, then translate that to COM__: 	 * maintaining backward compatibility with NTP practice of 	 * mapping unit 0 to the nonfunctional COM0: 	 * 	 * To ease the job of taking the windows COMx: device names 	 * out of reference clocks, we'll also work with those 	 * equanimously. 	 */
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"common_serial_open given %s\n"
operator|,
name|dev
operator|)
argument_list|)
expr_stmt|;
name|handle
operator|=
name|INVALID_HANDLE_VALUE
expr_stmt|;
name|pch
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
literal|'/'
operator|==
name|dev
index|[
literal|0
index|]
condition|)
block|{
name|pch
operator|=
name|dev
operator|+
name|strlen
argument_list|(
name|dev
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
name|pch
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|pch
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"common_serial_open skipped to ending digits leaving %s\n"
operator|,
name|pch
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|_strnicmp
argument_list|(
literal|"COM"
argument_list|,
name|dev
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|pch
operator|=
name|dev
operator|+
literal|3
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"common_serial_open skipped COM leaving %s\n"
operator|,
name|pch
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pch
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
name|pch
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"not a digit: %s\n"
operator|,
name|pch
condition|?
name|pch
else|:
literal|"[NULL]"
operator|)
argument_list|)
expr_stmt|;
return|return
name|INVALID_HANDLE_VALUE
return|;
block|}
name|unit
operator|=
name|strtoul
argument_list|(
name|pch
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|pch
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pch
operator|||
name|unit
operator|>
name|MAX_SERIAL
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"conversion failure: unit=%u at '%s'\n"
operator|,
name|pch
operator|)
argument_list|)
expr_stmt|;
return|return
name|INVALID_HANDLE_VALUE
return|;
block|}
comment|/* Now.... find the COM slot, and either create a new file 	 * (if there is no handle yet) or duplicate one of the existing 	 * handles. Unless the dup table for one com port would overflow, 	 * but that's an indication of a programming error somewhere. 	 */
name|slot
operator|=
name|insert_com_unit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|nhnd
operator|==
literal|0
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"windows device %s\n"
operator|,
name|slot
operator|->
name|comName
operator|)
argument_list|)
expr_stmt|;
name|slot
operator|->
name|htab
index|[
literal|0
index|]
operator|=
name|CreateFileA
argument_list|(
name|slot
operator|->
name|comName
argument_list|,
name|GENERIC_READ
operator||
name|GENERIC_WRITE
argument_list|,
literal|0
argument_list|,
comment|/* sharing prohibited */
name|NULL
argument_list|,
comment|/* default security */
name|OPEN_EXISTING
argument_list|,
name|FILE_ATTRIBUTE_NORMAL
operator||
name|FILE_FLAG_OVERLAPPED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_HANDLE_VALUE
operator|!=
name|slot
operator|->
name|htab
index|[
literal|0
index|]
condition|)
block|{
name|slot
operator|->
name|nhnd
operator|=
literal|1
expr_stmt|;
name|handle
operator|=
name|slot
operator|->
name|htab
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|pwindev
operator|=
name|slot
operator|->
name|comName
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|slot
operator|->
name|nhnd
operator|>=
name|MAX_COMDUP
condition|)
block|{
name|SetLastError
argument_list|(
name|ERROR_TOO_MANY_OPEN_FILES
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DuplicateHandle
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|slot
operator|->
name|htab
index|[
literal|0
index|]
argument_list|,
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|slot
operator|->
name|htab
index|[
name|slot
operator|->
name|nhnd
index|]
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
condition|)
block|{
name|handle
operator|=
name|slot
operator|->
name|htab
index|[
name|slot
operator|->
name|nhnd
operator|++
index|]
expr_stmt|;
operator|*
name|pwindev
operator|=
name|slot
operator|->
name|comName
expr_stmt|;
block|}
return|return
name|handle
return|;
block|}
end_function

begin_comment
comment|/*  * closeserial() is used in place of close by ntpd refclock I/O for ttys  */
end_comment

begin_function
name|int
name|closeserial
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|HANDLE
name|h
decl_stmt|;
name|size_t
name|hidx
decl_stmt|;
name|comhandles
modifier|*
name|slot
decl_stmt|;
name|h
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_HANDLE_VALUE
operator|==
name|h
condition|)
goto|goto
name|onerror
goto|;
name|slot
operator|=
name|lookup_com_handle
argument_list|(
name|h
argument_list|,
operator|&
name|hidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|slot
condition|)
goto|goto
name|onerror
goto|;
name|slot
operator|->
name|htab
index|[
name|hidx
index|]
operator|=
name|slot
operator|->
name|htab
index|[
operator|--
name|slot
operator|->
name|nhnd
index|]
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|nhnd
operator|==
literal|0
condition|)
name|remove_com_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
name|close
argument_list|(
name|fd
argument_list|)
return|;
comment|/* closes system handle, too! */
name|onerror
label|:
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * isserialhandle() -- check if a handle is a COM port handle  */
end_comment

begin_function
name|int
comment|/*BOOL*/
name|isserialhandle
parameter_list|(
name|HANDLE
name|h
parameter_list|)
block|{
if|if
condition|(
name|INVALID_HANDLE_VALUE
operator|!=
name|h
operator|&&
name|NULL
operator|!=
name|h
condition|)
return|return
name|lookup_com_handle
argument_list|(
name|h
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * tty_open - open serial port for refclock special uses  *  * This routine opens a serial port for and returns the   * file descriptor if success and -1 if failure.  */
end_comment

begin_function
name|int
name|tty_open
parameter_list|(
specifier|const
name|char
modifier|*
name|dev
parameter_list|,
comment|/* device name pointer */
name|int
name|access
parameter_list|,
comment|/* O_RDWR */
name|int
name|mode
comment|/* unused */
parameter_list|)
block|{
name|HANDLE
name|Handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|windev
decl_stmt|;
comment|/* 	 * open communication port handle 	 */
name|windev
operator|=
name|dev
expr_stmt|;
name|Handle
operator|=
name|common_serial_open
argument_list|(
name|dev
argument_list|,
operator|&
name|windev
argument_list|)
expr_stmt|;
if|if
condition|(
name|Handle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"tty_open: device %s CreateFile error: %m"
argument_list|,
name|windev
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EMFILE
expr_stmt|;
comment|/* lie, lacking conversion from GetLastError() */
return|return
operator|-
literal|1
return|;
block|}
return|return
name|_open_osfhandle
argument_list|(
operator|(
name|intptr_t
operator|)
name|Handle
argument_list|,
name|_O_TEXT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * refclock_open - open serial port for reference clock  *  * This routine opens a serial port for I/O and sets default options. It  * returns the file descriptor or -1 indicating failure.  */
end_comment

begin_function
name|int
name|refclock_open
parameter_list|(
specifier|const
name|char
modifier|*
name|dev
parameter_list|,
comment|/* device name pointer */
name|u_int
name|speed
parameter_list|,
comment|/* serial port speed (code) */
name|u_int
name|flags
comment|/* line discipline flags */
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|windev
decl_stmt|;
name|HANDLE
name|h
decl_stmt|;
name|COMMTIMEOUTS
name|timeouts
decl_stmt|;
name|DCB
name|dcb
decl_stmt|;
name|DWORD
name|dwEvtMask
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|translate
decl_stmt|;
comment|/* 	 * open communication port handle 	 */
name|windev
operator|=
name|dev
expr_stmt|;
name|h
operator|=
name|common_serial_open
argument_list|(
name|dev
argument_list|,
operator|&
name|windev
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_HANDLE_VALUE
operator|==
name|h
condition|)
block|{
name|SAVE_ERRNO
argument_list|(
argument|msyslog(LOG_ERR,
literal|"CreateFile(%s) error: %m"
argument|, 				windev);
argument_list|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Change the input/output buffers to be large. */
if|if
condition|(
operator|!
name|SetupComm
argument_list|(
name|h
argument_list|,
literal|1024
argument_list|,
literal|1024
argument_list|)
condition|)
block|{
name|SAVE_ERRNO
argument_list|(
argument|msyslog(LOG_ERR,
literal|"SetupComm(%s) error: %m"
argument|, 				windev);
argument_list|)
return|return
operator|-
literal|1
return|;
block|}
name|dcb
operator|.
name|DCBlength
operator|=
sizeof|sizeof
argument_list|(
name|dcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GetCommState
argument_list|(
name|h
argument_list|,
operator|&
name|dcb
argument_list|)
condition|)
block|{
name|SAVE_ERRNO
argument_list|(
argument|msyslog(LOG_ERR,
literal|"GetCommState(%s) error: %m"
argument|, 				windev);
argument_list|)
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|speed
condition|)
block|{
case|case
name|B300
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|300
expr_stmt|;
break|break;
case|case
name|B1200
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|1200
expr_stmt|;
break|break;
case|case
name|B2400
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|2400
expr_stmt|;
break|break;
case|case
name|B4800
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|4800
expr_stmt|;
break|break;
case|case
name|B9600
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|9600
expr_stmt|;
break|break;
case|case
name|B19200
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|19200
expr_stmt|;
break|break;
case|case
name|B38400
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|38400
expr_stmt|;
break|break;
case|case
name|B57600
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|57600
expr_stmt|;
break|break;
case|case
name|B115200
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|115200
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s unsupported bps code %u"
argument_list|,
name|windev
argument_list|,
name|speed
argument_list|)
expr_stmt|;
name|SetLastError
argument_list|(
name|ERROR_INVALID_PARAMETER
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dcb
operator|.
name|fBinary
operator|=
name|TRUE
expr_stmt|;
name|dcb
operator|.
name|fParity
operator|=
name|TRUE
expr_stmt|;
name|dcb
operator|.
name|fOutxCtsFlow
operator|=
literal|0
expr_stmt|;
name|dcb
operator|.
name|fOutxDsrFlow
operator|=
literal|0
expr_stmt|;
name|dcb
operator|.
name|fDtrControl
operator|=
name|DTR_CONTROL_ENABLE
expr_stmt|;
name|dcb
operator|.
name|fDsrSensitivity
operator|=
literal|0
expr_stmt|;
name|dcb
operator|.
name|fTXContinueOnXoff
operator|=
name|TRUE
expr_stmt|;
name|dcb
operator|.
name|fOutX
operator|=
literal|0
expr_stmt|;
name|dcb
operator|.
name|fInX
operator|=
literal|0
expr_stmt|;
name|dcb
operator|.
name|fErrorChar
operator|=
literal|0
expr_stmt|;
name|dcb
operator|.
name|fNull
operator|=
literal|0
expr_stmt|;
name|dcb
operator|.
name|fRtsControl
operator|=
name|RTS_CONTROL_DISABLE
expr_stmt|;
name|dcb
operator|.
name|fAbortOnError
operator|=
literal|0
expr_stmt|;
name|dcb
operator|.
name|ByteSize
operator|=
literal|8
expr_stmt|;
name|dcb
operator|.
name|StopBits
operator|=
name|ONESTOPBIT
expr_stmt|;
name|dcb
operator|.
name|Parity
operator|=
name|NOPARITY
expr_stmt|;
name|dcb
operator|.
name|ErrorChar
operator|=
literal|0
expr_stmt|;
name|dcb
operator|.
name|EofChar
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|LDISC_RAW
operator|&
name|flags
condition|)
name|dcb
operator|.
name|EvtChar
operator|=
literal|0
expr_stmt|;
else|else
name|dcb
operator|.
name|EvtChar
operator|=
literal|'\r'
expr_stmt|;
if|if
condition|(
operator|!
name|SetCommState
argument_list|(
name|h
argument_list|,
operator|&
name|dcb
argument_list|)
condition|)
block|{
name|SAVE_ERRNO
argument_list|(
argument|msyslog(LOG_ERR,
literal|"SetCommState(%s) error: %m"
argument|, 				windev);
argument_list|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* watch out for CR (dcb.EvtChar) as well as the CD line */
name|dwEvtMask
operator|=
name|EV_RLSD
expr_stmt|;
if|if
condition|(
name|LDISC_RAW
operator|&
name|flags
condition|)
name|dwEvtMask
operator||=
name|EV_RXCHAR
expr_stmt|;
else|else
name|dwEvtMask
operator||=
name|EV_RXFLAG
expr_stmt|;
if|if
condition|(
operator|!
name|SetCommMask
argument_list|(
name|h
argument_list|,
name|dwEvtMask
argument_list|)
condition|)
block|{
name|SAVE_ERRNO
argument_list|(
argument|msyslog(LOG_ERR,
literal|"SetCommMask(%s) error: %m"
argument|, 				windev);
argument_list|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* configure the handle to never block */
name|timeouts
operator|.
name|ReadIntervalTimeout
operator|=
name|MAXDWORD
expr_stmt|;
name|timeouts
operator|.
name|ReadTotalTimeoutMultiplier
operator|=
literal|0
expr_stmt|;
name|timeouts
operator|.
name|ReadTotalTimeoutConstant
operator|=
literal|0
expr_stmt|;
name|timeouts
operator|.
name|WriteTotalTimeoutMultiplier
operator|=
literal|0
expr_stmt|;
name|timeouts
operator|.
name|WriteTotalTimeoutConstant
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|SetCommTimeouts
argument_list|(
name|h
argument_list|,
operator|&
name|timeouts
argument_list|)
condition|)
block|{
name|SAVE_ERRNO
argument_list|(
argument|msyslog(LOG_ERR,
literal|"Device %s SetCommTimeouts error: %m"
argument|, 				windev);
argument_list|)
return|return
operator|-
literal|1
return|;
block|}
name|translate
operator|=
operator|(
name|LDISC_RAW
operator|&
name|flags
operator|)
condition|?
literal|0
else|:
name|_O_TEXT
expr_stmt|;
name|fd
operator|=
name|_open_osfhandle
argument_list|(
operator|(
name|intptr_t
operator|)
name|h
argument_list|,
name|translate
argument_list|)
expr_stmt|;
comment|/* refclock_open() long returned 0 on failure, avoid it. */
if|if
condition|(
literal|0
operator|==
name|fd
condition|)
block|{
name|fd
operator|=
name|_dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_function
name|int
name|ioctl_tiocmget
parameter_list|(
name|HANDLE
name|h
parameter_list|,
name|int
modifier|*
name|pi
parameter_list|)
block|{
name|DWORD
name|dw
decl_stmt|;
if|if
condition|(
operator|!
name|GetCommModemStatus
argument_list|(
name|h
argument_list|,
operator|&
name|dw
argument_list|)
condition|)
block|{
name|errno
operator|=
name|ENOTTY
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|pi
operator|=
operator|(
operator|(
name|dw
operator|&
name|MS_CTS_ON
operator|)
condition|?
name|TIOCM_CTS
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|dw
operator|&
name|MS_DSR_ON
operator|)
condition|?
name|TIOCM_DSR
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|dw
operator|&
name|MS_RLSD_ON
operator|)
condition|?
name|TIOCM_CAR
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|dw
operator|&
name|MS_RING_ON
operator|)
condition|?
name|TIOCM_RI
else|:
literal|0
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ioctl_tiocmset
parameter_list|(
name|HANDLE
name|h
parameter_list|,
name|int
modifier|*
name|pi
parameter_list|)
block|{
name|BOOL
name|failed
decl_stmt|;
name|int
name|result
decl_stmt|;
name|failed
operator|=
operator|!
name|EscapeCommFunction
argument_list|(
name|h
argument_list|,
operator|(
operator|*
name|pi
operator|&
name|TIOCM_RTS
operator|)
condition|?
name|SETRTS
else|:
name|CLRRTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|failed
condition|)
name|failed
operator|=
operator|!
name|EscapeCommFunction
argument_list|(
name|h
argument_list|,
operator|(
operator|*
name|pi
operator|&
name|TIOCM_DTR
operator|)
condition|?
name|SETDTR
else|:
name|CLRDTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
block|{
name|errno
operator|=
name|ENOTTY
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|result
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|ioctl
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|op
parameter_list|,
name|void
modifier|*
name|pv
parameter_list|)
block|{
name|HANDLE
name|h
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|modctl
decl_stmt|;
name|int
modifier|*
name|pi
init|=
operator|(
name|int
operator|*
operator|)
name|pv
decl_stmt|;
name|h
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_HANDLE_VALUE
operator|==
name|h
condition|)
block|{
comment|/* errno already set */
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|TIOCMGET
case|:
name|result
operator|=
name|ioctl_tiocmget
argument_list|(
name|h
argument_list|,
name|pi
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSET
case|:
name|result
operator|=
name|ioctl_tiocmset
argument_list|(
name|h
argument_list|,
name|pi
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIC
case|:
name|result
operator|=
name|ioctl_tiocmget
argument_list|(
name|h
argument_list|,
operator|&
name|modctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
return|return
name|result
return|;
name|modctl
operator|&=
operator|~
operator|(
operator|*
name|pi
operator|)
expr_stmt|;
name|result
operator|=
name|ioctl_tiocmset
argument_list|(
name|h
argument_list|,
operator|&
name|modctl
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIS
case|:
name|result
operator|=
name|ioctl_tiocmget
argument_list|(
name|h
argument_list|,
operator|&
name|modctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
return|return
name|result
return|;
name|modctl
operator||=
operator|*
name|pi
expr_stmt|;
name|result
operator|=
name|ioctl_tiocmset
argument_list|(
name|h
argument_list|,
operator|&
name|modctl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errno
operator|=
name|EINVAL
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|tcsetattr
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|optional_actions
parameter_list|,
specifier|const
name|struct
name|termios
modifier|*
name|tios
parameter_list|)
block|{
name|DCB
name|dcb
decl_stmt|;
name|HANDLE
name|h
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|optional_actions
argument_list|)
expr_stmt|;
name|h
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_HANDLE_VALUE
operator|==
name|h
condition|)
block|{
comment|/* errno already set */
return|return
operator|-
literal|1
return|;
block|}
name|dcb
operator|.
name|DCBlength
operator|=
sizeof|sizeof
argument_list|(
name|dcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GetCommState
argument_list|(
name|h
argument_list|,
operator|&
name|dcb
argument_list|)
condition|)
block|{
name|errno
operator|=
name|ENOTTY
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|max
argument_list|(
name|tios
operator|->
name|c_ospeed
argument_list|,
name|tios
operator|->
name|c_ispeed
argument_list|)
condition|)
block|{
case|case
name|B300
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|300
expr_stmt|;
break|break;
case|case
name|B1200
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|1200
expr_stmt|;
break|break;
case|case
name|B2400
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|2400
expr_stmt|;
break|break;
case|case
name|B4800
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|4800
expr_stmt|;
break|break;
case|case
name|B9600
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|9600
expr_stmt|;
break|break;
case|case
name|B19200
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|19200
expr_stmt|;
break|break;
case|case
name|B38400
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|38400
expr_stmt|;
break|break;
case|case
name|B57600
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|57600
expr_stmt|;
break|break;
case|case
name|B115200
case|:
name|dcb
operator|.
name|BaudRate
operator|=
literal|115200
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unsupported serial baud rate"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|tios
operator|->
name|c_cflag
operator|&
name|CSIZE
condition|)
block|{
case|case
name|CS5
case|:
name|dcb
operator|.
name|ByteSize
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|CS6
case|:
name|dcb
operator|.
name|ByteSize
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|dcb
operator|.
name|ByteSize
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|CS8
case|:
name|dcb
operator|.
name|ByteSize
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unsupported serial word size"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|PARENB
operator|&
name|tios
operator|->
name|c_cflag
condition|)
block|{
name|dcb
operator|.
name|fParity
operator|=
name|TRUE
expr_stmt|;
name|dcb
operator|.
name|Parity
operator|=
operator|(
name|tios
operator|->
name|c_cflag
operator|&
name|PARODD
operator|)
condition|?
name|ODDPARITY
else|:
name|EVENPARITY
expr_stmt|;
block|}
else|else
block|{
name|dcb
operator|.
name|fParity
operator|=
name|FALSE
expr_stmt|;
name|dcb
operator|.
name|Parity
operator|=
name|NOPARITY
expr_stmt|;
block|}
name|dcb
operator|.
name|StopBits
operator|=
operator|(
name|CSTOPB
operator|&
name|tios
operator|->
name|c_cflag
operator|)
condition|?
name|TWOSTOPBITS
else|:
name|ONESTOPBIT
expr_stmt|;
if|if
condition|(
operator|!
name|SetCommState
argument_list|(
name|h
argument_list|,
operator|&
name|dcb
argument_list|)
condition|)
block|{
name|errno
operator|=
name|ENOTTY
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tcgetattr
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|termios
modifier|*
name|tios
parameter_list|)
block|{
name|DCB
name|dcb
decl_stmt|;
name|HANDLE
name|h
decl_stmt|;
name|h
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_HANDLE_VALUE
operator|==
name|h
condition|)
block|{
comment|/* errno already set */
return|return
operator|-
literal|1
return|;
block|}
name|dcb
operator|.
name|DCBlength
operator|=
sizeof|sizeof
argument_list|(
name|dcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GetCommState
argument_list|(
name|h
argument_list|,
operator|&
name|dcb
argument_list|)
condition|)
block|{
name|errno
operator|=
name|ENOTTY
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*  Set c_ispeed& c_ospeed */
switch|switch
condition|(
name|dcb
operator|.
name|BaudRate
condition|)
block|{
case|case
literal|300
case|:
name|tios
operator|->
name|c_ispeed
operator|=
name|tios
operator|->
name|c_ospeed
operator|=
name|B300
expr_stmt|;
break|break;
case|case
literal|1200
case|:
name|tios
operator|->
name|c_ispeed
operator|=
name|tios
operator|->
name|c_ospeed
operator|=
name|B1200
expr_stmt|;
break|break;
case|case
literal|2400
case|:
name|tios
operator|->
name|c_ispeed
operator|=
name|tios
operator|->
name|c_ospeed
operator|=
name|B2400
expr_stmt|;
break|break;
case|case
literal|4800
case|:
name|tios
operator|->
name|c_ispeed
operator|=
name|tios
operator|->
name|c_ospeed
operator|=
name|B4800
expr_stmt|;
break|break;
case|case
literal|9600
case|:
name|tios
operator|->
name|c_ispeed
operator|=
name|tios
operator|->
name|c_ospeed
operator|=
name|B9600
expr_stmt|;
break|break;
case|case
literal|19200
case|:
name|tios
operator|->
name|c_ispeed
operator|=
name|tios
operator|->
name|c_ospeed
operator|=
name|B19200
expr_stmt|;
break|break;
case|case
literal|38400
case|:
name|tios
operator|->
name|c_ispeed
operator|=
name|tios
operator|->
name|c_ospeed
operator|=
name|B38400
expr_stmt|;
break|break;
case|case
literal|57600
case|:
name|tios
operator|->
name|c_ispeed
operator|=
name|tios
operator|->
name|c_ospeed
operator|=
name|B57600
expr_stmt|;
break|break;
case|case
literal|115200
case|:
name|tios
operator|->
name|c_ispeed
operator|=
name|tios
operator|->
name|c_ospeed
operator|=
name|B115200
expr_stmt|;
break|break;
default|default:
name|tios
operator|->
name|c_ispeed
operator|=
name|tios
operator|->
name|c_ospeed
operator|=
name|B9600
expr_stmt|;
block|}
switch|switch
condition|(
name|dcb
operator|.
name|ByteSize
condition|)
block|{
case|case
literal|5
case|:
name|tios
operator|->
name|c_cflag
operator|=
name|CS5
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|tios
operator|->
name|c_cflag
operator|=
name|CS6
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|tios
operator|->
name|c_cflag
operator|=
name|CS7
expr_stmt|;
break|break;
case|case
literal|8
case|:
default|default:
name|tios
operator|->
name|c_cflag
operator|=
name|CS8
expr_stmt|;
block|}
if|if
condition|(
name|dcb
operator|.
name|fParity
condition|)
block|{
name|tios
operator|->
name|c_cflag
operator||=
name|PARENB
expr_stmt|;
if|if
condition|(
name|ODDPARITY
operator|==
name|dcb
operator|.
name|Parity
condition|)
name|tios
operator|->
name|c_cflag
operator||=
name|PARODD
expr_stmt|;
block|}
if|if
condition|(
name|TWOSTOPBITS
operator|==
name|dcb
operator|.
name|StopBits
condition|)
name|tios
operator|->
name|c_cflag
operator||=
name|CSTOPB
expr_stmt|;
name|tios
operator|->
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|tios
operator|->
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|tios
operator|->
name|c_line
operator|=
literal|0
expr_stmt|;
name|tios
operator|->
name|c_oflag
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tcflush
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|HANDLE
name|h
decl_stmt|;
name|BOOL
name|success
decl_stmt|;
name|DWORD
name|flags
decl_stmt|;
name|int
name|result
decl_stmt|;
name|h
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|INVALID_HANDLE_VALUE
operator|==
name|h
condition|)
block|{
comment|/* errno already set */
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|TCIFLUSH
case|:
name|flags
operator|=
name|PURGE_RXCLEAR
expr_stmt|;
break|break;
case|case
name|TCOFLUSH
case|:
name|flags
operator|=
name|PURGE_TXABORT
expr_stmt|;
break|break;
case|case
name|TCIOFLUSH
case|:
name|flags
operator|=
name|PURGE_RXCLEAR
operator||
name|PURGE_TXABORT
expr_stmt|;
break|break;
default|default:
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|success
operator|=
name|PurgeComm
argument_list|(
name|h
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|errno
operator|=
name|ENOTTY
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

end_unit

