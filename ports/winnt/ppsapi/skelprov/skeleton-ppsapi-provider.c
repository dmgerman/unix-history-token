begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * skeleton-ppsapi-provider.c - structure but no useful function  */
end_comment

begin_comment
comment|/***********************************************************************  *								       *  * Copyright (c) David L. Mills 1999-2009			       *  *								       *  * Permission to use, copy, modify, and distribute this software and   *  * its documentation for any purpose and without fee is hereby	       *  * granted, provided that the above copyright notice appears in all    *  * copies and that both the copyright notice and this permission       *  * notice appear in supporting documentation, and that the name        *  * University of Delaware not be used in advertising or publicity      *  * pertaining to distribution of the software without specific,        *  * written prior permission. The University of Delaware makes no       *  * representations about the suitability this software for any	       *  * purpose. It is provided "as is" without express or implied          *  * warranty.							       *  *								       *  ***********************************************************************  *								       *  * This header file complies with "Pulse-Per-Second API for UNIX-like  *  * Operating Systems, Version 1.0", rfc2783. Credit is due Jeff Mogul  *  * and Marc Brett, from whom much of this code was shamelessly stolen. *  *								       *  * This skeleton-ppsapi-provider.c implements the PPSAPI provider DLL  *  * interface but has no actual timestamp-fetching code.  It is	       *  * derived from serialpps-ppsapi-provider.c which was derived from     *  * David L. Mills' timepps.h for Solaris.			       *  *								       *  ***********************************************************************  *								       *  * Some of this include file					       *  * Copyright (c) 1999 by Ulrich Windl,				       *  *	based on code by Reg Clemens<reg@dwf.com>		       *  *		based on code by Poul-Henning Kamp<phk@FreeBSD.org>   *  *								       *  ***********************************************************************  *								       *  * "THE BEER-WARE LICENSE" (Revision 42):			       *  *<phk@FreeBSD.org> wrote this file.  As long as you retain this      *  * notice you can do whatever you want with this stuff. If we meet some*  * day, and you think this stuff is worth it, you can buy me a beer    *  * in return.	Poul-Henning Kamp				       *  *								       *  **********************************************************************/
end_comment

begin_include
include|#
directive|include
file|"skeleton-ppsapi-provider.h"
end_include

begin_decl_stmt
name|pcreate_pps_handle
name|p_create_pps_handle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ppps_ntp_timestamp_from_counter
name|p_ntp_timestamp_from_counter
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SKELPPS_CAPS
value|(PPS_CAPTUREASSERT | PPS_OFFSETASSERT	\ 			 | PPS_TSFMT_TSPEC | PPS_TSFMT_NTPFP)
end_define

begin_define
define|#
directive|define
name|SKELPPS_RO
value|(PPS_CANWAIT | PPS_CANPOLL)
end_define

begin_comment
comment|/*  * The ntp_timestamp_from_counter callback into timepps.h routines in  * the host is saved in each unit separately, so that binaries that  * inline timepps.h into multiple source files (such as refclock_atom.c  * and a number of other ntpd refclocks including refclock_nmea.c) will  * get called back in the correct instance for each unit.  This assumes   * that ppsapi_prov_init for subsequent instances happens only after the  * first instance has completed all time_pps_create() calls it will  * invoke, which is a safe assumption at least for ntpd.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|skel_unit_tag
block|{
name|HANDLE
name|device
decl_stmt|;
name|ppps_ntp_timestamp_from_counter
name|p_ntp_timestamp_from_counter
decl_stmt|;
block|}
name|skel_unit
typedef|;
end_typedef

begin_comment
comment|/*  * DllMain - DLL entrypoint, no-op.  */
end_comment

begin_function
name|BOOL
name|APIENTRY
name|DllMain
parameter_list|(
name|HMODULE
name|hModule
parameter_list|,
name|DWORD
name|ul_reason_for_call
parameter_list|,
name|LPVOID
name|lpReserved
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|hModule
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|ul_reason_for_call
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|lpReserved
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * prov_time_pps_create - create PPS handle given underlying device  */
end_comment

begin_function
name|int
name|WINAPI
name|prov_time_pps_create
parameter_list|(
name|HANDLE
name|device
parameter_list|,
comment|/* underlying device */
name|pps_handle_t
modifier|*
name|handle
comment|/* returned handle */
parameter_list|)
block|{
name|skel_unit
modifier|*
name|pskelunit
decl_stmt|;
name|pps_unit_t
modifier|*
name|punit
decl_stmt|;
comment|/* 	 * Allocate and initialize unit structure. 	 */
name|pskelunit
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pskelunit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pskelunit
condition|)
return|return
name|ENOMEM
return|;
name|pskelunit
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|pskelunit
operator|->
name|p_ntp_timestamp_from_counter
operator|=
name|p_ntp_timestamp_from_counter
expr_stmt|;
operator|*
name|handle
operator|=
call|(
modifier|*
name|p_create_pps_handle
call|)
argument_list|(
name|pskelunit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|handle
condition|)
block|{
name|punit
operator|=
operator|(
name|pps_unit_t
operator|*
operator|)
operator|*
name|handle
expr_stmt|;
name|punit
operator|->
name|params
operator|.
name|api_version
operator|=
name|PPS_API_VERS_1
expr_stmt|;
name|punit
operator|->
name|params
operator|.
name|mode
operator|=
name|PPS_CAPTUREASSERT
operator||
name|PPS_TSFMT_TSPEC
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|handle
operator|)
condition|?
literal|0
else|:
name|ENOMEM
return|;
block|}
end_function

begin_comment
comment|/*  * prov_time_pps_destroy - release PPS handle  */
end_comment

begin_function
name|int
name|WINAPI
name|prov_time_pps_destroy
parameter_list|(
name|pps_unit_t
modifier|*
name|unit
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|skel_unit
modifier|*
name|pskelunit
decl_stmt|;
name|UNUSED
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|pskelunit
operator|=
name|context
expr_stmt|;
name|free
argument_list|(
name|pskelunit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * prov_time_pps_setparams - set parameters for handle  */
end_comment

begin_function
name|int
name|WINAPI
name|prov_time_pps_setparams
parameter_list|(
name|pps_unit_t
modifier|*
name|unit
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
specifier|const
name|pps_params_t
modifier|*
name|params
parameter_list|)
block|{
name|skel_unit
modifier|*
name|pskelunit
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|mode_in
decl_stmt|;
name|pskelunit
operator|=
name|context
expr_stmt|;
comment|/* 	 * There was no reasonable consensus in the API working group. 	 * I require `api_version' to be set! 	 */
if|if
condition|(
name|params
operator|->
name|api_version
operator|!=
name|PPS_API_VERS_1
condition|)
return|return
name|EINVAL
return|;
comment|/* 	 * The only settable modes are PPS_CAPTUREASSERT, 	 * PPS_OFFSETASSERT, and the timestamp formats. 	 */
name|mode_in
operator|=
name|params
operator|->
name|mode
expr_stmt|;
comment|/* 	 * Only one of the time formats may be selected 	 * if a nonzero assert offset is supplied. 	 */
if|if
condition|(
operator|(
name|mode_in
operator|&
operator|(
name|PPS_TSFMT_TSPEC
operator||
name|PPS_TSFMT_NTPFP
operator|)
operator|)
operator|==
operator|(
name|PPS_TSFMT_TSPEC
operator||
name|PPS_TSFMT_NTPFP
operator|)
condition|)
block|{
if|if
condition|(
name|params
operator|->
name|assert_offset
operator|.
name|tv_sec
operator|||
name|params
operator|->
name|assert_offset
operator|.
name|tv_nsec
condition|)
return|return
name|EINVAL
return|;
comment|/* 		 * If no offset was specified but both time 		 * format flags are used consider it harmless 		 * but turn off PPS_TSFMT_NTPFP so getparams 		 * will not show both formats lit. 		 */
name|mode_in
operator|&=
operator|~
name|PPS_TSFMT_NTPFP
expr_stmt|;
block|}
comment|/* turn off read-only bits */
name|mode_in
operator|&=
operator|~
name|SKELPPS_RO
expr_stmt|;
comment|/* 	 * test remaining bits, should only have captureassert,  	 * offsetassert, and/or timestamp format bits. 	 */
if|if
condition|(
name|mode_in
operator|&
operator|~
operator|(
name|PPS_CAPTUREASSERT
operator||
name|PPS_OFFSETASSERT
operator||
name|PPS_TSFMT_TSPEC
operator||
name|PPS_TSFMT_NTPFP
operator|)
condition|)
return|return
name|EOPNOTSUPP
return|;
comment|/* 	 * ok, ready to go. 	 */
name|mode
operator|=
name|unit
operator|->
name|params
operator|.
name|mode
expr_stmt|;
name|unit
operator|->
name|params
operator|=
operator|*
name|params
expr_stmt|;
name|unit
operator|->
name|params
operator|.
name|mode
operator|=
name|mode
operator||
name|mode_in
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * prov_time_pps_fetch - Fetch timestamps  */
end_comment

begin_function
name|int
name|WINAPI
name|prov_time_pps_fetch
parameter_list|(
name|pps_unit_t
modifier|*
name|unit
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
specifier|const
name|int
name|tsformat
parameter_list|,
name|pps_info_t
modifier|*
name|pinfo
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|ULONGLONG
name|WindowsTimestamp
decl_stmt|;
name|ULONGLONG
name|Counterstamp
decl_stmt|;
name|skel_unit
modifier|*
name|pskelunit
decl_stmt|;
name|pps_info_t
name|infobuf
decl_stmt|;
comment|/* 	 * nb. PPS_CANWAIT is NOT set by the implementation, we can totally 	 * ignore the timeout variable. 	 */
name|UNUSED
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|pskelunit
operator|=
name|context
expr_stmt|;
name|memset
argument_list|(
operator|&
name|infobuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|infobuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * if not captureassert, nothing to return. 	 */
if|if
condition|(
operator|!
operator|(
name|unit
operator|->
name|params
operator|.
name|mode
operator|&
name|PPS_CAPTUREASSERT
operator|)
condition|)
block|{
operator|*
name|pinfo
operator|=
name|infobuf
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * ADD CODE to retrieve timestamp here. 	 */
name|WindowsTimestamp
operator|=
name|Counterstamp
operator|=
literal|0
expr_stmt|;
comment|/* 	 * ADD CODE to retrieve timestamp here. 	 */
comment|/* 	 * pps_ntp_timestamp_from_counter takes the two flavors 	 * of timestamp we have (counter and system time) and 	 * uses whichever it can to give the best NTP fixed-point 	 * conversion.  In ntpd the Counterstamp is typically 	 * used.  A stub implementation in timepps.h simply 	 * converts from Windows timestamp to NTP fixed-point. 	 * We call through a pointer to get ntpd's version. 	 */
call|(
modifier|*
name|pskelunit
operator|->
name|p_ntp_timestamp_from_counter
call|)
argument_list|(
operator|&
name|infobuf
operator|.
name|assert_timestamp_ntpfp
argument_list|,
name|WindowsTimestamp
argument_list|,
name|Counterstamp
argument_list|)
expr_stmt|;
comment|/* 	 * Note that only assert timestamps 	 * are captured by this interface. 	 */
name|infobuf
operator|.
name|assert_sequence
operator|=
literal|0
expr_stmt|;
comment|/* ADD CODE */
comment|/* 	 * Apply offset and translate to specified format 	 */
switch|switch
condition|(
name|tsformat
condition|)
block|{
case|case
name|PPS_TSFMT_NTPFP
case|:
comment|/* NTP format requires no translation */
if|if
condition|(
name|unit
operator|->
name|params
operator|.
name|mode
operator|&
name|PPS_OFFSETASSERT
condition|)
block|{
name|NTPFP_L_ADDS
argument_list|(
operator|&
name|infobuf
operator|.
name|assert_timestamp_ntpfp
argument_list|,
operator|&
name|unit
operator|->
name|params
operator|.
name|assert_offset_ntpfp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PPS_TSFMT_TSPEC
case|:
comment|/* timespec format requires conversion to nsecs form */
name|PPS_NTPTOTSPEC
argument_list|(
name|infobuf
operator|.
name|assert_timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|params
operator|.
name|mode
operator|&
name|PPS_OFFSETASSERT
condition|)
block|{
name|infobuf
operator|.
name|assert_timestamp
operator|.
name|tv_sec
operator|+=
name|unit
operator|->
name|params
operator|.
name|assert_offset
operator|.
name|tv_sec
expr_stmt|;
name|infobuf
operator|.
name|assert_timestamp
operator|.
name|tv_nsec
operator|+=
name|unit
operator|->
name|params
operator|.
name|assert_offset
operator|.
name|tv_nsec
expr_stmt|;
name|PPS_NORMALIZE
argument_list|(
name|infobuf
operator|.
name|assert_timestamp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
name|infobuf
operator|.
name|current_mode
operator|=
name|unit
operator|->
name|params
operator|.
name|mode
expr_stmt|;
operator|*
name|pinfo
operator|=
name|infobuf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * prov_time_pps_kcbind - specify kernel consumer  *  * Not supported so far by Windows.  */
end_comment

begin_function
name|int
name|WINAPI
name|prov_time_pps_kcbind
parameter_list|(
name|pps_unit_t
modifier|*
name|punit
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
specifier|const
name|int
name|kernel_consumer
parameter_list|,
specifier|const
name|int
name|edge
parameter_list|,
specifier|const
name|int
name|tsformat
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|punit
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|kernel_consumer
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|tsformat
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_comment
comment|/*  * prov_init - returns capabilities and provider name  */
end_comment

begin_function
name|int
name|WINAPI
name|ppsapi_prov_init
parameter_list|(
name|int
name|ppsapi_timepps_prov_ver
parameter_list|,
name|pcreate_pps_handle
name|create_pps_handle
parameter_list|,
name|ppps_ntp_timestamp_from_counter
name|ntp_timestamp_from_counter
parameter_list|,
name|char
modifier|*
name|short_name_buf
parameter_list|,
name|size_t
name|short_name_size
parameter_list|,
name|char
modifier|*
name|full_name_buf
parameter_list|,
name|size_t
name|full_name_size
parameter_list|)
block|{
name|ppsapi_provider
name|test_prov
decl_stmt|;
if|if
condition|(
name|ppsapi_timepps_prov_ver
operator|<
name|PPSAPI_TIMEPPS_PROV_VER
condition|)
return|return
literal|0
return|;
name|p_create_pps_handle
operator|=
name|create_pps_handle
expr_stmt|;
name|p_ntp_timestamp_from_counter
operator|=
name|ntp_timestamp_from_counter
expr_stmt|;
name|strncpy
argument_list|(
name|short_name_buf
argument_list|,
literal|"skeleton"
argument_list|,
name|short_name_size
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|full_name_buf
argument_list|,
literal|"skeleton, ADD CODE to make useful"
argument_list|,
name|full_name_size
argument_list|)
expr_stmt|;
comment|/* 	 * Use function pointer prototypes from timepps.h to verify 	 * our prototypes match with some otherwise pointless code. 	 */
name|test_prov
operator|.
name|ptime_pps_create
operator|=
operator|&
name|prov_time_pps_create
expr_stmt|;
name|test_prov
operator|.
name|ptime_pps_destroy
operator|=
operator|&
name|prov_time_pps_destroy
expr_stmt|;
name|test_prov
operator|.
name|ptime_pps_fetch
operator|=
operator|&
name|prov_time_pps_fetch
expr_stmt|;
name|test_prov
operator|.
name|ptime_pps_kcbind
operator|=
operator|&
name|prov_time_pps_kcbind
expr_stmt|;
name|test_prov
operator|.
name|ptime_pps_setparams
operator|=
operator|&
name|prov_time_pps_setparams
expr_stmt|;
return|return
name|SKELPPS_CAPS
return|;
block|}
end_function

end_unit

