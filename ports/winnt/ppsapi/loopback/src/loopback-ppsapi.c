begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * loopback-ppsapi-provider.c - derived from monolithic timepps.h  *				 for usermode PPS by Juergen Perlinger  */
end_comment

begin_comment
comment|/***********************************************************************  *								       *  * Copyright (c) David L. Mills 1999-2009			       *  *								       *  * Permission to use, copy, modify, and distribute this software and   *  * its documentation for any purpose and without fee is hereby	       *  * granted, provided that the above copyright notice appears in all    *  * copies and that both the copyright notice and this permission       *  * notice appear in supporting documentation, and that the name        *  * University of Delaware not be used in advertising or publicity      *  * pertaining to distribution of the software without specific,        *  * written prior permission. The University of Delaware makes no       *  * representations about the suitability this software for any	       *  * purpose. It is provided "as is" without express or implied          *  * warranty.							       *  *								       *  ***********************************************************************  *								       *  * This header file complies with "Pulse-Per-Second API for UNIX-like  *  * Operating Systems, Version 1.0", rfc2783. Credit is due Jeff Mogul  *  * and Marc Brett, from whom much of this code was shamelessly stolen. *  *								       *  * This serialpps-ppsapi-provider.dll implements the PPSAPI provider   *  * for serialpps.sys, which is a very lightly patched Windows	       *  * serial.sys with CD timestamping support.  *								       *  * This Windows version was derived by Dave Hart		       *  *<davehart@davehart.com> from David L. Mills' timepps-Solaris.h      *  *								       *  ***********************************************************************  *								       *  * Some of this include file					       *  * Copyright (c) 1999 by Ulrich Windl,				       *  *	based on code by Reg Clemens<reg@dwf.com>		       *  *		based on code by Poul-Henning Kamp<phk@FreeBSD.org>   *  *								       *  ***********************************************************************  *								       *  * "THE BEER-WARE LICENSE" (Revision 42):			       *  *<phk@FreeBSD.org> wrote this file.  As long as you retain this      *  * notice you can do whatever you want with this stuff. If we meet some*  * day, and you think this stuff is worth it, you can buy me a beer    *  * in return.	Poul-Henning Kamp				       *  *								       *  **********************************************************************/
end_comment

begin_comment
comment|/*  * Implementation note: the logical states ``assert'' and ``clear''  * are implemented in terms of the UART register, i.e. ``assert''  * means the bit is set. This follows the sense of the serial driver  * of the Windows OS, and is opposite of the RS-232 spec for the  * CD/DCD logical state.  */
end_comment

begin_define
define|#
directive|define
name|PPSAPI_PROVIDER_EXPORTS
end_define

begin_include
include|#
directive|include
file|"loopback-ppsapi.h"
end_include

begin_comment
comment|/* ** global stuff */
end_comment

begin_decl_stmt
name|pcreate_pps_handle
name|p_create_pps_handle
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SERIALPPS_CAPS
value|(PPS_CAPTUREBOTH | PPS_OFFSETBOTH | PPS_TSFMT_BOTH)
end_define

begin_define
define|#
directive|define
name|SERIALPPS_RO
value|(PPS_CANWAIT | PPS_CANPOLL)
end_define

begin_comment
comment|/*  * The ntp_timestamp_from_counter callback into timepps.h routines in  * the host is saved in each unit separately, so that binaries that  * inline timepps.h into multiple source files (such as refclock_atom.c  * and a number of other ntpd refclocks including refclock_nmea.c) will  * get called back in the correct instance for each unit.  This assumes   * that ppsapi_prov_init for subsequent instances happens only after the  * first instance has completed all time_pps_create() calls it will  * invoke, which is a safe assumption at least for ntpd.  */
end_comment

begin_struct
struct|struct
name|loopback_unit
block|{
name|HANDLE
name|hnd_dev
decl_stmt|;
comment|/* true device handle	*/
name|HANDLE
name|hnd_pps
decl_stmt|;
comment|/* loopback handle	*/
name|ntp_fp_t
name|ofs_assert
decl_stmt|;
comment|/* correction for assert*/
name|ntp_fp_t
name|ofs_clear
decl_stmt|;
comment|/* correction for clear */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|loopback_unit
name|loopback_unit
typedef|;
end_typedef

begin_comment
comment|/*  * --------------------------------------------------------------------  * DllMain - DLL entrypoint, no-op.  * --------------------------------------------------------------------  */
end_comment

begin_function
name|BOOL
name|APIENTRY
name|DllMain
parameter_list|(
name|HMODULE
name|hModule
parameter_list|,
name|DWORD
name|why
parameter_list|,
name|LPVOID
name|lpReserved
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|hModule
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|lpReserved
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|why
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * --------------------------------------------------------------------  * time conversion and other helpers  * --------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------  * convert fixed point time stamp to struct timespec, with proper  * Epoch/Era unfolding around the current time.  */
end_comment

begin_function
specifier|static
name|struct
name|timespec
name|fp_stamp_to_tspec
parameter_list|(
name|ntp_fp_t
name|x
parameter_list|,
name|time_t
name|p
parameter_list|)
block|{
name|struct
name|timespec
name|out
decl_stmt|;
name|u_int64
name|tmp
decl_stmt|;
name|u_int32
name|ntp
decl_stmt|;
name|ntp
operator|=
name|x
operator|.
name|I
operator|.
name|u
expr_stmt|;
name|tmp
operator|=
name|p
expr_stmt|;
name|tmp
operator|-=
literal|0x80000000u
expr_stmt|;
comment|/* unshift of half range */
name|ntp
operator|-=
operator|(
name|u_int32
operator|)
name|PPS_JAN_1970
expr_stmt|;
comment|/* warp into UN*X domain */
name|ntp
operator|-=
operator|(
name|u_int32
operator|)
name|tmp
expr_stmt|;
comment|/* cycle difference	 */
name|tmp
operator|+=
operator|(
name|u_int64
operator|)
name|ntp
expr_stmt|;
comment|/* get expanded time	 */
name|out
operator|.
name|tv_sec
operator|=
operator|(
name|time_t
operator|)
name|tmp
expr_stmt|;
name|out
operator|.
name|tv_nsec
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|u_int64
operator|)
name|x
operator|.
name|F
operator|.
name|u
operator|*
name|PPS_NANOSECOND
operator|+
literal|0x80000000u
operator|)
operator|>>
literal|32
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|out
operator|.
name|tv_nsec
operator|>=
name|PPS_NANOSECOND
condition|)
block|{
name|out
operator|.
name|tv_nsec
operator|-=
name|PPS_NANOSECOND
expr_stmt|;
name|out
operator|.
name|tv_sec
operator|++
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * convert a duration in struct timespec format to  * fixed point representation.  */
end_comment

begin_function
specifier|static
name|ntp_fp_t
name|tspec_to_fp
parameter_list|(
specifier|const
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|ntp_fp_t
name|out
decl_stmt|;
name|long
name|tmp
decl_stmt|;
name|out
operator|.
name|I
operator|.
name|u
operator|=
operator|(
name|u_int32
operator|)
name|ts
operator|->
name|tv_sec
expr_stmt|;
name|tmp
operator|=
name|ts
operator|->
name|tv_nsec
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|0
condition|)
do|do
block|{
name|tmp
operator|+=
name|PPS_NANOSECOND
expr_stmt|;
name|out
operator|.
name|I
operator|.
name|u
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|tmp
operator|<
literal|0
condition|)
do|;
elseif|else
if|if
condition|(
name|tmp
operator|>=
name|PPS_NANOSECOND
condition|)
do|do
block|{
name|tmp
operator|-=
name|PPS_NANOSECOND
expr_stmt|;
name|out
operator|.
name|I
operator|.
name|u
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|tmp
operator|>=
name|PPS_NANOSECOND
condition|)
do|;
name|out
operator|.
name|F
operator|.
name|u
operator|=
call|(
name|u_int32
call|)
argument_list|(
operator|(
name|u_int64
operator|)
name|tmp
operator|<<
literal|32
argument_list|)
operator|+
operator|(
name|PPS_NANOSECOND
operator|/
literal|2
operator|)
operator|/
name|PPS_NANOSECOND
expr_stmt|;
return|return
name|out
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * count number of '1' bits in a u_long  */
end_comment

begin_function
specifier|static
name|size_t
name|popcount
parameter_list|(
name|u_long
name|val
parameter_list|)
block|{
name|size_t
name|res
decl_stmt|;
for|for
control|(
name|res
operator|=
literal|0
init|;
name|val
condition|;
name|res
operator|++
control|)
name|val
operator|&=
operator|(
name|val
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * --------------------------------------------------------------------  * API function implementation  * --------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------  * prov_time_pps_create - create PPS handle given underlying device  */
end_comment

begin_function
name|int
name|WINAPI
name|prov_time_pps_create
parameter_list|(
name|HANDLE
name|device
parameter_list|,
comment|/* underlying device */
name|pps_handle_t
modifier|*
name|handle
comment|/* returned handle */
parameter_list|)
block|{
name|loopback_unit
modifier|*
name|loopunit
decl_stmt|;
name|pps_unit_t
modifier|*
name|punit
decl_stmt|;
comment|/* 	 * Allocate and initialize loopback unit structure. 	 */
name|loopunit
operator|=
operator|(
name|loopback_unit
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|loopback_unit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|loopunit
condition|)
return|return
name|ENOMEM
return|;
comment|/* Try to attach to NTPD internal data with the device handle. 	 * Free unit buffer on failure. 	 */
name|loopunit
operator|->
name|hnd_dev
operator|=
name|device
expr_stmt|;
name|loopunit
operator|->
name|hnd_pps
operator|=
name|ntp_pps_attach_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|loopunit
operator|->
name|hnd_pps
condition|)
block|{
name|free
argument_list|(
name|loopunit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* create the outer PPS handle structure. Undo work done so far 	 * if things go wrong. 	 */
operator|*
name|handle
operator|=
call|(
modifier|*
name|p_create_pps_handle
call|)
argument_list|(
name|loopunit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|handle
condition|)
block|{
name|ntp_pps_detach_device
argument_list|(
name|loopunit
operator|->
name|hnd_pps
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|loopunit
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* All good so far. Store things to remember. */
name|punit
operator|=
operator|(
name|pps_unit_t
operator|*
operator|)
operator|*
name|handle
expr_stmt|;
name|punit
operator|->
name|params
operator|.
name|api_version
operator|=
name|PPS_API_VERS_1
expr_stmt|;
name|punit
operator|->
name|params
operator|.
name|mode
operator|=
name|PPS_CAPTUREBOTH
operator||
name|PPS_TSFMT_BOTH
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * prov_time_pps_destroy - release PPS handle  */
end_comment

begin_function
name|int
name|WINAPI
name|prov_time_pps_destroy
parameter_list|(
name|pps_unit_t
modifier|*
name|unit
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|loopback_unit
modifier|*
name|loopunit
decl_stmt|;
name|loopunit
operator|=
operator|(
name|loopback_unit
operator|*
operator|)
name|context
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|context
operator|==
name|context
condition|)
name|unit
operator|->
name|context
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|loopunit
condition|)
name|ntp_pps_detach_device
argument_list|(
name|loopunit
operator|->
name|hnd_pps
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|loopunit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * prov_time_pps_setparams - set parameters for handle  */
end_comment

begin_function
name|int
name|WINAPI
name|prov_time_pps_setparams
parameter_list|(
name|pps_unit_t
modifier|*
name|unit
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
specifier|const
name|pps_params_t
modifier|*
name|params
parameter_list|)
block|{
name|loopback_unit
modifier|*
name|loopunit
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|loopunit
operator|=
operator|(
name|loopback_unit
operator|*
operator|)
name|context
expr_stmt|;
name|mode
operator|=
name|params
operator|->
name|mode
expr_stmt|;
comment|/* 	 * There was no reasonable consensus in the API working group. 	 * I require `api_version' to be set! 	 */
if|if
condition|(
name|params
operator|->
name|api_version
operator|!=
name|PPS_API_VERS_1
condition|)
return|return
name|EINVAL
return|;
comment|/* 	 * We support all edges and formats plus offsets, but not 	 * POLL or WAIT. And we are strict on the time stamp format: 	 * Only one is permitted if we set offsets! 	 */
comment|/* 	 * Only one of the time formats may be selected. 	 */
if|if
condition|(
operator|(
name|mode
operator|&
name|PPS_OFFSETBOTH
operator|)
operator|!=
literal|0
operator|&&
name|popcount
argument_list|(
name|mode
operator|&
name|PPS_TSFMT_BOTH
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|EINVAL
return|;
comment|/* turn off read-only bits */
name|mode
operator|&=
operator|~
name|SERIALPPS_RO
expr_stmt|;
comment|/* 	 * test remaining bits. 	 */
if|if
condition|(
name|mode
operator|&
operator|~
operator|(
name|PPS_CAPTUREBOTH
operator||
name|PPS_OFFSETBOTH
operator||
name|PPS_TSFMT_BOTH
operator|)
condition|)
return|return
name|EOPNOTSUPP
return|;
comment|/* 	 * ok, ready to go. 	 * 	 * calculate offsets as ntp_fp_t's and store them in unit as ntp_fp_t. They will 	 * be always applied, since fetching the time stamps is not critical. 	 */
if|if
condition|(
name|mode
operator|&
name|PPS_OFFSETASSERT
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|PPS_TSFMT_TSPEC
condition|)
name|loopunit
operator|->
name|ofs_assert
operator|=
name|tspec_to_fp
argument_list|(
operator|&
name|params
operator|->
name|assert_offset
argument_list|)
expr_stmt|;
else|else
name|loopunit
operator|->
name|ofs_assert
operator|=
name|params
operator|->
name|assert_offset_ntpfp
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|PPS_OFFSETCLEAR
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|PPS_TSFMT_TSPEC
condition|)
name|loopunit
operator|->
name|ofs_clear
operator|=
name|tspec_to_fp
argument_list|(
operator|&
name|params
operator|->
name|clear_offset
argument_list|)
expr_stmt|;
else|else
name|loopunit
operator|->
name|ofs_clear
operator|=
name|params
operator|->
name|clear_offset_ntpfp
expr_stmt|;
block|}
comment|/* save remaining bits */
name|mode
operator||=
name|unit
operator|->
name|params
operator|.
name|mode
expr_stmt|;
name|unit
operator|->
name|params
operator|=
operator|*
name|params
expr_stmt|;
name|unit
operator|->
name|params
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * prov_time_pps_fetch - Fetch timestamps  */
end_comment

begin_function
name|int
name|WINAPI
name|prov_time_pps_fetch
parameter_list|(
name|pps_unit_t
modifier|*
name|unit
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
specifier|const
name|int
name|tsformat
parameter_list|,
name|pps_info_t
modifier|*
name|pinfo
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|loopback_unit
modifier|*
name|loopunit
decl_stmt|;
name|PPSData_t
name|pps_stamps
decl_stmt|;
name|pps_info_t
name|infobuf
decl_stmt|;
name|BOOL
name|rc
decl_stmt|;
name|time_t
name|tnow
decl_stmt|;
comment|/* 	 * nb. PPS_CANWAIT is NOT set by the implementation, we can totally 	 * ignore the timeout variable. 	 */
name|UNUSED
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|loopunit
operator|=
operator|(
name|loopback_unit
operator|*
operator|)
name|context
expr_stmt|;
comment|/* read& check raw data from daemon */
name|memset
argument_list|(
operator|&
name|infobuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|infobuf
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ntp_pps_read
argument_list|(
name|loopunit
operator|->
name|hnd_pps
argument_list|,
operator|&
name|pps_stamps
argument_list|,
sizeof|sizeof
argument_list|(
name|pps_stamps
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
block|{
switch|switch
condition|(
name|GetLastError
argument_list|()
condition|)
block|{
case|case
name|ERROR_INVALID_HANDLE
case|:
return|return
name|EINVAL
return|;
case|case
name|ERROR_INVALID_PARAMETER
case|:
return|return
name|EOPNOTSUPP
return|;
case|case
name|ERROR_INVALID_DATA
case|:
return|return
name|ENXIO
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
comment|/* add offsets on raw data */
name|NTPFP_L_ADDS
argument_list|(
operator|&
name|pps_stamps
operator|.
name|ts_assert
argument_list|,
operator|&
name|loopunit
operator|->
name|ofs_assert
argument_list|)
expr_stmt|;
name|NTPFP_L_ADDS
argument_list|(
operator|&
name|pps_stamps
operator|.
name|ts_clear
argument_list|,
operator|&
name|loopunit
operator|->
name|ofs_clear
argument_list|)
expr_stmt|;
comment|/* store sequence numbers */
name|infobuf
operator|.
name|assert_sequence
operator|=
name|pps_stamps
operator|.
name|cc_assert
expr_stmt|;
name|infobuf
operator|.
name|clear_sequence
operator|=
name|pps_stamps
operator|.
name|cc_clear
expr_stmt|;
comment|/* 	 * Translate or copy to specified format 	 */
switch|switch
condition|(
name|tsformat
condition|)
block|{
case|case
name|PPS_TSFMT_NTPFP
case|:
comment|/* NTP format requires no translation */
name|infobuf
operator|.
name|assert_timestamp_ntpfp
operator|=
name|pps_stamps
operator|.
name|ts_assert
expr_stmt|;
name|infobuf
operator|.
name|clear_timestamp_ntpfp
operator|=
name|pps_stamps
operator|.
name|ts_clear
expr_stmt|;
break|break;
case|case
name|PPS_TSFMT_TSPEC
case|:
comment|/* timespec format requires conversion to nsecs form */
name|time
argument_list|(
operator|&
name|tnow
argument_list|)
expr_stmt|;
name|infobuf
operator|.
name|assert_timestamp
operator|=
name|fp_stamp_to_tspec
argument_list|(
name|pps_stamps
operator|.
name|ts_assert
argument_list|,
name|tnow
argument_list|)
expr_stmt|;
name|infobuf
operator|.
name|clear_timestamp
operator|=
name|fp_stamp_to_tspec
argument_list|(
name|pps_stamps
operator|.
name|ts_clear
argument_list|,
name|tnow
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
name|infobuf
operator|.
name|current_mode
operator|=
name|unit
operator|->
name|params
operator|.
name|mode
expr_stmt|;
operator|*
name|pinfo
operator|=
name|infobuf
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * prov_time_pps_kcbind - specify kernel consumer  *  * Not supported so far by Windows.  */
end_comment

begin_function
name|int
name|WINAPI
name|prov_time_pps_kcbind
parameter_list|(
name|pps_unit_t
modifier|*
name|punit
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
specifier|const
name|int
name|kernel_consumer
parameter_list|,
specifier|const
name|int
name|edge
parameter_list|,
specifier|const
name|int
name|tsformat
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|punit
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|kernel_consumer
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|tsformat
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------  * prov_init - returns capabilities and provider name  */
end_comment

begin_function
name|int
name|WINAPI
name|ppsapi_prov_init
parameter_list|(
name|int
name|ppsapi_timepps_prov_ver
parameter_list|,
name|pcreate_pps_handle
name|create_pps_handle
parameter_list|,
name|ppps_ntp_timestamp_from_counter
name|ntp_timestamp_from_counter
parameter_list|,
name|char
modifier|*
name|short_name_buf
parameter_list|,
name|size_t
name|short_name_size
parameter_list|,
name|char
modifier|*
name|full_name_buf
parameter_list|,
name|size_t
name|full_name_size
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|ntp_timestamp_from_counter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppsapi_timepps_prov_ver
operator|<
name|PPSAPI_TIMEPPS_PROV_VER
condition|)
return|return
literal|0
return|;
name|p_create_pps_handle
operator|=
name|create_pps_handle
expr_stmt|;
name|strncpy
argument_list|(
name|short_name_buf
argument_list|,
literal|"loopback"
argument_list|,
name|short_name_size
argument_list|)
expr_stmt|;
name|short_name_buf
index|[
name|short_name_size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* ensure ASCIIZ */
name|strncpy
argument_list|(
name|full_name_buf
argument_list|,
literal|"loopback user mode DCD change detection"
argument_list|,
name|full_name_size
argument_list|)
expr_stmt|;
name|full_name_buf
index|[
name|full_name_size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* ensure ASCIIZ */
return|return
name|SERIALPPS_CAPS
return|;
block|}
end_function

end_unit

