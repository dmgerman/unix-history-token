begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * (c) Copyright 1995 HEWLETT-PACKARD COMPANY  *  * To anyone who acknowledges that this file is provided  * "AS IS" without any express or implied warranty:  * permission to use, copy, modify, and distribute this  * file for any purpose is hereby granted without fee,  * provided that the above copyright notice and this  * notice appears in all copies, and that the name of  * Hewlett-Packard Company not be used in advertising or  * publicity pertaining to distribution of the software  * without specific, written prior permission.  Hewlett-  * Packard Company makes no representations about the  * suitability of this software for any purpose.  *  */
end_comment

begin_comment
comment|/*  * k5dcecon - Program to convert a K5 TGT to a DCE context,  * for use with DFS and its PAG.  *  * The program is designed to be called as a sub process,  * and return via stdout the name of the cache which implies  * the PAG which should be used. This program itself does not  * use the cache or PAG itself, so the PAG in the kernel for  * this program may not be set.  *  * The calling program can then use the name of the cache  * to set the KRB5CCNAME and PAG for itself and its children.  *  * If no ticket was passed, an attemplt to join an existing  * PAG will be made.  *  * If a forwarded K5 TGT is passed in, either a new DCE  * context will be created, or an existing one will be updated.  * If the same ticket was already used to create an existing  * context, it will be joined instead.  *  * Parts of this program are based on k5dceauth,c which was  * given to me by HP and by the k5dcelogin.c which I developed.  * A slightly different version of k5dcelogin.c, was added to  * DCE 1.2.2  *  * D. E. Engert 6/17/97 ANL  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"k5dce.h"
end_include

begin_include
include|#
directive|include
file|<dce/sec_login.h>
end_include

begin_include
include|#
directive|include
file|<dce/dce_error.h>
end_include

begin_include
include|#
directive|include
file|<dce/passwd.h>
end_include

begin_comment
comment|/* #define DEBUG */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEEDEBUG
parameter_list|(
name|A
parameter_list|)
value|fprintf(stderr,A); fflush(stderr)
end_define

begin_define
define|#
directive|define
name|DEEDEBUG2
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|fprintf(stderr,A,B); fflush(stderr)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEEDEBUG
parameter_list|(
name|A
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DEEDEBUG2
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_define
define|#
directive|define
name|seteuid
parameter_list|(
name|A
parameter_list|)
value|setresuid(-1,A,-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|k5dcecreate
parameter_list|(
name|uid_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|krb5_creds
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|k5dcecon
parameter_list|(
name|uid_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|k5dcegettgt
parameter_list|(
name|krb5_ccache
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|krb5_creds
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|k5dcematch
parameter_list|(
name|uid_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|off_t
modifier|*
parameter_list|,
name|krb5_creds
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|k5dcesession
parameter_list|(
name|uid_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|krb5_creds
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|krb5_flags
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|progname
init|=
literal|"k5dcecon"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|now
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/* AIX with DCE 1.1 does not have the com_err in the libdce.a   * do a half hearted job of substituting for it.   */
end_comment

begin_function
name|void
name|com_err
parameter_list|(
name|char
modifier|*
name|p1
parameter_list|,
name|int
name|code
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|lst
decl_stmt|;
name|dce_error_string_t
name|err_string
decl_stmt|;
name|dce_error_inq_text
argument_list|(
name|code
argument_list|,
name|err_string
argument_list|,
operator|&
name|lst
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error %d in %s: %s\n"
argument_list|,
name|code
argument_list|,
name|p1
argument_list|,
name|err_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
name|void
name|krb5_init_ets
parameter_list|()
block|{  }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------*/
end_comment

begin_comment
comment|/* find a cache to use  for our new pag           */
end_comment

begin_comment
comment|/* Since there is no simple way to determine which  * caches are associated with a pag, we will have  * do look around and see what makes most sense on  * different systems.  * on a Solaris system, and in the DCE source,  * the pags always start with a 41.  * this is not true on the IBM, where there does not  * appear to be any pattern.  *  * But since we are always certifing our creds when  * they are received, we can us that fact, and look  * at the first word of the associated data file  * to see that it has a "5". If not don't use.  */
end_comment

begin_function
name|int
name|k5dcesession
parameter_list|(
name|luid
parameter_list|,
name|pname
parameter_list|,
name|tgt
parameter_list|,
name|ppag
parameter_list|,
name|tflags
parameter_list|)
name|uid_t
name|luid
decl_stmt|;
name|char
modifier|*
name|pname
decl_stmt|;
name|krb5_creds
modifier|*
modifier|*
name|tgt
decl_stmt|;
name|int
modifier|*
name|ppag
decl_stmt|;
name|krb5_flags
name|tflags
decl_stmt|;
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|direntp
decl_stmt|;
name|off_t
name|size
decl_stmt|;
name|krb5_timestamp
name|endtime
decl_stmt|;
name|int
name|better
init|=
literal|0
decl_stmt|;
name|krb5_creds
modifier|*
name|xtgt
decl_stmt|;
name|char
name|prev_name
index|[
literal|17
index|]
init|=
literal|""
decl_stmt|;
name|krb5_timestamp
name|prev_endtime
decl_stmt|;
name|off_t
name|prev_size
decl_stmt|;
name|u_long
name|prev_pag
init|=
literal|0
decl_stmt|;
name|char
name|ccname
index|[
literal|64
index|]
init|=
literal|"FILE:/opt/dcelocal/var/security/creds/"
decl_stmt|;
name|error_status_t
name|st
decl_stmt|;
name|sec_login_handle_t
name|lcontext
init|=
literal|0
decl_stmt|;
name|dce_error_string_t
name|err_string
decl_stmt|;
name|int
name|lst
decl_stmt|;
name|DEEDEBUG2
argument_list|(
literal|"k5dcesession looking for flags %8.8x\n"
argument_list|,
name|tflags
argument_list|)
expr_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
literal|"/opt/dcelocal/var/security/creds/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
block|{
return|return
literal|1
return|;
block|}
while|while
condition|(
operator|(
name|direntp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/*  * (but root has the ffffffff which we are not interested in)  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|direntp
operator|->
name|d_name
argument_list|,
literal|"dcecred_"
argument_list|,
literal|8
argument_list|)
operator|&&
operator|(
name|strlen
argument_list|(
name|direntp
operator|->
name|d_name
argument_list|)
operator|==
literal|16
operator|)
condition|)
block|{
comment|/* looks like a cache name, lets do the stat, etc */
name|strcpy
argument_list|(
name|ccname
operator|+
literal|38
argument_list|,
name|direntp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|k5dcematch
argument_list|(
name|luid
argument_list|,
name|pname
argument_list|,
name|ccname
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|xtgt
argument_list|)
condition|)
block|{
comment|/* it's one of our caches, see if it is better          * i.e. the endtime is farther, and if the endtimes          * are the same, take the larger, as he who has the          * most tickets wins.          * it must also had the same set of flags at least          * i.e. if the forwarded TGT is forwardable, this one must          * be as well.          */
name|DEEDEBUG2
argument_list|(
literal|"Cache:%s"
argument_list|,
name|direntp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|DEEDEBUG2
argument_list|(
literal|" size:%d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DEEDEBUG2
argument_list|(
literal|" flags:%8.8x"
argument_list|,
name|xtgt
operator|->
name|ticket_flags
argument_list|)
expr_stmt|;
name|DEEDEBUG2
argument_list|(
literal|" %s"
argument_list|,
name|ctime
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|xtgt
operator|->
name|times
operator|.
name|endtime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xtgt
operator|->
name|ticket_flags
operator|&
name|tflags
operator|)
operator|==
name|tflags
condition|)
block|{
if|if
condition|(
name|prev_name
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|xtgt
operator|->
name|times
operator|.
name|endtime
operator|>
name|prev_endtime
condition|)
block|{
name|better
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|xtgt
operator|->
name|times
operator|.
name|endtime
operator|=
name|prev_endtime
operator|)
operator|&&
operator|(
name|size
operator|>
name|prev_size
operator|)
condition|)
block|{
name|better
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* the first */
if|if
condition|(
name|xtgt
operator|->
name|times
operator|.
name|endtime
operator|>=
name|now
condition|)
block|{
name|better
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|better
condition|)
block|{
name|strcpy
argument_list|(
name|prev_name
argument_list|,
name|direntp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|prev_endtime
operator|=
name|xtgt
operator|->
name|times
operator|.
name|endtime
expr_stmt|;
name|prev_size
operator|=
name|size
expr_stmt|;
name|sscanf
argument_list|(
name|prev_name
operator|+
literal|8
argument_list|,
literal|"%8X"
argument_list|,
operator|&
name|prev_pag
argument_list|)
expr_stmt|;
operator|*
name|tgt
operator|=
name|xtgt
expr_stmt|;
name|better
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev_name
index|[
literal|0
index|]
condition|)
return|return
literal|1
return|;
comment|/* failed to find one */
name|DEEDEBUG2
argument_list|(
literal|"Best: %s\n"
argument_list|,
name|prev_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppag
condition|)
operator|*
name|ppag
operator|=
name|prev_pag
expr_stmt|;
name|strcpy
argument_list|(
name|ccname
operator|+
literal|38
argument_list|,
name|prev_name
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"KRB5CCNAME"
argument_list|,
name|ccname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------*/
end_comment

begin_comment
comment|/* see if this cache is for this this principal */
end_comment

begin_function
name|int
name|k5dcematch
parameter_list|(
name|luid
parameter_list|,
name|pname
parameter_list|,
name|ccname
parameter_list|,
name|sizep
parameter_list|,
name|tgt
parameter_list|)
name|uid_t
name|luid
decl_stmt|;
name|char
modifier|*
name|pname
decl_stmt|;
name|char
modifier|*
name|ccname
decl_stmt|;
name|off_t
modifier|*
name|sizep
decl_stmt|;
comment|/* size of the file */
name|krb5_creds
modifier|*
modifier|*
name|tgt
decl_stmt|;
block|{
name|krb5_ccache
name|cache
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|char
name|ccdata
index|[
literal|256
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* DEEDEBUG2("k5dcematch called: cache=%s\n",ccname+38); */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ccname
argument_list|,
literal|"FILE:"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|ccdata
argument_list|,
name|ccname
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ccdata
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
comment|/* DEEDEBUG2("Checking the .data file for %s\n",ccdata); */
if|if
condition|(
name|stat
argument_list|(
name|ccdata
argument_list|,
operator|&
name|stbuf
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|stbuf
operator|.
name|st_uid
operator|!=
name|luid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|ccdata
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|status
argument_list|,
literal|4
argument_list|)
operator|)
operator|!=
literal|4
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* DEEDEBUG2(".data file status = %d\n", status); */
if|if
condition|(
name|status
operator|!=
literal|5
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|stat
argument_list|(
name|ccname
operator|+
literal|5
argument_list|,
operator|&
name|stbuf
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|stbuf
operator|.
name|st_uid
operator|!=
name|luid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|sizep
operator|=
name|stbuf
operator|.
name|st_size
expr_stmt|;
block|}
return|return
operator|(
name|k5dcegettgt
argument_list|(
operator|&
name|cache
argument_list|,
name|ccname
argument_list|,
name|pname
argument_list|,
name|tgt
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------*/
end_comment

begin_comment
comment|/* k5dcegettgt - get the tgt from a cache */
end_comment

begin_function
name|int
name|k5dcegettgt
parameter_list|(
name|pcache
parameter_list|,
name|ccname
parameter_list|,
name|pname
parameter_list|,
name|tgt
parameter_list|)
name|krb5_ccache
modifier|*
name|pcache
decl_stmt|;
name|char
modifier|*
name|ccname
decl_stmt|;
name|char
modifier|*
name|pname
decl_stmt|;
name|krb5_creds
modifier|*
modifier|*
name|tgt
decl_stmt|;
block|{
name|krb5_ccache
name|cache
decl_stmt|;
name|krb5_cc_cursor
name|cur
decl_stmt|;
name|krb5_creds
name|creds
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|found
init|=
literal|1
decl_stmt|;
name|krb5_principal
name|princ
decl_stmt|;
name|char
modifier|*
name|kusername
decl_stmt|;
name|krb5_flags
name|flags
decl_stmt|;
name|char
modifier|*
name|sname
decl_stmt|,
modifier|*
name|realm
decl_stmt|,
modifier|*
name|tgtname
init|=
name|NULL
decl_stmt|;
comment|/* Since DCE does not expose much of the Kerberos interface,    * we will have to use what we can. This means setting the    * KRB5CCNAME for each file we want to test    * We will also not worry about freeing extra cache structures    * as this this routine is also not exposed, and this should not    * effect this module.    * We should also free the creds contents, but that is not exposed    * either.    */
name|setenv
argument_list|(
literal|"KRB5CCNAME"
argument_list|,
name|ccname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cache
operator|=
name|NULL
expr_stmt|;
operator|*
name|tgt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|code
operator|=
name|krb5_cc_default
argument_list|(
name|pcache
argument_list|)
condition|)
block|{
name|com_err
argument_list|(
name|progname
argument_list|,
name|code
argument_list|,
literal|"while getting ccache"
argument_list|)
expr_stmt|;
goto|goto
name|return2
goto|;
block|}
name|DEEDEBUG
argument_list|(
literal|"Got cache\n"
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|=
name|krb5_cc_set_flags
argument_list|(
operator|*
name|pcache
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|com_err
argument_list|(
name|progname
argument_list|,
name|code
argument_list|,
literal|"While setting flags"
argument_list|)
expr_stmt|;
goto|goto
name|return2
goto|;
block|}
name|DEEDEBUG
argument_list|(
literal|"Set flags\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|=
name|krb5_cc_get_principal
argument_list|(
operator|*
name|pcache
argument_list|,
operator|&
name|princ
argument_list|)
condition|)
block|{
name|com_err
argument_list|(
name|progname
argument_list|,
name|code
argument_list|,
literal|"While getting princ"
argument_list|)
expr_stmt|;
goto|goto
name|return1
goto|;
block|}
name|DEEDEBUG
argument_list|(
literal|"Got principal\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|=
name|krb5_unparse_name
argument_list|(
name|princ
argument_list|,
operator|&
name|kusername
argument_list|)
condition|)
block|{
name|com_err
argument_list|(
name|progname
argument_list|,
name|code
argument_list|,
literal|"While unparsing principal"
argument_list|)
expr_stmt|;
goto|goto
name|return1
goto|;
block|}
name|DEEDEBUG2
argument_list|(
literal|"Unparsed to \"%s\"\n"
argument_list|,
name|kusername
argument_list|)
expr_stmt|;
name|DEEDEBUG2
argument_list|(
literal|"pname is \"%s\"\n"
argument_list|,
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|kusername
argument_list|,
name|pname
argument_list|)
condition|)
block|{
name|DEEDEBUG
argument_list|(
literal|"Principals not equal\n"
argument_list|)
expr_stmt|;
goto|goto
name|return1
goto|;
block|}
name|DEEDEBUG
argument_list|(
literal|"Principals equal\n"
argument_list|)
expr_stmt|;
name|realm
operator|=
name|strchr
argument_list|(
name|pname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
name|realm
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|tgtname
operator|=
name|malloc
argument_list|(
literal|9
operator|+
literal|2
operator|*
name|strlen
argument_list|(
name|realm
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Malloc failed for tgtname\n"
argument_list|)
expr_stmt|;
goto|goto
name|return1
goto|;
block|}
name|strcpy
argument_list|(
name|tgtname
argument_list|,
literal|"krbtgt/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tgtname
argument_list|,
name|realm
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tgtname
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tgtname
argument_list|,
name|realm
argument_list|)
expr_stmt|;
name|DEEDEBUG2
argument_list|(
literal|"Getting tgt %s\n"
argument_list|,
name|tgtname
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|=
name|krb5_cc_start_seq_get
argument_list|(
operator|*
name|pcache
argument_list|,
operator|&
name|cur
argument_list|)
condition|)
block|{
name|com_err
argument_list|(
name|progname
argument_list|,
name|code
argument_list|,
literal|"while starting to retrieve tickets"
argument_list|)
expr_stmt|;
goto|goto
name|return1
goto|;
block|}
while|while
condition|(
operator|!
operator|(
name|code
operator|=
name|krb5_cc_next_cred
argument_list|(
operator|*
name|pcache
argument_list|,
operator|&
name|cur
argument_list|,
operator|&
name|creds
argument_list|)
operator|)
condition|)
block|{
name|krb5_creds
modifier|*
name|cred
init|=
operator|&
name|creds
decl_stmt|;
if|if
condition|(
name|code
operator|=
name|krb5_unparse_name
argument_list|(
name|cred
operator|->
name|server
argument_list|,
operator|&
name|sname
argument_list|)
condition|)
block|{
name|com_err
argument_list|(
name|progname
argument_list|,
name|code
argument_list|,
literal|"while unparsing server name"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|sname
argument_list|,
name|tgtname
argument_list|,
name|strlen
argument_list|(
name|tgtname
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DEEDEBUG
argument_list|(
literal|"FOUND\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|=
name|krb5_copy_creds
argument_list|(
operator|&
name|creds
argument_list|,
name|tgt
argument_list|)
condition|)
block|{
name|com_err
argument_list|(
name|progname
argument_list|,
name|code
argument_list|,
literal|"while copying TGT"
argument_list|)
expr_stmt|;
goto|goto
name|return1
goto|;
block|}
name|found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* we should do a krb5_free_cred_contents(creds); */
block|}
if|if
condition|(
name|code
operator|=
name|krb5_cc_end_seq_get
argument_list|(
operator|*
name|pcache
argument_list|,
operator|&
name|cur
argument_list|)
condition|)
block|{
name|com_err
argument_list|(
name|progname
argument_list|,
name|code
argument_list|,
literal|"while finishing retrieval"
argument_list|)
expr_stmt|;
goto|goto
name|return2
goto|;
block|}
name|return1
label|:
name|flags
operator|=
name|KRB5_TC_OPENCLOSE
expr_stmt|;
name|krb5_cc_set_flags
argument_list|(
operator|*
name|pcache
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* force a close */
name|return2
label|:
if|if
condition|(
name|tgtname
condition|)
name|free
argument_list|(
name|tgtname
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------*/
end_comment

begin_comment
comment|/* Convert a forwarded TGT to a DCE context */
end_comment

begin_function
name|int
name|k5dcecon
parameter_list|(
name|luid
parameter_list|,
name|luser
parameter_list|,
name|pname
parameter_list|)
name|uid_t
name|luid
decl_stmt|;
name|char
modifier|*
name|luser
decl_stmt|;
name|char
modifier|*
name|pname
decl_stmt|;
block|{
name|krb5_creds
modifier|*
name|ftgt
init|=
name|NULL
decl_stmt|;
name|krb5_creds
modifier|*
name|tgt
init|=
name|NULL
decl_stmt|;
name|unsigned32
name|dfspag
decl_stmt|;
name|boolean32
name|reset_passwd
init|=
literal|0
decl_stmt|;
name|int
name|lst
decl_stmt|;
name|dce_error_string_t
name|err_string
decl_stmt|;
name|char
modifier|*
name|shell_prog
decl_stmt|;
name|krb5_ccache
name|fcache
decl_stmt|;
name|char
modifier|*
name|ccname
decl_stmt|;
name|char
modifier|*
name|kusername
decl_stmt|;
name|char
modifier|*
name|urealm
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|pag
decl_stmt|;
name|int
name|code
decl_stmt|;
name|krb5_timestamp
name|endtime
decl_stmt|;
comment|/* If there is no cache to be converted, we should not be here */
if|if
condition|(
operator|(
name|ccname
operator|=
name|getenv
argument_list|(
literal|"KRB5CCNAME"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|DEEDEBUG
argument_list|(
literal|"No KRB5CCNAME\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|k5dcegettgt
argument_list|(
operator|&
name|fcache
argument_list|,
name|ccname
argument_list|,
name|pname
argument_list|,
operator|&
name|ftgt
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Did not find TGT\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|DEEDEBUG2
argument_list|(
literal|"flags=%x\n"
argument_list|,
name|ftgt
operator|->
name|ticket_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ftgt
operator|->
name|ticket_flags
operator|&
name|TKT_FLG_FORWARDABLE
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Ticket not forwardable\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* but OK to continue */
block|}
name|setenv
argument_list|(
literal|"KRB5CCNAME"
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
define|#
directive|define
name|TKT_ACCEPTABLE
value|(TKT_FLG_FORWARDABLE | TKT_FLG_PROXIABLE \          | TKT_FLG_MAY_POSTDATE | TKT_FLG_RENEWABLE | TKT_FLG_HW_AUTH \          | TKT_FLG_PRE_AUTH)
if|if
condition|(
operator|!
name|k5dcesession
argument_list|(
name|luid
argument_list|,
name|pname
argument_list|,
operator|&
name|tgt
argument_list|,
operator|&
name|pag
argument_list|,
operator|(
name|ftgt
operator|->
name|ticket_flags
operator|&
name|TKT_ACCEPTABLE
operator|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|ftgt
operator|->
name|times
operator|.
name|endtime
operator|>
name|tgt
operator|->
name|times
operator|.
name|endtime
condition|)
block|{
name|DEEDEBUG
argument_list|(
literal|"Updating existing cache\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|k5dceupdate
argument_list|(
operator|&
name|ftgt
argument_list|,
name|pag
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|DEEDEBUG
argument_list|(
literal|"Using existing cache\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* use the original one */
block|}
block|}
comment|/* see if the tgts match up */
if|if
condition|(
operator|(
name|code
operator|=
name|k5dcecreate
argument_list|(
name|luid
argument_list|,
name|luser
argument_list|,
name|pname
argument_list|,
operator|&
name|ftgt
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|code
operator|)
return|;
block|}
comment|/*    * Destroy the Kerberos5 cred cache file.    * but dont care aout the return code.    */
name|DEEDEBUG
argument_list|(
literal|"Destroying the old cache\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|krb5_cc_destroy
argument_list|(
name|fcache
argument_list|)
operator|)
condition|)
block|{
name|com_err
argument_list|(
name|progname
argument_list|,
name|code
argument_list|,
literal|"while destroying Kerberos5 ccache"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------*/
end_comment

begin_comment
comment|/* k5dceupdate - update the cache with a new TGT    */
end_comment

begin_comment
comment|/* Assumed that the KRB5CCNAME has been set         */
end_comment

begin_function
name|int
name|k5dceupdate
parameter_list|(
name|krbtgt
parameter_list|,
name|pag
parameter_list|)
name|krb5_creds
modifier|*
modifier|*
name|krbtgt
decl_stmt|;
name|int
name|pag
decl_stmt|;
block|{
name|krb5_ccache
name|ccache
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|code
operator|=
name|krb5_cc_default
argument_list|(
operator|&
name|ccache
argument_list|)
condition|)
block|{
name|com_err
argument_list|(
name|progname
argument_list|,
name|code
argument_list|,
literal|"while opening cache for update"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|code
operator|=
name|ccache
operator|->
name|ops
operator|->
name|init
argument_list|(
name|ccache
argument_list|,
operator|(
operator|*
name|krbtgt
operator|)
operator|->
name|client
argument_list|)
condition|)
block|{
name|com_err
argument_list|(
name|progname
argument_list|,
name|code
argument_list|,
literal|"while reinitilizing cache"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|3
operator|)
return|;
block|}
comment|/* krb5_cc_store_cred */
if|if
condition|(
name|code
operator|=
name|ccache
operator|->
name|ops
operator|->
name|store
argument_list|(
name|ccache
argument_list|,
operator|*
name|krbtgt
argument_list|)
condition|)
block|{
name|com_err
argument_list|(
name|progname
argument_list|,
name|code
argument_list|,
literal|"while updating cache"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
name|sec_login_pag_new_tgt
argument_list|(
name|pag
argument_list|,
operator|(
operator|*
name|krbtgt
operator|)
operator|->
name|times
operator|.
name|endtime
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------*/
end_comment

begin_comment
comment|/* k5dcecreate - create a new DCE context           */
end_comment

begin_function
name|int
name|k5dcecreate
parameter_list|(
name|luid
parameter_list|,
name|luser
parameter_list|,
name|pname
parameter_list|,
name|krbtgt
parameter_list|)
name|uid_t
name|luid
decl_stmt|;
name|char
modifier|*
name|luser
decl_stmt|;
name|char
modifier|*
name|pname
decl_stmt|;
name|krb5_creds
modifier|*
modifier|*
name|krbtgt
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|urealm
decl_stmt|;
name|char
modifier|*
name|username
decl_stmt|;
name|char
modifier|*
name|defrealm
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|error_status_t
name|st
decl_stmt|;
name|sec_login_handle_t
name|lcontext
init|=
literal|0
decl_stmt|;
name|sec_login_auth_src_t
name|auth_src
init|=
literal|0
decl_stmt|;
name|boolean32
name|reset_passwd
init|=
literal|0
decl_stmt|;
name|int
name|lst
decl_stmt|;
name|dce_error_string_t
name|err_string
decl_stmt|;
name|setenv
argument_list|(
literal|"KRB5CCNAME"
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* make sure it not misused */
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|DEEDEBUG2
argument_list|(
literal|"uid=%d\n"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
comment|/* if run as root, change to user, so as to have the 	 * cache created for the local user even if cross-cell 	 * If run as a user, let standard file protection work. 	 */
if|if
condition|(
name|uid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|seteuid
argument_list|(
name|luid
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|abort
goto|;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|pname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|urealm
operator|=
operator|++
name|cp
expr_stmt|;
name|DEEDEBUG2
argument_list|(
literal|"basename=%s\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|DEEDEBUG2
argument_list|(
literal|"realm=%s\n"
argument_list|,
name|urealm
argument_list|)
expr_stmt|;
comment|/* now build the username as a single string or a /.../cell/user      * if this is a cross cell      */
if|if
condition|(
operator|(
name|username
operator|=
name|malloc
argument_list|(
literal|7
operator|+
name|strlen
argument_list|(
name|pname
argument_list|)
operator|+
name|strlen
argument_list|(
name|urealm
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Malloc failed for username\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
if|if
condition|(
name|krb5_get_default_realm
argument_list|(
operator|&
name|defrealm
argument_list|)
condition|)
block|{
name|DEEDEBUG
argument_list|(
literal|"krb5_get_default_realm failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|urealm
argument_list|,
name|defrealm
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|username
argument_list|,
name|pname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|username
argument_list|,
literal|"/.../"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|username
argument_list|,
name|urealm
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|username
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|username
argument_list|,
name|pname
argument_list|)
expr_stmt|;
block|}
comment|/*      * Setup a DCE login context      */
if|if
condition|(
name|sec_login_setup_identity
argument_list|(
operator|(
name|unsigned_char_p_t
operator|)
name|username
argument_list|,
operator|(
name|sec_login_external_tgt
operator||
name|sec_login_proxy_cred
operator|)
argument_list|,
operator|&
name|lcontext
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
comment|/* 	 * Add our TGT. 	 */
name|DEEDEBUG
argument_list|(
literal|"Adding our new TGT\n"
argument_list|)
expr_stmt|;
name|sec_login_krb5_add_cred
argument_list|(
name|lcontext
argument_list|,
operator|*
name|krbtgt
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
condition|)
block|{
name|dce_error_inq_text
argument_list|(
name|st
argument_list|,
name|err_string
argument_list|,
operator|&
name|lst
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error while adding credentials for %s because %s\n"
argument_list|,
name|username
argument_list|,
name|err_string
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|DEEDEBUG
argument_list|(
literal|"validating and certifying\n"
argument_list|)
expr_stmt|;
comment|/* 	   * Now "validate" and certify the identity, 	   *  usually we would pass a password here, but... 	   * sec_login_valid_and_cert_ident 	   * sec_login_validate_identity 	   */
if|if
condition|(
name|sec_login_validate_identity
argument_list|(
name|lcontext
argument_list|,
literal|0
argument_list|,
operator|&
name|reset_passwd
argument_list|,
operator|&
name|auth_src
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|DEEDEBUG2
argument_list|(
literal|"validate_identity st=%d\n"
argument_list|,
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
condition|)
block|{
name|dce_error_inq_text
argument_list|(
name|st
argument_list|,
name|err_string
argument_list|,
operator|&
name|lst
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Validation error for %s because %s\n"
argument_list|,
name|username
argument_list|,
name|err_string
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
if|if
condition|(
operator|!
name|sec_login_certify_identity
argument_list|(
name|lcontext
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|dce_error_inq_text
argument_list|(
name|st
argument_list|,
name|err_string
argument_list|,
operator|&
name|lst
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Credentials not certified because %s\n"
argument_list|,
name|err_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reset_passwd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Password must be changed for %s\n"
argument_list|,
name|username
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|auth_src
operator|==
name|sec_login_auth_src_local
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Credentials obtained from local registry for %s\n"
argument_list|,
name|username
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|auth_src
operator|==
name|sec_login_auth_src_overridden
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Validated %s from local override entry, no network credentials obtained\n"
argument_list|,
name|username
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
comment|/* 	     * Actually create the cred files. 	     */
name|DEEDEBUG
argument_list|(
literal|"Ceating new cred files.\n"
argument_list|)
expr_stmt|;
name|sec_login_set_context
argument_list|(
name|lcontext
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
condition|)
block|{
name|dce_error_inq_text
argument_list|(
name|st
argument_list|,
name|err_string
argument_list|,
operator|&
name|lst
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to set context for %s because %s\n"
argument_list|,
name|username
argument_list|,
name|err_string
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
comment|/*          * Now free up the local context and leave the          * network context with its pag          */
if|#
directive|if
literal|0
block|sec_login_release_context(&lcontext,&st);         if (st) {           dce_error_inq_text(st, err_string,&lst);           fprintf(stderr,                "Unable to release context for %s because %s\n",             username, err_string);           goto abort;         }
endif|#
directive|endif
block|}
else|else
block|{
name|DEEDEBUG2
argument_list|(
literal|"validate failed %d\n"
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|dce_error_inq_text
argument_list|(
name|st
argument_list|,
name|err_string
argument_list|,
operator|&
name|lst
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to validate %s because %s\n"
argument_list|,
name|username
argument_list|,
name|err_string
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
block|}
else|else
block|{
name|dce_error_inq_text
argument_list|(
name|st
argument_list|,
name|err_string
argument_list|,
operator|&
name|lst
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to setup login entry for %s because %s\n"
argument_list|,
name|username
argument_list|,
name|err_string
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|done
label|:
comment|/* if we were root, get back to root */
name|DEEDEBUG2
argument_list|(
literal|"sec_login_inq_pag %8.8x\n"
argument_list|,
name|sec_login_inq_pag
argument_list|(
name|lcontext
argument_list|,
operator|&
name|st
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|==
literal|0
condition|)
block|{
name|seteuid
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|DEEDEBUG
argument_list|(
literal|"completed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|abort
label|:
if|if
condition|(
name|uid
operator|==
literal|0
condition|)
block|{
name|seteuid
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|DEEDEBUG
argument_list|(
literal|"Aborting\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-------------------------------------------------*/
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|char
modifier|*
name|lusername
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|pname
init|=
name|NULL
decl_stmt|;
name|int
name|fflag
init|=
literal|0
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|uid_t
name|luid
decl_stmt|;
name|uid_t
name|myuid
decl_stmt|;
name|char
modifier|*
name|ccname
decl_stmt|;
name|krb5_creds
modifier|*
name|tgt
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|open
argument_list|(
literal|"/tmp/k5dce.debug"
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_APPEND
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|myuid
operator|=
name|getuid
argument_list|()
condition|)
block|{
name|DEEDEBUG2
argument_list|(
literal|"UID = %d\n"
argument_list|,
name|myuid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|33
argument_list|)
expr_stmt|;
comment|/* must be root to run this, get out now */
block|}
while|while
condition|(
operator|(
name|rv
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"l:p:fs"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|DEEDEBUG2
argument_list|(
literal|"Arg = %c\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rv
condition|)
block|{
case|case
literal|'l'
case|:
comment|/* user name */
name|lusername
operator|=
name|optarg
expr_stmt|;
name|DEEDEBUG2
argument_list|(
literal|"Optarg = %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* principal name */
name|pname
operator|=
name|optarg
expr_stmt|;
name|DEEDEBUG2
argument_list|(
literal|"Optarg = %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* convert a forwarded TGT to a context */
name|fflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* old test parameter, ignore it */
break|break;
block|}
block|}
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|krb5_init_ets
argument_list|()
expr_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* set time to check expired tickets */
comment|/* if lusername == NULL, Then user is passed as the USER= variable */
if|if
condition|(
operator|!
name|lusername
condition|)
block|{
name|lusername
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lusername
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"USER not in environment\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|3
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|lusername
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Who are you?\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|44
operator|)
return|;
block|}
name|luid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
name|status
operator|=
name|k5dcecon
argument_list|(
name|luid
argument_list|,
name|lusername
argument_list|,
name|pname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|k5dcesession
argument_list|(
name|luid
argument_list|,
name|pname
argument_list|,
operator|&
name|tgt
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|status
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|getenv
argument_list|(
literal|"KRB5CCNAME"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* return via stdout to caller */
name|DEEDEBUG2
argument_list|(
literal|"KRB5CCNAME=%s\n"
argument_list|,
name|getenv
argument_list|(
literal|"KRB5CCNAME"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DEEDEBUG2
argument_list|(
literal|"Returning status %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

end_unit

