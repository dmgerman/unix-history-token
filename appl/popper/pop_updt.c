begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_include
include|#
directive|include
file|<popper.h>
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|standard_error
index|[]
init|=
literal|"Error error updating primary drop. Mailbox unchanged"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  updt:   Apply changes to a user's POP maildrop  */
end_comment

begin_function
name|int
name|pop_updt
parameter_list|(
name|POP
modifier|*
name|p
parameter_list|)
block|{
name|FILE
modifier|*
name|md
decl_stmt|;
comment|/*  Stream pointer for                                                         the user's maildrop */
name|int
name|mfd
decl_stmt|;
comment|/*  File descriptor for                                                         above */
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/*  Read buffer */
name|MsgInfoList
modifier|*
name|mp
decl_stmt|;
comment|/*  Pointer to message                                                         info list */
name|int
name|msg_num
decl_stmt|;
comment|/*  Current message                                                         counter */
name|int
name|status_written
decl_stmt|;
comment|/*  Status header field                                                         written */
name|int
name|nchar
decl_stmt|;
comment|/* Bytes read/written */
name|long
name|offset
decl_stmt|;
comment|/* New mail offset */
name|int
name|blank_line
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|p
operator|->
name|debug
condition|)
block|{
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_DEBUG
argument_list|,
literal|"Performing maildrop update..."
argument_list|)
expr_stmt|;
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_DEBUG
argument_list|,
literal|"Checking to see if all messages were deleted"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|IS_MAILDIR
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|pop_maildir_update
argument_list|(
name|p
argument_list|)
return|;
if|if
condition|(
name|p
operator|->
name|msgs_deleted
operator|==
name|p
operator|->
name|msg_count
condition|)
block|{
comment|/* Truncate before close, to avoid race condition,  DO NOT UNLINK!            Another process may have opened,  and not yet tried to lock */
name|ftruncate
argument_list|(
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|p
operator|->
name|drop
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|p
operator|->
name|drop
argument_list|)
expr_stmt|;
return|return
operator|(
name|POP_SUCCESS
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|p
operator|->
name|debug
condition|)
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_DEBUG
argument_list|,
literal|"Opening mail drop \"%s\""
argument_list|,
name|p
operator|->
name|drop_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*  Open the user's real maildrop */
if|if
condition|(
operator|(
name|mfd
operator|=
name|open
argument_list|(
name|p
operator|->
name|drop_name
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0600
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|md
operator|=
name|fdopen
argument_list|(
name|mfd
argument_list|,
literal|"r+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
name|standard_error
argument_list|)
return|;
block|}
comment|/*  Lock the user's real mail drop */
if|if
condition|(
name|flock
argument_list|(
name|mfd
argument_list|,
name|LOCK_EX
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fclose
argument_list|(
name|md
argument_list|)
expr_stmt|;
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"flock: '%s': %s"
argument_list|,
name|p
operator|->
name|temp_drop
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
block|}
comment|/* Go to the right places */
name|offset
operator|=
name|lseek
argument_list|(
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|p
operator|->
name|drop
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
comment|/*  Append any messages that may have arrived during the session         to the temporary maildrop */
while|while
condition|(
operator|(
name|nchar
operator|=
name|read
argument_list|(
name|mfd
argument_list|,
name|buffer
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|nchar
operator|!=
name|write
argument_list|(
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|p
operator|->
name|drop
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|nchar
argument_list|)
condition|)
block|{
name|nchar
operator|=
operator|-
literal|1
expr_stmt|;
break|break ;
block|}
if|if
condition|(
name|nchar
operator|!=
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|md
argument_list|)
expr_stmt|;
name|ftruncate
argument_list|(
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|p
operator|->
name|drop
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|p
operator|->
name|drop
argument_list|)
expr_stmt|;
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
name|standard_error
argument_list|)
return|;
block|}
name|rewind
argument_list|(
name|md
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|mfd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|ftruncate
argument_list|(
name|mfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Synch stdio and the kernel for the POP drop */
name|rewind
argument_list|(
name|p
operator|->
name|drop
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|p
operator|->
name|drop
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/*  Transfer messages not flagged for deletion from the temporary         maildrop to the new maildrop */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|p
operator|->
name|debug
condition|)
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_DEBUG
argument_list|,
literal|"Creating new maildrop \"%s\" from \"%s\""
argument_list|,
name|p
operator|->
name|drop_name
argument_list|,
name|p
operator|->
name|temp_drop
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
for|for
control|(
name|msg_num
operator|=
literal|0
init|;
name|msg_num
operator|<
name|p
operator|->
name|msg_count
condition|;
operator|++
name|msg_num
control|)
block|{
name|int
name|doing_body
decl_stmt|;
comment|/*  Get a pointer to the message information list */
name|mp
operator|=
operator|&
name|p
operator|->
name|mlp
index|[
name|msg_num
index|]
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|DEL_FLAG
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|p
operator|->
name|debug
condition|)
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_DEBUG
argument_list|,
literal|"Message %d flagged for deletion."
argument_list|,
name|mp
operator|->
name|number
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
continue|continue;
block|}
name|fseek
argument_list|(
name|p
operator|->
name|drop
argument_list|,
name|mp
operator|->
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|p
operator|->
name|debug
condition|)
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_DEBUG
argument_list|,
literal|"Copying message %d."
argument_list|,
name|mp
operator|->
name|number
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|blank_line
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|status_written
operator|=
name|doing_body
operator|=
literal|0
init|;
name|fgets
argument_list|(
name|buffer
argument_list|,
name|MAXMSGLINELEN
argument_list|,
name|p
operator|->
name|drop
argument_list|)
condition|;
control|)
block|{
if|if
condition|(
name|doing_body
operator|==
literal|0
condition|)
block|{
comment|/* Header */
comment|/*  Update the message status */
if|if
condition|(
name|strncasecmp
argument_list|(
name|buffer
argument_list|,
literal|"Status:"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|RETR_FLAG
condition|)
name|fputs
argument_list|(
literal|"Status: RO\n"
argument_list|,
name|md
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|buffer
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|status_written
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/*  A blank line signals the end of the header. */
if|if
condition|(
operator|*
name|buffer
operator|==
literal|'\n'
condition|)
block|{
name|doing_body
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|status_written
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|RETR_FLAG
condition|)
name|fputs
argument_list|(
literal|"Status: RO\n\n"
argument_list|,
name|md
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"Status: U\n\n"
argument_list|,
name|md
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|md
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*  Save another header line */
name|fputs
argument_list|(
name|buffer
argument_list|,
name|md
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Body */
if|if
condition|(
name|blank_line
operator|&&
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|fputs
argument_list|(
name|buffer
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|blank_line
operator|=
operator|(
operator|*
name|buffer
operator|==
literal|'\n'
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* flush and check for errors now!  The new mail will writen        without stdio,  since we need not separate messages */
name|fflush
argument_list|(
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|md
argument_list|)
condition|)
block|{
name|ftruncate
argument_list|(
name|mfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|md
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|p
operator|->
name|drop
argument_list|)
expr_stmt|;
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
name|standard_error
argument_list|)
return|;
block|}
comment|/* Go to start of new mail if any */
name|lseek
argument_list|(
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|p
operator|->
name|drop
argument_list|)
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nchar
operator|=
name|read
argument_list|(
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|p
operator|->
name|drop
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|nchar
operator|!=
name|write
argument_list|(
name|mfd
argument_list|,
name|buffer
argument_list|,
name|nchar
argument_list|)
condition|)
block|{
name|nchar
operator|=
operator|-
literal|1
expr_stmt|;
break|break ;
block|}
if|if
condition|(
name|nchar
operator|!=
literal|0
condition|)
block|{
name|ftruncate
argument_list|(
name|mfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|md
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|p
operator|->
name|drop
argument_list|)
expr_stmt|;
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
name|standard_error
argument_list|)
return|;
block|}
comment|/*  Close the maildrop and empty temporary maildrop */
name|fclose
argument_list|(
name|md
argument_list|)
expr_stmt|;
name|ftruncate
argument_list|(
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|p
operator|->
name|drop
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|p
operator|->
name|drop
argument_list|)
expr_stmt|;
return|return
operator|(
name|pop_quit
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

