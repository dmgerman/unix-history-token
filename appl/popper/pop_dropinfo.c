begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_include
include|#
directive|include
file|<popper.h>
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UIDL
argument_list|)
operator|||
name|defined
argument_list|(
name|XOVER
argument_list|)
end_if

begin_comment
comment|/*  * Copy the string found after after : into a malloced buffer. Stop  * copying at end of string or end of line. End of line delimiter is  * not part of the resulting copy.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_value_after_colon
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|;
name|p
operator|++
control|)
comment|/* Find : */
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
goto|goto
name|error
goto|;
name|p
operator|++
expr_stmt|;
comment|/* Skip over : */
for|for
control|(
init|;
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|;
name|p
operator|++
control|)
comment|/* Remove white space */
empty_stmt|;
for|for
control|(
name|t
operator|=
name|p
init|;
operator|*
name|t
operator|!=
literal|0
operator|&&
operator|*
name|t
operator|!=
literal|'\n'
operator|&&
operator|*
name|t
operator|!=
literal|'\r'
condition|;
name|t
operator|++
control|)
comment|/* Find end of str */
empty_stmt|;
name|tmp
operator|=
name|t
operator|=
name|malloc
argument_list|(
name|t
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
goto|goto
name|error
goto|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\r'
condition|;
name|p
operator|++
operator|,
name|t
operator|++
control|)
comment|/* Copy characters */
operator|*
name|t
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|t
operator|=
literal|0
expr_stmt|;
comment|/* Terminate string */
return|return
name|tmp
return|;
name|error
label|:
return|return
literal|"ErrorUIDL"
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|parse_header
parameter_list|(
name|MsgInfoList
modifier|*
name|mp
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|UIDL
argument_list|)
operator|||
name|defined
argument_list|(
name|XOVER
argument_list|)
if|if
condition|(
name|strncasecmp
argument_list|(
literal|"Message-Id:"
argument_list|,
name|buffer
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|msg_id
operator|==
name|NULL
condition|)
name|mp
operator|->
name|msg_id
operator|=
name|find_value_after_colon
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UIDL
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|buffer
argument_list|,
literal|"X-UIDL:"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Courtesy to Qualcomm, there really is no such 	   thing as X-UIDL */
name|mp
operator|->
name|msg_id
operator|=
name|find_value_after_colon
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XOVER
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
literal|"Subject:"
argument_list|,
name|buffer
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|subject
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|mp
operator|->
name|subject
operator|=
name|find_value_after_colon
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|mp
operator|->
name|subject
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\t'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
literal|"From:"
argument_list|,
name|buffer
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|from
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|mp
operator|->
name|from
operator|=
name|find_value_after_colon
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|mp
operator|->
name|from
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\t'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
literal|"Date:"
argument_list|,
name|buffer
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|date
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|mp
operator|->
name|date
operator|=
name|find_value_after_colon
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|mp
operator|->
name|date
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\t'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|add_missing_headers
parameter_list|(
name|POP
modifier|*
name|p
parameter_list|,
name|MsgInfoList
modifier|*
name|mp
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|UIDL
argument_list|)
operator|||
name|defined
argument_list|(
name|XOVER
argument_list|)
if|if
condition|(
name|mp
operator|->
name|msg_id
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|mp
operator|->
name|msg_id
argument_list|,
literal|"no-message-id-%d"
argument_list|,
name|mp
operator|->
name|number
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fclose
argument_list|(
name|p
operator|->
name|drop
argument_list|)
expr_stmt|;
name|p
operator|->
name|msg_count
operator|=
literal|0
expr_stmt|;
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"Can't build message list for '%s': Out of memory"
argument_list|,
name|p
operator|->
name|user
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XOVER
if|if
condition|(
name|mp
operator|->
name|subject
operator|==
name|NULL
condition|)
name|mp
operator|->
name|subject
operator|=
literal|"<none>"
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|from
operator|==
name|NULL
condition|)
name|mp
operator|->
name|from
operator|=
literal|"<unknown>"
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|date
operator|==
name|NULL
condition|)
name|mp
operator|->
name|date
operator|=
literal|"<unknown>"
expr_stmt|;
endif|#
directive|endif
return|return
name|POP_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  *  dropinfo:   Extract information about the POP maildrop and store  *  it for use by the other POP routines.  */
end_comment

begin_function
name|int
name|pop_dropinfo
parameter_list|(
name|POP
modifier|*
name|p
parameter_list|)
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/*  Read buffer */
name|MsgInfoList
modifier|*
name|mp
decl_stmt|;
comment|/*  Pointer to message                                                         info list */
name|int
name|msg_num
decl_stmt|;
comment|/*  Current message                                                         counter */
name|int
name|nchar
decl_stmt|;
comment|/*  Bytes written/read */
name|int
name|blank_line
init|=
literal|1
decl_stmt|;
comment|/* previous line was blank */
name|int
name|in_header
init|=
literal|0
decl_stmt|;
comment|/* if we are in a header block */
comment|/*  Initialize maildrop status variables in the POP parameter block */
name|p
operator|->
name|msg_count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|msgs_deleted
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|last_msg
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|bytes_deleted
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|drop_size
operator|=
literal|0
expr_stmt|;
comment|/*  Allocate memory for message information structures */
name|p
operator|->
name|msg_count
operator|=
name|ALLOC_MSGS
expr_stmt|;
name|p
operator|->
name|mlp
operator|=
operator|(
name|MsgInfoList
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|p
operator|->
name|msg_count
argument_list|,
sizeof|sizeof
argument_list|(
name|MsgInfoList
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|mlp
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|p
operator|->
name|drop
argument_list|)
expr_stmt|;
name|p
operator|->
name|msg_count
operator|=
literal|0
expr_stmt|;
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"Can't build message list for '%s': Out of memory"
argument_list|,
name|p
operator|->
name|user
argument_list|)
return|;
block|}
name|rewind
argument_list|(
name|p
operator|->
name|drop
argument_list|)
expr_stmt|;
comment|/*  Scan the file, loading the message information list with         information about each message */
for|for
control|(
name|msg_num
operator|=
name|p
operator|->
name|drop_size
operator|=
literal|0
operator|,
name|mp
operator|=
name|p
operator|->
name|mlp
operator|-
literal|1
init|;
name|fgets
argument_list|(
name|buffer
argument_list|,
name|MAXMSGLINELEN
argument_list|,
name|p
operator|->
name|drop
argument_list|)
condition|;
control|)
block|{
name|nchar
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|blank_line
operator|&&
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|in_header
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|msg_num
operator|>
name|p
operator|->
name|msg_count
condition|)
block|{
name|p
operator|->
name|mlp
operator|=
operator|(
name|MsgInfoList
operator|*
operator|)
name|realloc
argument_list|(
name|p
operator|->
name|mlp
argument_list|,
operator|(
name|p
operator|->
name|msg_count
operator|+=
name|ALLOC_MSGS
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|MsgInfoList
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|mlp
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|p
operator|->
name|drop
argument_list|)
expr_stmt|;
name|p
operator|->
name|msg_count
operator|=
literal|0
expr_stmt|;
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"Can't build message list for '%s': Out of memory"
argument_list|,
name|p
operator|->
name|user
argument_list|)
return|;
block|}
name|mp
operator|=
name|p
operator|->
name|mlp
operator|+
name|msg_num
operator|-
literal|2
expr_stmt|;
block|}
operator|++
name|mp
expr_stmt|;
name|mp
operator|->
name|number
operator|=
name|msg_num
expr_stmt|;
name|mp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|lines
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|offset
operator|=
name|ftell
argument_list|(
name|p
operator|->
name|drop
argument_list|)
operator|-
name|nchar
expr_stmt|;
name|mp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|UIDL
argument_list|)
operator|||
name|defined
argument_list|(
name|XOVER
argument_list|)
name|mp
operator|->
name|msg_id
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XOVER
name|mp
operator|->
name|subject
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|from
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|date
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|p
operator|->
name|debug
condition|)
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_DEBUG
argument_list|,
literal|"Msg %d at offset %ld being added to list"
argument_list|,
name|mp
operator|->
name|number
argument_list|,
name|mp
operator|->
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
elseif|else
if|if
condition|(
name|in_header
condition|)
name|parse_header
argument_list|(
name|mp
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|blank_line
operator|=
operator|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"\n"
argument_list|,
name|nchar
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|blank_line
condition|)
block|{
name|int
name|e
decl_stmt|;
name|in_header
operator|=
literal|0
expr_stmt|;
name|e
operator|=
name|add_missing_headers
argument_list|(
name|p
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|POP_SUCCESS
condition|)
return|return
name|e
return|;
block|}
name|mp
operator|->
name|length
operator|+=
name|nchar
expr_stmt|;
name|p
operator|->
name|drop_size
operator|+=
name|nchar
expr_stmt|;
name|mp
operator|->
name|lines
operator|++
expr_stmt|;
block|}
name|p
operator|->
name|msg_count
operator|=
name|msg_num
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|p
operator|->
name|debug
operator|&&
name|msg_num
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mp
operator|=
name|p
operator|->
name|mlp
init|;
name|i
operator|<
name|p
operator|->
name|msg_count
condition|;
name|i
operator|++
operator|,
name|mp
operator|++
control|)
ifdef|#
directive|ifdef
name|UIDL
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_DEBUG
argument_list|,
literal|"Msg %d at offset %ld is %ld octets long and has %u lines and id %s."
argument_list|,
name|mp
operator|->
name|number
argument_list|,
name|mp
operator|->
name|offset
argument_list|,
name|mp
operator|->
name|length
argument_list|,
name|mp
operator|->
name|lines
argument_list|,
name|mp
operator|->
name|msg_id
argument_list|)
expr_stmt|;
else|#
directive|else
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_DEBUG
argument_list|,
literal|"Msg %d at offset %d is %d octets long and has %u lines."
argument_list|,
name|mp
operator|->
name|number
argument_list|,
name|mp
operator|->
name|offset
argument_list|,
name|mp
operator|->
name|length
argument_list|,
name|mp
operator|->
name|lines
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|(
name|POP_SUCCESS
operator|)
return|;
block|}
end_function

end_unit

