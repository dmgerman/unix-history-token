begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_include
include|#
directive|include
file|<popper.h>
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Run as the user in `pwd'  */
end_comment

begin_function
name|int
name|changeuser
parameter_list|(
name|POP
modifier|*
name|p
parameter_list|,
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|)
block|{
if|if
condition|(
name|setgid
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_PRIORITY
argument_list|,
literal|"Unable to change to gid %u: %s"
argument_list|,
operator|(
name|unsigned
operator|)
name|pwd
operator|->
name|pw_gid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"Unable to change gid"
argument_list|)
return|;
block|}
if|if
condition|(
name|setuid
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_PRIORITY
argument_list|,
literal|"Unable to change to uid %u: %s"
argument_list|,
operator|(
name|unsigned
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"Unable to change uid"
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|p
operator|->
name|debug
condition|)
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_DEBUG
argument_list|,
literal|"uid = %u, gid = %u"
argument_list|,
operator|(
name|unsigned
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|unsigned
operator|)
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|POP_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  *  dropcopy:   Make a temporary copy of the user's mail drop and  *  save a stream pointer for it.  */
end_comment

begin_function
name|int
name|pop_dropcopy
parameter_list|(
name|POP
modifier|*
name|p
parameter_list|,
name|struct
name|passwd
modifier|*
name|pwp
parameter_list|)
block|{
name|int
name|mfd
decl_stmt|;
comment|/*  File descriptor for                                                         the user's maildrop */
name|int
name|dfd
decl_stmt|;
comment|/*  File descriptor for                                                         the SERVER maildrop */
name|FILE
modifier|*
name|tf
decl_stmt|;
comment|/*  The temp file */
name|char
name|template
index|[
name|POP_TMPSIZE
index|]
decl_stmt|;
comment|/*  Temp name holder */
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/*  Read buffer */
name|long
name|offset
decl_stmt|;
comment|/*  Old/New boundary */
name|int
name|nchar
decl_stmt|;
comment|/*  Bytes written/read */
name|int
name|tf_fd
decl_stmt|;
comment|/*  fd for temp file */
name|int
name|ret
decl_stmt|;
comment|/*  Create a temporary maildrop into which to copy the updated maildrop */
name|snprintf
argument_list|(
name|p
operator|->
name|temp_drop
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|temp_drop
argument_list|)
argument_list|,
name|POP_DROP
argument_list|,
name|p
operator|->
name|user
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|p
operator|->
name|debug
condition|)
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_DEBUG
argument_list|,
literal|"Creating temporary maildrop '%s'"
argument_list|,
name|p
operator|->
name|temp_drop
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* Here we work to make sure the user doesn't cause us to remove or      * write over existing files by limiting how much work we do while      * running as root.      */
name|strlcpy
argument_list|(
name|template
argument_list|,
name|POP_TMPDROP
argument_list|,
sizeof|sizeof
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tf_fd
operator|=
name|mkstemp
argument_list|(
name|template
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|tf
operator|=
name|fdopen
argument_list|(
name|tf_fd
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_PRIORITY
argument_list|,
literal|"Unable to create temporary temporary maildrop '%s': %s"
argument_list|,
name|template
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"System error, can't create temporary file."
argument_list|)
return|;
block|}
comment|/* Now give this file to the user	*/
name|chown
argument_list|(
name|template
argument_list|,
name|pwp
operator|->
name|pw_uid
argument_list|,
name|pwp
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|template
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
comment|/* Now link this file to the temporary maildrop.  If this fails it      * is probably because the temporary maildrop already exists.  If so,      * this is ok.  We can just go on our way, because by the time we try      * to write into the file we will be running as the user.      */
name|link
argument_list|(
name|template
argument_list|,
name|p
operator|->
name|temp_drop
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|ret
operator|=
name|changeuser
argument_list|(
name|p
argument_list|,
name|pwp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|POP_SUCCESS
condition|)
return|return
name|ret
return|;
comment|/* Open for append,  this solves the crash recovery problem */
if|if
condition|(
operator|(
name|dfd
operator|=
name|open
argument_list|(
name|p
operator|->
name|temp_drop
argument_list|,
name|O_RDWR
operator||
name|O_APPEND
operator||
name|O_CREAT
argument_list|,
literal|0600
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_PRIORITY
argument_list|,
literal|"Unable to open temporary maildrop '%s': %s"
argument_list|,
name|p
operator|->
name|temp_drop
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"System error, can't open temporary file, do you own it?"
argument_list|)
return|;
block|}
comment|/*  Lock the temporary maildrop */
if|if
condition|(
name|flock
argument_list|(
name|dfd
argument_list|,
operator|(
name|LOCK_EX
operator||
name|LOCK_NB
operator|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EWOULDBLOCK
case|:
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"%sMaildrop lock busy!  Is another session active?"
argument_list|,
operator|(
name|p
operator|->
name|flags
operator|&
name|POP_FLAG_CAPA
operator|)
condition|?
literal|"[IN-USE] "
else|:
literal|""
argument_list|)
return|;
comment|/* NOTREACHED */
default|default:
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"flock: '%s': %s"
argument_list|,
name|p
operator|->
name|temp_drop
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
comment|/* NOTREACHED */
block|}
comment|/* May have grown or shrunk between open and lock! */
name|offset
operator|=
name|lseek
argument_list|(
name|dfd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
comment|/*  Open the user's maildrop, If this fails,  no harm in assuming empty */
if|if
condition|(
operator|(
name|mfd
operator|=
name|open
argument_list|(
name|p
operator|->
name|drop_name
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/*  Lock the maildrop */
if|if
condition|(
name|flock
argument_list|(
name|mfd
argument_list|,
name|LOCK_EX
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|mfd
argument_list|)
expr_stmt|;
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"flock: '%s': %s"
argument_list|,
name|p
operator|->
name|temp_drop
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
return|;
block|}
comment|/*  Copy the actual mail drop into the temporary mail drop */
while|while
condition|(
operator|(
name|nchar
operator|=
name|read
argument_list|(
name|mfd
argument_list|,
name|buffer
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|nchar
operator|!=
name|write
argument_list|(
name|dfd
argument_list|,
name|buffer
argument_list|,
name|nchar
argument_list|)
condition|)
block|{
name|nchar
operator|=
operator|-
literal|1
expr_stmt|;
break|break ;
block|}
if|if
condition|(
name|nchar
operator|!=
literal|0
condition|)
block|{
comment|/* Error adding new mail.  Truncate to original size,                and leave the maildrop as is.  The user will not                see the new mail until the error goes away.                Should let them process the current backlog,  in case                the error is a quota problem requiring deletions! */
name|ftruncate
argument_list|(
name|dfd
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Mail transferred!  Zero the mail drop NOW,  that we                do not have to do gymnastics to figure out what's new                and what is old later */
name|ftruncate
argument_list|(
name|mfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*  Close the actual mail drop */
name|close
argument_list|(
name|mfd
argument_list|)
expr_stmt|;
block|}
comment|/*  Acquire a stream pointer for the temporary maildrop */
if|if
condition|(
operator|(
name|p
operator|->
name|drop
operator|=
name|fdopen
argument_list|(
name|dfd
argument_list|,
literal|"a+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|dfd
argument_list|)
expr_stmt|;
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"Cannot assign stream for %s"
argument_list|,
name|p
operator|->
name|temp_drop
argument_list|)
return|;
block|}
name|rewind
argument_list|(
name|p
operator|->
name|drop
argument_list|)
expr_stmt|;
return|return
operator|(
name|POP_SUCCESS
operator|)
return|;
block|}
end_function

end_unit

