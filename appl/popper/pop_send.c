begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_include
include|#
directive|include
file|<popper.h>
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  *  sendline:   Send a line of a multi-line response to a client.  */
end_comment

begin_function
specifier|static
name|int
name|pop_sendline
parameter_list|(
name|POP
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|bp
decl_stmt|;
comment|/*  Byte stuff lines that begin with the termination octet */
if|if
condition|(
operator|*
name|buffer
operator|==
name|POP_TERMINATE
condition|)
name|fputc
argument_list|(
name|POP_TERMINATE
argument_list|,
name|p
operator|->
name|output
argument_list|)
expr_stmt|;
comment|/*  Look for a<NL> in the buffer */
if|if
condition|(
operator|(
name|bp
operator|=
name|strchr
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
comment|/*  Send the line to the client */
name|fputs
argument_list|(
name|buffer
argument_list|,
name|p
operator|->
name|output
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|p
operator|->
name|debug
condition|)
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_DEBUG
argument_list|,
literal|"Sending line \"%s\""
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*  Put a<CR><NL> if a newline was removed from the buffer */
if|if
condition|(
name|bp
condition|)
name|fputs
argument_list|(
literal|"\r\n"
argument_list|,
name|p
operator|->
name|output
argument_list|)
expr_stmt|;
return|return
name|bp
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  *  send:   Send the header and a specified number of lines  *          from a mail message to a POP client.  */
end_comment

begin_function
name|int
name|pop_send
parameter_list|(
name|POP
modifier|*
name|p
parameter_list|)
block|{
name|MsgInfoList
modifier|*
name|mp
decl_stmt|;
comment|/*  Pointer to message info list */
name|int
name|msg_num
decl_stmt|;
name|int
name|msg_lines
decl_stmt|;
name|char
name|buffer
index|[
name|MAXMSGLINELEN
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|RETURN_PATH_HANDLING
name|char
modifier|*
name|return_path_adr
decl_stmt|;
name|char
modifier|*
name|return_path_end
decl_stmt|;
name|int
name|return_path_sent
decl_stmt|;
name|int
name|return_path_linlen
decl_stmt|;
endif|#
directive|endif
name|int
name|sent_nl
init|=
literal|0
decl_stmt|;
comment|/*  Convert the first parameter into an integer */
name|msg_num
operator|=
name|atoi
argument_list|(
name|p
operator|->
name|pop_parm
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/*  Is requested message out of range? */
if|if
condition|(
operator|(
name|msg_num
operator|<
literal|1
operator|)
operator|||
operator|(
name|msg_num
operator|>
name|p
operator|->
name|msg_count
operator|)
condition|)
return|return
operator|(
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"Message %d does not exist."
argument_list|,
name|msg_num
argument_list|)
operator|)
return|;
comment|/*  Get a pointer to the message in the message list */
name|mp
operator|=
operator|&
name|p
operator|->
name|mlp
index|[
name|msg_num
operator|-
literal|1
index|]
expr_stmt|;
comment|/*  Is the message flagged for deletion? */
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|DEL_FLAG
condition|)
return|return
operator|(
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"Message %d has been deleted."
argument_list|,
name|msg_num
argument_list|)
operator|)
return|;
comment|/*  If this is a TOP command, get the number of lines to send */
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|pop_command
argument_list|,
literal|"top"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*  Convert the second parameter into an integer */
name|msg_lines
operator|=
name|atoi
argument_list|(
name|p
operator|->
name|pop_parm
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  Assume that a RETR (retrieve) command was issued */
name|msg_lines
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*  Flag the message as retreived */
name|mp
operator|->
name|flags
operator||=
name|RETR_FLAG
expr_stmt|;
block|}
comment|/*  Display the number of bytes in the message */
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_SUCCESS
argument_list|,
literal|"%ld octets"
argument_list|,
name|mp
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_MAILDIR
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|int
name|e
init|=
name|pop_maildir_open
argument_list|(
name|p
argument_list|,
name|mp
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|!=
name|POP_SUCCESS
condition|)
return|return
name|e
return|;
block|}
comment|/*  Position to the start of the message */
name|fseek
argument_list|(
name|p
operator|->
name|drop
argument_list|,
name|mp
operator|->
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|return_path_sent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|IS_MAILDIR
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/*  Skip the first line (the sendmail "From" line) */
name|fgets
argument_list|(
name|buffer
argument_list|,
name|MAXMSGLINELEN
argument_list|,
name|p
operator|->
name|drop
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RETURN_PATH_HANDLING
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|return_path_linlen
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|return_path_adr
operator|=
name|buffer
operator|+
literal|5
init|;
operator|(
operator|*
name|return_path_adr
operator|==
literal|' '
operator|||
operator|*
name|return_path_adr
operator|==
literal|'\t'
operator|)
operator|&&
name|return_path_adr
operator|<
name|buffer
operator|+
name|return_path_linlen
condition|;
name|return_path_adr
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|return_path_adr
operator|<
name|buffer
operator|+
name|return_path_linlen
condition|)
block|{
if|if
condition|(
operator|(
name|return_path_end
operator|=
name|strchr
argument_list|(
name|return_path_adr
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|return_path_end
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|return_path_adr
argument_list|)
operator|!=
literal|0
operator|&&
operator|*
name|return_path_adr
operator|!=
literal|'\n'
condition|)
block|{
specifier|static
name|char
name|tmpbuf
index|[
name|MAXMSGLINELEN
operator|+
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|snprintf
argument_list|(
name|tmpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
argument_list|,
literal|"Return-Path: %s\n"
argument_list|,
name|return_path_adr
argument_list|)
operator|<
name|MAXMSGLINELEN
condition|)
block|{
name|pop_sendline
argument_list|(
name|p
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|hangup
condition|)
return|return
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"SIGHUP or SIGPIPE flagged"
argument_list|)
return|;
name|return_path_sent
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
block|}
comment|/*  Send the header of the message followed by a blank line */
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
name|MAXMSGLINELEN
argument_list|,
name|p
operator|->
name|drop
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|RETURN_PATH_HANDLING
comment|/* Don't send existing Return-Path-header if already sent own */
if|if
condition|(
operator|!
name|return_path_sent
operator|||
name|strncasecmp
argument_list|(
name|buffer
argument_list|,
literal|"Return-Path:"
argument_list|,
literal|12
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
name|sent_nl
operator|=
name|pop_sendline
argument_list|(
name|p
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|/*  A single newline (blank line) signals the             end of the header.  sendline() converts this to a NULL,             so that's what we look for. */
if|if
condition|(
operator|*
name|buffer
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|hangup
condition|)
return|return
operator|(
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"SIGHUP or SIGPIPE flagged"
argument_list|)
operator|)
return|;
block|}
comment|/*  Send the message body */
block|{
name|int
name|blank_line
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
name|MAXMSGLINELEN
operator|-
literal|1
argument_list|,
name|p
operator|->
name|drop
argument_list|)
condition|)
block|{
comment|/*  Look for the start of the next message */
if|if
condition|(
operator|!
name|IS_MAILDIR
argument_list|(
name|p
argument_list|)
operator|&&
name|blank_line
operator|&&
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|blank_line
operator|=
operator|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/*  Decrement the lines sent (for a TOP command) */
if|if
condition|(
name|msg_lines
operator|>=
literal|0
operator|&&
name|msg_lines
operator|--
operator|==
literal|0
condition|)
break|break;
name|sent_nl
operator|=
name|pop_sendline
argument_list|(
name|p
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|hangup
condition|)
return|return
operator|(
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"SIGHUP or SIGPIPE flagged"
argument_list|)
operator|)
return|;
block|}
comment|/* add missing newline at end */
if|if
condition|(
operator|!
name|sent_nl
condition|)
name|fputs
argument_list|(
literal|"\r\n"
argument_list|,
name|p
operator|->
name|output
argument_list|)
expr_stmt|;
comment|/* some pop-clients want a blank line at the end of the            message, we always add one here, but what the heck -- in            outer (white) space, no one can hear you scream */
if|if
condition|(
name|IS_MAILDIR
argument_list|(
name|p
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"\r\n"
argument_list|,
name|p
operator|->
name|output
argument_list|)
expr_stmt|;
block|}
comment|/*  "." signals the end of a multi-line transmission */
name|fputs
argument_list|(
literal|".\r\n"
argument_list|,
name|p
operator|->
name|output
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|p
operator|->
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
name|POP_SUCCESS
operator|)
return|;
block|}
end_function

end_unit

