begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_include
include|#
directive|include
file|<popper.h>
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  *  get_command:    Extract the command from an input line form a POP client  */
end_comment

begin_function_decl
name|int
name|pop_capa
parameter_list|(
name|POP
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|state_table
name|states
index|[]
init|=
block|{
block|{
name|auth1
block|,
literal|"user"
block|,
literal|1
block|,
literal|1
block|,
name|pop_user
block|,
block|{
name|auth1
block|,
name|auth2
block|}
block|}
block|,
block|{
name|auth2
block|,
literal|"pass"
block|,
literal|1
block|,
literal|99
block|,
name|pop_pass
block|,
block|{
name|auth1
block|,
name|trans
block|}
block|}
block|,
ifdef|#
directive|ifdef
name|RPOP
block|{
name|auth2
block|,
literal|"rpop"
block|,
literal|1
block|,
literal|1
block|,
name|pop_rpop
block|,
block|{
name|auth1
block|,
name|trans
block|}
block|}
block|,
endif|#
directive|endif
comment|/* RPOP */
ifdef|#
directive|ifdef
name|SASL
block|{
name|auth1
block|,
literal|"auth"
block|,
literal|1
block|,
literal|2
block|,
name|pop_auth
block|,
block|{
name|auth1
block|,
name|trans
block|}
block|}
block|,
endif|#
directive|endif
block|{
name|auth1
block|,
literal|"quit"
block|,
literal|0
block|,
literal|0
block|,
name|pop_quit
block|,
block|{
name|halt
block|,
name|halt
block|}
block|}
block|,
block|{
name|auth2
block|,
literal|"quit"
block|,
literal|0
block|,
literal|0
block|,
name|pop_quit
block|,
block|{
name|halt
block|,
name|halt
block|}
block|}
block|,
ifdef|#
directive|ifdef
name|CAPA
block|{
name|auth1
block|,
literal|"capa"
block|,
literal|0
block|,
literal|0
block|,
name|pop_capa
block|,
block|{
name|auth1
block|,
name|auth1
block|}
block|}
block|,
block|{
name|auth2
block|,
literal|"capa"
block|,
literal|0
block|,
literal|0
block|,
name|pop_capa
block|,
block|{
name|auth2
block|,
name|auth2
block|}
block|}
block|,
block|{
name|trans
block|,
literal|"capa"
block|,
literal|0
block|,
literal|0
block|,
name|pop_capa
block|,
block|{
name|trans
block|,
name|trans
block|}
block|}
block|,
endif|#
directive|endif
block|{
name|trans
block|,
literal|"stat"
block|,
literal|0
block|,
literal|0
block|,
name|pop_stat
block|,
block|{
name|trans
block|,
name|trans
block|}
block|}
block|,
block|{
name|trans
block|,
literal|"list"
block|,
literal|0
block|,
literal|1
block|,
name|pop_list
block|,
block|{
name|trans
block|,
name|trans
block|}
block|}
block|,
block|{
name|trans
block|,
literal|"retr"
block|,
literal|1
block|,
literal|1
block|,
name|pop_send
block|,
block|{
name|trans
block|,
name|trans
block|}
block|}
block|,
block|{
name|trans
block|,
literal|"dele"
block|,
literal|1
block|,
literal|1
block|,
name|pop_dele
block|,
block|{
name|trans
block|,
name|trans
block|}
block|}
block|,
block|{
name|trans
block|,
literal|"noop"
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
block|{
name|trans
block|,
name|trans
block|}
block|}
block|,
block|{
name|trans
block|,
literal|"rset"
block|,
literal|0
block|,
literal|0
block|,
name|pop_rset
block|,
block|{
name|trans
block|,
name|trans
block|}
block|}
block|,
block|{
name|trans
block|,
literal|"top"
block|,
literal|2
block|,
literal|2
block|,
name|pop_send
block|,
block|{
name|trans
block|,
name|trans
block|}
block|}
block|,
block|{
name|trans
block|,
literal|"last"
block|,
literal|0
block|,
literal|0
block|,
name|pop_last
block|,
block|{
name|trans
block|,
name|trans
block|}
block|}
block|,
block|{
name|trans
block|,
literal|"quit"
block|,
literal|0
block|,
literal|0
block|,
name|pop_updt
block|,
block|{
name|halt
block|,
name|halt
block|}
block|}
block|,
block|{
name|trans
block|,
literal|"help"
block|,
literal|0
block|,
literal|0
block|,
name|pop_help
block|,
block|{
name|trans
block|,
name|trans
block|}
block|}
block|,
ifdef|#
directive|ifdef
name|UIDL
block|{
name|trans
block|,
literal|"uidl"
block|,
literal|0
block|,
literal|1
block|,
name|pop_uidl
block|,
block|{
name|trans
block|,
name|trans
block|}
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XOVER
block|{
name|trans
block|,
literal|"xover"
block|,
literal|0
block|,
literal|0
block|,
name|pop_xover
block|,
block|{
name|trans
block|,
name|trans
block|}
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XDELE
block|{
name|trans
block|,
literal|"xdele"
block|,
literal|1
block|,
literal|2
block|,
name|pop_xdele
block|,
block|{
name|trans
block|,
name|trans
block|}
block|}
block|,
endif|#
directive|endif
block|{
operator|(
name|state
operator|)
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
block|{
name|halt
block|,
name|halt
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pop_capa
parameter_list|(
name|POP
modifier|*
name|p
parameter_list|)
block|{
comment|/*  Search for the POP command in the command/state table */
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_SUCCESS
argument_list|,
literal|"Capability list follows"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|auth_level
operator|==
name|AUTH_NONE
operator|||
name|p
operator|->
name|auth_level
operator|==
name|AUTH_OTP
condition|)
name|fprintf
argument_list|(
name|p
operator|->
name|output
argument_list|,
literal|"USER\r\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|output
argument_list|,
literal|"TOP\r\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|output
argument_list|,
literal|"PIPELINING\r\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|output
argument_list|,
literal|"EXPIRE NEVER\r\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|output
argument_list|,
literal|"RESP-CODES\r\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SASL
name|pop_capa_sasl
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UIDL
name|fprintf
argument_list|(
name|p
operator|->
name|output
argument_list|,
literal|"UIDL\r\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XOVER
name|fprintf
argument_list|(
name|p
operator|->
name|output
argument_list|,
literal|"XOVER\r\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XDELE
name|fprintf
argument_list|(
name|p
operator|->
name|output
argument_list|,
literal|"XDELE\r\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|CurrentState
operator|==
name|trans
condition|)
name|fprintf
argument_list|(
name|p
operator|->
name|output
argument_list|,
literal|"IMPLEMENTATION %s-%s\r\n"
argument_list|,
name|PACKAGE
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|p
operator|->
name|output
argument_list|,
literal|".\r\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|p
operator|->
name|output
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|POP_FLAG_CAPA
expr_stmt|;
return|return
operator|(
name|POP_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|state_table
modifier|*
name|pop_get_command
parameter_list|(
name|POP
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|mp
parameter_list|)
block|{
name|state_table
modifier|*
name|s
decl_stmt|;
name|char
name|buf
index|[
name|MAXMSGLINELEN
index|]
decl_stmt|;
comment|/*  Save a copy of the original client line */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|p
operator|->
name|debug
condition|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|mp
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*  Parse the message into the parameter array */
if|if
condition|(
operator|(
name|p
operator|->
name|parm_count
operator|=
name|pop_parse
argument_list|(
name|p
argument_list|,
name|mp
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/*  Do not log cleartext passwords */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|p
operator|->
name|debug
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|pop_command
argument_list|,
literal|"pass"
argument_list|)
operator|==
literal|0
condition|)
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_DEBUG
argument_list|,
literal|"Received: \"%s xxxxxxxxx\""
argument_list|,
name|p
operator|->
name|pop_command
argument_list|)
expr_stmt|;
else|else
block|{
comment|/*  Remove trailing<LF> */
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pop_log
argument_list|(
name|p
argument_list|,
name|POP_DEBUG
argument_list|,
literal|"Received: \"%s\""
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* DEBUG */
comment|/*  Search for the POP command in the command/state table */
for|for
control|(
name|s
operator|=
name|states
init|;
name|s
operator|->
name|command
condition|;
name|s
operator|++
control|)
block|{
comment|/*  Is this a valid command for the current operating state? */
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|command
argument_list|,
name|p
operator|->
name|pop_command
argument_list|)
operator|==
literal|0
operator|&&
name|s
operator|->
name|ValidCurrentState
operator|==
name|p
operator|->
name|CurrentState
condition|)
block|{
comment|/*  Were too few parameters passed to the command? */
if|if
condition|(
name|p
operator|->
name|parm_count
operator|<
name|s
operator|->
name|min_parms
condition|)
block|{
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"Too few arguments for the %s command."
argument_list|,
name|p
operator|->
name|pop_command
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*  Were too many parameters passed to the command? */
if|if
condition|(
name|p
operator|->
name|parm_count
operator|>
name|s
operator|->
name|max_parms
condition|)
block|{
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"Too many arguments for the %s command."
argument_list|,
name|p
operator|->
name|pop_command
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*  Return a pointer to the entry for this command in                 the command/state table */
return|return
operator|(
name|s
operator|)
return|;
block|}
block|}
comment|/*  The client command was not located in the command/state table */
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_FAILURE
argument_list|,
literal|"Unknown command: \"%s\"."
argument_list|,
name|p
operator|->
name|pop_command
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|pop_help
parameter_list|(
name|POP
modifier|*
name|p
parameter_list|)
block|{
name|state_table
modifier|*
name|s
decl_stmt|;
name|pop_msg
argument_list|(
name|p
argument_list|,
name|POP_SUCCESS
argument_list|,
literal|"help"
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|states
init|;
name|s
operator|->
name|command
condition|;
name|s
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|p
operator|->
name|output
argument_list|,
literal|"%s\r\n"
argument_list|,
name|s
operator|->
name|command
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|p
operator|->
name|output
argument_list|,
literal|".\r\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|p
operator|->
name|output
argument_list|)
expr_stmt|;
return|return
name|POP_SUCCESS
return|;
block|}
end_function

end_unit

