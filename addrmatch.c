begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: addrmatch.c,v 1.9 2014/01/19 11:21:51 dtucker Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2004-2008 Damien Miller<djm@mindrot.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"match.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_struct
struct|struct
name|xaddr
block|{
name|sa_family_t
name|af
decl_stmt|;
union|union
block|{
name|struct
name|in_addr
name|v4
decl_stmt|;
name|struct
name|in6_addr
name|v6
decl_stmt|;
name|u_int8_t
name|addr8
index|[
literal|16
index|]
decl_stmt|;
name|u_int32_t
name|addr32
index|[
literal|4
index|]
decl_stmt|;
block|}
name|xa
union|;
comment|/* 128-bit address */
name|u_int32_t
name|scope_id
decl_stmt|;
comment|/* iface scope id for v6 */
define|#
directive|define
name|v4
value|xa.v4
define|#
directive|define
name|v6
value|xa.v6
define|#
directive|define
name|addr8
value|xa.addr8
define|#
directive|define
name|addr32
value|xa.addr32
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|addr_unicast_masklen
parameter_list|(
name|int
name|af
parameter_list|)
block|{
switch|switch
condition|(
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
return|return
literal|32
return|;
case|case
name|AF_INET6
case|:
return|return
literal|128
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|masklen_valid
parameter_list|(
name|int
name|af
parameter_list|,
name|u_int
name|masklen
parameter_list|)
block|{
switch|switch
condition|(
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
return|return
name|masklen
operator|<=
literal|32
condition|?
literal|0
else|:
operator|-
literal|1
return|;
case|case
name|AF_INET6
case|:
return|return
name|masklen
operator|<=
literal|128
condition|?
literal|0
else|:
operator|-
literal|1
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Convert struct sockaddr to struct xaddr  * Returns 0 on success, -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|addr_sa_to_xaddr
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|socklen_t
name|slen
parameter_list|,
name|struct
name|xaddr
modifier|*
name|xa
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|in4
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|in6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
decl_stmt|;
name|memset
argument_list|(
name|xa
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xa
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|slen
operator|<
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|in4
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|xa
operator|->
name|af
operator|=
name|AF_INET
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|xa
operator|->
name|v4
argument_list|,
operator|&
name|in4
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|xa
operator|->
name|v4
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|slen
operator|<
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|in6
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|xa
operator|->
name|af
operator|=
name|AF_INET6
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|xa
operator|->
name|v6
argument_list|,
operator|&
name|in6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|xa
operator|->
name|v6
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID
name|xa
operator|->
name|scope_id
operator|=
name|in6
operator|->
name|sin6_scope_id
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate a netmask of length 'l' for address family 'af' and  * store it in 'n'.  * Returns 0 on success, -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|addr_netmask
parameter_list|(
name|int
name|af
parameter_list|,
name|u_int
name|l
parameter_list|,
name|struct
name|xaddr
modifier|*
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|masklen_valid
argument_list|(
name|af
argument_list|,
name|l
argument_list|)
operator|!=
literal|0
operator|||
name|n
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|n
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
name|n
operator|->
name|af
operator|=
name|AF_INET
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|n
operator|->
name|v4
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
operator|(
literal|0xffffffff
operator|<<
operator|(
literal|32
operator|-
name|l
operator|)
operator|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|AF_INET6
case|:
name|n
operator|->
name|af
operator|=
name|AF_INET6
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|l
operator|>=
literal|32
condition|;
name|i
operator|++
operator|,
name|l
operator|-=
literal|32
control|)
name|n
operator|->
name|addr32
index|[
name|i
index|]
operator|=
literal|0xffffffffU
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|4
operator|&&
name|l
operator|!=
literal|0
condition|)
name|n
operator|->
name|addr32
index|[
name|i
index|]
operator|=
name|htonl
argument_list|(
operator|(
literal|0xffffffff
operator|<<
operator|(
literal|32
operator|-
name|l
operator|)
operator|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Perform logical AND of addresses 'a' and 'b', storing result in 'dst'.  * Returns 0 on success, -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|addr_and
parameter_list|(
name|struct
name|xaddr
modifier|*
name|dst
parameter_list|,
specifier|const
name|struct
name|xaddr
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|xaddr
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
operator|||
name|a
operator|==
name|NULL
operator|||
name|b
operator|==
name|NULL
operator|||
name|a
operator|->
name|af
operator|!=
name|b
operator|->
name|af
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|a
operator|->
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
name|dst
operator|->
name|v4
operator|.
name|s_addr
operator|&=
name|b
operator|->
name|v4
operator|.
name|s_addr
expr_stmt|;
return|return
literal|0
return|;
case|case
name|AF_INET6
case|:
name|dst
operator|->
name|scope_id
operator|=
name|a
operator|->
name|scope_id
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|dst
operator|->
name|addr32
index|[
name|i
index|]
operator|&=
name|b
operator|->
name|addr32
index|[
name|i
index|]
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compare addresses 'a' and 'b'  * Return 0 if addresses are identical, -1 if (a< b) or 1 if (a> b)  */
end_comment

begin_function
specifier|static
name|int
name|addr_cmp
parameter_list|(
specifier|const
name|struct
name|xaddr
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|xaddr
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|af
operator|!=
name|b
operator|->
name|af
condition|)
return|return
name|a
operator|->
name|af
operator|==
name|AF_INET6
condition|?
literal|1
else|:
operator|-
literal|1
return|;
switch|switch
condition|(
name|a
operator|->
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|a
operator|->
name|v4
operator|.
name|s_addr
operator|==
name|b
operator|->
name|v4
operator|.
name|s_addr
condition|)
return|return
literal|0
return|;
return|return
name|ntohl
argument_list|(
name|a
operator|->
name|v4
operator|.
name|s_addr
argument_list|)
operator|>
name|ntohl
argument_list|(
name|b
operator|->
name|v4
operator|.
name|s_addr
argument_list|)
condition|?
literal|1
else|:
operator|-
literal|1
return|;
case|case
name|AF_INET6
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|a
operator|->
name|addr8
index|[
name|i
index|]
operator|-
name|b
operator|->
name|addr8
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
name|a
operator|->
name|addr8
index|[
name|i
index|]
operator|>
name|b
operator|->
name|addr8
index|[
name|i
index|]
condition|?
literal|1
else|:
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|scope_id
operator|==
name|b
operator|->
name|scope_id
condition|)
return|return
literal|0
return|;
return|return
name|a
operator|->
name|scope_id
operator|>
name|b
operator|->
name|scope_id
condition|?
literal|1
else|:
operator|-
literal|1
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse string address 'p' into 'n'  * Returns 0 on success, -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|addr_pton
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|struct
name|xaddr
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_NUMERICHOST
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|getaddrinfo
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ai
operator|==
name|NULL
operator|||
name|ai
operator|->
name|ai_addr
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|n
operator|!=
name|NULL
operator|&&
name|addr_sa_to_xaddr
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|,
name|n
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Perform bitwise negation of address  * Returns 0 on success, -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|addr_invert
parameter_list|(
name|struct
name|xaddr
modifier|*
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|n
operator|->
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
name|n
operator|->
name|v4
operator|.
name|s_addr
operator|=
operator|~
name|n
operator|->
name|v4
operator|.
name|s_addr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|AF_INET6
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|n
operator|->
name|addr32
index|[
name|i
index|]
operator|=
operator|~
name|n
operator|->
name|addr32
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Calculate a netmask of length 'l' for address family 'af' and  * store it in 'n'.  * Returns 0 on success, -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|addr_hostmask
parameter_list|(
name|int
name|af
parameter_list|,
name|u_int
name|l
parameter_list|,
name|struct
name|xaddr
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
name|addr_netmask
argument_list|(
name|af
argument_list|,
name|l
argument_list|,
name|n
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|addr_invert
argument_list|(
name|n
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test whether address 'a' is all zeros (i.e. 0.0.0.0 or ::)  * Returns 0 on if address is all-zeros, -1 if not all zeros or on failure.  */
end_comment

begin_function
specifier|static
name|int
name|addr_is_all0s
parameter_list|(
specifier|const
name|struct
name|xaddr
modifier|*
name|a
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|a
operator|->
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
return|return
operator|(
name|a
operator|->
name|v4
operator|.
name|s_addr
operator|==
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
case|case
name|AF_INET6
case|:
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|a
operator|->
name|addr32
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Test whether host portion of address 'a', as determined by 'masklen'  * is all zeros.  * Returns 0 on if host portion of address is all-zeros,  * -1 if not all zeros or on failure.  */
end_comment

begin_function
specifier|static
name|int
name|addr_host_is_all0s
parameter_list|(
specifier|const
name|struct
name|xaddr
modifier|*
name|a
parameter_list|,
name|u_int
name|masklen
parameter_list|)
block|{
name|struct
name|xaddr
name|tmp_addr
decl_stmt|,
name|tmp_mask
decl_stmt|,
name|tmp_result
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp_addr
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_hostmask
argument_list|(
name|a
operator|->
name|af
argument_list|,
name|masklen
argument_list|,
operator|&
name|tmp_mask
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|addr_and
argument_list|(
operator|&
name|tmp_result
argument_list|,
operator|&
name|tmp_addr
argument_list|,
operator|&
name|tmp_mask
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|addr_is_all0s
argument_list|(
operator|&
name|tmp_result
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a CIDR address (x.x.x.x/y or xxxx:yyyy::/z).  * Return -1 on parse error, -2 on inconsistency or 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|addr_pton_cidr
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|struct
name|xaddr
modifier|*
name|n
parameter_list|,
name|u_int
modifier|*
name|l
parameter_list|)
block|{
name|struct
name|xaddr
name|tmp
decl_stmt|;
name|long
name|unsigned
name|int
name|masklen
init|=
literal|999
decl_stmt|;
name|char
name|addrbuf
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|mp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
comment|/* Don't modify argument */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|strlcpy
argument_list|(
name|addrbuf
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|mp
operator|=
name|strchr
argument_list|(
name|addrbuf
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|mp
operator|=
literal|'\0'
expr_stmt|;
name|mp
operator|++
expr_stmt|;
name|masklen
operator|=
name|strtoul
argument_list|(
name|mp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
literal|'\0'
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
operator|||
name|masklen
operator|>
literal|128
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|addr_pton
argument_list|(
name|addrbuf
argument_list|,
operator|&
name|tmp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
name|masklen
operator|=
name|addr_unicast_masklen
argument_list|(
name|tmp
operator|.
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|masklen_valid
argument_list|(
name|tmp
operator|.
name|af
argument_list|,
name|masklen
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|2
return|;
if|if
condition|(
name|addr_host_is_all0s
argument_list|(
operator|&
name|tmp
argument_list|,
name|masklen
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|2
return|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|n
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|!=
name|NULL
condition|)
operator|*
name|l
operator|=
name|masklen
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|addr_netmatch
parameter_list|(
specifier|const
name|struct
name|xaddr
modifier|*
name|host
parameter_list|,
specifier|const
name|struct
name|xaddr
modifier|*
name|net
parameter_list|,
name|u_int
name|masklen
parameter_list|)
block|{
name|struct
name|xaddr
name|tmp_mask
decl_stmt|,
name|tmp_result
decl_stmt|;
if|if
condition|(
name|host
operator|->
name|af
operator|!=
name|net
operator|->
name|af
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|addr_netmask
argument_list|(
name|host
operator|->
name|af
argument_list|,
name|masklen
argument_list|,
operator|&
name|tmp_mask
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|addr_and
argument_list|(
operator|&
name|tmp_result
argument_list|,
name|host
argument_list|,
operator|&
name|tmp_mask
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|addr_cmp
argument_list|(
operator|&
name|tmp_result
argument_list|,
name|net
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Match "addr" against list pattern list "_list", which may contain a  * mix of CIDR addresses and old-school wildcards.  *  * If addr is NULL, then no matching is performed, but _list is parsed  * and checked for well-formedness.  *  * Returns 1 on match found (never returned when addr == NULL).  * Returns 0 on if no match found, or no errors found when addr == NULL.  * Returns -1 on negated match found (never returned when addr == NULL).  * Returns -2 on invalid list entry.  */
end_comment

begin_function
name|int
name|addr_match_list
parameter_list|(
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|_list
parameter_list|)
block|{
name|char
modifier|*
name|list
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|o
decl_stmt|;
name|struct
name|xaddr
name|try_addr
decl_stmt|,
name|match_addr
decl_stmt|;
name|u_int
name|masklen
decl_stmt|,
name|neg
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
name|addr
operator|!=
name|NULL
operator|&&
name|addr_pton
argument_list|(
name|addr
argument_list|,
operator|&
name|try_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"%s: couldn't parse address %.100s"
argument_list|,
name|__func__
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|o
operator|=
name|list
operator|=
name|strdup
argument_list|(
name|_list
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|list
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|neg
operator|=
operator|*
name|cp
operator|==
literal|'!'
expr_stmt|;
if|if
condition|(
name|neg
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|ret
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
comment|/* Prefer CIDR address matching */
name|r
operator|=
name|addr_pton_cidr
argument_list|(
name|cp
argument_list|,
operator|&
name|match_addr
argument_list|,
operator|&
name|masklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"Inconsistent mask length for "
literal|"network \"%.100s\""
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|addr
operator|!=
name|NULL
operator|&&
name|addr_netmatch
argument_list|(
operator|&
name|try_addr
argument_list|,
operator|&
name|match_addr
argument_list|,
name|masklen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|foundit
label|:
if|if
condition|(
name|neg
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
else|else
block|{
comment|/* If CIDR parse failed, try wildcard string match */
if|if
condition|(
name|addr
operator|!=
name|NULL
operator|&&
name|match_pattern
argument_list|(
name|addr
argument_list|,
name|cp
argument_list|)
operator|==
literal|1
condition|)
goto|goto
name|foundit
goto|;
block|}
block|}
name|free
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Match "addr" against list CIDR list "_list". Lexical wildcards and  * negation are not supported. If "addr" == NULL, will verify structure  * of "_list".  *  * Returns 1 on match found (never returned when addr == NULL).  * Returns 0 on if no match found, or no errors found when addr == NULL.  * Returns -1 on error  */
end_comment

begin_function
name|int
name|addr_match_cidr_list
parameter_list|(
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|_list
parameter_list|)
block|{
name|char
modifier|*
name|list
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|o
decl_stmt|;
name|struct
name|xaddr
name|try_addr
decl_stmt|,
name|match_addr
decl_stmt|;
name|u_int
name|masklen
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
name|addr
operator|!=
name|NULL
operator|&&
name|addr_pton
argument_list|(
name|addr
argument_list|,
operator|&
name|try_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|debug2
argument_list|(
literal|"%s: couldn't parse address %.100s"
argument_list|,
name|__func__
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|o
operator|=
name|list
operator|=
name|strdup
argument_list|(
name|_list
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|list
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"%s: empty entry in list \"%.100s\""
argument_list|,
name|__func__
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 		 * NB. This function is called in pre-auth with untrusted data, 		 * so be extra paranoid about junk reaching getaddrino (via 		 * addr_pton_cidr). 		 */
comment|/* Stop junk from reaching getaddrinfo. +3 is for masklen */
if|if
condition|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|>
name|INET6_ADDRSTRLEN
operator|+
literal|3
condition|)
block|{
name|error
argument_list|(
literal|"%s: list entry \"%.100s\" too long"
argument_list|,
name|__func__
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
define|#
directive|define
name|VALID_CIDR_CHARS
value|"0123456789abcdefABCDEF.:/"
if|if
condition|(
name|strspn
argument_list|(
name|cp
argument_list|,
name|VALID_CIDR_CHARS
argument_list|)
operator|!=
name|strlen
argument_list|(
name|cp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%s: list entry \"%.100s\" contains invalid "
literal|"characters"
argument_list|,
name|__func__
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Prefer CIDR address matching */
name|r
operator|=
name|addr_pton_cidr
argument_list|(
name|cp
argument_list|,
operator|&
name|match_addr
argument_list|,
operator|&
name|masklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Invalid network entry \"%.100s\""
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
operator|-
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"Inconsistent mask length for "
literal|"network \"%.100s\""
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|addr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|addr_netmatch
argument_list|(
operator|&
name|try_addr
argument_list|,
operator|&
name|match_addr
argument_list|,
name|masklen
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
name|free
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

