begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* 	netrc.c  	procedures to read and parse the .netrc file  	You may call: 		commandfile() 		to read the file. 		rdnetfile(cfile)	to read the file.  Note: 	commandfile() 		will read the passwd file 		if getenv(HOME) searches the passwd file  Table of netrc options 	option			default 	------			------- 	default			default machine 	login string		current login 	password string		- 	notify yes/no		yes 	write yes/no		yes 	command string		- 	force yes/no		no  Fabry has suggested that machine names be more general: that you be able to say:  	cory:	fabry on Cory 	caf:	caf on Cory 	c:	fabry on C  so the formulation would look like:  	default key 	key: machine login passwd ... 	key: ....  and so on  Gould has suggested the format be:  	pseudo cory 	real Cory 	login fabry 	pseudo caf 	real Cory 	login caf 	pseudo c 	real C 		login fabry  Init file example: format local C remote A  	default A 	machine A    local C link /dev/net-A    speed 9 	machine Cory local C link /dev/net-Cory speed 9 	 if remote == 0, default is A also options: 	vaxtovax, length, debug  speed: speeds baud setting 	300	7 	1200	9 	9600	13 onlyuid: 	should be a decimal uid, as returned by getuid() 	if 0 is considered ignored.  passwords work as follows:    passwd = "\n" means no password  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* tokens, returned by parser */
end_comment

begin_define
define|#
directive|define
name|MACHINE
value|1
end_define

begin_define
define|#
directive|define
name|LOGIN
value|2
end_define

begin_define
define|#
directive|define
name|PASSWORD
value|3
end_define

begin_define
define|#
directive|define
name|ONLYUID
value|4
end_define

begin_define
define|#
directive|define
name|NOTIFY
value|5
end_define

begin_define
define|#
directive|define
name|COMMAND
value|7
end_define

begin_define
define|#
directive|define
name|ID
value|8
end_define

begin_define
define|#
directive|define
name|YES
value|9
end_define

begin_define
define|#
directive|define
name|DEFAULT
value|10
end_define

begin_define
define|#
directive|define
name|WRITE
value|11
end_define

begin_define
define|#
directive|define
name|NO
value|12
end_define

begin_define
define|#
directive|define
name|FORCE
value|13
end_define

begin_define
define|#
directive|define
name|LOCALTOK
value|14
end_define

begin_define
define|#
directive|define
name|LINK
value|15
end_define

begin_define
define|#
directive|define
name|SPEED
value|16
end_define

begin_define
define|#
directive|define
name|VAXTOVAX
value|17
end_define

begin_define
define|#
directive|define
name|LENGTH
value|18
end_define

begin_define
define|#
directive|define
name|DEBUGTOK
value|19
end_define

begin_define
define|#
directive|define
name|ALTIME
value|20
end_define

begin_define
define|#
directive|define
name|ALCOUNT
value|21
end_define

begin_comment
comment|/* global */
end_comment

begin_decl_stmt
name|char
name|vaxtovax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linkspeed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|local
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxbread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|atime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|device
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|datasize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|onlyuid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tokval
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|tokstruct
block|{
name|char
modifier|*
name|tokstr
decl_stmt|;
name|int
name|tval
decl_stmt|;
block|}
name|toktab
index|[]
init|=
block|{
literal|"machine"
block|,
name|MACHINE
block|,
literal|"login"
block|,
name|LOGIN
block|,
literal|"password"
block|,
name|PASSWORD
block|,
literal|"onlyuid"
block|,
name|ONLYUID
block|,
literal|"notify"
block|,
name|NOTIFY
block|,
literal|"command"
block|,
name|COMMAND
block|,
literal|"yes"
block|,
name|YES
block|,
literal|"y"
block|,
name|YES
block|,
literal|"no"
block|,
name|NO
block|,
literal|"n"
block|,
name|NO
block|,
literal|"default"
block|,
name|DEFAULT
block|,
literal|"write"
block|,
name|WRITE
block|,
literal|"force"
block|,
name|FORCE
block|,
literal|"local"
block|,
name|LOCALTOK
block|,
literal|"speed"
block|,
name|SPEED
block|,
literal|"link"
block|,
name|LINK
block|,
literal|"vaxtovax"
block|,
name|VAXTOVAX
block|,
literal|"length"
block|,
name|LENGTH
block|,
literal|"debug"
block|,
name|DEBUGTOK
block|,
literal|"time"
block|,
name|ALTIME
block|,
literal|"count"
block|,
name|ALCOUNT
block|,
literal|0
block|,
literal|0
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|stat
name|statbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	commandfile()  	this procedure reads in and parses the .netrc file. 	when you call this, if the remote machine is to be explicitely 	set, the global variable "remote" must have a value. 	on return, if it is non-zero, "remote" will have the 	remote machine the data was collected for. 	status.localname need not have a value. */
end_comment

begin_macro
name|commandfile
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|hdir
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|hdir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdir
operator|==
name|NULL
condition|)
name|hdir
operator|=
literal|"."
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/.netrc"
argument_list|,
name|hdir
argument_list|)
expr_stmt|;
comment|/* 	debug("file %s",buf); */
name|cfile
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfile
operator|==
name|NULL
condition|)
return|return;
name|rdnetfile
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	read the file cfile and parse */
end_comment

begin_macro
name|rdnetfile
argument_list|(
argument|cfile
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|cfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|t
decl_stmt|;
if|if
condition|(
name|cfile
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|cfile
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
literal|0444
operator|)
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
operator|(
name|t
operator|=
name|token
argument_list|(
name|cfile
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|DEFAULT
case|:
if|if
condition|(
name|token
argument_list|(
name|cfile
argument_list|)
operator|==
name|ID
operator|&&
name|remote
operator|==
literal|0
condition|)
name|remote
operator|=
name|lookup
argument_list|(
name|tokval
argument_list|)
expr_stmt|;
comment|/* 			debug("rem %c\n",remote); 			*/
break|break;
case|case
name|MACHINE
case|:
if|if
condition|(
name|remote
operator|==
literal|0
condition|)
name|remote
operator|=
name|getremote
argument_list|(
name|local
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
argument_list|(
name|cfile
argument_list|)
operator|!=
name|ID
condition|)
continue|continue;
if|if
condition|(
name|remote
operator|!=
name|lookup
argument_list|(
name|tokval
argument_list|)
condition|)
continue|continue;
comment|/* this is the entry for the remote mach we want */
name|getnetline
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
break|break;
block|}
block|}
return|return;
block|}
end_block

begin_comment
comment|/* 	read a line of the file */
end_comment

begin_expr_stmt
specifier|static
name|getnetline
argument_list|(
argument|cfile
argument_list|)
name|FILE
operator|*
name|cfile
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|t
decl_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|token
argument_list|(
name|cfile
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|t
condition|)
block|{
comment|/* these options are usually in the .netrc file */
case|case
name|MACHINE
case|:
return|return;
case|case
name|LOGIN
case|:
if|if
condition|(
name|token
argument_list|(
name|cfile
argument_list|)
operator|&&
name|status
operator|.
name|login
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|login
argument_list|,
name|tokval
argument_list|)
expr_stmt|;
break|break;
case|case
name|PASSWORD
case|:
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|cfile
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
literal|077
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"Error - .netrc file not correct mode.\n"
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|"Remove password or correct mode.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
argument_list|(
name|cfile
argument_list|)
operator|&&
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
name|tokval
argument_list|)
expr_stmt|;
comment|/* 			debug("mp:%s:%s\n",status.mpasswd,tokval); 			*/
break|break;
case|case
name|NOTIFY
case|:
name|status
operator|.
name|nonotify
operator|=
name|token
argument_list|(
name|cfile
argument_list|)
operator|==
name|NO
expr_stmt|;
break|break;
case|case
name|WRITE
case|:
name|status
operator|.
name|nowrite
operator|=
name|token
argument_list|(
name|cfile
argument_list|)
operator|==
name|NO
expr_stmt|;
break|break;
case|case
name|COMMAND
case|:
if|if
condition|(
name|token
argument_list|(
name|cfile
argument_list|)
operator|&&
name|status
operator|.
name|defcmd
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|defcmd
argument_list|,
name|tokval
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORCE
case|:
name|status
operator|.
name|force
operator|=
name|token
argument_list|(
name|cfile
argument_list|)
operator|==
name|YES
expr_stmt|;
break|break;
comment|/* these options are usually in /usr/net/initfile */
case|case
name|LOCALTOK
case|:
if|if
condition|(
name|token
argument_list|(
name|cfile
argument_list|)
condition|)
name|local
operator|=
name|lookup
argument_list|(
name|tokval
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINK
case|:
if|if
condition|(
name|token
argument_list|(
name|cfile
argument_list|)
condition|)
name|strcpy
argument_list|(
name|device
argument_list|,
name|tokval
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPEED
case|:
if|if
condition|(
name|token
argument_list|(
name|cfile
argument_list|)
condition|)
name|linkspeed
operator|=
name|atoi
argument_list|(
name|tokval
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAXTOVAX
case|:
name|vaxtovax
operator|++
expr_stmt|;
break|break;
case|case
name|LENGTH
case|:
if|if
condition|(
name|token
argument_list|(
name|cfile
argument_list|)
condition|)
name|datasize
operator|=
name|atoi
argument_list|(
name|tokval
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEBUGTOK
case|:
name|debugflg
operator|++
expr_stmt|;
break|break;
case|case
name|ALTIME
case|:
if|if
condition|(
name|token
argument_list|(
name|cfile
argument_list|)
condition|)
name|atime
operator|=
name|atoi
argument_list|(
name|tokval
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALCOUNT
case|:
if|if
condition|(
name|token
argument_list|(
name|cfile
argument_list|)
condition|)
name|maxbread
operator|=
name|atoi
argument_list|(
name|tokval
argument_list|)
expr_stmt|;
break|break;
case|case
name|ONLYUID
case|:
if|if
condition|(
name|token
argument_list|(
name|cfile
argument_list|)
condition|)
name|onlyuid
operator|=
name|atoi
argument_list|(
name|tokval
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
argument_list|(
literal|"Unknown .netrc option %s\n"
argument_list|,
name|tokval
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|token
argument_list|(
argument|cfile
argument_list|)
name|FILE
operator|*
name|cfile
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* returns next token in cfile, 0 on EOF */
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|cfile
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|cfile
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|','
operator|)
condition|)
empty_stmt|;
comment|/* next char begins token */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
name|tokval
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
comment|/* process quoted string */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|cfile
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|cfile
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tokval
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	debug("tok %s",tokval); */
return|return
operator|(
name|tlookup
argument_list|(
name|tokval
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|tlookup
argument_list|(
argument|str
argument_list|)
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|tokstruct
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|toktab
init|;
name|p
operator|->
name|tokstr
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|streql
argument_list|(
name|p
operator|->
name|tokstr
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|p
operator|->
name|tval
operator|)
return|;
block|}
return|return
operator|(
name|ID
operator|)
return|;
block|}
end_block

end_unit

