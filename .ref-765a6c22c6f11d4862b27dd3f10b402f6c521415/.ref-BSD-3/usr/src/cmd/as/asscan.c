begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"asscan.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|d124
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|exp
modifier|*
name|xp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tokbufdesc
modifier|*
name|bufstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*where the buffer list begins*/
end_comment

begin_decl_stmt
name|struct
name|tokbufdesc
modifier|*
name|buftail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*last one on the list*/
end_comment

begin_decl_stmt
name|struct
name|tokbufdesc
modifier|*
name|emptybuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the one being filled*/
end_comment

begin_define
define|#
directive|define
name|TOKDALLOP
value|8
end_define

begin_decl_stmt
name|int
name|useVM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*keep `tmp' file in virtual memory*/
end_comment

begin_decl_stmt
name|int
name|bufno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*which buffer number: 0,1 for tmp file*/
end_comment

begin_decl_stmt
name|struct
name|tokbufdesc
name|tokbuf
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*our initial increment of buffers*/
end_comment

begin_macro
name|inittmpfile
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|useVM
condition|)
block|{
name|bufstart
operator|=
operator|&
name|tokbuf
index|[
literal|0
index|]
expr_stmt|;
name|buftail
operator|=
operator|&
name|tokbuf
index|[
literal|1
index|]
expr_stmt|;
name|bufstart
operator|->
name|tok_next
operator|=
name|buftail
expr_stmt|;
name|buftail
operator|->
name|tok_next
operator|=
literal|0
expr_stmt|;
block|}
name|tokbuf
index|[
literal|0
index|]
operator|.
name|tok_count
operator|=
operator|-
literal|1
expr_stmt|;
name|tokbuf
index|[
literal|1
index|]
operator|.
name|tok_count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|bufno
operator|=
literal|0
expr_stmt|;
name|emptybuf
operator|=
operator|&
name|tokbuf
index|[
name|bufno
index|]
expr_stmt|;
name|tokptr
operator|=
literal|0
expr_stmt|;
name|tokub
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|closetmpfile
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|useVM
condition|)
block|{
name|emptybuf
operator|->
name|toks
index|[
name|emptybuf
operator|->
name|tok_count
operator|++
index|]
operator|=
name|PARSEEOF
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 *	Clean up the buffers that haven't been 			 *	written out yet 			 */
if|if
condition|(
name|tokbuf
index|[
name|bufno
operator|^
literal|1
index|]
operator|.
name|tok_count
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|tokbuf
index|[
name|bufno
operator|^
literal|1
index|]
argument_list|,
sizeof|sizeof
expr|*
name|emptybuf
argument_list|,
literal|1
argument_list|,
name|tmpfil
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|badwrite
label|:
name|yyerror
argument_list|(
literal|"Unexpected end of file writing the interpass tmp file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 *	Ensure that we will read an End of file, 			 *	if there are more than one file names 			 *	in the argument list 			 */
name|tokbuf
index|[
name|bufno
index|]
operator|.
name|toks
index|[
name|tokbuf
index|[
name|bufno
index|]
operator|.
name|tok_count
operator|++
index|]
operator|=
name|PARSEEOF
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|tokbuf
index|[
name|bufno
index|]
argument_list|,
sizeof|sizeof
expr|*
name|emptybuf
argument_list|,
literal|1
argument_list|,
name|tmpfil
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|badwrite
goto|;
block|}
block|}
comment|/*end of being pass 1*/
block|}
end_block

begin_define
define|#
directive|define
name|bstrlg
parameter_list|(
name|from
parameter_list|,
name|length
parameter_list|)
define|\
value|*(lgtype *)from = length; \ 	(char *)from += sizeof(lgtype) + length
end_define

begin_define
define|#
directive|define
name|bstrfromto
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
define|\
value|*(lgtype *)from = (char *)to - (char *)from - sizeof(lgtype); \ 	(char *)from += sizeof(lgtype) + (char *)to - (char *)from
end_define

begin_define
define|#
directive|define
name|eatstrlg
parameter_list|(
name|from
parameter_list|)
define|\
value|(char *)from +=  sizeof(lgtype) + *(lgtype *)from
end_define

begin_define
define|#
directive|define
name|bskiplg
parameter_list|(
name|from
parameter_list|,
name|length
parameter_list|)
define|\
value|*(lgtype *)from = length; \ 	(char *)from += sizeof(lgtype) + length
end_define

begin_define
define|#
directive|define
name|bskipfromto
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
define|\
value|*(lgtype *)from = (toktype *)to - (toktype *)from - sizeof(lgtype); \ 	(char *)from += sizeof (lgtype) + (toktype *)to - (toktype *)from
end_define

begin_define
define|#
directive|define
name|eatskiplg
parameter_list|(
name|from
parameter_list|)
define|\
value|(toktype *)from += sizeof(lgtype) + *(lgtype *)from
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|ptrall
name|firsttoken
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*global communication with parser*/
end_comment

begin_function
name|toktype
name|yylex
parameter_list|()
block|{
specifier|register
name|ptrall
name|bufptr
decl_stmt|;
specifier|register
name|toktype
name|val
decl_stmt|;
specifier|register
name|struct
name|exp
modifier|*
name|locxp
decl_stmt|;
name|bufptr
operator|=
name|tokptr
expr_stmt|;
comment|/*copy in the global value*/
name|top
label|:
if|if
condition|(
name|bufptr
operator|<
name|tokub
condition|)
block|{
name|gtoken
argument_list|(
name|val
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yylval
operator|=
name|val
condition|)
block|{
case|case
name|PARSEEOF
case|:
name|yylval
operator|=
name|val
operator|=
name|PARSEEOF
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|locxp
operator|=
name|xp
operator|++
expr_stmt|;
name|glong
argument_list|(
name|locxp
operator|->
name|xvalue
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
name|makevalue
label|:
name|locxp
operator|->
name|xtype
operator|=
name|XABS
expr_stmt|;
name|locxp
operator|->
name|xloc
operator|=
literal|0
expr_stmt|;
name|locxp
operator|->
name|xname
operator|=
name|NULL
expr_stmt|;
name|yylval
operator|=
operator|(
name|int
operator|)
name|locxp
expr_stmt|;
break|break;
case|case
name|FLTNUM
case|:
comment|/*case patched on 3-Jan-80*/
name|locxp
operator|=
name|xp
operator|++
expr_stmt|;
name|gdouble
argument_list|(
name|locxp
operator|->
name|doubval
operator|.
name|dvalue
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
comment|/* 					 *	We make sure that locxp->xvalue 					 *	is not in the range suitable for 					 *	a short literal.  The field 					 *	xvalue is only used for 					 *	integers, not doubles, but when 					 *	we test for short literals 					 *	in ascode.c, we look 					 *	at the field xvalue when 					 *	it encounters an in line 					 *	floating number. Ergo, 					 *	give it a bad value. 					 */
name|locxp
operator|->
name|xvalue
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|makevalue
goto|;
case|case
name|NAME
case|:
name|gptr
argument_list|(
name|yylval
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
name|lastnam
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
break|break;
case|case
name|SIZESPEC
case|:
case|case
name|REG
case|:
case|case
name|INSTn
case|:
case|case
name|INST0
case|:
name|gchar
argument_list|(
name|yylval
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IJXXX
case|:
name|gchar
argument_list|(
name|yylval
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
name|gptr
argument_list|(
name|lastjxxx
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ILINESKIP
case|:
name|gint
argument_list|(
name|yylval
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
name|lineno
operator|+=
name|yylval
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|SKIP
case|:
name|eatskiplg
argument_list|(
name|bufptr
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|VOID
case|:
goto|goto
name|top
goto|;
case|case
name|STRING
case|:
name|strptr
operator|=
operator|&
name|strbuf
index|[
name|strno
operator|^=
literal|1
index|]
expr_stmt|;
name|strptr
operator|->
name|str_lg
operator|=
operator|*
operator|(
operator|(
name|lgtype
operator|*
operator|)
name|bufptr
operator|)
expr_stmt|;
name|movestr
argument_list|(
operator|&
name|strptr
operator|->
name|str
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bufptr
operator|+
sizeof|sizeof
argument_list|(
name|lgtype
argument_list|)
argument_list|,
name|strptr
operator|->
name|str_lg
argument_list|)
expr_stmt|;
name|eatstrlg
argument_list|(
name|bufptr
argument_list|)
expr_stmt|;
name|yylval
operator|=
operator|(
name|int
operator|)
name|strptr
expr_stmt|;
break|break;
case|case
name|ISTAB
case|:
case|case
name|ISTABSTR
case|:
case|case
name|ISTABNONE
case|:
case|case
name|ISTABDOT
case|:
case|case
name|IALIGN
case|:
name|gptr
argument_list|(
name|yylval
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*end of the switch*/
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|toktrace
condition|)
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|INT
case|:
name|printf
argument_list|(
literal|"Class integer val %d\n"
argument_list|,
operator|(
operator|(
expr|struct
name|exp
operator|*
operator|)
name|yylval
operator|)
operator|->
name|xvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLTNUM
case|:
name|printf
argument_list|(
literal|"Class floating point num value %4.3f\n"
argument_list|,
operator|(
operator|(
expr|struct
name|exp
operator|*
operator|)
name|yylval
operator|)
operator|->
name|doubval
operator|.
name|dvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME
case|:
name|printf
argument_list|(
literal|"Class name, \"%.8s\"\n"
argument_list|,
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|printf
argument_list|(
literal|"Class register, number %d\n"
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSTn
case|:
name|printf
argument_list|(
literal|"Class INSTn, %.8s\n"
argument_list|,
name|itab
index|[
literal|0xFF
operator|&
name|yylval
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|IJXXX
case|:
name|printf
argument_list|(
literal|"Class IJXXX, %.8s\n"
argument_list|,
name|itab
index|[
literal|0xFF
operator|&
name|yylval
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|INST0
case|:
name|printf
argument_list|(
literal|"Class INST0, %.8s\n"
argument_list|,
name|itab
index|[
literal|0xFF
operator|&
name|yylval
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|printf
argument_list|(
literal|"Class string, length %d\n"
argument_list|,
operator|(
operator|(
expr|struct
name|strdesc
operator|*
operator|)
name|yylval
operator|)
operator|->
name|str_lg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Pass: %d Tok: %d Other class: %d, 0%o, '%c'\n"
argument_list|,
name|passno
argument_list|,
name|bufptr
operator|-
name|firsttoken
argument_list|,
name|val
argument_list|,
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*end of the debug switch*/
endif|#
directive|endif
block|}
comment|/*end of this buffer*/
else|else
block|{
if|if
condition|(
name|useVM
condition|)
block|{
name|bufno
operator|+=
literal|1
expr_stmt|;
name|emptybuf
operator|=
name|emptybuf
operator|->
name|tok_next
expr_stmt|;
if|if
condition|(
name|emptybuf
operator|==
literal|0
condition|)
block|{
name|struct
name|tokbufdesc
modifier|*
name|newdallop
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
goto|goto
name|badread
goto|;
name|emptybuf
operator|=
name|newdallop
operator|=
operator|(
expr|struct
name|tokbufdesc
operator|*
operator|)
name|sbrk
argument_list|(
name|TOKDALLOP
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|tokbufdesc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|emptybuf
operator|==
operator|(
expr|struct
name|tokbufdesc
operator|*
operator|)
operator|-
literal|1
condition|)
goto|goto
name|badwrite
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOKDALLOP
condition|;
name|i
operator|++
control|)
block|{
name|buftail
operator|->
name|tok_next
operator|=
name|newdallop
expr_stmt|;
name|buftail
operator|=
name|newdallop
expr_stmt|;
name|newdallop
operator|+=
literal|1
expr_stmt|;
block|}
name|buftail
operator|->
name|tok_next
operator|=
literal|0
expr_stmt|;
block|}
comment|/*end of need to get more buffers*/
operator|(
name|toktype
operator|*
operator|)
name|bufptr
operator|=
operator|&
operator|(
name|emptybuf
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
name|scan_dot_s
argument_list|(
name|emptybuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*don't use VM*/
name|bufno
operator|^=
literal|1
expr_stmt|;
name|emptybuf
operator|=
operator|&
name|tokbuf
index|[
name|bufno
index|]
expr_stmt|;
operator|(
operator|(
name|toktype
operator|*
operator|)
name|bufptr
operator|)
operator|=
operator|&
operator|(
name|emptybuf
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
comment|/* 				 *	First check if there are things to write 				 *	out at all 				 */
if|if
condition|(
name|emptybuf
operator|->
name|tok_count
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|emptybuf
argument_list|,
sizeof|sizeof
expr|*
name|emptybuf
argument_list|,
literal|1
argument_list|,
name|tmpfil
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|badwrite
label|:
name|yyerror
argument_list|(
literal|"Unexpected end of file writing the interpass tmp file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|scan_dot_s
argument_list|(
name|emptybuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*pass 2*/
if|if
condition|(
name|fread
argument_list|(
name|emptybuf
argument_list|,
sizeof|sizeof
expr|*
name|emptybuf
argument_list|,
literal|1
argument_list|,
name|tmpfil
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|badread
label|:
name|yyerror
argument_list|(
literal|"Unexpected end of file while reading the interpass tmp file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*end of pass2*/
block|}
comment|/*end of using a real live file*/
operator|(
name|char
operator|*
operator|)
name|tokub
operator|=
operator|(
name|char
operator|*
operator|)
name|bufptr
operator|+
name|emptybuf
operator|->
name|tok_count
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|firsttoken
operator|=
name|bufptr
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"created buffernumber %d with %d tokens\n"
argument_list|,
name|bufno
argument_list|,
name|emptybuf
operator|->
name|tok_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|top
goto|;
block|}
comment|/*end of reading/creating a new buffer*/
name|tokptr
operator|=
name|bufptr
expr_stmt|;
comment|/*copy back the global value*/
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*end of yylex*/
end_comment

begin_expr_stmt
name|buildskip
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
specifier|register
name|ptrall
name|from
operator|,
name|to
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|diff
decl_stmt|;
specifier|register
name|int
name|frombufno
decl_stmt|;
specifier|register
name|struct
name|tokbufdesc
modifier|*
name|middlebuf
decl_stmt|;
comment|/* 	 *	check if from and to are in the same buffer 	 *	from and to DIFFER BY AT MOST 1 buffer and to is 	 *	always ahead of from, with to being in the buffer emptybuf 	 *	points to. 	 *	The hard part here is accounting for the case where the 	 *	skip is to cross a buffer boundary; we must construct 	 *	two skips. 	 * 	 *	Figure out where the buffer boundary between from and to is 	 *	It's easy in VM, as buffers increase to high memory, but 	 *	w/o VM, we alternate between two buffers, and want 	 *	to look at the exact middle of the contiguous buffer region. 	 */
name|middlebuf
operator|=
name|useVM
condition|?
name|emptybuf
else|:
operator|&
name|tokbuf
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|toktype
operator|*
operator|)
name|from
operator|>
operator|(
name|toktype
operator|*
operator|)
name|middlebuf
operator|)
operator|^
operator|(
operator|(
name|toktype
operator|*
operator|)
name|to
operator|>
operator|(
name|toktype
operator|*
operator|)
name|middlebuf
operator|)
condition|)
block|{
comment|/*split across a buffer boundary*/
name|ptoken
argument_list|(
name|from
argument_list|,
name|SKIP
argument_list|)
expr_stmt|;
comment|/* 		 *	Set the skip so it lands someplace beyond 		 *	the end of this buffer. 		 *	When we pull this skip out in the second pass, 		 *	we will temporarily move the current pointer 		 *	out beyond the end of the buffer, but immediately 		 *	do a compare and fail the compare, and then reset 		 *	all the pointers correctly to point into the next buffer. 		 */
name|bskiplg
argument_list|(
name|from
argument_list|,
name|TOKBUFLG
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 *	Now, force from to be in the same buffer as to 		 */
operator|(
name|toktype
operator|*
operator|)
name|from
operator|=
operator|(
name|toktype
operator|*
operator|)
operator|&
operator|(
name|emptybuf
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
comment|/* 	 *	Now, to and from are in the same buffer 	 */
if|if
condition|(
name|from
operator|>
name|to
condition|)
name|yyerror
argument_list|(
literal|"Internal error: bad skip construction"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|diff
operator|=
operator|(
name|toktype
operator|*
operator|)
name|to
operator|-
operator|(
name|toktype
operator|*
operator|)
name|from
operator|)
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|toktype
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|lgtype
argument_list|)
operator|+
literal|1
operator|)
condition|)
block|{
name|ptoken
argument_list|(
name|from
argument_list|,
name|SKIP
argument_list|)
expr_stmt|;
name|bskipfromto
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|diff
operator|>
literal|0
condition|;
operator|--
name|diff
control|)
name|ptoken
argument_list|(
name|from
argument_list|,
name|VOID
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|movestr
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|lg
argument_list|)
specifier|register
name|char
operator|*
name|to
operator|,
operator|*
name|from
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|lg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|lg
operator|<=
literal|0
condition|)
return|return;
do|do
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|lg
condition|)
do|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|newfflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|newfname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scanlineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the scanner's linenumber*/
end_comment

begin_macro
name|new_dot_s
argument_list|(
argument|namep
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|namep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|newfflag
operator|=
literal|1
expr_stmt|;
name|newfname
operator|=
name|namep
expr_stmt|;
name|dotsname
operator|=
name|namep
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|scanlineno
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	Maps characters to their use in assembly language  */
end_comment

begin_define
define|#
directive|define
name|EOFCHAR
value|(-1)
end_define

begin_define
define|#
directive|define
name|NEEDCHAR
value|(-2)
end_define

begin_decl_stmt
name|readonly
name|short
name|type
index|[]
init|=
block|{
name|NEEDSBUF
block|,
comment|/*fill up the input buffer*/
name|SCANEOF
block|,
comment|/*hit the hard end of file*/
name|SP
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
comment|/*\0..^G*/
name|BADCHAR
block|,
name|SP
block|,
name|NL
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|SP
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
comment|/*BS..SI*/
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
comment|/*DLE..ETB*/
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
name|BADCHAR
block|,
comment|/*CAN..US*/
name|SP
block|,
name|ORNOT
block|,
name|DQ
block|,
name|SH
block|,
name|LITOP
block|,
name|REGOP
block|,
name|AND
block|,
name|SQ
block|,
comment|/*sp .. '*/
name|LP
block|,
name|RP
block|,
name|MUL
block|,
name|PLUS
block|,
name|CM
block|,
name|MINUS
block|,
name|ALPH
block|,
name|DIV
block|,
comment|/*( .. /*/
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
name|DIG
block|,
comment|/*0 .. 7*/
name|DIG
block|,
name|DIG
block|,
name|COLON
block|,
name|SEMI
block|,
name|LSH
block|,
name|BADCHAR
block|,
name|RSH
block|,
name|BADCHAR
block|,
comment|/*8 .. ?*/
name|BADCHAR
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
comment|/*@ .. G*/
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
comment|/*H .. BADCHAR*/
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
comment|/*P .. V*/
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|LB
block|,
name|BADCHAR
block|,
name|RB
block|,
name|XOR
block|,
name|ALPH
block|,
comment|/*W .. _*/
name|SIZEQUOTE
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
comment|/*` .. g*/
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
comment|/*h .. o*/
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
comment|/*p .. v*/
name|ALPH
block|,
name|ALPH
block|,
name|ALPH
block|,
name|BADCHAR
block|,
name|IOR
block|,
name|BADCHAR
block|,
name|TILDE
block|,
name|BADCHAR
block|,
comment|/*x .. del*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	The table of possible uses for each character to test set inclusion.  *	Different than the above table, which knows about tokens yylex  *	is to return.  */
end_comment

begin_define
define|#
directive|define
name|HEXFLAG
value|01
end_define

begin_comment
comment|/* 'x' or 'X' */
end_comment

begin_define
define|#
directive|define
name|HEXLDIGIT
value|02
end_define

begin_comment
comment|/* 'a' .. 'f' */
end_comment

begin_define
define|#
directive|define
name|HEXUDIGIT
value|04
end_define

begin_comment
comment|/* 'A' .. 'F' */
end_comment

begin_define
define|#
directive|define
name|ALPHA
value|010
end_define

begin_comment
comment|/* 'A' .. 'Z', 'a' .. 'z', '_'*/
end_comment

begin_define
define|#
directive|define
name|DIGIT
value|020
end_define

begin_comment
comment|/* '0' .. '9' */
end_comment

begin_define
define|#
directive|define
name|FLOATEXP
value|040
end_define

begin_comment
comment|/* 'd' 'e' 'D' 'E' */
end_comment

begin_comment
comment|/*exponent field*/
end_comment

begin_define
define|#
directive|define
name|SIGN
value|0100
end_define

begin_comment
comment|/* '+' .. '-'*/
end_comment

begin_define
define|#
directive|define
name|REGDIGIT
value|0200
end_define

begin_comment
comment|/* '0' .. '5' */
end_comment

begin_define
define|#
directive|define
name|SZSPECBEGIN
value|0400
end_define

begin_comment
comment|/* 'b', 'B', 'l', 'L', 'w', 'W' */
end_comment

begin_define
define|#
directive|define
name|POINT
value|01000
end_define

begin_comment
comment|/* '.' */
end_comment

begin_define
define|#
directive|define
name|SPACE
value|02000
end_define

begin_comment
comment|/* '\t' or ' ' */
end_comment

begin_define
define|#
directive|define
name|BSESCAPE
value|04000
end_define

begin_comment
comment|/* bnrtf */
end_comment

begin_define
define|#
directive|define
name|STRESCAPE
value|010000
end_define

begin_comment
comment|/* '"', '\\', '\n' */
end_comment

begin_define
define|#
directive|define
name|OCTDIGIT
value|020000
end_define

begin_comment
comment|/* '0' .. '7' */
end_comment

begin_define
define|#
directive|define
name|FLOATFLAG
value|040000
end_define

begin_comment
comment|/* 'd', 'D', 'f', 'F' */
end_comment

begin_comment
comment|/*after leading 0*/
end_comment

begin_decl_stmt
name|readonly
name|short
name|charsets
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*\0..^G*/
literal|0
block|,
name|SPACE
block|,
name|STRESCAPE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*BS..SI*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*DLE..ETB*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*CAN..US*/
name|SPACE
block|,
literal|0
block|,
name|STRESCAPE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*sp.. '*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|SIGN
block|,
literal|0
block|,
name|SIGN
block|,
name|POINT
operator|+
name|ALPHA
block|,
literal|0
block|,
comment|/*( .. /*/
name|DIGIT
operator|+
name|REGDIGIT
operator|+
name|OCTDIGIT
block|,
name|DIGIT
operator|+
name|REGDIGIT
operator|+
name|OCTDIGIT
block|,
comment|/*0..1*/
name|DIGIT
operator|+
name|REGDIGIT
operator|+
name|OCTDIGIT
block|,
name|DIGIT
operator|+
name|REGDIGIT
operator|+
name|OCTDIGIT
block|,
comment|/*2..3*/
name|DIGIT
operator|+
name|REGDIGIT
operator|+
name|OCTDIGIT
block|,
name|DIGIT
operator|+
name|REGDIGIT
operator|+
name|OCTDIGIT
block|,
comment|/*4..5*/
name|DIGIT
operator|+
name|OCTDIGIT
block|,
name|DIGIT
operator|+
name|OCTDIGIT
block|,
comment|/*6..7*/
name|DIGIT
block|,
name|DIGIT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*8..?*/
literal|0
block|,
comment|/*@*/
name|ALPHA
operator|+
name|HEXUDIGIT
block|,
name|ALPHA
operator|+
name|HEXUDIGIT
operator|+
name|SZSPECBEGIN
block|,
comment|/*A..B*/
name|ALPHA
operator|+
name|HEXUDIGIT
block|,
name|ALPHA
operator|+
name|HEXUDIGIT
operator|+
name|FLOATEXP
operator|+
name|FLOATFLAG
block|,
comment|/*C..D*/
name|ALPHA
operator|+
name|HEXUDIGIT
operator|+
name|FLOATEXP
block|,
name|ALPHA
operator|+
name|HEXUDIGIT
operator|+
name|FLOATFLAG
block|,
comment|/*E..F*/
name|ALPHA
block|,
comment|/*G*/
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
block|,
comment|/*H..K*/
name|ALPHA
operator|+
name|SZSPECBEGIN
block|,
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
block|,
comment|/*L..O*/
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
block|,
comment|/*P..S*/
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
operator|+
name|SZSPECBEGIN
block|,
comment|/*T..W*/
name|ALPHA
operator|+
name|HEXFLAG
block|,
name|ALPHA
block|,
name|ALPHA
block|,
literal|0
block|,
name|STRESCAPE
block|,
literal|0
block|,
literal|0
block|,
name|ALPHA
block|,
comment|/*X.._*/
literal|0
block|,
name|ALPHA
operator|+
name|HEXLDIGIT
block|,
name|ALPHA
operator|+
name|HEXLDIGIT
operator|+
name|BSESCAPE
operator|+
name|SZSPECBEGIN
block|,
comment|/*a..b*/
name|ALPHA
operator|+
name|HEXLDIGIT
block|,
name|ALPHA
operator|+
name|HEXLDIGIT
operator|+
name|FLOATEXP
operator|+
name|FLOATFLAG
block|,
comment|/*c..d*/
name|ALPHA
operator|+
name|HEXLDIGIT
operator|+
name|FLOATEXP
block|,
name|ALPHA
operator|+
name|HEXLDIGIT
operator|+
name|BSESCAPE
operator|+
name|FLOATFLAG
block|,
comment|/*e..f*/
name|ALPHA
block|,
comment|/*g*/
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
block|,
comment|/*h..k*/
name|ALPHA
operator|+
name|SZSPECBEGIN
block|,
name|ALPHA
block|,
name|ALPHA
operator|+
name|BSESCAPE
block|,
name|ALPHA
block|,
comment|/*l..o*/
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
operator|+
name|BSESCAPE
block|,
name|ALPHA
block|,
comment|/*p..s*/
name|ALPHA
operator|+
name|BSESCAPE
block|,
name|ALPHA
block|,
name|ALPHA
block|,
name|ALPHA
operator|+
name|SZSPECBEGIN
block|,
comment|/*t..w*/
name|ALPHA
operator|+
name|HEXFLAG
block|,
name|ALPHA
block|,
name|ALPHA
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*x..del*/
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INCHARSET
parameter_list|(
name|val
parameter_list|,
name|kind
parameter_list|)
value|(charsets[val]& (kind) )
end_define

begin_decl_stmt
specifier|static
name|toktype
name|oval
init|=
name|NL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INBUFLG
value|2 + 2*BUFSIZ + 128
end_define

begin_decl_stmt
specifier|static
name|char
name|inbuffer
index|[
name|INBUFLG
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|InBufPtr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|getchar
end_ifdef

begin_undef
undef|#
directive|undef
name|getchar
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|getchar
parameter_list|()
value|*inbufptr++
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ungetc
end_ifdef

begin_undef
undef|#
directive|undef
name|ungetc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ungetc
parameter_list|(
name|char
parameter_list|,
name|fileptr
parameter_list|)
value|*--inbufptr = char
end_define

begin_function
name|char
modifier|*
name|fillinbuffer
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|inbufptr
decl_stmt|;
name|int
name|nread
decl_stmt|;
name|inbufptr
operator|=
operator|&
name|inbuffer
index|[
literal|2
index|]
expr_stmt|;
comment|/*allow enough room for two ungetcs*/
name|nread
operator|=
name|fread
argument_list|(
name|inbufptr
argument_list|,
literal|1
argument_list|,
literal|2
operator|*
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
literal|2
operator|*
name|BUFSIZ
condition|)
block|{
name|cp
operator|=
name|fgets
argument_list|(
name|inbufptr
operator|+
literal|2
operator|*
name|BUFSIZ
argument_list|,
literal|128
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
comment|/*get next whole line*/
if|if
condition|(
name|cp
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|cp
operator|++
condition|)
empty_stmt|;
comment|/*find the trailing null*/
operator|*
operator|--
name|cp
operator|=
name|NEEDCHAR
expr_stmt|;
comment|/*clobber with a NEED character*/
return|return
operator|(
name|inbufptr
operator|)
return|;
block|}
else|else
block|{
operator|*
operator|(
name|inbufptr
operator|+
literal|2
operator|*
name|BUFSIZ
operator|)
operator|=
name|EOFCHAR
expr_stmt|;
return|return
operator|(
name|inbufptr
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
comment|/*hard end of file*/
return|return
operator|(
literal|0
operator|)
return|;
name|inbuffer
index|[
literal|2
operator|+
name|nread
index|]
operator|=
name|EOFCHAR
expr_stmt|;
return|return
operator|(
name|inbufptr
operator|)
return|;
block|}
block|}
end_function

begin_macro
name|scan_dot_s
argument_list|(
argument|bufferbox
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tokbufdesc
modifier|*
name|bufferbox
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|yylval
decl_stmt|;
comment|/*lexical value*/
specifier|register
name|toktype
name|val
decl_stmt|;
comment|/*the value returned; the character read*/
specifier|register
name|int
name|base
decl_stmt|;
comment|/*the base of the number also counter*/
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|inbufptr
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|op
decl_stmt|;
specifier|register
name|unsigned
name|char
name|tag
decl_stmt|;
specifier|register
name|ptrall
name|bufptr
decl_stmt|;
comment|/*where to stuff tokens*/
name|ptrall
name|lgbackpatch
decl_stmt|;
comment|/*where to stuff a string length*/
name|ptrall
name|bufub
decl_stmt|;
comment|/*where not to stuff tokens*/
specifier|register
name|int
name|maxstrlg
decl_stmt|;
comment|/*how long a string can be*/
name|long
name|intval
decl_stmt|;
comment|/*value of int*/
name|char
name|fltchr
index|[
literal|64
index|]
decl_stmt|;
comment|/*buffer for floating values*/
name|double
name|fltval
decl_stmt|;
comment|/*floating value returned*/
name|int
name|linescrossed
decl_stmt|;
comment|/*when doing strings and comments*/
name|inbufptr
operator|=
name|InBufPtr
expr_stmt|;
if|if
condition|(
name|inbufptr
operator|==
literal|0
condition|)
block|{
name|inbufptr
operator|=
name|fillinbuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|inbufptr
operator|==
literal|0
condition|)
block|{
comment|/*end of file*/
name|endoffile
label|:
name|inbufptr
operator|=
literal|0
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|PARSEEOF
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
operator|(
name|toktype
operator|*
operator|)
name|bufptr
operator|=
operator|(
name|toktype
operator|*
operator|)
operator|&
operator|(
name|bufferbox
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
operator|(
name|toktype
operator|*
operator|)
name|bufub
operator|=
operator|&
operator|(
name|bufferbox
operator|->
name|toks
index|[
name|AVAILTOKS
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|newfflag
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|">>>>>>>>>>>>>(scanner) Starting to insert tokens into a new file: %s\n"
argument_list|,
name|newfname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|IFILE
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|STRING
argument_list|)
expr_stmt|;
name|val
operator|=
name|strlen
argument_list|(
name|newfname
argument_list|)
operator|+
literal|1
expr_stmt|;
name|movestr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
operator|(
name|lgtype
operator|*
operator|)
name|bufptr
operator|)
index|[
literal|1
index|]
operator|)
argument_list|,
name|newfname
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bstrlg
argument_list|(
name|bufptr
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|ILINENO
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|pint
argument_list|(
name|bufptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newfflag
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|bufptr
operator|<
name|bufub
condition|)
block|{
name|loop
label|:
switch|switch
condition|(
name|yylval
operator|=
operator|(
name|type
operator|+
literal|2
operator|)
index|[
name|val
operator|=
name|getchar
argument_list|()
index|]
condition|)
block|{
case|case
name|SCANEOF
case|:
name|inbufptr
operator|=
literal|0
expr_stmt|;
goto|goto
name|endoffile
goto|;
case|case
name|NEEDSBUF
case|:
name|inbufptr
operator|=
name|fillinbuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|inbufptr
operator|==
literal|0
condition|)
goto|goto
name|endoffile
goto|;
goto|goto
name|loop
goto|;
case|case
name|DIV
case|:
comment|/*process C style comments*/
if|if
condition|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'*'
condition|)
block|{
comment|/*comment prelude*/
name|int
name|incomment
decl_stmt|;
name|linescrossed
operator|=
literal|0
expr_stmt|;
name|incomment
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*skip over the * */
do|do
block|{
while|while
condition|(
operator|(
name|val
operator|!=
literal|'*'
operator|)
operator|&&
operator|(
name|val
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|val
operator|!=
name|EOFCHAR
operator|)
operator|&&
operator|(
name|val
operator|!=
name|NEEDCHAR
operator|)
condition|)
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|'\n'
condition|)
block|{
name|scanlineno
operator|++
expr_stmt|;
name|linescrossed
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
name|EOFCHAR
condition|)
goto|goto
name|endoffile
goto|;
if|if
condition|(
name|val
operator|==
name|NEEDCHAR
condition|)
block|{
name|inbufptr
operator|=
name|fillinbuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|inbufptr
operator|==
literal|0
condition|)
goto|goto
name|endoffile
goto|;
name|lineno
operator|++
expr_stmt|;
name|incomment
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*pull in the new char*/
block|}
else|else
block|{
comment|/*its a star */
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|incomment
operator|=
name|val
operator|!=
literal|'/'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|incomment
condition|)
do|;
name|val
operator|=
name|ILINESKIP
expr_stmt|;
name|yylval
operator|=
name|linescrossed
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
comment|/*just an ordinary DIV*/
name|ungetc
argument_list|(
name|val
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|val
operator|=
name|yylval
operator|=
name|DIV
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
case|case
name|SH
case|:
if|if
condition|(
name|oval
operator|==
name|NL
condition|)
block|{
comment|/* 				 *	Attempt to recognize a C preprocessor 				 *	style comment '^#[ \t]*[0-9]*[ \t]*".*" 				 */
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*bump the #*/
while|while
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|SPACE
argument_list|)
condition|)
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*bump white */
if|if
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|DIGIT
argument_list|)
condition|)
block|{
name|intval
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|DIGIT
argument_list|)
condition|)
block|{
name|intval
operator|=
name|intval
operator|*
literal|10
operator|+
name|val
operator|-
literal|'0'
expr_stmt|;
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|SPACE
argument_list|)
condition|)
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|'"'
condition|)
block|{
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|ILINENO
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|pint
argument_list|(
name|bufptr
argument_list|,
name|intval
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|IFILE
argument_list|)
expr_stmt|;
comment|/* 						 *	The '"' has already been 						 *	munched 						 *	 						 *	eatstr will not eat 						 *	the trailing \n, so 						 *	it is given to the parser 						 *	and counted. 						 */
goto|goto
name|eatstr
goto|;
block|}
block|}
block|}
comment|/* 			 *	Well, its just an ordinary decadent comment 			 */
while|while
condition|(
operator|(
name|val
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|val
operator|!=
name|EOFCHAR
operator|)
condition|)
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|EOFCHAR
condition|)
goto|goto
name|endoffile
goto|;
name|val
operator|=
name|yylval
operator|=
name|oval
operator|=
name|NL
expr_stmt|;
name|scanlineno
operator|++
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|NL
case|:
name|scanlineno
operator|++
expr_stmt|;
name|val
operator|=
name|yylval
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|SP
case|:
name|oval
operator|=
name|SP
expr_stmt|;
comment|/*invalidate ^# meta comments*/
goto|goto
name|loop
goto|;
case|case
name|REGOP
case|:
comment|/* % , could be used as modulo, or register*/
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|DIGIT
argument_list|)
condition|)
block|{
name|yylval
operator|=
name|val
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
name|INCHARSET
argument_list|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
name|REGDIGIT
argument_list|)
condition|)
name|yylval
operator|=
literal|10
operator|+
name|val
operator|-
literal|'0'
expr_stmt|;
else|else
name|ungetc
argument_list|(
name|val
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
comment|/* 				 *	God only knows what the original author 				 *	wanted this undocumented feature to 				 *	do. 				 *		%5++ is really  r7 				 */
while|while
condition|(
name|INCHARSET
argument_list|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
name|SIGN
argument_list|)
condition|)
block|{
if|if
condition|(
name|val
operator|==
literal|'+'
condition|)
name|yylval
operator|++
expr_stmt|;
else|else
name|yylval
operator|--
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|val
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG
expr_stmt|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|val
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|val
operator|=
name|REGOP
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
case|case
name|ALPH
case|:
name|yylval
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|SZSPECBEGIN
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'`'
operator|||
name|val
operator|==
literal|'^'
condition|)
block|{
name|yylval
operator||=
literal|0100
expr_stmt|;
comment|/*convert to lower*/
if|if
condition|(
name|yylval
operator|==
literal|'b'
condition|)
name|yylval
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|yylval
operator|==
literal|'w'
condition|)
name|yylval
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|yylval
operator|==
literal|'l'
condition|)
name|yylval
operator|=
literal|4
expr_stmt|;
else|else
name|yylval
operator|=
name|d124
expr_stmt|;
name|val
operator|=
name|SIZESPEC
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|val
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|val
operator|=
name|yylval
expr_stmt|;
comment|/*restore first character*/
block|}
block|}
name|cp
operator|=
name|yytext
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cp
operator|<
operator|&
name|yytext
index|[
name|NCPS
index|]
condition|)
operator|*
name|cp
operator|++
operator|=
name|val
expr_stmt|;
block|}
do|while
condition|(
name|INCHARSET
argument_list|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
name|ALPHA
operator||
name|DIGIT
argument_list|)
condition|)
do|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|SPACE
argument_list|)
condition|)
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|ungetc
argument_list|(
name|val
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|tag
operator|=
operator|(
name|op
operator|=
operator|*
name|lookup
argument_list|(
literal|1
argument_list|)
operator|)
operator|->
name|tag
expr_stmt|;
if|if
condition|(
name|tag
operator|&&
name|tag
operator|!=
name|LABELID
condition|)
block|{
name|yylval
operator|=
operator|(
operator|(
expr|struct
name|instab
operator|*
operator|)
name|op
operator|)
operator|->
name|opcode
expr_stmt|;
name|val
operator|=
name|op
operator|->
name|tag
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
comment|/* 				 *	Its a name... (Labels are subsets ofname) 				 */
name|yylval
operator|=
operator|(
name|int
operator|)
name|op
expr_stmt|;
name|val
operator|=
name|NAME
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
case|case
name|DIG
case|:
name|intval
operator|=
name|val
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|'0'
condition|)
block|{
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|HEXFLAG
argument_list|)
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|FLOATFLAG
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|fltchr
decl_stmt|;
name|double
name|atof
parameter_list|()
function_decl|;
while|while
condition|(
operator|(
name|p
operator|<
operator|&
name|fltchr
index|[
literal|63
index|]
operator|)
operator|&&
name|INCHARSET
argument_list|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
operator|(
name|DIGIT
operator||
name|SIGN
operator||
name|FLOATEXP
operator||
name|POINT
operator|)
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
name|val
expr_stmt|;
name|ungetc
argument_list|(
name|val
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|fltval
operator|=
name|atof
argument_list|(
name|fltchr
argument_list|)
expr_stmt|;
name|val
operator|=
name|FLTNUM
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|val
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|base
operator|=
literal|8
expr_stmt|;
block|}
block|}
else|else
name|base
operator|=
literal|10
expr_stmt|;
while|while
condition|(
name|INCHARSET
argument_list|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
name|DIGIT
argument_list|)
operator|||
operator|(
name|base
operator|==
literal|16
operator|&&
operator|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|HEXLDIGIT
operator||
name|HEXUDIGIT
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|8
condition|)
name|intval
operator|<<=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|==
literal|10
condition|)
name|intval
operator|*=
literal|10
expr_stmt|;
else|else
block|{
name|intval
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|HEXLDIGIT
argument_list|)
condition|)
name|val
operator|-=
literal|'a'
operator|-
literal|10
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|HEXUDIGIT
argument_list|)
condition|)
name|val
operator|-=
literal|'A'
operator|-
literal|10
operator|-
literal|'0'
expr_stmt|;
block|}
name|intval
operator|+=
name|val
operator|-
literal|'0'
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|val
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|val
operator|=
name|INT
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|LSH
case|:
case|case
name|RSH
case|:
comment|/* 			 *	We allow the C style operators 			 *<< and>>, as well as< and> 			 */
if|if
condition|(
operator|(
name|base
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|val
condition|)
name|ungetc
argument_list|(
name|base
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|val
operator|=
name|yylval
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|MINUS
case|:
if|if
condition|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'('
condition|)
name|yylval
operator|=
name|val
operator|=
name|MP
expr_stmt|;
else|else
block|{
name|ungetc
argument_list|(
name|val
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|val
operator|=
name|MINUS
expr_stmt|;
block|}
goto|goto
name|ret
goto|;
case|case
name|SQ
case|:
if|if
condition|(
operator|(
name|yylval
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
name|scanlineno
operator|++
expr_stmt|;
comment|/*not entirely correct*/
name|intval
operator|=
name|yylval
expr_stmt|;
name|val
operator|=
name|INT
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|DQ
case|:
name|eatstr
label|:
name|linescrossed
operator|=
literal|0
expr_stmt|;
name|maxstrlg
operator|=
operator|(
name|char
operator|*
operator|)
name|bufub
operator|-
operator|(
name|char
operator|*
operator|)
name|bufptr
expr_stmt|;
if|if
condition|(
name|maxstrlg
operator|<
name|MAXSTRLG
condition|)
block|{
name|ungetc
argument_list|(
literal|'"'
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
operator|*
operator|(
name|toktype
operator|*
operator|)
name|bufptr
operator|=
name|VOID
expr_stmt|;
name|bufub
operator|=
name|bufptr
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|maxstrlg
operator|>
name|MAXSTRLG
condition|)
name|maxstrlg
operator|=
name|MAXSTRLG
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|STRING
argument_list|)
expr_stmt|;
name|lgbackpatch
operator|=
name|bufptr
expr_stmt|;
comment|/*this is where the size goes*/
name|bufptr
operator|+=
sizeof|sizeof
argument_list|(
name|lgtype
argument_list|)
expr_stmt|;
comment|/* 			 *	bufptr is now set to 			 *	be stuffed with characters from 			 *	the input 			 */
while|while
condition|(
operator|(
name|maxstrlg
operator|>
literal|0
operator|)
operator|&&
operator|!
operator|(
name|INCHARSET
argument_list|(
operator|(
name|val
operator|=
name|getchar
argument_list|()
operator|)
argument_list|,
name|STRESCAPE
argument_list|)
operator|)
condition|)
block|{
name|stuff
label|:
name|maxstrlg
operator|-=
literal|1
expr_stmt|;
name|pchar
argument_list|(
name|bufptr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxstrlg
operator|<=
literal|0
condition|)
block|{
comment|/*enough characters to fill a string buffer*/
name|ungetc
argument_list|(
literal|'"'
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
comment|/*will read it next*/
block|}
elseif|else
if|if
condition|(
name|val
operator|==
literal|'"'
condition|)
empty_stmt|;
comment|/*done*/
elseif|else
if|if
condition|(
name|val
operator|==
literal|'\n'
condition|)
block|{
name|scanlineno
operator|++
expr_stmt|;
name|linescrossed
operator|++
expr_stmt|;
goto|goto
name|stuff
goto|;
block|}
else|else
block|{
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*skip the '\\'*/
if|if
condition|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|BSESCAPE
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|val
condition|)
block|{
case|case
literal|'b'
case|:
name|val
operator|=
literal|'\b'
expr_stmt|;
goto|goto
name|stuff
goto|;
case|case
literal|'f'
case|:
name|val
operator|=
literal|'\f'
expr_stmt|;
goto|goto
name|stuff
goto|;
case|case
literal|'n'
case|:
name|val
operator|=
literal|'\n'
expr_stmt|;
goto|goto
name|stuff
goto|;
case|case
literal|'r'
case|:
name|val
operator|=
literal|'\r'
expr_stmt|;
goto|goto
name|stuff
goto|;
case|case
literal|'t'
case|:
name|val
operator|=
literal|'\t'
expr_stmt|;
goto|goto
name|stuff
goto|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|OCTDIGIT
argument_list|)
operator|)
condition|)
goto|goto
name|stuff
goto|;
name|base
operator|=
literal|0
expr_stmt|;
name|intval
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|base
operator|<
literal|3
operator|)
operator|&&
operator|(
name|INCHARSET
argument_list|(
name|val
argument_list|,
name|OCTDIGIT
argument_list|)
operator|)
condition|)
block|{
name|base
operator|++
expr_stmt|;
name|intval
operator|<<=
literal|3
expr_stmt|;
name|intval
operator|+=
name|val
operator|-
literal|'0'
expr_stmt|;
name|val
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|val
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|char
operator|)
name|intval
expr_stmt|;
goto|goto
name|stuff
goto|;
block|}
comment|/* 			 *	bufptr now points at the next free slot 			 */
name|bstrfromto
argument_list|(
name|lgbackpatch
argument_list|,
name|bufptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|linescrossed
condition|)
block|{
name|val
operator|=
name|ILINESKIP
expr_stmt|;
name|yylval
operator|=
name|linescrossed
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
goto|goto
name|builtval
goto|;
case|case
name|BADCHAR
case|:
name|linescrossed
operator|=
name|lineno
expr_stmt|;
name|lineno
operator|=
name|scanlineno
expr_stmt|;
name|yyerror
argument_list|(
literal|"Illegal character mapped: %d, char read:(octal) %o"
argument_list|,
name|yylval
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|linescrossed
expr_stmt|;
name|val
operator|=
name|BADCHAR
expr_stmt|;
goto|goto
name|ret
goto|;
default|default:
name|val
operator|=
name|yylval
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/*end of the switch*/
comment|/* 	 *	here with one token, so stuff it 	 */
name|ret
label|:
name|oval
operator|=
name|val
expr_stmt|;
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|val
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|ILINESKIP
case|:
name|pint
argument_list|(
name|bufptr
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIZESPEC
case|:
name|pchar
argument_list|(
name|bufptr
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|plong
argument_list|(
name|bufptr
argument_list|,
name|intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLTNUM
case|:
name|pdouble
argument_list|(
name|bufptr
argument_list|,
name|fltval
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME
case|:
name|pptr
argument_list|(
name|bufptr
argument_list|,
operator|(
name|int
operator|)
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|pchar
argument_list|(
name|bufptr
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|INST0
case|:
case|case
name|INSTn
case|:
name|pchar
argument_list|(
name|bufptr
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
break|break;
case|case
name|IJXXX
case|:
name|pchar
argument_list|(
name|bufptr
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
name|pptr
argument_list|(
name|bufptr
argument_list|,
operator|(
name|int
operator|)
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|symalloc
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISTAB
case|:
case|case
name|ISTABSTR
case|:
case|case
name|ISTABNONE
case|:
case|case
name|ISTABDOT
case|:
case|case
name|IALIGN
case|:
name|pptr
argument_list|(
name|bufptr
argument_list|,
operator|(
name|int
operator|)
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|symalloc
argument_list|()
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 *	default: 	 */
block|}
name|builtval
label|:
empty_stmt|;
block|}
comment|/*end of the while to stuff the buffer*/
name|done
label|:
name|bufferbox
operator|->
name|tok_count
operator|=
operator|(
name|toktype
operator|*
operator|)
name|bufptr
operator|-
operator|&
operator|(
name|bufferbox
operator|->
name|toks
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* 	 *	This is a real kludge: 	 * 	 *	We put the last token in the buffer to be  a MINUS 	 *	symbol.  This last token will never be picked up 	 *	in the normal way, but can be looked at during 	 *	a peekahead look that the short circuit expression 	 *	evaluator uses to see if an expression is complicated. 	 * 	 *	Consider the following situation: 	 * 	 *	.word	45		+	47 	 *        buffer 1      |  buffer 0 	 *	the peekahead would want to look across the buffer, 	 *	but will look in the buffer end zone, see the minus, and 	 *	fail. 	 */
name|ptoken
argument_list|(
name|bufptr
argument_list|,
name|MINUS
argument_list|)
expr_stmt|;
name|InBufPtr
operator|=
name|inbufptr
expr_stmt|;
comment|/*copy this back*/
block|}
end_block

end_unit

