begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*      *	tCopy.c      *      *	functions to copy pi trees to pTrees      */
end_comment

begin_include
include|#
directive|include
file|"whoami"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PTREE
end_ifdef

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/*      *	tCopy      *	a mongo switch statement to farm out the actual copying       *	to the appropriate routines.      *	given a pointer to a pi tree branch, it returns a pPointer to      *	a pTree copy of that branch.      */
end_comment

begin_function
name|pPointer
name|tCopy
parameter_list|(
name|node
parameter_list|)
name|int
modifier|*
name|node
decl_stmt|;
block|{
if|if
condition|(
name|node
operator|==
name|NIL
condition|)
return|return
name|pNIL
return|;
switch|switch
condition|(
name|node
index|[
literal|0
index|]
condition|)
block|{
case|case
name|T_PROG
case|:
case|case
name|T_PDEC
case|:
case|case
name|T_FDEC
case|:
return|return
name|PorFCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_TYPTR
case|:
return|return
name|PtrTCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_TYPACK
case|:
return|return
name|PackTCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_TYSCAL
case|:
return|return
name|EnumTCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_TYRANG
case|:
return|return
name|RangeTCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_TYARY
case|:
return|return
name|ArrayTCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_TYFILE
case|:
return|return
name|FileTCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_TYSET
case|:
return|return
name|SetTCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_TYREC
case|:
return|return
name|RecTCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_FLDLST
case|:
return|return
name|FldlstCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_RFIELD
case|:
return|return
name|FieldCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_TYVARPT
case|:
return|return
name|VarntCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_TYVARNT
case|:
return|return
name|VCaseCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_CSTAT
case|:
return|return
name|CasedCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_PVAL
case|:
case|case
name|T_PVAR
case|:
return|return
name|ParamCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_CSTRNG
case|:
return|return
name|sCopy
argument_list|(
name|node
index|[
literal|1
index|]
argument_list|)
return|;
case|case
name|T_STRNG
case|:
return|return
name|sCopy
argument_list|(
name|node
index|[
literal|2
index|]
argument_list|)
return|;
case|case
name|T_PLUSC
case|:
case|case
name|T_PLUS
case|:
case|case
name|T_MINUSC
case|:
case|case
name|T_MINUS
case|:
case|case
name|T_NOT
case|:
return|return
name|UnOpCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_ID
case|:
return|return
name|ThreadSymbol
argument_list|(
name|node
index|[
literal|1
index|]
argument_list|)
return|;
case|case
name|T_TYID
case|:
return|return
name|ThreadSymbol
argument_list|(
name|node
index|[
literal|2
index|]
argument_list|)
return|;
case|case
name|T_CINT
case|:
case|case
name|T_CBINT
case|:
return|return
name|iCopy
argument_list|(
name|node
index|[
literal|1
index|]
argument_list|)
return|;
case|case
name|T_INT
case|:
case|case
name|T_BINT
case|:
return|return
name|iCopy
argument_list|(
name|node
index|[
literal|2
index|]
argument_list|)
return|;
case|case
name|T_CFINT
case|:
return|return
name|fCopy
argument_list|(
name|node
index|[
literal|1
index|]
argument_list|)
return|;
case|case
name|T_FINT
case|:
return|return
name|fCopy
argument_list|(
name|node
index|[
literal|2
index|]
argument_list|)
return|;
case|case
name|T_LISTPP
case|:
return|return
name|ListCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_PCALL
case|:
return|return
name|PCallCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_BLOCK
case|:
case|case
name|T_BSTL
case|:
return|return
name|ListCopy
argument_list|(
name|node
index|[
literal|2
index|]
argument_list|)
return|;
case|case
name|T_CASE
case|:
return|return
name|CaseSCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_WITH
case|:
return|return
name|WithCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_WHILE
case|:
return|return
name|WhileCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_REPEAT
case|:
return|return
name|RepeatCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_FORU
case|:
case|case
name|T_FORD
case|:
return|return
name|ForCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_IF
case|:
case|case
name|T_IFEL
case|:
return|return
name|IfCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_GOTO
case|:
return|return
name|GotoCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_LABEL
case|:
return|return
name|LabelCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_ASRT
case|:
return|return
name|AssertCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_ASGN
case|:
return|return
name|AssignCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_NIL
case|:
return|return
name|NilCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_FCALL
case|:
return|return
name|FCallCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_CSET
case|:
return|return
name|SetCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_RANG
case|:
return|return
name|RangeCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_VAR
case|:
return|return
name|VarCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_ARY
case|:
return|return
name|SubscCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_FIELD
case|:
return|return
name|SelCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_PTR
case|:
return|return
name|PtrCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_EQ
case|:
case|case
name|T_LT
case|:
case|case
name|T_GT
case|:
case|case
name|T_LE
case|:
case|case
name|T_GE
case|:
case|case
name|T_NE
case|:
case|case
name|T_IN
case|:
case|case
name|T_ADD
case|:
case|case
name|T_SUB
case|:
case|case
name|T_MULT
case|:
case|case
name|T_DIVD
case|:
case|case
name|T_DIV
case|:
case|case
name|T_MOD
case|:
case|case
name|T_OR
case|:
case|case
name|T_AND
case|:
return|return
name|BinOpCopy
argument_list|(
name|node
argument_list|)
return|;
case|case
name|T_WEXP
case|:
return|return
name|WidthCopy
argument_list|(
name|node
argument_list|)
return|;
default|default:
name|panic
argument_list|(
literal|"tCopy"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*      *	copy a list of nodes into ListNodes      *	(with a hack for appending one list to another      *	    for example: labelled statements)      *	listnode[0]	T_LISTPP      *		[1]	"list_element"      *		[2]	"list_next"      */
end_comment

begin_function
name|pPointer
name|ListCopy
parameter_list|(
name|listnode
parameter_list|)
name|int
modifier|*
name|listnode
decl_stmt|;
block|{
name|pPointer
name|First
decl_stmt|;
name|pPointer
name|After
decl_stmt|;
name|int
modifier|*
name|listp
decl_stmt|;
name|pPointer
name|Item
decl_stmt|;
name|pPointer
name|List
decl_stmt|;
name|pPointer
name|Furthur
decl_stmt|;
name|First
operator|=
name|pNIL
expr_stmt|;
name|After
operator|=
name|pNIL
expr_stmt|;
for|for
control|(
name|listp
operator|=
name|listnode
init|;
name|listp
operator|!=
name|NIL
condition|;
name|listp
operator|=
operator|(
name|int
operator|*
operator|)
name|listp
index|[
literal|2
index|]
control|)
block|{
name|List
operator|=
name|pNewNode
argument_list|(
name|ListTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ListNode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|First
operator|==
name|pNIL
condition|)
name|First
operator|=
name|List
expr_stmt|;
name|Item
operator|=
name|tCopy
argument_list|(
name|listp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListItem
operator|=
name|Item
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListDown
operator|=
name|pNIL
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListUp
operator|=
name|After
expr_stmt|;
if|if
condition|(
name|After
operator|!=
name|pNIL
condition|)
name|pDEF
argument_list|(
name|After
argument_list|)
operator|.
name|ListDown
operator|=
name|List
expr_stmt|;
name|After
operator|=
name|List
expr_stmt|;
comment|/* 	     *	if ListItem is a ListNode whose ListUp is non-pNIL 	     *	append that list to this list, using that ListUp 	     *	as an additional ListItem. 	     */
name|Furthur
operator|=
name|Item
expr_stmt|;
if|if
condition|(
name|Furthur
operator|!=
name|pNIL
operator|&&
name|pTAG
argument_list|(
name|Furthur
argument_list|)
operator|==
name|ListTAG
operator|&&
name|pUSE
argument_list|(
name|Furthur
argument_list|)
operator|.
name|ListUp
operator|!=
name|pNIL
condition|)
block|{
name|Item
operator|=
name|pUSE
argument_list|(
name|Furthur
argument_list|)
operator|.
name|ListUp
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListItem
operator|=
name|Item
expr_stmt|;
name|pDEF
argument_list|(
name|Furthur
argument_list|)
operator|.
name|ListUp
operator|=
name|List
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListDown
operator|=
name|Furthur
expr_stmt|;
do|do
block|{
name|After
operator|=
name|Furthur
expr_stmt|;
name|Furthur
operator|=
name|pUSE
argument_list|(
name|After
argument_list|)
operator|.
name|ListDown
expr_stmt|;
block|}
do|while
condition|(
name|Furthur
operator|!=
name|pNIL
condition|)
do|;
block|}
block|}
return|return
name|First
return|;
block|}
end_function

begin_comment
comment|/*      *	ListAppend      *	append a random item to the end of a list      *	(with a hack for appending one list to another      *	 e.g. labelled statments)      */
end_comment

begin_function
name|pPointer
name|ListAppend
parameter_list|(
name|list
parameter_list|,
name|item
parameter_list|)
name|pPointer
name|list
decl_stmt|;
name|pPointer
name|item
decl_stmt|;
block|{
name|pPointer
name|List
init|=
name|pNewNode
argument_list|(
name|ListTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ListNode
argument_list|)
argument_list|)
decl_stmt|;
name|pPointer
name|First
decl_stmt|;
name|pPointer
name|After
decl_stmt|;
name|pPointer
name|Furthur
decl_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListItem
operator|=
name|item
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListDown
operator|=
name|pNIL
expr_stmt|;
name|First
operator|=
name|After
operator|=
name|list
expr_stmt|;
if|if
condition|(
name|First
operator|==
name|pNIL
condition|)
block|{
name|First
operator|=
name|List
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|Furthur
operator|=
name|pUSE
argument_list|(
name|After
argument_list|)
operator|.
name|ListDown
operator|)
operator|!=
name|pNIL
condition|)
name|After
operator|=
name|Furthur
expr_stmt|;
name|pDEF
argument_list|(
name|After
argument_list|)
operator|.
name|ListDown
operator|=
name|List
expr_stmt|;
block|}
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListUp
operator|=
name|After
expr_stmt|;
comment|/* 	 *	if item is a ListNode whose ListUp is non-pNIL 	 *	append that list to this list, using that ListUp 	 *	as an additional ListItem. 	 */
name|Furthur
operator|=
name|item
expr_stmt|;
if|if
condition|(
name|Furthur
operator|!=
name|pNIL
operator|&&
name|pTAG
argument_list|(
name|Furthur
argument_list|)
operator|==
name|ListTAG
operator|&&
name|pUSE
argument_list|(
name|Furthur
argument_list|)
operator|.
name|ListUp
operator|!=
name|pNIL
condition|)
block|{
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListDown
operator|=
name|Furthur
expr_stmt|;
name|pDEF
argument_list|(
name|List
argument_list|)
operator|.
name|ListItem
operator|=
name|pUSE
argument_list|(
name|Furthur
argument_list|)
operator|.
name|ListUp
expr_stmt|;
name|pDEF
argument_list|(
name|Furthur
argument_list|)
operator|.
name|ListUp
operator|=
name|List
expr_stmt|;
block|}
return|return
name|First
return|;
block|}
end_function

begin_comment
comment|/*      *	iCopy      *	copy an integer (string) to an IntNode      */
end_comment

begin_function
name|pPointer
name|iCopy
parameter_list|(
name|intstring
parameter_list|)
name|char
modifier|*
name|intstring
decl_stmt|;
block|{
name|pPointer
name|Int
init|=
name|pNewNode
argument_list|(
name|IntTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|IntNode
argument_list|)
argument_list|)
decl_stmt|;
name|pDEF
argument_list|(
name|Int
argument_list|)
operator|.
name|IntValue
operator|=
name|atol
argument_list|(
name|intstring
argument_list|)
expr_stmt|;
return|return
name|Int
return|;
block|}
end_function

begin_comment
comment|/*      *	fCopy      *	copy a float (string) to a RealNode      */
end_comment

begin_function
name|pPointer
name|fCopy
parameter_list|(
name|realstring
parameter_list|)
name|char
modifier|*
name|realstring
decl_stmt|;
block|{
name|pPointer
name|Real
init|=
name|pNewNode
argument_list|(
name|RealTAG
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|RealNode
argument_list|)
argument_list|)
decl_stmt|;
name|pDEF
argument_list|(
name|Real
argument_list|)
operator|.
name|RealValue
operator|=
name|atof
argument_list|(
name|realstring
argument_list|)
expr_stmt|;
return|return
name|Real
return|;
block|}
end_function

begin_comment
comment|/*      *	sCopy      *	copy a string to a StringNode      */
end_comment

begin_function
name|pPointer
name|sCopy
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|pPointer
name|String
decl_stmt|;
if|if
condition|(
name|string
operator|==
name|NIL
condition|)
return|return
name|pNIL
return|;
name|String
operator|=
name|pNewNode
argument_list|(
name|StringTAG
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pDEF
argument_list|(
name|String
argument_list|)
operator|.
name|StringValue
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|String
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|PTREE
end_endif

end_unit

