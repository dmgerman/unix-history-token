begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_define
define|#
directive|define
name|NUMWORDS
value|TTSIZE * 128
end_define

begin_comment
comment|/*  max number of words in P0 space  */
end_comment

begin_define
define|#
directive|define
name|BITQUADS
value|TTSIZE * 2
end_define

begin_comment
comment|/*  length of bit map in quad words  */
end_comment

begin_define
define|#
directive|define
name|ftstbit
value|asm("	ashl	$-2,r11,r3");\ 			asm("	bbcs	r3,_bitmapq,$1");\ 			asm("	.byte	4");
end_define

begin_comment
comment|/*  define ftstbit	if( readbit(p) ) return; oksetbit;  */
end_comment

begin_define
define|#
directive|define
name|readbit
parameter_list|(
name|p
parameter_list|)
value|((int)bitmap[r=(int)p>>5]& (s=bitmsk[((int)p>>2)&7]))
end_define

begin_define
define|#
directive|define
name|lookbit
parameter_list|(
name|p
parameter_list|)
value|(bitmap[(int)p>>5]& bitmsk[((int)p>>2)& 7])
end_define

begin_define
define|#
directive|define
name|setbit
parameter_list|(
name|p
parameter_list|)
value|{bitmap[(int)p>>5] |= bitmsk[((int)p>> 2)& 7];}
end_define

begin_define
define|#
directive|define
name|oksetbit
value|{bitmap[r] |= s;}
end_define

begin_define
define|#
directive|define
name|readchk
parameter_list|(
name|p
parameter_list|)
value|((int)bitfre[(int)p>>5]& bitmsk[((int)p>>2)&7])
end_define

begin_define
define|#
directive|define
name|setchk
parameter_list|(
name|p
parameter_list|)
value|{bitfre[(int)p>>5] |= bitmsk[((int)p>> 2)& 7];}
end_define

begin_struct
struct|struct
name|heads
block|{
name|struct
name|heads
modifier|*
name|link
decl_stmt|;
name|char
modifier|*
name|pntr
decl_stmt|;
block|}
name|header
index|[
name|TTSIZE
index|]
struct|;
end_struct

begin_decl_stmt
name|FILE
modifier|*
name|chkport
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* garbage collection dump file */
end_comment

begin_decl_stmt
name|lispval
name|datalim
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  end of data space */
end_comment

begin_decl_stmt
name|double
name|bitmapq
index|[
name|BITQUADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the bit map--one bit per long  */
end_comment

begin_decl_stmt
name|double
name|zeroq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  a quad word of zeros  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bitmap
init|=
operator|(
name|char
operator|*
operator|)
name|bitmapq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  byte version of bit map array */
end_comment

begin_decl_stmt
name|char
name|bitmsk
index|[
literal|8
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|64
block|,
literal|128
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  used by bit-marking macros  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|bind_lists
init|=
operator|(
name|int
operator|*
operator|)
name|CNIL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  lisp data for compiled code */
end_comment

begin_function_decl
name|char
modifier|*
name|xsbrk
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|atmlen
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|types
block|{
name|char
modifier|*
name|next_free
decl_stmt|;
name|int
name|space_left
decl_stmt|,
name|space
decl_stmt|,
name|type
decl_stmt|,
name|type_len
decl_stmt|;
comment|/*  note type_len is in units of int */
name|lispval
modifier|*
name|items
decl_stmt|,
modifier|*
name|pages
decl_stmt|,
modifier|*
name|type_name
decl_stmt|;
name|struct
name|heads
modifier|*
name|first
decl_stmt|;
block|}
name|atom_str
init|=
block|{
operator|(
name|char
operator|*
operator|)
name|CNIL
block|,
literal|0
block|,
name|ATOMSPP
block|,
name|ATOM
block|,
literal|5
block|,
operator|&
name|atom_items
block|,
operator|&
name|atom_pages
block|,
operator|&
name|atom_name
block|,
operator|(
expr|struct
name|heads
operator|*
operator|)
name|CNIL
block|}
struct|,
name|strng_str
init|=
block|{
operator|(
name|char
operator|*
operator|)
name|CNIL
block|,
literal|0
block|,
name|STRSPP
block|,
name|STRNG
block|,
literal|1
block|,
operator|&
name|str_items
block|,
operator|&
name|str_pages
block|,
operator|&
name|str_name
block|,
operator|(
expr|struct
name|heads
operator|*
operator|)
name|CNIL
block|}
struct|,
name|int_str
init|=
block|{
operator|(
name|char
operator|*
operator|)
name|CNIL
block|,
literal|0
block|,
name|INTSPP
block|,
name|INT
block|,
literal|1
block|,
operator|&
name|int_items
block|,
operator|&
name|int_pages
block|,
operator|&
name|int_name
block|,
operator|(
expr|struct
name|heads
operator|*
operator|)
name|CNIL
block|}
struct|,
name|dtpr_str
init|=
block|{
operator|(
name|char
operator|*
operator|)
name|CNIL
block|,
literal|0
block|,
name|DTPRSPP
block|,
name|DTPR
block|,
literal|2
block|,
operator|&
name|dtpr_items
block|,
operator|&
name|dtpr_pages
block|,
operator|&
name|dtpr_name
block|,
operator|(
expr|struct
name|heads
operator|*
operator|)
name|CNIL
block|}
struct|,
name|doub_str
init|=
block|{
operator|(
name|char
operator|*
operator|)
name|CNIL
block|,
literal|0
block|,
name|DOUBSPP
block|,
name|DOUB
block|,
literal|2
block|,
operator|&
name|doub_items
block|,
operator|&
name|doub_pages
block|,
operator|&
name|doub_name
block|,
operator|(
expr|struct
name|heads
operator|*
operator|)
name|CNIL
block|}
struct|,
name|array_str
init|=
block|{
operator|(
name|char
operator|*
operator|)
name|CNIL
block|,
literal|0
block|,
name|ARRAYSPP
block|,
name|ARRAY
block|,
literal|5
block|,
operator|&
name|array_items
block|,
operator|&
name|array_pages
block|,
operator|&
name|array_name
block|,
operator|(
expr|struct
name|heads
operator|*
operator|)
name|CNIL
block|}
struct|,
name|sdot_str
init|=
block|{
operator|(
name|char
operator|*
operator|)
name|CNIL
block|,
literal|0
block|,
name|SDOTSPP
block|,
name|SDOT
block|,
literal|2
block|,
operator|&
name|sdot_items
block|,
operator|&
name|sdot_pages
block|,
operator|&
name|sdot_name
block|,
operator|(
expr|struct
name|heads
operator|*
operator|)
name|CNIL
block|}
struct|,
name|val_str
init|=
block|{
operator|(
name|char
operator|*
operator|)
name|CNIL
block|,
literal|0
block|,
name|VALSPP
block|,
name|VALUE
block|,
literal|1
block|,
operator|&
name|val_items
block|,
operator|&
name|val_pages
block|,
operator|&
name|val_name
block|,
operator|(
expr|struct
name|heads
operator|*
operator|)
name|CNIL
block|}
struct|,
name|funct_str
init|=
block|{
operator|(
name|char
operator|*
operator|)
name|CNIL
block|,
literal|0
block|,
name|BCDSPP
block|,
name|BCD
block|,
literal|2
block|,
operator|&
name|funct_items
block|,
operator|&
name|funct_pages
block|,
operator|&
name|funct_name
block|,
operator|(
expr|struct
name|heads
operator|*
operator|)
name|CNIL
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|int
name|initflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* starts off TRUE: initially gc not allowed */
end_comment

begin_decl_stmt
name|int
name|gcflag
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  TRUE during garbage collection  */
end_comment

begin_decl_stmt
name|int
name|current
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pages currently allocated */
end_comment

begin_define
define|#
directive|define
name|NUMSPACES
value|9
end_define

begin_function_decl
specifier|static
name|struct
name|types
modifier|*
function_decl|(
name|spaces
function_decl|[
name|NUMSPACES
function_decl|]
end_function_decl

begin_expr_stmt
unit|)
operator|=
block|{
operator|&
name|atom_str
block|,
operator|&
name|strng_str
block|,
operator|&
name|int_str
block|,
operator|&
name|dtpr_str
block|,
operator|&
name|doub_str
block|,
operator|&
name|array_str
block|,
operator|&
name|sdot_str
block|,
operator|&
name|val_str
block|,
operator|&
name|funct_str
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/** get_more_space(type_struct) *****************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Allocates and structures a new page, returning 0.			*/
end_comment

begin_comment
comment|/*  If no space is available, returns 1.				*/
end_comment

begin_macro
name|get_more_space
argument_list|(
argument|type_struct
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|types
modifier|*
name|type_struct
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|cntr
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|int
modifier|*
name|loop
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|lispval
name|p
decl_stmt|,
name|plim
decl_stmt|;
name|struct
name|heads
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|initflag
operator|==
name|FALSE
condition|)
comment|/*  mustn't look at plist of plima too soon  */
block|{
while|while
condition|(
name|plim
operator|=
name|copval
argument_list|(
name|plima
argument_list|,
operator|(
name|lispval
operator|)
name|CNIL
argument_list|)
operator|,
name|TYPE
argument_list|(
name|plim
argument_list|)
operator|!=
name|INT
condition|)
name|copval
argument_list|(
name|plima
argument_list|,
name|error
argument_list|(
literal|"BAD PAGE LIMIT"
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plim
operator|->
name|i
operator|<=
name|current
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/*  Can't allocate  */
block|}
if|if
condition|(
name|current
operator|>=
name|TTSIZE
condition|)
return|return
operator|(
literal|2
operator|)
return|;
name|start
operator|=
name|xsbrk
argument_list|(
name|NBPG
argument_list|)
expr_stmt|;
comment|/* bump the page counter for this space */
operator|++
operator|(
operator|(
operator|*
operator|(
name|type_struct
operator|->
name|pages
operator|)
operator|)
operator|->
name|i
operator|)
expr_stmt|;
name|SETTYPE
argument_list|(
name|start
argument_list|,
name|type_struct
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/*  set type of page  */
name|type_struct
operator|->
name|space_left
operator|=
name|type_struct
operator|->
name|space
expr_stmt|;
name|next
operator|=
operator|&
name|header
index|[
name|current
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|type_struct
operator|->
name|type
operator|)
operator|==
name|STRNG
condition|)
block|{
name|type_struct
operator|->
name|next_free
operator|=
name|start
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  space was available  */
block|}
name|next
operator|->
name|pntr
operator|=
name|start
expr_stmt|;
name|next
operator|->
name|link
operator|=
name|type_struct
operator|->
name|first
expr_stmt|;
name|type_struct
operator|->
name|first
operator|=
name|next
expr_stmt|;
name|temp
operator|=
name|loop
operator|=
operator|(
name|int
operator|*
operator|)
name|start
expr_stmt|;
for|for
control|(
name|cntr
operator|=
literal|1
init|;
name|cntr
operator|<
name|type_struct
operator|->
name|space
condition|;
name|cntr
operator|++
control|)
name|loop
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|*
name|loop
operator|=
call|(
name|int
call|)
argument_list|(
name|loop
operator|+
name|type_struct
operator|->
name|type_len
argument_list|)
operator|)
expr_stmt|;
operator|*
name|loop
operator|=
call|(
name|int
call|)
argument_list|(
name|type_struct
operator|->
name|next_free
argument_list|)
expr_stmt|;
name|type_struct
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
name|temp
expr_stmt|;
comment|/*  if type atom, set pnames to CNIL  */
if|if
condition|(
name|type_struct
operator|==
operator|&
name|atom_str
condition|)
for|for
control|(
name|cntr
operator|=
literal|0
operator|,
name|p
operator|=
operator|(
name|lispval
operator|)
name|temp
init|;
name|cntr
operator|<
name|atom_str
operator|.
name|space
condition|;
operator|++
name|cntr
control|)
block|{
name|p
operator|->
name|pname
operator|=
operator|(
name|char
operator|*
operator|)
name|CNIL
expr_stmt|;
name|p
operator|=
call|(
name|lispval
call|)
argument_list|(
operator|(
name|int
operator|*
operator|)
name|p
operator|+
name|atom_str
operator|.
name|type_len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  space was available  */
block|}
end_block

begin_comment
comment|/** next_one(type_struct) ************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Allocates one new item of each kind of space, except STRNG.		*/
end_comment

begin_comment
comment|/*  If there is no space, calls gc, the garbage collector.		*/
end_comment

begin_comment
comment|/*  If there is still no space, allocates a new page using		*/
end_comment

begin_comment
comment|/*  get_more_space(type_struct)						*/
end_comment

begin_function
name|lispval
name|next_one
parameter_list|(
name|type_struct
parameter_list|)
name|struct
name|types
modifier|*
name|type_struct
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
name|snpand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|type_struct
operator|->
name|next_free
operator|==
operator|(
name|char
operator|*
operator|)
name|CNIL
condition|)
block|{
name|int
name|g
decl_stmt|;
if|if
condition|(
operator|(
name|type_struct
operator|->
name|type
operator|!=
name|ATOM
operator|)
operator|&&
comment|/* can't collect atoms */
operator|(
name|type_struct
operator|->
name|type
operator|!=
name|STRNG
operator|)
operator|&&
comment|/* can't collect strings */
operator|(
name|gcthresh
operator|->
name|i
operator|<=
name|current
operator|)
operator|&&
comment|/* threshhold for gc */
name|ISNIL
argument_list|(
name|copval
argument_list|(
name|gcdis
argument_list|,
name|CNIL
argument_list|)
argument_list|)
operator|&&
comment|/* gc not disabled */
operator|(
name|NOTNIL
argument_list|(
name|copval
argument_list|(
name|gcload
argument_list|,
name|CNIL
argument_list|)
argument_list|)
operator|||
operator|(
name|loading
operator|->
name|clb
operator|!=
name|tatom
operator|)
operator|)
operator|&&
comment|/* not to collect during load */
operator|(
name|initflag
operator|==
name|FALSE
operator|)
operator|&&
comment|/* dont gc during init */
operator|(
name|gcflag
operator|==
name|FALSE
operator|)
condition|)
comment|/* don't recurse gc */
block|{
comment|/* fputs("Collecting",poport); 			dmpport(poport);*/
name|gc
argument_list|(
name|type_struct
argument_list|)
expr_stmt|;
comment|/*  collect  */
block|}
if|if
condition|(
name|type_struct
operator|->
name|next_free
operator|!=
operator|(
name|char
operator|*
operator|)
name|CNIL
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|g
operator|=
name|get_more_space
argument_list|(
name|type_struct
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|g
operator|==
literal|1
condition|)
block|{
name|plimit
operator|->
name|i
operator|=
name|current
operator|+
name|NUMSPACES
expr_stmt|;
comment|/*  allow a few more pages  */
name|copval
argument_list|(
name|plima
argument_list|,
name|plimit
argument_list|)
expr_stmt|;
comment|/*  restore to reserved reg  */
name|error
argument_list|(
literal|"PAGE LIMIT EXCEEDED--EMERGENCY PAGES ALLOCATED"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"SORRY, ABSOLUTE PAGE LIMIT HAS BEEN REACHED"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|type_struct
operator|->
name|next_free
expr_stmt|;
name|type_struct
operator|->
name|next_free
operator|=
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|type_struct
operator|->
name|next_free
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newint
parameter_list|()
block|{
operator|++
operator|(
name|int_items
operator|->
name|i
operator|)
expr_stmt|;
return|return
operator|(
name|next_one
argument_list|(
operator|&
name|int_str
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newdot
parameter_list|()
block|{
name|lispval
name|temp
decl_stmt|;
operator|++
operator|(
name|dtpr_items
operator|->
name|i
operator|)
expr_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|dtpr_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|car
operator|=
name|temp
operator|->
name|cdr
operator|=
name|nil
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newdoub
parameter_list|()
block|{
operator|++
operator|(
name|doub_items
operator|->
name|i
operator|)
expr_stmt|;
return|return
operator|(
name|next_one
argument_list|(
operator|&
name|doub_str
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newsdot
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
operator|++
operator|(
name|dtpr_items
operator|->
name|i
operator|)
expr_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|sdot_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|car
operator|=
name|temp
operator|->
name|cdr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|atom
modifier|*
name|newatom
parameter_list|()
block|{
name|struct
name|atom
modifier|*
name|save
decl_stmt|;
operator|++
operator|(
name|atom_items
operator|->
name|i
operator|)
expr_stmt|;
name|save
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|next_one
argument_list|(
operator|&
name|atom_str
argument_list|)
expr_stmt|;
name|save
operator|->
name|plist
operator|=
name|save
operator|->
name|fnbnd
operator|=
name|nil
expr_stmt|;
name|save
operator|->
name|hshlnk
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|CNIL
expr_stmt|;
name|save
operator|->
name|clb
operator|=
name|CNIL
expr_stmt|;
name|save
operator|->
name|pname
operator|=
name|newstr
argument_list|()
expr_stmt|;
return|return
operator|(
name|save
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|newstr
parameter_list|()
block|{
name|char
modifier|*
name|save
decl_stmt|;
name|int
name|atmlen2
decl_stmt|;
operator|++
operator|(
name|str_items
operator|->
name|i
operator|)
expr_stmt|;
name|atmlen
operator|=
name|strlen
argument_list|(
name|strbuf
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|atmlen
operator|>
name|strng_str
operator|.
name|space_left
condition|)
while|while
condition|(
name|get_more_space
argument_list|(
operator|&
name|strng_str
argument_list|)
condition|)
name|error
argument_list|(
literal|"YOU HAVE RUN OUT OF SPACE"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|save
operator|=
name|strng_str
operator|.
name|next_free
operator|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|atmlen2
operator|=
name|atmlen
expr_stmt|;
while|while
condition|(
name|atmlen2
operator|%
literal|4
condition|)
operator|++
name|atmlen2
expr_stmt|;
comment|/*  even up length of string  */
name|strng_str
operator|.
name|next_free
operator|+=
name|atmlen2
expr_stmt|;
name|strng_str
operator|.
name|space_left
operator|-=
name|atmlen2
expr_stmt|;
return|return
operator|(
name|save
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|inewstr
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|strbuf
index|[
name|STRBLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpyn
argument_list|(
name|strbuf
argument_list|,
name|s
argument_list|,
name|STRBLEN
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|newstr
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newarray
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
operator|++
operator|(
name|array_items
operator|->
name|i
operator|)
expr_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|array_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|nil
expr_stmt|;
name|temp
operator|->
name|accfun
operator|=
name|nil
expr_stmt|;
name|temp
operator|->
name|aux
operator|=
name|nil
expr_stmt|;
name|temp
operator|->
name|length
operator|=
name|SMALL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|->
name|delta
operator|=
name|SMALL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|badcall
parameter_list|()
block|{
name|error
argument_list|(
literal|"BAD FUNCTION DESCRIPTOR USED IN CALL"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|lispval
name|newfunct
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
operator|++
operator|(
name|funct_items
operator|->
name|i
operator|)
expr_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|funct_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|entry
operator|=
name|badcall
expr_stmt|;
name|temp
operator|->
name|discipline
operator|=
name|nil
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newval
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
operator|++
operator|(
name|val_items
operator|->
name|i
operator|)
expr_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|val_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|l
operator|=
name|nil
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|inewval
parameter_list|(
name|arg
parameter_list|)
name|lispval
name|arg
decl_stmt|;
block|{
name|lispval
name|temp
decl_stmt|;
operator|++
operator|(
name|val_items
operator|->
name|i
operator|)
expr_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|val_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|l
operator|=
name|arg
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Ngc *****************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  LISP interface to gc.						*/
end_comment

begin_function
name|lispval
name|Ngc
parameter_list|()
block|{
name|lispval
name|temp
decl_stmt|;
if|if
condition|(
name|ISNIL
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
condition|)
return|return
operator|(
name|gc
argument_list|(
name|CNIL
argument_list|)
operator|)
return|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|DTPR
condition|)
name|error
argument_list|(
literal|"BAD CALL TO GC"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|chkport
operator|=
name|poport
expr_stmt|;
if|if
condition|(
name|NOTNIL
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|car
argument_list|)
condition|)
block|{
name|temp
operator|=
name|eval
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|car
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|==
name|PORT
condition|)
name|chkport
operator|=
operator|(
name|FILE
operator|*
operator|)
operator|*
name|temp
expr_stmt|;
block|}
name|gc1
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_comment
comment|/** gc(type_struct) *****************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  garbage collector:  Collects garbage by mark and sweep algorithm.	*/
end_comment

begin_comment
comment|/*  After this is done, calls the Nlambda, gcafter.			*/
end_comment

begin_comment
comment|/*  gc may also be called from LISP, as a lambda of no arguments.	*/
end_comment

begin_function
name|lispval
name|gc
parameter_list|(
name|type_struct
parameter_list|)
name|struct
name|types
modifier|*
name|type_struct
decl_stmt|;
block|{
name|lispval
name|save
decl_stmt|;
struct|struct
block|{
name|long
name|mytime
decl_stmt|;
name|long
name|allelse
index|[
literal|3
index|]
decl_stmt|;
block|}
name|begin
struct|,
name|finish
struct|;
specifier|extern
name|int
name|GCtime
decl_stmt|;
name|save
operator|=
name|copval
argument_list|(
name|gcport
argument_list|,
name|CNIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|GCtime
condition|)
name|times
argument_list|(
operator|&
name|begin
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|TYPE
argument_list|(
name|save
argument_list|)
operator|!=
name|PORT
operator|)
operator|&&
name|NOTNIL
argument_list|(
name|save
argument_list|)
condition|)
name|save
operator|=
name|error
argument_list|(
literal|"NEED PORT FOR GC"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|chkport
operator|=
name|ISNIL
argument_list|(
name|save
argument_list|)
condition|?
name|poport
else|:
operator|(
name|FILE
operator|*
operator|)
operator|*
name|save
expr_stmt|;
name|gc1
argument_list|(
name|NOTNIL
argument_list|(
name|copval
argument_list|(
name|gccheck
argument_list|,
name|CNIL
argument_list|)
argument_list|)
operator|||
operator|(
name|chkport
operator|!=
name|poport
operator|)
argument_list|)
expr_stmt|;
comment|/* mark&sweep */
comment|/* Now we call gcafter--special case if gc called from LISP */
if|if
condition|(
name|type_struct
operator|==
operator|(
expr|struct
name|types
operator|*
operator|)
name|CNIL
condition|)
name|gccall1
operator|->
name|cdr
operator|=
name|nil
expr_stmt|;
comment|/* make the call "(gcafter)" */
else|else
block|{
name|gccall1
operator|->
name|cdr
operator|=
name|gccall2
expr_stmt|;
name|gccall2
operator|->
name|car
operator|=
operator|*
operator|(
name|type_struct
operator|->
name|type_name
operator|)
expr_stmt|;
block|}
name|gcflag
operator|=
name|TRUE
expr_stmt|;
comment|/*  flag to indicate in garbage collector  */
name|save
operator|=
name|eval
argument_list|(
name|gccall1
argument_list|)
expr_stmt|;
comment|/*  call gcafter  */
name|gcflag
operator|=
name|FALSE
expr_stmt|;
comment|/*  turn off flag  */
if|if
condition|(
name|GCtime
condition|)
block|{
name|times
argument_list|(
operator|&
name|finish
argument_list|)
expr_stmt|;
name|GCtime
operator|+=
operator|(
name|finish
operator|.
name|mytime
operator|-
name|begin
operator|.
name|mytime
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|save
operator|)
return|;
comment|/*  return result of gcafter  */
block|}
end_function

begin_comment
comment|/*  gc1()  **************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Mark-and-sweep phase						*/
end_comment

begin_macro
name|gc1
argument_list|(
argument|chkflag
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chkflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|typep
decl_stmt|;
specifier|register
name|int
modifier|*
name|start
decl_stmt|,
modifier|*
name|point
decl_stmt|;
name|struct
name|types
modifier|*
name|s
decl_stmt|;
name|struct
name|heads
modifier|*
name|loop
decl_stmt|;
name|struct
name|argent
modifier|*
name|loop2
decl_stmt|;
name|int
name|markdp
parameter_list|()
function_decl|;
comment|/*  decide whether to check LISP structure or not  */
comment|/*  first set all bit maps to zero  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
name|int
operator|)
name|datalim
operator|>>
literal|8
operator|)
condition|;
operator|++
name|i
control|)
name|bitmapq
index|[
name|i
index|]
operator|=
name|zeroq
expr_stmt|;
comment|/* then mark all atoms' plists, clbs, and function bindings */
for|for
control|(
name|loop
operator|=
name|atom_str
operator|.
name|first
init|;
name|loop
operator|!=
operator|(
expr|struct
name|heads
operator|*
operator|)
name|CNIL
condition|;
name|loop
operator|=
name|loop
operator|->
name|link
control|)
for|for
control|(
name|start
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|loop
operator|->
name|pntr
operator|)
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|atom_str
operator|.
name|space
condition|;
name|start
operator|=
name|start
operator|+
name|atom_str
operator|.
name|type_len
operator|,
operator|++
name|i
control|)
block|{
comment|/* unused atoms are marked with pname == CNIL */
comment|/* this is done by get_more_space, as well as */
comment|/* by gc (in the future)		      */
if|if
condition|(
operator|(
operator|(
name|lispval
operator|)
name|start
operator|)
operator|->
name|pname
operator|==
operator|(
name|char
operator|*
operator|)
name|CNIL
condition|)
continue|continue;
define|#
directive|define
name|MARKSUB
parameter_list|(
name|p
parameter_list|)
value|if(nil!=((lispval)start)->p)markdp(((lispval)start)->p);
name|MARKSUB
argument_list|(
name|clb
argument_list|)
expr_stmt|;
name|MARKSUB
argument_list|(
name|fnbnd
argument_list|)
expr_stmt|;
name|MARKSUB
argument_list|(
name|plist
argument_list|)
expr_stmt|;
block|}
comment|/* next run up the name stack */
for|for
control|(
name|loop2
operator|=
name|np
operator|-
literal|1
init|;
name|loop2
operator|>=
name|orgnp
condition|;
operator|--
name|loop2
control|)
name|markdp
argument_list|(
operator|(
name|loop2
operator|->
name|val
operator|)
argument_list|)
expr_stmt|;
comment|/* from TBL 29july79  */
comment|/* next mark all compiler linked data */
name|point
operator|=
name|bind_lists
expr_stmt|;
while|while
condition|(
operator|(
name|start
operator|=
name|point
operator|)
operator|!=
operator|(
name|int
operator|*
operator|)
name|CNIL
condition|)
block|{
while|while
condition|(
operator|*
name|start
operator|!=
operator|-
literal|1
condition|)
name|markdp
argument_list|(
operator|*
name|start
operator|++
argument_list|)
expr_stmt|;
name|point
operator|=
operator|(
name|int
operator|*
operator|)
operator|*
operator|(
name|point
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* end from TBL */
comment|/* next mark all system-significant lisp data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIGNIF
condition|;
operator|++
name|i
control|)
name|markdp
argument_list|(
operator|(
name|lispsys
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* all accessible data has now been marked. */
comment|/* all collectable spaces must be swept,    */
comment|/* and freelists constructed.		    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMSPACES
condition|;
operator|++
name|i
control|)
block|{
comment|/* STRINGS do not participate. */
comment|/* ATOMS dont either (currently) */
name|s
operator|=
name|spaces
index|[
name|i
index|]
expr_stmt|;
name|typep
operator|=
name|s
operator|->
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|typep
operator|==
name|STRNG
operator|)
operator|||
operator|(
name|typep
operator|==
name|ATOM
operator|)
condition|)
continue|continue;
name|s
operator|->
name|space_left
operator|=
literal|0
expr_stmt|;
comment|/* we will count free cells */
operator|(
operator|*
operator|(
name|s
operator|->
name|items
operator|)
operator|)
operator|->
name|i
operator|=
literal|0
expr_stmt|;
comment|/* and compute cells used    */
comment|/* for each space, traverse list of pages. */
name|s
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
name|CNIL
expr_stmt|;
comment|/*  reinitialize free list  */
for|for
control|(
name|loop
operator|=
name|s
operator|->
name|first
init|;
name|loop
operator|!=
operator|(
expr|struct
name|heads
operator|*
operator|)
name|CNIL
condition|;
name|loop
operator|=
name|loop
operator|->
name|link
control|)
block|{
comment|/* add another page's worth to use count */
operator|(
operator|*
operator|(
name|s
operator|->
name|items
operator|)
operator|)
operator|->
name|i
operator|+=
name|s
operator|->
name|space
expr_stmt|;
comment|/* for each page, make a list of unmarked data */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|point
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|loop
operator|->
name|pntr
operator|)
init|;
name|j
operator|<
name|s
operator|->
name|space
condition|;
operator|++
name|j
operator|,
name|point
operator|+=
name|s
operator|->
name|type_len
control|)
if|if
condition|(
operator|!
name|lookbit
argument_list|(
name|point
argument_list|)
condition|)
block|{
comment|/* add to free list */
comment|/* update pointer to free list*/
comment|/* update count of free list */
operator|*
name|point
operator|=
call|(
name|int
call|)
argument_list|(
name|s
operator|->
name|next_free
argument_list|)
expr_stmt|;
name|s
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
name|point
expr_stmt|;
operator|++
operator|(
name|s
operator|->
name|space_left
operator|)
expr_stmt|;
block|}
block|}
operator|(
operator|*
operator|(
name|s
operator|->
name|items
operator|)
operator|)
operator|->
name|i
operator|-=
name|s
operator|->
name|space_left
expr_stmt|;
comment|/* compute cells used */
block|}
block|}
end_block

begin_comment
comment|/** alloc() *************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  This routine tries to allocate one more page of the space named	*/
end_comment

begin_comment
comment|/*  by the argument.  If no more space is available returns 1, else 0.	*/
end_comment

begin_function
name|lispval
name|alloc
parameter_list|(
name|tname
parameter_list|,
name|npages
parameter_list|)
name|lispval
name|tname
decl_stmt|;
name|int
name|npages
decl_stmt|;
block|{
name|int
name|ii
decl_stmt|,
name|jj
decl_stmt|;
name|ii
operator|=
name|typenum
argument_list|(
name|tname
argument_list|)
expr_stmt|;
for|for
control|(
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
name|npages
condition|;
operator|++
name|jj
control|)
if|if
condition|(
name|get_more_space
argument_list|(
name|spaces
index|[
name|ii
index|]
argument_list|)
condition|)
break|break;
return|return
operator|(
name|inewint
argument_list|(
name|jj
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|csegment
parameter_list|(
name|tname
parameter_list|,
name|nitems
parameter_list|)
name|lispval
name|tname
decl_stmt|;
name|int
name|nitems
decl_stmt|;
block|{
name|int
name|ii
decl_stmt|,
name|jj
decl_stmt|;
name|char
modifier|*
name|charadd
decl_stmt|;
name|ii
operator|=
name|typenum
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|nitems
operator|=
name|nitems
operator|*
literal|4
operator|*
name|spaces
index|[
name|ii
index|]
operator|->
name|type_len
expr_stmt|;
comment|/*  find c-length of space  */
while|while
condition|(
name|nitems
operator|%
literal|512
condition|)
operator|++
name|nitems
expr_stmt|;
comment|/*  round up to right length  */
name|current
operator|+=
name|nitems
operator|/
literal|512
expr_stmt|;
name|charadd
operator|=
name|sbrk
argument_list|(
name|nitems
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|charadd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"NOT ENOUGH SPACE FOR ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|datalim
operator|=
call|(
name|lispval
call|)
argument_list|(
name|charadd
operator|+
name|nitems
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|int
operator|)
name|datalim
operator|)
operator|>>
literal|9
operator|)
operator|>
name|TTSIZE
condition|)
block|{
name|datalim
operator|=
call|(
name|lispval
call|)
argument_list|(
name|TTSIZE
operator|<<
literal|9
argument_list|)
expr_stmt|;
name|badmem
argument_list|(
literal|53
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
name|nitems
condition|;
name|jj
operator|=
name|jj
operator|+
literal|512
control|)
block|{
name|SETTYPE
argument_list|(
name|charadd
operator|+
name|jj
argument_list|,
name|spaces
index|[
name|ii
index|]
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|lispval
operator|)
name|charadd
operator|)
return|;
block|}
end_function

begin_function
name|int
name|csizeof
parameter_list|(
name|tname
parameter_list|)
name|lispval
name|tname
decl_stmt|;
block|{
return|return
operator|(
name|spaces
index|[
name|typenum
argument_list|(
name|tname
argument_list|)
index|]
operator|->
name|type_len
operator|*
literal|4
operator|)
return|;
block|}
end_function

begin_function
name|int
name|typenum
parameter_list|(
name|tname
parameter_list|)
name|lispval
name|tname
decl_stmt|;
block|{
name|int
name|ii
decl_stmt|;
name|chek
label|:
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|NUMSPACES
condition|;
operator|++
name|ii
control|)
if|if
condition|(
name|tname
operator|==
operator|*
operator|(
name|spaces
index|[
name|ii
index|]
operator|->
name|type_name
operator|)
condition|)
break|break;
if|if
condition|(
name|ii
operator|==
name|NUMSPACES
condition|)
block|{
name|tname
operator|=
name|error
argument_list|(
literal|"BAD TYPE NAME"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|chek
goto|;
block|}
return|return
operator|(
name|ii
operator|)
return|;
block|}
end_function

begin_comment
comment|/** markit(p) ***********************************************************/
end_comment

begin_comment
comment|/*  just calls markdp							*/
end_comment

begin_macro
name|markit
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|lispval
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|markdp
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/** markdp(p) ***********************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  markdp is the routine which marks each data item.  If it is a	*/
end_comment

begin_comment
comment|/*  dotted pair, the car and cdr are marked also.			*/
end_comment

begin_comment
comment|/*  An iterative method is used to mark list structure, to avoid	*/
end_comment

begin_comment
comment|/*  excessive recursion.						*/
end_comment

begin_expr_stmt
name|markdp
argument_list|(
name|p
argument_list|)
specifier|register
name|lispval
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*	register int r, s;	(goes with non-asm readbit, oksetbit)	*/
name|ptr_loop
label|:
if|if
condition|(
operator|(
name|int
operator|)
name|p
operator|<=
literal|0
condition|)
return|return;
comment|/*  do not mark special data types or nil=0  */
switch|switch
condition|(
name|TYPE
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
case|case
name|DOUB
case|:
comment|/*			setbit(p);*/
name|ftstbit
expr_stmt|;
return|return;
case|case
name|VALUE
case|:
name|ftstbit
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|l
expr_stmt|;
goto|goto
name|ptr_loop
goto|;
case|case
name|DTPR
case|:
name|ftstbit
expr_stmt|;
name|markdp
argument_list|(
name|p
operator|->
name|car
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|cdr
expr_stmt|;
goto|goto
name|ptr_loop
goto|;
case|case
name|ARRAY
case|:
name|ftstbit
expr_stmt|;
comment|/* mark array itself */
name|markdp
argument_list|(
name|p
operator|->
name|accfun
argument_list|)
expr_stmt|;
comment|/* mark access function */
name|markdp
argument_list|(
name|p
operator|->
name|aux
argument_list|)
expr_stmt|;
comment|/* mark aux data */
name|markdp
argument_list|(
name|p
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* mark length */
name|markdp
argument_list|(
name|p
operator|->
name|delta
argument_list|)
expr_stmt|;
comment|/* mark delta */
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|int
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|dataptr
init|=
name|p
operator|->
name|data
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|l
operator|=
name|p
operator|->
name|length
operator|->
name|i
operator|,
name|d
operator|=
name|p
operator|->
name|delta
operator|->
name|i
init|;
name|i
operator|<
name|l
condition|;
operator|++
name|i
control|)
block|{
name|markdp
argument_list|(
name|dataptr
argument_list|)
expr_stmt|;
name|dataptr
operator|+=
name|d
expr_stmt|;
block|}
return|return;
block|}
case|case
name|SDOT
case|:
do|do
block|{
name|ftstbit
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|CDR
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
literal|0
condition|)
do|;
return|return;
case|case
name|BCD
case|:
name|ftstbit
expr_stmt|;
name|markdp
argument_list|(
name|p
operator|->
name|discipline
argument_list|)
expr_stmt|;
return|return;
block|}
return|return;
block|}
end_block

begin_function
name|char
modifier|*
name|xsbrk
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|xx
decl_stmt|;
comment|/*  pointer to next available blank page  */
specifier|static
name|int
name|cycle
init|=
literal|0
decl_stmt|;
comment|/*  number of blank pages available  */
name|lispval
name|u
decl_stmt|;
comment|/*  used to compute limits of bit table  */
if|if
condition|(
operator|(
name|cycle
operator|--
operator|)
operator|<=
literal|0
condition|)
block|{
name|cycle
operator|=
literal|15
expr_stmt|;
name|xx
operator|=
name|sbrk
argument_list|(
literal|16
operator|*
name|NBPG
argument_list|)
expr_stmt|;
comment|/*  get pages 16 at a time  */
if|if
condition|(
operator|(
name|int
operator|)
name|xx
operator|==
operator|-
literal|1
condition|)
name|lispend
argument_list|(
literal|"For sbrk from lisp: no space... Goodbye!"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|xx
operator|+=
name|NBPG
expr_stmt|;
name|done
label|:
if|if
condition|(
operator|(
name|u
operator|=
call|(
name|lispval
call|)
argument_list|(
name|xx
operator|+
name|NBPG
argument_list|)
operator|)
operator|>
name|datalim
condition|)
name|datalim
operator|=
name|u
expr_stmt|;
return|return
operator|(
name|xx
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ysbrk
parameter_list|(
name|pages
parameter_list|,
name|type
parameter_list|)
name|int
name|pages
decl_stmt|,
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|xx
decl_stmt|;
comment|/*  will point to block of storage  */
name|int
name|i
decl_stmt|;
name|xx
operator|=
name|sbrk
argument_list|(
name|pages
operator|*
name|NBPG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|xx
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"OUT OF SPACE FOR ARRAY REQUEST"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|datalim
operator|=
call|(
name|lispval
call|)
argument_list|(
name|xx
operator|+
name|pages
operator|*
name|NBPG
argument_list|)
expr_stmt|;
comment|/*  compute bit table limit  */
comment|/*  set type for pages  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pages
condition|;
operator|++
name|i
control|)
block|{
name|SETTYPE
argument_list|(
operator|(
name|xx
operator|+
name|i
operator|*
name|NBPG
operator|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|xx
operator|)
return|;
comment|/*  return pointer to block of storage  */
block|}
end_function

begin_comment
comment|/* getatom **************************************************************/
end_comment

begin_comment
comment|/* returns either an existing atom with the name specified in strbuf, or*/
end_comment

begin_comment
comment|/* if the atom does not already exist, regurgitates a new one and       */
end_comment

begin_comment
comment|/* returns it.                                                          */
end_comment

begin_function
name|lispval
name|getatom
parameter_list|()
block|{
specifier|register
name|lispval
name|aptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|endname
decl_stmt|;
name|lispval
name|b
decl_stmt|;
name|char
name|c
decl_stmt|;
specifier|register
name|int
name|hash
decl_stmt|;
name|snpand
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|name
operator|=
name|strbuf
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
operator|(
name|char
operator|)
literal|0377
condition|)
return|return
operator|(
name|eofa
operator|)
return|;
name|hash
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|name
operator|=
name|strbuf
init|;
operator|*
name|name
condition|;
control|)
block|{
name|hash
operator|^=
operator|*
name|name
operator|++
expr_stmt|;
block|}
name|hash
operator|&=
literal|0177
expr_stmt|;
comment|/*  make sure no high-order bits have crept in  */
name|atmlen
operator|=
name|name
operator|-
name|strbuf
operator|+
literal|1
expr_stmt|;
name|aptr
operator|=
operator|(
name|lispval
operator|)
name|hasht
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|aptr
operator|!=
name|CNIL
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|strbuf
argument_list|,
name|aptr
operator|->
name|pname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|aptr
operator|)
return|;
else|else
name|aptr
operator|=
operator|(
name|lispval
operator|)
name|aptr
operator|->
name|hshlnk
expr_stmt|;
name|aptr
operator|=
operator|(
name|lispval
operator|)
name|newatom
argument_list|()
expr_stmt|;
name|aptr
operator|->
name|hshlnk
operator|=
name|hasht
index|[
name|hash
index|]
expr_stmt|;
name|hasht
index|[
name|hash
index|]
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|aptr
expr_stmt|;
name|endname
operator|=
name|name
operator|-
literal|1
expr_stmt|;
name|name
operator|=
name|strbuf
expr_stmt|;
if|if
condition|(
operator|(
name|atmlen
operator|!=
literal|4
operator|)
operator|&&
operator|(
operator|*
name|name
operator|==
literal|'c'
operator|)
operator|&&
operator|(
operator|*
name|endname
operator|==
literal|'r'
operator|)
condition|)
block|{
name|b
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|protect
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|car
operator|=
name|lambda
expr_stmt|;
name|b
operator|->
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|cdr
expr_stmt|;
name|b
operator|->
name|car
operator|=
name|newdot
argument_list|()
expr_stmt|;
operator|(
name|b
operator|->
name|car
operator|)
operator|->
name|car
operator|=
name|xatom
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|b
operator|->
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|cdr
expr_stmt|;
if|if
condition|(
operator|++
name|name
operator|==
name|endname
condition|)
block|{
name|b
operator|->
name|car
operator|=
operator|(
name|lispval
operator|)
name|xatom
expr_stmt|;
name|aptr
operator|->
name|fnbnd
operator|=
name|unprot
argument_list|()
expr_stmt|;
break|break;
block|}
name|b
operator|->
name|car
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|car
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|name
operator|)
operator|==
literal|'a'
condition|)
name|b
operator|->
name|car
operator|=
name|cara
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
name|b
operator|->
name|car
operator|=
name|cdra
expr_stmt|;
else|else
block|{
name|unprot
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
name|aptr
operator|)
return|;
block|}
end_function

end_unit

