begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"lfuncs.h"
end_include

begin_include
include|#
directive|include
file|"chkrtab.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_function
name|lispval
name|Nsyscall
parameter_list|()
block|{
specifier|register
name|lispval
name|aptr
decl_stmt|,
name|temp
decl_stmt|;
specifier|register
name|int
name|acount
init|=
literal|0
decl_stmt|;
name|int
name|args
index|[
literal|50
index|]
decl_stmt|;
name|snpand
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|aptr
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|temp
operator|=
name|eval
argument_list|(
name|aptr
operator|->
name|car
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|!=
name|INT
condition|)
return|return
operator|(
name|error
argument_list|(
literal|"syscall"
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
name|args
index|[
name|acount
operator|++
index|]
operator|=
name|temp
operator|->
name|i
expr_stmt|;
name|aptr
operator|=
name|aptr
operator|->
name|cdr
expr_stmt|;
while|while
condition|(
name|aptr
operator|!=
name|nil
operator|&&
name|acount
operator|<
literal|49
condition|)
block|{
name|temp
operator|=
name|eval
argument_list|(
name|aptr
operator|->
name|car
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
condition|)
block|{
case|case
name|ATOM
case|:
name|args
index|[
name|acount
operator|++
index|]
operator|=
operator|(
name|int
operator|)
name|temp
operator|->
name|a
operator|.
name|pname
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|args
index|[
name|acount
operator|++
index|]
operator|=
operator|(
name|int
operator|)
name|temp
operator|->
name|i
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|error
argument_list|(
literal|"syscall"
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
block|}
name|aptr
operator|=
name|aptr
operator|->
name|cdr
expr_stmt|;
block|}
if|if
condition|(
name|acount
operator|==
literal|0
condition|)
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* produce arg count message */
name|temp
operator|=
name|newint
argument_list|()
expr_stmt|;
name|temp
operator|->
name|i
operator|=
name|vsyscall
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* eval-when: this has the form (eval-when<list><form1><form2> ...)    where the list may contain any combination of `eval', `load', `compile'.    The interpreter (us) looks for the atom `eval', if it is present    we treat the rest of the forms as a progn. */
end_comment

begin_function
name|lispval
name|Nevwhen
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
name|snpand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|handy
operator|=
operator|(
name|lbot
operator|->
name|val
operator|)
operator|->
name|car
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|cdr
control|)
if|if
condition|(
name|handy
operator|->
name|car
operator|==
operator|(
name|lispval
operator|)
name|Veval
condition|)
block|{
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
operator|(
operator|(
name|lbot
operator|-
literal|1
operator|)
operator|->
name|val
operator|)
operator|->
name|cdr
argument_list|)
expr_stmt|;
return|return
operator|(
name|Nprogn
argument_list|()
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
comment|/* eval not seen */
block|}
end_function

begin_comment
comment|/*	Status functions.   *  These operate on the statuslist stlist which has the form:  *	( status_elem_1 status_elem_2 status_elem_3 ...)  *  where each status element has the form:  *	( name readcode setcode .  readvalue)  *  where  *	name - name of the status feature (the first arg to the status  *		function).  *	readcode - fixnum which tells status how to read the value of  *		this status name.  The codes are #defined.  *	setcode - fixnum which tells sstatus how to set the value of  *		this status name  *	readvalue - the value of the status feature is usually stored  *		here.  *	  * Readcodes:  *  *	ST_READ - if no second arg, return readvalue.  *		  if the second arg is given, we return t if it is eq to  *		  the readvalue.  *	ST_FEATR - used in (status feature xxx) where we test for xxx being  *		  in the status features list  *	ST_SYNT - used in (status syntax c) where we return c's syntax code  *	ST_INTB - read stattab entry  *	ST_NFETR - used in (status nofeature xxx) where we test for xxx not  *		  being in the status features list  *	ST_DMPR - read the dumpmode   *   * Setcodes:  *	ST_NO -  if not allowed to set this status through sstatus.  *	ST_SET - if the second arg is made the readvalue.  *	ST_FEATW - for (sstatus feature xxx), we add xxx to the   *		  (status features) list.  *	ST_TOLC - if non nil, map upper case chars in atoms to lc.  *	ST_CORE - if non nil, have bus errors and segmentation violations  *		  dump core, if nil have them produce a bad-mem err msg  *	ST_INTB - set stattab table entry  *	ST_NFETW - use in (sstatus nofeature xxx) where we wish to remove xxx  *		   from the status feature list.  *	ST_DMPW - set the dumpmode  */
end_comment

begin_function
name|lispval
name|Nstatus
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|,
name|curitm
decl_stmt|,
name|valarg
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|int
name|typ
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ctable
decl_stmt|;
specifier|extern
name|int
name|dmpmode
decl_stmt|;
name|lispval
name|Istsrch
parameter_list|()
function_decl|;
if|if
condition|(
name|lbot
operator|->
name|val
operator|==
name|nil
condition|)
return|return
operator|(
name|nil
operator|)
return|;
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
comment|/* arg list */
while|while
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|DTPR
condition|)
name|handy
operator|=
name|error
argument_list|(
literal|"status: bad arg list"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|curitm
operator|=
name|Istsrch
argument_list|(
name|handy
operator|->
name|car
argument_list|)
expr_stmt|;
comment|/* look for feature */
if|if
condition|(
name|curitm
operator|==
name|nil
condition|)
return|return
operator|(
name|nil
operator|)
return|;
comment|/* non existant */
if|if
condition|(
name|handy
operator|->
name|cdr
operator|==
name|nil
condition|)
name|valarg
operator|=
operator|(
name|lispval
operator|)
name|CNIL
expr_stmt|;
else|else
name|valarg
operator|=
name|handy
operator|->
name|cdr
operator|->
name|car
expr_stmt|;
comment|/* now do the processing with curitm pointing to the requested 	   item in the status list  	 */
switch|switch
condition|(
name|typ
operator|=
name|curitm
operator|->
name|cdr
operator|->
name|car
operator|->
name|i
condition|)
block|{
comment|/* look at readcode */
case|case
name|ST_READ
case|:
name|curitm
operator|=
name|Istsrch
argument_list|(
name|handy
operator|->
name|car
argument_list|)
expr_stmt|;
comment|/* look for name */
if|if
condition|(
name|curitm
operator|==
name|nil
condition|)
return|return
operator|(
name|nil
operator|)
return|;
if|if
condition|(
name|valarg
operator|!=
operator|(
name|lispval
operator|)
name|CNIL
condition|)
name|error
argument_list|(
literal|"status: Second arg not allowed."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|curitm
operator|->
name|cdr
operator|->
name|cdr
operator|->
name|cdr
operator|)
return|;
case|case
name|ST_NFETR
case|:
comment|/* look for feature present */
case|case
name|ST_FEATR
case|:
comment|/* look for feature */
name|curitm
operator|=
name|Istsrch
argument_list|(
name|matom
argument_list|(
literal|"features"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valarg
operator|==
operator|(
name|lispval
operator|)
name|CNIL
condition|)
name|error
argument_list|(
literal|"status: need second arg"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|handy
operator|=
name|curitm
operator|->
name|cdr
operator|->
name|cdr
operator|->
name|cdr
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|cdr
control|)
if|if
condition|(
name|handy
operator|->
name|car
operator|==
name|valarg
condition|)
return|return
operator|(
name|typ
operator|==
name|ST_FEATR
condition|?
name|tatom
else|:
name|nil
operator|)
return|;
return|return
operator|(
name|typ
operator|==
name|ST_FEATR
condition|?
name|nil
else|:
name|tatom
operator|)
return|;
case|case
name|ST_SYNT
case|:
comment|/* want characcter syntax */
name|handy
operator|=
name|Vreadtable
operator|->
name|clb
expr_stmt|;
name|chkrtab
argument_list|(
name|handy
argument_list|)
expr_stmt|;
if|if
condition|(
name|valarg
operator|==
operator|(
name|lispval
operator|)
name|CNIL
condition|)
name|error
argument_list|(
literal|"status: need second arg"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|valarg
argument_list|)
operator|!=
name|ATOM
condition|)
name|valarg
operator|=
name|error
argument_list|(
literal|"status: second arg must be atom"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|indx
operator|=
name|valarg
operator|->
name|pname
index|[
literal|0
index|]
expr_stmt|;
comment|/* get first char */
if|if
condition|(
name|valarg
operator|->
name|pname
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|error
argument_list|(
literal|"status: only one character atom allowed"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|handy
operator|=
name|newint
argument_list|()
operator|)
operator|->
name|i
operator|=
name|ctable
index|[
name|indx
index|]
operator|&
literal|0377
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
case|case
name|ST_RINTB
case|:
return|return
operator|(
name|stattab
index|[
name|curitm
operator|->
name|cdr
operator|->
name|cdr
operator|->
name|cdr
operator|->
name|i
index|]
operator|)
return|;
case|case
name|ST_DMPR
case|:
return|return
operator|(
name|inewint
argument_list|(
name|dmpmode
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|lispval
name|Nsstatus
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
name|lispval
name|Isstatus
parameter_list|()
function_decl|;
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|DTPR
operator|||
name|TYPE
argument_list|(
name|handy
operator|->
name|cdr
argument_list|)
operator|!=
name|DTPR
condition|)
name|handy
operator|=
name|error
argument_list|(
literal|"sstatus: Bad args"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|Isstatus
argument_list|(
name|handy
operator|->
name|car
argument_list|,
name|handy
operator|->
name|cdr
operator|->
name|car
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Isstatus - internal routine to do a set status.	*/
end_comment

begin_function
name|lispval
name|Isstatus
parameter_list|(
name|curnam
parameter_list|,
name|curval
parameter_list|)
name|lispval
name|curnam
decl_stmt|,
name|curval
decl_stmt|;
block|{
specifier|register
name|lispval
name|curitm
decl_stmt|,
name|head
decl_stmt|;
name|lispval
name|Istsrch
argument_list|()
decl_stmt|,
name|Iaddstat
argument_list|()
decl_stmt|;
name|int
name|badmemr
parameter_list|()
function_decl|;
specifier|extern
name|int
name|uctolc
decl_stmt|,
name|dmpmode
decl_stmt|;
name|curitm
operator|=
name|Istsrch
argument_list|(
name|curnam
argument_list|)
expr_stmt|;
comment|/* if doesnt exist, make one up */
if|if
condition|(
name|curitm
operator|==
name|nil
condition|)
name|curitm
operator|=
name|Iaddstat
argument_list|(
name|curnam
argument_list|,
name|ST_READ
argument_list|,
name|ST_SET
argument_list|,
name|nil
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|curitm
operator|->
name|cdr
operator|->
name|cdr
operator|->
name|car
operator|->
name|i
condition|)
block|{
case|case
name|ST_NO
case|:
name|error
argument_list|(
literal|"sstatus: cannot set this status"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
case|case
name|ST_SET
case|:
goto|goto
name|setit
goto|;
case|case
name|ST_FEATW
case|:
name|curitm
operator|=
name|Istsrch
argument_list|(
name|matom
argument_list|(
literal|"features"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|curnam
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|car
operator|=
name|curval
expr_stmt|;
name|curnam
operator|->
name|cdr
operator|=
name|curitm
operator|->
name|cdr
operator|->
name|cdr
operator|->
name|cdr
expr_stmt|;
comment|/* old val */
name|curitm
operator|->
name|cdr
operator|->
name|cdr
operator|->
name|cdr
operator|=
name|curnam
expr_stmt|;
return|return
operator|(
name|curval
operator|)
return|;
case|case
name|ST_NFETW
case|:
comment|/* remove from features list */
name|curitm
operator|=
name|Istsrch
argument_list|(
name|matom
argument_list|(
literal|"features"
argument_list|)
argument_list|)
operator|->
name|cdr
operator|->
name|cdr
expr_stmt|;
for|for
control|(
name|head
operator|=
name|curitm
operator|->
name|cdr
init|;
name|head
operator|!=
name|nil
condition|;
name|head
operator|=
name|head
operator|->
name|cdr
control|)
block|{
if|if
condition|(
name|head
operator|->
name|car
operator|==
name|curval
condition|)
name|curitm
operator|->
name|cdr
operator|=
name|head
operator|->
name|cdr
expr_stmt|;
else|else
name|curitm
operator|=
name|head
expr_stmt|;
block|}
return|return
operator|(
name|nil
operator|)
return|;
case|case
name|ST_TOLC
case|:
if|if
condition|(
name|curval
operator|==
name|nil
condition|)
name|uctolc
operator|=
name|FALSE
expr_stmt|;
else|else
name|uctolc
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|setit
goto|;
case|case
name|ST_CORE
case|:
if|if
condition|(
name|curval
operator|==
name|nil
condition|)
block|{
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|badmemr
argument_list|)
expr_stmt|;
comment|/* catch bus errors */
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|badmemr
argument_list|)
expr_stmt|;
comment|/* and segmentation viols */
block|}
else|else
block|{
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* let them core dump */
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
goto|goto
name|setit
goto|;
case|case
name|ST_INTB
case|:
name|stattab
index|[
name|curitm
operator|->
name|cdr
operator|->
name|cdr
operator|->
name|cdr
operator|->
name|i
index|]
operator|=
name|curval
expr_stmt|;
return|return
operator|(
name|curval
operator|)
return|;
case|case
name|ST_DMPW
case|:
if|if
condition|(
name|TYPE
argument_list|(
name|curval
argument_list|)
operator|!=
name|INT
operator|||
operator|(
name|curval
operator|->
name|i
operator|!=
literal|413
operator|&&
name|curval
operator|->
name|i
operator|!=
literal|410
operator|)
condition|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"sstatus: bad dump mode:"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|curval
argument_list|)
expr_stmt|;
name|dmpmode
operator|=
name|curval
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|curval
operator|)
return|;
block|}
name|setit
label|:
comment|/* store value in status list */
name|curitm
operator|->
name|cdr
operator|->
name|cdr
operator|->
name|cdr
operator|=
name|curval
expr_stmt|;
return|return
operator|(
name|curval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Istsrch - utility routine to search the status list for the    name given as an argument.  If such an entry is not found,    we return nil  */
end_comment

begin_function
name|lispval
name|Istsrch
parameter_list|(
name|nam
parameter_list|)
name|lispval
name|nam
decl_stmt|;
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
for|for
control|(
name|handy
operator|=
name|stlist
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|cdr
control|)
if|if
condition|(
name|handy
operator|->
name|car
operator|->
name|car
operator|==
name|nam
condition|)
return|return
operator|(
name|handy
operator|->
name|car
operator|)
return|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Iaddstat - add a status entry to the status list	*/
end_comment

begin_comment
comment|/*	return new entry in status list */
end_comment

begin_function
name|lispval
name|Iaddstat
parameter_list|(
name|name
parameter_list|,
name|readcode
parameter_list|,
name|setcode
parameter_list|,
name|valu
parameter_list|)
name|lispval
name|name
decl_stmt|,
name|valu
decl_stmt|;
name|int
name|readcode
decl_stmt|,
name|setcode
decl_stmt|;
block|{
specifier|register
name|lispval
name|handy
decl_stmt|,
name|handy2
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|handy
operator|=
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
comment|/* build status list here */
operator|(
name|handy2
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|car
operator|=
name|name
expr_stmt|;
name|handy
operator|->
name|car
operator|=
name|handy2
expr_stmt|;
operator|(
operator|(
name|handy2
operator|->
name|cdr
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|car
operator|=
name|newint
argument_list|()
operator|)
operator|->
name|i
operator|=
name|readcode
expr_stmt|;
name|handy2
operator|=
name|handy2
operator|->
name|cdr
expr_stmt|;
operator|(
operator|(
name|handy2
operator|->
name|cdr
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|car
operator|=
name|newint
argument_list|()
operator|)
operator|->
name|i
operator|=
name|setcode
expr_stmt|;
name|handy2
operator|->
name|cdr
operator|->
name|cdr
operator|=
name|valu
expr_stmt|;
comment|/* link this one in */
name|handy
operator|->
name|cdr
operator|=
name|stlist
expr_stmt|;
name|stlist
operator|=
name|handy
expr_stmt|;
return|return
operator|(
name|handy
operator|->
name|car
operator|)
return|;
comment|/* return new item in stlist */
block|}
end_function

end_unit

