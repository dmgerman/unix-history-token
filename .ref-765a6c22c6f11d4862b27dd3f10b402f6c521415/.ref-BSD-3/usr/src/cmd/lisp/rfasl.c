begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|"chkrtab.h"
end_include

begin_comment
comment|/* rfasl  - really fast loader		j.k.foderaro  * this loader is tuned for the lisp fast loading application  * any changes in the system loading procedure will require changes  * to this file  * Nov 4, 1979 - this now becomes fasl to the lisp world  */
end_comment

begin_comment
comment|/* global variables to keep track of allocation */
end_comment

begin_decl_stmt
name|int
name|curps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* external functions called or referenced */
end_comment

begin_decl_stmt
name|int
name|_qf0
argument_list|()
decl_stmt|,
name|_qf1
argument_list|()
decl_stmt|,
name|_qf2
argument_list|()
decl_stmt|,
name|_qf3
argument_list|()
decl_stmt|,
name|_qf4
argument_list|()
decl_stmt|,
name|_qfuncl
argument_list|()
decl_stmt|,
name|svkludg
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
name|Lread
argument_list|()
decl_stmt|,
name|Lcons
argument_list|()
decl_stmt|,
name|Lminus
argument_list|()
decl_stmt|,
name|Ladd1
argument_list|()
decl_stmt|,
name|Lsub1
argument_list|()
decl_stmt|,
name|Lplist
argument_list|()
decl_stmt|,
name|Lputprop
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
name|Lprint
argument_list|()
decl_stmt|,
name|Lpatom
argument_list|()
decl_stmt|,
name|Lconcat
argument_list|()
decl_stmt|,
name|Lget
argument_list|()
decl_stmt|,
name|Lmapc
argument_list|()
decl_stmt|,
name|Lmapcan
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
name|Llist
argument_list|()
decl_stmt|,
name|Ladd
argument_list|()
decl_stmt|,
name|Lgreaterp
argument_list|()
decl_stmt|,
name|Lequal
argument_list|()
decl_stmt|,
name|Ltimes
argument_list|()
decl_stmt|,
name|Lsub
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|lispval
name|Lncons
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|lispval
name|Idothrow
argument_list|()
decl_stmt|,
name|error
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|lispval
modifier|*
name|tynames
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|_erthrow
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|setsav
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|initflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* when TRUE, inhibits gc */
end_comment

begin_comment
comment|/* prelud to linker table in data segment    * these locations always begin the data segment, if there is any change  * to the compiler, this must be fixed up.  *  */
end_comment

begin_define
define|#
directive|define
name|PRESIZ
value|(8*4)
end_define

begin_struct
struct|struct
name|prelud
block|{
name|int
name|dummy
index|[
name|PRESIZ
operator|/
literal|4
index|]
decl_stmt|;
block|}
name|prel
init|=
block|{
operator|(
name|int
operator|)
operator|&
name|bnp
block|,
operator|(
name|int
operator|)
name|_qfuncl
block|,
operator|(
name|int
operator|)
name|_qf4
block|,
operator|(
name|int
operator|)
name|_qf3
block|,
operator|(
name|int
operator|)
name|_qf2
block|,
operator|(
name|int
operator|)
name|_qf1
block|,
operator|(
name|int
operator|)
name|_qf0
block|,
operator|(
name|int
operator|)
literal|0
block|}
struct|;
end_struct

begin_comment
comment|/* mini symbol table, contains the only external symbols compiled code    is allowed to reference  */
end_comment

begin_define
define|#
directive|define
name|SYMMAX
value|35
end_define

begin_struct
struct|struct
name|ssym
block|{
name|char
modifier|*
name|fnam
decl_stmt|;
comment|/* pointer to string containing name */
name|int
name|floc
decl_stmt|;
comment|/* address of symbol */
name|int
name|ord
decl_stmt|;
comment|/* ordinal number within cur sym tab */
block|}
name|symbtb
index|[
name|SYMMAX
index|]
init|=
block|{
literal|"_Lminus"
block|,
operator|(
name|int
operator|)
name|Lminus
block|,
operator|-
literal|1
block|,
literal|"_Ladd1"
block|,
operator|(
name|int
operator|)
name|Ladd1
block|,
operator|-
literal|1
block|,
literal|"_Lsub1"
block|,
operator|(
name|int
operator|)
name|Lsub1
block|,
operator|-
literal|1
block|,
literal|"_Lplist"
block|,
operator|(
name|int
operator|)
name|Lplist
block|,
operator|-
literal|1
block|,
literal|"_Lcons"
block|,
operator|(
name|int
operator|)
name|Lcons
block|,
operator|-
literal|1
block|,
literal|"_Lputpro"
block|,
operator|(
name|int
operator|)
name|Lputprop
block|,
operator|-
literal|1
block|,
literal|"_Lprint"
block|,
operator|(
name|int
operator|)
name|Lprint
block|,
operator|-
literal|1
block|,
literal|"_Lpatom"
block|,
operator|(
name|int
operator|)
name|Lpatom
block|,
operator|-
literal|1
block|,
literal|"_Lread"
block|,
operator|(
name|int
operator|)
name|Lread
block|,
operator|-
literal|1
block|,
literal|"_Lconcat"
block|,
operator|(
name|int
operator|)
name|Lconcat
block|,
operator|-
literal|1
block|,
literal|"_Lget"
block|,
operator|(
name|int
operator|)
name|Lget
block|,
operator|-
literal|1
block|,
literal|"_Lmapc"
block|,
operator|(
name|int
operator|)
name|Lmapc
block|,
operator|-
literal|1
block|,
literal|"_Lmapcan"
block|,
operator|(
name|int
operator|)
name|Lmapcan
block|,
operator|-
literal|1
block|,
literal|"_Llist"
block|,
operator|(
name|int
operator|)
name|Llist
block|,
operator|-
literal|1
block|,
literal|"_Ladd"
block|,
operator|(
name|int
operator|)
name|Ladd
block|,
operator|-
literal|1
block|,
literal|"_Lgreate"
block|,
operator|(
name|int
operator|)
name|Lgreaterp
block|,
operator|-
literal|1
block|,
literal|"_Lequal"
block|,
operator|(
name|int
operator|)
name|Lequal
block|,
operator|-
literal|1
block|,
literal|"_Ltimes"
block|,
operator|(
name|int
operator|)
name|Ltimes
block|,
operator|-
literal|1
block|,
literal|"_Lsub"
block|,
operator|(
name|int
operator|)
name|Lsub
block|,
operator|-
literal|1
block|,
literal|"_Lncons"
block|,
operator|(
name|int
operator|)
name|Lncons
block|,
operator|-
literal|1
block|,
literal|"_typetab"
block|,
operator|(
name|int
operator|)
name|typetab
block|,
operator|-
literal|1
block|,
literal|"_tynames"
block|,
operator|(
name|int
operator|)
name|tynames
block|,
operator|-
literal|1
block|,
literal|"_errp"
block|,
operator|(
name|int
operator|)
operator|&
name|errp
block|,
operator|-
literal|1
block|,
literal|"_Idothro"
block|,
operator|(
name|int
operator|)
name|Idothrow
block|,
operator|-
literal|1
block|,
literal|"__erthro"
block|,
operator|(
name|int
operator|)
name|_erthrow
block|,
operator|-
literal|1
block|,
literal|"_error"
block|,
operator|(
name|int
operator|)
name|error
block|,
operator|-
literal|1
block|,
literal|"_bnp"
block|,
operator|(
name|int
operator|)
operator|&
name|bnp
block|,
operator|-
literal|1
block|,
literal|"__qfuncl"
block|,
operator|(
name|int
operator|)
name|_qfuncl
block|,
operator|-
literal|1
block|,
literal|"__qf4"
block|,
operator|(
name|int
operator|)
name|_qf4
block|,
operator|-
literal|1
block|,
literal|"__qf3"
block|,
operator|(
name|int
operator|)
name|_qf3
block|,
operator|-
literal|1
block|,
literal|"__qf2"
block|,
operator|(
name|int
operator|)
name|_qf2
block|,
operator|-
literal|1
block|,
literal|"__qf1"
block|,
operator|(
name|int
operator|)
name|_qf1
block|,
operator|-
literal|1
block|,
literal|"__qf0"
block|,
operator|(
name|int
operator|)
name|_qf0
block|,
operator|-
literal|1
block|,
literal|"_setsav"
block|,
operator|(
name|int
operator|)
name|setsav
block|,
operator|-
literal|1
block|,
literal|"_svkludg"
block|,
operator|(
name|int
operator|)
name|svkludg
block|,
operator|-
literal|1
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|nlist
name|syml
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to read a.out symb tab */
end_comment

begin_decl_stmt
specifier|extern
name|lispval
modifier|*
name|bind_lists
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gc binding lists 	  */
end_comment

begin_comment
comment|/* bindage structure:  *  the bindage structure describes the linkages of functions and name,  *  and tells which functions should be evaluated.  It is mainly used   *  for the non-fasl'ing of files, we only use one of the fields in fasl  */
end_comment

begin_struct
struct|struct
name|bindage
block|{
name|lispval
function_decl|(
modifier|*
name|b_entry
function_decl|)
parameter_list|()
function_decl|;
comment|/* function entry point */
name|int
name|b_atmlnk
decl_stmt|;
comment|/* pointer to string    */
name|int
name|b_type
decl_stmt|;
comment|/* type code, as described below */
block|}
struct|;
end_struct

begin_comment
comment|/* the possible values of b_type  * -1 - this is the end of the bindage entries  * 0  - this is a lambda function  * 1  - this is a nlambda function  * 2  - this is a macro function  * 99 - evaluate the string  *  */
end_comment

begin_comment
comment|/* maximum number of functions */
end_comment

begin_define
define|#
directive|define
name|MAXFNS
value|500
end_define

begin_function
name|lispval
name|Lfasl
parameter_list|()
block|{
specifier|register
name|int
name|orgtx
decl_stmt|,
name|orgdt
decl_stmt|,
name|orgps
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|svnp
decl_stmt|,
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|exec
name|exblk
decl_stmt|;
comment|/* stores a.out header */
name|FILE
modifier|*
name|filp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|map
decl_stmt|;
comment|/* file pointer */
name|int
name|domap
decl_stmt|;
name|lispval
name|handy
decl_stmt|;
name|struct
name|relocation_info
name|reloc
decl_stmt|;
name|struct
name|prelud
modifier|*
name|ppre
decl_stmt|;
name|lispval
name|disp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|times
decl_stmt|,
modifier|*
name|iptr
decl_stmt|,
name|oldinitflag
decl_stmt|;
name|int
name|funloc
index|[
name|MAXFNS
index|]
decl_stmt|;
comment|/* addresses of functions rel to txt org */
name|int
name|funcnt
init|=
literal|0
decl_stmt|;
comment|/* unrelocated start and end of litteral table */
name|int
name|litstrt
init|=
literal|0
decl_stmt|,
name|litend
init|=
literal|0
decl_stmt|;
name|int
name|segdif
decl_stmt|;
name|struct
name|bindage
modifier|*
name|bindorg
decl_stmt|,
modifier|*
name|curbind
decl_stmt|;
name|int
name|linkerloc
decl_stmt|,
name|bindloc
init|=
literal|0
decl_stmt|,
name|typer
decl_stmt|,
name|linkstrt
decl_stmt|,
name|linkend
decl_stmt|;
name|lispval
name|rdform
decl_stmt|,
modifier|*
name|linktab
decl_stmt|;
name|int
name|segsiz
decl_stmt|;
name|int
name|debug
init|=
literal|0
decl_stmt|;
name|lispval
name|currtab
decl_stmt|,
name|curibase
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|ATOM
condition|)
name|error
argument_list|(
literal|"non atom arg"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|filp
operator|=
name|fopen
argument_list|(
operator|(
name|lbot
operator|->
name|val
operator|)
operator|->
name|pname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Can't open file"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|9797
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
name|domap
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|handy
operator|=
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
operator|)
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|ATOM
operator|)
operator|||
operator|(
name|map
operator|=
name|fopen
argument_list|(
name|handy
operator|->
name|pname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"rfasl: can't open map file"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
name|domap
operator|=
name|TRUE
expr_stmt|;
name|fprintf
argument_list|(
name|map
argument_list|,
literal|"Map of file %s\n"
argument_list|,
name|lbot
operator|->
name|val
operator|->
name|pname
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"[fasl %s]"
argument_list|,
name|lbot
operator|->
name|val
operator|->
name|pname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|svnp
operator|=
name|np
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
comment|/* set up base for later calls */
comment|/* clear the ords in the symbol table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYMMAX
condition|;
name|i
operator|++
control|)
name|symbtb
index|[
name|i
index|]
operator|.
name|ord
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|exblk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filp
argument_list|)
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Read failed"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* read in symbol table and set the ordinal values */
name|fseek
argument_list|(
name|filp
argument_list|,
call|(
name|long
call|)
argument_list|(
literal|32
operator|+
name|exblk
operator|.
name|a_text
operator|+
name|exblk
operator|.
name|a_data
operator|+
name|exblk
operator|.
name|a_trsize
operator|+
name|exblk
operator|.
name|a_drsize
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|times
operator|=
name|exblk
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|" %d symbols in symbol table\n"
argument_list|,
name|times
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|times
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|syml
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filp
argument_list|)
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Symb tab read error"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|syml
operator|.
name|n_type
operator|==
name|N_EXT
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SYMMAX
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|symbtb
index|[
name|j
index|]
operator|.
name|ord
operator|<
literal|0
operator|)
operator|&&
name|strcmpn
argument_list|(
name|symbtb
index|[
name|j
index|]
operator|.
name|fnam
argument_list|,
name|syml
operator|.
name|n_name
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|symbtb
index|[
name|j
index|]
operator|.
name|ord
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"symbol %s ord is %d\n"
argument_list|,
name|syml
operator|.
name|n_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|j
operator|>=
name|SYMMAX
condition|)
name|printf
argument_list|(
literal|"Unknown symbol %s\n"
argument_list|,
name|syml
operator|.
name|n_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|ch
operator|=
name|syml
operator|.
name|n_name
index|[
literal|0
index|]
operator|)
operator|==
literal|'s'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'L'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'.'
operator|)
condition|)
empty_stmt|;
comment|/* skip this */
elseif|else
if|if
condition|(
name|syml
operator|.
name|n_name
index|[
literal|0
index|]
operator|==
literal|'F'
condition|)
name|funloc
index|[
name|funcnt
operator|++
index|]
operator|=
name|syml
operator|.
name|n_value
expr_stmt|;
comment|/* seeing function */
elseif|else
if|if
condition|(
operator|!
name|bindloc
operator|&&
operator|(
name|strcmp
argument_list|(
name|syml
operator|.
name|n_name
argument_list|,
literal|"BINDER"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|bindloc
operator|=
name|syml
operator|.
name|n_value
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|syml
operator|.
name|n_name
argument_list|,
literal|"litstrt"
argument_list|)
operator|==
literal|0
condition|)
name|litstrt
operator|=
name|syml
operator|.
name|n_value
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|syml
operator|.
name|n_name
argument_list|,
literal|"litend"
argument_list|)
operator|==
literal|0
condition|)
name|litend
operator|=
name|syml
operator|.
name|n_value
expr_stmt|;
block|}
comment|/* check to make sure we are working with the right format */
if|if
condition|(
operator|(
name|litstrt
operator|==
literal|0
operator|)
operator|||
operator|(
name|litend
operator|==
literal|0
operator|)
condition|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"File not in new fasl format"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/*----------------*/
comment|/* read in text segment */
name|fseek
argument_list|(
name|filp
argument_list|,
operator|(
name|long
operator|)
literal|32
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|segsiz
operator|=
name|exblk
operator|.
name|a_text
operator|+
name|exblk
operator|.
name|a_data
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|curps
operator|=
operator|(
name|int
operator|)
name|csegment
argument_list|(
name|int_name
argument_list|,
name|segsiz
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
name|exblk
operator|.
name|a_text
argument_list|,
name|filp
argument_list|)
operator|!=
name|exblk
operator|.
name|a_text
condition|)
name|error
argument_list|(
literal|"Read error in text and data read"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|orgtx
operator|=
name|curps
expr_stmt|;
name|orgdt
operator|=
name|curps
operator|+
name|exblk
operator|.
name|a_text
expr_stmt|;
name|linkstrt
operator|=
name|orgdt
operator|+
name|PRESIZ
expr_stmt|;
comment|/* start of linker table */
name|linkend
operator|=
name|orgdt
operator|+
name|exblk
operator|.
name|a_data
operator|-
literal|4
expr_stmt|;
comment|/* end of linker table */
comment|/* the object file is a 410 file and thus has seperate text and 	   data segments.  The data is assumed to be loaded at the start 	   of the next PAGSIZ byte boundary, we must calculate the difference 	   between where the data segment begins and where the loader 	   thinks it begins.  Caclulate by rounding up the text size and 	   seeing how much is skipped 	*/
name|segdif
operator|=
operator|(
operator|(
name|exblk
operator|.
name|a_text
operator|+
name|PAGRND
operator|)
operator|&
operator|~
name|PAGRND
operator|)
operator|-
name|exblk
operator|.
name|a_text
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"funcs %d, orgtx %x, orgdt %x, linkstrt %x, linkend %x segdif %x"
argument_list|,
name|funcnt
argument_list|,
name|orgtx
argument_list|,
name|orgdt
argument_list|,
name|linkstrt
argument_list|,
name|linkend
argument_list|,
name|segdif
argument_list|)
expr_stmt|;
comment|/* set the linker table to all -1's so we can put in the gc table */
for|for
control|(
name|iptr
operator|=
operator|(
name|int
operator|*
operator|)
name|linkstrt
init|;
name|iptr
operator|<=
operator|(
name|int
operator|*
operator|)
name|linkend
condition|;
name|iptr
operator|++
control|)
operator|*
name|iptr
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* copy in the prelud */
name|ppre
operator|=
operator|(
expr|struct
name|prelud
operator|*
operator|)
name|orgdt
expr_stmt|;
comment|/* use structure to copy */
operator|*
name|ppre
operator|=
name|prel
expr_stmt|;
comment|/* copy over prelud */
comment|/* link our table into the gc tables */
operator|*
operator|(
operator|(
operator|(
name|int
operator|*
operator|)
name|linkstrt
operator|)
operator|-
literal|1
operator|)
operator|=
operator|(
name|int
operator|)
name|bind_lists
expr_stmt|;
comment|/* point to current */
name|bind_lists
operator|=
operator|(
name|lispval
operator|*
operator|)
name|linkstrt
expr_stmt|;
comment|/* new relocate the necessary symbols in the text segment */
name|orgps
operator|=
name|orgtx
expr_stmt|;
name|fseek
argument_list|(
name|filp
argument_list|,
call|(
name|long
call|)
argument_list|(
literal|32
operator|+
name|exblk
operator|.
name|a_text
operator|+
name|exblk
operator|.
name|a_data
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|times
operator|=
operator|(
name|exblk
operator|.
name|a_trsize
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
expr_stmt|;
comment|/* the only symbols we will relocate are references to  lisp 	   1) functions like _Lcons  	   2) the symbol linker in the data segment  	  type (1) can be recognized by extern and pcrel, while 	  type (2) can be recognized by !extern and pcrel and data segment 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|times
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|reloc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filp
argument_list|)
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Bad text reloc read"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|.
name|r_extern
operator|&&
name|reloc
operator|.
name|r_pcrel
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SYMMAX
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|symbtb
index|[
name|j
index|]
operator|.
name|ord
operator|==
name|reloc
operator|.
name|r_symbolnum
condition|)
comment|/* look for this sym */
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Relocating %d (ord %d) at %x\n"
argument_list|,
name|j
argument_list|,
name|symbtb
index|[
name|j
index|]
operator|.
name|ord
argument_list|,
name|reloc
operator|.
name|r_address
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|orgps
operator|+
name|reloc
operator|.
name|r_address
operator|)
operator|+=
name|symbtb
index|[
name|j
index|]
operator|.
name|floc
operator|-
name|orgtx
expr_stmt|;
break|break;
block|}
block|}
empty_stmt|;
if|if
condition|(
name|j
operator|>=
name|SYMMAX
condition|)
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Couldnt find ord # %d\n"
argument_list|,
name|reloc
operator|.
name|r_symbolnum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|reloc
operator|.
name|r_extern
operator|&&
name|reloc
operator|.
name|r_pcrel
operator|&&
operator|(
name|reloc
operator|.
name|r_symbolnum
operator|==
name|N_DATA
operator|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"relocing at addr %x \n"
argument_list|,
name|reloc
operator|.
name|r_address
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|orgps
operator|+
name|reloc
operator|.
name|r_address
operator|)
operator|-=
name|segdif
expr_stmt|;
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* set up a fake port so we can read from core */
comment|/* first find a free port 	 	       */
name|p
operator|=
name|stdin
expr_stmt|;
for|for
control|(
init|;
name|p
operator|->
name|_flag
operator|&
operator|(
name|_IOREAD
operator||
name|_IOWRT
operator|)
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|>=
name|_iob
operator|+
name|_NFILE
condition|)
name|error
argument_list|(
literal|" No free file descriptor for fasl "
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|p
operator|->
name|_flag
operator|=
name|_IOREAD
operator||
name|_IOSTRG
expr_stmt|;
name|p
operator|->
name|_base
operator|=
name|p
operator|->
name|_ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|orgtx
operator|+
name|litstrt
operator|)
expr_stmt|;
comment|/* start at beginning of lit */
name|p
operator|->
name|_cnt
operator|=
name|litend
operator|-
name|litstrt
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"litstrt %d, charstrt  %d\n"
argument_list|,
name|litstrt
argument_list|,
name|p
operator|->
name|_base
argument_list|)
expr_stmt|;
comment|/* the first forms we wish to read are those literals in the  	 * literal table, that is those forms referenced by an offset 	 * from r8 in  compiled code 	 */
comment|/* to read in the forms correctly, we must set up the read table 	 */
name|currtab
operator|=
name|Vreadtable
operator|->
name|clb
expr_stmt|;
name|Vreadtable
operator|->
name|clb
operator|=
name|strtab
expr_stmt|;
comment|/* standard read table */
name|curibase
operator|=
name|ibase
operator|->
name|clb
expr_stmt|;
name|ibase
operator|->
name|clb
operator|=
name|inewint
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* read in decimal */
name|linktab
operator|=
operator|(
name|lispval
operator|*
operator|)
name|linkstrt
expr_stmt|;
name|oldinitflag
operator|=
name|initflag
expr_stmt|;
comment|/* remember current val */
name|initflag
operator|=
name|TRUE
expr_stmt|;
comment|/* turn OFF gc */
while|while
condition|(
name|linktab
operator|<
operator|(
name|lispval
operator|*
operator|)
name|linkend
condition|)
block|{
name|np
operator|=
name|svnp
expr_stmt|;
name|protect
argument_list|(
name|P
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|handy
operator|=
name|Lread
argument_list|()
expr_stmt|;
name|getc
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* eat trailing blank */
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"one form read: "
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|handy
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
operator|*
name|linktab
operator|++
operator|=
name|handy
expr_stmt|;
block|}
comment|/* now process the binder table, which contains pointers to  	   functions to link in and forms to evaluate. 	*/
name|bindorg
operator|=
operator|(
expr|struct
name|bindage
operator|*
operator|)
operator|(
name|orgtx
operator|+
name|bindloc
operator|)
expr_stmt|;
name|funcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"binding loc %d, orgin : %d\n"
argument_list|,
name|bindloc
argument_list|,
name|bindorg
argument_list|)
expr_stmt|;
for|for
control|(
name|curbind
operator|=
name|bindorg
init|;
name|curbind
operator|->
name|b_type
operator|!=
operator|-
literal|1
condition|;
name|curbind
operator|++
control|)
block|{
name|np
operator|=
name|svnp
expr_stmt|;
name|protect
argument_list|(
name|P
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|rdform
operator|=
name|Lread
argument_list|()
expr_stmt|;
name|getc
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* eat trailing null */
name|protect
argument_list|(
name|rdform
argument_list|)
expr_stmt|;
if|if
condition|(
name|curbind
operator|->
name|b_type
operator|<=
literal|2
condition|)
comment|/* if function type */
block|{
name|handy
operator|=
name|newfunct
argument_list|()
expr_stmt|;
name|rdform
operator|->
name|fnbnd
operator|=
name|handy
expr_stmt|;
name|handy
operator|->
name|entry
operator|=
operator|(
name|lispval
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|orgtx
operator|+
name|funloc
index|[
name|funcnt
operator|++
index|]
operator|)
expr_stmt|;
name|handy
operator|->
name|discipline
operator|=
operator|(
name|curbind
operator|->
name|b_type
operator|==
literal|0
condition|?
name|lambda
else|:
name|curbind
operator|->
name|b_type
operator|==
literal|1
condition|?
name|nlambda
else|:
name|macro
operator|)
expr_stmt|;
if|if
condition|(
name|domap
condition|)
name|fprintf
argument_list|(
name|map
argument_list|,
literal|"%s\n%x\n"
argument_list|,
name|rdform
operator|->
name|pname
argument_list|,
name|handy
operator|->
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Vreadtable
operator|->
name|clb
operator|=
name|currtab
expr_stmt|;
name|ibase
operator|->
name|clb
operator|=
name|curibase
expr_stmt|;
name|eval
argument_list|(
name|rdform
argument_list|)
expr_stmt|;
comment|/* otherwise eval it */
name|curibase
operator|=
name|ibase
operator|->
name|clb
expr_stmt|;
name|ibase
operator|->
name|clb
operator|=
name|inewint
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|Vreadtable
operator|->
name|clb
operator|=
name|strtab
expr_stmt|;
block|}
block|}
empty_stmt|;
name|p
operator|->
name|_flag
operator|=
literal|0
expr_stmt|;
comment|/* give up file descriptor */
name|initflag
operator|=
name|oldinitflag
expr_stmt|;
comment|/* restore state of gc */
name|Vreadtable
operator|->
name|clb
operator|=
name|currtab
expr_stmt|;
name|chkrtab
argument_list|(
name|currtab
argument_list|)
expr_stmt|;
name|ibase
operator|->
name|clb
operator|=
name|curibase
expr_stmt|;
name|fclose
argument_list|(
name|filp
argument_list|)
expr_stmt|;
if|if
condition|(
name|domap
condition|)
name|fclose
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|tatom
operator|)
return|;
block|}
end_function

end_unit

