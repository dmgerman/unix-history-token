begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	vmmem.c	2.2	1/25/80	*/
end_comment

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/pte.h"
end_include

begin_include
include|#
directive|include
file|"../h/cmap.h"
end_include

begin_include
include|#
directive|include
file|"../h/proc.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_include
include|#
directive|include
file|"../h/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../h/text.h"
end_include

begin_include
include|#
directive|include
file|"../h/vm.h"
end_include

begin_include
include|#
directive|include
file|"../h/file.h"
end_include

begin_include
include|#
directive|include
file|"../h/inode.h"
end_include

begin_include
include|#
directive|include
file|"../h/buf.h"
end_include

begin_comment
comment|/*  * Allocate memory, and always succeed  * by jolting page-out daemon  * so as to obtain page frames.  * To be used in conjunction with vmemfree().  */
end_comment

begin_expr_stmt
name|vmemall
argument_list|(
name|pte
argument_list|,
name|size
argument_list|,
name|p
argument_list|,
name|type
argument_list|)
specifier|register
expr|struct
name|pte
operator|*
name|pte
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|m
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
name|size
operator|>
name|maxmem
condition|)
name|panic
argument_list|(
literal|"vmemall size"
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|freemem
operator|<
name|desfree
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|proc
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* jolt daemon */
while|while
condition|(
name|freemem
operator|==
literal|0
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|freemem
argument_list|,
name|PSWP
operator|+
literal|2
argument_list|)
expr_stmt|;
name|m
operator|=
name|imin
argument_list|(
name|size
argument_list|,
name|freemem
argument_list|)
expr_stmt|;
name|VOID
name|memall
parameter_list|(
name|pte
parameter_list|,
name|m
parameter_list|,
name|p
parameter_list|,
name|type
parameter_list|)
function_decl|;
name|size
operator|-=
name|m
expr_stmt|;
name|pte
operator|+=
name|m
expr_stmt|;
block|}
if|if
condition|(
name|freemem
operator|<
name|desfree
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|proc
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* jolt daemon */
comment|/* 	 * Always succeeds, but return success for 	 * vgetu and vgetpt (e.g.) which call either 	 * memall or vmemall depending on context. 	 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Free valid and reclaimable page frames belonging to the  * count pages starting at pte.  If a page is valid  * or reclaimable and locked (but not a system page), then  * we simply mark the page as MGONE and let the pageout  * daemon free the page when it is through with it.  * If a page is reclaimable, and already in the free list, then  * we mark the page as MGONE, and (of course) don't free it.  *  * Determines the largest contiguous cluster of  * valid pages and frees them in one call to memfree.  */
end_comment

begin_expr_stmt
name|vmemfree
argument_list|(
name|pte
argument_list|,
name|count
argument_list|)
specifier|register
expr|struct
name|pte
operator|*
name|pte
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|spte
decl_stmt|;
comment|/* */
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|size
decl_stmt|,
name|pcnt
decl_stmt|,
name|fileno
decl_stmt|;
if|if
condition|(
name|count
operator|%
name|CLSIZE
condition|)
name|panic
argument_list|(
literal|"vmemfree"
argument_list|)
expr_stmt|;
for|for
control|(
name|size
operator|=
literal|0
operator|,
name|pcnt
operator|=
literal|0
init|;
name|count
operator|>
literal|0
condition|;
name|pte
operator|+=
name|CLSIZE
operator|,
name|count
operator|-=
name|CLSIZE
control|)
block|{
if|if
condition|(
name|pte
operator|->
name|pg_fod
operator|==
literal|0
operator|&&
name|pte
operator|->
name|pg_pfnum
condition|)
block|{
name|c
operator|=
operator|&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
index|]
expr_stmt|;
name|pcnt
operator|+=
name|CLSIZE
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|c_flag
operator|&
name|MLOCK
operator|)
operator|&&
operator|!
operator|(
name|c
operator|->
name|c_flag
operator|&
name|MSYS
operator|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CLSIZE
condition|;
name|j
operator|++
control|)
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|pte
operator|+
name|j
operator|)
operator|&=
operator|(
name|PG_PROT
operator||
name|PG_VREADM
operator|)
expr_stmt|;
name|c
operator|->
name|c_flag
operator||=
name|MGONE
expr_stmt|;
goto|goto
name|free
goto|;
block|}
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MFREE
condition|)
block|{
name|pcnt
operator|-=
name|CLSIZE
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CLSIZE
condition|;
name|j
operator|++
control|)
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|pte
operator|+
name|j
operator|)
operator|&=
operator|(
name|PG_PROT
operator||
name|PG_VREADM
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MTEXT
condition|)
name|distpte
argument_list|(
operator|&
name|text
index|[
name|c
operator|->
name|c_ndx
index|]
argument_list|,
operator|(
name|int
operator|)
name|c
operator|->
name|c_page
argument_list|,
name|pte
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_flag
operator||=
name|MGONE
expr_stmt|;
goto|goto
name|free
goto|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|spte
operator|=
name|pte
expr_stmt|;
name|size
operator|+=
name|CLSIZE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pte
operator|->
name|pg_fod
condition|)
block|{
name|fileno
operator|=
operator|(
operator|(
expr|struct
name|fpte
operator|*
operator|)
name|pte
operator|)
operator|->
name|pg_fileno
expr_stmt|;
if|if
condition|(
name|fileno
operator|<
name|NOFILE
condition|)
if|if
condition|(
operator|(
name|u
operator|.
name|u_vrpages
index|[
name|fileno
index|]
operator|-=
name|CLSIZE
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|u
operator|.
name|u_vrpages
index|[
name|fileno
index|]
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"vmemfree vrpages"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|u
operator|.
name|u_ofile
index|[
name|fileno
index|]
operator|->
name|f_inode
operator|->
name|i_vfdcnt
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"vmemfree vfdcnt"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CLSIZE
condition|;
name|j
operator|++
control|)
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|pte
operator|+
name|j
operator|)
operator|&=
operator|(
name|PG_PROT
operator||
name|PG_VREADM
operator|)
expr_stmt|;
block|}
name|free
label|:
if|if
condition|(
name|size
condition|)
block|{
name|memfree
argument_list|(
name|spte
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|size
condition|)
name|memfree
argument_list|(
name|spte
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|pcnt
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Unlink a page frame from the free list -  *  * Performed if the page being reclaimed  * is in the free list.  */
end_comment

begin_macro
name|munlink
argument_list|(
argument|pf
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|pf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|next
decl_stmt|,
name|prev
decl_stmt|;
name|next
operator|=
name|cmap
index|[
name|pgtocm
argument_list|(
name|pf
argument_list|)
index|]
operator|.
name|c_next
expr_stmt|;
name|prev
operator|=
name|cmap
index|[
name|pgtocm
argument_list|(
name|pf
argument_list|)
index|]
operator|.
name|c_prev
expr_stmt|;
name|cmap
index|[
name|prev
index|]
operator|.
name|c_next
operator|=
name|next
expr_stmt|;
name|cmap
index|[
name|next
index|]
operator|.
name|c_prev
operator|=
name|prev
expr_stmt|;
name|cmap
index|[
name|pgtocm
argument_list|(
name|pf
argument_list|)
index|]
operator|.
name|c_flag
operator|&=
operator|~
name|MFREE
expr_stmt|;
if|if
condition|(
name|freemem
operator|<
name|minfree
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|proc
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* jolt paging daemon */
name|freemem
operator|-=
name|CLSIZE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Allocate memory -  *  * The free list appears as a doubly linked list  * in the core map with cmap[0] serving as a header.  */
end_comment

begin_expr_stmt
name|memall
argument_list|(
name|pte
argument_list|,
name|size
argument_list|,
name|p
argument_list|,
name|type
argument_list|)
specifier|register
expr|struct
name|pte
operator|*
name|pte
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmap
modifier|*
name|c
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|rpte
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|rp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|next
decl_stmt|,
name|curpos
decl_stmt|;
name|unsigned
name|pf
decl_stmt|;
if|if
condition|(
name|size
operator|%
name|CLSIZE
condition|)
name|panic
argument_list|(
literal|"memall"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|freemem
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
name|size
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
name|CLSIZE
control|)
block|{
name|curpos
operator|=
name|cmap
index|[
name|CMHEAD
index|]
operator|.
name|c_next
expr_stmt|;
name|c
operator|=
operator|&
name|cmap
index|[
name|curpos
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|c_flag
operator|&
name|MFREE
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"dup mem alloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmtopg
argument_list|(
name|curpos
argument_list|)
operator|>
name|maxfree
condition|)
name|panic
argument_list|(
literal|"bad mem alloc"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|c_flag
operator|&
operator|(
name|MGONE
operator||
name|MSYS
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MTEXT
condition|)
name|rp
operator|=
name|text
index|[
name|c
operator|->
name|c_ndx
index|]
operator|.
name|x_caddr
expr_stmt|;
else|else
name|rp
operator|=
operator|&
name|proc
index|[
name|c
operator|->
name|c_ndx
index|]
expr_stmt|;
while|while
condition|(
name|rp
operator|->
name|p_flag
operator|&
name|SNOVM
condition|)
name|rp
operator|=
name|rp
operator|->
name|p_xlink
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MTEXT
condition|)
name|rpte
operator|=
name|tptopte
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MDATA
condition|)
name|rpte
operator|=
name|dptopte
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
else|else
name|rpte
operator|=
name|sptopte
argument_list|(
name|rp
argument_list|,
name|c
operator|->
name|c_page
argument_list|)
expr_stmt|;
name|zapcl
argument_list|(
name|rpte
argument_list|,
name|pg_pfnum
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MTEXT
condition|)
name|distpte
argument_list|(
operator|&
name|text
index|[
name|c
operator|->
name|c_ndx
index|]
argument_list|,
operator|(
name|int
operator|)
name|c
operator|->
name|c_page
argument_list|,
name|rpte
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|MSYS
condition|)
if|if
condition|(
name|type
operator|==
name|MTEXT
condition|)
block|{
name|c
operator|->
name|c_page
operator|=
name|vtotp
argument_list|(
name|p
argument_list|,
name|ptetov
argument_list|(
name|p
argument_list|,
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_ndx
operator|=
name|p
operator|->
name|p_textp
operator|-
operator|&
name|text
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|MDATA
condition|)
name|c
operator|->
name|c_page
operator|=
name|vtodp
argument_list|(
name|p
argument_list|,
name|ptetov
argument_list|(
name|p
argument_list|,
name|pte
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|c
operator|->
name|c_page
operator|=
name|vtosp
argument_list|(
name|p
argument_list|,
name|ptetov
argument_list|(
name|p
argument_list|,
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_ndx
operator|=
name|p
operator|->
name|p_ndx
expr_stmt|;
block|}
name|pf
operator|=
name|cmtopg
argument_list|(
name|curpos
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CLSIZE
condition|;
name|j
operator|++
control|)
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|++
operator|=
name|pf
operator|++
expr_stmt|;
name|c
operator|->
name|c_flag
operator|=
name|MLOCK
operator||
name|type
expr_stmt|;
name|freemem
operator|-=
name|CLSIZE
expr_stmt|;
name|next
operator|=
name|c
operator|->
name|c_next
expr_stmt|;
name|cmap
index|[
name|CMHEAD
index|]
operator|.
name|c_next
operator|=
name|next
expr_stmt|;
name|cmap
index|[
name|next
index|]
operator|.
name|c_prev
operator|=
name|CMHEAD
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Free memory -  *  * The page frames being returned are inserted  * to the head/tail of the free list depending  * on whether there is any possible future use of them.  *  * If the freemem count had been zero,  * the processes sleeping for memory  * are awakened.  */
end_comment

begin_expr_stmt
name|memfree
argument_list|(
name|pte
argument_list|,
name|size
argument_list|,
name|useless
argument_list|)
specifier|register
expr|struct
name|pte
operator|*
name|pte
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|prev
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|size
operator|%
name|CLSIZE
condition|)
name|panic
argument_list|(
literal|"memfree"
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|size
operator|-=
name|CLSIZE
expr_stmt|;
name|i
operator|=
name|pte
operator|->
name|pg_pfnum
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|firstfree
operator|||
name|i
operator|>
name|maxfree
condition|)
name|panic
argument_list|(
literal|"bad mem free"
argument_list|)
expr_stmt|;
name|i
operator|=
name|pgtocm
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmap
index|[
name|i
index|]
operator|.
name|c_flag
operator|&
name|MFREE
condition|)
name|panic
argument_list|(
literal|"dup mem free"
argument_list|)
expr_stmt|;
if|if
condition|(
name|useless
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CLSIZE
condition|;
name|j
operator|++
control|)
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|pte
operator|+
name|j
operator|)
operator|&=
operator|(
name|PG_PROT
operator||
name|PG_VREADM
operator|)
expr_stmt|;
name|cmap
index|[
name|i
index|]
operator|.
name|c_flag
operator||=
name|MGONE
expr_stmt|;
name|next
operator|=
name|cmap
index|[
name|CMHEAD
index|]
operator|.
name|c_next
expr_stmt|;
name|cmap
index|[
name|next
index|]
operator|.
name|c_prev
operator|=
name|i
expr_stmt|;
name|cmap
index|[
name|i
index|]
operator|.
name|c_prev
operator|=
name|CMHEAD
expr_stmt|;
name|cmap
index|[
name|i
index|]
operator|.
name|c_next
operator|=
name|next
expr_stmt|;
name|cmap
index|[
name|CMHEAD
index|]
operator|.
name|c_next
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|cmap
index|[
name|CMHEAD
index|]
operator|.
name|c_prev
expr_stmt|;
name|cmap
index|[
name|prev
index|]
operator|.
name|c_next
operator|=
name|i
expr_stmt|;
name|cmap
index|[
name|i
index|]
operator|.
name|c_next
operator|=
name|CMHEAD
expr_stmt|;
name|cmap
index|[
name|i
index|]
operator|.
name|c_prev
operator|=
name|prev
expr_stmt|;
name|cmap
index|[
name|CMHEAD
index|]
operator|.
name|c_prev
operator|=
name|i
expr_stmt|;
block|}
name|cmap
index|[
name|i
index|]
operator|.
name|c_flag
operator||=
name|MFREE
expr_stmt|;
if|if
condition|(
name|freemem
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|freemem
argument_list|)
expr_stmt|;
name|freemem
operator|+=
name|CLSIZE
expr_stmt|;
name|pte
operator|+=
name|CLSIZE
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Initialize core map  */
end_comment

begin_macro
name|meminit
argument_list|(
argument|first
argument_list|,
argument|last
argument_list|)
end_macro

begin_decl_stmt
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|firstfree
operator|=
name|clrnd
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|maxfree
operator|=
name|clrnd
argument_list|(
name|last
operator|-
operator|(
name|CLSIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|freemem
operator|=
name|maxfree
operator|-
name|firstfree
expr_stmt|;
if|if
condition|(
operator|(
name|ecmap
operator|-
name|cmap
operator|)
operator|<
name|freemem
operator|/
name|CLSIZE
condition|)
name|freemem
operator|=
operator|(
name|ecmap
operator|-
name|cmap
operator|)
operator|*
name|CLSIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|freemem
operator|/
name|CLSIZE
condition|;
name|i
operator|++
control|)
block|{
name|cmap
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|c_next
operator|=
name|i
expr_stmt|;
name|cmap
index|[
name|i
index|]
operator|.
name|c_prev
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|cmap
index|[
name|i
index|]
operator|.
name|c_flag
operator|=
name|MFREE
operator||
name|MGONE
expr_stmt|;
block|}
name|cmap
index|[
name|freemem
operator|/
name|CLSIZE
index|]
operator|.
name|c_next
operator|=
name|CMHEAD
expr_stmt|;
name|cmap
index|[
name|CMHEAD
index|]
operator|.
name|c_prev
operator|=
name|freemem
operator|/
name|CLSIZE
expr_stmt|;
name|cmap
index|[
name|CMHEAD
index|]
operator|.
name|c_flag
operator|=
name|MSYS
expr_stmt|;
name|avefree
operator|=
name|freemem
expr_stmt|;
name|hand
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Wait for frame pf to become unlocked  * if it is currently locked.  */
end_comment

begin_macro
name|mwait
argument_list|(
argument|pf
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|pf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|mlock
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|munlock
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Lock a page frame.  */
end_comment

begin_macro
name|mlock
argument_list|(
argument|pf
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|pf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmap
modifier|*
name|c
init|=
operator|&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pf
argument_list|)
index|]
decl_stmt|;
while|while
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MLOCK
condition|)
block|{
name|c
operator|->
name|c_flag
operator||=
name|MWANT
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|c
argument_list|,
name|PSWP
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|c_flag
operator||=
name|MLOCK
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Unlock a page frame.  */
end_comment

begin_macro
name|munlock
argument_list|(
argument|pf
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|pf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmap
modifier|*
name|c
init|=
operator|&
name|cmap
index|[
name|pgtocm
argument_list|(
name|pf
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|c_flag
operator|&
name|MLOCK
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"dup page unlock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_flag
operator|&
name|MWANT
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_flag
operator|&=
operator|~
operator|(
name|MLOCK
operator||
name|MWANT
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   * Lock a virtual segment.  *  * For each cluster of pages, if the cluster is not valid,  * touch it to fault it in, otherwise just lock page frame.  * Called from physio to ensure that the pages   * participating in raw i/o are valid and locked.  * We use SDLYU to keep pagein from unlocking pages,  * so they make it safely back here locked.  */
end_comment

begin_macro
name|vslock
argument_list|(
argument|base
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|base
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|v
decl_stmt|;
specifier|register
name|int
name|npf
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator||=
name|SDLYU
expr_stmt|;
name|v
operator|=
name|btop
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|npf
operator|=
name|btoc
argument_list|(
name|count
operator|+
operator|(
operator|(
name|int
operator|)
name|base
operator|&
name|CLOFSET
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|npf
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pte
operator|->
name|pg_v
condition|)
name|mlock
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
expr_stmt|;
else|else
name|VOID
name|fubyte
argument_list|(
operator|(
name|caddr_t
operator|)
name|ctob
argument_list|(
name|v
argument_list|)
argument_list|)
decl_stmt|;
comment|/* fault in cluster */
name|pte
operator|+=
name|CLSIZE
expr_stmt|;
name|v
operator|+=
name|CLSIZE
expr_stmt|;
name|npf
operator|-=
name|CLSIZE
expr_stmt|;
block|}
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator|&=
operator|~
name|SDLYU
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   * Unlock a virtual segment.  */
end_comment

begin_macro
name|vsunlock
argument_list|(
argument|base
argument_list|,
argument|count
argument_list|,
argument|rw
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|base
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|int
name|npf
decl_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
name|btop
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|npf
operator|=
name|btoc
argument_list|(
name|count
operator|+
operator|(
operator|(
name|int
operator|)
name|base
operator|&
name|CLOFSET
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|npf
operator|>
literal|0
condition|)
block|{
name|munlock
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|B_READ
condition|)
comment|/* Reading from device writes memory */
name|pte
operator|->
name|pg_m
operator|=
literal|1
expr_stmt|;
name|pte
operator|+=
name|CLSIZE
expr_stmt|;
name|npf
operator|-=
name|CLSIZE
expr_stmt|;
block|}
block|}
end_block

end_unit

