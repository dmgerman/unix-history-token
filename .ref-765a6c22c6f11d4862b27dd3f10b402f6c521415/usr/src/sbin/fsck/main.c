begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|version
index|[]
init|=
literal|"@(#)main.c	2.30 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs.h>
end_include

begin_include
include|#
directive|include
file|<sys/inode.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<fstab.h>
end_include

begin_define
define|#
directive|define
name|KERNEL
end_define

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_comment
comment|/* RECONSTRUCT ONLY BAD CG IN PASS 6 */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|SIG_TYP
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_define
define|#
directive|define
name|MAXNINDIR
value|(MAXBSIZE / sizeof (daddr_t))
end_define

begin_define
define|#
directive|define
name|MAXINOPB
value|(MAXBSIZE / sizeof (struct dinode))
end_define

begin_define
define|#
directive|define
name|SPERB
value|(MAXBSIZE / sizeof(short))
end_define

begin_define
define|#
directive|define
name|MINDIRSIZE
value|(sizeof (struct dirtemplate))
end_define

begin_define
define|#
directive|define
name|MAXDUP
value|10
end_define

begin_comment
comment|/* limit on dup blks (per inode) */
end_comment

begin_define
define|#
directive|define
name|MAXBAD
value|10
end_define

begin_comment
comment|/* limit on bad blks (per inode) */
end_comment

begin_define
define|#
directive|define
name|USTATE
value|0
end_define

begin_comment
comment|/* inode not allocated */
end_comment

begin_define
define|#
directive|define
name|FSTATE
value|01
end_define

begin_comment
comment|/* inode is file */
end_comment

begin_define
define|#
directive|define
name|DSTATE
value|02
end_define

begin_comment
comment|/* inode is directory */
end_comment

begin_define
define|#
directive|define
name|CLEAR
value|03
end_define

begin_comment
comment|/* inode is to be cleared */
end_comment

begin_typedef
typedef|typedef
name|struct
name|dinode
name|DINODE
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|direct
name|DIRECT
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ALLOC
value|((dp->di_mode& IFMT) != 0)
end_define

begin_define
define|#
directive|define
name|DIRCT
value|((dp->di_mode& IFMT) == IFDIR)
end_define

begin_define
define|#
directive|define
name|REG
value|((dp->di_mode& IFMT) == IFREG)
end_define

begin_define
define|#
directive|define
name|BLK
value|((dp->di_mode& IFMT) == IFBLK)
end_define

begin_define
define|#
directive|define
name|CHR
value|((dp->di_mode& IFMT) == IFCHR)
end_define

begin_define
define|#
directive|define
name|LNK
value|((dp->di_mode& IFMT) == IFLNK)
end_define

begin_define
define|#
directive|define
name|SOCK
value|((dp->di_mode& IFMT) == IFSOCK)
end_define

begin_define
define|#
directive|define
name|BADBLK
value|((dp->di_mode& IFMT) == IFMT)
end_define

begin_define
define|#
directive|define
name|SPECIAL
value|(BLK || CHR)
end_define

begin_struct
struct|struct
name|bufarea
block|{
name|struct
name|bufarea
modifier|*
name|b_next
decl_stmt|;
comment|/* must be first */
name|daddr_t
name|b_bno
decl_stmt|;
name|int
name|b_size
decl_stmt|;
union|union
block|{
name|char
name|b_buf
index|[
name|MAXBSIZE
index|]
decl_stmt|;
comment|/* buffer space */
name|short
name|b_lnks
index|[
name|SPERB
index|]
decl_stmt|;
comment|/* link counts */
name|daddr_t
name|b_indir
index|[
name|MAXNINDIR
index|]
decl_stmt|;
comment|/* indirect block */
name|struct
name|fs
name|b_fs
decl_stmt|;
comment|/* super block */
name|struct
name|cg
name|b_cg
decl_stmt|;
comment|/* cylinder group */
name|struct
name|dinode
name|b_dinode
index|[
name|MAXINOPB
index|]
decl_stmt|;
comment|/* inode block */
block|}
name|b_un
union|;
name|char
name|b_dirty
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|bufarea
name|BUFAREA
typedef|;
end_typedef

begin_decl_stmt
name|BUFAREA
name|inoblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* inode blocks */
end_comment

begin_decl_stmt
name|BUFAREA
name|fileblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* other blks in filesys */
end_comment

begin_decl_stmt
name|BUFAREA
name|sblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file system superblock */
end_comment

begin_decl_stmt
name|BUFAREA
name|cgblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cylinder group blocks */
end_comment

begin_define
define|#
directive|define
name|initbarea
parameter_list|(
name|x
parameter_list|)
value|(x)->b_dirty = 0;(x)->b_bno = (daddr_t)-1
end_define

begin_define
define|#
directive|define
name|dirty
parameter_list|(
name|x
parameter_list|)
value|(x)->b_dirty = 1
end_define

begin_define
define|#
directive|define
name|inodirty
parameter_list|()
value|inoblk.b_dirty = 1
end_define

begin_define
define|#
directive|define
name|sbdirty
parameter_list|()
value|sblk.b_dirty = 1
end_define

begin_define
define|#
directive|define
name|cgdirty
parameter_list|()
value|cgblk.b_dirty = 1
end_define

begin_define
define|#
directive|define
name|dirblk
value|fileblk.b_un
end_define

begin_define
define|#
directive|define
name|sblock
value|sblk.b_un.b_fs
end_define

begin_define
define|#
directive|define
name|cgrp
value|cgblk.b_un.b_cg
end_define

begin_struct
struct|struct
name|filecntl
block|{
name|int
name|rfdes
decl_stmt|;
name|int
name|wfdes
decl_stmt|;
name|int
name|mod
decl_stmt|;
block|}
name|dfile
struct|;
end_struct

begin_comment
comment|/* file descriptors for filesys */
end_comment

begin_struct
struct|struct
name|inodesc
block|{
name|char
name|id_type
decl_stmt|;
comment|/* type of descriptor, DATA or ADDR */
name|int
function_decl|(
modifier|*
name|id_func
function_decl|)
parameter_list|()
function_decl|;
comment|/* function to be applied to blocks of inode */
name|ino_t
name|id_number
decl_stmt|;
comment|/* inode number described */
name|ino_t
name|id_parent
decl_stmt|;
comment|/* for DATA nodes, their parent */
name|daddr_t
name|id_blkno
decl_stmt|;
comment|/* current block number being examined */
name|int
name|id_numfrags
decl_stmt|;
comment|/* number of frags contained in block */
name|long
name|id_filesize
decl_stmt|;
comment|/* for DATA nodes, the size of the directory */
name|int
name|id_loc
decl_stmt|;
comment|/* for DATA nodes, current location in dir */
name|int
name|id_entryno
decl_stmt|;
comment|/* for DATA nodes, current entry number */
name|DIRECT
modifier|*
name|id_dirp
decl_stmt|;
comment|/* for data nodes, ptr to current entry */
enum|enum
block|{
name|DONTKNOW
block|,
name|NOFIX
block|,
name|FIX
block|}
name|id_fix
enum|;
comment|/* policy on fixing errors */
block|}
struct|;
end_struct

begin_comment
comment|/* file types */
end_comment

begin_define
define|#
directive|define
name|DATA
value|1
end_define

begin_define
define|#
directive|define
name|ADDR
value|2
end_define

begin_define
define|#
directive|define
name|DUPTBLSIZE
value|100
end_define

begin_comment
comment|/* num of dup blocks to remember */
end_comment

begin_decl_stmt
name|daddr_t
name|duplist
index|[
name|DUPTBLSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dup block table */
end_comment

begin_decl_stmt
name|daddr_t
modifier|*
name|enddup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next entry in dup table */
end_comment

begin_decl_stmt
name|daddr_t
modifier|*
name|muldup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* multiple dups part of table */
end_comment

begin_define
define|#
directive|define
name|MAXLNCNT
value|500
end_define

begin_comment
comment|/* num zero link cnts to remember */
end_comment

begin_decl_stmt
name|ino_t
name|badlncnt
index|[
name|MAXLNCNT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of inos with zero link cnts */
end_comment

begin_decl_stmt
name|ino_t
modifier|*
name|badlnp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next entry in table */
end_comment

begin_decl_stmt
name|char
name|rawflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assume a no response */
end_comment

begin_decl_stmt
name|char
name|yflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assume a yes response */
end_comment

begin_decl_stmt
name|int
name|bflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* location of alternate super block */
end_comment

begin_decl_stmt
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output debugging info */
end_comment

begin_decl_stmt
name|char
name|preen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* just fix normal inconsistencies */
end_comment

begin_decl_stmt
name|char
name|rplyflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* any questions asked? */
end_comment

begin_decl_stmt
name|char
name|hotroot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* checking root device */
end_comment

begin_decl_stmt
name|char
name|fixcg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* corrupted free list bit maps */
end_comment

begin_decl_stmt
name|char
modifier|*
name|blockmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to primary blk allocation map */
end_comment

begin_decl_stmt
name|char
modifier|*
name|freemap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to secondary blk allocation map */
end_comment

begin_decl_stmt
name|char
modifier|*
name|statemap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to inode state table */
end_comment

begin_decl_stmt
name|short
modifier|*
name|lncntp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to link count table */
end_comment

begin_decl_stmt
name|char
modifier|*
name|srchname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name being searched for in dir */
end_comment

begin_decl_stmt
name|char
name|pathname
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current pathname */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pathp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to pathname position */
end_comment

begin_decl_stmt
name|char
modifier|*
name|endpathname
init|=
operator|&
name|pathname
index|[
name|BUFSIZ
operator|-
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|lfname
init|=
literal|"lost+found"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|imax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of inodes */
end_comment

begin_decl_stmt
name|ino_t
name|lastino
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hiwater mark of inodes */
end_comment

begin_decl_stmt
name|ino_t
name|lfdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lost& found directory */
end_comment

begin_decl_stmt
name|off_t
name|maxblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* largest logical blk in file */
end_comment

begin_decl_stmt
name|off_t
name|bmapsz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* num chars in blockmap */
end_comment

begin_decl_stmt
name|daddr_t
name|n_ffree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of small free blocks */
end_comment

begin_decl_stmt
name|daddr_t
name|n_bfree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of large free blocks */
end_comment

begin_decl_stmt
name|daddr_t
name|n_blks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of blocks used */
end_comment

begin_decl_stmt
name|daddr_t
name|n_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of files seen */
end_comment

begin_decl_stmt
name|daddr_t
name|n_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|n_bad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|fmax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of blocks in the volume */
end_comment

begin_decl_stmt
name|daddr_t
name|badblk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|dupblk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inosumbad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offsumbad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|frsumbad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sbsumbad
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|zapino
parameter_list|(
name|x
parameter_list|)
value|(*(x) = zino)
end_define

begin_decl_stmt
name|struct
name|dinode
name|zino
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|setbmap
parameter_list|(
name|x
parameter_list|)
value|setbit(blockmap, x)
end_define

begin_define
define|#
directive|define
name|getbmap
parameter_list|(
name|x
parameter_list|)
value|isset(blockmap, x)
end_define

begin_define
define|#
directive|define
name|clrbmap
parameter_list|(
name|x
parameter_list|)
value|clrbit(blockmap, x)
end_define

begin_define
define|#
directive|define
name|setfmap
parameter_list|(
name|x
parameter_list|)
value|setbit(freemap, x)
end_define

begin_define
define|#
directive|define
name|getfmap
parameter_list|(
name|x
parameter_list|)
value|isset(freemap, x)
end_define

begin_define
define|#
directive|define
name|clrfmap
parameter_list|(
name|x
parameter_list|)
value|clrbit(freemap, x)
end_define

begin_define
define|#
directive|define
name|ALTERED
value|010
end_define

begin_define
define|#
directive|define
name|KEEPON
value|04
end_define

begin_define
define|#
directive|define
name|SKIP
value|02
end_define

begin_define
define|#
directive|define
name|STOP
value|01
end_define

begin_expr_stmt
name|int
argument_list|(
operator|*
name|signal
argument_list|()
argument_list|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|time_t
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|DINODE
modifier|*
name|ginode
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|DIRECT
modifier|*
name|fsck_readdir
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|BUFAREA
modifier|*
name|getblk
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|catch
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|findino
argument_list|()
decl_stmt|,
name|mkentry
argument_list|()
decl_stmt|,
name|chgdd
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pass1check
argument_list|()
decl_stmt|,
name|pass1bcheck
argument_list|()
decl_stmt|,
name|pass2check
argument_list|()
decl_stmt|,
name|pass4check
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rawname
argument_list|()
decl_stmt|,
modifier|*
name|unrawname
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|calloc
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|strcat
argument_list|()
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|inside
index|[]
decl_stmt|,
name|around
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|char
modifier|*
name|fragtbl
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|devname
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|struct
name|fstab
modifier|*
name|fsp
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|passno
decl_stmt|,
name|anygtr
decl_stmt|,
name|sumstatus
decl_stmt|;
name|sync
argument_list|()
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
operator|*
name|argv
condition|)
block|{
case|case
literal|'p'
case|:
name|preen
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|bflag
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bflag
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Alternate super block location: %d\n"
argument_list|,
name|bflag
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debug
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* default no answer flag */
case|case
literal|'N'
case|:
name|nflag
operator|++
expr_stmt|;
name|yflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
comment|/* default yes answer flag */
case|case
literal|'Y'
case|:
name|yflag
operator|++
expr_stmt|;
name|nflag
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|errexit
argument_list|(
literal|"%c option?\n"
argument_list|,
operator|*
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catch
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
while|while
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
block|{
name|hotroot
operator|=
literal|0
expr_stmt|;
name|checkfilesys
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|sumstatus
operator|=
literal|0
expr_stmt|;
name|passno
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|anygtr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setfsent
argument_list|()
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|"Can't open checklist file: %s\n"
argument_list|,
name|FSTAB
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fsp
operator|=
name|getfsent
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fsp
operator|->
name|fs_type
argument_list|,
name|FSTAB_RW
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|fsp
operator|->
name|fs_type
argument_list|,
name|FSTAB_RO
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|fsp
operator|->
name|fs_type
argument_list|,
name|FSTAB_RQ
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|preen
operator|==
literal|0
operator|||
name|passno
operator|==
literal|1
operator|&&
name|fsp
operator|->
name|fs_passno
operator|==
name|passno
condition|)
block|{
if|if
condition|(
name|blockcheck
argument_list|(
name|fsp
operator|->
name|fs_spec
argument_list|)
operator|==
literal|0
operator|&&
name|preen
condition|)
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fsp
operator|->
name|fs_passno
operator|>
name|passno
condition|)
name|anygtr
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|fsp
operator|->
name|fs_passno
operator|==
name|passno
condition|)
block|{
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
if|if
condition|(
name|blockcheck
argument_list|(
name|fsp
operator|->
name|fs_spec
argument_list|)
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
else|else
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|preen
condition|)
block|{
name|union
name|wait
name|status
decl_stmt|;
while|while
condition|(
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|sumstatus
operator||=
name|status
operator|.
name|w_retcode
expr_stmt|;
block|}
name|passno
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|anygtr
condition|)
do|;
if|if
condition|(
name|sumstatus
condition|)
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|endfsent
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|blockcheck
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|stslash
decl_stmt|,
name|stblock
decl_stmt|,
name|stchar
decl_stmt|;
name|char
modifier|*
name|raw
decl_stmt|;
name|int
name|looped
init|=
literal|0
decl_stmt|;
name|hotroot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"/"
argument_list|,
operator|&
name|stslash
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't stat root\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|retry
label|:
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|stblock
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't stat %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|stblock
operator|.
name|st_mode
operator|&
name|S_IFBLK
condition|)
block|{
name|raw
operator|=
name|rawname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|raw
argument_list|,
operator|&
name|stchar
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't stat %s\n"
argument_list|,
name|raw
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|stchar
operator|.
name|st_mode
operator|&
name|S_IFCHR
condition|)
block|{
if|if
condition|(
name|stslash
operator|.
name|st_dev
operator|==
name|stblock
operator|.
name|st_rdev
condition|)
block|{
name|hotroot
operator|++
expr_stmt|;
name|raw
operator|=
name|unrawname
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|checkfilesys
argument_list|(
name|raw
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"%s is not a character device\n"
argument_list|,
name|raw
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|stblock
operator|.
name|st_mode
operator|&
name|S_IFCHR
condition|)
block|{
if|if
condition|(
name|looped
condition|)
block|{
name|error
argument_list|(
literal|"Can't make sense out of name %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|name
operator|=
name|unrawname
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|looped
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|error
argument_list|(
literal|"Can't make sense out of name %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|checkfilesys
argument_list|(
argument|filesys
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filesys
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|devname
operator|=
name|filesys
expr_stmt|;
if|if
condition|(
name|setup
argument_list|(
name|filesys
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|preen
condition|)
name|pfatal
argument_list|(
literal|"CAN'T CHECK FILE SYSTEM."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 1: scan inodes tallying blocks used */
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"** Last Mounted on %s\n"
argument_list|,
name|sblock
operator|.
name|fs_fsmnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|hotroot
condition|)
name|printf
argument_list|(
literal|"** Root file system\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"** Phase 1 - Check Blocks and Sizes\n"
argument_list|)
expr_stmt|;
block|}
name|pass1
argument_list|()
expr_stmt|;
comment|/* 1b: locate first references to duplicates, if any */
if|if
condition|(
name|enddup
operator|!=
operator|&
name|duplist
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|preen
condition|)
name|pfatal
argument_list|(
literal|"INTERNAL ERROR: dups with -p"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"** Phase 1b - Rescan For More DUPS\n"
argument_list|)
expr_stmt|;
name|pass1b
argument_list|()
expr_stmt|;
block|}
comment|/* 2: traverse directories from root to mark all connected directories */
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** Phase 2 - Check Pathnames\n"
argument_list|)
expr_stmt|;
name|pass2
argument_list|()
expr_stmt|;
comment|/* 3: scan inodes looking for disconnected directories */
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** Phase 3 - Check Connectivity\n"
argument_list|)
expr_stmt|;
name|pass3
argument_list|()
expr_stmt|;
comment|/* 4: scan inodes looking for disconnected files; check reference counts */
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** Phase 4 - Check Reference Counts\n"
argument_list|)
expr_stmt|;
name|pass4
argument_list|()
expr_stmt|;
comment|/* 5: check resource counts in cylinder groups */
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** Phase 5 - Check Cyl groups\n"
argument_list|)
expr_stmt|;
name|pass5
argument_list|()
expr_stmt|;
if|if
condition|(
name|fixcg
condition|)
block|{
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** Phase 6 - Salvage Cylinder Groups\n"
argument_list|)
expr_stmt|;
name|makecg
argument_list|()
expr_stmt|;
name|n_ffree
operator|=
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
expr_stmt|;
name|n_bfree
operator|=
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
expr_stmt|;
block|}
name|pwarn
argument_list|(
literal|"%d files, %d used, %d free (%d frags, %d blocks)\n"
argument_list|,
name|n_files
argument_list|,
name|n_blks
operator|-
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
argument_list|,
name|n_ffree
operator|+
name|sblock
operator|.
name|fs_frag
operator|*
name|n_bfree
argument_list|,
name|n_ffree
argument_list|,
name|n_bfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfile
operator|.
name|mod
condition|)
block|{
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|sblock
operator|.
name|fs_time
argument_list|)
expr_stmt|;
name|sbdirty
argument_list|()
expr_stmt|;
block|}
name|ckfini
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|blockmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|freemap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|statemap
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lncntp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dfile
operator|.
name|mod
condition|)
return|return;
if|if
condition|(
operator|!
name|preen
condition|)
block|{
name|printf
argument_list|(
literal|"\n***** FILE SYSTEM WAS MODIFIED *****\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hotroot
condition|)
name|printf
argument_list|(
literal|"\n***** REBOOT UNIX *****\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hotroot
condition|)
block|{
name|sync
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|setup
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dev_t
name|rootdev
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
name|daddr_t
name|super
init|=
name|bflag
condition|?
name|bflag
else|:
name|SBLOCK
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|cgd
decl_stmt|;
name|long
name|size
decl_stmt|;
name|BUFAREA
name|asblk
decl_stmt|;
define|#
directive|define
name|altsblock
value|asblk.b_un.b_fs
if|if
condition|(
name|stat
argument_list|(
literal|"/"
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
name|errexit
argument_list|(
literal|"Can't stat root\n"
argument_list|)
expr_stmt|;
name|rootdev
operator|=
name|statb
operator|.
name|st_dev
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dev
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't stat %s\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rawflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFBLK
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCHR
condition|)
name|rawflg
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|reply
argument_list|(
literal|"file is not a block or character device; OK"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|rootdev
operator|==
name|statb
operator|.
name|st_rdev
condition|)
name|hotroot
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dfile
operator|.
name|rfdes
operator|=
name|open
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't open %s\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** %s"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
operator|||
operator|(
name|dfile
operator|.
name|wfdes
operator|=
name|open
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dfile
operator|.
name|wfdes
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|pfatal
argument_list|(
literal|"NO WRITE ACCESS"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (NO WRITE)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fixcg
operator|=
literal|0
expr_stmt|;
name|inosumbad
operator|=
literal|0
expr_stmt|;
name|offsumbad
operator|=
literal|0
expr_stmt|;
name|frsumbad
operator|=
literal|0
expr_stmt|;
name|sbsumbad
operator|=
literal|0
expr_stmt|;
name|dfile
operator|.
name|mod
operator|=
literal|0
expr_stmt|;
name|n_files
operator|=
name|n_blks
operator|=
name|n_ffree
operator|=
name|n_bfree
operator|=
literal|0
expr_stmt|;
name|muldup
operator|=
name|enddup
operator|=
operator|&
name|duplist
index|[
literal|0
index|]
expr_stmt|;
name|badlnp
operator|=
operator|&
name|badlncnt
index|[
literal|0
index|]
expr_stmt|;
name|lfdir
operator|=
literal|0
expr_stmt|;
name|rplyflag
operator|=
literal|0
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|sblk
argument_list|)
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|fileblk
argument_list|)
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|inoblk
argument_list|)
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|cgblk
argument_list|)
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|asblk
argument_list|)
expr_stmt|;
comment|/* 	 * Read in the super block and its summary info. 	 */
if|if
condition|(
name|bread
argument_list|(
operator|&
name|dfile
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sblock
argument_list|,
name|super
argument_list|,
operator|(
name|long
operator|)
name|SBSIZE
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sblk
operator|.
name|b_bno
operator|=
name|super
expr_stmt|;
name|sblk
operator|.
name|b_size
operator|=
name|SBSIZE
expr_stmt|;
comment|/* 	 * run a few consistency checks of the super block 	 */
if|if
condition|(
name|sblock
operator|.
name|fs_magic
operator|!=
name|FS_MAGIC
condition|)
block|{
name|badsb
argument_list|(
literal|"MAGIC NUMBER WRONG"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_ncg
operator|<
literal|1
condition|)
block|{
name|badsb
argument_list|(
literal|"NCG OUT OF RANGE"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_cpg
operator|<
literal|1
operator|||
name|sblock
operator|.
name|fs_cpg
operator|>
name|MAXCPG
condition|)
block|{
name|badsb
argument_list|(
literal|"CPG OUT OF RANGE"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_ncg
operator|*
name|sblock
operator|.
name|fs_cpg
operator|<
name|sblock
operator|.
name|fs_ncyl
operator|||
operator|(
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
operator|)
operator|*
name|sblock
operator|.
name|fs_cpg
operator|>=
name|sblock
operator|.
name|fs_ncyl
condition|)
block|{
name|badsb
argument_list|(
literal|"NCYL DOES NOT JIVE WITH NCG*CPG"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_sbsize
operator|>
name|SBSIZE
condition|)
block|{
name|badsb
argument_list|(
literal|"SIZE PREPOSTEROUSLY LARGE"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Set all possible fields that could differ, then do check 	 * of whole super block against an alternate super block. 	 * When an alternate super-block is specified this check is skipped. 	 */
if|if
condition|(
name|bflag
condition|)
goto|goto
name|sbok
goto|;
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|asblk
argument_list|,
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_sbsize
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|altsblock
operator|.
name|fs_link
operator|=
name|sblock
operator|.
name|fs_link
expr_stmt|;
name|altsblock
operator|.
name|fs_rlink
operator|=
name|sblock
operator|.
name|fs_rlink
expr_stmt|;
name|altsblock
operator|.
name|fs_time
operator|=
name|sblock
operator|.
name|fs_time
expr_stmt|;
name|altsblock
operator|.
name|fs_cstotal
operator|=
name|sblock
operator|.
name|fs_cstotal
expr_stmt|;
name|altsblock
operator|.
name|fs_cgrotor
operator|=
name|sblock
operator|.
name|fs_cgrotor
expr_stmt|;
name|altsblock
operator|.
name|fs_fmod
operator|=
name|sblock
operator|.
name|fs_fmod
expr_stmt|;
name|altsblock
operator|.
name|fs_clean
operator|=
name|sblock
operator|.
name|fs_clean
expr_stmt|;
name|altsblock
operator|.
name|fs_ronly
operator|=
name|sblock
operator|.
name|fs_ronly
expr_stmt|;
name|altsblock
operator|.
name|fs_flags
operator|=
name|sblock
operator|.
name|fs_flags
expr_stmt|;
name|altsblock
operator|.
name|fs_maxcontig
operator|=
name|sblock
operator|.
name|fs_maxcontig
expr_stmt|;
name|altsblock
operator|.
name|fs_minfree
operator|=
name|sblock
operator|.
name|fs_minfree
expr_stmt|;
name|altsblock
operator|.
name|fs_rotdelay
operator|=
name|sblock
operator|.
name|fs_rotdelay
expr_stmt|;
name|altsblock
operator|.
name|fs_maxbpg
operator|=
name|sblock
operator|.
name|fs_maxbpg
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sblock
operator|.
name|fs_csp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|altsblock
operator|.
name|fs_csp
argument_list|,
sizeof|sizeof
name|sblock
operator|.
name|fs_csp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sblock
operator|.
name|fs_fsmnt
argument_list|,
operator|(
name|char
operator|*
operator|)
name|altsblock
operator|.
name|fs_fsmnt
argument_list|,
sizeof|sizeof
name|sblock
operator|.
name|fs_fsmnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sblock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|altsblock
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|.
name|fs_sbsize
argument_list|)
condition|)
block|{
name|badsb
argument_list|(
literal|"TRASHED VALUES IN SUPER BLOCK"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sbok
label|:
name|fmax
operator|=
name|sblock
operator|.
name|fs_size
expr_stmt|;
name|imax
operator|=
name|sblock
operator|.
name|fs_ncg
operator|*
name|sblock
operator|.
name|fs_ipg
expr_stmt|;
name|n_bad
operator|=
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* boot block plus dedicated sblock */
comment|/* 	 * read in the summary info. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_cssize
condition|;
name|i
operator|+=
name|sblock
operator|.
name|fs_bsize
operator|,
name|j
operator|++
control|)
block|{
name|size
operator|=
name|sblock
operator|.
name|fs_cssize
operator|-
name|i
operator|<
name|sblock
operator|.
name|fs_bsize
condition|?
name|sblock
operator|.
name|fs_cssize
operator|-
name|i
else|:
name|sblock
operator|.
name|fs_bsize
expr_stmt|;
name|sblock
operator|.
name|fs_csp
index|[
name|j
index|]
operator|=
operator|(
expr|struct
name|csum
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
operator|&
name|dfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sblock
operator|.
name|fs_csp
index|[
name|j
index|]
argument_list|,
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_csaddr
operator|+
name|j
operator|*
name|sblock
operator|.
name|fs_frag
argument_list|)
argument_list|,
name|size
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * allocate and initialize the necessary maps 	 */
name|bmapsz
operator|=
name|roundup
argument_list|(
name|howmany
argument_list|(
name|fmax
argument_list|,
name|NBBY
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|blockmap
operator|=
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|bmapsz
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockmap
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cannot alloc %d bytes for blockmap\n"
argument_list|,
name|bmapsz
argument_list|)
expr_stmt|;
goto|goto
name|badsb
goto|;
block|}
name|freemap
operator|=
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|bmapsz
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|freemap
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cannot alloc %d bytes for freemap\n"
argument_list|,
name|bmapsz
argument_list|)
expr_stmt|;
goto|goto
name|badsb
goto|;
block|}
name|statemap
operator|=
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|imax
operator|+
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|statemap
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cannot alloc %d bytes for statemap\n"
argument_list|,
name|imax
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|badsb
goto|;
block|}
name|lncntp
operator|=
operator|(
name|short
operator|*
operator|)
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|imax
operator|+
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lncntp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cannot alloc %d bytes for lncntp\n"
argument_list|,
operator|(
name|imax
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badsb
goto|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|c
operator|++
control|)
block|{
name|cgd
operator|=
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|d
operator|=
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|cgd
operator|+=
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
block|}
else|else
name|d
operator|=
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|d
operator|<
name|cgd
condition|;
name|d
operator|++
control|)
name|setbmap
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|badsb
label|:
name|ckfini
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|altsblock
block|}
end_block

begin_macro
name|pass1
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
name|int
name|ndb
decl_stmt|,
name|partial
decl_stmt|;
name|struct
name|inodesc
name|idesc
decl_stmt|;
name|ino_t
name|inumber
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|idesc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inodesc
argument_list|)
argument_list|)
expr_stmt|;
name|idesc
operator|.
name|id_type
operator|=
name|ADDR
expr_stmt|;
name|idesc
operator|.
name|id_func
operator|=
name|pass1check
expr_stmt|;
name|inumber
operator|=
literal|0
expr_stmt|;
name|n_blks
operator|+=
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|cgblk
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_cgsize
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cgrp
operator|.
name|cg_magic
operator|!=
name|CG_MAGIC
condition|)
block|{
name|pfatal
argument_list|(
literal|"CG %d: BAD MAGIC NUMBER\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cgrp
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|.
name|fs_cgsize
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_ipg
condition|;
name|i
operator|++
operator|,
name|inumber
operator|++
control|)
block|{
name|dp
operator|=
name|ginode
argument_list|(
name|inumber
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
continue|continue;
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|ALLOC
condition|)
block|{
if|if
condition|(
operator|!
name|isset
argument_list|(
name|cgrp
operator|.
name|cg_iused
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%d bad, not used\n"
argument_list|,
name|inumber
argument_list|)
expr_stmt|;
name|inosumbad
operator|++
expr_stmt|;
block|}
name|n
operator|--
expr_stmt|;
name|lastino
operator|=
name|inumber
expr_stmt|;
if|if
condition|(
operator|!
name|preen
operator|&&
name|BADBLK
operator|&&
name|reply
argument_list|(
literal|"HOLD BAD BLOCK"
argument_list|)
operator|==
literal|1
condition|)
block|{
name|dp
operator|->
name|di_size
operator|=
name|sblock
operator|.
name|fs_fsize
expr_stmt|;
name|dp
operator|->
name|di_mode
operator|=
name|IFREG
operator||
literal|0600
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ftypeok
argument_list|(
name|dp
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|unknown
goto|;
if|if
condition|(
name|dp
operator|->
name|di_size
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"bad size %d:"
argument_list|,
name|dp
operator|->
name|di_size
argument_list|)
expr_stmt|;
goto|goto
name|unknown
goto|;
block|}
name|ndb
operator|=
name|howmany
argument_list|(
name|dp
operator|->
name|di_size
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|SPECIAL
condition|)
name|ndb
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
name|ndb
init|;
name|j
operator|<
name|NDADDR
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|dp
operator|->
name|di_db
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"bad direct addr: %d\n"
argument_list|,
name|dp
operator|->
name|di_db
index|[
name|j
index|]
argument_list|)
expr_stmt|;
goto|goto
name|unknown
goto|;
block|}
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|ndb
operator|-=
name|NDADDR
init|;
name|ndb
operator|>
literal|0
condition|;
name|j
operator|++
control|)
name|ndb
operator|/=
name|NINDIR
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|NIADDR
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|dp
operator|->
name|di_ib
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"bad indirect addr: %d\n"
argument_list|,
name|dp
operator|->
name|di_ib
index|[
name|j
index|]
argument_list|)
expr_stmt|;
goto|goto
name|unknown
goto|;
block|}
name|n_files
operator|++
expr_stmt|;
name|lncntp
index|[
name|inumber
index|]
operator|=
name|dp
operator|->
name|di_nlink
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|di_nlink
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|badlnp
operator|<
operator|&
name|badlncnt
index|[
name|MAXLNCNT
index|]
condition|)
operator|*
name|badlnp
operator|++
operator|=
name|inumber
expr_stmt|;
else|else
block|{
name|pfatal
argument_list|(
literal|"LINK COUNT TABLE OVERFLOW"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|statemap
index|[
name|inumber
index|]
operator|=
name|DIRCT
condition|?
name|DSTATE
else|:
name|FSTATE
expr_stmt|;
name|badblk
operator|=
name|dupblk
operator|=
literal|0
expr_stmt|;
name|maxblk
operator|=
literal|0
expr_stmt|;
name|idesc
operator|.
name|id_number
operator|=
name|inumber
expr_stmt|;
name|idesc
operator|.
name|id_filesize
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|ckinode
argument_list|(
name|dp
argument_list|,
operator|&
name|idesc
argument_list|)
expr_stmt|;
name|idesc
operator|.
name|id_filesize
operator|*=
name|btodb
argument_list|(
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|di_blocks
operator|!=
name|idesc
operator|.
name|id_filesize
condition|)
block|{
name|pwarn
argument_list|(
literal|"INCORRECT BLOCK COUNT I=%u (%ld should be %ld)"
argument_list|,
name|inumber
argument_list|,
name|dp
operator|->
name|di_blocks
argument_list|,
name|idesc
operator|.
name|id_filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (CORRECTED)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reply
argument_list|(
literal|"CORRECT"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|dp
operator|->
name|di_blocks
operator|=
name|idesc
operator|.
name|id_filesize
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
block|}
continue|continue;
name|unknown
label|:
name|pfatal
argument_list|(
literal|"UNKNOWN FILE TYPE I=%u"
argument_list|,
name|inumber
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CLEAR"
argument_list|)
operator|==
literal|1
condition|)
block|{
name|zapino
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|inosumbad
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|isset
argument_list|(
name|cgrp
operator|.
name|cg_iused
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%d bad, marked used\n"
argument_list|,
name|inumber
argument_list|)
expr_stmt|;
name|inosumbad
operator|++
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
name|partial
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NDADDR
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|dp
operator|->
name|di_db
index|[
name|j
index|]
operator|!=
literal|0
condition|)
name|partial
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NIADDR
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|dp
operator|->
name|di_ib
index|[
name|j
index|]
operator|!=
literal|0
condition|)
name|partial
operator|++
expr_stmt|;
if|if
condition|(
name|partial
operator|||
name|dp
operator|->
name|di_mode
operator|!=
literal|0
operator|||
name|dp
operator|->
name|di_size
operator|!=
literal|0
condition|)
block|{
name|pfatal
argument_list|(
literal|"PARTIALLY ALLOCATED INODE I=%u"
argument_list|,
name|inumber
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CLEAR"
argument_list|)
operator|==
literal|1
condition|)
block|{
name|zapino
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|inosumbad
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|n
operator|!=
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nifree
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"cg[%d].cg_cs.cs_nifree is %d; calc %d\n"
argument_list|,
name|c
argument_list|,
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nifree
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|inosumbad
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|!=
name|sblock
operator|.
name|fs_cs
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
operator|.
name|cs_nbfree
operator|||
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|!=
name|sblock
operator|.
name|fs_cs
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
operator|.
name|cs_nffree
operator|||
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|!=
name|sblock
operator|.
name|fs_cs
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
operator|.
name|cs_nifree
operator|||
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_ndir
operator|!=
name|sblock
operator|.
name|fs_cs
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
operator|.
name|cs_ndir
condition|)
name|sbsumbad
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|pass1check
argument_list|(
name|idesc
argument_list|)
specifier|register
expr|struct
name|inodesc
operator|*
name|idesc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|daddr_t
modifier|*
name|dlp
decl_stmt|;
name|int
name|res
init|=
name|KEEPON
decl_stmt|;
name|int
name|anyout
decl_stmt|,
name|nfrags
decl_stmt|;
name|daddr_t
name|blkno
init|=
name|idesc
operator|->
name|id_blkno
decl_stmt|;
name|anyout
operator|=
name|outrange
argument_list|(
name|blkno
argument_list|,
name|idesc
operator|->
name|id_numfrags
argument_list|)
expr_stmt|;
for|for
control|(
name|nfrags
operator|=
name|idesc
operator|->
name|id_numfrags
init|;
name|nfrags
operator|>
literal|0
condition|;
name|blkno
operator|++
operator|,
name|nfrags
operator|--
control|)
block|{
if|if
condition|(
name|anyout
operator|&&
name|outrange
argument_list|(
name|blkno
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|blkerr
argument_list|(
name|idesc
operator|->
name|id_number
argument_list|,
literal|"BAD"
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|badblk
operator|>=
name|MAXBAD
condition|)
block|{
name|pwarn
argument_list|(
literal|"EXCESSIVE BAD BLKS I=%u"
argument_list|,
name|idesc
operator|->
name|id_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (SKIPPING)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
name|res
operator|=
name|SKIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|getbmap
argument_list|(
name|blkno
argument_list|)
condition|)
block|{
name|blkerr
argument_list|(
name|idesc
operator|->
name|id_number
argument_list|,
literal|"DUP"
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|dupblk
operator|>=
name|MAXDUP
condition|)
block|{
name|pwarn
argument_list|(
literal|"EXCESSIVE DUP BLKS I=%u"
argument_list|,
name|idesc
operator|->
name|id_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (SKIPPING)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
if|if
condition|(
name|enddup
operator|>=
operator|&
name|duplist
index|[
name|DUPTBLSIZE
index|]
condition|)
block|{
name|pfatal
argument_list|(
literal|"DUP TABLE OVERFLOW."
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
for|for
control|(
name|dlp
operator|=
name|duplist
init|;
name|dlp
operator|<
name|muldup
condition|;
name|dlp
operator|++
control|)
if|if
condition|(
operator|*
name|dlp
operator|==
name|blkno
condition|)
block|{
operator|*
name|enddup
operator|++
operator|=
name|blkno
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dlp
operator|>=
name|muldup
condition|)
block|{
operator|*
name|enddup
operator|++
operator|=
operator|*
name|muldup
expr_stmt|;
operator|*
name|muldup
operator|++
operator|=
name|blkno
expr_stmt|;
block|}
block|}
else|else
block|{
name|n_blks
operator|++
expr_stmt|;
name|setbmap
argument_list|(
name|blkno
argument_list|)
expr_stmt|;
block|}
name|idesc
operator|->
name|id_filesize
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_block

begin_macro
name|pass1b
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
name|struct
name|inodesc
name|idesc
decl_stmt|;
name|ino_t
name|inumber
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|idesc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inodesc
argument_list|)
argument_list|)
expr_stmt|;
name|idesc
operator|.
name|id_type
operator|=
name|ADDR
expr_stmt|;
name|idesc
operator|.
name|id_func
operator|=
name|pass1bcheck
expr_stmt|;
name|inumber
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|c
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_ipg
condition|;
name|i
operator|++
operator|,
name|inumber
operator|++
control|)
block|{
name|dp
operator|=
name|ginode
argument_list|(
name|inumber
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
continue|continue;
name|idesc
operator|.
name|id_number
operator|=
name|inumber
expr_stmt|;
if|if
condition|(
name|statemap
index|[
name|inumber
index|]
operator|!=
name|USTATE
operator|&&
operator|(
name|ckinode
argument_list|(
name|dp
argument_list|,
operator|&
name|idesc
argument_list|)
operator|&
name|STOP
operator|)
condition|)
goto|goto
name|out1b
goto|;
block|}
block|}
name|out1b
label|:
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|inoblk
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|pass1bcheck
argument_list|(
name|idesc
argument_list|)
specifier|register
expr|struct
name|inodesc
operator|*
name|idesc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|daddr_t
modifier|*
name|dlp
decl_stmt|;
name|int
name|nfrags
decl_stmt|,
name|res
init|=
name|KEEPON
decl_stmt|;
name|daddr_t
name|blkno
init|=
name|idesc
operator|->
name|id_blkno
decl_stmt|;
for|for
control|(
name|nfrags
operator|=
name|idesc
operator|->
name|id_numfrags
init|;
name|nfrags
operator|>
literal|0
condition|;
name|blkno
operator|++
operator|,
name|nfrags
operator|--
control|)
block|{
if|if
condition|(
name|outrange
argument_list|(
name|blkno
argument_list|,
literal|1
argument_list|)
condition|)
name|res
operator|=
name|SKIP
expr_stmt|;
for|for
control|(
name|dlp
operator|=
name|duplist
init|;
name|dlp
operator|<
name|muldup
condition|;
name|dlp
operator|++
control|)
if|if
condition|(
operator|*
name|dlp
operator|==
name|blkno
condition|)
block|{
name|blkerr
argument_list|(
name|idesc
operator|->
name|id_number
argument_list|,
literal|"DUP"
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
operator|*
name|dlp
operator|=
operator|*
operator|--
name|muldup
expr_stmt|;
operator|*
name|muldup
operator|=
name|blkno
expr_stmt|;
if|if
condition|(
name|muldup
operator|==
name|duplist
condition|)
return|return
operator|(
name|STOP
operator|)
return|;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_block

begin_macro
name|pass2
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
name|struct
name|inodesc
name|rootdesc
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rootdesc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inodesc
argument_list|)
argument_list|)
expr_stmt|;
name|rootdesc
operator|.
name|id_type
operator|=
name|ADDR
expr_stmt|;
name|rootdesc
operator|.
name|id_func
operator|=
name|pass2check
expr_stmt|;
name|rootdesc
operator|.
name|id_number
operator|=
name|ROOTINO
expr_stmt|;
name|pathp
operator|=
name|pathname
expr_stmt|;
switch|switch
condition|(
name|statemap
index|[
name|ROOTINO
index|]
condition|)
block|{
case|case
name|USTATE
case|:
name|errexit
argument_list|(
literal|"ROOT INODE UNALLOCATED. TERMINATING.\n"
argument_list|)
expr_stmt|;
case|case
name|FSTATE
case|:
name|pfatal
argument_list|(
literal|"ROOT INODE NOT DIRECTORY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|dp
operator|=
name|ginode
argument_list|(
name|ROOTINO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|dp
operator|->
name|di_mode
operator|&=
operator|~
name|IFMT
expr_stmt|;
name|dp
operator|->
name|di_mode
operator||=
name|IFDIR
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|inosumbad
operator|++
expr_stmt|;
name|statemap
index|[
name|ROOTINO
index|]
operator|=
name|DSTATE
expr_stmt|;
comment|/* fall into ... */
case|case
name|DSTATE
case|:
name|descend
argument_list|(
operator|&
name|rootdesc
argument_list|,
name|ROOTINO
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEAR
case|:
name|pfatal
argument_list|(
literal|"DUPS/BAD IN ROOT INODE"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|statemap
index|[
name|ROOTINO
index|]
operator|=
name|DSTATE
expr_stmt|;
name|descend
argument_list|(
operator|&
name|rootdesc
argument_list|,
name|ROOTINO
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|pass2check
argument_list|(
argument|idesc
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inodesc
modifier|*
name|idesc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DIRECT
modifier|*
name|dirp
init|=
name|idesc
operator|->
name|id_dirp
decl_stmt|;
name|char
modifier|*
name|curpathloc
decl_stmt|;
name|int
name|n
decl_stmt|,
name|entrysize
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|DINODE
modifier|*
name|dp
decl_stmt|;
name|DIRECT
name|proto
decl_stmt|;
comment|/*  	 * check for "." 	 */
if|if
condition|(
name|idesc
operator|->
name|id_entryno
operator|!=
literal|0
condition|)
goto|goto
name|chk1
goto|;
if|if
condition|(
name|dirp
operator|->
name|d_ino
operator|!=
literal|0
operator|&&
name|dirp
operator|->
name|d_namlen
operator|==
literal|1
operator|&&
name|dirp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|dirp
operator|->
name|d_ino
operator|!=
name|idesc
operator|->
name|id_number
condition|)
block|{
name|direrr
argument_list|(
name|idesc
operator|->
name|id_number
argument_list|,
literal|"BAD INODE NUMBER FOR '.'"
argument_list|)
expr_stmt|;
name|dirp
operator|->
name|d_ino
operator|=
name|idesc
operator|->
name|id_number
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
literal|1
condition|)
name|ret
operator||=
name|ALTERED
expr_stmt|;
block|}
goto|goto
name|chk1
goto|;
block|}
name|direrr
argument_list|(
name|idesc
operator|->
name|id_number
argument_list|,
literal|"MISSING '.'"
argument_list|)
expr_stmt|;
name|proto
operator|.
name|d_ino
operator|=
name|idesc
operator|->
name|id_number
expr_stmt|;
name|proto
operator|.
name|d_namlen
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|proto
operator|.
name|d_name
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|entrysize
operator|=
name|DIRSIZ
argument_list|(
operator|&
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|->
name|d_ino
operator|!=
literal|0
condition|)
block|{
name|pfatal
argument_list|(
literal|"CANNOT FIX, FIRST ENTRY IN DIRECTORY CONTAINS %s\n"
argument_list|,
name|dirp
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dirp
operator|->
name|d_reclen
operator|<
name|entrysize
condition|)
block|{
name|pfatal
argument_list|(
literal|"CANNOT FIX, INSUFFICIENT SPACE TO ADD '.'\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dirp
operator|->
name|d_reclen
operator|<
literal|2
operator|*
name|entrysize
condition|)
block|{
name|proto
operator|.
name|d_reclen
operator|=
name|dirp
operator|->
name|d_reclen
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|proto
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dirp
argument_list|,
name|entrysize
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
literal|1
condition|)
name|ret
operator||=
name|ALTERED
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|dirp
operator|->
name|d_reclen
operator|-
name|entrysize
expr_stmt|;
name|proto
operator|.
name|d_reclen
operator|=
name|entrysize
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|proto
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dirp
argument_list|,
name|entrysize
argument_list|)
expr_stmt|;
name|idesc
operator|->
name|id_entryno
operator|++
expr_stmt|;
name|lncntp
index|[
name|dirp
operator|->
name|d_ino
index|]
operator|--
expr_stmt|;
name|dirp
operator|=
operator|(
name|DIRECT
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|dirp
operator|)
operator|+
name|entrysize
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dirp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dirp
operator|->
name|d_reclen
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
literal|1
condition|)
name|ret
operator||=
name|ALTERED
expr_stmt|;
block|}
name|chk1
label|:
if|if
condition|(
name|idesc
operator|->
name|id_entryno
operator|>
literal|1
condition|)
goto|goto
name|chk2
goto|;
name|proto
operator|.
name|d_ino
operator|=
name|idesc
operator|->
name|id_parent
expr_stmt|;
name|proto
operator|.
name|d_namlen
operator|=
literal|2
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|proto
operator|.
name|d_name
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
name|entrysize
operator|=
name|DIRSIZ
argument_list|(
operator|&
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|idesc
operator|->
name|id_entryno
operator|==
literal|0
condition|)
block|{
name|n
operator|=
name|DIRSIZ
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|->
name|d_reclen
operator|<
name|n
operator|+
name|entrysize
condition|)
goto|goto
name|chk2
goto|;
name|proto
operator|.
name|d_reclen
operator|=
name|dirp
operator|->
name|d_reclen
operator|-
name|n
expr_stmt|;
name|dirp
operator|->
name|d_reclen
operator|=
name|n
expr_stmt|;
name|idesc
operator|->
name|id_entryno
operator|++
expr_stmt|;
name|lncntp
index|[
name|dirp
operator|->
name|d_ino
index|]
operator|--
expr_stmt|;
name|dirp
operator|=
operator|(
name|DIRECT
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|dirp
operator|)
operator|+
name|n
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dirp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dirp
operator|->
name|d_reclen
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|dirp
operator|->
name|d_ino
operator|!=
literal|0
operator|&&
name|dirp
operator|->
name|d_namlen
operator|==
literal|2
operator|&&
name|strcmp
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dirp
operator|->
name|d_ino
operator|!=
name|idesc
operator|->
name|id_parent
condition|)
block|{
name|direrr
argument_list|(
name|idesc
operator|->
name|id_number
argument_list|,
literal|"BAD INODE NUMBER FOR '..'"
argument_list|)
expr_stmt|;
name|dirp
operator|->
name|d_ino
operator|=
name|idesc
operator|->
name|id_parent
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
literal|1
condition|)
name|ret
operator||=
name|ALTERED
expr_stmt|;
block|}
goto|goto
name|chk2
goto|;
block|}
name|direrr
argument_list|(
name|idesc
operator|->
name|id_number
argument_list|,
literal|"MISSING '..'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|->
name|d_ino
operator|!=
literal|0
condition|)
block|{
name|pfatal
argument_list|(
literal|"CANNOT FIX, SECOND ENTRY IN DIRECTORY CONTAINS %s\n"
argument_list|,
name|dirp
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dirp
operator|->
name|d_reclen
operator|<
name|entrysize
condition|)
block|{
name|pfatal
argument_list|(
literal|"CANNOT FIX, INSUFFICIENT SPACE TO ADD '..'\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|proto
operator|.
name|d_reclen
operator|=
name|dirp
operator|->
name|d_reclen
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|proto
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dirp
argument_list|,
name|entrysize
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
literal|1
condition|)
name|ret
operator||=
name|ALTERED
expr_stmt|;
block|}
name|chk2
label|:
if|if
condition|(
name|dirp
operator|->
name|d_ino
operator|==
literal|0
condition|)
return|return
operator|(
name|ret
operator||
name|KEEPON
operator|)
return|;
if|if
condition|(
name|idesc
operator|->
name|id_entryno
operator|>=
literal|2
operator|&&
name|dirp
operator|->
name|d_namlen
operator|<=
literal|2
operator|&&
name|dirp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|dirp
operator|->
name|d_namlen
operator|==
literal|1
condition|)
block|{
name|direrr
argument_list|(
name|idesc
operator|->
name|id_number
argument_list|,
literal|"EXTRA '.' ENTRY"
argument_list|)
expr_stmt|;
name|dirp
operator|->
name|d_ino
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
literal|1
condition|)
name|ret
operator||=
name|ALTERED
expr_stmt|;
return|return
operator|(
name|KEEPON
operator||
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|dirp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|direrr
argument_list|(
name|idesc
operator|->
name|id_number
argument_list|,
literal|"EXTRA '..' ENTRY"
argument_list|)
expr_stmt|;
name|dirp
operator|->
name|d_ino
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
literal|1
condition|)
name|ret
operator||=
name|ALTERED
expr_stmt|;
return|return
operator|(
name|KEEPON
operator||
name|ret
operator|)
return|;
block|}
block|}
name|curpathloc
operator|=
name|pathp
expr_stmt|;
operator|*
name|pathp
operator|++
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|pathp
operator|+
name|dirp
operator|->
name|d_namlen
operator|>=
name|endpathname
condition|)
block|{
operator|*
name|pathp
operator|=
literal|'\0'
expr_stmt|;
name|errexit
argument_list|(
literal|"NAME TOO LONG %s%s\n"
argument_list|,
name|pathname
argument_list|,
name|dirp
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|,
name|pathp
argument_list|,
name|dirp
operator|->
name|d_namlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pathp
operator|+=
name|dirp
operator|->
name|d_namlen
expr_stmt|;
name|idesc
operator|->
name|id_entryno
operator|++
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dirp
operator|->
name|d_ino
operator|>
name|imax
operator|||
name|dirp
operator|->
name|d_ino
operator|<=
literal|0
condition|)
block|{
name|direrr
argument_list|(
name|dirp
operator|->
name|d_ino
argument_list|,
literal|"I OUT OF RANGE"
argument_list|)
expr_stmt|;
name|n
operator|=
name|reply
argument_list|(
literal|"REMOVE"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|again
label|:
switch|switch
condition|(
name|statemap
index|[
name|dirp
operator|->
name|d_ino
index|]
condition|)
block|{
case|case
name|USTATE
case|:
name|direrr
argument_list|(
name|dirp
operator|->
name|d_ino
argument_list|,
literal|"UNALLOCATED"
argument_list|)
expr_stmt|;
name|n
operator|=
name|reply
argument_list|(
literal|"REMOVE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEAR
case|:
name|direrr
argument_list|(
name|dirp
operator|->
name|d_ino
argument_list|,
literal|"DUP/BAD"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|reply
argument_list|(
literal|"REMOVE"
argument_list|)
operator|)
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|(
name|dirp
operator|->
name|d_ino
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|statemap
index|[
name|dirp
operator|->
name|d_ino
index|]
operator|=
name|DIRCT
condition|?
name|DSTATE
else|:
name|FSTATE
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|FSTATE
case|:
name|lncntp
index|[
name|dirp
operator|->
name|d_ino
index|]
operator|--
expr_stmt|;
break|break;
case|case
name|DSTATE
case|:
name|descend
argument_list|(
name|idesc
argument_list|,
name|dirp
operator|->
name|d_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|statemap
index|[
name|dirp
operator|->
name|d_ino
index|]
operator|!=
name|CLEAR
condition|)
block|{
name|lncntp
index|[
name|dirp
operator|->
name|d_ino
index|]
operator|--
expr_stmt|;
block|}
else|else
block|{
name|dirp
operator|->
name|d_ino
operator|=
literal|0
expr_stmt|;
name|ret
operator||=
name|ALTERED
expr_stmt|;
block|}
break|break;
block|}
block|}
name|pathp
operator|=
name|curpathloc
expr_stmt|;
operator|*
name|pathp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|ret
operator||
name|KEEPON
operator|)
return|;
name|dirp
operator|->
name|d_ino
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator||
name|KEEPON
operator||
name|ALTERED
operator|)
return|;
block|}
end_block

begin_macro
name|pass3
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
name|struct
name|inodesc
name|idesc
decl_stmt|;
name|ino_t
name|inumber
decl_stmt|,
name|orphan
decl_stmt|;
name|int
name|loopcnt
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|idesc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inodesc
argument_list|)
argument_list|)
expr_stmt|;
name|idesc
operator|.
name|id_type
operator|=
name|DATA
expr_stmt|;
for|for
control|(
name|inumber
operator|=
name|ROOTINO
init|;
name|inumber
operator|<=
name|lastino
condition|;
name|inumber
operator|++
control|)
block|{
if|if
condition|(
name|statemap
index|[
name|inumber
index|]
operator|==
name|DSTATE
condition|)
block|{
name|pathp
operator|=
name|pathname
expr_stmt|;
operator|*
name|pathp
operator|++
operator|=
literal|'?'
expr_stmt|;
operator|*
name|pathp
operator|=
literal|'\0'
expr_stmt|;
name|idesc
operator|.
name|id_func
operator|=
name|findino
expr_stmt|;
name|srchname
operator|=
literal|".."
expr_stmt|;
name|idesc
operator|.
name|id_parent
operator|=
name|inumber
expr_stmt|;
name|loopcnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|orphan
operator|=
name|idesc
operator|.
name|id_parent
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|(
name|orphan
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|idesc
operator|.
name|id_parent
operator|=
literal|0
expr_stmt|;
name|idesc
operator|.
name|id_filesize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
name|idesc
operator|.
name|id_number
operator|=
name|orphan
expr_stmt|;
operator|(
name|void
operator|)
name|ckinode
argument_list|(
name|dp
argument_list|,
operator|&
name|idesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|idesc
operator|.
name|id_parent
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|loopcnt
operator|>=
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_ndir
condition|)
break|break;
name|loopcnt
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|statemap
index|[
name|idesc
operator|.
name|id_parent
index|]
operator|==
name|DSTATE
condition|)
do|;
if|if
condition|(
name|linkup
argument_list|(
name|orphan
argument_list|,
name|idesc
operator|.
name|id_parent
argument_list|)
operator|==
literal|1
condition|)
block|{
name|idesc
operator|.
name|id_func
operator|=
name|pass2check
expr_stmt|;
name|idesc
operator|.
name|id_number
operator|=
name|lfdir
expr_stmt|;
name|descend
argument_list|(
operator|&
name|idesc
argument_list|,
name|orphan
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_macro
name|pass4
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|ino_t
name|inumber
decl_stmt|,
modifier|*
name|blp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|inodesc
name|idesc
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|idesc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inodesc
argument_list|)
argument_list|)
expr_stmt|;
name|idesc
operator|.
name|id_type
operator|=
name|ADDR
expr_stmt|;
name|idesc
operator|.
name|id_func
operator|=
name|pass4check
expr_stmt|;
for|for
control|(
name|inumber
operator|=
name|ROOTINO
init|;
name|inumber
operator|<=
name|lastino
condition|;
name|inumber
operator|++
control|)
block|{
name|idesc
operator|.
name|id_number
operator|=
name|inumber
expr_stmt|;
switch|switch
condition|(
name|statemap
index|[
name|inumber
index|]
condition|)
block|{
case|case
name|FSTATE
case|:
name|n
operator|=
name|lncntp
index|[
name|inumber
index|]
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|adjust
argument_list|(
operator|&
name|idesc
argument_list|,
operator|(
name|short
operator|)
name|n
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|blp
operator|=
name|badlncnt
init|;
name|blp
operator|<
name|badlnp
condition|;
name|blp
operator|++
control|)
if|if
condition|(
operator|*
name|blp
operator|==
name|inumber
condition|)
block|{
name|clri
argument_list|(
operator|&
name|idesc
argument_list|,
literal|"UNREF"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|DSTATE
case|:
name|clri
argument_list|(
operator|&
name|idesc
argument_list|,
literal|"UNREF"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEAR
case|:
name|clri
argument_list|(
operator|&
name|idesc
argument_list|,
literal|"BAD/DUP"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|imax
operator|-
name|ROOTINO
operator|-
name|n_files
operator|!=
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nifree
condition|)
block|{
name|pwarn
argument_list|(
literal|"FREE INODE COUNT WRONG IN SUPERBLK"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (FIXED)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
operator|||
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
literal|1
condition|)
block|{
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nifree
operator|=
name|imax
operator|-
name|ROOTINO
operator|-
name|n_files
expr_stmt|;
name|sbdirty
argument_list|()
expr_stmt|;
block|}
block|}
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|fileblk
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|pass4check
argument_list|(
name|idesc
argument_list|)
specifier|register
expr|struct
name|inodesc
operator|*
name|idesc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|daddr_t
modifier|*
name|dlp
decl_stmt|;
name|int
name|nfrags
decl_stmt|,
name|res
init|=
name|KEEPON
decl_stmt|;
name|daddr_t
name|blkno
init|=
name|idesc
operator|->
name|id_blkno
decl_stmt|;
for|for
control|(
name|nfrags
operator|=
name|idesc
operator|->
name|id_numfrags
init|;
name|nfrags
operator|>
literal|0
condition|;
name|blkno
operator|++
operator|,
name|nfrags
operator|--
control|)
block|{
if|if
condition|(
name|outrange
argument_list|(
name|blkno
argument_list|,
literal|1
argument_list|)
condition|)
name|res
operator|=
name|SKIP
expr_stmt|;
elseif|else
if|if
condition|(
name|getbmap
argument_list|(
name|blkno
argument_list|)
condition|)
block|{
for|for
control|(
name|dlp
operator|=
name|duplist
init|;
name|dlp
operator|<
name|enddup
condition|;
name|dlp
operator|++
control|)
if|if
condition|(
operator|*
name|dlp
operator|==
name|blkno
condition|)
block|{
operator|*
name|dlp
operator|=
operator|*
operator|--
name|enddup
expr_stmt|;
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
name|clrbmap
argument_list|(
name|blkno
argument_list|)
expr_stmt|;
name|n_blks
operator|--
expr_stmt|;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_block

begin_macro
name|pass5
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|b
decl_stmt|,
name|d
decl_stmt|;
name|short
name|bo
index|[
name|MAXCPG
index|]
index|[
name|NRPOS
index|]
decl_stmt|;
name|long
name|botot
index|[
name|MAXCPG
index|]
decl_stmt|;
name|long
name|frsum
index|[
name|MAXFRAG
index|]
decl_stmt|;
name|int
name|blk
decl_stmt|;
name|daddr_t
name|cbase
decl_stmt|;
name|int
name|blockbits
init|=
operator|(
literal|1
operator|<<
name|sblock
operator|.
name|fs_frag
operator|)
operator|-
literal|1
decl_stmt|;
name|bcopy
argument_list|(
name|blockmap
argument_list|,
name|freemap
argument_list|,
operator|(
name|unsigned
operator|)
name|bmapsz
argument_list|)
expr_stmt|;
name|dupblk
operator|=
literal|0
expr_stmt|;
name|n_index
operator|=
name|sblock
operator|.
name|fs_ncg
operator|*
operator|(
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
literal|0
argument_list|)
operator|-
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|c
operator|++
control|)
block|{
name|cbase
operator|=
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|botot
argument_list|,
sizeof|sizeof
argument_list|(
name|botot
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bo
argument_list|,
sizeof|sizeof
argument_list|(
name|bo
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|frsum
argument_list|,
sizeof|sizeof
argument_list|(
name|frsum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * need to account for the super blocks 		 * which appear (inaccurately) bad 		 */
name|n_bad
operator|+=
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
operator|-
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|cgblk
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_cgsize
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cgrp
operator|.
name|cg_magic
operator|!=
name|CG_MAGIC
condition|)
block|{
name|pfatal
argument_list|(
literal|"CG %d: BAD MAGIC NUMBER\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cgrp
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|.
name|fs_cgsize
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|sblock
operator|.
name|fs_fpg
condition|;
name|b
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|blk
operator|=
name|blkmap
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgrp
operator|.
name|cg_free
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|blk
operator|==
name|blockbits
condition|)
block|{
if|if
condition|(
name|pass5check
argument_list|(
name|cbase
operator|+
name|b
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
operator|==
name|STOP
condition|)
goto|goto
name|out5
goto|;
comment|/* this is clumsy ... */
name|n_ffree
operator|-=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|n_bfree
operator|++
expr_stmt|;
name|botot
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|b
argument_list|)
index|]
operator|++
expr_stmt|;
name|bo
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|b
argument_list|)
index|]
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|b
argument_list|)
index|]
operator|++
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|sblock
operator|.
name|fs_frag
condition|;
name|d
operator|++
control|)
if|if
condition|(
operator|(
name|blk
operator|&
operator|(
literal|1
operator|<<
name|d
operator|)
operator|)
operator|&&
name|pass5check
argument_list|(
name|cbase
operator|+
name|b
operator|+
name|d
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|)
operator|==
name|STOP
condition|)
goto|goto
name|out5
goto|;
name|fragacct
argument_list|(
operator|&
name|sblock
argument_list|,
name|blk
argument_list|,
name|frsum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cgrp
operator|.
name|cg_frsum
argument_list|,
operator|(
name|char
operator|*
operator|)
name|frsum
argument_list|,
sizeof|sizeof
argument_list|(
name|frsum
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_frag
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cgrp
operator|.
name|cg_frsum
index|[
name|i
index|]
operator|!=
name|frsum
index|[
name|i
index|]
condition|)
name|printf
argument_list|(
literal|"cg[%d].cg_frsum[%d] have %d calc %d\n"
argument_list|,
name|c
argument_list|,
name|i
argument_list|,
name|cgrp
operator|.
name|cg_frsum
index|[
name|i
index|]
argument_list|,
name|frsum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|frsumbad
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cgrp
operator|.
name|cg_btot
argument_list|,
operator|(
name|char
operator|*
operator|)
name|botot
argument_list|,
sizeof|sizeof
argument_list|(
name|botot
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sblock
operator|.
name|fs_cpg
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|botot
index|[
name|n
index|]
operator|!=
name|cgrp
operator|.
name|cg_btot
index|[
name|n
index|]
condition|)
name|printf
argument_list|(
literal|"cg[%d].cg_btot[%d] have %d calc %d\n"
argument_list|,
name|c
argument_list|,
name|n
argument_list|,
name|cgrp
operator|.
name|cg_btot
index|[
name|n
index|]
argument_list|,
name|botot
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|offsumbad
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cgrp
operator|.
name|cg_b
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bo
argument_list|,
sizeof|sizeof
argument_list|(
name|bo
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRPOS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bo
index|[
name|n
index|]
index|[
name|i
index|]
operator|!=
name|cgrp
operator|.
name|cg_b
index|[
name|n
index|]
index|[
name|i
index|]
condition|)
name|printf
argument_list|(
literal|"cg[%d].cg_b[%d][%d] have %d calc %d\n"
argument_list|,
name|c
argument_list|,
name|n
argument_list|,
name|i
argument_list|,
name|cgrp
operator|.
name|cg_b
index|[
name|n
index|]
index|[
name|i
index|]
argument_list|,
name|bo
index|[
name|n
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|offsumbad
operator|++
expr_stmt|;
block|}
block|}
name|out5
label|:
if|if
condition|(
name|dupblk
condition|)
name|pwarn
argument_list|(
literal|"%d DUP BLKS IN BIT MAPS\n"
argument_list|,
name|dupblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixcg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|b
operator|=
name|n_blks
operator|+
name|n_ffree
operator|+
name|sblock
operator|.
name|fs_frag
operator|*
name|n_bfree
operator|+
name|n_index
operator|+
name|n_bad
operator|)
operator|!=
name|fmax
condition|)
block|{
name|pwarn
argument_list|(
literal|"%ld BLK(S) MISSING\n"
argument_list|,
name|fmax
operator|-
name|b
argument_list|)
expr_stmt|;
name|fixcg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inosumbad
operator|+
name|offsumbad
operator|+
name|frsumbad
operator|+
name|sbsumbad
condition|)
block|{
name|pwarn
argument_list|(
literal|"SUMMARY INFORMATION %s%s%s%sBAD\n"
argument_list|,
name|inosumbad
condition|?
literal|"(INODE FREE) "
else|:
literal|""
argument_list|,
name|offsumbad
condition|?
literal|"(BLOCK OFFSETS) "
else|:
literal|""
argument_list|,
name|frsumbad
condition|?
literal|"(FRAG SUMMARIES) "
else|:
literal|""
argument_list|,
name|sbsumbad
condition|?
literal|"(SUPER BLOCK SUMMARIES) "
else|:
literal|""
argument_list|)
expr_stmt|;
name|fixcg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_ffree
operator|!=
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|||
name|n_bfree
operator|!=
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
condition|)
block|{
name|pwarn
argument_list|(
literal|"FREE BLK COUNT(S) WRONG IN SUPERBLK"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (FIXED)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
operator|||
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
literal|1
condition|)
block|{
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|=
name|n_ffree
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|=
name|n_bfree
expr_stmt|;
name|sbdirty
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fixcg
condition|)
block|{
name|pwarn
argument_list|(
literal|"BAD CYLINDER GROUPS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (SALVAGED)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reply
argument_list|(
literal|"SALVAGE"
argument_list|)
operator|==
literal|0
condition|)
name|fixcg
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|pass5check
argument_list|(
argument|blk
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|outrange
argument_list|(
name|blk
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|)
condition|)
block|{
name|fixcg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|pfatal
argument_list|(
literal|"BAD BLOCKS IN BIT MAPS."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|badblk
operator|>=
name|MAXBAD
condition|)
block|{
name|printf
argument_list|(
literal|"EXCESSIVE BAD BLKS IN BIT MAPS."
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
block|}
for|for
control|(
init|;
name|size
operator|>
literal|0
condition|;
name|blk
operator|++
operator|,
name|size
operator|--
control|)
if|if
condition|(
name|getfmap
argument_list|(
name|blk
argument_list|)
condition|)
block|{
name|fixcg
operator|=
literal|1
expr_stmt|;
operator|++
name|dupblk
expr_stmt|;
block|}
else|else
block|{
name|n_ffree
operator|++
expr_stmt|;
name|setfmap
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_macro
name|ckinode
argument_list|(
argument|dp
argument_list|,
argument|idesc
argument_list|)
end_macro

begin_decl_stmt
name|DINODE
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|inodesc
modifier|*
name|idesc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|daddr_t
modifier|*
name|ap
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|n
decl_stmt|,
name|ndb
decl_stmt|,
name|offset
decl_stmt|;
name|DINODE
name|dino
decl_stmt|;
if|if
condition|(
name|SPECIAL
condition|)
return|return
operator|(
name|KEEPON
operator|)
return|;
name|dino
operator|=
operator|*
name|dp
expr_stmt|;
name|idesc
operator|->
name|id_fix
operator|=
name|DONTKNOW
expr_stmt|;
name|idesc
operator|->
name|id_entryno
operator|=
literal|0
expr_stmt|;
name|ndb
operator|=
name|howmany
argument_list|(
name|dino
operator|.
name|di_size
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
operator|&
name|dino
operator|.
name|di_db
index|[
literal|0
index|]
init|;
name|ap
operator|<
operator|&
name|dino
operator|.
name|di_db
index|[
name|NDADDR
index|]
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
operator|--
name|ndb
operator|==
literal|0
operator|&&
operator|(
name|offset
operator|=
name|blkoff
argument_list|(
operator|&
name|sblock
argument_list|,
name|dino
operator|.
name|di_size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|idesc
operator|->
name|id_numfrags
operator|=
name|numfrags
argument_list|(
operator|&
name|sblock
argument_list|,
name|fragroundup
argument_list|(
operator|&
name|sblock
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|idesc
operator|->
name|id_numfrags
operator|=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|==
literal|0
condition|)
continue|continue;
name|idesc
operator|->
name|id_blkno
operator|=
operator|*
name|ap
expr_stmt|;
if|if
condition|(
name|idesc
operator|->
name|id_type
operator|==
name|ADDR
condition|)
name|ret
operator|=
call|(
modifier|*
name|idesc
operator|->
name|id_func
call|)
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|dirscan
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&
name|STOP
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|idesc
operator|->
name|id_numfrags
operator|=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
for|for
control|(
name|ap
operator|=
operator|&
name|dino
operator|.
name|di_ib
index|[
literal|0
index|]
operator|,
name|n
operator|=
literal|1
init|;
name|n
operator|<=
literal|2
condition|;
name|ap
operator|++
operator|,
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ap
condition|)
block|{
name|idesc
operator|->
name|id_blkno
operator|=
operator|*
name|ap
expr_stmt|;
name|ret
operator|=
name|iblock
argument_list|(
name|idesc
argument_list|,
name|n
argument_list|,
name|dino
operator|.
name|di_size
operator|-
name|sblock
operator|.
name|fs_bsize
operator|*
name|NDADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&
name|STOP
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_macro
name|iblock
argument_list|(
argument|idesc
argument_list|,
argument|ilevel
argument_list|,
argument|isize
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inodesc
modifier|*
name|idesc
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|ilevel
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|long
name|isize
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|daddr_t
modifier|*
name|ap
decl_stmt|;
specifier|register
name|daddr_t
modifier|*
name|aplim
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
argument_list|(
operator|*
name|func
argument_list|)
argument_list|()
decl_stmt|,
name|nif
decl_stmt|;
name|BUFAREA
name|ib
decl_stmt|;
if|if
condition|(
name|idesc
operator|->
name|id_type
operator|==
name|ADDR
condition|)
block|{
name|func
operator|=
name|idesc
operator|->
name|id_func
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|n
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|idesc
argument_list|)
operator|)
operator|&
name|KEEPON
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
block|}
else|else
name|func
operator|=
name|dirscan
expr_stmt|;
if|if
condition|(
name|outrange
argument_list|(
name|idesc
operator|->
name|id_blkno
argument_list|,
name|idesc
operator|->
name|id_numfrags
argument_list|)
condition|)
comment|/* protect thyself */
return|return
operator|(
name|SKIP
operator|)
return|;
name|initbarea
argument_list|(
operator|&
name|ib
argument_list|)
expr_stmt|;
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|ib
argument_list|,
name|idesc
operator|->
name|id_blkno
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|SKIP
operator|)
return|;
name|ilevel
operator|--
expr_stmt|;
if|if
condition|(
name|ilevel
operator|==
literal|0
condition|)
block|{
name|nif
operator|=
name|lblkno
argument_list|(
operator|&
name|sblock
argument_list|,
name|isize
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
comment|/* ilevel == 1 */
block|{
name|nif
operator|=
name|isize
operator|/
operator|(
name|sblock
operator|.
name|fs_bsize
operator|*
name|NINDIR
argument_list|(
operator|&
name|sblock
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nif
operator|>
name|NINDIR
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
name|nif
operator|=
name|NINDIR
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
name|aplim
operator|=
operator|&
name|ib
operator|.
name|b_un
operator|.
name|b_indir
index|[
name|nif
index|]
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|ib
operator|.
name|b_un
operator|.
name|b_indir
operator|,
name|i
operator|=
literal|1
init|;
name|ap
operator|<
name|aplim
condition|;
name|ap
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|ap
condition|)
block|{
name|idesc
operator|->
name|id_blkno
operator|=
operator|*
name|ap
expr_stmt|;
if|if
condition|(
name|ilevel
operator|>
literal|0
condition|)
name|n
operator|=
name|iblock
argument_list|(
name|idesc
argument_list|,
name|ilevel
argument_list|,
name|isize
operator|-
name|i
operator|*
name|NINDIR
argument_list|(
operator|&
name|sblock
argument_list|)
operator|*
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|idesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&
name|STOP
condition|)
return|return
operator|(
name|n
operator|)
return|;
block|}
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_macro
name|outrange
argument_list|(
argument|blk
argument_list|,
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|blk
operator|+
name|cnt
argument_list|)
operator|>
name|fmax
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|c
operator|=
name|dtog
argument_list|(
operator|&
name|sblock
argument_list|,
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|<
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|blk
operator|+
name|cnt
operator|)
operator|>
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"blk %d< cgdmin %d;"
argument_list|,
name|blk
argument_list|,
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" blk+cnt %d> cgsbase %d\n"
argument_list|,
name|blk
operator|+
name|cnt
argument_list|,
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|blk
operator|+
name|cnt
operator|)
operator|>
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
operator|+
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"blk %d>= cgdmin %d;"
argument_list|,
name|blk
argument_list|,
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" blk+cnt %d> sblock.fs_fpg %d\n"
argument_list|,
name|blk
operator|+
name|cnt
argument_list|,
name|sblock
operator|.
name|fs_fpg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|blkerr
argument_list|(
argument|ino
argument_list|,
argument|s
argument_list|,
argument|blk
argument_list|)
end_macro

begin_decl_stmt
name|ino_t
name|ino
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|pfatal
argument_list|(
literal|"%ld %s I=%u"
argument_list|,
name|blk
argument_list|,
name|s
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|statemap
index|[
name|ino
index|]
operator|=
name|CLEAR
expr_stmt|;
block|}
end_block

begin_macro
name|descend
argument_list|(
argument|parentino
argument_list|,
argument|inumber
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inodesc
modifier|*
name|parentino
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|inumber
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
name|struct
name|inodesc
name|curino
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|curino
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inodesc
argument_list|)
argument_list|)
expr_stmt|;
name|statemap
index|[
name|inumber
index|]
operator|=
name|FSTATE
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|(
name|inumber
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dp
operator|->
name|di_size
operator|==
literal|0
condition|)
block|{
name|direrr
argument_list|(
name|inumber
argument_list|,
literal|"ZERO LENGTH DIRECTORY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"REMOVE"
argument_list|)
operator|==
literal|1
condition|)
name|statemap
index|[
name|inumber
index|]
operator|=
name|CLEAR
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dp
operator|->
name|di_size
operator|<
name|MINDIRSIZE
condition|)
block|{
name|direrr
argument_list|(
name|inumber
argument_list|,
literal|"DIRECTORY TOO SHORT"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|di_size
operator|=
name|MINDIRSIZE
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
literal|1
condition|)
name|inodirty
argument_list|()
expr_stmt|;
block|}
name|curino
operator|.
name|id_type
operator|=
name|DATA
expr_stmt|;
name|curino
operator|.
name|id_func
operator|=
name|parentino
operator|->
name|id_func
expr_stmt|;
name|curino
operator|.
name|id_parent
operator|=
name|parentino
operator|->
name|id_number
expr_stmt|;
name|curino
operator|.
name|id_number
operator|=
name|inumber
expr_stmt|;
name|curino
operator|.
name|id_filesize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
operator|(
name|void
operator|)
name|ckinode
argument_list|(
name|dp
argument_list|,
operator|&
name|curino
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|dirscan
argument_list|(
name|idesc
argument_list|)
specifier|register
expr|struct
name|inodesc
operator|*
name|idesc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|DIRECT
modifier|*
name|dp
decl_stmt|;
name|int
name|dsize
decl_stmt|,
name|n
decl_stmt|;
name|long
name|blksiz
decl_stmt|;
name|char
name|dbuf
index|[
name|DIRBLKSIZ
index|]
decl_stmt|;
if|if
condition|(
name|idesc
operator|->
name|id_type
operator|!=
name|DATA
condition|)
name|errexit
argument_list|(
literal|"wrong type to dirscan %d\n"
argument_list|,
name|idesc
operator|->
name|id_type
argument_list|)
expr_stmt|;
name|blksiz
operator|=
name|idesc
operator|->
name|id_numfrags
operator|*
name|sblock
operator|.
name|fs_fsize
expr_stmt|;
if|if
condition|(
name|outrange
argument_list|(
name|idesc
operator|->
name|id_blkno
argument_list|,
name|idesc
operator|->
name|id_numfrags
argument_list|)
condition|)
block|{
name|idesc
operator|->
name|id_filesize
operator|-=
name|blksiz
expr_stmt|;
return|return
operator|(
name|SKIP
operator|)
return|;
block|}
name|idesc
operator|->
name|id_loc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|fsck_readdir
argument_list|(
name|idesc
argument_list|)
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|fsck_readdir
argument_list|(
name|idesc
argument_list|)
control|)
block|{
name|dsize
operator|=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|,
name|dbuf
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|idesc
operator|->
name|id_dirp
operator|=
operator|(
name|DIRECT
operator|*
operator|)
name|dbuf
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
call|(
modifier|*
name|idesc
operator|->
name|id_func
call|)
argument_list|(
name|idesc
argument_list|)
operator|)
operator|&
name|ALTERED
condition|)
block|{
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|fileblk
argument_list|,
name|idesc
operator|->
name|id_blkno
argument_list|,
name|blksiz
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|dbuf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|dirty
argument_list|(
operator|&
name|fileblk
argument_list|)
expr_stmt|;
name|sbdirty
argument_list|()
expr_stmt|;
block|}
else|else
name|n
operator|&=
operator|~
name|ALTERED
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|&
name|STOP
condition|)
return|return
operator|(
name|n
operator|)
return|;
block|}
return|return
operator|(
name|idesc
operator|->
name|id_filesize
operator|>
literal|0
condition|?
name|KEEPON
else|:
name|STOP
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * get next entry in a directory.  */
end_comment

begin_function
name|DIRECT
modifier|*
name|fsck_readdir
parameter_list|(
name|idesc
parameter_list|)
specifier|register
name|struct
name|inodesc
modifier|*
name|idesc
decl_stmt|;
block|{
specifier|register
name|DIRECT
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ndp
decl_stmt|;
name|long
name|size
decl_stmt|,
name|blksiz
decl_stmt|;
name|blksiz
operator|=
name|idesc
operator|->
name|id_numfrags
operator|*
name|sblock
operator|.
name|fs_fsize
expr_stmt|;
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|fileblk
argument_list|,
name|idesc
operator|->
name|id_blkno
argument_list|,
name|blksiz
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|idesc
operator|->
name|id_filesize
operator|-=
name|blksiz
operator|-
name|idesc
operator|->
name|id_loc
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|idesc
operator|->
name|id_loc
operator|%
name|DIRBLKSIZ
operator|==
literal|0
operator|&&
name|idesc
operator|->
name|id_filesize
operator|>
literal|0
operator|&&
name|idesc
operator|->
name|id_loc
operator|<
name|blksiz
condition|)
block|{
name|dp
operator|=
operator|(
name|DIRECT
operator|*
operator|)
operator|(
name|dirblk
operator|.
name|b_buf
operator|+
name|idesc
operator|->
name|id_loc
operator|)
expr_stmt|;
if|if
condition|(
name|dircheck
argument_list|(
name|idesc
argument_list|,
name|dp
argument_list|)
condition|)
goto|goto
name|dpok
goto|;
name|idesc
operator|->
name|id_loc
operator|+=
name|DIRBLKSIZ
expr_stmt|;
name|idesc
operator|->
name|id_filesize
operator|-=
name|DIRBLKSIZ
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|DIRBLKSIZ
expr_stmt|;
name|dp
operator|->
name|d_ino
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dofix
argument_list|(
name|idesc
argument_list|)
condition|)
name|dirty
argument_list|(
operator|&
name|fileblk
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
name|dpok
label|:
if|if
condition|(
name|idesc
operator|->
name|id_filesize
operator|<=
literal|0
operator|||
name|idesc
operator|->
name|id_loc
operator|>=
name|blksiz
condition|)
return|return
name|NULL
return|;
name|dp
operator|=
operator|(
name|DIRECT
operator|*
operator|)
operator|(
name|dirblk
operator|.
name|b_buf
operator|+
name|idesc
operator|->
name|id_loc
operator|)
expr_stmt|;
name|idesc
operator|->
name|id_loc
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|idesc
operator|->
name|id_filesize
operator|-=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|ndp
operator|=
operator|(
name|DIRECT
operator|*
operator|)
operator|(
name|dirblk
operator|.
name|b_buf
operator|+
name|idesc
operator|->
name|id_loc
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|idesc
operator|->
name|id_filesize
operator|<=
literal|0
operator|&&
name|idesc
operator|->
name|id_loc
operator|%
name|DIRBLKSIZ
operator|!=
literal|0
operator|)
operator|||
operator|(
name|idesc
operator|->
name|id_loc
operator|<
name|blksiz
operator|&&
name|idesc
operator|->
name|id_filesize
operator|>
literal|0
operator|&&
name|dircheck
argument_list|(
name|idesc
argument_list|,
name|ndp
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|size
operator|=
name|DIRBLKSIZ
operator|-
operator|(
name|idesc
operator|->
name|id_loc
operator|%
name|DIRBLKSIZ
operator|)
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|+=
name|size
expr_stmt|;
name|idesc
operator|->
name|id_loc
operator|+=
name|size
expr_stmt|;
name|idesc
operator|->
name|id_filesize
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|dofix
argument_list|(
name|idesc
argument_list|)
condition|)
name|dirty
argument_list|(
operator|&
name|fileblk
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that a directory entry is valid.  * This is a superset of the checks made in the kernel.  */
end_comment

begin_macro
name|dircheck
argument_list|(
argument|idesc
argument_list|,
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inodesc
modifier|*
name|idesc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|DIRECT
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|spaceleft
decl_stmt|;
name|size
operator|=
name|DIRSIZ
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|spaceleft
operator|=
name|DIRBLKSIZ
operator|-
operator|(
name|idesc
operator|->
name|id_loc
operator|%
name|DIRBLKSIZ
operator|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|<
name|imax
operator|&&
name|dp
operator|->
name|d_reclen
operator|!=
literal|0
operator|&&
name|dp
operator|->
name|d_reclen
operator|<=
name|spaceleft
operator|&&
operator|(
name|dp
operator|->
name|d_reclen
operator|&
literal|0x3
operator|)
operator|==
literal|0
operator|&&
name|dp
operator|->
name|d_reclen
operator|>=
name|size
operator|&&
name|idesc
operator|->
name|id_filesize
operator|>=
name|size
operator|&&
name|dp
operator|->
name|d_namlen
operator|<=
name|MAXNAMLEN
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|cp
operator|=
name|dp
operator|->
name|d_name
operator|,
name|size
operator|=
literal|0
init|;
name|size
operator|<
name|dp
operator|->
name|d_namlen
condition|;
name|size
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
operator|||
operator|(
operator|*
name|cp
operator|++
operator|&
literal|0200
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|direrr
argument_list|(
argument|ino
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|ino_t
name|ino
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
name|pwarn
argument_list|(
literal|"%s "
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|pinode
argument_list|(
name|ino
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|(
name|ino
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|ftypeok
argument_list|(
name|dp
argument_list|)
condition|)
name|pfatal
argument_list|(
literal|"%s=%s\n"
argument_list|,
name|DIRCT
condition|?
literal|"DIR"
else|:
literal|"FILE"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
else|else
name|pfatal
argument_list|(
literal|"NAME=%s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|adjust
argument_list|(
name|idesc
argument_list|,
name|lcnt
argument_list|)
specifier|register
expr|struct
name|inodesc
operator|*
name|idesc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|short
name|lcnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|(
name|idesc
operator|->
name|id_number
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dp
operator|->
name|di_nlink
operator|==
name|lcnt
condition|)
block|{
if|if
condition|(
name|linkup
argument_list|(
name|idesc
operator|->
name|id_number
argument_list|,
operator|(
name|ino_t
operator|)
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|clri
argument_list|(
name|idesc
argument_list|,
literal|"UNREF"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pwarn
argument_list|(
literal|"LINK COUNT %s"
argument_list|,
operator|(
name|lfdir
operator|==
name|idesc
operator|->
name|id_number
operator|)
condition|?
name|lfname
else|:
operator|(
name|DIRCT
condition|?
literal|"DIR"
else|:
literal|"FILE"
operator|)
argument_list|)
expr_stmt|;
name|pinode
argument_list|(
name|idesc
operator|->
name|id_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" COUNT %d SHOULD BE %d"
argument_list|,
name|dp
operator|->
name|di_nlink
argument_list|,
name|dp
operator|->
name|di_nlink
operator|-
name|lcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
block|{
if|if
condition|(
name|lcnt
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|preendie
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" (ADJUSTED)\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preen
operator|||
name|reply
argument_list|(
literal|"ADJUST"
argument_list|)
operator|==
literal|1
condition|)
block|{
name|dp
operator|->
name|di_nlink
operator|-=
name|lcnt
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|clri
argument_list|(
name|idesc
argument_list|,
name|s
argument_list|,
name|flg
argument_list|)
specifier|register
expr|struct
name|inodesc
operator|*
name|idesc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|(
name|idesc
operator|->
name|id_number
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|flg
operator|==
literal|1
condition|)
block|{
name|pwarn
argument_list|(
literal|"%s %s"
argument_list|,
name|s
argument_list|,
name|DIRCT
condition|?
literal|"DIR"
else|:
literal|"FILE"
argument_list|)
expr_stmt|;
name|pinode
argument_list|(
name|idesc
operator|->
name|id_number
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preen
operator|||
name|reply
argument_list|(
literal|"CLEAR"
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (CLEARED)\n"
argument_list|)
expr_stmt|;
name|n_files
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|ckinode
argument_list|(
name|dp
argument_list|,
name|idesc
argument_list|)
expr_stmt|;
name|zapino
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|statemap
index|[
name|idesc
operator|->
name|id_number
index|]
operator|=
name|USTATE
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|inosumbad
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|badsb
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BAD SUPER BLOCK: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|pwarn
argument_list|(
literal|"USE -b OPTION TO FSCK TO SPECIFY LOCATION OF AN ALTERNATE\n"
argument_list|)
expr_stmt|;
name|pfatal
argument_list|(
literal|"SUPER-BLOCK TO SUPPLY NEEDED INFORMATION; SEE fsck(8).\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|DINODE
modifier|*
name|ginode
parameter_list|(
name|inumber
parameter_list|)
name|ino_t
name|inumber
decl_stmt|;
block|{
name|daddr_t
name|iblk
decl_stmt|;
specifier|static
name|ino_t
name|startinum
init|=
literal|0
decl_stmt|;
comment|/* blk num of first in raw area */
if|if
condition|(
name|inumber
operator|<
name|ROOTINO
operator|||
name|inumber
operator|>
name|imax
condition|)
block|{
if|if
condition|(
name|debug
operator|&&
name|inumber
operator|>
name|imax
condition|)
name|printf
argument_list|(
literal|"inumber out of range (%d)\n"
argument_list|,
name|inumber
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|startinum
operator|==
literal|0
operator|||
name|inumber
operator|<
name|startinum
operator|||
name|inumber
operator|>=
name|startinum
operator|+
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
block|{
name|iblk
operator|=
name|itod
argument_list|(
operator|&
name|sblock
argument_list|,
name|inumber
argument_list|)
expr_stmt|;
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|inoblk
argument_list|,
name|iblk
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|startinum
operator|=
operator|(
name|inumber
operator|/
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
operator|)
operator|*
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|inoblk
operator|.
name|b_un
operator|.
name|b_dinode
index|[
name|inumber
operator|%
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_macro
name|ftypeok
argument_list|(
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|DINODE
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|dp
operator|->
name|di_mode
operator|&
name|IFMT
condition|)
block|{
case|case
name|IFDIR
case|:
case|case
name|IFREG
case|:
case|case
name|IFBLK
case|:
case|case
name|IFCHR
case|:
case|case
name|IFLNK
case|:
case|case
name|IFSOCK
case|:
return|return
operator|(
literal|1
operator|)
return|;
default|default:
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"bad file type 0%o\n"
argument_list|,
name|dp
operator|->
name|di_mode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|reply
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|preen
condition|)
name|pfatal
argument_list|(
literal|"INTERNAL ERROR: GOT TO reply()"
argument_list|)
expr_stmt|;
name|rplyflag
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s? "
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
operator|||
name|dfile
operator|.
name|wfdes
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" no\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|yflag
condition|)
block|{
name|printf
argument_list|(
literal|" yes\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|getline
argument_list|(
name|stdin
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
operator|==
name|EOF
condition|)
name|errexit
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'y'
operator|||
name|line
index|[
literal|0
index|]
operator|==
literal|'Y'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|getline
argument_list|(
argument|fp
argument_list|,
argument|loc
argument_list|,
argument|maxlen
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|lastloc
decl_stmt|;
name|p
operator|=
name|loc
expr_stmt|;
name|lastloc
operator|=
operator|&
name|p
index|[
name|maxlen
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|n
argument_list|)
operator|&&
name|p
operator|<
name|lastloc
condition|)
operator|*
name|p
operator|++
operator|=
name|n
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|p
operator|-
name|loc
operator|)
return|;
block|}
end_block

begin_function
name|BUFAREA
modifier|*
name|getblk
parameter_list|(
name|bp
parameter_list|,
name|blk
parameter_list|,
name|size
parameter_list|)
specifier|register
name|BUFAREA
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
specifier|register
name|struct
name|filecntl
modifier|*
name|fcp
decl_stmt|;
name|daddr_t
name|dblk
decl_stmt|;
name|fcp
operator|=
operator|&
name|dfile
expr_stmt|;
name|dblk
operator|=
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bno
operator|==
name|dblk
condition|)
return|return
operator|(
name|bp
operator|)
return|;
name|flush
argument_list|(
name|fcp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
name|fcp
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_buf
argument_list|,
name|dblk
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_bno
operator|=
name|dblk
expr_stmt|;
name|bp
operator|->
name|b_size
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
name|bp
operator|->
name|b_bno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_macro
name|flush
argument_list|(
argument|fcp
argument_list|,
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|filecntl
modifier|*
name|fcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|BUFAREA
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|bp
operator|->
name|b_dirty
condition|)
operator|(
name|void
operator|)
name|bwrite
argument_list|(
name|fcp
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_buf
argument_list|,
name|bp
operator|->
name|b_bno
argument_list|,
operator|(
name|long
operator|)
name|bp
operator|->
name|b_size
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dirty
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|rwerr
argument_list|(
argument|s
argument_list|,
argument|blk
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|pfatal
argument_list|(
literal|"CANNOT %s: BLK %ld"
argument_list|,
name|s
argument_list|,
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|"Program terminated\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ckfini
argument_list|()
end_macro

begin_block
block|{
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|fileblk
argument_list|)
expr_stmt|;
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|sblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|.
name|b_bno
operator|!=
name|SBLOCK
condition|)
block|{
name|sblk
operator|.
name|b_bno
operator|=
name|SBLOCK
expr_stmt|;
name|sbdirty
argument_list|()
expr_stmt|;
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|sblk
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|inoblk
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|dfile
operator|.
name|rfdes
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|dfile
operator|.
name|wfdes
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pinode
argument_list|(
argument|ino
argument_list|)
end_macro

begin_decl_stmt
name|ino_t
name|ino
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|uidbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|" I=%u "
argument_list|,
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|(
name|ino
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|printf
argument_list|(
literal|" OWNER="
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpw
argument_list|(
operator|(
name|int
operator|)
name|dp
operator|->
name|di_uid
argument_list|,
name|uidbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
name|uidbuf
init|;
operator|*
name|p
operator|!=
literal|':'
condition|;
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|uidbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|dp
operator|->
name|di_uid
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"MODE=%o\n"
argument_list|,
name|dp
operator|->
name|di_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SIZE=%ld "
argument_list|,
name|dp
operator|->
name|di_size
argument_list|)
expr_stmt|;
name|p
operator|=
name|ctime
argument_list|(
operator|&
name|dp
operator|->
name|di_mtime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MTIME=%12.12s %4.4s "
argument_list|,
name|p
operator|+
literal|4
argument_list|,
name|p
operator|+
literal|20
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|makecg
argument_list|()
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|,
name|blk
decl_stmt|;
name|daddr_t
name|dbase
decl_stmt|,
name|d
decl_stmt|,
name|dlower
decl_stmt|,
name|dupper
decl_stmt|,
name|dmax
decl_stmt|;
name|long
name|i
decl_stmt|,
name|j
decl_stmt|,
name|s
decl_stmt|;
name|ino_t
name|inumber
decl_stmt|;
specifier|register
name|struct
name|csum
modifier|*
name|cs
decl_stmt|;
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nifree
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_ndir
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|c
operator|++
control|)
block|{
name|dbase
operator|=
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|dmax
operator|=
name|dbase
operator|+
name|sblock
operator|.
name|fs_fpg
expr_stmt|;
if|if
condition|(
name|dmax
operator|>
name|sblock
operator|.
name|fs_size
condition|)
block|{
for|for
control|(
init|;
name|dmax
operator|>=
name|sblock
operator|.
name|fs_size
condition|;
name|dmax
operator|--
control|)
name|clrbit
argument_list|(
name|cgrp
operator|.
name|cg_free
argument_list|,
name|dmax
operator|-
name|dbase
argument_list|)
expr_stmt|;
name|dmax
operator|++
expr_stmt|;
block|}
name|dlower
operator|=
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
operator|-
name|dbase
expr_stmt|;
name|dupper
operator|=
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
operator|-
name|dbase
expr_stmt|;
name|cs
operator|=
operator|&
name|sblock
operator|.
name|fs_cs
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|cgrp
operator|.
name|cg_time
argument_list|)
expr_stmt|;
name|cgrp
operator|.
name|cg_magic
operator|=
name|CG_MAGIC
expr_stmt|;
name|cgrp
operator|.
name|cg_cgx
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
condition|)
name|cgrp
operator|.
name|cg_ncyl
operator|=
name|sblock
operator|.
name|fs_ncyl
operator|%
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
else|else
name|cgrp
operator|.
name|cg_ncyl
operator|=
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
name|cgrp
operator|.
name|cg_niblk
operator|=
name|sblock
operator|.
name|fs_ipg
expr_stmt|;
name|cgrp
operator|.
name|cg_ndblk
operator|=
name|dmax
operator|-
name|dbase
expr_stmt|;
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_ndir
operator|=
literal|0
expr_stmt|;
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|=
literal|0
expr_stmt|;
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|=
literal|0
expr_stmt|;
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|=
literal|0
expr_stmt|;
name|cgrp
operator|.
name|cg_rotor
operator|=
literal|0
expr_stmt|;
name|cgrp
operator|.
name|cg_frotor
operator|=
literal|0
expr_stmt|;
name|cgrp
operator|.
name|cg_irotor
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_frag
condition|;
name|i
operator|++
control|)
name|cgrp
operator|.
name|cg_frsum
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|inumber
operator|=
name|sblock
operator|.
name|fs_ipg
operator|*
name|c
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_ipg
condition|;
name|inumber
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|++
expr_stmt|;
name|clrbit
argument_list|(
name|cgrp
operator|.
name|cg_iused
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dp
operator|=
name|ginode
argument_list|(
name|inumber
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|ALLOC
condition|)
block|{
if|if
condition|(
name|DIRCT
condition|)
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_ndir
operator|++
expr_stmt|;
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|--
expr_stmt|;
name|setbit
argument_list|(
name|cgrp
operator|.
name|cg_iused
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
while|while
condition|(
name|i
operator|<
name|MAXIPG
condition|)
block|{
name|clrbit
argument_list|(
name|cgrp
operator|.
name|cg_iused
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ROOTINO
condition|;
name|i
operator|++
control|)
block|{
name|setbit
argument_list|(
name|cgrp
operator|.
name|cg_iused
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|--
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|MAXCPG
condition|;
name|s
operator|++
control|)
block|{
name|cgrp
operator|.
name|cg_btot
index|[
name|s
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRPOS
condition|;
name|i
operator|++
control|)
name|cgrp
operator|.
name|cg_b
index|[
name|s
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|dupper
operator|+=
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|d
operator|=
name|dlower
init|;
name|d
operator|<
name|dupper
condition|;
name|d
operator|++
control|)
name|clrbit
argument_list|(
name|cgrp
operator|.
name|cg_free
argument_list|,
name|d
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
literal|0
init|;
operator|(
name|d
operator|+
name|sblock
operator|.
name|fs_frag
operator|)
operator|<=
name|dmax
operator|-
name|dbase
condition|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_frag
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|getbmap
argument_list|(
name|dbase
operator|+
name|d
operator|+
name|i
argument_list|)
condition|)
block|{
name|setbit
argument_list|(
name|cgrp
operator|.
name|cg_free
argument_list|,
name|d
operator|+
name|i
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
else|else
name|clrbit
argument_list|(
name|cgrp
operator|.
name|cg_free
argument_list|,
name|d
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
name|sblock
operator|.
name|fs_frag
condition|)
block|{
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|cgrp
operator|.
name|cg_btot
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|++
expr_stmt|;
name|cgrp
operator|.
name|cg_b
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|+=
name|j
expr_stmt|;
name|blk
operator|=
name|blkmap
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgrp
operator|.
name|cg_free
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|fragacct
argument_list|(
operator|&
name|sblock
argument_list|,
name|blk
argument_list|,
name|cgrp
operator|.
name|cg_frsum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
name|d
init|;
name|d
operator|<
name|dmax
operator|-
name|dbase
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|getbmap
argument_list|(
name|dbase
operator|+
name|d
argument_list|)
condition|)
block|{
name|setbit
argument_list|(
name|cgrp
operator|.
name|cg_free
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
else|else
name|clrbit
argument_list|(
name|cgrp
operator|.
name|cg_free
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|d
operator|%
name|sblock
operator|.
name|fs_frag
operator|!=
literal|0
condition|;
name|d
operator|++
control|)
name|clrbit
argument_list|(
name|cgrp
operator|.
name|cg_free
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|d
condition|)
block|{
name|blk
operator|=
name|blkmap
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgrp
operator|.
name|cg_free
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fragacct
argument_list|(
operator|&
name|sblock
argument_list|,
name|blk
argument_list|,
name|cgrp
operator|.
name|cg_frsum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|d
operator|/=
name|sblock
operator|.
name|fs_frag
init|;
name|d
operator|<
name|MAXBPG
argument_list|(
operator|&
name|sblock
argument_list|)
condition|;
name|d
operator|++
control|)
name|clrblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgrp
operator|.
name|cg_free
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|+=
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nffree
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|+=
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nbfree
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nifree
operator|+=
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nifree
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_ndir
operator|+=
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_ndir
expr_stmt|;
operator|*
name|cs
operator|=
name|cgrp
operator|.
name|cg_cs
expr_stmt|;
operator|(
name|void
operator|)
name|bwrite
argument_list|(
operator|&
name|dfile
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cgrp
argument_list|,
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_cgsize
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_cssize
condition|;
name|i
operator|+=
name|sblock
operator|.
name|fs_bsize
operator|,
name|j
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|bwrite
argument_list|(
operator|&
name|dfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sblock
operator|.
name|fs_csp
index|[
name|j
index|]
argument_list|,
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_csaddr
operator|+
name|j
operator|*
name|sblock
operator|.
name|fs_frag
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_cssize
operator|-
name|i
operator|<
name|sblock
operator|.
name|fs_bsize
condition|?
name|sblock
operator|.
name|fs_cssize
operator|-
name|i
else|:
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_ronly
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_fmod
operator|=
literal|0
expr_stmt|;
name|sbdirty
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|findino
argument_list|(
argument|idesc
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inodesc
modifier|*
name|idesc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DIRECT
modifier|*
name|dirp
init|=
name|idesc
operator|->
name|id_dirp
decl_stmt|;
if|if
condition|(
name|dirp
operator|->
name|d_ino
operator|==
literal|0
condition|)
return|return
operator|(
name|KEEPON
operator|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|,
name|srchname
argument_list|)
condition|)
block|{
if|if
condition|(
name|dirp
operator|->
name|d_ino
operator|>=
name|ROOTINO
operator|&&
name|dirp
operator|->
name|d_ino
operator|<=
name|imax
condition|)
name|idesc
operator|->
name|id_parent
operator|=
name|dirp
operator|->
name|d_ino
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_macro
name|mkentry
argument_list|(
argument|idesc
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inodesc
modifier|*
name|idesc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DIRECT
modifier|*
name|dirp
init|=
name|idesc
operator|->
name|id_dirp
decl_stmt|;
name|DIRECT
name|newent
decl_stmt|;
name|int
name|newlen
decl_stmt|,
name|oldlen
decl_stmt|;
name|newent
operator|.
name|d_namlen
operator|=
literal|11
expr_stmt|;
name|newlen
operator|=
name|DIRSIZ
argument_list|(
operator|&
name|newent
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|->
name|d_ino
operator|!=
literal|0
condition|)
name|oldlen
operator|=
name|DIRSIZ
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
else|else
name|oldlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dirp
operator|->
name|d_reclen
operator|-
name|oldlen
operator|<
name|newlen
condition|)
return|return
operator|(
name|KEEPON
operator|)
return|;
name|newent
operator|.
name|d_reclen
operator|=
name|dirp
operator|->
name|d_reclen
operator|-
name|oldlen
expr_stmt|;
name|dirp
operator|->
name|d_reclen
operator|=
name|oldlen
expr_stmt|;
name|dirp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|dirp
operator|)
operator|+
name|oldlen
operator|)
expr_stmt|;
name|dirp
operator|->
name|d_ino
operator|=
name|idesc
operator|->
name|id_parent
expr_stmt|;
comment|/* ino to be entered is in id_parent */
name|dirp
operator|->
name|d_reclen
operator|=
name|newent
operator|.
name|d_reclen
expr_stmt|;
name|dirp
operator|->
name|d_namlen
operator|=
name|lftempname
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|,
name|idesc
operator|->
name|id_parent
argument_list|)
expr_stmt|;
return|return
operator|(
name|ALTERED
operator||
name|STOP
operator|)
return|;
block|}
end_block

begin_macro
name|chgdd
argument_list|(
argument|idesc
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inodesc
modifier|*
name|idesc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DIRECT
modifier|*
name|dirp
init|=
name|idesc
operator|->
name|id_dirp
decl_stmt|;
if|if
condition|(
name|dirp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dirp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|dirp
operator|->
name|d_name
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|dirp
operator|->
name|d_ino
operator|=
name|lfdir
expr_stmt|;
return|return
operator|(
name|ALTERED
operator||
name|STOP
operator|)
return|;
block|}
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_macro
name|linkup
argument_list|(
argument|orphan
argument_list|,
argument|pdir
argument_list|)
end_macro

begin_decl_stmt
name|ino_t
name|orphan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|pdir
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
name|int
name|lostdir
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|inodesc
name|idesc
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|idesc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inodesc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|(
name|orphan
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lostdir
operator|=
name|DIRCT
expr_stmt|;
name|pwarn
argument_list|(
literal|"UNREF %s "
argument_list|,
name|lostdir
condition|?
literal|"DIR"
else|:
literal|"FILE"
argument_list|)
expr_stmt|;
name|pinode
argument_list|(
name|orphan
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
operator|&&
name|dp
operator|->
name|di_size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (RECONNECTED)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reply
argument_list|(
literal|"RECONNECT"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pathp
operator|=
name|pathname
expr_stmt|;
operator|*
name|pathp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|pathp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|lfdir
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|(
name|ROOTINO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|srchname
operator|=
name|lfname
expr_stmt|;
name|idesc
operator|.
name|id_type
operator|=
name|DATA
expr_stmt|;
name|idesc
operator|.
name|id_func
operator|=
name|findino
expr_stmt|;
name|idesc
operator|.
name|id_number
operator|=
name|ROOTINO
expr_stmt|;
name|idesc
operator|.
name|id_filesize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
operator|(
name|void
operator|)
name|ckinode
argument_list|(
name|dp
argument_list|,
operator|&
name|idesc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lfdir
operator|=
name|idesc
operator|.
name|id_parent
operator|)
operator|==
literal|0
condition|)
block|{
name|pfatal
argument_list|(
literal|"SORRY. NO lost+found DIRECTORY"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|(
name|lfdir
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|!
name|DIRCT
operator|||
name|statemap
index|[
name|lfdir
index|]
operator|!=
name|FSTATE
condition|)
block|{
name|pfatal
argument_list|(
literal|"SORRY. NO lost+found DIRECTORY"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|fragoff
argument_list|(
operator|&
name|sblock
argument_list|,
name|dp
operator|->
name|di_size
argument_list|)
condition|)
block|{
name|dp
operator|->
name|di_size
operator|=
name|fragroundup
argument_list|(
operator|&
name|sblock
argument_list|,
name|dp
operator|->
name|di_size
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|lfname
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|lfname
argument_list|,
name|pathp
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pathp
operator|+=
name|len
expr_stmt|;
name|idesc
operator|.
name|id_type
operator|=
name|DATA
expr_stmt|;
name|idesc
operator|.
name|id_func
operator|=
name|mkentry
expr_stmt|;
name|idesc
operator|.
name|id_number
operator|=
name|lfdir
expr_stmt|;
name|idesc
operator|.
name|id_filesize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
name|idesc
operator|.
name|id_parent
operator|=
name|orphan
expr_stmt|;
comment|/* this is the inode to enter */
name|idesc
operator|.
name|id_fix
operator|=
name|DONTKNOW
expr_stmt|;
if|if
condition|(
operator|(
name|ckinode
argument_list|(
name|dp
argument_list|,
operator|&
name|idesc
argument_list|)
operator|&
name|ALTERED
operator|)
operator|==
literal|0
condition|)
block|{
name|pfatal
argument_list|(
literal|"SORRY. NO SPACE IN lost+found DIRECTORY"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|lncntp
index|[
name|orphan
index|]
operator|--
expr_stmt|;
operator|*
name|pathp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|pathp
operator|+=
name|lftempname
argument_list|(
name|pathp
argument_list|,
name|orphan
argument_list|)
expr_stmt|;
if|if
condition|(
name|lostdir
condition|)
block|{
name|dp
operator|=
name|ginode
argument_list|(
name|orphan
argument_list|)
expr_stmt|;
name|idesc
operator|.
name|id_type
operator|=
name|DATA
expr_stmt|;
name|idesc
operator|.
name|id_func
operator|=
name|chgdd
expr_stmt|;
name|idesc
operator|.
name|id_number
operator|=
name|orphan
expr_stmt|;
name|idesc
operator|.
name|id_filesize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
name|idesc
operator|.
name|id_fix
operator|=
name|DONTKNOW
expr_stmt|;
operator|(
name|void
operator|)
name|ckinode
argument_list|(
name|dp
argument_list|,
operator|&
name|idesc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|(
name|lfdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dp
operator|->
name|di_nlink
operator|++
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|lncntp
index|[
name|lfdir
index|]
operator|++
expr_stmt|;
block|}
name|pwarn
argument_list|(
literal|"DIR I=%u CONNECTED. "
argument_list|,
name|orphan
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PARENT WAS I=%u\n"
argument_list|,
name|pdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * generate a temporary name for the lost+found directory.  */
end_comment

begin_macro
name|lftempname
argument_list|(
argument|bufp
argument_list|,
argument|ino
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|bufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|ino
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ino_t
name|in
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|namlen
decl_stmt|;
name|cp
operator|=
name|bufp
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|in
operator|=
name|imax
init|;
name|in
operator|>
literal|0
condition|;
name|in
operator|/=
literal|10
control|)
name|cp
operator|++
expr_stmt|;
operator|*
operator|--
name|cp
operator|=
literal|0
expr_stmt|;
name|namlen
operator|=
name|cp
operator|-
name|bufp
expr_stmt|;
name|in
operator|=
name|ino
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|bufp
condition|)
block|{
operator|*
operator|--
name|cp
operator|=
operator|(
name|in
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|in
operator|/=
literal|10
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'#'
expr_stmt|;
return|return
operator|(
name|namlen
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|bread
argument_list|(
name|fcp
argument_list|,
name|buf
argument_list|,
name|blk
argument_list|,
name|size
argument_list|)
specifier|register
expr|struct
name|filecntl
operator|*
name|fcp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|lseek
argument_list|(
name|fcp
operator|->
name|rfdes
argument_list|,
operator|(
name|long
operator|)
name|dbtob
argument_list|(
name|blk
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|rwerr
argument_list|(
literal|"SEEK"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|read
argument_list|(
name|fcp
operator|->
name|rfdes
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|)
operator|==
name|size
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|rwerr
argument_list|(
literal|"READ"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|bwrite
argument_list|(
name|fcp
argument_list|,
name|buf
argument_list|,
name|blk
argument_list|,
name|size
argument_list|)
specifier|register
expr|struct
name|filecntl
operator|*
name|fcp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fcp
operator|->
name|wfdes
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lseek
argument_list|(
name|fcp
operator|->
name|wfdes
argument_list|,
operator|(
name|long
operator|)
name|dbtob
argument_list|(
name|blk
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|rwerr
argument_list|(
literal|"SEEK"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|write
argument_list|(
name|fcp
operator|->
name|wfdes
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|)
operator|==
name|size
condition|)
block|{
name|fcp
operator|->
name|mod
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rwerr
argument_list|(
literal|"WRITE"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|catch
argument_list|()
end_macro

begin_block
block|{
name|ckfini
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|unrawname
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|char
modifier|*
name|dp
init|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
if|if
condition|(
name|dp
operator|==
literal|0
condition|)
return|return
operator|(
name|cp
operator|)
return|;
if|if
condition|(
name|stat
argument_list|(
name|cp
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|cp
operator|)
return|;
if|if
condition|(
operator|(
name|stb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFCHR
condition|)
return|return
operator|(
name|cp
operator|)
return|;
if|if
condition|(
operator|*
operator|(
name|dp
operator|+
literal|1
operator|)
operator|!=
literal|'r'
condition|)
return|return
operator|(
name|cp
operator|)
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|+
literal|1
argument_list|,
name|dp
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|rawname
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|static
name|char
name|rawbuf
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|dp
init|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|dp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|rawbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|=
literal|'/'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|rawbuf
argument_list|,
literal|"/r"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|rawbuf
argument_list|,
name|dp
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|rawbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * determine whether an inode should be fixed.  */
end_comment

begin_expr_stmt
name|dofix
argument_list|(
name|idesc
argument_list|)
specifier|register
expr|struct
name|inodesc
operator|*
name|idesc
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|idesc
operator|->
name|id_fix
condition|)
block|{
case|case
name|DONTKNOW
case|:
name|direrr
argument_list|(
name|idesc
operator|->
name|id_number
argument_list|,
literal|"DIRECTORY CORRUPTED"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"SALVAGE"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|idesc
operator|->
name|id_fix
operator|=
name|NOFIX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|idesc
operator|->
name|id_fix
operator|=
name|FIX
expr_stmt|;
return|return
operator|(
name|ALTERED
operator|)
return|;
case|case
name|FIX
case|:
return|return
operator|(
name|ALTERED
operator|)
return|;
case|case
name|NOFIX
case|:
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|errexit
argument_list|(
literal|"UNKNOWN INODESC FIX MODE %d\n"
argument_list|,
name|idesc
operator|->
name|id_fix
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|error
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|,
argument|s3
argument_list|,
argument|s4
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|,
name|s4
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|errexit
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|,
argument|s3
argument_list|,
argument|s4
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|error
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|,
name|s4
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * An inconsistency occured which shouldn't during normal operations.  * Die if preening, otherwise just printf.  */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|pfatal
argument_list|(
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|preen
condition|)
block|{
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|preendie
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|preendie
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"%s: UNEXPECTED INCONSISTENCY; RUN fsck MANUALLY.\n"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Pwarn is like printf when not preening,  * or a warning (preceded by filename) when preening.  */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|pwarn
argument_list|(
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_comment
comment|/*  * Stub for routines from kernel.  */
end_comment

begin_macro
name|panic
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|pfatal
argument_list|(
literal|"INTERNAL INCONSISTENCY: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

