begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Font description file producer for imagen fonts:  David Slattengren  * Taken from vfontinfo by Andy Hertzfeld  4/79  *  *	Use:  mifnt [ -nNAME ]  [ -smial ]  [ "-xs1,s2[;s1,s2...]" ]  *		[ "-ys1,s2[;s1,s2...]" ]  [ -p# ]  [ -r# ]  [ -ddir ]  font  *  *	Mkfnt takes the font named "font" and produces a ditroff description  *	file from it.  The -n option takes the 1 or 2 letter troff name to put  *	the description (default = XX).  The -s, -m, -i, -a options select a  *	different character mapping than for a "roman" font.  s = special;  *	m = math;  i = italics;  a = ascii.  The -l option tells if the font  *	has ligatures.  *  *	Both -x and -y options allow character name mapping.  A semi-colon  *	separated list of comma-separated character-name pairs follows the  *	x or y.  Notice that there are no spaces in the -x or -y command.  It  *	is also IMPORTANT to enclose these arguments in single quotes to stop  *	the cshell from interpretting the contents.  A -x pair REPLACES the  *	definition for s1 by s2.  A -y pair creates a synonym for s1 and calls  *	it s2.  -x and -y MUST be sent after -s, -m, -i, or -a  if one of them  *	is used.  Some synonyms are defaulted.  To remove a synonym or char-  *	acter, leave out s2.  *  *	The -p# option tells what point size the DESC file has  *	as it's "unitwidth" argument (default: 40).  The -r# option is the  *	resolution of the device (default: 240, in units/inch).  The -d option  *	tells where to find fonts (default: /usr/src/local/imagen/fonts/raster).  */
end_comment

begin_comment
comment|/*  *  Here's an ascii character set, just in case you need it:       | 00 nul| 01 soh| 02 stx| 03 etx| 04 eot| 05 enq| 06 ack| 07 bel|      | 08 bs | 09 ht | 0a nl | 0b vt | 0c np | 0d cr | 0e so | 0f si |      | 10 dle| 11 dc1| 12 dc2| 13 dc3| 14 dc4| 15 nak| 16 syn| 17 etb|      | 18 can| 19 em | 1a sub| 1b esc| 1c fs | 1d gs | 1e rs | 1f us |      | 20 sp | 21  ! | 22  " | 23  # | 24  $ | 25  % | 26& | 27  ' |      | 28  ( | 29  ) | 2a  * | 2b  + | 2c  , | 2d  - | 2e  . | 2f  / |      | 30  0 | 31  1 | 32  2 | 33  3 | 34  4 | 35  5 | 36  6 | 37  7 |      | 38  8 | 39  9 | 3a  : | 3b  ; | 3c< | 3d  = | 3e> | 3f  ? |      | 40  @ | 41  A | 42  B | 43  C | 44  D | 45  E | 46  F | 47  G |      | 48  H | 49  I | 4a  J | 4b  K | 4c  L | 4d  M | 4e  N | 4f  O |      | 50  P | 51  Q | 52  R | 53  S | 54  T | 55  U | 56  V | 57  W |      | 58  X | 59  Y | 5a  Z | 5b  [ | 5c  \ | 5d  ] | 5e  ^ | 5f  _ |      | 60  ` | 61  a | 62  b | 63  c | 64  d | 65  e | 66  f | 67  g |      | 68  h | 69  i | 6a  j | 6b  k | 6c  l | 6d  m | 6e  n | 6f  o |      | 70  p | 71  q | 72  r | 73  s | 74  t | 75  u | 76  v | 77  w |      | 78  x | 79  y | 7a  z | 7b  { | 7c  | | 7d  } | 7e  ~ | 7f del|   *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"rst.h"
end_include

begin_decl_stmt
name|char
name|sccsid
index|[]
init|=
literal|"@(#)makeifont.c	1.3	(Berkeley)	%G%"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PCNTUP
value|62
end_define

begin_comment
comment|/* percent of maximum height for an ascender */
end_comment

begin_define
define|#
directive|define
name|PCNTDOWN
value|73
end_define

begin_comment
comment|/* percent of maximum droop for a descender */
end_comment

begin_define
define|#
directive|define
name|FONTDIR
value|"/usr/src/local/imagen/fonts/raster"
end_define

begin_define
define|#
directive|define
name|POINTSIZE
value|40
end_define

begin_comment
comment|/* this is the "unitwidth" point size */
end_comment

begin_define
define|#
directive|define
name|MINSIZE
value|6
end_define

begin_comment
comment|/* the minimum and maximum point size values */
end_comment

begin_define
define|#
directive|define
name|MAXSIZE
value|36
end_define

begin_comment
comment|/*    acceptible for use as "unitwidth"s */
end_comment

begin_define
define|#
directive|define
name|MINRES
value|10
end_define

begin_comment
comment|/* check up on resolution input by setting */
end_comment

begin_define
define|#
directive|define
name|MAXRES
value|100000
end_define

begin_comment
comment|/*    absurdly out-of-range limits on them */
end_comment

begin_define
define|#
directive|define
name|MAXLAST
value|127
end_define

begin_comment
comment|/* highest character code allowed */
end_comment

begin_define
define|#
directive|define
name|SYNON
value|100
end_define

begin_comment
comment|/* number of entries in a synonym table. */
end_comment

begin_comment
comment|/*    equals twice the number of pairs. */
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|idstrings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place for identifying strings */
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|endstring
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points to end of id strings */
end_comment

begin_decl_stmt
name|double
name|fixtowdth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "fix" and magnification conversion factor */
end_comment

begin_decl_stmt
name|glyph_dir
name|g
index|[
name|DIRSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* directory of glyph definitions */
end_comment

begin_decl_stmt
name|preamble
name|p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set of variables for preamble */
end_comment

begin_decl_stmt
name|int
name|res
init|=
name|RES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* resolution of the device (units/inch) */
end_comment

begin_decl_stmt
name|int
name|pointsize
init|=
name|POINTSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* point size being used for unitwidth */
end_comment

begin_decl_stmt
name|int
name|psize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* point size of font actually used */
end_comment

begin_decl_stmt
name|int
name|psizelist
index|[]
init|=
block|{
literal|40
block|,
literal|36
block|,
literal|28
block|,
literal|24
block|,
literal|22
block|,
literal|20
block|,
literal|18
block|,
literal|16
block|,
literal|14
block|,
literal|13
block|,
literal|12
block|,
literal|11
block|,
literal|10
block|,
literal|9
block|,
literal|8
block|,
literal|7
block|,
literal|6
block|,
literal|5
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fontname
init|=
literal|"XX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* troff name of font - set on command line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fontdir
init|=
name|FONTDIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place to look for fonts */
end_comment

begin_decl_stmt
name|char
name|IName
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file name put here */
end_comment

begin_function_decl
name|char
modifier|*
name|rdchar
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* function makes strings for ascii */
end_comment

begin_decl_stmt
name|int
name|FID
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file number */
end_comment

begin_decl_stmt
name|int
name|maxdown
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of the most "droopy" character */
end_comment

begin_decl_stmt
name|int
name|maxup
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of the tallest character */
end_comment

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1, 2, or 3 for type of ascend/descending */
end_comment

begin_decl_stmt
name|int
name|ligsf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag "does this font have ligatures?" */
end_comment

begin_comment
comment|/* following are the character maps for */
end_comment

begin_comment
comment|/* ascii code-conversion to printables... */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|charmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|synonyms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numsyn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|iregular
index|[]
init|=
block|{
literal|"*G"
block|,
literal|"*D"
block|,
literal|"*H"
block|,
literal|"*L"
block|,
literal|"*C"
block|,
literal|"*P"
block|,
literal|"*S"
block|,
literal|"*U"
block|,
literal|"*F"
block|,
literal|"*Q"
block|,
literal|"*W"
block|,
literal|"id"
block|,
literal|"ij"
block|,
literal|"ga"
block|,
literal|"aa"
block|,
literal|"^"
block|,
literal|"d^"
block|,
literal|"hc"
block|,
literal|"rn"
block|,
literal|".."
block|,
literal|"~"
block|,
literal|"ve"
block|,
literal|"im"
block|,
literal|"de"
block|,
literal|"ce"
block|,
literal|"tl"
block|,
literal|"ar"
block|,
literal|"fb"
block|,
literal|"ae"
block|,
literal|"oe"
block|,
literal|"AE"
block|,
literal|"OE"
block|,
literal|"o/"
block|,
literal|"!"
block|,
literal|"\""
block|,
literal|"fm"
block|,
literal|"ft"
block|,
literal|"%"
block|,
literal|"&"
block|,
literal|"'"
block|,
literal|"("
block|,
literal|")"
block|,
literal|"*"
block|,
literal|"+"
block|,
literal|","
block|,
literal|"hy"
block|,
literal|"."
block|,
literal|"/"
block|,
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|":"
block|,
literal|";"
block|,
literal|"<"
block|,
literal|"="
block|,
literal|">"
block|,
literal|"?"
block|,
literal|"es"
block|,
literal|"A"
block|,
literal|"B"
block|,
literal|"C"
block|,
literal|"D"
block|,
literal|"E"
block|,
literal|"F"
block|,
literal|"G"
block|,
literal|"H"
block|,
literal|"I"
block|,
literal|"J"
block|,
literal|"K"
block|,
literal|"L"
block|,
literal|"M"
block|,
literal|"N"
block|,
literal|"O"
block|,
literal|"P"
block|,
literal|"Q"
block|,
literal|"R"
block|,
literal|"S"
block|,
literal|"T"
block|,
literal|"U"
block|,
literal|"V"
block|,
literal|"W"
block|,
literal|"X"
block|,
literal|"Y"
block|,
literal|"Z"
block|,
literal|"["
block|,
literal|"b\""
block|,
literal|"]"
block|,
literal|"\\-"
block|,
literal|"em"
block|,
literal|"`"
block|,
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|,
literal|"d"
block|,
literal|"e"
block|,
literal|"f"
block|,
literal|"g"
block|,
literal|"h"
block|,
literal|"i"
block|,
literal|"j"
block|,
literal|"k"
block|,
literal|"l"
block|,
literal|"m"
block|,
literal|"n"
block|,
literal|"o"
block|,
literal|"p"
block|,
literal|"q"
block|,
literal|"r"
block|,
literal|"s"
block|,
literal|"t"
block|,
literal|"u"
block|,
literal|"v"
block|,
literal|"w"
block|,
literal|"x"
block|,
literal|"y"
block|,
literal|"z"
block|,
literal|"ff"
block|,
literal|"fi"
block|,
literal|"fl"
block|,
literal|"Fi"
block|,
literal|"Fl"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nregular
init|=
literal|14
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sregular
index|[
name|SYNON
index|]
init|=
block|{
literal|"A"
block|,
literal|"*A"
block|,
literal|"B"
block|,
literal|"*B"
block|,
literal|"E"
block|,
literal|"*E"
block|,
literal|"H"
block|,
literal|"*Y"
block|,
literal|"I"
block|,
literal|"*I"
block|,
literal|"K"
block|,
literal|"*K"
block|,
literal|"M"
block|,
literal|"*M"
block|,
literal|"N"
block|,
literal|"*N"
block|,
literal|"O"
block|,
literal|"*O"
block|,
literal|"P"
block|,
literal|"*R"
block|,
literal|"T"
block|,
literal|"*T"
block|,
literal|"X"
block|,
literal|"*X"
block|,
literal|"Z"
block|,
literal|"*Z"
block|,
literal|"hy"
block|,
literal|"-"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|iascii
index|[]
init|=
block|{
literal|"m."
block|,
literal|"da"
block|,
literal|"*a"
block|,
literal|"*b"
block|,
literal|"an"
block|,
literal|"no"
block|,
literal|"mo"
block|,
literal|"*p"
block|,
literal|"*l"
block|,
literal|"*g"
block|,
literal|"*d"
block|,
literal|"is"
block|,
literal|"+-"
block|,
literal|"O+"
block|,
literal|"if"
block|,
literal|"pd"
block|,
literal|"sb"
block|,
literal|"sp"
block|,
literal|"ca"
block|,
literal|"cu"
block|,
literal|"fa"
block|,
literal|"te"
block|,
literal|"OX"
block|,
literal|"<>"
block|,
literal|"<-"
block|,
literal|"->"
block|,
literal|"ap"
block|,
literal|"!="
block|,
literal|"<="
block|,
literal|">="
block|,
literal|"=="
block|,
literal|"or"
block|,
literal|""
block|,
literal|"!"
block|,
literal|"\""
block|,
literal|"#"
block|,
literal|"$"
block|,
literal|"%"
block|,
literal|"&"
block|,
literal|"'"
block|,
literal|"("
block|,
literal|")"
block|,
literal|"*"
block|,
literal|"+"
block|,
literal|","
block|,
literal|"-"
block|,
literal|"."
block|,
literal|"/"
block|,
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|":"
block|,
literal|";"
block|,
literal|"<"
block|,
literal|"="
block|,
literal|">"
block|,
literal|"?"
block|,
literal|"@"
block|,
literal|"A"
block|,
literal|"B"
block|,
literal|"C"
block|,
literal|"D"
block|,
literal|"E"
block|,
literal|"F"
block|,
literal|"G"
block|,
literal|"H"
block|,
literal|"I"
block|,
literal|"J"
block|,
literal|"K"
block|,
literal|"L"
block|,
literal|"M"
block|,
literal|"N"
block|,
literal|"O"
block|,
literal|"P"
block|,
literal|"Q"
block|,
literal|"R"
block|,
literal|"S"
block|,
literal|"T"
block|,
literal|"U"
block|,
literal|"V"
block|,
literal|"W"
block|,
literal|"X"
block|,
literal|"Y"
block|,
literal|"Z"
block|,
literal|"["
block|,
literal|"\\"
block|,
literal|"]"
block|,
literal|"^"
block|,
literal|"em"
block|,
literal|"`"
block|,
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|,
literal|"d"
block|,
literal|"e"
block|,
literal|"f"
block|,
literal|"g"
block|,
literal|"h"
block|,
literal|"i"
block|,
literal|"j"
block|,
literal|"k"
block|,
literal|"l"
block|,
literal|"m"
block|,
literal|"n"
block|,
literal|"o"
block|,
literal|"p"
block|,
literal|"q"
block|,
literal|"r"
block|,
literal|"s"
block|,
literal|"t"
block|,
literal|"u"
block|,
literal|"v"
block|,
literal|"w"
block|,
literal|"x"
block|,
literal|"y"
block|,
literal|"z"
block|,
literal|"{"
block|,
literal|"|"
block|,
literal|"}"
block|,
literal|"~"
block|,
literal|"dm"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nascii
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sascii
index|[
name|SYNON
index|]
init|=
block|{
literal|"-"
block|,
literal|"hy"
block|,
literal|"-"
block|,
literal|"\\-"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ispecial
index|[]
init|=
block|{
literal|"mi"
block|,
literal|"m."
block|,
literal|"mu"
block|,
literal|"**"
block|,
literal|"\\"
block|,
literal|"ci"
block|,
literal|"+-"
block|,
literal|"-+"
block|,
literal|"O+"
block|,
literal|"O-"
block|,
literal|"OX"
block|,
literal|"O/"
block|,
literal|"O."
block|,
literal|"di"
block|,
literal|"ht"
block|,
literal|"bu"
block|,
literal|"pe"
block|,
literal|"=="
block|,
literal|"ib"
block|,
literal|"ip"
block|,
literal|"<="
block|,
literal|">="
block|,
literal|"(="
block|,
literal|")="
block|,
literal|"ap"
block|,
literal|"pt"
block|,
literal|"sb"
block|,
literal|"sp"
block|,
literal|"!="
block|,
literal|".="
block|,
literal|"(("
block|,
literal|"))"
block|,
literal|"<-"
block|,
literal|"->"
block|,
literal|"ua"
block|,
literal|"da"
block|,
literal|"<>"
block|,
literal|"<<"
block|,
literal|">>"
block|,
literal|"~="
block|,
literal|"lh"
block|,
literal|"rh"
block|,
literal|"Ua"
block|,
literal|"Da"
block|,
literal|"><"
block|,
literal|"uL"
block|,
literal|"uR"
block|,
literal|"lR"
block|,
literal|"fm"
block|,
literal|"if"
block|,
literal|"mo"
block|,
literal|"!m"
block|,
literal|"0/"
block|,
literal|"ul"
block|,
literal|"al"
block|,
literal|")("
block|,
literal|"fa"
block|,
literal|"te"
block|,
literal|"no"
block|,
literal|"?0"
block|,
literal|"?1"
block|,
literal|"?2"
block|,
literal|"cr"
block|,
literal|""
block|,
literal|"/"
block|,
literal|"A"
block|,
literal|"B"
block|,
literal|"C"
block|,
literal|"D"
block|,
literal|"E"
block|,
literal|"F"
block|,
literal|"G"
block|,
literal|"H"
block|,
literal|"I"
block|,
literal|"J"
block|,
literal|"K"
block|,
literal|"L"
block|,
literal|"M"
block|,
literal|"N"
block|,
literal|"O"
block|,
literal|"P"
block|,
literal|"Q"
block|,
literal|"R"
block|,
literal|"S"
block|,
literal|"T"
block|,
literal|"U"
block|,
literal|"V"
block|,
literal|"W"
block|,
literal|"X"
block|,
literal|"Y"
block|,
literal|"Z"
block|,
literal|"cu"
block|,
literal|"ca"
block|,
literal|"c+"
block|,
literal|"an"
block|,
literal|"or"
block|,
literal|"|-"
block|,
literal|"-|"
block|,
literal|"lf"
block|,
literal|"rf"
block|,
literal|"lc"
block|,
literal|"rc"
block|,
literal|"{"
block|,
literal|"}"
block|,
literal|"<"
block|,
literal|">"
block|,
literal|"bv"
block|,
literal|"||"
block|,
literal|"[["
block|,
literal|"]]"
block|,
literal|""
block|,
literal|""
block|,
literal|"sr"
block|,
literal|"#"
block|,
literal|"gr"
block|,
literal|"is"
block|,
literal|"ux"
block|,
literal|"dx"
block|,
literal|"rx"
block|,
literal|"dm"
block|,
literal|"sc"
block|,
literal|"dg"
block|,
literal|"dd"
block|,
literal|"pp"
block|,
literal|"@"
block|,
literal|"co"
block|,
literal|""
block|,
literal|"$"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nspecial
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sspecial
index|[
name|SYNON
index|]
init|=
block|{
literal|""
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|imath
index|[]
init|=
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"lf"
block|,
literal|"rf"
block|,
literal|"lc"
block|,
literal|"rc"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"Bl"
block|,
literal|"Br"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"lt"
block|,
literal|"rt"
block|,
literal|"lb"
block|,
literal|"rb"
block|,
literal|"lk"
block|,
literal|"rk"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"LT"
block|,
literal|"RT"
block|,
literal|"LB"
block|,
literal|"RB"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"?0"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"?1"
block|,
literal|"?2"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nmath
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|smath
index|[
name|SYNON
index|]
init|=
block|{
literal|""
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|iitalics
index|[]
init|=
block|{
literal|"*G"
block|,
literal|"*D"
block|,
literal|"*H"
block|,
literal|"*L"
block|,
literal|"*C"
block|,
literal|"*P"
block|,
literal|"*S"
block|,
literal|"*U"
block|,
literal|"*F"
block|,
literal|"*Q"
block|,
literal|"*W"
block|,
literal|"*a"
block|,
literal|"*b"
block|,
literal|"*g"
block|,
literal|"*d"
block|,
literal|"*e"
block|,
literal|"*z"
block|,
literal|"*y"
block|,
literal|"*h"
block|,
literal|"*i"
block|,
literal|"*k"
block|,
literal|"*l"
block|,
literal|"*m"
block|,
literal|"*n"
block|,
literal|"*c"
block|,
literal|"*p"
block|,
literal|"*r"
block|,
literal|"*s"
block|,
literal|"*t"
block|,
literal|"*u"
block|,
literal|"*f"
block|,
literal|"*x"
block|,
literal|"id"
block|,
literal|"!"
block|,
literal|"\""
block|,
literal|"el"
block|,
literal|"?0"
block|,
literal|"pd"
block|,
literal|"&"
block|,
literal|"'"
block|,
literal|"("
block|,
literal|")"
block|,
literal|"*"
block|,
literal|"+"
block|,
literal|","
block|,
literal|"hy"
block|,
literal|"."
block|,
literal|"/"
block|,
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|":"
block|,
literal|";"
block|,
literal|"<"
block|,
literal|"="
block|,
literal|">"
block|,
literal|"?"
block|,
literal|"id"
block|,
literal|"A"
block|,
literal|"B"
block|,
literal|"C"
block|,
literal|"D"
block|,
literal|"E"
block|,
literal|"F"
block|,
literal|"G"
block|,
literal|"H"
block|,
literal|"I"
block|,
literal|"J"
block|,
literal|"K"
block|,
literal|"L"
block|,
literal|"M"
block|,
literal|"N"
block|,
literal|"O"
block|,
literal|"P"
block|,
literal|"Q"
block|,
literal|"R"
block|,
literal|"S"
block|,
literal|"T"
block|,
literal|"U"
block|,
literal|"V"
block|,
literal|"W"
block|,
literal|"X"
block|,
literal|"Y"
block|,
literal|"Z"
block|,
literal|"["
block|,
literal|""
block|,
literal|"]"
block|,
literal|""
block|,
literal|""
block|,
literal|"`"
block|,
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|,
literal|"d"
block|,
literal|"e"
block|,
literal|"f"
block|,
literal|"g"
block|,
literal|"h"
block|,
literal|"i"
block|,
literal|"j"
block|,
literal|"k"
block|,
literal|"l"
block|,
literal|"m"
block|,
literal|"n"
block|,
literal|"o"
block|,
literal|"p"
block|,
literal|"q"
block|,
literal|"r"
block|,
literal|"s"
block|,
literal|"t"
block|,
literal|"u"
block|,
literal|"v"
block|,
literal|"w"
block|,
literal|"x"
block|,
literal|"y"
block|,
literal|"z"
block|,
literal|"*q"
block|,
literal|"*w"
block|,
literal|"?2"
block|,
literal|"?1"
block|,
literal|"w-"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nitalics
init|=
literal|15
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sitalics
index|[
name|SYNON
index|]
init|=
block|{
literal|"A"
block|,
literal|"*A"
block|,
literal|"B"
block|,
literal|"*B"
block|,
literal|"E"
block|,
literal|"*E"
block|,
literal|"H"
block|,
literal|"*Y"
block|,
literal|"I"
block|,
literal|"*I"
block|,
literal|"K"
block|,
literal|"*K"
block|,
literal|"M"
block|,
literal|"*M"
block|,
literal|"N"
block|,
literal|"*N"
block|,
literal|"O"
block|,
literal|"*O"
block|,
literal|"P"
block|,
literal|"*R"
block|,
literal|"T"
block|,
literal|"*T"
block|,
literal|"X"
block|,
literal|"*X"
block|,
literal|"Z"
block|,
literal|"*Z"
block|,
literal|"o"
block|,
literal|"*o"
block|,
literal|"hy"
block|,
literal|"-"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* two indexes */
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* string traveller */
specifier|register
name|char
name|delimit
decl_stmt|;
comment|/* place for delemiters on command-line */
name|char
name|tostring
parameter_list|()
function_decl|;
comment|/* function makes string */
name|char
modifier|*
name|nextstring
parameter_list|()
function_decl|;
comment|/* moves to next string on list */
name|charmap
operator|=
name|iregular
expr_stmt|;
comment|/* default character map */
name|synonyms
operator|=
name|sregular
expr_stmt|;
name|numsyn
operator|=
name|nregular
expr_stmt|;
while|while
condition|(
operator|*
operator|(
operator|*
operator|(
operator|++
name|argv
operator|)
operator|)
operator|==
literal|'-'
condition|)
block|{
comment|/* do options... */
switch|switch
condition|(
operator|*
operator|(
operator|++
operator|(
operator|*
name|argv
operator|)
operator|)
condition|)
block|{
case|case
literal|'s'
case|:
name|charmap
operator|=
name|ispecial
expr_stmt|;
comment|/* special font */
name|synonyms
operator|=
name|sspecial
expr_stmt|;
name|numsyn
operator|=
name|nspecial
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|charmap
operator|=
name|imath
expr_stmt|;
comment|/* math font */
name|synonyms
operator|=
name|smath
expr_stmt|;
name|numsyn
operator|=
name|nmath
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|charmap
operator|=
name|iitalics
expr_stmt|;
comment|/* italics font */
name|synonyms
operator|=
name|sitalics
expr_stmt|;
name|numsyn
operator|=
name|nitalics
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|charmap
operator|=
name|iascii
expr_stmt|;
comment|/* ascii font */
name|synonyms
operator|=
name|sascii
expr_stmt|;
name|numsyn
operator|=
name|nascii
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|ligsf
operator|=
literal|1
expr_stmt|;
comment|/* ascii font */
break|break;
case|case
literal|'n'
case|:
name|fontname
operator|=
operator|++
operator|*
name|argv
expr_stmt|;
comment|/* troff font name */
break|break;
case|case
literal|'x'
case|:
name|ptr
operator|=
operator|++
operator|*
name|argv
expr_stmt|;
comment|/* replacements */
while|while
condition|(
name|delimit
operator|=
name|tostring
argument_list|(
name|ptr
argument_list|,
literal|','
argument_list|)
condition|)
block|{
comment|/* get s1 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAXLAST
condition|;
name|i
operator|++
control|)
comment|/* search for match */
if|if
condition|(
name|strcmp
argument_list|(
name|charmap
index|[
name|i
index|]
argument_list|,
name|ptr
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>
name|MAXLAST
condition|)
name|error
argument_list|(
literal|"-x option: no match"
argument_list|)
expr_stmt|;
name|charmap
index|[
name|i
index|]
operator|=
name|ptr
operator|=
name|nextstring
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* replace s1 */
name|delimit
operator|=
name|tostring
argument_list|(
name|ptr
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
comment|/* with string s2 */
if|if
condition|(
name|delimit
condition|)
name|ptr
operator|=
name|nextstring
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'y'
case|:
name|ptr
operator|=
operator|++
operator|*
name|argv
expr_stmt|;
comment|/* synonyms */
while|while
condition|(
name|delimit
operator|=
name|tostring
argument_list|(
name|ptr
argument_list|,
literal|','
argument_list|)
condition|)
block|{
comment|/* get s1 */
name|synonyms
index|[
literal|2
operator|*
name|numsyn
index|]
operator|=
name|ptr
expr_stmt|;
comment|/* set on end of list */
name|ptr
operator|=
name|nextstring
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* get string s2 */
name|delimit
operator|=
name|tostring
argument_list|(
name|ptr
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
condition|)
block|{
comment|/* if something there */
name|synonyms
index|[
literal|2
operator|*
name|numsyn
operator|++
operator|+
literal|1
index|]
operator|=
name|ptr
expr_stmt|;
comment|/* add to list */
block|}
else|else
block|{
comment|/* otherwise remove */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numsyn
condition|;
name|i
operator|++
control|)
comment|/* from list */
if|if
condition|(
name|strcmp
argument_list|(
name|synonyms
index|[
literal|2
operator|*
name|i
index|]
argument_list|,
name|ptr
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|synonyms
index|[
literal|2
operator|*
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|delimit
condition|)
name|ptr
operator|=
name|nextstring
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|numsyn
operator|>
name|SYNON
condition|)
name|error
argument_list|(
literal|"out of synonym space"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
name|fontdir
operator|=
operator|++
operator|*
name|argv
expr_stmt|;
comment|/* directory */
break|break;
case|case
literal|'p'
case|:
name|pointsize
operator|=
name|atoi
argument_list|(
operator|++
operator|*
name|argv
argument_list|)
expr_stmt|;
comment|/* point size */
if|if
condition|(
name|pointsize
operator|<
name|MINSIZE
operator|||
name|pointsize
operator|>
name|MAXSIZE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Illegal point size: %d\n"
argument_list|,
name|pointsize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
name|res
operator|=
name|atoi
argument_list|(
operator|++
operator|*
name|argv
argument_list|)
expr_stmt|;
comment|/* resolution */
if|if
condition|(
name|res
operator|<
name|MINRES
operator|||
name|res
operator|>
name|MAXRES
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Illegal resolution: %d\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad option: %c"
argument_list|,
operator|*
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* open font file */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|FID
operator|<
literal|0
operator|&&
operator|(
name|psize
operator|=
name|psizelist
index|[
name|i
index|]
operator|)
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|IName
argument_list|,
literal|"%s/%s.r%d"
argument_list|,
name|fontdir
argument_list|,
operator|*
name|argv
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|FID
operator|=
name|open
argument_list|(
name|IName
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FID
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't find %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|read
argument_list|(
name|FID
argument_list|,
operator|&
name|filemark
index|[
literal|0
index|]
argument_list|,
name|FMARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|filemark
argument_list|,
literal|"Rast"
argument_list|,
literal|4
argument_list|)
operator|||
name|i
operator|!=
name|FMARK
condition|)
name|error
argument_list|(
literal|"Bad File Mark in Font file."
argument_list|)
expr_stmt|;
name|p
operator|.
name|p_size
operator|=
name|rd2
argument_list|()
expr_stmt|;
name|p
operator|.
name|p_version
operator|=
name|rd1
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|p_version
condition|)
name|error
argument_list|(
literal|"Wrong version of Font file."
argument_list|)
expr_stmt|;
name|p
operator|.
name|p_glyph
operator|=
name|rd3
argument_list|()
expr_stmt|;
name|p
operator|.
name|p_first
operator|=
name|rd2
argument_list|()
expr_stmt|;
name|p
operator|.
name|p_last
operator|=
name|rd2
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|p_last
operator|>
name|MAXLAST
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"truncating from %d to %d\n"
argument_list|,
name|p
operator|.
name|p_last
argument_list|,
name|MAXLAST
argument_list|)
expr_stmt|;
name|p
operator|.
name|p_last
operator|=
name|MAXLAST
expr_stmt|;
block|}
name|p
operator|.
name|p_mag
operator|=
name|rd4
argument_list|()
expr_stmt|;
name|p
operator|.
name|p_desiz
operator|=
name|rd4
argument_list|()
expr_stmt|;
name|p
operator|.
name|p_linesp
operator|=
name|rd4
argument_list|()
expr_stmt|;
name|p
operator|.
name|p_wordsp
operator|=
name|rd4
argument_list|()
expr_stmt|;
name|p
operator|.
name|p_rot
operator|=
name|rd2
argument_list|()
expr_stmt|;
name|p
operator|.
name|p_cadv
operator|=
name|rd1
argument_list|()
expr_stmt|;
name|p
operator|.
name|p_ladv
operator|=
name|rd1
argument_list|()
expr_stmt|;
name|p
operator|.
name|p_id
operator|=
name|rd4
argument_list|()
expr_stmt|;
name|p
operator|.
name|p_res
operator|=
name|rd2
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|p_res
operator|!=
name|res
condition|)
name|error
argument_list|(
literal|"Wrong resolution in Font file."
argument_list|)
expr_stmt|;
name|i
operator|=
name|p
operator|.
name|p_glyph
operator|-
literal|44
expr_stmt|;
name|idstrings
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|endstring
operator|=
name|idstrings
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|FID
argument_list|,
name|idstrings
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
name|error
argument_list|(
literal|"Bad preamble in Font file."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|p
operator|.
name|p_first
init|;
name|i
operator|<=
name|p
operator|.
name|p_last
condition|;
name|i
operator|++
control|)
block|{
name|g
index|[
name|i
index|]
operator|.
name|g_height
operator|=
name|rd2
argument_list|()
expr_stmt|;
name|g
index|[
name|i
index|]
operator|.
name|g_width
operator|=
name|rd2
argument_list|()
expr_stmt|;
name|g
index|[
name|i
index|]
operator|.
name|g_up
operator|=
name|rd2
argument_list|()
expr_stmt|;
name|g
index|[
name|i
index|]
operator|.
name|g_left
operator|=
name|rd2
argument_list|()
expr_stmt|;
name|g
index|[
name|i
index|]
operator|.
name|g_pwidth
operator|=
name|rd4
argument_list|()
expr_stmt|;
name|g
index|[
name|i
index|]
operator|.
name|g_bitp
operator|=
name|rd3
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fixtowdth
operator|=
name|FIXPIX
operator|*
name|p
operator|.
name|p_mag
operator|/
literal|1000.0
operator|)
operator|==
literal|0.0
condition|)
name|fixtowdth
operator|=
name|FIXPIX
expr_stmt|;
name|printf
argument_list|(
literal|"# Font %s\n# size %.2f, "
argument_list|,
name|IName
argument_list|,
name|p
operator|.
name|p_desiz
operator|*
name|FIX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"first %d, last %d, res %d, "
argument_list|,
name|p
operator|.
name|p_first
argument_list|,
name|p
operator|.
name|p_last
argument_list|,
name|p
operator|.
name|p_res
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mag %.2f\n"
argument_list|,
name|fixtowdth
operator|/
name|FIXPIX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"name %s\n"
argument_list|,
name|fontname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ligsf
condition|)
name|printf
argument_list|(
literal|"ligatures ff fl fi ffl ffi 0\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
operator|(
name|pointsize
operator|*
name|p
operator|.
name|p_wordsp
operator|*
name|fixtowdth
operator|)
operator|/
name|psize
operator|)
operator|>
literal|127
condition|)
name|i
operator|=
literal|127
expr_stmt|;
name|printf
argument_list|(
literal|"spacewidth %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"# char	width	u/d	octal\ncharset\n"
argument_list|)
expr_stmt|;
comment|/* the octal values for the following characters are */
comment|/* purposefully OUT of the range for characters (128) */
name|printf
argument_list|(
literal|"\\|	%4d	 0	0200\n\\^	%4d	 0	0200\n"
argument_list|,
name|i
operator|/
literal|3
argument_list|,
name|i
operator|/
literal|6
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|p
operator|.
name|p_first
init|;
name|j
operator|<=
name|p
operator|.
name|p_last
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|g
index|[
name|j
index|]
operator|.
name|g_bitp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|g
index|[
name|j
index|]
operator|.
name|g_up
operator|>
name|maxup
condition|)
name|maxup
operator|=
name|g
index|[
name|j
index|]
operator|.
name|g_up
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|g
index|[
name|j
index|]
operator|.
name|g_height
operator|-
operator|(
name|g
index|[
name|j
index|]
operator|.
name|g_up
operator|+
literal|1
operator|)
operator|)
operator|>
name|maxdown
condition|)
name|maxdown
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|maxdown
operator|==
literal|0
condition|)
name|maxdown
operator|=
literal|1
expr_stmt|;
comment|/*******************************************************************************  	`type' is used to determine overhangs (up/down) from percentage of 	the maximum heights and dips.  Ascenders are higher than PCNTUP% 	of the highest, as descenders are more than PCNTDOWN%. 	widths [i = f(width)] are calculated from the definition point 	size (pointsize) and the one from this font (psize).  *******************************************************************************/
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|g
index|[
name|j
index|]
operator|.
name|g_bitp
operator|!=
literal|0
condition|)
block|{
name|type
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|g
index|[
name|j
index|]
operator|.
name|g_up
operator|*
literal|100
operator|)
operator|/
name|maxup
operator|)
operator|>
name|PCNTUP
argument_list|)
operator|*
literal|2
operator||
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
operator|(
name|g
index|[
name|j
index|]
operator|.
name|g_height
operator|-
operator|(
name|g
index|[
name|j
index|]
operator|.
name|g_up
operator|+
literal|1
operator|)
operator|)
operator|*
literal|100
operator|)
operator|/
name|maxdown
operator|)
operator|>
name|PCNTDOWN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|ptr
operator|=
name|charmap
index|[
name|j
index|]
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s	%4d	 %d	0%o\n"
argument_list|,
name|ptr
argument_list|,
call|(
name|int
call|)
argument_list|(
name|pointsize
operator|*
name|g
index|[
name|j
index|]
operator|.
name|g_pwidth
operator|*
name|fixtowdth
operator|/
name|psize
argument_list|)
argument_list|,
name|type
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numsyn
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ptr
argument_list|,
name|synonyms
index|[
literal|2
operator|*
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%s	\"\n"
argument_list|,
name|synonyms
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	char  tostring (pointer, delimitter)  |  | Results:	checks string pointed to by pointer and turns it into a  |		string at 'delimitter' by replacing it with '\0'.  If the  |		end of the string is found first, '\0' is returned; otherwise  |		the delimitter found there is returned.  |  *----------------------------------------------------------------------------*/
end_comment

begin_function
name|char
name|tostring
parameter_list|(
name|p
parameter_list|,
name|d
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|d
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
name|d
condition|)
name|p
operator|++
expr_stmt|;
name|d
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	char  * nextstring (pointer)  |  | Results:	returns address of next string after one pointed to by  |		pointer.  The next string is after the '\0' byte.  |  *----------------------------------------------------------------------------*/
end_comment

begin_function
name|char
modifier|*
name|nextstring
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
while|while
condition|(
operator|*
operator|(
name|p
operator|++
operator|)
condition|)
empty_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_macro
name|error
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"\nmakefont: %s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rd1
argument_list|()
end_macro

begin_block
block|{
name|unsigned
name|char
name|i
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
name|FID
argument_list|,
operator|&
name|i
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"File read error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|i
return|;
block|}
end_block

begin_macro
name|rd2
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
init|=
name|rd1
argument_list|()
operator|<<
literal|8
decl_stmt|;
return|return
name|i
operator|+
name|rd1
argument_list|()
return|;
block|}
end_block

begin_macro
name|rd3
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
init|=
name|rd2
argument_list|()
operator|<<
literal|8
decl_stmt|;
return|return
name|i
operator|+
name|rd1
argument_list|()
return|;
block|}
end_block

begin_macro
name|rd4
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
init|=
name|rd2
argument_list|()
operator|<<
literal|16
decl_stmt|;
return|return
name|i
operator|+
name|rd2
argument_list|()
return|;
block|}
end_block

end_unit

