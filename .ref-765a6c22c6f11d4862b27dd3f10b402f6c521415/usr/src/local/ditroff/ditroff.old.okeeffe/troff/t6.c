begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	t6.c	1.3	(Berkeley)	83/09/23	*/
end_comment

begin_include
include|#
directive|include
file|"tdef.h"
end_include

begin_decl_stmt
specifier|extern
include|#
directive|include
file|"d.h"
specifier|extern
include|#
directive|include
file|"v.h"
include|#
directive|include
file|"dev.h"
comment|/* troff6.c  width functions, sizes and fonts */
include|#
directive|include
file|<sgtty.h>
include|#
directive|include
file|"ext.h"
name|int
name|trflg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fitab[f][c] is 0 if c is not on font f 	/* if it's non-zero, c is in fontab[f] at position 	/* fitab[f][c]. 	*/
end_comment

begin_decl_stmt
name|int
name|fontlab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|pstab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cstab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|,
name|ccstab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bdtab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sbold
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|width
argument_list|(
argument|j
argument_list|)
end_macro

begin_decl_stmt
name|tchar
name|j
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|k
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|cbits
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|ismot
argument_list|(
name|j
argument_list|)
condition|)
block|{
if|if
condition|(
name|isvmot
argument_list|(
name|j
argument_list|)
condition|)
goto|goto
name|rtn
goto|;
name|k
operator|=
name|absmot
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnmot
argument_list|(
name|j
argument_list|)
condition|)
name|k
operator|=
operator|-
name|k
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
if|if
condition|(
name|i
operator|==
literal|'\b'
condition|)
block|{
name|k
operator|=
operator|-
name|widthp
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
if|if
condition|(
name|i
operator|==
name|PRESC
condition|)
name|i
operator|=
name|eschar
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|ohc
operator|||
name|iscontrol
argument_list|(
name|i
argument_list|)
condition|)
goto|goto
name|rtn
goto|;
if|if
condition|(
name|sfbits
argument_list|(
name|j
argument_list|)
operator|==
name|oldbits
condition|)
block|{
name|xfont
operator|=
name|pfont
expr_stmt|;
name|xpts
operator|=
name|ppts
expr_stmt|;
block|}
else|else
name|xbits
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|iszbit
argument_list|(
name|j
argument_list|)
condition|)
goto|goto
name|rtn
goto|;
if|if
condition|(
operator|!
name|trflg
condition|)
name|i
operator|=
name|trtab
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|-=
literal|32
operator|)
operator|<
literal|0
condition|)
goto|goto
name|rtn
goto|;
name|k
operator|=
name|getcw
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd
condition|)
name|k
operator|+=
operator|(
name|bd
operator|-
literal|1
operator|)
operator|*
name|HOR
expr_stmt|;
if|if
condition|(
name|cs
condition|)
name|k
operator|=
name|cs
expr_stmt|;
name|widthp
operator|=
name|k
expr_stmt|;
name|rtn
label|:
name|xbitf
operator|=
name|trflg
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|getcw
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|x
decl_stmt|,
name|j
decl_stmt|;
name|bd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* a blank */
name|k
operator|=
operator|(
name|fontab
index|[
name|xfont
index|]
index|[
literal|0
index|]
operator|*
name|spacesz
operator|+
literal|6
operator|)
operator|/
literal|12
expr_stmt|;
comment|/* this nonsense because .ss cmd uses 1/36 em as its units */
comment|/* and default is 12 */
goto|goto
name|g1
goto|;
block|}
if|if
condition|(
operator|(
name|j
operator|=
name|fitab
index|[
name|xfont
index|]
index|[
name|i
index|]
operator|&
name|BMASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* NOT current font */
comment|/* search through search list of xfont 		/* to see what font it ought to be on. 		/* for now, searches from current font in wraparound order. */
name|int
name|ii
decl_stmt|,
name|jj
decl_stmt|;
for|for
control|(
name|ii
operator|=
name|xfont
operator|,
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
name|nfonts
condition|;
name|jj
operator|++
operator|,
name|ii
operator|=
name|ii
operator|%
name|nfonts
operator|+
literal|1
control|)
block|{
name|j
operator|=
name|fitab
index|[
name|ii
index|]
index|[
name|i
index|]
operator|&
name|BMASK
expr_stmt|;
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|fontab
index|[
name|ii
index|]
expr_stmt|;
name|k
operator|=
operator|*
operator|(
name|p
operator|+
name|j
operator|)
expr_stmt|;
if|if
condition|(
name|xfont
operator|==
name|sbold
condition|)
name|bd
operator|=
name|bdtab
index|[
name|ii
index|]
expr_stmt|;
if|if
condition|(
name|setwdf
condition|)
name|v
operator|.
name|ct
operator||=
name|kerntab
index|[
name|ii
index|]
index|[
name|j
index|]
expr_stmt|;
goto|goto
name|g1
goto|;
block|}
block|}
name|code
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|fontab
index|[
name|xfont
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* leave a space-size space */
goto|goto
name|g1
goto|;
block|}
name|p
operator|=
name|fontab
index|[
name|xfont
index|]
expr_stmt|;
if|if
condition|(
name|setwdf
condition|)
name|v
operator|.
name|ct
operator||=
name|kerntab
index|[
name|xfont
index|]
index|[
name|j
index|]
expr_stmt|;
name|k
operator|=
operator|*
operator|(
name|p
operator|+
name|j
operator|)
expr_stmt|;
name|g1
label|:
if|if
condition|(
operator|!
name|bd
condition|)
name|bd
operator|=
name|bdtab
index|[
name|xfont
index|]
expr_stmt|;
if|if
condition|(
name|cs
operator|=
name|cstab
index|[
name|xfont
index|]
condition|)
block|{
if|if
condition|(
name|ccs
operator|=
name|ccstab
index|[
name|xfont
index|]
condition|)
name|x
operator|=
name|ccs
expr_stmt|;
else|else
name|x
operator|=
name|xpts
expr_stmt|;
name|cs
operator|=
operator|(
name|cs
operator|*
name|EMPTS
argument_list|(
name|x
argument_list|)
operator|)
operator|/
literal|36
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|(
name|k
operator|&
name|BMASK
operator|)
operator|*
name|xpts
operator|+
operator|(
name|Unitwidth
operator|/
literal|2
operator|)
operator|)
operator|/
name|Unitwidth
operator|)
return|;
comment|/* Unitwidth is Units/Point, where 	/* Units is the fundamental digitization 	/* of the character set widths, and 	/* Point is the number of goobies in a point 	/* e.g., for cat, Units=36, Point=6, so Unitwidth=36/6=6 	/* In effect, it's the size at which the widths 	/* translate directly into units. 	*/
block|}
end_block

begin_macro
name|xbits
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|tchar
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|j
operator|,
name|k
expr_stmt|;
name|xfont
operator|=
name|fbits
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|k
operator|=
name|sbits
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
condition|)
block|{
name|xpts
operator|=
name|pstab
index|[
operator|--
name|k
index|]
expr_stmt|;
name|oldbits
operator|=
name|sfbits
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|pfont
operator|=
name|xfont
expr_stmt|;
name|ppts
operator|=
name|xpts
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
switch|switch
condition|(
name|xbitf
condition|)
block|{
case|case
literal|0
case|:
name|xfont
operator|=
name|font
expr_stmt|;
name|xpts
operator|=
name|pts
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|xfont
operator|=
name|pfont
expr_stmt|;
name|xpts
operator|=
name|ppts
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|xfont
operator|=
name|mfont
expr_stmt|;
name|xpts
operator|=
name|mpts
expr_stmt|;
block|}
name|rtn
label|:
name|xbitf
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|tchar
name|setch
parameter_list|()
block|{
specifier|register
name|j
expr_stmt|;
name|char
name|temp
index|[
literal|10
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|extern
name|char
modifier|*
name|chname
decl_stmt|;
specifier|extern
name|short
modifier|*
name|chtab
decl_stmt|;
specifier|extern
name|int
name|nchtab
decl_stmt|;
name|s
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|++
operator|=
name|getach
argument_list|()
operator|)
operator|==
literal|0
operator|||
operator|(
operator|*
name|s
operator|++
operator|=
name|getach
argument_list|()
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nchtab
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chname
index|[
name|chtab
index|[
name|j
index|]
index|]
argument_list|,
name|temp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|j
operator|+
literal|128
operator||
name|chbits
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|tchar
name|absch
parameter_list|()
comment|/* absolute character number */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"troff: no \\C yet\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|findft
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|k
expr_stmt|;
specifier|register
name|char
name|last
decl_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
operator|(
name|i
operator|&
name|BMASK
operator|)
operator|-
literal|'0'
operator|)
operator|>=
literal|0
operator|&&
name|k
operator|<=
literal|9
condition|)
block|{
comment|/* digit - see if two */
if|if
condition|(
name|last
operator|=
name|cbits
argument_list|(
name|i
argument_list|)
operator|>>
name|BYTE
condition|)
if|if
condition|(
operator|(
name|last
operator|-=
literal|'0'
operator|)
operator|<
literal|0
operator|||
name|last
operator|>
literal|9
operator|||
operator|(
name|k
operator|=
name|k
operator|*
literal|10
operator|+
name|last
operator|)
operator|>
name|nfonts
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|k
operator|)
return|;
comment|/* one digit (or two, if in range */
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|fontlab
index|[
name|k
index|]
operator|!=
name|i
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|k
operator|>
name|nfonts
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_block

begin_macro
name|caseps
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|skip
argument_list|()
condition|)
name|i
operator|=
name|apts1
expr_stmt|;
else|else
block|{
name|noscale
operator|++
expr_stmt|;
name|i
operator|=
name|inumb
argument_list|(
operator|&
name|apts
argument_list|)
expr_stmt|;
comment|/* this is a disaster for fractional point sizes */
name|noscale
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nonumb
condition|)
return|return;
block|}
name|casps1
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|casps1
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return;
name|apts1
operator|=
name|apts
expr_stmt|;
name|apts
operator|=
name|i
expr_stmt|;
name|pts1
operator|=
name|pts
expr_stmt|;
name|pts
operator|=
name|findps
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|mchbits
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|findps
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|j
operator|,
name|k
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|>
operator|(
name|k
operator|=
name|pstab
index|[
name|j
index|]
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|k
condition|)
block|{
name|k
operator|=
name|pstab
index|[
operator|--
name|j
index|]
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|k
operator|)
return|;
block|}
end_block

begin_macro
name|mchbits
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
operator|,
name|k
expr_stmt|;
name|i
operator|=
name|pts
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|>
operator|(
name|k
operator|=
name|pstab
index|[
name|j
index|]
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|k
condition|)
block|{
name|k
operator|=
name|pstab
index|[
operator|--
name|j
index|]
expr_stmt|;
break|break;
block|}
name|chbits
operator|=
literal|0
expr_stmt|;
name|setsbits
argument_list|(
name|chbits
argument_list|,
operator|++
name|j
argument_list|)
expr_stmt|;
name|setfbits
argument_list|(
name|chbits
argument_list|,
name|font
argument_list|)
expr_stmt|;
name|sps
operator|=
name|width
argument_list|(
literal|' '
operator||
name|chbits
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setps
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|i
operator|=
name|cbits
argument_list|(
name|getch
argument_list|()
argument_list|)
operator|)
operator|==
literal|'+'
operator|||
name|i
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|j
operator|=
name|cbits
argument_list|(
name|ch
operator|=
name|getch
argument_list|()
argument_list|)
operator|-
literal|'0'
operator|)
operator|>=
literal|0
operator|&&
name|j
operator|<=
literal|9
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|'-'
condition|)
name|j
operator|=
operator|-
name|j
expr_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
name|casps1
argument_list|(
name|apts
operator|+
name|j
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|i
operator|-=
literal|'0'
operator|)
operator|==
literal|0
condition|)
block|{
name|casps1
argument_list|(
name|apts1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|i
operator|<=
literal|9
condition|)
block|{
comment|/* removed if (i<= 3&& */
comment|/* didn't work!!!! */
if|if
condition|(
name|i
operator|<=
literal|3
operator|&&
operator|(
name|j
operator|=
name|cbits
argument_list|(
name|ch
operator|=
name|getch
argument_list|()
argument_list|)
operator|-
literal|'0'
operator|)
operator|>=
literal|0
operator|&&
name|j
operator|<=
literal|9
condition|)
block|{
name|i
operator|=
literal|10
operator|*
name|i
operator|+
name|j
expr_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
block|}
name|casps1
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|tchar
name|setht
parameter_list|()
comment|/* set character height from \H'...' */
block|{
name|int
name|n
decl_stmt|;
name|tchar
name|c
decl_stmt|;
name|getch
argument_list|()
expr_stmt|;
name|n
operator|=
name|inumb
argument_list|(
operator|&
name|apts
argument_list|)
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|nonumb
condition|)
name|n
operator|=
name|apts
expr_stmt|;
comment|/* does this work? */
name|c
operator|=
name|CHARHT
expr_stmt|;
name|c
operator||=
name|ZBIT
expr_stmt|;
name|setsbits
argument_list|(
name|c
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|tchar
name|setslant
parameter_list|()
comment|/* set slant from \S'...' */
block|{
name|int
name|n
decl_stmt|;
name|tchar
name|c
decl_stmt|;
name|getch
argument_list|()
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|inumb
argument_list|(
operator|&
name|n
argument_list|)
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|nonumb
condition|)
name|n
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|SLANT
expr_stmt|;
name|c
operator||=
name|ZBIT
expr_stmt|;
name|setsfbits
argument_list|(
name|c
argument_list|,
name|n
operator|+
literal|180
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_macro
name|caseft
argument_list|()
end_macro

begin_block
block|{
name|skip
argument_list|()
expr_stmt|;
name|setfont
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setfont
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
if|if
condition|(
name|a
condition|)
name|i
operator|=
name|getrq
argument_list|()
expr_stmt|;
else|else
name|i
operator|=
name|getsn
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|||
name|i
operator|==
literal|'P'
condition|)
block|{
name|j
operator|=
name|font1
expr_stmt|;
goto|goto
name|s0
goto|;
block|}
if|if
condition|(
name|i
operator|==
literal|'S'
operator|||
name|i
operator|==
literal|'0'
condition|)
return|return;
if|if
condition|(
operator|(
name|j
operator|=
name|findft
argument_list|(
name|i
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
operator|(
name|j
operator|=
name|setfp
argument_list|(
literal|0
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
comment|/* try to put it in position 0 */
return|return;
name|s0
label|:
name|font1
operator|=
name|font
expr_stmt|;
name|font
operator|=
name|j
expr_stmt|;
name|mchbits
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|setwd
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|base
operator|,
name|wid
expr_stmt|;
name|tchar
name|i
decl_stmt|;
name|int
name|delim
decl_stmt|,
name|em
decl_stmt|,
name|k
decl_stmt|;
name|int
name|savlevel
decl_stmt|,
name|savhp
decl_stmt|,
name|savapts
decl_stmt|,
name|savapts1
decl_stmt|,
name|savfont
decl_stmt|,
name|savfont1
decl_stmt|,
name|savpts
decl_stmt|,
name|savpts1
decl_stmt|;
name|tchar
modifier|*
name|savpinchar
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
name|tempinchar
index|[
name|LNSIZE
index|]
decl_stmt|;
comment|/* XXX */
name|base
operator|=
name|v
operator|.
name|st
operator|=
name|v
operator|.
name|sb
operator|=
name|wid
operator|=
name|v
operator|.
name|ct
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ismot
argument_list|(
name|i
operator|=
name|getch
argument_list|()
argument_list|)
condition|)
return|return;
name|delim
operator|=
name|cbits
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|savhp
operator|=
name|v
operator|.
name|hp
expr_stmt|;
name|savpinchar
operator|=
name|pinchar
expr_stmt|;
comment|/* XXX */
for|for
control|(
name|p
operator|=
name|inchar
operator|,
name|q
operator|=
name|tempinchar
init|;
name|p
operator|<
name|pinchar
condition|;
control|)
comment|/* XXX */
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* XXX */
name|pinchar
operator|=
name|inchar
expr_stmt|;
comment|/* XXX */
name|savlevel
operator|=
name|level
expr_stmt|;
name|v
operator|.
name|hp
operator|=
name|level
operator|=
literal|0
expr_stmt|;
name|savapts
operator|=
name|apts
expr_stmt|;
name|savapts1
operator|=
name|apts1
expr_stmt|;
name|savfont
operator|=
name|font
expr_stmt|;
name|savfont1
operator|=
name|font1
expr_stmt|;
name|savpts
operator|=
name|pts
expr_stmt|;
name|savpts1
operator|=
name|pts1
expr_stmt|;
name|setwdf
operator|++
expr_stmt|;
while|while
condition|(
name|cbits
argument_list|(
name|i
operator|=
name|getch
argument_list|()
argument_list|)
operator|!=
name|delim
operator|&&
operator|!
name|nlflg
condition|)
block|{
name|wid
operator|+=
name|width
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ismot
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|em
operator|=
name|POINT
operator|*
name|xpts
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isvmot
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|k
operator|=
name|absmot
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnmot
argument_list|(
name|i
argument_list|)
condition|)
name|k
operator|=
operator|-
name|k
expr_stmt|;
name|base
operator|-=
name|k
expr_stmt|;
name|em
operator|=
literal|0
expr_stmt|;
block|}
else|else
continue|continue;
if|if
condition|(
name|base
operator|<
name|v
operator|.
name|sb
condition|)
name|v
operator|.
name|sb
operator|=
name|base
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|base
operator|+
name|em
operator|)
operator|>
name|v
operator|.
name|st
condition|)
name|v
operator|.
name|st
operator|=
name|k
expr_stmt|;
block|}
name|nform
operator|=
literal|0
expr_stmt|;
name|setn1
argument_list|(
name|wid
argument_list|)
expr_stmt|;
name|v
operator|.
name|hp
operator|=
name|savhp
expr_stmt|;
name|pinchar
operator|=
name|savpinchar
expr_stmt|;
comment|/* XXX */
for|for
control|(
name|p
operator|=
name|inchar
operator|,
name|q
operator|=
name|tempinchar
init|;
name|p
operator|<
name|pinchar
condition|;
control|)
comment|/* XXX */
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
comment|/* XXX */
name|level
operator|=
name|savlevel
expr_stmt|;
name|apts
operator|=
name|savapts
expr_stmt|;
name|apts1
operator|=
name|savapts1
expr_stmt|;
name|font
operator|=
name|savfont
expr_stmt|;
name|font1
operator|=
name|savfont1
expr_stmt|;
name|pts
operator|=
name|savpts
expr_stmt|;
name|pts1
operator|=
name|savpts1
expr_stmt|;
name|mchbits
argument_list|()
expr_stmt|;
name|setwdf
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|tchar
name|vmot
parameter_list|()
block|{
name|dfact
operator|=
name|lss
expr_stmt|;
name|vflag
operator|++
expr_stmt|;
return|return
operator|(
name|mot
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|tchar
name|hmot
parameter_list|()
block|{
name|dfact
operator|=
name|EM
expr_stmt|;
return|return
operator|(
name|mot
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|tchar
name|mot
parameter_list|()
block|{
specifier|register
name|short
name|j
decl_stmt|,
name|n
decl_stmt|;
name|tchar
name|i
decl_stmt|;
name|j
operator|=
name|HOR
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
comment|/*eat delim*/
if|if
condition|(
name|n
operator|=
name|atoi
argument_list|()
condition|)
block|{
if|if
condition|(
name|vflag
condition|)
name|j
operator|=
name|VERT
expr_stmt|;
name|i
operator|=
name|makem
argument_list|(
name|quant
argument_list|(
name|n
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
name|vflag
operator|=
literal|0
expr_stmt|;
name|dfact
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
name|tchar
name|sethl
parameter_list|(
name|k
parameter_list|)
name|int
name|k
decl_stmt|;
block|{
specifier|register
name|j
expr_stmt|;
name|tchar
name|i
decl_stmt|;
name|j
operator|=
name|EM
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|'u'
condition|)
name|j
operator|=
operator|-
name|j
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|==
literal|'r'
condition|)
name|j
operator|=
operator|-
literal|2
operator|*
name|j
expr_stmt|;
name|vflag
operator|++
expr_stmt|;
name|i
operator|=
name|makem
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|vflag
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
name|tchar
name|makem
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|tchar
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|i
operator|)
operator|<
literal|0
condition|)
name|j
operator|=
operator|-
name|j
expr_stmt|;
name|j
operator||=
name|MOT
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|j
operator||=
name|NMOT
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|j
operator||=
name|VMOT
expr_stmt|;
return|return
operator|(
name|j
operator|)
return|;
block|}
end_function

begin_function
name|tchar
name|getlg
parameter_list|(
name|i
parameter_list|)
name|tchar
name|i
decl_stmt|;
block|{
name|tchar
name|j
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|int
name|lf
decl_stmt|;
if|if
condition|(
operator|(
name|lf
operator|=
name|fontbase
index|[
name|fbits
argument_list|(
name|i
argument_list|)
index|]
operator|->
name|ligfont
operator|)
operator|==
literal|0
condition|)
comment|/* the font has no ligatures */
return|return
operator|(
name|i
operator|)
return|;
name|j
operator|=
name|getch0
argument_list|()
expr_stmt|;
if|if
condition|(
name|cbits
argument_list|(
name|j
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|lf
operator|&
name|LFI
operator|)
condition|)
name|j
operator|=
name|LIG_FI
expr_stmt|;
elseif|else
if|if
condition|(
name|cbits
argument_list|(
name|j
argument_list|)
operator|==
literal|'l'
operator|&&
operator|(
name|lf
operator|&
name|LFL
operator|)
condition|)
name|j
operator|=
name|LIG_FL
expr_stmt|;
elseif|else
if|if
condition|(
name|cbits
argument_list|(
name|j
argument_list|)
operator|==
literal|'f'
operator|&&
operator|(
name|lf
operator|&
name|LFF
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|lf
operator|&
operator|(
name|LFFI
operator||
name|LFFL
operator|)
operator|)
operator|&&
name|lg
operator|!=
literal|2
condition|)
block|{
name|k
operator|=
name|getch0
argument_list|()
expr_stmt|;
if|if
condition|(
name|cbits
argument_list|(
name|k
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|lf
operator|&
name|LFFI
operator|)
condition|)
name|j
operator|=
name|LIG_FFI
expr_stmt|;
elseif|else
if|if
condition|(
name|cbits
argument_list|(
name|k
argument_list|)
operator|==
literal|'l'
operator|&&
operator|(
name|lf
operator|&
name|LFFL
operator|)
condition|)
name|j
operator|=
name|LIG_FFL
expr_stmt|;
else|else
block|{
name|ch0
operator|=
name|k
expr_stmt|;
name|j
operator|=
name|LIG_FF
expr_stmt|;
block|}
block|}
else|else
name|j
operator|=
name|LIG_FF
expr_stmt|;
block|}
else|else
block|{
name|ch0
operator|=
name|j
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|&
name|SFMASK
operator||
name|j
operator|)
return|;
block|}
end_function

begin_macro
name|caselg
argument_list|()
end_macro

begin_block
block|{
name|lg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|skip
argument_list|()
condition|)
return|return;
name|lg
operator|=
name|atoi
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|casefp
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|dir
index|[
literal|50
index|]
decl_stmt|;
name|skip
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|cbits
argument_list|(
name|getch
argument_list|()
argument_list|)
operator|-
literal|'0'
operator|)
operator|<=
literal|0
operator|||
name|i
operator|>
name|nfonts
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"troff: fp: bad font position %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|skip
argument_list|()
operator|||
operator|!
operator|(
name|j
operator|=
name|getrq
argument_list|()
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"troff: fp: no font name\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|skip
argument_list|()
expr_stmt|;
name|setfp
argument_list|(
name|i
argument_list|,
name|j
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|setfp
argument_list|(
argument|pos
argument_list|,
argument|f
argument_list|,
argument|d
argument_list|)
end_macro

begin_comment
comment|/* mount font f at position pos[0...nfonts] */
end_comment

begin_decl_stmt
name|int
name|pos
decl_stmt|,
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|j
operator|,
name|k
expr_stmt|;
name|int
name|n
decl_stmt|;
name|char
name|longname
index|[
name|NS
index|]
decl_stmt|,
name|shortname
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|extern
name|int
name|nchtab
decl_stmt|;
name|shortname
index|[
literal|0
index|]
operator|=
name|f
operator|&
name|BMASK
expr_stmt|;
name|shortname
index|[
literal|1
index|]
operator|=
name|f
operator|>>
name|BYTE
expr_stmt|;
name|shortname
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
comment|/* normal case */
name|sprintf
argument_list|(
name|longname
argument_list|,
literal|"%s/dev%s/%s.out"
argument_list|,
name|fontfile
argument_list|,
name|devname
argument_list|,
name|shortname
argument_list|)
expr_stmt|;
else|else
comment|/* 3rd argument is a directory for the font */
name|sprintf
argument_list|(
name|longname
argument_list|,
literal|"%s/%s.out"
argument_list|,
name|fontfile
argument_list|,
name|shortname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|open
argument_list|(
name|longname
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"troff: Can't open %s\n"
argument_list|,
name|longname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|n
operator|=
name|fontbase
index|[
name|pos
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|read
argument_list|(
name|k
argument_list|,
name|fontbase
index|[
name|pos
index|]
argument_list|,
literal|3
operator|*
name|n
operator|+
name|nchtab
operator|+
literal|128
operator|-
literal|32
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
argument_list|)
expr_stmt|;
name|kerntab
index|[
name|pos
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|fontab
index|[
name|pos
index|]
operator|+
operator|(
name|fontbase
index|[
name|pos
index|]
operator|->
name|nwfont
operator|&
name|BMASK
operator|)
expr_stmt|;
comment|/* have to reset the fitab pointer because the width may be different */
name|fitab
index|[
name|pos
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|fontab
index|[
name|pos
index|]
operator|+
literal|3
operator|*
operator|(
name|fontbase
index|[
name|pos
index|]
operator|->
name|nwfont
operator|&
name|BMASK
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|fontbase
index|[
name|pos
index|]
operator|->
name|nwfont
operator|&
name|BMASK
operator|)
operator|>
name|n
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"troff: Font %s too big for position %d\n"
argument_list|,
name|shortname
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fontbase
index|[
name|pos
index|]
operator|->
name|nwfont
operator|=
name|n
expr_stmt|;
comment|/* so can load a larger one again later */
name|close
argument_list|(
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|smnt
condition|)
block|{
name|smnt
operator|=
literal|0
expr_stmt|;
name|sbold
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fontlab
index|[
name|pos
index|]
operator|=
name|f
operator|)
operator|==
literal|'S'
condition|)
name|smnt
operator|=
name|pos
expr_stmt|;
name|bdtab
index|[
name|pos
index|]
operator|=
name|cstab
index|[
name|pos
index|]
operator|=
name|ccstab
index|[
name|pos
index|]
operator|=
literal|0
expr_stmt|;
comment|/* if there is a directory, no place to store its name. */
comment|/* if position isn't zero, no place to store its value. */
comment|/* only time a FONTPOS is pushed back is if it's a */
comment|/* standard font on position 0 (i.e., mounted implicitly. */
comment|/* there's a bug here:  if there are several input lines */
comment|/* that look like .ft XX in short successtion, the output */
comment|/* will all be in the last one because the "x font ..." */
comment|/* comes out too soon.  pushing back FONTPOS doesn't work */
comment|/* with .ft commands because input is flushed after .xx cmds */
name|ptfpcmd
argument_list|(
name|pos
argument_list|,
name|shortname
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
operator|&&
name|pos
operator|==
literal|0
condition|)
name|ch
operator|=
operator|(
name|tchar
operator|)
name|FONTPOS
operator||
operator|(
name|tchar
operator|)
name|f
operator|<<
literal|16
expr_stmt|;
return|return
operator|(
name|pos
operator|)
return|;
block|}
end_block

begin_macro
name|casecs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|noscale
operator|++
expr_stmt|;
name|skip
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|=
name|getrq
argument_list|()
operator|)
operator|||
operator|(
name|i
operator|=
name|findft
argument_list|(
name|i
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|rtn
goto|;
name|skip
argument_list|()
expr_stmt|;
name|cstab
index|[
name|i
index|]
operator|=
name|atoi
argument_list|()
expr_stmt|;
name|skip
argument_list|()
expr_stmt|;
name|j
operator|=
name|atoi
argument_list|()
expr_stmt|;
if|if
condition|(
name|nonumb
condition|)
name|ccstab
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|ccstab
index|[
name|i
index|]
operator|=
name|findps
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|rtn
label|:
name|noscale
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|casebd
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
operator|,
name|k
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
name|bd0
label|:
if|if
condition|(
name|skip
argument_list|()
operator|||
operator|!
operator|(
name|i
operator|=
name|getrq
argument_list|()
operator|)
operator|||
operator|(
name|j
operator|=
name|findft
argument_list|(
name|i
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|k
condition|)
goto|goto
name|bd1
goto|;
else|else
return|return;
block|}
if|if
condition|(
name|j
operator|==
name|smnt
condition|)
block|{
name|k
operator|=
name|smnt
expr_stmt|;
goto|goto
name|bd0
goto|;
block|}
if|if
condition|(
name|k
condition|)
block|{
name|sbold
operator|=
name|j
expr_stmt|;
name|j
operator|=
name|k
expr_stmt|;
block|}
name|bd1
label|:
name|skip
argument_list|()
expr_stmt|;
name|noscale
operator|++
expr_stmt|;
name|bdtab
index|[
name|j
index|]
operator|=
name|atoi
argument_list|()
expr_stmt|;
name|noscale
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|casevs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|skip
argument_list|()
expr_stmt|;
name|vflag
operator|++
expr_stmt|;
name|dfact
operator|=
name|INCH
expr_stmt|;
comment|/* default scaling is points! */
name|dfactd
operator|=
literal|72
expr_stmt|;
name|res
operator|=
name|VERT
expr_stmt|;
name|i
operator|=
name|inumb
argument_list|(
operator|&
name|lss
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonumb
condition|)
name|i
operator|=
name|lss1
expr_stmt|;
comment|/*	if(i< VERT)i = VERT; */
if|if
condition|(
name|i
operator|<
name|VERT
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|lss1
operator|=
name|lss
expr_stmt|;
name|lss
operator|=
name|i
expr_stmt|;
block|}
end_block

begin_macro
name|casess
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|noscale
operator|++
expr_stmt|;
name|skip
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|atoi
argument_list|()
condition|)
block|{
name|spacesz
operator|=
name|i
operator|&
literal|0177
expr_stmt|;
name|sps
operator|=
name|width
argument_list|(
literal|' '
operator||
name|chbits
argument_list|)
expr_stmt|;
block|}
name|noscale
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|tchar
name|xlss
parameter_list|()
block|{
comment|/* stores \x'...' into 	/* two successive tchars. 	/* the first contains HX, the second the value, 	/* encoded as a vertical motion. 	/* decoding is done in n2.c by pchar(). 	*/
name|int
name|i
decl_stmt|;
name|tchar
name|c
decl_stmt|;
name|getch
argument_list|()
expr_stmt|;
name|dfact
operator|=
name|lss
expr_stmt|;
name|i
operator|=
name|quant
argument_list|(
name|atoi
argument_list|()
argument_list|,
name|VERT
argument_list|)
expr_stmt|;
name|dfact
operator|=
literal|1
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|ch0
operator|=
name|MOT
operator||
name|VMOT
operator||
name|i
expr_stmt|;
else|else
name|ch0
operator|=
name|MOT
operator||
name|VMOT
operator||
name|NMOT
operator||
operator|-
name|i
expr_stmt|;
name|c
operator|=
name|HX
expr_stmt|;
name|dummy
argument_list|()
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

end_unit

