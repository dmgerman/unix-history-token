begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)short.c	1.2	%G%  *  * Copyright -C- 1982 Barry S. Roitblat  *  *  *      This file contains routines to implement the short commands  * of the gremlin picture editor.  *  */
end_comment

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_include
include|#
directive|include
file|"grem2.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_comment
comment|/* imports from graphics files */
end_comment

begin_extern
extern|extern GRVector(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|GRPutText
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern GRCurve(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern GRClear(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|int
name|GRArc
parameter_list|()
function_decl|;
end_function_decl

begin_extern
extern|extern charxsize
operator|,
extern|charysize;
end_extern

begin_comment
comment|/* imports from display.c */
end_comment

begin_extern
extern|extern DISScreenAdd(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|DISScreenErase
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern DISDisplaySet(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|DISEraseSet
argument_list|()
operator|,
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* imports from database files */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|DBInit
argument_list|()
decl_stmt|,
modifier|*
name|DBCreateElt
argument_list|()
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern DBDelete(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|DBGravitate
argument_list|()
operator|,
name|DBClearElt
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|extern
name|ELT
modifier|*
name|DBCopy
parameter_list|()
function_decl|;
end_function_decl

begin_extern
extern|extern DBXform(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|DBBounded
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern DBAddSet(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|DBClearSet
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|POINT
modifier|*
name|PTInit
argument_list|()
decl_stmt|,
modifier|*
name|PTMakePoint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern PTDeletePoint(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from long.c */
end_comment

begin_extern
extern|extern LGIncludeSet(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from menu.c  */
end_comment

begin_extern
extern|extern MNHighLt(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|MNUnHighLt
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern HiMen[]
operator|,
extern|HiFont[]
operator|,
extern|HiBrush[]
operator|,
extern|HiMode[];
end_extern

begin_decl_stmt
name|int
name|adj
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imports from textio.c */
end_comment

begin_extern
extern|extern TxMsgOK(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|TxPutString
argument_list|()
operator|,
name|TxGetLine
argument_list|()
operator|,
name|TxRedisplay
argument_list|()
operator|,
name|TxPutMsg
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|extern
name|char
name|TxGetChar
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|TXFIELD
name|TAlign
decl_stmt|,
name|TAdjust
decl_stmt|,
name|TBrush
decl_stmt|,
name|TFont
decl_stmt|,
name|TGravity
decl_stmt|,
name|TCSize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|TXFIELD
name|TEdit
decl_stmt|,
name|TJustmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imports from c */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|sprintf
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* imports from main.c */
end_comment

begin_extern
extern|extern globinit(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* global initialization routine */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|PICTURE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current PICTURE database      */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|cset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current set database          */
end_comment

begin_extern
extern|extern CBRUSH
operator|,
extern|CSIZE
operator|,
extern|CFONT;
end_extern

begin_comment
comment|/* current brush, size, font     */
end_comment

begin_extern
extern|extern CJUST;
end_extern

begin_comment
comment|/* text justification mode       */
end_comment

begin_extern
extern|extern Gridon;
end_extern

begin_comment
comment|/* grid mode flag                */
end_comment

begin_extern
extern|extern Orientation;
end_extern

begin_comment
comment|/* orientation of workspace      */
end_comment

begin_extern
extern|extern Alignment;
end_extern

begin_comment
comment|/* point alignment indicator     */
end_comment

begin_decl_stmt
specifier|extern
name|float
name|PX
decl_stmt|,
name|PY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cursor coordinates            */
end_comment

begin_decl_stmt
specifier|extern
name|float
name|Lastx
decl_stmt|,
name|Lasty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* previous cursor coordinates   */
end_comment

begin_extern
extern|extern SEQ;
end_extern

begin_comment
comment|/* point sequence number         */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Editfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current edit file             */
end_comment

begin_decl_stmt
specifier|extern
name|POINT
modifier|*
name|POINTLIST
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* accumulated point list        */
end_comment

begin_extern
extern|extern Adjustment;
end_extern

begin_comment
comment|/* point adjustment mode         */
end_comment

begin_extern
extern|extern GravityOn;
end_extern

begin_comment
comment|/* gravity mode flag             */
end_comment

begin_extern
extern|extern Consume;
end_extern

begin_comment
comment|/* point clear flag              */
end_comment

begin_extern
extern|extern CHANGED;
end_extern

begin_comment
comment|/* PICTURE changed flag          */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|MEN
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers for user symbols     */
end_comment

begin_decl_stmt
specifier|extern
name|POINT
name|MENPOINT
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers used fo user symbols */
end_comment

begin_extern
extern|extern cmdbuf[];
end_extern

begin_comment
comment|/* line buffer for commands      */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
name|arhead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* arrow head template           */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|textpos
index|[]
decl_stmt|,
modifier|*
name|dispmode
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* text positioning modes        */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|textmode
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* text positioning              */
end_comment

begin_extern
extern|extern SHUpdate(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|SHDrawArc
argument_list|()
operator|,
name|SHDrawCurve
argument_list|()
operator|,
name|SHCopy
argument_list|()
operator|,
name|SHRedis
argument_list|()
operator|,
name|SHDefineSet
argument_list|()
operator|,
name|SHErase
argument_list|()
operator|,
name|SHSetArea
argument_list|()
operator|,
name|SHGravity
argument_list|()
operator|,
name|SHGrid
argument_list|()
operator|,
name|SHRotate
argument_list|()
operator|,
name|SHScale
argument_list|()
operator|,
name|SHTranslate
argument_list|()
operator|,
name|SHShellEsc
argument_list|()
operator|,
name|SHDrawVector
argument_list|()
operator|,
name|SHMAdjust
argument_list|()
operator|,
name|SHBox
argument_list|()
operator|,
name|SHArrow
argument_list|()
operator|,
name|SHSave1
argument_list|()
operator|,
name|SHSave2
argument_list|()
operator|,
name|SHSave3
argument_list|()
operator|,
name|SHSave4
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The following two arrays define the short commands and the routines  * that process them.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|shcmds
index|[]
init|=
block|{
literal|'\14'
block|,
literal|'!'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|'l'
block|,
literal|'q'
block|,
literal|'r'
block|,
literal|'s'
block|,
literal|'t'
block|,
literal|'v'
block|,
literal|'w'
block|,
literal|'x'
block|,
literal|'z'
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
operator|(
operator|*
operator|(
name|shrtns
index|[]
operator|)
operator|)
operator|(
operator|)
operator|=
block|{
name|SHUpdate
block|,
comment|/* redraw screen */
name|SHShellEsc
block|,
comment|/* shell escape */
name|SHSave1
block|,
comment|/* save user symbol */
name|SHSave2
block|,
comment|/* save user symbol */
name|SHSave3
block|,
comment|/* save user symbol */
name|SHSave4
block|,
comment|/* save user symbol */
name|SHDrawArc
block|,
comment|/* draw arc */
name|SHDrawCurve
block|,
comment|/* draw curve */
name|SHCopy
block|,
comment|/* copy current set */
name|SHDefineSet
block|,
comment|/* define current set */
name|SHErase
block|,
comment|/* erase elements */
name|SHSetArea
block|,
comment|/* select area for current set */
name|SHGravity
block|,
comment|/* gravity */
name|SHRedis
block|,
comment|/* text screen redisplay */
name|SHGrid
block|,
comment|/* toggle grid display */
name|SHRotate
block|,
comment|/* rotate current set */
name|SHScale
block|,
comment|/* scale current set */
name|SHTranslate
block|,
comment|/* translate current set */
name|SHDrawVector
block|,
comment|/* draw vectors */
name|SHArrow
block|,
comment|/* arrowhead */
name|SHBox
block|,
comment|/* rectangle from two points */
name|SHMAdjust
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* manhattan adjust */
end_comment

begin_function
name|int
name|SHLookup
parameter_list|(
name|c
parameter_list|,
name|table
parameter_list|)
name|char
name|c
decl_stmt|;
comment|/* Pointer to a char to be looked up */
name|char
name|table
index|[]
decl_stmt|;
comment|/* Pointer to an array of characters 				 * which are the valid commands.  The array 				 * must be sorted by ascii value. 				 */
comment|/*---------------------------------------------------------  *	SHLookup searches a table of characters to find one that matches a  *	the given character.  *  *      Results: If c is a valid command character, its index is   * returned, otherwise, if c is the null command, -2 is returned  * else -1 is returned.  *  *	Side Effects:	None.  *  * (Modified from software written by John Ousterhout for the caesar  *  program)  *---------------------------------------------------------  */
block|{
name|int
name|index
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|' '
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|table
index|[
name|index
index|]
operator|!=
literal|'\0'
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|table
index|[
name|index
index|]
operator|==
name|c
condition|)
return|return
operator|(
name|index
operator|)
return|;
if|if
condition|(
name|table
index|[
name|index
index|]
operator|>
name|c
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end SHLookup */
end_comment

begin_macro
name|SHCommand
argument_list|(
argument|command
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*---------------------------------------------------------  *	This routine reads in, looks up, and executes a long command.  *  *	Results:	None.  *  *	Side Effects:  *	Depends on the command that is invoked.  *---------------------------------------------------------  */
end_comment

begin_block
block|{
name|int
name|index
decl_stmt|;
name|index
operator|=
name|SHLookup
argument_list|(
operator|*
name|command
argument_list|,
name|shcmds
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|2
condition|)
return|return;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
operator|(
operator|*
operator|(
name|shrtns
index|[
name|index
index|]
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"no such command"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end SHCommand */
end_comment

begin_decl_stmt
specifier|static
name|char
name|nopnt
index|[
literal|18
index|]
init|=
literal|"not enough points"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|noset
index|[
literal|15
index|]
init|=
literal|"no current set"
decl_stmt|;
end_decl_stmt

begin_macro
name|SHDrawVector
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine creates and displays a VECTOR element from the  * points previously specified.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|e1
decl_stmt|;
name|POINT
modifier|*
name|plist
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|char
modifier|*
name|txt
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
comment|/* not enough points */
block|{
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
name|DBClearSet
argument_list|()
expr_stmt|;
comment|/* Clear current set in preparation */
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
comment|/* for making this the new one */
name|GRsetwmask
argument_list|(
name|linemask
operator||
name|setmask
argument_list|)
expr_stmt|;
name|plist
operator|=
name|PTInit
argument_list|()
expr_stmt|;
name|p1
operator|=
name|POINTLIST
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|p2
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p2
operator|->
name|x
argument_list|,
name|p2
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
name|GRVector
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|CBRUSH
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p2
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
empty_stmt|;
name|txt
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|txt
operator|=
literal|'\0'
expr_stmt|;
name|e1
operator|=
name|DBCreateElt
argument_list|(
name|VECTOR
argument_list|,
name|plist
argument_list|,
name|CBRUSH
argument_list|,
literal|0
argument_list|,
name|txt
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHDrawVector */
end_comment

begin_define
define|#
directive|define
name|twoPi
value|6.2832
end_define

begin_macro
name|SHDrawArc
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine creates and displays an ARC element based on the   * points previously defined.  If 3 or more points are defined, the  * extent of the arc is calculated as the angle formed by the   * respective lines through the second and third points and the first  * point.  If only 2 points are specified, a full circle is drawn.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|e1
decl_stmt|;
name|POINT
modifier|*
name|plist
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|char
modifier|*
name|txt
decl_stmt|;
name|double
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|angle
decl_stmt|,
name|radius
decl_stmt|;
name|int
name|stat
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
comment|/* not enough points */
block|{
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
name|plist
operator|=
name|PTInit
argument_list|()
expr_stmt|;
name|p1
operator|=
name|POINTLIST
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|radius
operator|=
name|sqrt
argument_list|(
name|pow
argument_list|(
operator|(
name|p2
operator|->
name|x
operator|-
name|p1
operator|->
name|x
operator|)
argument_list|,
literal|2.0
argument_list|)
operator|+
name|pow
argument_list|(
operator|(
name|p2
operator|->
name|y
operator|-
name|p1
operator|->
name|y
operator|)
argument_list|,
literal|2.0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEQ
operator|==
literal|2
condition|)
comment|/* draw full circle */
block|{
name|angle
operator|=
literal|0
expr_stmt|;
comment|/* Add extra positioning points  */
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p2
operator|->
name|x
argument_list|,
name|p2
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
operator|+
name|radius
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
operator|-
name|radius
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
operator|+
name|radius
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
operator|-
name|radius
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
block|}
comment|/* end if */
else|else
block|{
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|POINTLIST
operator|->
name|x
argument_list|,
name|POINTLIST
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|a1
operator|=
name|atan2
argument_list|(
operator|(
name|p1
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
operator|(
name|p1
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
operator|)
argument_list|)
expr_stmt|;
name|a2
operator|=
name|atan2
argument_list|(
operator|(
name|p2
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
operator|(
name|p2
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
operator|)
argument_list|)
expr_stmt|;
name|angle
operator|=
name|a1
operator|-
name|a2
expr_stmt|;
if|if
condition|(
name|angle
operator|<
literal|0.0
condition|)
name|angle
operator|+=
name|twoPi
expr_stmt|;
comment|/* Set second point to lie on arc */
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
operator|(
name|radius
operator|*
name|sin
argument_list|(
name|a2
argument_list|)
operator|+
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
operator|(
name|radius
operator|*
name|cos
argument_list|(
name|a2
argument_list|)
operator|+
name|POINTLIST
operator|->
name|y
operator|)
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
name|angle
operator|*=
literal|360.0
operator|/
name|twoPi
expr_stmt|;
comment|/* convert to degrees */
block|}
empty_stmt|;
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
comment|/* Clear current set, this element becomes */
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
comment|/* the new current set                     */
name|GRsetwmask
argument_list|(
name|linemask
operator||
name|setmask
argument_list|)
expr_stmt|;
name|stat
operator|=
name|GRArc
argument_list|(
name|POINTLIST
argument_list|,
name|p1
argument_list|,
name|angle
argument_list|,
name|CBRUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|>
operator|-
literal|1
condition|)
block|{
name|txt
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|txt
operator|=
literal|'\0'
expr_stmt|;
name|e1
operator|=
name|DBCreateElt
argument_list|(
name|ARC
argument_list|,
name|plist
argument_list|,
name|CBRUSH
argument_list|,
call|(
name|int
call|)
argument_list|(
name|angle
operator|+
literal|0.5
argument_list|)
argument_list|,
name|txt
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end SHDrawARc */
end_comment

begin_macro
name|SHDrawCurve
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine creates and displays a curve using points previously  * defined.  This is dependent on DISCurve which is not yet implemented.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|e1
decl_stmt|;
name|char
modifier|*
name|txt
decl_stmt|;
name|POINT
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|plist
decl_stmt|;
name|int
name|stat
decl_stmt|;
name|stat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
comment|/* not enough points */
block|{
name|error
argument_list|(
literal|"need at least 2 points"
argument_list|)
expr_stmt|;
return|return;
block|}
name|plist
operator|=
name|PTInit
argument_list|()
expr_stmt|;
name|p1
operator|=
name|POINTLIST
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|p2
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p2
operator|->
name|x
argument_list|,
name|p2
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p2
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
empty_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
comment|/* Clear current set, this element */
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
comment|/* the new current set             */
name|GRsetwmask
argument_list|(
name|linemask
operator||
name|setmask
argument_list|)
expr_stmt|;
name|stat
operator|=
name|GRCurve
argument_list|(
name|plist
argument_list|,
name|CBRUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
literal|0
condition|)
comment|/* bad knots */
block|{
name|error
argument_list|(
literal|"too many consecutive knots at same place"
argument_list|)
expr_stmt|;
return|return;
block|}
name|txt
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|txt
operator|=
literal|'\0'
expr_stmt|;
name|e1
operator|=
name|DBCreateElt
argument_list|(
name|CURVE
argument_list|,
name|plist
argument_list|,
name|CBRUSH
argument_list|,
literal|0
argument_list|,
name|txt
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHDrawCurve */
end_comment

begin_macro
name|SHErase
argument_list|()
end_macro

begin_comment
comment|/*  *     This routine erases selected elements from the screen and deletes  * them from the picture database.    */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|e1
decl_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
comment|/* delete elements in current set */
block|{
name|DISScreenErase
argument_list|(
name|cset
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|DBNextofSet
argument_list|(
name|cset
argument_list|)
expr_stmt|;
name|DBDelete
argument_list|(
name|cset
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|cset
operator|=
name|e1
expr_stmt|;
block|}
empty_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHErase */
end_comment

begin_macro
name|SHGravity
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine toggles the gravity mode.  */
end_comment

begin_block
block|{
if|if
condition|(
name|GravityOn
condition|)
block|{
name|MNUnHighLt
argument_list|(
name|HiMode
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|GravityOn
operator|=
name|FALSE
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TGravity
argument_list|,
literal|"OFF"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MNHighLt
argument_list|(
name|HiMode
index|[
literal|3
index|]
argument_list|,
name|hicolor
argument_list|)
expr_stmt|;
name|GravityOn
operator|=
name|TRUE
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TGravity
argument_list|,
literal|" ON"
argument_list|)
expr_stmt|;
block|}
name|Consume
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* End GravityOn */
end_comment

begin_macro
name|SHGrid
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine toggles the display of the grid   */
end_comment

begin_block
block|{
if|if
condition|(
name|Gridon
condition|)
block|{
name|Gridon
operator|=
name|FALSE
expr_stmt|;
name|GRBlankGrid
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Gridon
operator|=
name|TRUE
expr_stmt|;
name|GRDisplayGrid
argument_list|()
expr_stmt|;
block|}
name|Consume
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHGrid */
end_comment

begin_macro
name|SHMAdjust
argument_list|()
end_macro

begin_comment
comment|/*  * Manhattan Adjust -  *      This routine toggles the adjustment mode.  */
end_comment

begin_block
block|{
if|if
condition|(
name|Adjustment
operator|==
name|MAN
condition|)
block|{
name|MNUnHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|MAN
index|]
index|]
argument_list|)
expr_stmt|;
name|Adjustment
operator|=
name|NOADJ
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TAdjust
argument_list|,
literal|"NO ADJUSTMENT"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MNUnHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|Adjustment
index|]
index|]
argument_list|)
expr_stmt|;
name|MNHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|MAN
index|]
index|]
argument_list|,
name|hicolor
argument_list|)
expr_stmt|;
name|Adjustment
operator|=
name|MAN
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TAdjust
argument_list|,
literal|"  MANHATTAN  "
argument_list|)
expr_stmt|;
block|}
name|Consume
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_macro
name|SHDefineSet
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine defines the current set based upon previously  * defined points to select elements.  The action is performed by  * clearing the current set and calling LGIncludeSet.  */
end_comment

begin_block
block|{
name|DBClearSet
argument_list|()
expr_stmt|;
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
name|LGIncludeSet
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHDefineSet */
end_comment

begin_macro
name|SHSetArea
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine defines the current set by selecting all elements  * bounded by a rectangle whose diagonal is defined by specifed points.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|e1
decl_stmt|;
name|POINT
modifier|*
name|p1
decl_stmt|;
name|float
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
block|{
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
name|DBClearSet
argument_list|()
expr_stmt|;
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
name|x1
operator|=
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|y1
operator|=
name|POINTLIST
operator|->
name|y
expr_stmt|;
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
name|x2
operator|=
name|p1
operator|->
name|x
expr_stmt|;
name|y2
operator|=
name|p1
operator|->
name|y
expr_stmt|;
name|e1
operator|=
name|PICTURE
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
if|if
condition|(
name|DBBounded
argument_list|(
name|e1
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
condition|)
block|{
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|DISDisplaySet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
comment|/* end if */
name|e1
operator|=
name|DBNextElt
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
block|}
end_block

begin_comment
comment|/* end SHSetArea */
end_comment

begin_macro
name|SHTranslate
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine translates the elements in the current set as defined  * by points.  The translation is accomplished by defining a transformation  * matrix and calling DBXform.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|e1
decl_stmt|;
name|POINT
modifier|*
name|p1
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
comment|/* not enough points */
block|{
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|noset
argument_list|)
expr_stmt|;
return|return;
block|}
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* set up translation matrix */
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|p1
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|p1
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
expr_stmt|;
name|e1
operator|=
name|cset
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
name|DISScreenErase
argument_list|(
name|e1
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
name|DBXform
argument_list|(
name|e1
argument_list|,
name|xmat
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|DBNextofSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHTranslate */
end_comment

begin_macro
name|SHCopy
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine copies the elements in the current set as defined  * by points.  To copy, the current set pointer is cleared so that new  * elements as added by DBCopy can be used to comprise the new current  * set.  A pointer is maintained to the old current set which is traversed  * to determine the elements to be copied.  This process continues for all  * points specified.  *  * NOTE:  This assumes that the DBClearSet routine does not alter the  *        pointers between elements in the set (which is currently true),  *        and must be changed it this does not hold.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|e1
decl_stmt|,
modifier|*
name|e2
decl_stmt|;
name|POINT
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
comment|/* not enough points */
block|{
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|noset
argument_list|)
expr_stmt|;
return|return;
block|}
name|p1
operator|=
name|POINTLIST
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* set up translation matrix */
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|p2
operator|->
name|x
operator|-
name|p1
operator|->
name|x
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|p2
operator|->
name|y
operator|-
name|p1
operator|->
name|y
expr_stmt|;
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
name|e1
operator|=
name|cset
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
comment|/* Dependent on Clearset preserving pointers */
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
name|e2
operator|=
name|DBCopy
argument_list|(
name|e1
argument_list|,
name|xmat
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e2
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|e2
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|DBNextofSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
comment|/* end while ! null elt */
name|p1
operator|=
name|p2
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
comment|/* end while ! null point */
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHCopy */
end_comment

begin_macro
name|SHRotate
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine rotates the elements in the current set as defined  * by points.  The rotation is accomplished by defining a transformation  * matrix and calling DBXform.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|e1
decl_stmt|;
name|POINT
name|pos
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|,
name|angle
decl_stmt|,
name|s
decl_stmt|,
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|3
condition|)
comment|/* not enough points */
block|{
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|noset
argument_list|)
expr_stmt|;
return|return;
block|}
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
comment|/* calculate rotation angle */
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|angle
operator|=
operator|(
name|float
operator|)
name|atan2
argument_list|(
operator|(
name|p2
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
operator|(
name|p2
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
operator|)
argument_list|)
operator|-
operator|(
name|float
operator|)
name|atan2
argument_list|(
operator|(
name|p1
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
operator|(
name|p1
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|float
operator|)
name|sin
argument_list|(
name|angle
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|float
operator|)
name|cos
argument_list|(
name|angle
argument_list|)
expr_stmt|;
comment|/* Define transformation matrix to translate set to origin, rotate,       and translate back.                                              */
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|s
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
operator|(
operator|-
name|c
operator|)
operator|*
name|POINTLIST
operator|->
name|x
operator|-
name|s
operator|*
name|POINTLIST
operator|->
name|y
operator|+
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
operator|(
operator|-
name|c
operator|)
operator|*
name|POINTLIST
operator|->
name|y
operator|+
name|s
operator|*
name|POINTLIST
operator|->
name|x
operator|+
name|POINTLIST
operator|->
name|y
expr_stmt|;
name|e1
operator|=
name|cset
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
name|DISScreenErase
argument_list|(
name|e1
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
name|DBXform
argument_list|(
name|e1
argument_list|,
name|xmat
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEXT
argument_list|(
name|e1
operator|->
name|type
argument_list|)
condition|)
block|{
name|GRsetwmask
argument_list|(
name|textmask
operator||
name|setmask
argument_list|)
expr_stmt|;
name|p1
operator|=
name|e1
operator|->
name|ptlist
expr_stmt|;
name|GRPutText
argument_list|(
name|e1
operator|->
name|type
argument_list|,
name|p1
argument_list|,
name|e1
operator|->
name|brushf
argument_list|,
name|e1
operator|->
name|size
argument_list|,
name|e1
operator|->
name|textpt
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|e1
operator|->
name|textpt
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PTInit
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
comment|/* add extra positioning points */
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
operator|+
name|i
operator|*
name|charxsize
operator|/
literal|2
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
operator|+
name|i
operator|*
name|charxsize
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
name|e1
operator|->
name|ptlist
operator|=
name|p2
expr_stmt|;
block|}
comment|/* end if TEXT */
else|else
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|DBNextofSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHRotate */
end_comment

begin_macro
name|SHScale
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine scales the elements in the current set as defined  * by points.  The scaling is accomplished by defining a transformation  * matrix and calling DBXform.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|e1
decl_stmt|;
name|POINT
name|pos
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|scalex
decl_stmt|,
name|scaley
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|3
condition|)
comment|/* not enough points */
block|{
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|noset
argument_list|)
expr_stmt|;
return|return;
block|}
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|d1
operator|=
name|sqrt
argument_list|(
name|pow
argument_list|(
operator|(
name|p1
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
literal|2.0
argument_list|)
operator|+
name|pow
argument_list|(
operator|(
name|p1
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
operator|)
argument_list|,
literal|2.0
argument_list|)
argument_list|)
expr_stmt|;
name|d2
operator|=
name|sqrt
argument_list|(
name|pow
argument_list|(
operator|(
name|p2
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
literal|2.0
argument_list|)
operator|+
name|pow
argument_list|(
operator|(
name|p2
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
operator|)
argument_list|,
literal|2.0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d1
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"infinite scale"
argument_list|)
expr_stmt|;
return|return;
block|}
name|scalex
operator|=
name|scaley
operator|=
name|d2
operator|/
name|d1
expr_stmt|;
comment|/* create transformation matrix to translate set to origin,         performaing the scaling and translating back               */
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|scalex
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|scaley
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
operator|-
name|POINTLIST
operator|->
name|x
operator|*
operator|(
name|scalex
operator|-
literal|1.0
operator|)
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|POINTLIST
operator|->
name|y
operator|*
operator|(
name|scaley
operator|-
literal|1.0
operator|)
expr_stmt|;
name|e1
operator|=
name|cset
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
name|DISScreenErase
argument_list|(
name|e1
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
name|DBXform
argument_list|(
name|e1
argument_list|,
name|xmat
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEXT
argument_list|(
name|e1
operator|->
name|type
argument_list|)
condition|)
block|{
name|GRsetwmask
argument_list|(
name|textmask
operator||
name|setmask
argument_list|)
expr_stmt|;
name|p1
operator|=
name|e1
operator|->
name|ptlist
expr_stmt|;
name|GRPutText
argument_list|(
name|e1
operator|->
name|type
argument_list|,
name|p1
argument_list|,
name|e1
operator|->
name|brushf
argument_list|,
name|e1
operator|->
name|size
argument_list|,
name|e1
operator|->
name|textpt
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|e1
operator|->
name|textpt
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PTInit
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
comment|/* add extra positioning points */
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
operator|+
name|i
operator|*
name|charxsize
operator|/
literal|2
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
operator|+
name|i
operator|*
name|charxsize
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
name|e1
operator|->
name|ptlist
operator|=
name|p2
expr_stmt|;
block|}
comment|/* end if TEXT */
else|else
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|DBNextofSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHScale */
end_comment

begin_macro
name|SHUpdate
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine redraws the graphics screen by clearing the screen ,  * redisplaying the menu and adding each element back to the display.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|e1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|GRClear
argument_list|(
name|linemask
operator||
name|setmask
operator||
name|textmask
argument_list|)
expr_stmt|;
name|MNDisplayMenu
argument_list|()
expr_stmt|;
name|e1
operator|=
name|PICTURE
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
name|linemask
argument_list|)
expr_stmt|;
name|e1
operator|=
name|DBNextElt
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|e1
operator|=
name|cset
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
name|setmask
argument_list|)
expr_stmt|;
name|e1
operator|=
name|DBNextofSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|Adjustment
operator|!=
name|NOADJ
condition|)
name|MNHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|Adjustment
index|]
index|]
argument_list|,
name|hicolor
argument_list|)
expr_stmt|;
if|if
condition|(
name|GravityOn
condition|)
name|MNHighLt
argument_list|(
name|HiMode
index|[
literal|3
index|]
argument_list|,
name|hicolor
argument_list|)
expr_stmt|;
comment|/* re highlight  */
name|MNHighLt
argument_list|(
name|HiFont
index|[
name|CFONT
operator|-
literal|1
index|]
argument_list|,
name|hicolor
argument_list|)
expr_stmt|;
comment|/* selected menu */
name|MNHighLt
argument_list|(
name|HiBrush
index|[
name|CBRUSH
operator|-
literal|1
index|]
argument_list|,
name|hicolor
argument_list|)
expr_stmt|;
comment|/* menu attributes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUSER
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|DBNullelt
argument_list|(
name|MEN
index|[
name|i
index|]
argument_list|)
condition|)
name|MNHighLt
argument_list|(
name|HiMen
index|[
name|i
index|]
argument_list|,
name|hicolor
argument_list|)
expr_stmt|;
name|Consume
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHUpdate */
end_comment

begin_macro
name|SHRedis
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine is used to redisplay the text screen.  * It clears the screen, then redisplays the text and each of the   * defined fields.  */
end_comment

begin_block
block|{
name|char
name|string
index|[
literal|4
index|]
decl_stmt|;
name|TxRedisplay
argument_list|()
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TEdit
argument_list|,
name|Editfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%1d"
argument_list|,
name|CBRUSH
argument_list|)
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TBrush
argument_list|,
name|string
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%1d"
argument_list|,
name|CFONT
argument_list|)
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TFont
argument_list|,
name|string
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%1d"
argument_list|,
name|CSIZE
argument_list|)
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TCSize
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TJustmode
argument_list|,
name|dispmode
index|[
name|CJUST
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%3d"
argument_list|,
name|Alignment
argument_list|)
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TAlign
argument_list|,
name|string
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%1d"
argument_list|,
name|CBRUSH
argument_list|)
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TBrush
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|GravityOn
condition|)
name|TxPutString
argument_list|(
operator|&
name|TGravity
argument_list|,
literal|" ON"
argument_list|)
expr_stmt|;
else|else
name|TxPutString
argument_list|(
operator|&
name|TGravity
argument_list|,
literal|"OFF"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Adjustment
condition|)
block|{
case|case
name|NOADJ
case|:
name|TxPutString
argument_list|(
operator|&
name|TAdjust
argument_list|,
literal|"NO ADJUSTMENT"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HORZ
case|:
name|TxPutString
argument_list|(
operator|&
name|TAdjust
argument_list|,
literal|" HORIZONTAL  "
argument_list|)
expr_stmt|;
break|break;
case|case
name|VERT
case|:
name|TxPutString
argument_list|(
operator|&
name|TAdjust
argument_list|,
literal|"  VERTICAL   "
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAN
case|:
name|TxPutString
argument_list|(
operator|&
name|TAdjust
argument_list|,
literal|"  MANHATTAN  "
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* end switch */
empty_stmt|;
name|Consume
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHRedis */
end_comment

begin_macro
name|SHShellEsc
argument_list|()
end_macro

begin_comment
comment|/*   *      This routine performs a shell escape through the c 'system'  * function.  It first retrieves the command line through TxGetLine.  */
end_comment

begin_block
block|{
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
name|TxGetLine
argument_list|(
literal|"!"
argument_list|,
name|line
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|TxClose
argument_list|()
expr_stmt|;
comment|/* Restore text terminal to 'normal' state */
operator|(
name|void
operator|)
name|system
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* do command */
comment|/* allow time for user to digest command */
name|printf
argument_list|(
literal|"Type<cr> to continue"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|line
index|[
literal|1
index|]
operator|=
name|TxGetChar
argument_list|()
expr_stmt|;
name|SHRedis
argument_list|()
expr_stmt|;
comment|/* reclaim terminal */
block|}
end_block

begin_comment
comment|/* end ShellEsc */
end_comment

begin_expr_stmt
specifier|static
name|savemen
argument_list|(
argument|sym
argument_list|)
name|int
name|sym
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  *      This local routine stores the current set in the specified  * user symbol.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|elist
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* set up copy transformation */
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* matrix for no              */
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* transformation             */
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|MEN
index|[
name|sym
index|]
argument_list|)
condition|)
block|{
comment|/* clear out existing symbol */
name|elist
operator|=
name|DBNextElt
argument_list|(
name|MEN
index|[
name|sym
index|]
argument_list|)
expr_stmt|;
name|DBClearElt
argument_list|(
name|MEN
index|[
name|sym
index|]
argument_list|)
expr_stmt|;
name|MEN
index|[
name|sym
index|]
operator|=
name|elist
expr_stmt|;
block|}
empty_stmt|;
name|elist
operator|=
name|cset
expr_stmt|;
comment|/* copy current set to symbol */
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elist
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|DBCopy
argument_list|(
name|elist
argument_list|,
name|xmat
argument_list|,
operator|&
operator|(
name|MEN
index|[
name|sym
index|]
operator|)
argument_list|)
expr_stmt|;
name|elist
operator|=
name|DBNextofSet
argument_list|(
name|elist
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
empty_stmt|;
if|if
condition|(
name|SEQ
operator|=
literal|0
condition|)
comment|/* no positioning points */
block|{
name|MENPOINT
index|[
name|sym
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|MENPOINT
index|[
name|sym
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|MENPOINT
index|[
name|sym
index|]
operator|.
name|x
operator|=
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|MENPOINT
index|[
name|sym
index|]
operator|.
name|y
operator|=
name|POINTLIST
operator|->
name|y
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DBNullelt
argument_list|(
name|MEN
index|[
name|sym
index|]
argument_list|)
condition|)
name|MNHighLt
argument_list|(
name|HiMen
index|[
name|sym
index|]
argument_list|,
name|hicolor
argument_list|)
expr_stmt|;
else|else
name|MNUnHighLt
argument_list|(
name|HiMen
index|[
name|sym
index|]
argument_list|)
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end savemen */
end_comment

begin_macro
name|SHSave1
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine saves the current set in user symbol 1 by  * calling savemen.  */
end_comment

begin_block
block|{
name|savemen
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SHSave2
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine saves the current set in user symbol 2 by  * calling savemen.  */
end_comment

begin_block
block|{
name|savemen
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SHSave3
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine saves the current set in user symbol 3 by  * calling savemen.  */
end_comment

begin_block
block|{
name|savemen
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SHSave4
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine saves the current set in user symbol 4 by  * calling savemen.  */
end_comment

begin_block
block|{
name|savemen
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SHBox
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine creates and displays a rectangle whose diagonal is  * defined by two points.  The routine uses the coordinates of these  * points to define a VECTOR element with the appropriate vertices.  */
end_comment

begin_block
block|{
name|POINT
modifier|*
name|plist
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|char
modifier|*
name|txt
decl_stmt|;
name|ELT
modifier|*
name|e1
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"not enough points"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p1
operator|=
name|POINTLIST
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|plist
operator|=
name|PTInit
argument_list|()
expr_stmt|;
comment|/* create points for vector element which defines  	                       the rectangle                                 */
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p2
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p2
operator|->
name|x
argument_list|,
name|p2
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p2
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
comment|/* close rectangle */
name|txt
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|txt
operator|=
literal|'\0'
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
comment|/* clear old set in preparation to make */
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
comment|/* the new current set */
name|e1
operator|=
name|DBCreateElt
argument_list|(
name|VECTOR
argument_list|,
name|plist
argument_list|,
name|CBRUSH
argument_list|,
literal|0
argument_list|,
name|txt
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGBox */
end_comment

begin_macro
name|SHArrow
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine draws arrow heads by 'copying' the arrow head template  * into the picture appropriately transformed.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|e1
decl_stmt|;
name|POINT
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|,
name|angle
decl_stmt|,
name|s
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
comment|/* not enough points */
block|{
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
name|p1
operator|.
name|x
operator|=
name|POINTLIST
operator|->
name|x
operator|-
literal|1
expr_stmt|;
name|p1
operator|.
name|y
operator|=
name|POINTLIST
operator|->
name|y
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
name|angle
operator|=
operator|(
name|float
operator|)
name|atan2
argument_list|(
operator|(
name|p2
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
operator|(
name|p2
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
operator|)
argument_list|)
operator|-
operator|(
name|float
operator|)
name|atan2
argument_list|(
operator|(
name|p1
operator|.
name|x
operator|-
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
operator|(
name|p1
operator|.
name|y
operator|-
name|POINTLIST
operator|->
name|y
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|float
operator|)
name|sin
argument_list|(
name|angle
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|float
operator|)
name|cos
argument_list|(
name|angle
argument_list|)
expr_stmt|;
comment|/* Define transformation matrix to translate element from origin       and rotate.                                                   */
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|s
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|POINTLIST
operator|->
name|y
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
comment|/* clear old set in preparation to make */
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
comment|/* the new current set */
name|arhead
operator|.
name|brushf
operator|=
name|CBRUSH
expr_stmt|;
name|e1
operator|=
name|DBCopy
argument_list|(
operator|&
name|arhead
argument_list|,
name|xmat
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHArrow */
end_comment

end_unit

