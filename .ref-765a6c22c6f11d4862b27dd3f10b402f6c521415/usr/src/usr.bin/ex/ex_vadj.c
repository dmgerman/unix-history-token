begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1981 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)ex_vadj.c	7.6	%G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_comment
comment|/*  * Routines to deal with management of logical versus physical  * display, opening and redisplaying lines on the screen, and  * use of intelligent terminal operations.  Routines to deal with  * screen cleanup after a change.  */
end_comment

begin_comment
comment|/*  * Display a new line at physical line p, returning  * the depth of the newly displayed line.  We may decide  * to expand the window on an intelligent terminal if it is  * less than a full screen by deleting a line above the top of the  * window before doing an insert line to keep all the good text  * on the screen in which case the line may actually end up  * somewhere other than line p.  */
end_comment

begin_expr_stmt
name|vopen
argument_list|(
name|tp
argument_list|,
name|p
argument_list|)
name|line
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|struct
name|vlinfo
modifier|*
name|vp
decl_stmt|,
modifier|*
name|vpc
decl_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
operator|!=
name|NULL
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vopen(%d, %d)\n"
argument_list|,
name|lineno
argument_list|(
name|tp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|state
operator|!=
name|VISUAL
condition|)
block|{
if|if
condition|(
name|vcnt
condition|)
if|if
condition|(
name|hold
operator|&
name|HOLDROL
condition|)
name|vup1
argument_list|()
expr_stmt|;
else|else
name|vclean
argument_list|()
expr_stmt|;
comment|/* 		 * Forget all that we once knew. 		 */
name|vcnt
operator|=
name|vcline
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|WBOT
expr_stmt|;
name|LASTLINE
operator|=
name|WBOT
operator|+
literal|1
expr_stmt|;
name|state
operator|=
name|bastate
expr_stmt|;
name|WTOP
operator|=
name|basWTOP
expr_stmt|;
name|WLINES
operator|=
name|basWLINES
expr_stmt|;
block|}
name|vpc
operator|=
operator|&
name|vlinfo
index|[
name|vcline
index|]
expr_stmt|;
for|for
control|(
name|vp
operator|=
operator|&
name|vlinfo
index|[
name|vcnt
index|]
init|;
name|vp
operator|>=
name|vpc
condition|;
name|vp
operator|--
control|)
name|vlcopy
argument_list|(
name|vp
index|[
literal|1
index|]
argument_list|,
name|vp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|vcnt
operator|++
expr_stmt|;
if|if
condition|(
name|Pline
operator|==
name|numbline
condition|)
comment|/* 		 * Dirtying all the lines is rather inefficient 		 * internally, but number mode is used rarely 		 * and so its not worth optimizing. 		 */
name|vdirty
argument_list|(
name|vcline
operator|+
literal|1
argument_list|,
name|WECHO
argument_list|)
expr_stmt|;
name|getline
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* 	 * If we are opening at the top of the window, can try a window 	 * expansion at the top. 	 */
if|if
condition|(
name|state
operator|==
name|VISUAL
operator|&&
name|vcline
operator|==
literal|0
operator|&&
name|vcnt
operator|>
literal|1
operator|&&
name|p
operator|>
name|ZERO
condition|)
block|{
name|cnt
operator|=
name|p
operator|+
name|vdepth
argument_list|()
operator|-
name|LINE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
name|p
operator|-=
name|cnt
expr_stmt|;
if|if
condition|(
name|p
operator|<
name|ZERO
condition|)
name|p
operator|=
name|ZERO
expr_stmt|;
name|WTOP
operator|=
name|p
expr_stmt|;
name|WLINES
operator|=
name|WBOT
operator|-
name|WTOP
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|vpc
operator|->
name|vliny
operator|=
name|p
operator|,
name|vpc
operator|->
name|vdepth
operator|=
literal|0
operator|,
name|vpc
operator|->
name|vflags
operator|=
literal|0
expr_stmt|;
name|cnt
operator|=
name|vreopen
argument_list|(
name|p
argument_list|,
name|lineno
argument_list|(
name|tp
argument_list|)
argument_list|,
name|vcline
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcline
operator|+
literal|1
operator|==
name|vcnt
condition|)
name|LINE
argument_list|(
name|vcnt
argument_list|)
operator|=
name|LINE
argument_list|(
name|vcline
argument_list|)
operator|+
name|cnt
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Redisplay logical line l at physical line p with line number lineno.  */
end_comment

begin_macro
name|vreopen
argument_list|(
argument|p
argument_list|,
argument|lineno
argument_list|,
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p
decl_stmt|,
name|lineno
decl_stmt|,
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|d
decl_stmt|;
specifier|register
name|struct
name|vlinfo
modifier|*
name|vp
init|=
operator|&
name|vlinfo
index|[
name|l
index|]
decl_stmt|;
name|d
operator|=
name|vp
operator|->
name|vdepth
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
operator|||
operator|(
name|vp
operator|->
name|vflags
operator|&
name|VDIRT
operator|)
condition|)
name|vp
operator|->
name|vdepth
operator|=
name|d
operator|=
name|vdepth
argument_list|()
expr_stmt|;
name|vp
operator|->
name|vliny
operator|=
name|p
operator|,
name|vp
operator|->
name|vflags
operator|&=
operator|~
name|VDIRT
expr_stmt|;
comment|/* 	 * Try to win by making the screen larger rather than inserting 	 * a line and driving text off the bottom. 	 */
name|p
operator|=
name|vglitchup
argument_list|(
name|l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * BUG:		Should consider using CE here to clear to end of line. 	 *		As it stands we always strike over the current text. 	 *		Since often the current text is the same as what 	 *		we are overstriking with, it tends not to show. 	 *		On the other hand if it is different and we end up 	 *		spacing out a lot of text, we could have won with 	 *		a CE.  This is probably worthwhile at low speed 	 *		only however, since clearly computation will be 	 *		necessary to determine which way to go. 	 */
name|vigoto
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pline
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
comment|/* 	 * When we are typing part of a line for hardcopy open, don't 	 * want to type the '$' marking an end of line if in list mode. 	 */
if|if
condition|(
name|hold
operator|&
name|HOLDDOL
condition|)
return|return
operator|(
name|d
operator|)
return|;
if|if
condition|(
name|Putchar
operator|==
name|listchar
condition|)
name|putchar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
comment|/* 	 * Optimization of cursor motion may prevent screen rollup if the 	 * line has blanks/tabs at the end unless we force the cursor to appear 	 * on the last line segment. 	 */
if|if
condition|(
name|vp
operator|->
name|vliny
operator|+
name|d
operator|-
literal|1
operator|>
name|WBOT
condition|)
name|vcsync
argument_list|()
expr_stmt|;
comment|/* 	 * Switch into hardcopy open mode if we are in one line (adm3) 	 * open mode and this line is now too long.  If in hardcopy 	 * open mode, then call sethard to move onto the next line 	 * with appropriate positioning. 	 */
if|if
condition|(
name|state
operator|==
name|ONEOPEN
condition|)
block|{
name|WCOLS
operator|=
name|OCOLUMNS
expr_stmt|;
if|if
condition|(
name|vdepth
argument_list|()
operator|>
literal|1
condition|)
block|{
name|WCOLS
operator|=
name|TUBECOLS
expr_stmt|;
name|sethard
argument_list|()
expr_stmt|;
block|}
else|else
name|WCOLS
operator|=
name|TUBECOLS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|HARDOPEN
condition|)
name|sethard
argument_list|()
expr_stmt|;
comment|/* 	 * Unless we filled (completely) the last line we typed on, 	 * we have to clear to the end of the line 	 * in case stuff is left from before. 	 */
if|if
condition|(
name|vp
operator|->
name|vliny
operator|+
name|d
operator|>
name|destline
condition|)
block|{
if|if
condition|(
name|IN
operator|&&
name|destcol
operator|==
name|WCOLS
condition|)
name|vigoto
argument_list|(
name|vp
operator|->
name|vliny
operator|+
name|d
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vclreol
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|d
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Real work for winning growing of window at top  * when inserting in the middle of a partially full  * screen on an intelligent terminal.  We have as argument  * the logical line number to be inserted after, and the offset  * from that line where the insert will go.  * We look at the picture of depths and positions, and if we can  * delete some (blank) lines from the top of the screen so that  * later inserts will not push stuff off the bottom.  */
end_comment

begin_macro
name|vglitchup
argument_list|(
argument|l
argument_list|,
argument|o
argument_list|)
end_macro

begin_decl_stmt
name|int
name|l
decl_stmt|,
name|o
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vlinfo
modifier|*
name|vp
init|=
operator|&
name|vlinfo
index|[
name|l
index|]
decl_stmt|;
specifier|register
name|int
name|need
decl_stmt|;
specifier|register
name|int
name|p
init|=
name|vp
operator|->
name|vliny
decl_stmt|;
name|short
name|oldhold
decl_stmt|,
name|oldheldech
decl_stmt|;
name|bool
name|glitched
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|l
operator|<
name|vcnt
operator|-
literal|1
condition|)
block|{
name|need
operator|=
name|p
operator|+
name|vp
operator|->
name|vdepth
operator|-
operator|(
name|vp
operator|+
literal|1
operator|)
operator|->
name|vliny
expr_stmt|;
if|if
condition|(
name|need
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|VISUAL
operator|&&
name|WTOP
operator|-
name|ZERO
operator|>=
name|need
operator|&&
name|AL
operator|&&
name|DL
condition|)
block|{
name|glitched
operator|++
expr_stmt|;
name|WTOP
operator|-=
name|need
expr_stmt|;
name|WLINES
operator|=
name|WBOT
operator|-
name|WTOP
operator|+
literal|1
expr_stmt|;
name|p
operator|-=
name|need
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|o
operator|==
name|WTOP
condition|)
block|{
name|vp
operator|->
name|vliny
operator|=
name|WTOP
expr_stmt|;
return|return
operator|(
name|WTOP
operator|+
name|o
operator|)
return|;
block|}
name|vdellin
argument_list|(
name|WTOP
argument_list|,
name|need
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|oldheldech
operator|=
name|heldech
expr_stmt|;
name|oldhold
operator|=
name|hold
expr_stmt|;
name|hold
operator||=
name|HOLDECH
expr_stmt|;
block|}
name|vinslin
argument_list|(
operator|(
name|vp
operator|+
literal|1
operator|)
operator|->
name|vliny
argument_list|,
name|need
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|glitched
condition|)
block|{
name|hold
operator|=
name|oldhold
expr_stmt|;
name|heldech
operator|=
name|oldheldech
expr_stmt|;
block|}
block|}
block|}
else|else
name|vp
index|[
literal|1
index|]
operator|.
name|vliny
operator|=
name|vp
index|[
literal|0
index|]
operator|.
name|vliny
operator|+
name|vp
operator|->
name|vdepth
expr_stmt|;
return|return
operator|(
name|p
operator|+
name|o
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Insert cnt blank lines before line p,  * logically and (if supported) physically.  */
end_comment

begin_expr_stmt
name|vinslin
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|,
name|l
argument_list|)
specifier|register
name|int
name|p
operator|,
name|cnt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|bool
name|could
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vinslin(%d, %d, %d)\n"
argument_list|,
name|p
argument_list|,
name|cnt
argument_list|,
name|l
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|+
name|cnt
operator|>
name|WBOT
operator|&&
name|CD
condition|)
block|{
comment|/* 		 * Really quick -- clear to end of screen. 		 */
name|cnt
operator|=
name|WECHO
operator|+
literal|1
operator|-
name|p
expr_stmt|;
name|vgoto
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|,
name|vputp
argument_list|(
name|CD
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|vclrech
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|vadjAL
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SR
operator|&&
name|p
operator|==
name|WTOP
operator|&&
name|costSR
operator|<
name|costAL
condition|)
block|{
comment|/* 		 * Use reverse scroll mode of the terminal, at 		 * the top of the window.  Reverse linefeed works 		 * too, since we only use it from line WTOP. 		 */
for|for
control|(
name|i
operator|=
name|cnt
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|vgoto
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|,
name|vputp
argument_list|(
name|SR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
operator|&&
operator|(
name|hold
operator|&
name|HOLDAT
operator|)
operator|==
literal|0
condition|)
name|putchar
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
comment|/* 			 * If we are at the top of the screen, and the 			 * terminal retains display above, then we 			 * should try to clear to end of line. 			 * Have to use CE since we don't remember what is 			 * actually on the line. 			 */
if|if
condition|(
name|CE
operator|&&
operator|(
name|DA
operator|||
name|p
operator|!=
literal|0
operator|)
condition|)
name|vputp
argument_list|(
name|CE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|vadjAL
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AL
condition|)
block|{
comment|/* 		 * Use insert line. 		 */
name|vgoto
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|AL_PARM
operator|&&
operator|(
name|cnt
operator|>
literal|1
operator|||
operator|*
name|AL
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* insert cnt lines.  Should do @'s too. */
name|vputp
argument_list|(
name|tgoto
argument_list|(
name|AL_PARM
argument_list|,
name|p
argument_list|,
name|cnt
argument_list|)
argument_list|,
name|WECHO
operator|+
literal|1
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CS
operator|&&
operator|*
name|AL
operator|==
literal|0
condition|)
block|{
comment|/* vt100 change scrolling region to fake AL */
name|vputp
argument_list|(
name|SC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vputp
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
name|p
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vputp
argument_list|(
name|RC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* CS homes stupid cursor */
for|for
control|(
name|i
operator|=
name|cnt
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|vputp
argument_list|(
name|SR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* should do @'s */
name|vputp
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vputp
argument_list|(
name|RC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Once again put it back */
block|}
else|else
block|{
name|vputp
argument_list|(
name|AL
argument_list|,
name|WECHO
operator|+
literal|1
operator|-
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cnt
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|vgoto
argument_list|(
name|outline
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vputp
argument_list|(
name|AL
argument_list|,
name|WECHO
operator|+
literal|1
operator|-
name|outline
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hold
operator|&
name|HOLDAT
operator|)
operator|==
literal|0
condition|)
name|putchar
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
block|}
block|}
name|vadjAL
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
else|else
name|could
operator|=
literal|0
expr_stmt|;
name|vopenup
argument_list|(
name|cnt
argument_list|,
name|could
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Logically open up after line l, cnt of them.  * We need to know if it was done ``physically'' since in this  * case we accept what the hardware gives us.  If we have to do  * it ourselves (brute force) we will squish out @ lines in the process  * if this will save us work.  */
end_comment

begin_macro
name|vopenup
argument_list|(
argument|cnt
argument_list|,
argument|could
argument_list|,
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|could
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vlinfo
modifier|*
name|vc
init|=
operator|&
name|vlinfo
index|[
name|l
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|struct
name|vlinfo
modifier|*
name|ve
init|=
operator|&
name|vlinfo
index|[
name|vcnt
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vopenup(%d, %d, %d)\n"
argument_list|,
name|cnt
argument_list|,
name|could
argument_list|,
name|l
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|could
condition|)
comment|/* 		 * This will push @ lines down the screen, 		 * just as the hardware did.  Since the default 		 * for intelligent terminals is to never have @ 		 * lines on the screen, this should never happen, 		 * and the code makes no special effort to be nice in this 		 * case, e.g. squishing out the @ lines by delete lines 		 * before doing append lines. 		 */
for|for
control|(
init|;
name|vc
operator|<=
name|ve
condition|;
name|vc
operator|++
control|)
name|vc
operator|->
name|vliny
operator|+=
name|cnt
expr_stmt|;
else|else
block|{
comment|/* 		 * Will have to clean up brute force eventually, 		 * so push the line data around as little as possible. 		 */
name|vc
operator|->
name|vliny
operator|+=
name|cnt
operator|,
name|vc
operator|->
name|vflags
operator||=
name|VDIRT
expr_stmt|;
while|while
condition|(
name|vc
operator|<
name|ve
condition|)
block|{
specifier|register
name|int
name|i
init|=
name|vc
operator|->
name|vliny
operator|+
name|vc
operator|->
name|vdepth
decl_stmt|;
name|vc
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<=
name|vc
operator|->
name|vliny
condition|)
break|break;
name|vc
operator|->
name|vliny
operator|=
name|i
operator|,
name|vc
operator|->
name|vflags
operator||=
name|VDIRT
expr_stmt|;
block|}
block|}
name|vscrap
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Adjust data structure internally to account for insertion of  * blank lines on the screen.  */
end_comment

begin_macro
name|vadjAL
argument_list|(
argument|p
argument_list|,
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p
decl_stmt|,
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|tlines
index|[
name|TUBELINES
index|]
decl_stmt|;
specifier|register
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vadjal(%d, %d)\n"
argument_list|,
name|p
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|copy
argument_list|(
name|tlines
argument_list|,
name|vtube
argument_list|,
sizeof|sizeof
name|vtube
argument_list|)
expr_stmt|;
comment|/*SASSIGN*/
for|for
control|(
name|from
operator|=
name|p
operator|,
name|to
operator|=
name|p
operator|+
name|cnt
init|;
name|to
operator|<=
name|WECHO
condition|;
name|from
operator|++
operator|,
name|to
operator|++
control|)
name|vtube
index|[
name|to
index|]
operator|=
name|tlines
index|[
name|from
index|]
expr_stmt|;
for|for
control|(
name|to
operator|=
name|p
init|;
name|from
operator|<=
name|WECHO
condition|;
name|from
operator|++
operator|,
name|to
operator|++
control|)
block|{
name|vtube
index|[
name|to
index|]
operator|=
name|tlines
index|[
name|from
index|]
expr_stmt|;
name|vclrbyte
argument_list|(
name|vtube
index|[
name|to
index|]
argument_list|,
name|WCOLS
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Have to clear the echo area since its contents aren't 	 * necessarily consistent with the rest of the display. 	 */
name|vclrech
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Roll the screen up logically and physically  * so that line dl is the bottom line on the screen.  */
end_comment

begin_macro
name|vrollup
argument_list|(
argument|dl
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dl
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|int
name|dc
init|=
name|destcol
decl_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vrollup(%d)\n"
argument_list|,
name|dl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cnt
operator|=
name|dl
operator|-
operator|(
name|splitw
condition|?
name|WECHO
else|:
name|WBOT
operator|)
expr_stmt|;
if|if
condition|(
name|splitw
operator|&&
operator|(
name|state
operator|==
name|VISUAL
operator|||
name|state
operator|==
name|CRTOPEN
operator|)
condition|)
name|holdupd
operator|=
literal|1
expr_stmt|;
name|vmoveitup
argument_list|(
name|cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vscroll
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
name|destline
operator|=
name|dl
operator|-
name|cnt
operator|,
name|destcol
operator|=
name|dc
expr_stmt|;
block|}
end_block

begin_macro
name|vup1
argument_list|()
end_macro

begin_block
block|{
name|vrollup
argument_list|(
name|WBOT
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Scroll the screen up cnt lines physically.  * If doclr is true, do a clear eol if the terminal  * has standout (to prevent it from scrolling up)  */
end_comment

begin_expr_stmt
name|vmoveitup
argument_list|(
name|cnt
argument_list|,
name|doclr
argument_list|)
specifier|register
name|int
name|cnt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|doclr
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vmoveitup(%d)\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|doclr
operator|&&
operator|(
name|SO
operator|||
name|SE
operator|)
condition|)
name|vclrech
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SF
condition|)
block|{
name|destline
operator|=
name|WECHO
expr_stmt|;
name|destcol
operator|=
operator|(
name|NONL
condition|?
literal|0
else|:
name|outcol
operator|%
name|WCOLS
operator|)
expr_stmt|;
name|fgoto
argument_list|()
expr_stmt|;
while|while
condition|(
name|cnt
operator|>
literal|0
condition|)
name|vputp
argument_list|(
name|SF
argument_list|,
literal|0
argument_list|)
operator|,
name|cnt
operator|--
expr_stmt|;
return|return;
block|}
name|destline
operator|=
name|WECHO
operator|+
name|cnt
expr_stmt|;
name|destcol
operator|=
operator|(
name|NONL
condition|?
literal|0
else|:
name|outcol
operator|%
name|WCOLS
operator|)
expr_stmt|;
name|fgoto
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|ONEOPEN
operator|||
name|state
operator|==
name|HARDOPEN
condition|)
block|{
name|outline
operator|=
name|destline
operator|=
literal|0
expr_stmt|;
name|vclrbyte
argument_list|(
name|vtube
index|[
literal|0
index|]
argument_list|,
name|WCOLS
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Scroll the screen up cnt lines logically.  */
end_comment

begin_expr_stmt
name|vscroll
argument_list|(
name|cnt
argument_list|)
specifier|register
name|int
name|cnt
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
name|char
modifier|*
name|tlines
index|[
name|TUBELINES
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vscroll(%d)\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cnt
operator|<
literal|0
operator|||
name|cnt
operator|>
name|TUBELINES
condition|)
name|error
argument_list|(
literal|"Internal error: vscroll"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return;
name|copy
argument_list|(
name|tlines
argument_list|,
name|vtube
argument_list|,
sizeof|sizeof
name|vtube
argument_list|)
expr_stmt|;
for|for
control|(
name|to
operator|=
name|ZERO
operator|,
name|from
operator|=
name|ZERO
operator|+
name|cnt
init|;
name|to
operator|<=
name|WECHO
operator|-
name|cnt
condition|;
name|to
operator|++
operator|,
name|from
operator|++
control|)
name|vtube
index|[
name|to
index|]
operator|=
name|tlines
index|[
name|from
index|]
expr_stmt|;
for|for
control|(
name|from
operator|=
name|ZERO
init|;
name|to
operator|<=
name|WECHO
condition|;
name|to
operator|++
operator|,
name|from
operator|++
control|)
block|{
name|vtube
index|[
name|to
index|]
operator|=
name|tlines
index|[
name|from
index|]
expr_stmt|;
name|vclrbyte
argument_list|(
name|vtube
index|[
name|to
index|]
argument_list|,
name|WCOLS
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|from
operator|=
literal|0
init|;
name|from
operator|<=
name|vcnt
condition|;
name|from
operator|++
control|)
name|LINE
argument_list|(
name|from
argument_list|)
operator|-=
name|cnt
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Discard logical lines due to physical wandering off the screen.  */
end_comment

begin_macro
name|vscrap
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vscrap\n"
argument_list|)
operator|,
name|tvliny
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|splitw
condition|)
return|return;
if|if
condition|(
name|vcnt
operator|&&
name|WBOT
operator|!=
name|WECHO
operator|&&
name|LINE
argument_list|(
literal|0
argument_list|)
operator|<
name|WTOP
operator|&&
name|LINE
argument_list|(
literal|0
argument_list|)
operator|>=
name|ZERO
condition|)
block|{
name|WTOP
operator|=
name|LINE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|WLINES
operator|=
name|WBOT
operator|-
name|WTOP
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|vcnt
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|LINE
argument_list|(
name|j
argument_list|)
operator|>=
name|WTOP
condition|)
block|{
if|if
condition|(
name|j
operator|==
literal|0
condition|)
break|break;
comment|/* 			 * Discard the first j physical lines off the top. 			 */
name|vcnt
operator|-=
name|j
operator|,
name|vcline
operator|-=
name|j
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|vcnt
condition|;
name|i
operator|++
control|)
name|vlcopy
argument_list|(
name|vlinfo
index|[
name|i
index|]
argument_list|,
name|vlinfo
index|[
name|i
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Discard lines off the bottom. 	 */
if|if
condition|(
name|vcnt
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|vcnt
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|LINE
argument_list|(
name|j
argument_list|)
operator|>
name|WBOT
operator|||
name|LINE
argument_list|(
name|j
argument_list|)
operator|+
name|DEPTH
argument_list|(
name|j
argument_list|)
operator|-
literal|1
operator|>
name|WBOT
condition|)
block|{
name|vcnt
operator|=
name|j
expr_stmt|;
break|break;
block|}
name|LASTLINE
operator|=
name|LINE
argument_list|(
name|vcnt
operator|-
literal|1
argument_list|)
operator|+
name|DEPTH
argument_list|(
name|vcnt
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tvliny
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * May have no lines! 	 */
block|}
end_block

begin_comment
comment|/*  * Repaint the screen, with cursor at curs, aftern an arbitrary change.  * Handle notification on large changes.  */
end_comment

begin_macro
name|vrepaint
argument_list|(
argument|curs
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|curs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|wdot
operator|=
name|NOLINE
expr_stmt|;
comment|/* 	 * In open want to notify first. 	 */
name|noteit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vscrap
argument_list|()
expr_stmt|;
comment|/* 	 * Deal with a totally useless display. 	 */
if|if
condition|(
name|vcnt
operator|==
literal|0
operator|||
name|vcline
operator|<
literal|0
operator|||
name|vcline
operator|>
name|vcnt
operator|||
name|holdupd
operator|&&
name|state
operator|!=
name|VISUAL
condition|)
block|{
specifier|register
name|line
modifier|*
name|odol
init|=
name|dol
decl_stmt|;
name|vcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|holdupd
condition|)
if|if
condition|(
name|state
operator|==
name|VISUAL
condition|)
name|ignore
argument_list|(
name|peekkey
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|vup1
argument_list|()
expr_stmt|;
name|holdupd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|odol
operator|==
name|zero
condition|)
name|fixzero
argument_list|()
expr_stmt|;
name|vcontext
argument_list|(
name|dot
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|noteit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|noteit
argument_list|(
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|odol
operator|==
name|zero
condition|)
block|{
name|CATCH
name|error
argument_list|(
literal|"No lines in buffer"
argument_list|)
decl_stmt|;
name|ENDCATCH
name|linebuf
index|[
literal|0
index|]
init|=
literal|0
decl_stmt|;
name|splitw
operator|=
literal|0
expr_stmt|;
block|}
name|vnline
argument_list|(
name|curs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Have some useful displayed text; refresh it. 	 */
name|getDOT
argument_list|()
expr_stmt|;
comment|/* 	 * This is for boundary conditions in open mode. 	 */
if|if
condition|(
name|FLAGS
argument_list|(
literal|0
argument_list|)
operator|&
name|VDIRT
condition|)
name|vsync
argument_list|(
name|WTOP
argument_list|)
expr_stmt|;
comment|/* 	 * If the current line is after the last displayed line 	 * or the bottom of the screen, then special effort is needed 	 * to get it on the screen.  We first try a redraw at the 	 * last line on the screen, hoping it will fill in where @ 	 * lines are now.  If this doesn't work, then roll it onto 	 * the screen. 	 */
if|if
condition|(
name|vcline
operator|>=
name|vcnt
operator|||
name|LINE
argument_list|(
name|vcline
argument_list|)
operator|>
name|WBOT
condition|)
block|{
name|short
name|oldhold
init|=
name|hold
decl_stmt|;
name|hold
operator||=
name|HOLDAT
operator|,
name|vredraw
argument_list|(
name|LASTLINE
argument_list|)
operator|,
name|hold
operator|=
name|oldhold
expr_stmt|;
if|if
condition|(
name|vcline
operator|>=
name|vcnt
condition|)
block|{
specifier|register
name|int
name|i
init|=
name|vcline
operator|-
name|vcnt
operator|+
literal|1
decl_stmt|;
name|dot
operator|-=
name|i
expr_stmt|;
name|vcline
operator|-=
name|i
expr_stmt|;
name|vroll
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|vsyncCL
argument_list|()
expr_stmt|;
block|}
else|else
name|vsync
argument_list|(
name|vcline
operator|>
literal|0
condition|?
name|LINE
argument_list|(
name|vcline
operator|-
literal|1
argument_list|)
else|:
name|WTOP
argument_list|)
expr_stmt|;
comment|/* 	 * Notification on large change for visual 	 * has to be done last or we may lose 	 * the echo area with redisplay. 	 */
name|noteit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Finally.  Move the cursor onto the current line. 	 */
name|vnline
argument_list|(
name|curs
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Fully cleanup the screen, leaving no @ lines except at end when  * line after last won't completely fit.  The routine vsync is  * more conservative and much less work on dumb terminals.  */
end_comment

begin_expr_stmt
name|vredraw
argument_list|(
name|p
argument_list|)
specifier|register
name|int
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|l
decl_stmt|;
specifier|register
name|line
modifier|*
name|tp
decl_stmt|;
name|char
name|temp
index|[
name|LBSIZE
index|]
decl_stmt|;
name|bool
name|anydl
init|=
literal|0
decl_stmt|;
name|short
name|oldhold
init|=
name|hold
decl_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vredraw(%d)\n"
argument_list|,
name|p
argument_list|)
operator|,
name|tvliny
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|holdupd
condition|)
block|{
name|holdupd
operator|=
literal|3
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|state
operator|==
name|HARDOPEN
operator|||
name|splitw
condition|)
return|return;
if|if
condition|(
name|p
operator|<
literal|0
comment|/* || p> WECHO */
condition|)
name|error
argument_list|(
literal|"Internal error: vredraw"
argument_list|)
expr_stmt|;
comment|/* 	 * Trim the ragged edges (lines which are off the screen but 	 * not yet logically discarded), save the current line, and 	 * search for first logical line affected by the redraw. 	 */
name|vscrap
argument_list|()
expr_stmt|;
name|CP
argument_list|(
name|temp
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
name|dot
operator|-
name|vcline
expr_stmt|;
if|if
condition|(
name|vcnt
operator|==
literal|0
condition|)
name|LINE
argument_list|(
literal|0
argument_list|)
operator|=
name|WTOP
expr_stmt|;
while|while
condition|(
name|l
operator|<
name|vcnt
operator|&&
name|LINE
argument_list|(
name|l
argument_list|)
operator|<
name|p
condition|)
name|l
operator|++
operator|,
name|tp
operator|++
expr_stmt|;
comment|/* 	 * We hold off echo area clearing during the redraw in deference 	 * to a final clear of the echo area at the end if appropriate. 	 */
name|heldech
operator|=
literal|0
expr_stmt|;
name|hold
operator||=
name|HOLDECH
expr_stmt|;
for|for
control|(
init|;
name|l
operator|<
name|vcnt
operator|&&
name|Peekkey
operator|!=
name|ATTN
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|==
name|vcline
condition|)
name|strcLIN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
else|else
name|getline
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
comment|/* 		 * Delete junk between displayed lines. 		 */
if|if
condition|(
name|LINE
argument_list|(
name|l
argument_list|)
operator|!=
name|LINE
argument_list|(
name|l
operator|+
literal|1
argument_list|)
operator|&&
name|LINE
argument_list|(
name|l
argument_list|)
operator|!=
name|p
condition|)
block|{
if|if
condition|(
name|anydl
operator|==
literal|0
operator|&&
name|DB
operator|&&
name|CD
condition|)
block|{
name|hold
operator|=
name|oldhold
expr_stmt|;
name|vclrech
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|anydl
operator|=
literal|1
expr_stmt|;
name|hold
operator||=
name|HOLDECH
expr_stmt|;
name|heldech
operator|=
literal|0
expr_stmt|;
block|}
name|vdellin
argument_list|(
name|p
argument_list|,
name|LINE
argument_list|(
name|l
argument_list|)
operator|-
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If line image is not know to be up to date, then 		 * redisplay it;  else just skip onward. 		 */
name|LINE
argument_list|(
name|l
argument_list|)
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|FLAGS
argument_list|(
name|l
argument_list|)
operator|&
name|VDIRT
condition|)
block|{
name|DEPTH
argument_list|(
name|l
argument_list|)
operator|=
name|vdepth
argument_list|()
expr_stmt|;
if|if
condition|(
name|l
operator|!=
name|vcline
operator|&&
name|p
operator|+
name|DEPTH
argument_list|(
name|l
argument_list|)
operator|-
literal|1
operator|>
name|WBOT
condition|)
block|{
name|vscrap
argument_list|()
expr_stmt|;
break|break;
block|}
name|FLAGS
argument_list|(
name|l
argument_list|)
operator|&=
operator|~
name|VDIRT
expr_stmt|;
name|vreopen
argument_list|(
name|p
argument_list|,
name|lineno
argument_list|(
name|tp
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|p
operator|=
name|LINE
argument_list|(
name|l
argument_list|)
operator|+
name|DEPTH
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|+=
name|DEPTH
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|tp
operator|++
expr_stmt|;
block|}
comment|/* 	 * That takes care of lines which were already partially displayed. 	 * Now try to fill the rest of the screen with text. 	 */
if|if
condition|(
name|state
operator|==
name|VISUAL
operator|&&
name|p
operator|<=
name|WBOT
condition|)
block|{
name|int
name|ovcline
init|=
name|vcline
decl_stmt|;
name|vcline
operator|=
name|l
expr_stmt|;
for|for
control|(
init|;
name|tp
operator|<=
name|dol
operator|&&
name|Peekkey
operator|!=
name|ATTN
condition|;
name|tp
operator|++
control|)
block|{
name|getline
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|vdepth
argument_list|()
operator|-
literal|1
operator|>
name|WBOT
condition|)
break|break;
name|vopen
argument_list|(
name|tp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|DEPTH
argument_list|(
name|vcline
argument_list|)
expr_stmt|;
name|vcline
operator|++
expr_stmt|;
block|}
name|vcline
operator|=
name|ovcline
expr_stmt|;
block|}
comment|/* 	 * Thats all the text we can get on. 	 * Now rest of lines (if any) get either a ~ if they 	 * are past end of file, or an @ if the next line won't fit. 	 */
for|for
control|(
init|;
name|p
operator|<=
name|WBOT
operator|&&
name|Peekkey
operator|!=
name|ATTN
condition|;
name|p
operator|++
control|)
name|vclrlin
argument_list|(
name|p
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|strcLIN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|hold
operator|=
name|oldhold
expr_stmt|;
if|if
condition|(
name|heldech
condition|)
name|vclrech
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tvliny
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Do the real work in deleting cnt lines starting at line p from  * the display.  First affected line is line l.  */
end_comment

begin_macro
name|vdellin
argument_list|(
argument|p
argument_list|,
argument|cnt
argument_list|,
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p
decl_stmt|,
name|cnt
decl_stmt|,
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|DL
operator|==
name|NOSTR
operator|||
name|cnt
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Can't do it; just remember that line l is munged. 		 */
name|FLAGS
argument_list|(
name|l
argument_list|)
operator||=
name|VDIRT
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vdellin(%d, %d, %d)\n"
argument_list|,
name|p
argument_list|,
name|cnt
argument_list|,
name|l
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Send the deletes to the screen and then adjust logical 	 * and physical internal data structures. 	 */
name|vgoto
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DL_PARM
operator|&&
operator|(
name|cnt
operator|>
literal|1
operator|||
operator|*
name|DL
operator|==
literal|0
operator|)
condition|)
block|{
name|vputp
argument_list|(
name|tgoto
argument_list|(
name|DL_PARM
argument_list|,
name|p
argument_list|,
name|cnt
argument_list|)
argument_list|,
name|WECHO
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CS
operator|&&
operator|*
name|DL
operator|==
literal|0
condition|)
block|{
comment|/* vt100: fake DL by changing scrolling region */
name|vputp
argument_list|(
name|SC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Save since CS homes stupid cursor */
name|vputp
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
name|p
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vputp
argument_list|(
name|tgoto
argument_list|(
name|CM
argument_list|,
literal|0
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Go to lower left corner */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
comment|/* .. and scroll cnt times */
name|putch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* should check NL too */
name|vputp
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* restore scrolling region */
name|vputp
argument_list|(
name|RC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* put cursor back */
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
name|vputp
argument_list|(
name|DL
argument_list|,
name|WECHO
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
name|vadjDL
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|vcloseup
argument_list|(
name|l
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Adjust internal physical screen image to account for deleted lines.  */
end_comment

begin_macro
name|vadjDL
argument_list|(
argument|p
argument_list|,
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p
decl_stmt|,
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|tlines
index|[
name|TUBELINES
index|]
decl_stmt|;
specifier|register
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vadjDL(%d, %d)\n"
argument_list|,
name|p
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Would like to use structured assignment but early 	 * v7 compiler (released with phototypesetter for v6) 	 * can't hack it. 	 */
name|copy
argument_list|(
name|tlines
argument_list|,
name|vtube
argument_list|,
sizeof|sizeof
name|vtube
argument_list|)
expr_stmt|;
comment|/*SASSIGN*/
for|for
control|(
name|from
operator|=
name|p
operator|+
name|cnt
operator|,
name|to
operator|=
name|p
init|;
name|from
operator|<=
name|WECHO
condition|;
name|from
operator|++
operator|,
name|to
operator|++
control|)
name|vtube
index|[
name|to
index|]
operator|=
name|tlines
index|[
name|from
index|]
expr_stmt|;
for|for
control|(
name|from
operator|=
name|p
init|;
name|to
operator|<=
name|WECHO
condition|;
name|from
operator|++
operator|,
name|to
operator|++
control|)
block|{
name|vtube
index|[
name|to
index|]
operator|=
name|tlines
index|[
name|from
index|]
expr_stmt|;
name|vclrbyte
argument_list|(
name|vtube
index|[
name|to
index|]
argument_list|,
name|WCOLS
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Sync the screen, like redraw but more lazy and willing to leave  * @ lines on the screen.  VsyncCL syncs starting at the current line.  * In any case, if the redraw option is set then all syncs map to redraws  * as if vsync didn't exist.  */
end_comment

begin_macro
name|vsyncCL
argument_list|()
end_macro

begin_block
block|{
name|vsync
argument_list|(
name|LINE
argument_list|(
name|vcline
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|vsync
argument_list|(
name|p
argument_list|)
specifier|register
name|int
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|value
argument_list|(
name|REDRAW
argument_list|)
condition|)
name|vredraw
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|vsync1
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The guts of a sync.  Similar to redraw but  * just less ambitous.  */
end_comment

begin_expr_stmt
name|vsync1
argument_list|(
name|p
argument_list|)
specifier|register
name|int
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|l
decl_stmt|;
name|char
name|temp
index|[
name|LBSIZE
index|]
decl_stmt|;
specifier|register
name|struct
name|vlinfo
modifier|*
name|vp
init|=
operator|&
name|vlinfo
index|[
literal|0
index|]
decl_stmt|;
name|short
name|oldhold
init|=
name|hold
decl_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vsync1(%d)\n"
argument_list|,
name|p
argument_list|)
operator|,
name|tvliny
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|holdupd
condition|)
block|{
if|if
condition|(
name|holdupd
operator|<
literal|3
condition|)
name|holdupd
operator|=
literal|2
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|state
operator|==
name|HARDOPEN
operator|||
name|splitw
condition|)
return|return;
name|vscrap
argument_list|()
expr_stmt|;
name|CP
argument_list|(
name|temp
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcnt
operator|==
literal|0
condition|)
name|LINE
argument_list|(
literal|0
argument_list|)
operator|=
name|WTOP
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|l
operator|<
name|vcnt
operator|&&
name|vp
operator|->
name|vliny
operator|<
name|p
condition|)
name|l
operator|++
operator|,
name|vp
operator|++
expr_stmt|;
name|heldech
operator|=
literal|0
expr_stmt|;
name|hold
operator||=
name|HOLDECH
expr_stmt|;
while|while
condition|(
name|p
operator|<=
name|WBOT
operator|&&
name|Peekkey
operator|!=
name|ATTN
condition|)
block|{
comment|/* 		 * Want to put a line here if not in visual and first line 		 * or if there are lies left and this line starts before 		 * the current line, or if this line is piled under the 		 * next line (vreplace does this and we undo it). 		 */
if|if
condition|(
name|l
operator|==
literal|0
operator|&&
name|state
operator|!=
name|VISUAL
operator|||
operator|(
name|l
operator|<
name|vcnt
operator|&&
operator|(
name|vp
operator|->
name|vliny
operator|<=
name|p
operator|||
name|vp
index|[
literal|0
index|]
operator|.
name|vliny
operator|==
name|vp
index|[
literal|1
index|]
operator|.
name|vliny
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|l
operator|==
literal|0
operator|||
name|vp
operator|->
name|vliny
operator|<
name|p
operator|||
operator|(
name|vp
operator|->
name|vflags
operator|&
name|VDIRT
operator|)
condition|)
block|{
if|if
condition|(
name|l
operator|==
name|vcline
condition|)
name|strcLIN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
else|else
name|getline
argument_list|(
name|dot
index|[
name|l
operator|-
name|vcline
index|]
argument_list|)
expr_stmt|;
comment|/* 				 * Be careful that a long line doesn't cause the 				 * screen to shoot up. 				 */
if|if
condition|(
name|l
operator|!=
name|vcline
operator|&&
operator|(
name|vp
operator|->
name|vflags
operator|&
name|VDIRT
operator|)
condition|)
block|{
name|vp
operator|->
name|vdepth
operator|=
name|vdepth
argument_list|()
expr_stmt|;
name|vp
operator|->
name|vflags
operator|&=
operator|~
name|VDIRT
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|vp
operator|->
name|vdepth
operator|-
literal|1
operator|>
name|WBOT
condition|)
break|break;
block|}
name|vreopen
argument_list|(
name|p
argument_list|,
name|lineDOT
argument_list|()
operator|+
operator|(
name|l
operator|-
name|vcline
operator|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|vp
operator|->
name|vliny
operator|+
name|vp
operator|->
name|vdepth
expr_stmt|;
name|vp
operator|++
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
else|else
comment|/* 			 * A physical line between logical lines, 			 * so we settle for an @ at the beginning. 			 */
name|vclrlin
argument_list|(
name|p
argument_list|,
name|dot
operator|+
operator|(
name|l
operator|-
name|vcline
operator|)
argument_list|)
operator|,
name|p
operator|++
expr_stmt|;
block|}
name|strcLIN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|hold
operator|=
name|oldhold
expr_stmt|;
if|if
condition|(
name|heldech
condition|)
name|vclrech
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Subtract (logically) cnt physical lines from the   * displayed position of lines starting with line l.  */
end_comment

begin_macro
name|vcloseup
argument_list|(
argument|l
argument_list|,
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|l
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vcloseup(%d, %d)\n"
argument_list|,
name|l
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|l
operator|+
literal|1
init|;
name|i
operator|<=
name|vcnt
condition|;
name|i
operator|++
control|)
name|LINE
argument_list|(
name|i
argument_list|)
operator|-=
name|cnt
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Workhorse for rearranging line descriptors on changes.  * The idea here is that, starting with line l, cnt lines  * have been replaced with newcnt lines.  All of these may  * be ridiculous, i.e. l may be -1000, cnt 50 and newcnt 0,  * since we may be called from an undo after the screen has  * moved a lot.  Thus we have to be careful.  *  * Many boundary conditions here.  */
end_comment

begin_macro
name|vreplace
argument_list|(
argument|l
argument_list|,
argument|cnt
argument_list|,
argument|newcnt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|l
decl_stmt|,
name|cnt
decl_stmt|,
name|newcnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|from
decl_stmt|,
name|to
decl_stmt|,
name|i
decl_stmt|;
name|bool
name|savenote
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
block|{
name|tfixnl
argument_list|()
operator|,
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"vreplace(%d, %d, %d)\n"
argument_list|,
name|l
argument_list|,
name|cnt
argument_list|,
name|newcnt
argument_list|)
expr_stmt|;
name|tvliny
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|l
operator|>=
name|vcnt
condition|)
return|return;
if|if
condition|(
name|l
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|+
name|cnt
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Nothing on the screen is relevant. 			 * Settle for redrawing from scratch (later). 			 */
name|vcnt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 		 * Normalize l to top of screen; the add is 		 * really a subtract from cnt since l is negative. 		 */
name|cnt
operator|+=
name|l
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Unseen lines were affect so notify (later). 		 */
name|savenote
operator|++
expr_stmt|;
block|}
comment|/* 	 * These shouldn't happen 	 * but would cause great havoc. 	 */
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
name|cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|newcnt
operator|<
literal|0
condition|)
name|newcnt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Surely worthy of note if more than report 	 * lines were changed. 	 */
if|if
condition|(
name|cnt
operator|>
name|value
argument_list|(
name|REPORT
argument_list|)
operator|||
name|newcnt
operator|>
name|value
argument_list|(
name|REPORT
argument_list|)
condition|)
name|savenote
operator|++
expr_stmt|;
comment|/* 	 * Same number of lines affeted as on screen, and we 	 * can insert and delete lines.  Thus we just type 	 * over them, since otherwise we will push them 	 * slowly off the screen, a clear lose. 	 */
if|if
condition|(
name|cnt
operator|==
name|newcnt
operator|||
name|vcnt
operator|-
name|l
operator|==
name|newcnt
operator|&&
name|AL
operator|&&
name|DL
condition|)
block|{
if|if
condition|(
name|cnt
operator|>
literal|1
operator|&&
name|l
operator|+
name|cnt
operator|>
name|vcnt
condition|)
name|savenote
operator|++
expr_stmt|;
name|vdirty
argument_list|(
name|l
argument_list|,
name|newcnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Lines are going away, squish them out. 		 */
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
comment|/* 			 * If non-displayed lines went away, 			 * always notify. 			 */
if|if
condition|(
name|cnt
operator|>
literal|1
operator|&&
name|l
operator|+
name|cnt
operator|>
name|vcnt
condition|)
name|savenote
operator|++
expr_stmt|;
if|if
condition|(
name|l
operator|+
name|cnt
operator|>=
name|vcnt
condition|)
name|cnt
operator|=
name|vcnt
operator|-
name|l
expr_stmt|;
else|else
for|for
control|(
name|from
operator|=
name|l
operator|+
name|cnt
operator|,
name|to
operator|=
name|l
init|;
name|from
operator|<=
name|vcnt
condition|;
name|to
operator|++
operator|,
name|from
operator|++
control|)
name|vlcopy
argument_list|(
name|vlinfo
index|[
name|to
index|]
argument_list|,
name|vlinfo
index|[
name|from
index|]
argument_list|)
expr_stmt|;
name|vcnt
operator|-=
name|cnt
expr_stmt|;
block|}
comment|/* 		 * Open up space for new lines appearing. 		 * All new lines are piled in the same place, 		 * and will be unpiled by vredraw/vsync, which 		 * inserts lines in front as it unpiles. 		 */
if|if
condition|(
name|newcnt
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Newlines are appearing which may not show, 			 * so notify (this is only approximately correct 			 * when long lines are present). 			 */
if|if
condition|(
name|newcnt
operator|>
literal|1
operator|&&
name|l
operator|+
name|newcnt
operator|>
name|vcnt
operator|+
literal|1
condition|)
name|savenote
operator|++
expr_stmt|;
comment|/* 			 * If there will be more lines than fit, then 			 * just throw way the rest of the stuff on the screen. 			 */
if|if
condition|(
name|l
operator|+
name|newcnt
operator|>
name|WBOT
operator|&&
name|AL
operator|&&
name|DL
condition|)
block|{
name|vcnt
operator|=
name|l
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
name|from
operator|=
name|vcnt
operator|,
name|to
operator|=
name|vcnt
operator|+
name|newcnt
expr_stmt|;
name|i
operator|=
name|TUBELINES
operator|-
name|to
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|from
operator|+=
name|i
operator|,
name|to
operator|+=
name|i
expr_stmt|;
name|vcnt
operator|=
name|to
expr_stmt|;
for|for
control|(
init|;
name|from
operator|>=
name|l
condition|;
name|from
operator|--
operator|,
name|to
operator|--
control|)
name|vlcopy
argument_list|(
name|vlinfo
index|[
name|to
index|]
argument_list|,
name|vlinfo
index|[
name|from
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|from
operator|=
name|to
operator|+
literal|1
operator|,
name|to
operator|=
name|l
init|;
name|to
operator|<
name|l
operator|+
name|newcnt
operator|&&
name|to
operator|<=
name|WBOT
operator|+
literal|1
condition|;
name|to
operator|++
control|)
block|{
name|LINE
argument_list|(
name|to
argument_list|)
operator|=
name|LINE
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|DEPTH
argument_list|(
name|to
argument_list|)
operator|=
literal|0
expr_stmt|;
name|FLAGS
argument_list|(
name|to
argument_list|)
operator|=
name|VDIRT
expr_stmt|;
block|}
block|}
block|}
name|skip
label|:
if|if
condition|(
name|Pline
operator|==
name|numbline
operator|&&
name|cnt
operator|!=
name|newcnt
condition|)
comment|/* 		 * When lines positions are shifted, the numbers 		 * will be wrong. 		 */
name|vdirty
argument_list|(
name|l
argument_list|,
name|WECHO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|savenote
condition|)
name|notecnt
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
name|trace
condition|)
name|tvliny
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Start harcopy open.  * Print an image of the line to the left of the cursor  * under the full print of the line and position the cursor.  * If we are in a scroll ^D within hardcopy open then all this  * is suppressed.  */
end_comment

begin_macro
name|sethard
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|state
operator|==
name|VISUAL
condition|)
return|return;
name|rubble
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|HARDOPEN
expr_stmt|;
if|if
condition|(
name|hold
operator|&
name|HOLDROL
condition|)
return|return;
name|vup1
argument_list|()
expr_stmt|;
name|LINE
argument_list|(
literal|0
argument_list|)
operator|=
name|WBOT
expr_stmt|;
if|if
condition|(
name|Pline
operator|==
name|numbline
condition|)
name|vgoto
argument_list|(
name|WBOT
argument_list|,
literal|0
argument_list|)
operator|,
name|printf
argument_list|(
literal|"%6d  "
argument_list|,
name|lineDOT
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Mark the lines starting at base for i lines  * as dirty so that they will be checked for correct  * display at next sync/redraw.  */
end_comment

begin_expr_stmt
name|vdirty
argument_list|(
name|base
argument_list|,
name|i
argument_list|)
specifier|register
name|int
name|base
operator|,
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|base
init|;
name|l
operator|<
name|vcnt
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
return|return;
name|FLAGS
argument_list|(
name|l
argument_list|)
operator||=
name|VDIRT
expr_stmt|;
block|}
block|}
end_block

end_unit

