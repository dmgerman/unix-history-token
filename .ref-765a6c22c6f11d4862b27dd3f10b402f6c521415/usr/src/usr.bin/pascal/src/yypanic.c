begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)yypanic.c 1.5 %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"tree_ty.h"
end_include

begin_comment
comment|/* must be included for yy.h */
end_comment

begin_include
include|#
directive|include
file|"yy.h"
end_include

begin_decl_stmt
name|struct
name|yytok
name|oldpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The routine yyPerror coordinates the panic when  * the correction routines fail. Three types of panics  * are possible - those in a declaration part, those  * in a statement part, and those in an expression.  *  * Declaration part panics consider insertion of "begin",  * expression part panics will stop on more symbols.  * The panics are otherwise the same.  *  * ERROR MESSAGE SUPPRESSION STRATEGY: August 11, 1977  *  * If the parser has not made at least 2 moves since the last point of  * error then we want to suppress the supplied error message.  * Otherwise we print it.  * We then skip input up to the next solid symbol.  */
end_comment

begin_macro
name|yyPerror
argument_list|(
argument|cp
argument_list|,
argument|kind
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|kind
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|ishifts
decl_stmt|,
name|brlev
decl_stmt|;
name|copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|oldpos
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|Y
operator|)
argument_list|,
sizeof|sizeof
name|oldpos
argument_list|)
expr_stmt|;
name|brlev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
for|for
control|(
name|ishifts
operator|=
name|yyshifts
init|;
condition|;
name|yychar
operator|=
name|yylex
argument_list|()
operator|,
name|yyshifts
operator|++
control|)
switch|switch
condition|(
name|yychar
condition|)
block|{
case|case
name|YILLCH
case|:
name|yerror
argument_list|(
literal|"Illegal character"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ishifts
operator|==
name|yyshifts
condition|)
name|yyOshifts
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|YEOF
case|:
if|if
condition|(
name|kind
operator|==
name|PDECL
condition|)
block|{
comment|/* 					 * we have paniced to end of file 					 * during declarations. Separately 					 * compiled segments can syntactically 					 * exit without any error message, so 					 * we force one here. 					 */
name|yerror
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|continuation
argument_list|()
expr_stmt|;
name|yyunexeof
argument_list|()
expr_stmt|;
block|}
goto|goto
name|quiet
goto|;
case|case
literal|';'
case|:
if|if
condition|(
name|kind
operator|==
name|PPROG
condition|)
continue|continue;
if|if
condition|(
name|kind
operator|==
name|PDECL
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
goto|goto
name|resume
goto|;
case|case
name|YEND
case|:
if|if
condition|(
name|kind
operator|==
name|PPROG
condition|)
continue|continue;
case|case
name|YPROCEDURE
case|:
case|case
name|YFUNCTION
case|:
goto|goto
name|resume
goto|;
case|case
name|YLABEL
case|:
case|case
name|YTYPE
case|:
case|case
name|YCONST
case|:
case|case
name|YVAR
case|:
if|if
condition|(
name|kind
operator|==
name|PSTAT
condition|)
block|{
name|yerror
argument_list|(
literal|"Declaration found when statement expected"
argument_list|)
expr_stmt|;
goto|goto
name|quiet
goto|;
block|}
case|case
name|YBEGIN
case|:
goto|goto
name|resume
goto|;
case|case
name|YFOR
case|:
case|case
name|YREPEAT
case|:
case|case
name|YWHILE
case|:
case|case
name|YGOTO
case|:
case|case
name|YIF
case|:
if|if
condition|(
name|kind
operator|!=
name|PDECL
condition|)
goto|goto
name|resume
goto|;
name|yerror
argument_list|(
literal|"Expected keyword begin after declarations, before statements"
argument_list|)
expr_stmt|;
name|unyylex
argument_list|(
operator|&
name|Y
argument_list|)
expr_stmt|;
name|yychar
operator|=
name|YBEGIN
expr_stmt|;
name|yylval
operator|=
name|nullsem
argument_list|(
name|YBEGIN
argument_list|)
expr_stmt|;
goto|goto
name|quiet
goto|;
case|case
name|YTHEN
case|:
case|case
name|YELSE
case|:
case|case
name|YDO
case|:
if|if
condition|(
name|kind
operator|==
name|PSTAT
condition|)
block|{
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
goto|goto
name|resume
goto|;
block|}
if|if
condition|(
name|kind
operator|==
name|PEXPR
condition|)
goto|goto
name|resume
goto|;
continue|continue;
case|case
literal|')'
case|:
case|case
literal|']'
case|:
if|if
condition|(
name|kind
operator|!=
name|PEXPR
condition|)
continue|continue;
if|if
condition|(
name|brlev
operator|==
literal|0
condition|)
goto|goto
name|resume
goto|;
if|if
condition|(
name|brlev
operator|>
literal|0
condition|)
name|brlev
operator|--
expr_stmt|;
continue|continue;
case|case
literal|'('
case|:
case|case
literal|'['
case|:
name|brlev
operator|++
expr_stmt|;
continue|continue;
case|case
literal|','
case|:
if|if
condition|(
name|brlev
operator|!=
literal|0
condition|)
continue|continue;
case|case
name|YOF
case|:
case|case
name|YTO
case|:
case|case
name|YDOWNTO
case|:
if|if
condition|(
name|kind
operator|==
name|PEXPR
condition|)
goto|goto
name|resume
goto|;
continue|continue;
ifdef|#
directive|ifdef
name|PI
comment|/* 			 * A rough approximation for now 			 * Should be much more lenient on suppressing 			 * warnings. 			 */
case|case
name|YID
case|:
name|syneflg
operator|=
name|TRUE
expr_stmt|;
continue|continue;
endif|#
directive|endif
block|}
name|resume
label|:
if|if
condition|(
name|yyOshifts
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|yychar
operator|!=
operator|-
literal|1
condition|)
name|unyylex
argument_list|(
operator|&
name|Y
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|Y
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|oldpos
operator|)
argument_list|,
sizeof|sizeof
name|Y
argument_list|)
expr_stmt|;
name|yerror
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
block|}
name|quiet
label|:
if|if
condition|(
name|yyshifts
operator|-
name|ishifts
operator|>
literal|2
operator|&&
name|opt
argument_list|(
literal|'r'
argument_list|)
condition|)
block|{
name|setpfx
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
name|yerror
argument_list|(
literal|"Parsing resumes"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we paniced in the statement part, 	 * and didn't stop at a ';', then we insert 	 * a ';' to prevent the recovery from immediately 	 * inserting one and complaining about it. 	 */
if|if
condition|(
name|kind
operator|==
name|PSTAT
operator|&&
name|yychar
operator|!=
literal|';'
condition|)
block|{
name|unyylex
argument_list|(
operator|&
name|Y
argument_list|)
expr_stmt|;
name|yyshifts
operator|--
expr_stmt|;
name|yytshifts
operator|--
expr_stmt|;
name|yychar
operator|=
literal|';'
expr_stmt|;
name|yylval
operator|=
name|nullsem
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

