begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)find.c	4.9 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_define
define|#
directive|define
name|A_DAY
value|86400L
end_define

begin_comment
comment|/* a day full of seconds */
end_comment

begin_define
define|#
directive|define
name|EQ
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(strcmp(x, y)==0)
end_define

begin_decl_stmt
name|int
name|Randlast
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Pathname
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|anode
block|{
name|int
function_decl|(
modifier|*
name|F
function_decl|)
parameter_list|()
function_decl|;
name|struct
name|anode
modifier|*
name|L
decl_stmt|,
modifier|*
name|R
decl_stmt|;
block|}
name|Node
index|[
literal|100
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|Nn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of nodes */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|Now
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Argc
decl_stmt|,
name|Ai
decl_stmt|,
name|Pi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|Argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cpio stuff */
end_comment

begin_decl_stmt
name|int
name|Cpio
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|Buf
decl_stmt|,
modifier|*
name|Dbuf
decl_stmt|,
modifier|*
name|Wp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Bufsize
init|=
literal|5120
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Wct
init|=
literal|2560
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|Newer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stat
name|Statb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|anode
modifier|*
name|exp
argument_list|()
decl_stmt|,
modifier|*
name|e1
argument_list|()
decl_stmt|,
modifier|*
name|e2
argument_list|()
decl_stmt|,
modifier|*
name|e3
argument_list|()
decl_stmt|,
modifier|*
name|mk
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|nxtarg
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|Home
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|Blocks
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * SEE ALSO:	updatedb, bigram.c, code.c  *		Usenix ;login:, February/March, 1983, p. 8.  *  * REVISIONS: 	James A. Woods, Informatics General Corporation,  *		NASA Ames Research Center, 6/81.  *  *		The second form searches a pre-computed filelist  *		(constructed nightly by /usr/lib/crontab) which is  *		compressed by updatedb (v.i.z.)  The effect of  *			find<name>  *		is similar to  *			find / +0 -name "*<name>*" -print  *		but much faster.  *  *		8/82 faster yet + incorporation of bigram coding -- jaw  *  *		1/83 incorporate glob-style matching -- jaw  */
end_comment

begin_define
define|#
directive|define
name|AMES
value|1
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|struct
name|anode
modifier|*
name|exlist
decl_stmt|;
name|int
name|paths
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|pwd
decl_stmt|,
modifier|*
name|popen
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|AMES
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: find name, or find path-list predicate-list\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|fastfind
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|time
argument_list|(
operator|&
name|Now
argument_list|)
expr_stmt|;
name|pwd
operator|=
name|popen
argument_list|(
literal|"pwd"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|Home
argument_list|,
literal|128
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
name|Home
index|[
name|strlen
argument_list|(
name|Home
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Argc
operator|=
name|argc
expr_stmt|;
name|Argv
operator|=
name|argv
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|usage
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: find path-list predicate-list\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Ai
operator|=
name|paths
operator|=
literal|1
init|;
name|Ai
operator|<
operator|(
name|argc
operator|-
literal|1
operator|)
condition|;
operator|++
name|Ai
operator|,
operator|++
name|paths
control|)
if|if
condition|(
operator|*
name|Argv
index|[
name|Ai
index|]
operator|==
literal|'-'
operator|||
name|EQ
argument_list|(
name|Argv
index|[
name|Ai
index|]
argument_list|,
literal|"("
argument_list|)
operator|||
name|EQ
argument_list|(
name|Argv
index|[
name|Ai
index|]
argument_list|,
literal|"!"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|paths
operator|==
literal|1
condition|)
comment|/* no path-list */
goto|goto
name|usage
goto|;
if|if
condition|(
operator|!
operator|(
name|exlist
operator|=
name|exp
argument_list|()
operator|)
condition|)
block|{
comment|/* parse and compile the arguments */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: parsing error\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Ai
operator|<
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: missing conjunction\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Pi
operator|=
literal|1
init|;
name|Pi
operator|<
name|paths
condition|;
operator|++
name|Pi
control|)
block|{
name|sp
operator|=
literal|0
expr_stmt|;
name|chdir
argument_list|(
name|Home
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|Pathname
argument_list|,
name|Argv
index|[
name|Pi
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|rindex
argument_list|(
name|Pathname
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|sp
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
operator|*
name|Pathname
condition|?
name|Pathname
else|:
literal|"/"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: bad starting directory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
name|Fname
operator|=
name|sp
condition|?
name|sp
else|:
name|Pathname
expr_stmt|;
name|descend
argument_list|(
name|Pathname
argument_list|,
name|Fname
argument_list|,
name|exlist
argument_list|)
expr_stmt|;
comment|/* to find files that match  */
block|}
if|if
condition|(
name|Cpio
condition|)
block|{
name|strcpy
argument_list|(
name|Pathname
argument_list|,
literal|"TRAILER!!!"
argument_list|)
expr_stmt|;
name|Statb
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|cpio
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%D blocks\n"
argument_list|,
name|Blocks
operator|*
literal|10
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* compile time functions:  priority is  exp()<e1()<e2()<e3()  */
end_comment

begin_function
name|struct
name|anode
modifier|*
name|exp
parameter_list|()
block|{
comment|/* parse ALTERNATION (-o)  */
name|int
name|or
parameter_list|()
function_decl|;
specifier|register
name|struct
name|anode
modifier|*
name|p1
decl_stmt|;
name|p1
operator|=
name|e1
argument_list|()
comment|/* get left operand */
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|nxtarg
argument_list|()
argument_list|,
literal|"-o"
argument_list|)
condition|)
block|{
name|Randlast
operator|--
expr_stmt|;
return|return
operator|(
name|mk
argument_list|(
name|or
argument_list|,
name|p1
argument_list|,
name|exp
argument_list|()
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|Ai
operator|<=
name|Argc
condition|)
operator|--
name|Ai
expr_stmt|;
return|return
operator|(
name|p1
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|anode
modifier|*
name|e1
parameter_list|()
block|{
comment|/* parse CONCATENATION (formerly -a) */
name|int
name|and
parameter_list|()
function_decl|;
specifier|register
name|struct
name|anode
modifier|*
name|p1
decl_stmt|;
specifier|register
name|char
modifier|*
name|a
decl_stmt|;
name|p1
operator|=
name|e2
argument_list|()
expr_stmt|;
name|a
operator|=
name|nxtarg
argument_list|()
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-a"
argument_list|)
condition|)
block|{
name|And
label|:
name|Randlast
operator|--
expr_stmt|;
return|return
operator|(
name|mk
argument_list|(
name|and
argument_list|,
name|p1
argument_list|,
name|e1
argument_list|()
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"("
argument_list|)
operator|||
name|EQ
argument_list|(
name|a
argument_list|,
literal|"!"
argument_list|)
operator|||
operator|(
operator|*
name|a
operator|==
literal|'-'
operator|&&
operator|!
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-o"
argument_list|)
operator|)
condition|)
block|{
operator|--
name|Ai
expr_stmt|;
goto|goto
name|And
goto|;
block|}
elseif|else
if|if
condition|(
name|Ai
operator|<=
name|Argc
condition|)
operator|--
name|Ai
expr_stmt|;
return|return
operator|(
name|p1
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|anode
modifier|*
name|e2
parameter_list|()
block|{
comment|/* parse NOT (!) */
name|int
name|not
parameter_list|()
function_decl|;
if|if
condition|(
name|Randlast
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: operand follows operand\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Randlast
operator|++
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|nxtarg
argument_list|()
argument_list|,
literal|"!"
argument_list|)
condition|)
return|return
operator|(
name|mk
argument_list|(
name|not
argument_list|,
name|e3
argument_list|()
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|Ai
operator|<=
name|Argc
condition|)
operator|--
name|Ai
expr_stmt|;
return|return
operator|(
name|e3
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|anode
modifier|*
name|e3
parameter_list|()
block|{
comment|/* parse parens and predicates */
name|int
name|exeq
argument_list|()
decl_stmt|,
name|ok
argument_list|()
decl_stmt|,
name|glob
argument_list|()
decl_stmt|,
name|mtime
argument_list|()
decl_stmt|,
name|atime
argument_list|()
decl_stmt|,
name|user
argument_list|()
decl_stmt|,
name|group
argument_list|()
decl_stmt|,
name|size
argument_list|()
decl_stmt|,
name|perm
argument_list|()
decl_stmt|,
name|links
argument_list|()
decl_stmt|,
name|print
argument_list|()
decl_stmt|,
name|type
argument_list|()
decl_stmt|,
name|ino
argument_list|()
decl_stmt|,
name|cpio
argument_list|()
decl_stmt|,
name|newer
argument_list|()
decl_stmt|;
name|struct
name|anode
modifier|*
name|p1
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
name|s
decl_stmt|;
name|a
operator|=
name|nxtarg
argument_list|()
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"("
argument_list|)
condition|)
block|{
name|Randlast
operator|--
expr_stmt|;
name|p1
operator|=
name|exp
argument_list|()
expr_stmt|;
name|a
operator|=
name|nxtarg
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|a
argument_list|,
literal|")"
argument_list|)
condition|)
goto|goto
name|err
goto|;
return|return
operator|(
name|p1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-print"
argument_list|)
condition|)
block|{
return|return
operator|(
name|mk
argument_list|(
name|print
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
name|b
operator|=
name|nxtarg
argument_list|()
expr_stmt|;
name|s
operator|=
operator|*
name|b
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|'+'
condition|)
name|b
operator|++
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-name"
argument_list|)
condition|)
return|return
operator|(
name|mk
argument_list|(
name|glob
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|b
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-mtime"
argument_list|)
condition|)
return|return
operator|(
name|mk
argument_list|(
name|mtime
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-atime"
argument_list|)
condition|)
return|return
operator|(
name|mk
argument_list|(
name|atime
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-user"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|getunum
argument_list|(
literal|"/etc/passwd"
argument_list|,
name|b
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|gmatch
argument_list|(
name|b
argument_list|,
literal|"[0-9]*"
argument_list|)
condition|)
return|return
name|mk
argument_list|(
name|user
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: cannot find -user name\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mk
argument_list|(
name|user
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|i
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-inum"
argument_list|)
condition|)
return|return
operator|(
name|mk
argument_list|(
name|ino
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-group"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|getunum
argument_list|(
literal|"/etc/group"
argument_list|,
name|b
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|gmatch
argument_list|(
name|b
argument_list|,
literal|"[0-9]*"
argument_list|)
condition|)
return|return
name|mk
argument_list|(
name|group
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: cannot find -group name\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mk
argument_list|(
name|group
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|i
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-size"
argument_list|)
condition|)
return|return
operator|(
name|mk
argument_list|(
name|size
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-links"
argument_list|)
condition|)
return|return
operator|(
name|mk
argument_list|(
name|links
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-perm"
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|b
condition|;
operator|++
name|b
control|)
block|{
if|if
condition|(
operator|*
name|b
operator|==
literal|'-'
condition|)
continue|continue;
name|i
operator|<<=
literal|3
expr_stmt|;
name|i
operator|=
name|i
operator|+
operator|(
operator|*
name|b
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|mk
argument_list|(
name|perm
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|i
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-type"
argument_list|)
condition|)
block|{
name|i
operator|=
name|s
operator|==
literal|'d'
condition|?
name|S_IFDIR
else|:
name|s
operator|==
literal|'b'
condition|?
name|S_IFBLK
else|:
name|s
operator|==
literal|'c'
condition|?
name|S_IFCHR
else|:
name|s
operator|==
literal|'f'
condition|?
name|S_IFREG
else|:
name|s
operator|==
literal|'l'
condition|?
name|S_IFLNK
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|mk
argument_list|(
name|type
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|i
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-exec"
argument_list|)
condition|)
block|{
name|i
operator|=
name|Ai
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|EQ
argument_list|(
name|nxtarg
argument_list|()
argument_list|,
literal|";"
argument_list|)
condition|)
empty_stmt|;
return|return
operator|(
name|mk
argument_list|(
name|exeq
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|i
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-ok"
argument_list|)
condition|)
block|{
name|i
operator|=
name|Ai
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|EQ
argument_list|(
name|nxtarg
argument_list|()
argument_list|,
literal|";"
argument_list|)
condition|)
empty_stmt|;
return|return
operator|(
name|mk
argument_list|(
name|ok
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|i
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-cpio"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|Cpio
operator|=
name|creat
argument_list|(
name|b
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: cannot create< %s>\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Buf
operator|=
operator|(
name|short
operator|*
operator|)
name|sbrk
argument_list|(
literal|512
argument_list|)
expr_stmt|;
name|Wp
operator|=
name|Dbuf
operator|=
operator|(
name|short
operator|*
operator|)
name|sbrk
argument_list|(
literal|5120
argument_list|)
expr_stmt|;
return|return
operator|(
name|mk
argument_list|(
name|cpio
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-newer"
argument_list|)
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|b
argument_list|,
operator|&
name|Statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: cannot access< %s>\n"
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Newer
operator|=
name|Statb
operator|.
name|st_mtime
expr_stmt|;
return|return
name|mk
argument_list|(
name|newer
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
name|err
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: bad option< %s>\n"
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|anode
modifier|*
name|mk
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
name|int
argument_list|(
operator|*
name|f
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|anode
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Node
index|[
name|Nn
index|]
operator|.
name|F
operator|=
name|f
expr_stmt|;
name|Node
index|[
name|Nn
index|]
operator|.
name|L
operator|=
name|l
expr_stmt|;
name|Node
index|[
name|Nn
index|]
operator|.
name|R
operator|=
name|r
expr_stmt|;
return|return
operator|(
operator|&
operator|(
name|Node
index|[
name|Nn
operator|++
index|]
operator|)
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|nxtarg
parameter_list|()
block|{
comment|/* get next arg from command line */
specifier|static
name|strikes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strikes
operator|==
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: incomplete statement\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Ai
operator|>=
name|Argc
condition|)
block|{
name|strikes
operator|++
expr_stmt|;
name|Ai
operator|=
name|Argc
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|""
operator|)
return|;
block|}
return|return
operator|(
name|Argv
index|[
name|Ai
operator|++
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* execution time functions */
end_comment

begin_expr_stmt
name|and
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|anode
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
operator|(
call|(
modifier|*
name|p
operator|->
name|L
operator|->
name|F
call|)
argument_list|(
name|p
operator|->
name|L
argument_list|)
operator|)
operator|&&
operator|(
call|(
modifier|*
name|p
operator|->
name|R
operator|->
name|F
call|)
argument_list|(
name|p
operator|->
name|R
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|or
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|anode
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
operator|(
call|(
modifier|*
name|p
operator|->
name|L
operator|->
name|F
call|)
argument_list|(
name|p
operator|->
name|L
argument_list|)
operator|)
operator|||
operator|(
call|(
modifier|*
name|p
operator|->
name|R
operator|->
name|F
call|)
argument_list|(
name|p
operator|->
name|R
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|not
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|anode
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
operator|!
operator|(
call|(
modifier|*
name|p
operator|->
name|L
operator|->
name|F
call|)
argument_list|(
name|p
operator|->
name|L
argument_list|)
operator|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|glob
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|;
name|char
operator|*
name|pat
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|gmatch
argument_list|(
name|Fname
argument_list|,
name|p
operator|->
name|pat
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|print
argument_list|()
end_macro

begin_block
block|{
name|puts
argument_list|(
name|Pathname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|mtime
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|t
block|,
name|s
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|scomp
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|Now
operator|-
name|Statb
operator|.
name|st_mtime
operator|)
operator|/
name|A_DAY
argument_list|)
argument_list|,
name|p
operator|->
name|t
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|atime
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|t
block|,
name|s
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|scomp
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|Now
operator|-
name|Statb
operator|.
name|st_atime
operator|)
operator|/
name|A_DAY
argument_list|)
argument_list|,
name|p
operator|->
name|t
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|user
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|u
block|,
name|s
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|scomp
argument_list|(
name|Statb
operator|.
name|st_uid
argument_list|,
name|p
operator|->
name|u
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|ino
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|u
block|,
name|s
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|scomp
argument_list|(
operator|(
name|int
operator|)
name|Statb
operator|.
name|st_ino
argument_list|,
name|p
operator|->
name|u
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|group
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|u
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|p
operator|->
name|u
operator|==
name|Statb
operator|.
name|st_gid
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|links
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|link
block|,
name|s
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|scomp
argument_list|(
name|Statb
operator|.
name|st_nlink
argument_list|,
name|p
operator|->
name|link
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|size
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|sz
block|,
name|s
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|scomp
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|Statb
operator|.
name|st_size
operator|+
literal|511
operator|)
operator|>>
literal|9
argument_list|)
argument_list|,
name|p
operator|->
name|sz
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|perm
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|per
block|,
name|s
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|i
operator|=
operator|(
name|p
operator|->
name|s
operator|==
literal|'-'
operator|)
condition|?
name|p
operator|->
name|per
else|:
literal|07777
expr_stmt|;
comment|/* '-' means only arg bits */
return|return
operator|(
operator|(
name|Statb
operator|.
name|st_mode
operator|&
name|i
operator|&
literal|07777
operator|)
operator|==
name|p
operator|->
name|per
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|type
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|per
block|,
name|s
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
operator|(
name|Statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|p
operator|->
name|per
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|exeq
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|com
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* to flush possible `-print' */
return|return
operator|(
name|doex
argument_list|(
name|p
operator|->
name|com
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|ok
argument_list|(
argument|p
argument_list|)
end_macro

begin_struct
struct|struct
block|{
name|int
name|f
decl_stmt|,
name|com
decl_stmt|;
block|}
modifier|*
name|p
struct|;
end_struct

begin_block
block|{
name|char
name|c
decl_stmt|;
name|int
name|yes
decl_stmt|;
name|yes
operator|=
literal|0
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* to flush possible `-print' */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"< %s ... %s> ?   "
argument_list|,
name|Argv
index|[
name|p
operator|->
name|com
index|]
argument_list|,
name|Pathname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'y'
condition|)
name|yes
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yes
condition|)
return|return
operator|(
name|doex
argument_list|(
name|p
operator|->
name|com
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|MKSHORT
parameter_list|(
name|v
parameter_list|,
name|lv
parameter_list|)
value|{U.l=1L;if(U.c[0]) U.l=lv, v[0]=U.s[1], v[1]=U.s[0]; else U.l=lv, v[0]=U.s[0], v[1]=U.s[1];}
end_define

begin_union
union|union
block|{
name|long
name|l
decl_stmt|;
name|short
name|s
index|[
literal|2
index|]
decl_stmt|;
name|char
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|U
union|;
end_union

begin_function
name|long
name|mklong
parameter_list|(
name|v
parameter_list|)
name|short
name|v
index|[]
decl_stmt|;
block|{
name|U
operator|.
name|l
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|U
operator|.
name|c
index|[
literal|0
index|]
comment|/* VAX */
condition|)
name|U
operator|.
name|s
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|1
index|]
operator|,
name|U
operator|.
name|s
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
else|else
name|U
operator|.
name|s
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
operator|,
name|U
operator|.
name|s
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
return|return
name|U
operator|.
name|l
return|;
block|}
end_function

begin_macro
name|cpio
argument_list|()
end_macro

begin_block
block|{
define|#
directive|define
name|MAGIC
value|070707
struct|struct
name|header
block|{
name|short
name|h_magic
decl_stmt|,
name|h_dev
decl_stmt|,
name|h_ino
decl_stmt|,
name|h_mode
decl_stmt|,
name|h_uid
decl_stmt|,
name|h_gid
decl_stmt|,
name|h_nlink
decl_stmt|,
name|h_rdev
decl_stmt|;
name|short
name|h_mtime
index|[
literal|2
index|]
decl_stmt|;
name|short
name|h_namesize
decl_stmt|;
name|short
name|h_filesize
index|[
literal|2
index|]
decl_stmt|;
name|char
name|h_name
index|[
literal|256
index|]
decl_stmt|;
block|}
name|hdr
struct|;
specifier|register
name|ifile
operator|,
name|ct
expr_stmt|;
specifier|static
name|long
name|fsz
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|hdr
operator|.
name|h_magic
operator|=
name|MAGIC
expr_stmt|;
name|strcpy
argument_list|(
name|hdr
operator|.
name|h_name
argument_list|,
operator|!
name|strncmp
argument_list|(
name|Pathname
argument_list|,
literal|"./"
argument_list|,
literal|2
argument_list|)
condition|?
name|Pathname
operator|+
literal|2
else|:
name|Pathname
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|h_namesize
operator|=
name|strlen
argument_list|(
name|hdr
operator|.
name|h_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|hdr
operator|.
name|h_uid
operator|=
name|Statb
operator|.
name|st_uid
expr_stmt|;
name|hdr
operator|.
name|h_gid
operator|=
name|Statb
operator|.
name|st_gid
expr_stmt|;
name|hdr
operator|.
name|h_dev
operator|=
name|Statb
operator|.
name|st_dev
expr_stmt|;
name|hdr
operator|.
name|h_ino
operator|=
name|Statb
operator|.
name|st_ino
expr_stmt|;
name|hdr
operator|.
name|h_mode
operator|=
name|Statb
operator|.
name|st_mode
expr_stmt|;
name|MKSHORT
argument_list|(
name|hdr
operator|.
name|h_mtime
argument_list|,
name|Statb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|h_nlink
operator|=
name|Statb
operator|.
name|st_nlink
expr_stmt|;
name|fsz
operator|=
name|hdr
operator|.
name|h_mode
operator|&
name|S_IFREG
condition|?
name|Statb
operator|.
name|st_size
else|:
literal|0L
expr_stmt|;
name|MKSHORT
argument_list|(
name|hdr
operator|.
name|h_filesize
argument_list|,
name|fsz
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|h_rdev
operator|=
name|Statb
operator|.
name|st_rdev
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|hdr
operator|.
name|h_name
argument_list|,
literal|"TRAILER!!!"
argument_list|)
condition|)
block|{
name|bwrite
argument_list|(
operator|(
name|short
operator|*
operator|)
operator|&
name|hdr
argument_list|,
operator|(
sizeof|sizeof
name|hdr
operator|-
literal|256
operator|)
operator|+
name|hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
name|bwrite
argument_list|(
name|Buf
argument_list|,
literal|512
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|mklong
argument_list|(
name|hdr
operator|.
name|h_filesize
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|ifile
operator|=
name|open
argument_list|(
name|Fname
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|cerror
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: cannot copy< %s>\n"
argument_list|,
name|hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|bwrite
argument_list|(
operator|(
name|short
operator|*
operator|)
operator|&
name|hdr
argument_list|,
operator|(
sizeof|sizeof
name|hdr
operator|-
literal|256
operator|)
operator|+
name|hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
for|for
control|(
name|fsz
operator|=
name|mklong
argument_list|(
name|hdr
operator|.
name|h_filesize
argument_list|)
init|;
name|fsz
operator|>
literal|0
condition|;
name|fsz
operator|-=
literal|512
control|)
block|{
name|ct
operator|=
name|fsz
operator|>
literal|512
condition|?
literal|512
else|:
name|fsz
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|ifile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Buf
argument_list|,
name|ct
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|cerror
goto|;
name|bwrite
argument_list|(
name|Buf
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|newer
argument_list|()
end_macro

begin_block
block|{
return|return
name|Statb
operator|.
name|st_mtime
operator|>
name|Newer
return|;
block|}
end_block

begin_comment
comment|/* support functions */
end_comment

begin_expr_stmt
name|scomp
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|s
argument_list|)
comment|/* funny signed compare */
specifier|register
name|a
operator|,
name|b
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|s
operator|==
literal|'+'
condition|)
return|return
operator|(
name|a
operator|>
name|b
operator|)
return|;
if|if
condition|(
name|s
operator|==
literal|'-'
condition|)
return|return
operator|(
name|a
operator|<
operator|(
name|b
operator|*
operator|-
literal|1
operator|)
operator|)
return|;
return|return
operator|(
name|a
operator|==
name|b
operator|)
return|;
block|}
end_block

begin_macro
name|doex
argument_list|(
argument|com
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|np
expr_stmt|;
specifier|register
name|char
modifier|*
name|na
decl_stmt|;
specifier|static
name|char
modifier|*
name|nargv
index|[
literal|50
index|]
decl_stmt|;
specifier|static
name|ccode
expr_stmt|;
name|ccode
operator|=
name|np
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|na
operator|=
name|Argv
index|[
name|com
operator|++
index|]
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|na
argument_list|,
literal|";"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|na
argument_list|,
literal|"{}"
argument_list|)
operator|==
literal|0
condition|)
name|nargv
index|[
name|np
operator|++
index|]
operator|=
name|Pathname
expr_stmt|;
else|else
name|nargv
index|[
name|np
operator|++
index|]
operator|=
name|na
expr_stmt|;
block|}
name|nargv
index|[
name|np
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|np
operator|==
literal|0
condition|)
return|return
operator|(
literal|9
operator|)
return|;
if|if
condition|(
name|fork
argument_list|()
condition|)
comment|/*parent*/
block|{
include|#
directive|include
file|<signal.h>
name|int
function_decl|(
modifier|*
name|old
function_decl|)
parameter_list|()
init|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|oldq
function_decl|)
parameter_list|()
init|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
function_decl|;
name|wait
argument_list|(
operator|&
name|ccode
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|oldq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*child*/
name|chdir
argument_list|(
name|Home
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|nargv
index|[
literal|0
index|]
argument_list|,
name|nargv
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ccode
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|getunum
argument_list|(
argument|f
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|,
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* find user/group name and return number */
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|char
name|str
index|[
literal|20
index|]
decl_stmt|;
name|FILE
modifier|*
name|pin
decl_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|pin
operator|=
name|fopen
argument_list|(
name|f
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
comment|/* prime with a CR */
do|do
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|sp
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|=
name|getc
argument_list|(
name|pin
argument_list|)
operator|)
operator|!=
literal|':'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|RET
goto|;
operator|*
operator|--
name|sp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|str
argument_list|,
name|s
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|pin
argument_list|)
operator|)
operator|!=
literal|':'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|RET
goto|;
name|sp
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|sp
operator|=
name|getc
argument_list|(
name|pin
argument_list|)
operator|)
operator|!=
literal|':'
condition|)
name|sp
operator|++
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
expr_stmt|;
goto|goto
name|RET
goto|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|pin
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
do|;
name|RET
label|:
name|fclose
argument_list|(
name|pin
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|descend
argument_list|(
argument|name
argument_list|,
argument|fname
argument_list|,
argument|exlist
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|anode
modifier|*
name|exlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DIR
modifier|*
name|dir
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|c1
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|endofname
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|fname
argument_list|,
operator|&
name|Statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: bad status< %s>\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
call|(
modifier|*
name|exlist
operator|->
name|F
call|)
argument_list|(
name|exlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|c1
operator|=
name|name
init|;
operator|*
name|c1
condition|;
operator|++
name|c1
control|)
empty_stmt|;
if|if
condition|(
operator|*
operator|(
name|c1
operator|-
literal|1
operator|)
operator|==
literal|'/'
condition|)
operator|--
name|c1
expr_stmt|;
name|endofname
operator|=
name|c1
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|fname
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|dir
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: cannot open< %s>\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
for|for
control|(
name|dp
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
continue|continue;
name|c1
operator|=
name|endofname
expr_stmt|;
operator|*
name|c1
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|c1
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|Fname
operator|=
name|endofname
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|descend
argument_list|(
name|name
argument_list|,
name|Fname
argument_list|,
name|exlist
argument_list|)
condition|)
block|{
operator|*
name|endofname
operator|=
literal|'\0'
expr_stmt|;
name|chdir
argument_list|(
name|Home
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|Pathname
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: bad directory tree\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|rv
operator|=
literal|1
expr_stmt|;
name|ret
label|:
if|if
condition|(
name|dir
condition|)
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
literal|".."
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|endofname
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: bad directory<%s>\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|gmatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
comment|/* string match as in glob */
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
operator|*
name|p
operator|!=
literal|'.'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
name|amatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
name|amatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|cc
expr_stmt|;
name|int
name|scc
decl_stmt|,
name|k
decl_stmt|;
name|int
name|c
decl_stmt|,
name|lc
decl_stmt|;
name|scc
operator|=
operator|*
name|s
expr_stmt|;
name|lc
operator|=
literal|077777
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
condition|)
block|{
case|case
literal|'['
case|:
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cc
operator|=
operator|*
operator|++
name|p
condition|)
block|{
switch|switch
condition|(
name|cc
condition|)
block|{
case|case
literal|']'
case|:
if|if
condition|(
name|k
condition|)
return|return
operator|(
name|amatch
argument_list|(
operator|++
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'-'
case|:
name|k
operator||=
name|lc
operator|<=
name|scc
operator|&
name|scc
operator|<=
operator|(
name|cc
operator|=
name|p
index|[
literal|1
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|scc
operator|==
operator|(
name|lc
operator|=
name|cc
operator|)
condition|)
name|k
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'?'
case|:
name|caseq
label|:
if|if
condition|(
name|scc
condition|)
return|return
operator|(
name|amatch
argument_list|(
operator|++
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'*'
case|:
return|return
operator|(
name|umatch
argument_list|(
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
case|case
literal|0
case|:
return|return
operator|(
operator|!
name|scc
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|scc
condition|)
goto|goto
name|caseq
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|umatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
name|amatch
argument_list|(
name|s
operator|++
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|bwrite
argument_list|(
name|rp
argument_list|,
name|c
argument_list|)
specifier|register
name|short
operator|*
name|rp
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|short
modifier|*
name|wp
init|=
name|Wp
decl_stmt|;
name|c
operator|=
operator|(
name|c
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|--
condition|)
block|{
if|if
condition|(
operator|!
name|Wct
condition|)
block|{
name|again
label|:
if|if
condition|(
name|write
argument_list|(
name|Cpio
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Dbuf
argument_list|,
name|Bufsize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Cpio
operator|=
name|chgreel
argument_list|(
literal|1
argument_list|,
name|Cpio
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|Wct
operator|=
name|Bufsize
operator|>>
literal|1
expr_stmt|;
name|wp
operator|=
name|Dbuf
expr_stmt|;
operator|++
name|Blocks
expr_stmt|;
block|}
operator|*
name|wp
operator|++
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
operator|--
name|Wct
expr_stmt|;
block|}
name|Wp
operator|=
name|wp
expr_stmt|;
block|}
end_block

begin_macro
name|chgreel
argument_list|(
argument|x
argument_list|,
argument|fl
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|f
expr_stmt|;
name|char
name|str
index|[
literal|22
index|]
decl_stmt|;
name|FILE
modifier|*
name|devtty
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
extern|extern errno;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: errno: %d, "
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: can't %s\n"
argument_list|,
name|x
condition|?
literal|"write output"
else|:
literal|"read input"
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|fl
argument_list|,
operator|&
name|statb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFCHR
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|again
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"If you want to go on, type device/file name %s\n"
argument_list|,
literal|"when ready"
argument_list|)
expr_stmt|;
name|devtty
operator|=
name|fopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|str
argument_list|,
literal|20
argument_list|,
name|devtty
argument_list|)
expr_stmt|;
name|str
index|[
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|str
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|str
argument_list|,
name|x
condition|?
literal|1
else|:
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"That didn't work"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|devtty
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
name|f
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|AMES
end_ifdef

begin_comment
comment|/*  * 'fastfind' scans a file list for the full pathname of a file  * given only a piece of the name.  The list has been processed with  * with "front-compression" and bigram coding.  Front compression reduces  * space by a factor of 4-5, bigram coding by a further 20-25%.  * The codes are:  *  *	0-28	likeliest differential counts + offset to make nonnegative   *	30	escape code for out-of-range count to follow in next word  *	128-255 bigram codes, (128 most common, as determined by 'updatedb')  *	32-127  single character (printable) ascii residue  *  * A novel two-tiered string search technique is employed:   *  * First, a metacharacter-free subpattern and partial pathname is  * matched BACKWARDS to avoid full expansion of the pathname list.  * The time savings is 40-50% over forward matching, which cannot efficiently  * handle overlapped search patterns and compressed path residue.  *  * Then, the actual shell glob-style regular expression (if in this form)  * is matched against the candidate pathnames using the slower routines  * provided in the standard 'find'.  */
end_comment

begin_define
define|#
directive|define
name|FCODES
value|"/usr/lib/find/find.codes"
end_define

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_define
define|#
directive|define
name|OFFSET
value|14
end_define

begin_define
define|#
directive|define
name|ESCCODE
value|30
end_define

begin_macro
name|fastfind
argument_list|(
argument|pathpart
argument_list|)
end_macro

begin_decl_stmt
name|char
name|pathpart
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|patprep
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|globflag
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|fopen
argument_list|()
decl_stmt|;
name|char
modifier|*
name|patend
decl_stmt|,
modifier|*
name|cutoff
decl_stmt|;
name|char
name|path
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|bigram1
index|[
literal|128
index|]
decl_stmt|,
name|bigram2
index|[
literal|128
index|]
decl_stmt|;
name|int
name|found
init|=
name|NO
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|FCODES
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
literal|"find: can't open %s\n"
argument_list|,
name|FCODES
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
name|bigram1
index|[
name|i
index|]
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|,
name|bigram2
index|[
name|i
index|]
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|pathpart
argument_list|,
literal|'*'
argument_list|)
operator|||
name|index
argument_list|(
name|pathpart
argument_list|,
literal|'?'
argument_list|)
operator|||
name|index
argument_list|(
name|pathpart
argument_list|,
literal|'['
argument_list|)
condition|)
name|globflag
operator|=
name|YES
expr_stmt|;
name|patend
operator|=
name|patprep
argument_list|(
name|pathpart
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|count
operator|+=
operator|(
operator|(
name|c
operator|==
name|ESCCODE
operator|)
condition|?
name|getw
argument_list|(
name|fp
argument_list|)
else|:
name|c
operator|)
operator|-
name|OFFSET
expr_stmt|;
for|for
control|(
name|p
operator|=
name|path
operator|+
name|count
init|;
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|>
name|ESCCODE
condition|;
control|)
comment|/* overlay old path */
if|if
condition|(
name|c
operator|<
literal|0200
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
else|else
comment|/* bigrams are parity-marked */
operator|*
name|p
operator|++
operator|=
name|bigram1
index|[
name|c
operator|&
literal|0177
index|]
operator|,
operator|*
name|p
operator|++
operator|=
name|bigram2
index|[
name|c
operator|&
literal|0177
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
operator|*
name|p
operator|--
operator|=
name|NULL
expr_stmt|;
name|cutoff
operator|=
operator|(
name|found
condition|?
name|path
else|:
name|path
operator|+
name|count
operator|)
expr_stmt|;
for|for
control|(
name|found
operator|=
name|NO
operator|,
name|s
operator|=
name|p
init|;
name|s
operator|>=
name|cutoff
condition|;
name|s
operator|--
control|)
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|patend
condition|)
block|{
comment|/* fast first char check */
for|for
control|(
name|p
operator|=
name|patend
operator|-
literal|1
operator|,
name|q
operator|=
name|s
operator|-
literal|1
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|--
operator|,
name|q
operator|--
control|)
if|if
condition|(
operator|*
name|q
operator|!=
operator|*
name|p
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* success on fast match */
name|found
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|globflag
operator|==
name|NO
operator|||
name|amatch
argument_list|(
name|path
argument_list|,
name|pathpart
argument_list|)
condition|)
name|puts
argument_list|(
name|path
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*     extract first glob-free subpattern for fast pre-match;     prepend NULL for backwards match; return end of pattern */
end_comment

begin_decl_stmt
specifier|static
name|char
name|globfree
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|patprep
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|subp
init|=
name|globfree
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|*
name|p
operator|==
literal|'?'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|']'
operator|&&
operator|*
name|p
operator|!=
name|NULL
condition|)
name|p
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|subp
operator|++
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
name|NULL
condition|)
comment|/* copy first noglob string */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'*'
operator|&&
operator|*
name|p
operator|!=
literal|'?'
operator|&&
operator|*
name|p
operator|!=
literal|'['
operator|&&
operator|*
name|p
operator|!=
name|NULL
operator|&&
name|subp
operator|<
operator|(
name|globfree
operator|+
sizeof|sizeof
argument_list|(
name|globfree
argument_list|)
operator|)
condition|)
operator|*
name|subp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
else|else
comment|/* pattern has noglob chars only */
operator|*
name|subp
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* ... check every path */
operator|*
name|subp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|--
name|subp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

