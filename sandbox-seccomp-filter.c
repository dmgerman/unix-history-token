begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2012 Will Drewry<wad@dataspill.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Uncomment the SANDBOX_SECCOMP_FILTER_DEBUG macro below to help diagnose  * filter breakage during development. *Do not* use this in production,  * as it relies on making library calls that are unsafe in signal context.  *  * Instead, live systems the auditctl(8) may be used to monitor failures.  * E.g.  *   auditctl -a task,always -F uid=<privsep uid>  */
end_comment

begin_comment
comment|/* #define SANDBOX_SECCOMP_FILTER_DEBUG 1 */
end_comment

begin_comment
comment|/* XXX it should be possible to do logging via the log socket safely */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SANDBOX_SECCOMP_FILTER_DEBUG
end_ifdef

begin_comment
comment|/* Use the kernel headers in case of an older toolchain. */
end_comment

begin_include
include|#
directive|include
file|<asm/siginfo.h>
end_include

begin_define
define|#
directive|define
name|__have_siginfo_t
value|1
end_define

begin_define
define|#
directive|define
name|__have_sigval_t
value|1
end_define

begin_define
define|#
directive|define
name|__have_sigevent_t
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SANDBOX_SECCOMP_FILTER_DEBUG */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SANDBOX_SECCOMP_FILTER
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/prctl.h>
end_include

begin_include
include|#
directive|include
file|<linux/net.h>
end_include

begin_include
include|#
directive|include
file|<linux/audit.h>
end_include

begin_include
include|#
directive|include
file|<linux/filter.h>
end_include

begin_include
include|#
directive|include
file|<linux/seccomp.h>
end_include

begin_include
include|#
directive|include
file|<elf.h>
end_include

begin_include
include|#
directive|include
file|<asm/unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* for offsetof */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"ssh-sandbox.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_comment
comment|/* Linux seccomp_filter sandbox */
end_comment

begin_define
define|#
directive|define
name|SECCOMP_FILTER_FAIL
value|SECCOMP_RET_KILL
end_define

begin_comment
comment|/* Use a signal handler to emit violations when debugging */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SANDBOX_SECCOMP_FILTER_DEBUG
end_ifdef

begin_undef
undef|#
directive|undef
name|SECCOMP_FILTER_FAIL
end_undef

begin_define
define|#
directive|define
name|SECCOMP_FILTER_FAIL
value|SECCOMP_RET_TRAP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SANDBOX_SECCOMP_FILTER_DEBUG */
end_comment

begin_if
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__LITTLE_ENDIAN
end_if

begin_define
define|#
directive|define
name|ARG_LO_OFFSET
value|0
end_define

begin_define
define|#
directive|define
name|ARG_HI_OFFSET
value|sizeof(uint32_t)
end_define

begin_elif
elif|#
directive|elif
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
end_elif

begin_define
define|#
directive|define
name|ARG_LO_OFFSET
value|sizeof(uint32_t)
end_define

begin_define
define|#
directive|define
name|ARG_HI_OFFSET
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"Unknown endianness"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Simple helpers to avoid manual errors (but larger BPF programs). */
end_comment

begin_define
define|#
directive|define
name|SC_DENY
parameter_list|(
name|_nr
parameter_list|,
name|_errno
parameter_list|)
define|\
value|BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (_nr), 0, 1), \ 	BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ERRNO|(_errno))
end_define

begin_define
define|#
directive|define
name|SC_ALLOW
parameter_list|(
name|_nr
parameter_list|)
define|\
value|BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (_nr), 0, 1), \ 	BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)
end_define

begin_define
define|#
directive|define
name|SC_ALLOW_ARG
parameter_list|(
name|_nr
parameter_list|,
name|_arg_nr
parameter_list|,
name|_arg_val
parameter_list|)
define|\
value|BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (_nr), 0, 6), \
comment|/* load and test first syscall argument, low word */
value|\ 	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, \ 	    offsetof(struct seccomp_data, args[(_arg_nr)]) + ARG_LO_OFFSET), \ 	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, \ 	    ((_arg_val)& 0xFFFFFFFF), 0, 3), \
comment|/* load and test first syscall argument, high word */
value|\ 	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, \ 	    offsetof(struct seccomp_data, args[(_arg_nr)]) + ARG_HI_OFFSET), \ 	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, \ 	    (((uint32_t)((uint64_t)(_arg_val)>> 32))& 0xFFFFFFFF), 0, 1), \ 	BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW), \
comment|/* reload syscall number; all rules expect it in accumulator */
value|\ 	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, \ 		offsetof(struct seccomp_data, nr))
end_define

begin_comment
comment|/* Syscall filtering set for preauth. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sock_filter
name|preauth_insns
index|[]
init|=
block|{
comment|/* Ensure the syscall arch convention is as expected. */
name|BPF_STMT
argument_list|(
name|BPF_LD
operator|+
name|BPF_W
operator|+
name|BPF_ABS
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|seccomp_data
argument_list|,
name|arch
argument_list|)
argument_list|)
block|,
name|BPF_JUMP
argument_list|(
name|BPF_JMP
operator|+
name|BPF_JEQ
operator|+
name|BPF_K
argument_list|,
name|SECCOMP_AUDIT_ARCH
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
block|,
name|BPF_STMT
argument_list|(
name|BPF_RET
operator|+
name|BPF_K
argument_list|,
name|SECCOMP_FILTER_FAIL
argument_list|)
block|,
comment|/* Load the syscall number for checking. */
name|BPF_STMT
argument_list|(
name|BPF_LD
operator|+
name|BPF_W
operator|+
name|BPF_ABS
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|seccomp_data
argument_list|,
name|nr
argument_list|)
argument_list|)
block|,
comment|/* Syscalls to non-fatally deny */
ifdef|#
directive|ifdef
name|__NR_lstat
name|SC_DENY
argument_list|(
name|__NR_lstat
argument_list|,
name|EACCES
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_lstat64
name|SC_DENY
argument_list|(
name|__NR_lstat64
argument_list|,
name|EACCES
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_fstat
name|SC_DENY
argument_list|(
name|__NR_fstat
argument_list|,
name|EACCES
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_fstat64
name|SC_DENY
argument_list|(
name|__NR_fstat64
argument_list|,
name|EACCES
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_open
name|SC_DENY
argument_list|(
name|__NR_open
argument_list|,
name|EACCES
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_openat
name|SC_DENY
argument_list|(
name|__NR_openat
argument_list|,
name|EACCES
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_newfstatat
name|SC_DENY
argument_list|(
name|__NR_newfstatat
argument_list|,
name|EACCES
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_stat
name|SC_DENY
argument_list|(
name|__NR_stat
argument_list|,
name|EACCES
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_stat64
name|SC_DENY
argument_list|(
name|__NR_stat64
argument_list|,
name|EACCES
argument_list|)
block|,
endif|#
directive|endif
comment|/* Syscalls to permit */
ifdef|#
directive|ifdef
name|__NR_brk
name|SC_ALLOW
argument_list|(
name|__NR_brk
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_clock_gettime
name|SC_ALLOW
argument_list|(
name|__NR_clock_gettime
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_close
name|SC_ALLOW
argument_list|(
name|__NR_close
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_exit
name|SC_ALLOW
argument_list|(
name|__NR_exit
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_exit_group
name|SC_ALLOW
argument_list|(
name|__NR_exit_group
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_getpgid
name|SC_ALLOW
argument_list|(
name|__NR_getpgid
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_getpid
name|SC_ALLOW
argument_list|(
name|__NR_getpid
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_getrandom
name|SC_ALLOW
argument_list|(
name|__NR_getrandom
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_gettimeofday
name|SC_ALLOW
argument_list|(
name|__NR_gettimeofday
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_madvise
name|SC_ALLOW
argument_list|(
name|__NR_madvise
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_mmap
name|SC_ALLOW
argument_list|(
name|__NR_mmap
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_mmap2
name|SC_ALLOW
argument_list|(
name|__NR_mmap2
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_mremap
name|SC_ALLOW
argument_list|(
name|__NR_mremap
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_munmap
name|SC_ALLOW
argument_list|(
name|__NR_munmap
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR__newselect
name|SC_ALLOW
argument_list|(
name|__NR__newselect
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_poll
name|SC_ALLOW
argument_list|(
name|__NR_poll
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_pselect6
name|SC_ALLOW
argument_list|(
name|__NR_pselect6
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_read
name|SC_ALLOW
argument_list|(
name|__NR_read
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_rt_sigprocmask
name|SC_ALLOW
argument_list|(
name|__NR_rt_sigprocmask
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_select
name|SC_ALLOW
argument_list|(
name|__NR_select
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_shutdown
name|SC_ALLOW
argument_list|(
name|__NR_shutdown
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_sigprocmask
name|SC_ALLOW
argument_list|(
name|__NR_sigprocmask
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_time
name|SC_ALLOW
argument_list|(
name|__NR_time
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_write
name|SC_ALLOW
argument_list|(
name|__NR_write
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NR_socketcall
name|SC_ALLOW_ARG
argument_list|(
name|__NR_socketcall
argument_list|,
literal|0
argument_list|,
name|SYS_SHUTDOWN
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__NR_ioctl
argument_list|)
operator|&&
name|defined
argument_list|(
name|__s390__
argument_list|)
comment|/* Allow ioctls for ICA crypto card on s390 */
name|SC_ALLOW_ARG
argument_list|(
name|__NR_ioctl
argument_list|,
literal|1
argument_list|,
name|Z90STAT_STATUS_MASK
argument_list|)
block|,
name|SC_ALLOW_ARG
argument_list|(
name|__NR_ioctl
argument_list|,
literal|1
argument_list|,
name|ICARSAMODEXPO
argument_list|)
block|,
name|SC_ALLOW_ARG
argument_list|(
name|__NR_ioctl
argument_list|,
literal|1
argument_list|,
name|ICARSACRT
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__ILP32__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__X32_SYSCALL_BIT
argument_list|)
comment|/* 	 * On Linux x32, the clock_gettime VDSO falls back to the 	 * x86-64 syscall under some circumstances, e.g. 	 * https://bugs.debian.org/849923 	 */
name|SC_ALLOW
argument_list|(
name|__NR_clock_gettime
operator|&
operator|~
name|__X32_SYSCALL_BIT
argument_list|)
block|;
endif|#
directive|endif
comment|/* Default deny */
name|BPF_STMT
argument_list|(
name|BPF_RET
operator|+
name|BPF_K
argument_list|,
name|SECCOMP_FILTER_FAIL
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sock_fprog
name|preauth_program
init|=
block|{
operator|.
name|len
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|preauth_insns
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|preauth_insns
index|[
literal|0
index|]
argument_list|)
argument_list|)
block|,
operator|.
name|filter
operator|=
operator|(
expr|struct
name|sock_filter
operator|*
operator|)
name|preauth_insns
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ssh_sandbox
block|{
name|pid_t
name|child_pid
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|struct
name|ssh_sandbox
modifier|*
name|ssh_sandbox_init
parameter_list|(
name|struct
name|monitor
modifier|*
name|monitor
parameter_list|)
block|{
name|struct
name|ssh_sandbox
modifier|*
name|box
decl_stmt|;
comment|/* 	 * Strictly, we don't need to maintain any state here but we need 	 * to return non-NULL to satisfy the API. 	 */
name|debug3
argument_list|(
literal|"%s: preparing seccomp filter sandbox"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|box
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|box
argument_list|)
argument_list|)
expr_stmt|;
name|box
operator|->
name|child_pid
operator|=
literal|0
expr_stmt|;
return|return
name|box
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SANDBOX_SECCOMP_FILTER_DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|monitor
modifier|*
name|pmonitor
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|mm_log_handler
parameter_list|(
name|LogLevel
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|ssh_sandbox_violation
parameter_list|(
name|int
name|signum
parameter_list|,
name|siginfo_t
modifier|*
name|info
parameter_list|,
name|void
modifier|*
name|void_context
parameter_list|)
block|{
name|char
name|msg
index|[
literal|256
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"%s: unexpected system call (arch:0x%x,syscall:%d @ %p)"
argument_list|,
name|__func__
argument_list|,
name|info
operator|->
name|si_arch
argument_list|,
name|info
operator|->
name|si_syscall
argument_list|,
name|info
operator|->
name|si_call_addr
argument_list|)
expr_stmt|;
name|mm_log_handler
argument_list|(
name|SYSLOG_LEVEL_FATAL
argument_list|,
name|msg
argument_list|,
name|pmonitor
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ssh_sandbox_child_debugging
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sigaction
name|act
decl_stmt|;
name|sigset_t
name|mask
decl_stmt|;
name|debug3
argument_list|(
literal|"%s: installing SIGSYS handler"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|act
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|act
argument_list|)
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGSYS
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_sigaction
operator|=
operator|&
name|ssh_sandbox_violation
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
name|SA_SIGINFO
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGSYS
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: sigaction(SIGSYS): %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|mask
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: sigprocmask(SIGSYS): %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SANDBOX_SECCOMP_FILTER_DEBUG */
end_comment

begin_function
name|void
name|ssh_sandbox_child
parameter_list|(
name|struct
name|ssh_sandbox
modifier|*
name|box
parameter_list|)
block|{
name|struct
name|rlimit
name|rl_zero
decl_stmt|;
name|int
name|nnp_failed
init|=
literal|0
decl_stmt|;
comment|/* Set rlimits for completeness if possible. */
name|rl_zero
operator|.
name|rlim_cur
operator|=
name|rl_zero
operator|.
name|rlim_max
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|RLIMIT_FSIZE
argument_list|,
operator|&
name|rl_zero
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: setrlimit(RLIMIT_FSIZE, { 0, 0 }): %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|rl_zero
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: setrlimit(RLIMIT_NOFILE, { 0, 0 }): %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|RLIMIT_NPROC
argument_list|,
operator|&
name|rl_zero
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: setrlimit(RLIMIT_NPROC, { 0, 0 }): %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SANDBOX_SECCOMP_FILTER_DEBUG
name|ssh_sandbox_child_debugging
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SANDBOX_SECCOMP_FILTER_DEBUG */
name|debug3
argument_list|(
literal|"%s: setting PR_SET_NO_NEW_PRIVS"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|prctl
argument_list|(
name|PR_SET_NO_NEW_PRIVS
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|debug
argument_list|(
literal|"%s: prctl(PR_SET_NO_NEW_PRIVS): %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|nnp_failed
operator|=
literal|1
expr_stmt|;
block|}
name|debug3
argument_list|(
literal|"%s: attaching seccomp filter program"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|prctl
argument_list|(
name|PR_SET_SECCOMP
argument_list|,
name|SECCOMP_MODE_FILTER
argument_list|,
operator|&
name|preauth_program
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|debug
argument_list|(
literal|"%s: prctl(PR_SET_SECCOMP): %s"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nnp_failed
condition|)
name|fatal
argument_list|(
literal|"%s: SECCOMP_MODE_FILTER activated but "
literal|"PR_SET_NO_NEW_PRIVS failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ssh_sandbox_parent_finish
parameter_list|(
name|struct
name|ssh_sandbox
modifier|*
name|box
parameter_list|)
block|{
name|free
argument_list|(
name|box
argument_list|)
expr_stmt|;
name|debug3
argument_list|(
literal|"%s: finished"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ssh_sandbox_parent_preauth
parameter_list|(
name|struct
name|ssh_sandbox
modifier|*
name|box
parameter_list|,
name|pid_t
name|child_pid
parameter_list|)
block|{
name|box
operator|->
name|child_pid
operator|=
name|child_pid
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SANDBOX_SECCOMP_FILTER */
end_comment

end_unit

