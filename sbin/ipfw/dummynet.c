begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2003 Luigi Rizzo  * Copyright (c) 1996 Alex Nash, Paul Traina, Poul-Henning Kamp  * Copyright (c) 1994 Ugen J.S.Antsilevich  *  * Idea and grammar partially left from:  * Copyright (c) 1993 Daniel Boulet  *  * Redistribution and use in source forms, with and without modification,  * are permitted provided that this entire comment appears intact.  *  * Redistribution in binary form may occur without any restrictions.  * Obviously, it would be nice if you gave credit where credit is due  * but requiring it would be too onerous.  *  * This software is provided ``AS IS'' without any warranties of any kind.  *  * NEW command line interface for IP firewall facility  *  * $FreeBSD$  *  * dummynet support  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_comment
comment|/* XXX there are several sysctl leftover here */
end_comment

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|"ipfw2.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_dummynet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_comment
comment|/* inet_ntoa */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|_s_x
name|dummynet_params
index|[]
init|=
block|{
block|{
literal|"plr"
block|,
name|TOK_PLR
block|}
block|,
block|{
literal|"noerror"
block|,
name|TOK_NOERROR
block|}
block|,
block|{
literal|"buckets"
block|,
name|TOK_BUCKETS
block|}
block|,
block|{
literal|"dst-ip"
block|,
name|TOK_DSTIP
block|}
block|,
block|{
literal|"src-ip"
block|,
name|TOK_SRCIP
block|}
block|,
block|{
literal|"dst-port"
block|,
name|TOK_DSTPORT
block|}
block|,
block|{
literal|"src-port"
block|,
name|TOK_SRCPORT
block|}
block|,
block|{
literal|"proto"
block|,
name|TOK_PROTO
block|}
block|,
block|{
literal|"weight"
block|,
name|TOK_WEIGHT
block|}
block|,
block|{
literal|"all"
block|,
name|TOK_ALL
block|}
block|,
block|{
literal|"mask"
block|,
name|TOK_MASK
block|}
block|,
block|{
literal|"droptail"
block|,
name|TOK_DROPTAIL
block|}
block|,
block|{
literal|"red"
block|,
name|TOK_RED
block|}
block|,
block|{
literal|"gred"
block|,
name|TOK_GRED
block|}
block|,
block|{
literal|"bw"
block|,
name|TOK_BW
block|}
block|,
block|{
literal|"bandwidth"
block|,
name|TOK_BW
block|}
block|,
block|{
literal|"delay"
block|,
name|TOK_DELAY
block|}
block|,
block|{
literal|"pipe"
block|,
name|TOK_PIPE
block|}
block|,
block|{
literal|"queue"
block|,
name|TOK_QUEUE
block|}
block|,
block|{
literal|"flow-id"
block|,
name|TOK_FLOWID
block|}
block|,
block|{
literal|"dst-ipv6"
block|,
name|TOK_DSTIP6
block|}
block|,
block|{
literal|"dst-ip6"
block|,
name|TOK_DSTIP6
block|}
block|,
block|{
literal|"src-ipv6"
block|,
name|TOK_SRCIP6
block|}
block|,
block|{
literal|"src-ip6"
block|,
name|TOK_SRCIP6
block|}
block|,
block|{
literal|"profile"
block|,
name|TOK_PIPE_PROFILE
block|}
block|,
block|{
literal|"burst"
block|,
name|TOK_BURST
block|}
block|,
block|{
literal|"dummynet-params"
block|,
name|TOK_NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
comment|/* terminator */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sort_q
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|void
modifier|*
name|pa
parameter_list|,
specifier|const
name|void
modifier|*
name|pb
parameter_list|)
block|{
name|int
name|rev
init|=
operator|(
name|co
operator|.
name|do_sort
operator|<
literal|0
operator|)
decl_stmt|;
name|int
name|field
init|=
name|rev
condition|?
operator|-
name|co
operator|.
name|do_sort
else|:
name|co
operator|.
name|do_sort
decl_stmt|;
name|long
name|long
name|res
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|dn_flow_queue
modifier|*
name|a
init|=
name|pa
decl_stmt|;
specifier|const
name|struct
name|dn_flow_queue
modifier|*
name|b
init|=
name|pb
decl_stmt|;
switch|switch
condition|(
name|field
condition|)
block|{
case|case
literal|1
case|:
comment|/* pkts */
name|res
operator|=
name|a
operator|->
name|len
operator|-
name|b
operator|->
name|len
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* bytes */
name|res
operator|=
name|a
operator|->
name|len_bytes
operator|-
name|b
operator|->
name|len_bytes
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* tot pkts */
name|res
operator|=
name|a
operator|->
name|tot_pkts
operator|-
name|b
operator|->
name|tot_pkts
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* tot bytes */
name|res
operator|=
name|a
operator|->
name|tot_bytes
operator|-
name|b
operator|->
name|tot_bytes
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|res
operator|<
literal|0
condition|)
name|res
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
name|res
operator|=
literal|1
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|rev
condition|?
name|res
else|:
operator|-
name|res
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|list_queues
parameter_list|(
name|struct
name|dn_flow_set
modifier|*
name|fs
parameter_list|,
name|struct
name|dn_flow_queue
modifier|*
name|q
parameter_list|)
block|{
name|int
name|l
decl_stmt|;
name|int
name|index_printed
decl_stmt|,
name|indexes
init|=
literal|0
decl_stmt|;
name|char
name|buff
index|[
literal|255
index|]
decl_stmt|;
name|struct
name|protoent
modifier|*
name|pe
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|rq_elements
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|co
operator|.
name|do_sort
operator|!=
literal|0
condition|)
name|qsort_r
argument_list|(
name|q
argument_list|,
name|fs
operator|->
name|rq_elements
argument_list|,
sizeof|sizeof
expr|*
name|q
argument_list|,
name|NULL
argument_list|,
name|sort_q
argument_list|)
expr_stmt|;
comment|/* Print IPv4 flows */
name|index_printed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|fs
operator|->
name|rq_elements
condition|;
name|l
operator|++
control|)
block|{
name|struct
name|in_addr
name|ina
decl_stmt|;
comment|/* XXX: Should check for IPv4 flows */
if|if
condition|(
name|IS_IP6_FLOW_ID
argument_list|(
operator|&
operator|(
name|q
index|[
name|l
index|]
operator|.
name|id
operator|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|index_printed
condition|)
block|{
name|index_printed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|indexes
operator|>
literal|0
condition|)
comment|/* currently a no-op */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|indexes
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"    "
literal|"mask: 0x%02x 0x%08x/0x%04x -> 0x%08x/0x%04x\n"
argument_list|,
name|fs
operator|->
name|flow_mask
operator|.
name|proto
argument_list|,
name|fs
operator|->
name|flow_mask
operator|.
name|src_ip
argument_list|,
name|fs
operator|->
name|flow_mask
operator|.
name|src_port
argument_list|,
name|fs
operator|->
name|flow_mask
operator|.
name|dst_ip
argument_list|,
name|fs
operator|->
name|flow_mask
operator|.
name|dst_port
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BKT Prot ___Source IP/port____ "
literal|"____Dest. IP/port____ "
literal|"Tot_pkt/bytes Pkt/Byte Drp\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%3d "
argument_list|,
name|q
index|[
name|l
index|]
operator|.
name|hash_slot
argument_list|)
expr_stmt|;
name|pe
operator|=
name|getprotobynumber
argument_list|(
name|q
index|[
name|l
index|]
operator|.
name|id
operator|.
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
condition|)
name|printf
argument_list|(
literal|"%-4s "
argument_list|,
name|pe
operator|->
name|p_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%4u "
argument_list|,
name|q
index|[
name|l
index|]
operator|.
name|id
operator|.
name|proto
argument_list|)
expr_stmt|;
name|ina
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|q
index|[
name|l
index|]
operator|.
name|id
operator|.
name|src_ip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%15s/%-5d "
argument_list|,
name|inet_ntoa
argument_list|(
name|ina
argument_list|)
argument_list|,
name|q
index|[
name|l
index|]
operator|.
name|id
operator|.
name|src_port
argument_list|)
expr_stmt|;
name|ina
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|q
index|[
name|l
index|]
operator|.
name|id
operator|.
name|dst_ip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%15s/%-5d "
argument_list|,
name|inet_ntoa
argument_list|(
name|ina
argument_list|)
argument_list|,
name|q
index|[
name|l
index|]
operator|.
name|id
operator|.
name|dst_port
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%4llu %8llu %2u %4u %3u\n"
argument_list|,
name|align_uint64
argument_list|(
operator|&
name|q
index|[
name|l
index|]
operator|.
name|tot_pkts
argument_list|)
argument_list|,
name|align_uint64
argument_list|(
operator|&
name|q
index|[
name|l
index|]
operator|.
name|tot_bytes
argument_list|)
argument_list|,
name|q
index|[
name|l
index|]
operator|.
name|len
argument_list|,
name|q
index|[
name|l
index|]
operator|.
name|len_bytes
argument_list|,
name|q
index|[
name|l
index|]
operator|.
name|drops
argument_list|)
expr_stmt|;
if|if
condition|(
name|co
operator|.
name|verbose
condition|)
name|printf
argument_list|(
literal|"   S %20llu  F %20llu\n"
argument_list|,
name|align_uint64
argument_list|(
operator|&
name|q
index|[
name|l
index|]
operator|.
name|S
argument_list|)
argument_list|,
name|align_uint64
argument_list|(
operator|&
name|q
index|[
name|l
index|]
operator|.
name|F
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Print IPv6 flows */
name|index_printed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|fs
operator|->
name|rq_elements
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|IS_IP6_FLOW_ID
argument_list|(
operator|&
operator|(
name|q
index|[
name|l
index|]
operator|.
name|id
operator|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|index_printed
condition|)
block|{
name|index_printed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|indexes
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|indexes
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"\n        mask: proto: 0x%02x, flow_id: 0x%08x,  "
argument_list|,
name|fs
operator|->
name|flow_mask
operator|.
name|proto
argument_list|,
name|fs
operator|->
name|flow_mask
operator|.
name|flow_id6
argument_list|)
expr_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
operator|(
name|fs
operator|->
name|flow_mask
operator|.
name|src_ip6
operator|)
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s/0x%04x -> "
argument_list|,
name|buff
argument_list|,
name|fs
operator|->
name|flow_mask
operator|.
name|src_port
argument_list|)
expr_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
operator|(
name|fs
operator|->
name|flow_mask
operator|.
name|dst_ip6
operator|)
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s/0x%04x\n"
argument_list|,
name|buff
argument_list|,
name|fs
operator|->
name|flow_mask
operator|.
name|dst_port
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BKT ___Prot___ _flow-id_ "
literal|"______________Source IPv6/port_______________ "
literal|"_______________Dest. IPv6/port_______________ "
literal|"Tot_pkt/bytes Pkt/Byte Drp\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%3d "
argument_list|,
name|q
index|[
name|l
index|]
operator|.
name|hash_slot
argument_list|)
expr_stmt|;
name|pe
operator|=
name|getprotobynumber
argument_list|(
name|q
index|[
name|l
index|]
operator|.
name|id
operator|.
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%9s "
argument_list|,
name|pe
operator|->
name|p_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%9u "
argument_list|,
name|q
index|[
name|l
index|]
operator|.
name|id
operator|.
name|proto
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%7d  %39s/%-5d "
argument_list|,
name|q
index|[
name|l
index|]
operator|.
name|id
operator|.
name|flow_id6
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
operator|(
name|q
index|[
name|l
index|]
operator|.
name|id
operator|.
name|src_ip6
operator|)
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|)
argument_list|,
name|q
index|[
name|l
index|]
operator|.
name|id
operator|.
name|src_port
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %39s/%-5d "
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
operator|(
name|q
index|[
name|l
index|]
operator|.
name|id
operator|.
name|dst_ip6
operator|)
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|)
argument_list|,
name|q
index|[
name|l
index|]
operator|.
name|id
operator|.
name|dst_port
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %4llu %8llu %2u %4u %3u\n"
argument_list|,
name|align_uint64
argument_list|(
operator|&
name|q
index|[
name|l
index|]
operator|.
name|tot_pkts
argument_list|)
argument_list|,
name|align_uint64
argument_list|(
operator|&
name|q
index|[
name|l
index|]
operator|.
name|tot_bytes
argument_list|)
argument_list|,
name|q
index|[
name|l
index|]
operator|.
name|len
argument_list|,
name|q
index|[
name|l
index|]
operator|.
name|len_bytes
argument_list|,
name|q
index|[
name|l
index|]
operator|.
name|drops
argument_list|)
expr_stmt|;
if|if
condition|(
name|co
operator|.
name|verbose
condition|)
name|printf
argument_list|(
literal|"   S %20llu  F %20llu\n"
argument_list|,
name|align_uint64
argument_list|(
operator|&
name|q
index|[
name|l
index|]
operator|.
name|S
argument_list|)
argument_list|,
name|align_uint64
argument_list|(
operator|&
name|q
index|[
name|l
index|]
operator|.
name|F
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_flowset_parms
parameter_list|(
name|struct
name|dn_flow_set
modifier|*
name|fs
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|l
decl_stmt|;
name|char
name|qs
index|[
literal|30
index|]
decl_stmt|;
name|char
name|plr
index|[
literal|30
index|]
decl_stmt|;
name|char
name|red
index|[
literal|90
index|]
decl_stmt|;
comment|/* Display RED parameters */
name|l
operator|=
name|fs
operator|->
name|qsize
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|flags_fs
operator|&
name|DN_QSIZE_IS_BYTES
condition|)
block|{
if|if
condition|(
name|l
operator|>=
literal|8192
condition|)
name|sprintf
argument_list|(
name|qs
argument_list|,
literal|"%d KB"
argument_list|,
name|l
operator|/
literal|1024
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|qs
argument_list|,
literal|"%d B"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|qs
argument_list|,
literal|"%3d sl."
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|plr
condition|)
name|sprintf
argument_list|(
name|plr
argument_list|,
literal|"plr %f"
argument_list|,
literal|1.0
operator|*
name|fs
operator|->
name|plr
operator|/
call|(
name|double
call|)
argument_list|(
literal|0x7fffffff
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|plr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|flags_fs
operator|&
name|DN_IS_RED
condition|)
comment|/* RED parameters */
name|sprintf
argument_list|(
name|red
argument_list|,
literal|"\n\t %cRED w_q %f min_th %d max_th %d max_p %f"
argument_list|,
operator|(
name|fs
operator|->
name|flags_fs
operator|&
name|DN_IS_GENTLE_RED
operator|)
condition|?
literal|'G'
else|:
literal|' '
argument_list|,
literal|1.0
operator|*
name|fs
operator|->
name|w_q
operator|/
call|(
name|double
call|)
argument_list|(
literal|1
operator|<<
name|SCALE_RED
argument_list|)
argument_list|,
name|SCALE_VAL
argument_list|(
name|fs
operator|->
name|min_th
argument_list|)
argument_list|,
name|SCALE_VAL
argument_list|(
name|fs
operator|->
name|max_th
argument_list|)
argument_list|,
literal|1.0
operator|*
name|fs
operator|->
name|max_p
operator|/
call|(
name|double
call|)
argument_list|(
literal|1
operator|<<
name|SCALE_RED
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|red
argument_list|,
literal|"droptail"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s %s%s %d queues (%d buckets) %s\n"
argument_list|,
name|prefix
argument_list|,
name|qs
argument_list|,
name|plr
argument_list|,
name|fs
operator|->
name|rq_elements
argument_list|,
name|fs
operator|->
name|rq_size
argument_list|,
name|red
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_extra_delay_parms
parameter_list|(
name|struct
name|dn_pipe
modifier|*
name|p
parameter_list|)
block|{
name|double
name|loss
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|samples_no
operator|<=
literal|0
condition|)
return|return;
name|loss
operator|=
name|p
operator|->
name|loss_level
expr_stmt|;
name|loss
operator|/=
name|p
operator|->
name|samples_no
expr_stmt|;
name|printf
argument_list|(
literal|"\t profile: name \"%s\" loss %f samples %d\n"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|loss
argument_list|,
name|p
operator|->
name|samples_no
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipfw_list_pipes
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|uint
name|nbytes
parameter_list|,
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
block|{
name|int
name|rulenum
decl_stmt|;
name|void
modifier|*
name|next
init|=
name|data
decl_stmt|;
name|struct
name|dn_pipe
modifier|*
name|p
init|=
operator|(
expr|struct
name|dn_pipe
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|dn_flow_set
modifier|*
name|fs
decl_stmt|;
name|struct
name|dn_flow_queue
modifier|*
name|q
decl_stmt|;
name|int
name|l
decl_stmt|;
if|if
condition|(
name|ac
operator|>
literal|0
condition|)
name|rulenum
operator|=
name|strtoul
argument_list|(
operator|*
name|av
operator|++
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|else
name|rulenum
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|nbytes
operator|>=
sizeof|sizeof
expr|*
name|p
condition|;
name|p
operator|=
operator|(
expr|struct
name|dn_pipe
operator|*
operator|)
name|next
control|)
block|{
name|double
name|b
init|=
name|p
operator|->
name|bandwidth
decl_stmt|;
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|char
name|prefix
index|[
literal|80
index|]
decl_stmt|;
name|char
name|burst
index|[
literal|5
operator|+
literal|7
index|]
decl_stmt|;
if|if
condition|(
name|SLIST_NEXT
argument_list|(
name|p
argument_list|,
name|next
argument_list|)
operator|!=
operator|(
expr|struct
name|dn_pipe
operator|*
operator|)
name|DN_IS_PIPE
condition|)
break|break;
comment|/* done with pipes, now queues */
comment|/* 		 * compute length, as pipe have variable size 		 */
name|l
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|+
name|p
operator|->
name|fs
operator|.
name|rq_elements
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|l
expr_stmt|;
name|nbytes
operator|-=
name|l
expr_stmt|;
if|if
condition|(
operator|(
name|rulenum
operator|!=
literal|0
operator|&&
name|rulenum
operator|!=
name|p
operator|->
name|pipe_nr
operator|)
operator|||
name|co
operator|.
name|do_pipe
operator|==
literal|2
condition|)
continue|continue;
comment|/* 		 * Print rate (or clocking interface) 		 */
if|if
condition|(
name|p
operator|->
name|if_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|if_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"unlimited"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|>=
literal|1000000
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%7.3f Mbit/s"
argument_list|,
name|b
operator|/
literal|1000000
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|>=
literal|1000
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%7.3f Kbit/s"
argument_list|,
name|b
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%7.3f bit/s "
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|prefix
argument_list|,
literal|"%05d: %s %4d ms "
argument_list|,
name|p
operator|->
name|pipe_nr
argument_list|,
name|buf
argument_list|,
name|p
operator|->
name|delay
argument_list|)
expr_stmt|;
name|print_flowset_parms
argument_list|(
operator|&
operator|(
name|p
operator|->
name|fs
operator|)
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|humanize_number
argument_list|(
name|burst
argument_list|,
sizeof|sizeof
argument_list|(
name|burst
argument_list|)
argument_list|,
name|p
operator|->
name|burst
argument_list|,
literal|"Byte"
argument_list|,
name|HN_AUTOSCALE
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|||
name|co
operator|.
name|verbose
condition|)
name|printf
argument_list|(
literal|"\t burst: %ju Byte\n"
argument_list|,
name|p
operator|->
name|burst
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\t burst: %s\n"
argument_list|,
name|burst
argument_list|)
expr_stmt|;
name|print_extra_delay_parms
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
expr|struct
name|dn_flow_queue
operator|*
operator|)
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|list_queues
argument_list|(
operator|&
operator|(
name|p
operator|->
name|fs
operator|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|fs
operator|=
name|next
init|;
name|nbytes
operator|>=
sizeof|sizeof
expr|*
name|fs
condition|;
name|fs
operator|=
name|next
control|)
block|{
name|char
name|prefix
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|SLIST_NEXT
argument_list|(
name|fs
argument_list|,
name|next
argument_list|)
operator|!=
operator|(
expr|struct
name|dn_flow_set
operator|*
operator|)
name|DN_IS_QUEUE
condition|)
break|break;
name|l
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|fs
argument_list|)
operator|+
name|fs
operator|->
name|rq_elements
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|char
operator|*
operator|)
name|fs
operator|+
name|l
expr_stmt|;
name|nbytes
operator|-=
name|l
expr_stmt|;
if|if
condition|(
name|rulenum
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|rulenum
operator|!=
name|fs
operator|->
name|fs_nr
operator|&&
name|co
operator|.
name|do_pipe
operator|==
literal|2
operator|)
operator|||
operator|(
name|rulenum
operator|!=
name|fs
operator|->
name|parent_nr
operator|&&
name|co
operator|.
name|do_pipe
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
name|q
operator|=
operator|(
expr|struct
name|dn_flow_queue
operator|*
operator|)
operator|(
name|fs
operator|+
literal|1
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|prefix
argument_list|,
literal|"q%05d: weight %d pipe %d "
argument_list|,
name|fs
operator|->
name|fs_nr
argument_list|,
name|fs
operator|->
name|weight
argument_list|,
name|fs
operator|->
name|parent_nr
argument_list|)
expr_stmt|;
name|print_flowset_parms
argument_list|(
name|fs
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|list_queues
argument_list|(
name|fs
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Delete pipe or queue i  */
end_comment

begin_function
name|int
name|ipfw_delete_pipe
parameter_list|(
name|int
name|pipe_or_queue
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|dn_pipe
name|p
decl_stmt|;
name|memset
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe_or_queue
operator|==
literal|1
condition|)
name|p
operator|.
name|pipe_nr
operator|=
name|i
expr_stmt|;
comment|/* pipe */
else|else
name|p
operator|.
name|fs
operator|.
name|fs_nr
operator|=
name|i
expr_stmt|;
comment|/* queue */
name|i
operator|=
name|do_cmd
argument_list|(
name|IP_DUMMYNET_DEL
argument_list|,
operator|&
name|p
argument_list|,
sizeof|sizeof
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
name|warn
argument_list|(
literal|"rule %u: setsockopt(IP_DUMMYNET_DEL)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  * Code to parse delay profiles.  *  * Some link types introduce extra delays in the transmission  * of a packet, e.g. because of MAC level framing, contention on  * the use of the channel, MAC level retransmissions and so on.  * From our point of view, the channel is effectively unavailable  * for this extra time, which is constant or variable depending  * on the link type. Additionally, packets may be dropped after this  * time (e.g. on a wireless link after too many retransmissions).  * We can model the additional delay with an empirical curve  * that represents its distribution.  *  *	cumulative probability  *	1.0 ^  *	    |  *	L   +-- loss-level          x  *	    |                 ******  *	    |                *  *	    |           *****  *	    |          *  *	    |        **  *	    |       *                           *	    +-------*------------------->  *			delay  *  * The empirical curve may have both vertical and horizontal lines.  * Vertical lines represent constant delay for a range of  * probabilities; horizontal lines correspond to a discontinuty  * in the delay distribution: the pipe will use the largest delay  * for a given probability.  *   * To pass the curve to dummynet, we must store the parameters  * in a file as described below, and issue the command  *  *      ipfw pipe<n> config ... bw XXX profile<filename> ...  *  * The file format is the following, with whitespace acting as  * a separator and '#' indicating the beginning a comment:  *  *	samples N  *		the number of samples used in the internal  *		representation (2..1024; default 100);  *  *	loss-level L   *		The probability above which packets are lost.  *               (0.0<= L<= 1.0, default 1.0 i.e. no loss);  *  *	name identifier  *		Optional a name (listed by "ipfw pipe show")  *		to identify the distribution;  *  *	"delay prob" | "prob delay"  *		One of these two lines is mandatory and defines  *		the format of the following lines with data points.  *  *	XXX YYY  *		2 or more lines representing points in the curve,  *		with either delay or probability first, according  *		to the chosen format.  *		The unit for delay is milliseconds.  *  * Data points does not need to be ordered or equal to the number  * specified in the "samples" line. ipfw will sort and interpolate  * the curve as needed.  *  * Example of a profile file:           name    bla_bla_bla         samples 100         loss-level    0.86         prob    delay         0       200	# minimum overhead is 200ms         0.5     200         0.5     300         0.8     1000         0.9     1300         1       1300    * Internally, we will convert the curve to a fixed number of  * samples, and when it is time to transmit a packet we will  * model the extra delay as extra bits in the packet.  *  */
end_comment

begin_define
define|#
directive|define
name|ED_MAX_LINE_LEN
value|256+ED_MAX_NAME_LEN
end_define

begin_define
define|#
directive|define
name|ED_TOK_SAMPLES
value|"samples"
end_define

begin_define
define|#
directive|define
name|ED_TOK_LOSS
value|"loss-level"
end_define

begin_define
define|#
directive|define
name|ED_TOK_NAME
value|"name"
end_define

begin_define
define|#
directive|define
name|ED_TOK_DELAY
value|"delay"
end_define

begin_define
define|#
directive|define
name|ED_TOK_PROB
value|"prob"
end_define

begin_define
define|#
directive|define
name|ED_TOK_BW
value|"bw"
end_define

begin_define
define|#
directive|define
name|ED_SEPARATORS
value|" \t\n"
end_define

begin_define
define|#
directive|define
name|ED_MIN_SAMPLES_NO
value|2
end_define

begin_comment
comment|/*  * returns 1 if s is a non-negative number, with at least one '.'  */
end_comment

begin_function
specifier|static
name|int
name|is_valid_number
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|dots_found
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
operator|&&
operator|(
name|s
index|[
name|i
index|]
operator|!=
literal|'.'
operator|||
operator|++
name|dots_found
operator|>
literal|1
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Take as input a string describing a bandwidth value  * and return the numeric bandwidth value.  * set clocking interface or bandwidth value  */
end_comment

begin_function
specifier|static
name|void
name|read_bandwidth
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
modifier|*
name|bandwidth
parameter_list|,
name|char
modifier|*
name|if_name
parameter_list|,
name|int
name|namelen
parameter_list|)
block|{
if|if
condition|(
operator|*
name|bandwidth
operator|!=
operator|-
literal|1
condition|)
name|warn
argument_list|(
literal|"duplicate token, override bandwidth value!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|arg
index|[
literal|0
index|]
operator|<=
literal|'z'
condition|)
block|{
if|if
condition|(
name|namelen
operator|>=
name|IFNAMSIZ
condition|)
name|warn
argument_list|(
literal|"interface name truncated"
argument_list|)
expr_stmt|;
name|namelen
operator|--
expr_stmt|;
comment|/* interface name */
name|strncpy
argument_list|(
name|if_name
argument_list|,
name|arg
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|if_name
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|bandwidth
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* read bandwidth value */
name|int
name|bw
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|NULL
decl_stmt|;
name|bw
operator|=
name|strtoul
argument_list|(
name|arg
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'K'
operator|||
operator|*
name|end
operator|==
literal|'k'
condition|)
block|{
name|end
operator|++
expr_stmt|;
name|bw
operator|*=
literal|1000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|end
operator|==
literal|'M'
condition|)
block|{
name|end
operator|++
expr_stmt|;
name|bw
operator|*=
literal|1000000
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|end
operator|==
literal|'B'
operator|&&
name|_substrcmp2
argument_list|(
name|end
argument_list|,
literal|"Bi"
argument_list|,
literal|"Bit/s"
argument_list|)
operator|!=
literal|0
operator|)
operator|||
name|_substrcmp2
argument_list|(
name|end
argument_list|,
literal|"by"
argument_list|,
literal|"bytes"
argument_list|)
operator|==
literal|0
condition|)
name|bw
operator|*=
literal|8
expr_stmt|;
if|if
condition|(
name|bw
operator|<
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"bandwidth too large"
argument_list|)
expr_stmt|;
operator|*
name|bandwidth
operator|=
name|bw
expr_stmt|;
name|if_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|point
block|{
name|double
name|prob
decl_stmt|;
name|double
name|delay
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|compare_points
parameter_list|(
specifier|const
name|void
modifier|*
name|vp1
parameter_list|,
specifier|const
name|void
modifier|*
name|vp2
parameter_list|)
block|{
specifier|const
name|struct
name|point
modifier|*
name|p1
init|=
name|vp1
decl_stmt|;
specifier|const
name|struct
name|point
modifier|*
name|p2
init|=
name|vp2
decl_stmt|;
name|double
name|res
init|=
literal|0
decl_stmt|;
name|res
operator|=
name|p1
operator|->
name|prob
operator|-
name|p2
operator|->
name|prob
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
name|res
operator|=
name|p1
operator|->
name|delay
operator|-
name|p2
operator|->
name|delay
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|res
operator|>
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ED_EFMT
parameter_list|(
name|s
parameter_list|)
value|EX_DATAERR,"error in %s at line %d: "#s,filename,lineno
end_define

begin_function
specifier|static
name|void
name|load_extra_delays
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|dn_pipe
modifier|*
name|p
parameter_list|)
block|{
name|char
name|line
index|[
name|ED_MAX_LINE_LEN
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|lineno
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|samples
init|=
operator|-
literal|1
decl_stmt|;
name|double
name|loss
init|=
operator|-
literal|1.0
decl_stmt|;
name|char
name|profile_name
index|[
name|ED_MAX_NAME_LEN
index|]
decl_stmt|;
name|int
name|delay_first
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|do_points
init|=
literal|0
decl_stmt|;
name|struct
name|point
name|points
index|[
name|ED_MAX_SAMPLES_NO
index|]
decl_stmt|;
name|int
name|points_no
init|=
literal|0
decl_stmt|;
name|profile_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
literal|"fopen: %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|ED_MAX_LINE_LEN
argument_list|,
name|f
argument_list|)
condition|)
block|{
comment|/* read commands */
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|cur
init|=
name|line
decl_stmt|,
modifier|*
name|name
init|=
name|NULL
decl_stmt|,
modifier|*
name|arg
init|=
name|NULL
decl_stmt|;
operator|++
name|lineno
expr_stmt|;
comment|/* parse the line */
while|while
condition|(
name|cur
condition|)
block|{
name|s
operator|=
name|strsep
argument_list|(
operator|&
name|cur
argument_list|,
name|ED_SEPARATORS
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|*
name|s
operator|==
literal|'#'
condition|)
break|break;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|arg
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"too many arguments"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|s
expr_stmt|;
else|else
name|arg
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
comment|/* empty line */
continue|continue;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"missing arg for %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|ED_TOK_SAMPLES
argument_list|)
condition|)
block|{
if|if
condition|(
name|samples
operator|>
literal|0
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"duplicate ``samples'' line"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|atoi
argument_list|(
name|arg
argument_list|)
operator|<=
literal|0
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"invalid number of samples"
argument_list|)
argument_list|)
expr_stmt|;
name|samples
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|>
name|ED_MAX_SAMPLES_NO
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"too many samples, maximum is %d"
argument_list|)
argument_list|,
name|ED_MAX_SAMPLES_NO
argument_list|)
expr_stmt|;
name|do_points
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|ED_TOK_BW
argument_list|)
condition|)
block|{
name|read_bandwidth
argument_list|(
name|arg
argument_list|,
operator|&
name|p
operator|->
name|bandwidth
argument_list|,
name|p
operator|->
name|if_name
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|if_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|ED_TOK_LOSS
argument_list|)
condition|)
block|{
if|if
condition|(
name|loss
operator|!=
operator|-
literal|1.0
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"duplicated token: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_valid_number
argument_list|(
name|arg
argument_list|)
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"invalid %s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|loss
operator|=
name|atof
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|loss
operator|>
literal|1
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"%s greater than 1.0"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|do_points
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|ED_TOK_NAME
argument_list|)
condition|)
block|{
if|if
condition|(
name|profile_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"duplicated token: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|profile_name
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|profile_name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|profile_name
index|[
sizeof|sizeof
argument_list|(
name|profile_name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|do_points
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|ED_TOK_DELAY
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_points
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"duplicated token: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|delay_first
operator|=
literal|1
expr_stmt|;
name|do_points
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|ED_TOK_PROB
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_points
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"duplicated token: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|delay_first
operator|=
literal|0
expr_stmt|;
name|do_points
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|do_points
condition|)
block|{
if|if
condition|(
operator|!
name|is_valid_number
argument_list|(
name|name
argument_list|)
operator|||
operator|!
name|is_valid_number
argument_list|(
name|arg
argument_list|)
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"invalid point found"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay_first
condition|)
block|{
name|points
index|[
name|points_no
index|]
operator|.
name|delay
operator|=
name|atof
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|points
index|[
name|points_no
index|]
operator|.
name|prob
operator|=
name|atof
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|points
index|[
name|points_no
index|]
operator|.
name|delay
operator|=
name|atof
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|points
index|[
name|points_no
index|]
operator|.
name|prob
operator|=
name|atof
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|points
index|[
name|points_no
index|]
operator|.
name|prob
operator|>
literal|1.0
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"probability greater than 1.0"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|points_no
expr_stmt|;
block|}
else|else
block|{
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"unrecognised command '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"'%s' not found, assuming 100"
argument_list|,
name|ED_TOK_SAMPLES
argument_list|)
expr_stmt|;
name|samples
operator|=
literal|100
expr_stmt|;
block|}
if|if
condition|(
name|loss
operator|==
operator|-
literal|1.0
condition|)
block|{
name|warnx
argument_list|(
literal|"'%s' not found, assuming no loss"
argument_list|,
name|ED_TOK_LOSS
argument_list|)
expr_stmt|;
name|loss
operator|=
literal|1
expr_stmt|;
block|}
comment|/* make sure that there are enough points. */
if|if
condition|(
name|points_no
operator|<
name|ED_MIN_SAMPLES_NO
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"too few samples, need at least %d"
argument_list|)
argument_list|,
name|ED_MIN_SAMPLES_NO
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|points
argument_list|,
name|points_no
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|point
argument_list|)
argument_list|,
name|compare_points
argument_list|)
expr_stmt|;
comment|/* interpolation */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|points_no
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|double
name|y1
init|=
name|points
index|[
name|i
index|]
operator|.
name|prob
operator|*
name|samples
decl_stmt|;
name|double
name|x1
init|=
name|points
index|[
name|i
index|]
operator|.
name|delay
decl_stmt|;
name|double
name|y2
init|=
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|prob
operator|*
name|samples
decl_stmt|;
name|double
name|x2
init|=
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|delay
decl_stmt|;
name|int
name|index
init|=
name|y1
decl_stmt|;
name|int
name|stop
init|=
name|y2
decl_stmt|;
if|if
condition|(
name|x1
operator|==
name|x2
condition|)
block|{
for|for
control|(
init|;
name|index
operator|<
name|stop
condition|;
operator|++
name|index
control|)
name|p
operator|->
name|samples
index|[
name|index
index|]
operator|=
name|x1
expr_stmt|;
block|}
else|else
block|{
name|double
name|m
init|=
operator|(
name|y2
operator|-
name|y1
operator|)
operator|/
operator|(
name|x2
operator|-
name|x1
operator|)
decl_stmt|;
name|double
name|c
init|=
name|y1
operator|-
name|m
operator|*
name|x1
decl_stmt|;
for|for
control|(
init|;
name|index
operator|<
name|stop
condition|;
operator|++
name|index
control|)
name|p
operator|->
name|samples
index|[
name|index
index|]
operator|=
operator|(
name|index
operator|-
name|c
operator|)
operator|/
name|m
expr_stmt|;
block|}
block|}
name|p
operator|->
name|samples_no
operator|=
name|samples
expr_stmt|;
name|p
operator|->
name|loss_level
operator|=
name|loss
operator|*
name|samples
expr_stmt|;
name|strncpy
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|profile_name
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipfw_config_pipe
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|int
name|samples
index|[
name|ED_MAX_SAMPLES_NO
index|]
decl_stmt|;
name|struct
name|dn_pipe
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|void
modifier|*
name|par
init|=
name|NULL
decl_stmt|;
name|memset
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|bandwidth
operator|=
operator|-
literal|1
expr_stmt|;
name|av
operator|++
expr_stmt|;
name|ac
operator|--
expr_stmt|;
comment|/* Pipe number */
if|if
condition|(
name|ac
operator|&&
name|isdigit
argument_list|(
operator|*
operator|*
name|av
argument_list|)
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
operator|*
name|av
argument_list|)
expr_stmt|;
name|av
operator|++
expr_stmt|;
name|ac
operator|--
expr_stmt|;
if|if
condition|(
name|co
operator|.
name|do_pipe
operator|==
literal|1
condition|)
name|p
operator|.
name|pipe_nr
operator|=
name|i
expr_stmt|;
else|else
name|p
operator|.
name|fs
operator|.
name|fs_nr
operator|=
name|i
expr_stmt|;
block|}
while|while
condition|(
name|ac
operator|>
literal|0
condition|)
block|{
name|double
name|d
decl_stmt|;
name|int
name|tok
init|=
name|match_token
argument_list|(
name|dummynet_params
argument_list|,
operator|*
name|av
argument_list|)
decl_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|TOK_NOERROR
case|:
name|p
operator|.
name|fs
operator|.
name|flags_fs
operator||=
name|DN_NOERROR
expr_stmt|;
break|break;
case|case
name|TOK_PLR
case|:
name|NEED1
argument_list|(
literal|"plr needs argument 0..1\n"
argument_list|)
expr_stmt|;
name|d
operator|=
name|strtod
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|1
condition|)
name|d
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|plr
operator|=
call|(
name|int
call|)
argument_list|(
name|d
operator|*
literal|0x7fffffff
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_QUEUE
case|:
name|NEED1
argument_list|(
literal|"queue needs queue size\n"
argument_list|)
expr_stmt|;
name|end
operator|=
name|NULL
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|qsize
operator|=
name|strtoul
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'K'
operator|||
operator|*
name|end
operator|==
literal|'k'
condition|)
block|{
name|p
operator|.
name|fs
operator|.
name|flags_fs
operator||=
name|DN_QSIZE_IS_BYTES
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|qsize
operator|*=
literal|1024
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|end
operator|==
literal|'B'
operator|||
name|_substrcmp2
argument_list|(
name|end
argument_list|,
literal|"by"
argument_list|,
literal|"bytes"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|.
name|fs
operator|.
name|flags_fs
operator||=
name|DN_QSIZE_IS_BYTES
expr_stmt|;
block|}
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_BUCKETS
case|:
name|NEED1
argument_list|(
literal|"buckets needs argument\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|rq_size
operator|=
name|strtoul
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_MASK
case|:
name|NEED1
argument_list|(
literal|"mask needs mask specifier\n"
argument_list|)
expr_stmt|;
comment|/* 			 * per-flow queue, mask is dst_ip, dst_port, 			 * src_ip, src_port, proto measured in bits 			 */
name|par
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|p
operator|.
name|fs
operator|.
name|flow_mask
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|.
name|fs
operator|.
name|flow_mask
argument_list|)
argument_list|)
expr_stmt|;
name|end
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|ac
operator|>=
literal|1
condition|)
block|{
name|uint32_t
modifier|*
name|p32
init|=
name|NULL
decl_stmt|;
name|uint16_t
modifier|*
name|p16
init|=
name|NULL
decl_stmt|;
name|uint32_t
modifier|*
name|p20
init|=
name|NULL
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|pa6
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|a
decl_stmt|;
name|tok
operator|=
name|match_token
argument_list|(
name|dummynet_params
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|TOK_ALL
case|:
comment|/* 				     * special case, all bits significant 				     */
name|p
operator|.
name|fs
operator|.
name|flow_mask
operator|.
name|dst_ip
operator|=
operator|~
literal|0
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|flow_mask
operator|.
name|src_ip
operator|=
operator|~
literal|0
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|flow_mask
operator|.
name|dst_port
operator|=
operator|~
literal|0
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|flow_mask
operator|.
name|src_port
operator|=
operator|~
literal|0
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|flow_mask
operator|.
name|proto
operator|=
operator|~
literal|0
expr_stmt|;
name|n2mask
argument_list|(
operator|&
operator|(
name|p
operator|.
name|fs
operator|.
name|flow_mask
operator|.
name|dst_ip6
operator|)
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|n2mask
argument_list|(
operator|&
operator|(
name|p
operator|.
name|fs
operator|.
name|flow_mask
operator|.
name|src_ip6
operator|)
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|flow_mask
operator|.
name|flow_id6
operator|=
operator|~
literal|0
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|flags_fs
operator||=
name|DN_HAVE_FLOW_MASK
expr_stmt|;
goto|goto
name|end_mask
goto|;
case|case
name|TOK_DSTIP
case|:
name|p32
operator|=
operator|&
name|p
operator|.
name|fs
operator|.
name|flow_mask
operator|.
name|dst_ip
expr_stmt|;
break|break;
case|case
name|TOK_SRCIP
case|:
name|p32
operator|=
operator|&
name|p
operator|.
name|fs
operator|.
name|flow_mask
operator|.
name|src_ip
expr_stmt|;
break|break;
case|case
name|TOK_DSTIP6
case|:
name|pa6
operator|=
operator|&
operator|(
name|p
operator|.
name|fs
operator|.
name|flow_mask
operator|.
name|dst_ip6
operator|)
expr_stmt|;
break|break;
case|case
name|TOK_SRCIP6
case|:
name|pa6
operator|=
operator|&
operator|(
name|p
operator|.
name|fs
operator|.
name|flow_mask
operator|.
name|src_ip6
operator|)
expr_stmt|;
break|break;
case|case
name|TOK_FLOWID
case|:
name|p20
operator|=
operator|&
name|p
operator|.
name|fs
operator|.
name|flow_mask
operator|.
name|flow_id6
expr_stmt|;
break|break;
case|case
name|TOK_DSTPORT
case|:
name|p16
operator|=
operator|&
name|p
operator|.
name|fs
operator|.
name|flow_mask
operator|.
name|dst_port
expr_stmt|;
break|break;
case|case
name|TOK_SRCPORT
case|:
name|p16
operator|=
operator|&
name|p
operator|.
name|fs
operator|.
name|flow_mask
operator|.
name|src_port
expr_stmt|;
break|break;
case|case
name|TOK_PROTO
case|:
break|break;
default|default:
name|ac
operator|++
expr_stmt|;
name|av
operator|--
expr_stmt|;
comment|/* backtrack */
goto|goto
name|end_mask
goto|;
block|}
if|if
condition|(
name|ac
operator|<
literal|1
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"mask: value missing"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|av
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|a
operator|=
name|strtoul
argument_list|(
name|av
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa6
operator|==
name|NULL
condition|)
name|a
operator|=
operator|(
name|a
operator|==
literal|32
operator|)
condition|?
operator|~
literal|0
else|:
operator|(
literal|1
operator|<<
name|a
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|a
operator|=
name|strtoul
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p32
operator|!=
name|NULL
condition|)
operator|*
name|p32
operator|=
name|a
expr_stmt|;
elseif|else
if|if
condition|(
name|p16
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|a
operator|>
literal|0xFFFF
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"port mask must be 16 bit"
argument_list|)
expr_stmt|;
operator|*
name|p16
operator|=
operator|(
name|uint16_t
operator|)
name|a
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p20
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|a
operator|>
literal|0xfffff
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"flow_id mask must be 20 bit"
argument_list|)
expr_stmt|;
operator|*
name|p20
operator|=
operator|(
name|uint32_t
operator|)
name|a
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pa6
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|a
operator|>
literal|128
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"in6addr invalid mask len"
argument_list|)
expr_stmt|;
else|else
name|n2mask
argument_list|(
name|pa6
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|a
operator|>
literal|0xFF
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"proto mask must be 8 bit"
argument_list|)
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|flow_mask
operator|.
name|proto
operator|=
operator|(
name|uint8_t
operator|)
name|a
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|!=
literal|0
condition|)
name|p
operator|.
name|fs
operator|.
name|flags_fs
operator||=
name|DN_HAVE_FLOW_MASK
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
block|}
comment|/* end while, config masks */
name|end_mask
label|:
break|break;
case|case
name|TOK_RED
case|:
case|case
name|TOK_GRED
case|:
name|NEED1
argument_list|(
literal|"red/gred needs w_q/min_th/max_th/max_p\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|flags_fs
operator||=
name|DN_IS_RED
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|TOK_GRED
condition|)
name|p
operator|.
name|fs
operator|.
name|flags_fs
operator||=
name|DN_IS_GENTLE_RED
expr_stmt|;
comment|/* 			 * the format for parameters is w_q/min_th/max_th/max_p 			 */
if|if
condition|(
operator|(
name|end
operator|=
name|strsep
argument_list|(
operator|&
name|av
index|[
literal|0
index|]
argument_list|,
literal|"/"
argument_list|)
operator|)
condition|)
block|{
name|double
name|w_q
init|=
name|strtod
argument_list|(
name|end
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|w_q
operator|>
literal|1
operator|||
name|w_q
operator|<=
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"0< w_q<= 1"
argument_list|)
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|w_q
operator|=
call|(
name|int
call|)
argument_list|(
name|w_q
operator|*
operator|(
literal|1
operator|<<
name|SCALE_RED
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|end
operator|=
name|strsep
argument_list|(
operator|&
name|av
index|[
literal|0
index|]
argument_list|,
literal|"/"
argument_list|)
operator|)
condition|)
block|{
name|p
operator|.
name|fs
operator|.
name|min_th
operator|=
name|strtoul
argument_list|(
name|end
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'K'
operator|||
operator|*
name|end
operator|==
literal|'k'
condition|)
name|p
operator|.
name|fs
operator|.
name|min_th
operator|*=
literal|1024
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|end
operator|=
name|strsep
argument_list|(
operator|&
name|av
index|[
literal|0
index|]
argument_list|,
literal|"/"
argument_list|)
operator|)
condition|)
block|{
name|p
operator|.
name|fs
operator|.
name|max_th
operator|=
name|strtoul
argument_list|(
name|end
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'K'
operator|||
operator|*
name|end
operator|==
literal|'k'
condition|)
name|p
operator|.
name|fs
operator|.
name|max_th
operator|*=
literal|1024
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|end
operator|=
name|strsep
argument_list|(
operator|&
name|av
index|[
literal|0
index|]
argument_list|,
literal|"/"
argument_list|)
operator|)
condition|)
block|{
name|double
name|max_p
init|=
name|strtod
argument_list|(
name|end
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|max_p
operator|>
literal|1
operator|||
name|max_p
operator|<=
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"0< max_p<= 1"
argument_list|)
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|max_p
operator|=
call|(
name|int
call|)
argument_list|(
name|max_p
operator|*
operator|(
literal|1
operator|<<
name|SCALE_RED
operator|)
argument_list|)
expr_stmt|;
block|}
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_DROPTAIL
case|:
name|p
operator|.
name|fs
operator|.
name|flags_fs
operator|&=
operator|~
operator|(
name|DN_IS_RED
operator||
name|DN_IS_GENTLE_RED
operator|)
expr_stmt|;
break|break;
case|case
name|TOK_BW
case|:
name|NEED1
argument_list|(
literal|"bw needs bandwidth or interface\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|co
operator|.
name|do_pipe
operator|!=
literal|1
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"bandwidth only valid for pipes"
argument_list|)
expr_stmt|;
name|read_bandwidth
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|p
operator|.
name|bandwidth
argument_list|,
name|p
operator|.
name|if_name
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|.
name|if_name
argument_list|)
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_DELAY
case|:
if|if
condition|(
name|co
operator|.
name|do_pipe
operator|!=
literal|1
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"delay only valid for pipes"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"delay needs argument 0..10000ms\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|delay
operator|=
name|strtoul
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_WEIGHT
case|:
if|if
condition|(
name|co
operator|.
name|do_pipe
operator|==
literal|1
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"weight only valid for queues"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"weight needs argument 0..100\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|weight
operator|=
name|strtoul
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_PIPE
case|:
if|if
condition|(
name|co
operator|.
name|do_pipe
operator|==
literal|1
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"pipe only valid for queues"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"pipe needs pipe_number\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|parent_nr
operator|=
name|strtoul
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_PIPE_PROFILE
case|:
if|if
condition|(
name|co
operator|.
name|do_pipe
operator|!=
literal|1
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"extra delay only valid for pipes"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"extra delay needs the file name\n"
argument_list|)
expr_stmt|;
name|p
operator|.
name|samples
operator|=
operator|&
name|samples
index|[
literal|0
index|]
expr_stmt|;
name|load_extra_delays
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
operator|--
name|ac
expr_stmt|;
operator|++
name|av
expr_stmt|;
break|break;
case|case
name|TOK_BURST
case|:
if|if
condition|(
name|co
operator|.
name|do_pipe
operator|!=
literal|1
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"burst only valid for pipes"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"burst needs argument\n"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expand_number
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|(
name|int64_t
operator|*
operator|)
operator|&
name|p
operator|.
name|burst
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
name|errno
operator|!=
name|ERANGE
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"burst: invalid argument"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
name|p
operator|.
name|burst
operator|>
operator|(
literal|1ULL
operator|<<
literal|48
operator|)
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"burst: out of range (0..2^48-1)"
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"unrecognised option ``%s''"
argument_list|,
name|av
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|co
operator|.
name|do_pipe
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|p
operator|.
name|pipe_nr
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"pipe_nr must be> 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|delay
operator|>
literal|10000
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"delay must be< 10000"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* co.do_pipe == 2, queue */
if|if
condition|(
name|p
operator|.
name|fs
operator|.
name|parent_nr
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"pipe must be> 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|fs
operator|.
name|weight
operator|>
literal|100
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"weight must be<= 100"
argument_list|)
expr_stmt|;
block|}
comment|/* check for bandwidth value */
if|if
condition|(
name|p
operator|.
name|bandwidth
operator|==
operator|-
literal|1
condition|)
block|{
name|p
operator|.
name|bandwidth
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|samples_no
operator|>
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"profile requires a bandwidth limit"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|.
name|fs
operator|.
name|flags_fs
operator|&
name|DN_QSIZE_IS_BYTES
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|long
name|limit
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"net.inet.ip.dummynet.pipe_byte_limit"
argument_list|,
operator|&
name|limit
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|limit
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|fs
operator|.
name|qsize
operator|>
name|limit
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"queue size must be< %ldB"
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|len
decl_stmt|;
name|long
name|limit
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"net.inet.ip.dummynet.pipe_slot_limit"
argument_list|,
operator|&
name|limit
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|limit
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|fs
operator|.
name|qsize
operator|>
name|limit
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"2<= queue size<= %ld"
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|.
name|fs
operator|.
name|flags_fs
operator|&
name|DN_IS_RED
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|int
name|lookup_depth
decl_stmt|,
name|avg_pkt_size
decl_stmt|;
name|double
name|s
decl_stmt|,
name|idle
decl_stmt|,
name|weight
decl_stmt|,
name|w_q
decl_stmt|;
name|struct
name|clockinfo
name|ck
decl_stmt|;
name|int
name|t
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|fs
operator|.
name|min_th
operator|>=
name|p
operator|.
name|fs
operator|.
name|max_th
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"min_th %d must be< than max_th %d"
argument_list|,
name|p
operator|.
name|fs
operator|.
name|min_th
argument_list|,
name|p
operator|.
name|fs
operator|.
name|max_th
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|fs
operator|.
name|max_th
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"max_th must be> 0"
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"net.inet.ip.dummynet.red_lookup_depth"
argument_list|,
operator|&
name|lookup_depth
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"sysctlbyname(\"%s\")"
argument_list|,
literal|"net.inet.ip.dummynet.red_lookup_depth"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup_depth
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"net.inet.ip.dummynet.red_lookup_depth"
literal|" must be greater than zero"
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"net.inet.ip.dummynet.red_avg_pkt_size"
argument_list|,
operator|&
name|avg_pkt_size
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"sysctlbyname(\"%s\")"
argument_list|,
literal|"net.inet.ip.dummynet.red_avg_pkt_size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|avg_pkt_size
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"net.inet.ip.dummynet.red_avg_pkt_size must"
literal|" be greater than zero"
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|clockinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"kern.clockrate"
argument_list|,
operator|&
name|ck
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"sysctlbyname(\"%s\")"
argument_list|,
literal|"kern.clockrate"
argument_list|)
expr_stmt|;
comment|/* 		 * Ticks needed for sending a medium-sized packet. 		 * Unfortunately, when we are configuring a WF2Q+ queue, we 		 * do not have bandwidth information, because that is stored 		 * in the parent pipe, and also we have multiple queues 		 * competing for it. So we set s=0, which is not very 		 * correct. But on the other hand, why do we want RED with 		 * WF2Q+ ? 		 */
if|if
condition|(
name|p
operator|.
name|bandwidth
operator|==
literal|0
condition|)
comment|/* this is a WF2Q+ queue */
name|s
operator|=
literal|0
expr_stmt|;
else|else
name|s
operator|=
operator|(
name|double
operator|)
name|ck
operator|.
name|hz
operator|*
name|avg_pkt_size
operator|*
literal|8
operator|/
name|p
operator|.
name|bandwidth
expr_stmt|;
comment|/* 		 * max idle time (in ticks) before avg queue size becomes 0. 		 * NOTA:  (3/w_q) is approx the value x so that 		 * (1-w_q)^x< 10^-3. 		 */
name|w_q
operator|=
operator|(
operator|(
name|double
operator|)
name|p
operator|.
name|fs
operator|.
name|w_q
operator|)
operator|/
operator|(
literal|1
operator|<<
name|SCALE_RED
operator|)
expr_stmt|;
name|idle
operator|=
name|s
operator|*
literal|3.
operator|/
name|w_q
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|lookup_step
operator|=
operator|(
name|int
operator|)
name|idle
operator|/
name|lookup_depth
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|.
name|fs
operator|.
name|lookup_step
condition|)
name|p
operator|.
name|fs
operator|.
name|lookup_step
operator|=
literal|1
expr_stmt|;
name|weight
operator|=
literal|1
operator|-
name|w_q
expr_stmt|;
for|for
control|(
name|t
operator|=
name|p
operator|.
name|fs
operator|.
name|lookup_step
init|;
name|t
operator|>
literal|1
condition|;
operator|--
name|t
control|)
name|weight
operator|*=
literal|1
operator|-
name|w_q
expr_stmt|;
name|p
operator|.
name|fs
operator|.
name|lookup_weight
operator|=
call|(
name|int
call|)
argument_list|(
name|weight
operator|*
operator|(
literal|1
operator|<<
name|SCALE_RED
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|.
name|samples_no
operator|<=
literal|0
condition|)
block|{
name|i
operator|=
name|do_cmd
argument_list|(
name|IP_DUMMYNET_CONFIGURE
argument_list|,
operator|&
name|p
argument_list|,
sizeof|sizeof
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|dn_pipe_max
name|pm
decl_stmt|;
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
name|pm
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|pm
operator|.
name|pipe
argument_list|,
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|pm
operator|.
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pm
operator|.
name|samples
argument_list|,
name|samples
argument_list|,
sizeof|sizeof
argument_list|(
name|pm
operator|.
name|samples
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|do_cmd
argument_list|(
name|IP_DUMMYNET_CONFIGURE
argument_list|,
operator|&
name|pm
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"setsockopt(%s)"
argument_list|,
literal|"IP_DUMMYNET_CONFIGURE"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

