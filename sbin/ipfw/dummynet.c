begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2003,2010 Luigi Rizzo  *  * Redistribution and use in source forms, with and without modification,  * are permitted provided that this entire comment appears intact.  *  * Redistribution in binary form may occur without any restrictions.  * Obviously, it would be nice if you gave credit where credit is due  * but requiring it would be too onerous.  *  * This software is provided ``AS IS'' without any warranties of any kind.  *  * $FreeBSD$  *  * dummynet support  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* XXX there are several sysctl leftover here */
end_comment

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|"ipfw2.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_dummynet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_comment
comment|/* inet_ntoa */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|_s_x
name|dummynet_params
index|[]
init|=
block|{
block|{
literal|"plr"
block|,
name|TOK_PLR
block|}
block|,
block|{
literal|"noerror"
block|,
name|TOK_NOERROR
block|}
block|,
block|{
literal|"buckets"
block|,
name|TOK_BUCKETS
block|}
block|,
block|{
literal|"dst-ip"
block|,
name|TOK_DSTIP
block|}
block|,
block|{
literal|"src-ip"
block|,
name|TOK_SRCIP
block|}
block|,
block|{
literal|"dst-port"
block|,
name|TOK_DSTPORT
block|}
block|,
block|{
literal|"src-port"
block|,
name|TOK_SRCPORT
block|}
block|,
block|{
literal|"proto"
block|,
name|TOK_PROTO
block|}
block|,
block|{
literal|"weight"
block|,
name|TOK_WEIGHT
block|}
block|,
block|{
literal|"lmax"
block|,
name|TOK_LMAX
block|}
block|,
block|{
literal|"maxlen"
block|,
name|TOK_LMAX
block|}
block|,
block|{
literal|"all"
block|,
name|TOK_ALL
block|}
block|,
block|{
literal|"mask"
block|,
name|TOK_MASK
block|}
block|,
comment|/* alias for both */
block|{
literal|"sched_mask"
block|,
name|TOK_SCHED_MASK
block|}
block|,
block|{
literal|"flow_mask"
block|,
name|TOK_FLOW_MASK
block|}
block|,
block|{
literal|"droptail"
block|,
name|TOK_DROPTAIL
block|}
block|,
block|{
literal|"red"
block|,
name|TOK_RED
block|}
block|,
block|{
literal|"gred"
block|,
name|TOK_GRED
block|}
block|,
block|{
literal|"bw"
block|,
name|TOK_BW
block|}
block|,
block|{
literal|"bandwidth"
block|,
name|TOK_BW
block|}
block|,
block|{
literal|"delay"
block|,
name|TOK_DELAY
block|}
block|,
block|{
literal|"link"
block|,
name|TOK_LINK
block|}
block|,
block|{
literal|"pipe"
block|,
name|TOK_PIPE
block|}
block|,
block|{
literal|"queue"
block|,
name|TOK_QUEUE
block|}
block|,
block|{
literal|"flowset"
block|,
name|TOK_FLOWSET
block|}
block|,
block|{
literal|"sched"
block|,
name|TOK_SCHED
block|}
block|,
block|{
literal|"pri"
block|,
name|TOK_PRI
block|}
block|,
block|{
literal|"priority"
block|,
name|TOK_PRI
block|}
block|,
block|{
literal|"type"
block|,
name|TOK_TYPE
block|}
block|,
block|{
literal|"flow-id"
block|,
name|TOK_FLOWID
block|}
block|,
block|{
literal|"dst-ipv6"
block|,
name|TOK_DSTIP6
block|}
block|,
block|{
literal|"dst-ip6"
block|,
name|TOK_DSTIP6
block|}
block|,
block|{
literal|"src-ipv6"
block|,
name|TOK_SRCIP6
block|}
block|,
block|{
literal|"src-ip6"
block|,
name|TOK_SRCIP6
block|}
block|,
block|{
literal|"profile"
block|,
name|TOK_PROFILE
block|}
block|,
block|{
literal|"burst"
block|,
name|TOK_BURST
block|}
block|,
block|{
literal|"dummynet-params"
block|,
name|TOK_NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
comment|/* terminator */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|O_NEXT
parameter_list|(
name|p
parameter_list|,
name|len
parameter_list|)
value|((void *)((char *)p + len))
end_define

begin_function
specifier|static
name|void
name|oid_fill
parameter_list|(
name|struct
name|dn_id
modifier|*
name|oid
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|type
parameter_list|,
name|uintptr_t
name|id
parameter_list|)
block|{
name|oid
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|oid
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|oid
operator|->
name|subtype
operator|=
literal|0
expr_stmt|;
name|oid
operator|->
name|id
operator|=
name|id
expr_stmt|;
block|}
end_function

begin_comment
comment|/* make room in the buffer and move the pointer forward */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|o_next
parameter_list|(
name|struct
name|dn_id
modifier|*
modifier|*
name|o
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|dn_id
modifier|*
name|ret
init|=
operator|*
name|o
decl_stmt|;
name|oid_fill
argument_list|(
name|ret
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|o
operator|=
name|O_NEXT
argument_list|(
operator|*
name|o
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int sort_q(void *arg, const void *pa, const void *pb) { 	int rev = (co.do_sort< 0); 	int field = rev ? -co.do_sort : co.do_sort; 	long long res = 0; 	const struct dn_flow_queue *a = pa; 	const struct dn_flow_queue *b = pb;  	switch (field) { 	case 1:
comment|/* pkts */
end_comment

begin_comment
unit|res = a->len - b->len; 		break; 	case 2:
comment|/* bytes */
end_comment

begin_comment
unit|res = a->len_bytes - b->len_bytes; 		break;  	case 3:
comment|/* tot pkts */
end_comment

begin_comment
unit|res = a->tot_pkts - b->tot_pkts; 		break;  	case 4:
comment|/* tot bytes */
end_comment

begin_endif
unit|res = a->tot_bytes - b->tot_bytes; 		break; 	} 	if (res< 0) 		res = -1; 	if (res> 0) 		res = 1; 	return (int)(rev ? res : -res); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* print a mask and header for the subsequent list of flows */
end_comment

begin_function
specifier|static
name|void
name|print_mask
parameter_list|(
name|struct
name|ipfw_flow_id
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
operator|!
name|IS_IP6_FLOW_ID
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"    "
literal|"mask: %s 0x%02x 0x%08x/0x%04x -> 0x%08x/0x%04x\n"
argument_list|,
name|id
operator|->
name|extra
condition|?
literal|"queue,"
else|:
literal|""
argument_list|,
name|id
operator|->
name|proto
argument_list|,
name|id
operator|->
name|src_ip
argument_list|,
name|id
operator|->
name|src_port
argument_list|,
name|id
operator|->
name|dst_ip
argument_list|,
name|id
operator|->
name|dst_port
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BKT Prot ___Source IP/port____ "
literal|"____Dest. IP/port____ "
literal|"Tot_pkt/bytes Pkt/Byte Drp\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|255
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"\n        mask: %sproto: 0x%02x, flow_id: 0x%08x,  "
argument_list|,
name|id
operator|->
name|extra
condition|?
literal|"queue,"
else|:
literal|""
argument_list|,
name|id
operator|->
name|proto
argument_list|,
name|id
operator|->
name|flow_id6
argument_list|)
expr_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
operator|(
name|id
operator|->
name|src_ip6
operator|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s/0x%04x -> "
argument_list|,
name|buf
argument_list|,
name|id
operator|->
name|src_port
argument_list|)
expr_stmt|;
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
operator|(
name|id
operator|->
name|dst_ip6
operator|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s/0x%04x\n"
argument_list|,
name|buf
argument_list|,
name|id
operator|->
name|dst_port
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BKT ___Prot___ _flow-id_ "
literal|"______________Source IPv6/port_______________ "
literal|"_______________Dest. IPv6/port_______________ "
literal|"Tot_pkt/bytes Pkt/Byte Drp\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|list_flow
parameter_list|(
name|struct
name|dn_flow
modifier|*
name|ni
parameter_list|)
block|{
name|char
name|buff
index|[
literal|255
index|]
decl_stmt|;
name|struct
name|protoent
modifier|*
name|pe
decl_stmt|;
name|struct
name|in_addr
name|ina
decl_stmt|;
name|struct
name|ipfw_flow_id
modifier|*
name|id
init|=
operator|&
name|ni
operator|->
name|fid
decl_stmt|;
name|pe
operator|=
name|getprotobynumber
argument_list|(
name|id
operator|->
name|proto
argument_list|)
expr_stmt|;
comment|/* XXX: Should check for IPv4 flows */
name|printf
argument_list|(
literal|"%3u%c"
argument_list|,
operator|(
name|ni
operator|->
name|oid
operator|.
name|id
operator|)
operator|&
literal|0xff
argument_list|,
name|id
operator|->
name|extra
condition|?
literal|'*'
else|:
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_IP6_FLOW_ID
argument_list|(
name|id
argument_list|)
condition|)
block|{
if|if
condition|(
name|pe
condition|)
name|printf
argument_list|(
literal|"%-4s "
argument_list|,
name|pe
operator|->
name|p_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%4u "
argument_list|,
name|id
operator|->
name|proto
argument_list|)
expr_stmt|;
name|ina
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|id
operator|->
name|src_ip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%15s/%-5d "
argument_list|,
name|inet_ntoa
argument_list|(
name|ina
argument_list|)
argument_list|,
name|id
operator|->
name|src_port
argument_list|)
expr_stmt|;
name|ina
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|id
operator|->
name|dst_ip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%15s/%-5d "
argument_list|,
name|inet_ntoa
argument_list|(
name|ina
argument_list|)
argument_list|,
name|id
operator|->
name|dst_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Print IPv6 flows */
if|if
condition|(
name|pe
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%9s "
argument_list|,
name|pe
operator|->
name|p_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%9u "
argument_list|,
name|id
operator|->
name|proto
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%7d  %39s/%-5d "
argument_list|,
name|id
operator|->
name|flow_id6
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
operator|(
name|id
operator|->
name|src_ip6
operator|)
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|)
argument_list|,
name|id
operator|->
name|src_port
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %39s/%-5d "
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
operator|(
name|id
operator|->
name|dst_ip6
operator|)
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|)
argument_list|,
name|id
operator|->
name|dst_port
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%4llu %8llu %2u %4u %3u\n"
argument_list|,
name|align_uint64
argument_list|(
operator|&
name|ni
operator|->
name|tot_pkts
argument_list|)
argument_list|,
name|align_uint64
argument_list|(
operator|&
name|ni
operator|->
name|tot_bytes
argument_list|)
argument_list|,
name|ni
operator|->
name|length
argument_list|,
name|ni
operator|->
name|len_bytes
argument_list|,
name|ni
operator|->
name|drops
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_flowset_parms
parameter_list|(
name|struct
name|dn_fs
modifier|*
name|fs
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|l
decl_stmt|;
name|char
name|qs
index|[
literal|30
index|]
decl_stmt|;
name|char
name|plr
index|[
literal|30
index|]
decl_stmt|;
name|char
name|red
index|[
literal|90
index|]
decl_stmt|;
comment|/* Display RED parameters */
name|l
operator|=
name|fs
operator|->
name|qsize
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|flags
operator|&
name|DN_QSIZE_BYTES
condition|)
block|{
if|if
condition|(
name|l
operator|>=
literal|8192
condition|)
name|sprintf
argument_list|(
name|qs
argument_list|,
literal|"%d KB"
argument_list|,
name|l
operator|/
literal|1024
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|qs
argument_list|,
literal|"%d B"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|qs
argument_list|,
literal|"%3d sl."
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|plr
condition|)
name|sprintf
argument_list|(
name|plr
argument_list|,
literal|"plr %f"
argument_list|,
literal|1.0
operator|*
name|fs
operator|->
name|plr
operator|/
call|(
name|double
call|)
argument_list|(
literal|0x7fffffff
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|plr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|flags
operator|&
name|DN_IS_RED
condition|)
comment|/* RED parameters */
name|sprintf
argument_list|(
name|red
argument_list|,
literal|"\n\t %cRED w_q %f min_th %d max_th %d max_p %f"
argument_list|,
operator|(
name|fs
operator|->
name|flags
operator|&
name|DN_IS_GENTLE_RED
operator|)
condition|?
literal|'G'
else|:
literal|' '
argument_list|,
literal|1.0
operator|*
name|fs
operator|->
name|w_q
operator|/
call|(
name|double
call|)
argument_list|(
literal|1
operator|<<
name|SCALE_RED
argument_list|)
argument_list|,
name|fs
operator|->
name|min_th
argument_list|,
name|fs
operator|->
name|max_th
argument_list|,
literal|1.0
operator|*
name|fs
operator|->
name|max_p
operator|/
call|(
name|double
call|)
argument_list|(
literal|1
operator|<<
name|SCALE_RED
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|red
argument_list|,
literal|"droptail"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
index|[
literal|0
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"%s %s%s %d queues (%d buckets) %s\n"
argument_list|,
name|prefix
argument_list|,
name|qs
argument_list|,
name|plr
argument_list|,
name|fs
operator|->
name|oid
operator|.
name|id
argument_list|,
name|fs
operator|->
name|buckets
argument_list|,
name|red
argument_list|)
expr_stmt|;
name|prefix
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"q%05d %s%s %d flows (%d buckets) sched %d "
literal|"weight %d lmax %d pri %d %s\n"
argument_list|,
name|fs
operator|->
name|fs_nr
argument_list|,
name|qs
argument_list|,
name|plr
argument_list|,
name|fs
operator|->
name|oid
operator|.
name|id
argument_list|,
name|fs
operator|->
name|buckets
argument_list|,
name|fs
operator|->
name|sched_nr
argument_list|,
name|fs
operator|->
name|par
index|[
literal|0
index|]
argument_list|,
name|fs
operator|->
name|par
index|[
literal|1
index|]
argument_list|,
name|fs
operator|->
name|par
index|[
literal|2
index|]
argument_list|,
name|red
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|flags
operator|&
name|DN_HAVE_MASK
condition|)
name|print_mask
argument_list|(
operator|&
name|fs
operator|->
name|flow_mask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_extra_delay_parms
parameter_list|(
name|struct
name|dn_profile
modifier|*
name|p
parameter_list|)
block|{
name|double
name|loss
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|samples_no
operator|<=
literal|0
condition|)
return|return;
name|loss
operator|=
name|p
operator|->
name|loss_level
expr_stmt|;
name|loss
operator|/=
name|p
operator|->
name|samples_no
expr_stmt|;
name|printf
argument_list|(
literal|"\t profile: name \"%s\" loss %f samples %d\n"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|loss
argument_list|,
name|p
operator|->
name|samples_no
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flush_buf
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * generic list routine. We expect objects in a specific order, i.e.  * PIPES AND SCHEDULERS:  *	link; scheduler; internal flowset if any; instances  * we can tell a pipe from the number.  *  * FLOWSETS:  *	flowset; queues;  * link i (int queue); scheduler i; si(i) { flowsets() : queues }  */
end_comment

begin_function
specifier|static
name|void
name|list_pipes
parameter_list|(
name|struct
name|dn_id
modifier|*
name|oid
parameter_list|,
name|struct
name|dn_id
modifier|*
name|end
parameter_list|)
block|{
name|char
name|buf
index|[
literal|160
index|]
decl_stmt|;
comment|/* pending buffer */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
name|oid
operator|!=
name|end
condition|;
name|oid
operator|=
name|O_NEXT
argument_list|(
name|oid
argument_list|,
name|oid
operator|->
name|len
argument_list|)
control|)
block|{
if|if
condition|(
name|oid
operator|->
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|oid
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid oid len %d\n"
argument_list|,
name|oid
operator|->
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|oid
operator|->
name|type
condition|)
block|{
default|default:
name|flush_buf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unrecognized object %d size %d\n"
argument_list|,
name|oid
operator|->
name|type
argument_list|,
name|oid
operator|->
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|DN_TEXT
case|:
comment|/* list of attached flowsets */
block|{
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
struct|struct
block|{
name|struct
name|dn_id
name|id
decl_stmt|;
name|uint32_t
name|p
index|[
literal|0
index|]
decl_stmt|;
block|}
modifier|*
name|d
init|=
operator|(
name|void
operator|*
operator|)
name|oid
struct|;
name|l
operator|=
operator|(
name|oid
operator|->
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|oid
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|d
operator|->
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"   Children flowsets: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%u "
argument_list|,
name|d
operator|->
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DN_CMD_GET
case|:
if|if
condition|(
name|co
operator|.
name|verbose
condition|)
name|printf
argument_list|(
literal|"answer for cmd %d, len %d\n"
argument_list|,
name|oid
operator|->
name|type
argument_list|,
name|oid
operator|->
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|DN_SCH
case|:
block|{
name|struct
name|dn_sch
modifier|*
name|s
init|=
operator|(
expr|struct
name|dn_sch
operator|*
operator|)
name|oid
decl_stmt|;
name|flush_buf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" sched %d type %s flags 0x%x %d buckets %d active\n"
argument_list|,
name|s
operator|->
name|sched_nr
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|buckets
argument_list|,
name|s
operator|->
name|oid
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|DN_HAVE_MASK
condition|)
name|print_mask
argument_list|(
operator|&
name|s
operator|->
name|sched_mask
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DN_FLOW
case|:
name|list_flow
argument_list|(
operator|(
expr|struct
name|dn_flow
operator|*
operator|)
name|oid
argument_list|)
expr_stmt|;
break|break;
case|case
name|DN_LINK
case|:
block|{
name|struct
name|dn_link
modifier|*
name|p
init|=
operator|(
expr|struct
name|dn_link
operator|*
operator|)
name|oid
decl_stmt|;
name|double
name|b
init|=
name|p
operator|->
name|bandwidth
decl_stmt|;
name|char
name|bwbuf
index|[
literal|30
index|]
decl_stmt|;
name|char
name|burst
index|[
literal|5
operator|+
literal|7
index|]
decl_stmt|;
comment|/* This starts a new object so flush buffer */
name|flush_buf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* data rate */
if|if
condition|(
name|b
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|bwbuf
argument_list|,
literal|"unlimited     "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|>=
literal|1000000
condition|)
name|sprintf
argument_list|(
name|bwbuf
argument_list|,
literal|"%7.3f Mbit/s"
argument_list|,
name|b
operator|/
literal|1000000
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|>=
literal|1000
condition|)
name|sprintf
argument_list|(
name|bwbuf
argument_list|,
literal|"%7.3f Kbit/s"
argument_list|,
name|b
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|bwbuf
argument_list|,
literal|"%7.3f bit/s "
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|humanize_number
argument_list|(
name|burst
argument_list|,
sizeof|sizeof
argument_list|(
name|burst
argument_list|)
argument_list|,
name|p
operator|->
name|burst
argument_list|,
literal|""
argument_list|,
name|HN_AUTOSCALE
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|||
name|co
operator|.
name|verbose
condition|)
name|sprintf
argument_list|(
name|burst
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|burst
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%05d: %s %4d ms burst %s"
argument_list|,
name|p
operator|->
name|link_nr
operator|%
name|DN_MAX_ID
argument_list|,
name|bwbuf
argument_list|,
name|p
operator|->
name|delay
argument_list|,
name|burst
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DN_FS
case|:
name|print_flowset_parms
argument_list|(
operator|(
expr|struct
name|dn_fs
operator|*
operator|)
name|oid
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|DN_PROFILE
case|:
name|flush_buf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|print_extra_delay_parms
argument_list|(
operator|(
expr|struct
name|dn_profile
operator|*
operator|)
name|oid
argument_list|)
expr_stmt|;
block|}
name|flush_buf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|// XXX does it really go here ?
block|}
block|}
end_function

begin_comment
comment|/*  * Delete pipe, queue or scheduler i  */
end_comment

begin_function
name|int
name|ipfw_delete_pipe
parameter_list|(
name|int
name|do_pipe
parameter_list|,
name|int
name|i
parameter_list|)
block|{
struct|struct
block|{
name|struct
name|dn_id
name|oid
decl_stmt|;
name|uintptr_t
name|a
index|[
literal|1
index|]
decl_stmt|;
comment|/* add more if we want a list */
block|}
name|cmd
struct|;
name|oid_fill
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|DN_CMD_DELETE
argument_list|,
name|DN_API_VERSION
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|oid
operator|.
name|subtype
operator|=
operator|(
name|do_pipe
operator|==
literal|1
operator|)
condition|?
name|DN_LINK
else|:
operator|(
operator|(
name|do_pipe
operator|==
literal|2
operator|)
condition|?
name|DN_FS
else|:
name|DN_SCH
operator|)
expr_stmt|;
name|cmd
operator|.
name|a
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|i
operator|=
name|do_cmd
argument_list|(
name|IP_DUMMYNET3
argument_list|,
operator|&
name|cmd
argument_list|,
name|cmd
operator|.
name|oid
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
name|warn
argument_list|(
literal|"rule %u: setsockopt(IP_DUMMYNET_DEL)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  * Code to parse delay profiles.  *  * Some link types introduce extra delays in the transmission  * of a packet, e.g. because of MAC level framing, contention on  * the use of the channel, MAC level retransmissions and so on.  * From our point of view, the channel is effectively unavailable  * for this extra time, which is constant or variable depending  * on the link type. Additionally, packets may be dropped after this  * time (e.g. on a wireless link after too many retransmissions).  * We can model the additional delay with an empirical curve  * that represents its distribution.  *  *	cumulative probability  *	1.0 ^  *	    |  *	L   +-- loss-level          x  *	    |                 ******  *	    |                *  *	    |           *****  *	    |          *  *	    |        **  *	    |       *                           *	    +-------*------------------->  *			delay  *  * The empirical curve may have both vertical and horizontal lines.  * Vertical lines represent constant delay for a range of  * probabilities; horizontal lines correspond to a discontinuty  * in the delay distribution: the link will use the largest delay  * for a given probability.  *   * To pass the curve to dummynet, we must store the parameters  * in a file as described below, and issue the command  *  *      ipfw pipe<n> config ... bw XXX profile<filename> ...  *  * The file format is the following, with whitespace acting as  * a separator and '#' indicating the beginning a comment:  *  *	samples N  *		the number of samples used in the internal  *		representation (2..1024; default 100);  *  *	loss-level L   *		The probability above which packets are lost.  *               (0.0<= L<= 1.0, default 1.0 i.e. no loss);  *  *	name identifier  *		Optional a name (listed by "ipfw pipe show")  *		to identify the distribution;  *  *	"delay prob" | "prob delay"  *		One of these two lines is mandatory and defines  *		the format of the following lines with data points.  *  *	XXX YYY  *		2 or more lines representing points in the curve,  *		with either delay or probability first, according  *		to the chosen format.  *		The unit for delay is milliseconds.  *  * Data points does not need to be ordered or equal to the number  * specified in the "samples" line. ipfw will sort and interpolate  * the curve as needed.  *  * Example of a profile file:           name    bla_bla_bla         samples 100         loss-level    0.86         prob    delay         0       200	# minimum overhead is 200ms         0.5     200         0.5     300         0.8     1000         0.9     1300         1       1300    * Internally, we will convert the curve to a fixed number of  * samples, and when it is time to transmit a packet we will  * model the extra delay as extra bits in the packet.  *  */
end_comment

begin_define
define|#
directive|define
name|ED_MAX_LINE_LEN
value|256+ED_MAX_NAME_LEN
end_define

begin_define
define|#
directive|define
name|ED_TOK_SAMPLES
value|"samples"
end_define

begin_define
define|#
directive|define
name|ED_TOK_LOSS
value|"loss-level"
end_define

begin_define
define|#
directive|define
name|ED_TOK_NAME
value|"name"
end_define

begin_define
define|#
directive|define
name|ED_TOK_DELAY
value|"delay"
end_define

begin_define
define|#
directive|define
name|ED_TOK_PROB
value|"prob"
end_define

begin_define
define|#
directive|define
name|ED_TOK_BW
value|"bw"
end_define

begin_define
define|#
directive|define
name|ED_SEPARATORS
value|" \t\n"
end_define

begin_define
define|#
directive|define
name|ED_MIN_SAMPLES_NO
value|2
end_define

begin_comment
comment|/*  * returns 1 if s is a non-negative number, with at least one '.'  */
end_comment

begin_function
specifier|static
name|int
name|is_valid_number
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|dots_found
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
operator|&&
operator|(
name|s
index|[
name|i
index|]
operator|!=
literal|'.'
operator|||
operator|++
name|dots_found
operator|>
literal|1
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Take as input a string describing a bandwidth value  * and return the numeric bandwidth value.  * set clocking interface or bandwidth value  */
end_comment

begin_function
specifier|static
name|void
name|read_bandwidth
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
modifier|*
name|bandwidth
parameter_list|,
name|char
modifier|*
name|if_name
parameter_list|,
name|int
name|namelen
parameter_list|)
block|{
if|if
condition|(
operator|*
name|bandwidth
operator|!=
operator|-
literal|1
condition|)
name|warnx
argument_list|(
literal|"duplicate token, override bandwidth value!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|arg
index|[
literal|0
index|]
operator|<=
literal|'z'
condition|)
block|{
if|if
condition|(
operator|!
name|if_name
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"no if support"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|namelen
operator|>=
name|IFNAMSIZ
condition|)
name|warn
argument_list|(
literal|"interface name truncated"
argument_list|)
expr_stmt|;
name|namelen
operator|--
expr_stmt|;
comment|/* interface name */
name|strncpy
argument_list|(
name|if_name
argument_list|,
name|arg
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|if_name
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|bandwidth
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* read bandwidth value */
name|int
name|bw
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|NULL
decl_stmt|;
name|bw
operator|=
name|strtoul
argument_list|(
name|arg
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'K'
operator|||
operator|*
name|end
operator|==
literal|'k'
condition|)
block|{
name|end
operator|++
expr_stmt|;
name|bw
operator|*=
literal|1000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|end
operator|==
literal|'M'
condition|)
block|{
name|end
operator|++
expr_stmt|;
name|bw
operator|*=
literal|1000000
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|end
operator|==
literal|'B'
operator|&&
name|_substrcmp2
argument_list|(
name|end
argument_list|,
literal|"Bi"
argument_list|,
literal|"Bit/s"
argument_list|)
operator|!=
literal|0
operator|)
operator|||
name|_substrcmp2
argument_list|(
name|end
argument_list|,
literal|"by"
argument_list|,
literal|"bytes"
argument_list|)
operator|==
literal|0
condition|)
name|bw
operator|*=
literal|8
expr_stmt|;
if|if
condition|(
name|bw
operator|<
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"bandwidth too large"
argument_list|)
expr_stmt|;
operator|*
name|bandwidth
operator|=
name|bw
expr_stmt|;
if|if
condition|(
name|if_name
condition|)
name|if_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|point
block|{
name|double
name|prob
decl_stmt|;
name|double
name|delay
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|compare_points
parameter_list|(
specifier|const
name|void
modifier|*
name|vp1
parameter_list|,
specifier|const
name|void
modifier|*
name|vp2
parameter_list|)
block|{
specifier|const
name|struct
name|point
modifier|*
name|p1
init|=
name|vp1
decl_stmt|;
specifier|const
name|struct
name|point
modifier|*
name|p2
init|=
name|vp2
decl_stmt|;
name|double
name|res
init|=
literal|0
decl_stmt|;
name|res
operator|=
name|p1
operator|->
name|prob
operator|-
name|p2
operator|->
name|prob
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
name|res
operator|=
name|p1
operator|->
name|delay
operator|-
name|p2
operator|->
name|delay
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|res
operator|>
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ED_EFMT
parameter_list|(
name|s
parameter_list|)
value|EX_DATAERR,"error in %s at line %d: "#s,filename,lineno
end_define

begin_function
specifier|static
name|void
name|load_extra_delays
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|dn_profile
modifier|*
name|p
parameter_list|,
name|struct
name|dn_link
modifier|*
name|link
parameter_list|)
block|{
name|char
name|line
index|[
name|ED_MAX_LINE_LEN
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|lineno
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|samples
init|=
operator|-
literal|1
decl_stmt|;
name|double
name|loss
init|=
operator|-
literal|1.0
decl_stmt|;
name|char
name|profile_name
index|[
name|ED_MAX_NAME_LEN
index|]
decl_stmt|;
name|int
name|delay_first
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|do_points
init|=
literal|0
decl_stmt|;
name|struct
name|point
name|points
index|[
name|ED_MAX_SAMPLES_NO
index|]
decl_stmt|;
name|int
name|points_no
init|=
literal|0
decl_stmt|;
comment|/* XXX link never NULL? */
name|p
operator|->
name|link_nr
operator|=
name|link
operator|->
name|link_nr
expr_stmt|;
name|profile_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
literal|"fopen: %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|ED_MAX_LINE_LEN
argument_list|,
name|f
argument_list|)
condition|)
block|{
comment|/* read commands */
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|cur
init|=
name|line
decl_stmt|,
modifier|*
name|name
init|=
name|NULL
decl_stmt|,
modifier|*
name|arg
init|=
name|NULL
decl_stmt|;
operator|++
name|lineno
expr_stmt|;
comment|/* parse the line */
while|while
condition|(
name|cur
condition|)
block|{
name|s
operator|=
name|strsep
argument_list|(
operator|&
name|cur
argument_list|,
name|ED_SEPARATORS
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|*
name|s
operator|==
literal|'#'
condition|)
break|break;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|arg
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"too many arguments"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|s
expr_stmt|;
else|else
name|arg
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
comment|/* empty line */
continue|continue;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"missing arg for %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|ED_TOK_SAMPLES
argument_list|)
condition|)
block|{
if|if
condition|(
name|samples
operator|>
literal|0
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"duplicate ``samples'' line"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|atoi
argument_list|(
name|arg
argument_list|)
operator|<=
literal|0
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"invalid number of samples"
argument_list|)
argument_list|)
expr_stmt|;
name|samples
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|>
name|ED_MAX_SAMPLES_NO
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"too many samples, maximum is %d"
argument_list|)
argument_list|,
name|ED_MAX_SAMPLES_NO
argument_list|)
expr_stmt|;
name|do_points
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|ED_TOK_BW
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
name|read_bandwidth
argument_list|(
name|arg
argument_list|,
operator|&
name|link
operator|->
name|bandwidth
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|ED_TOK_LOSS
argument_list|)
condition|)
block|{
if|if
condition|(
name|loss
operator|!=
operator|-
literal|1.0
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"duplicated token: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_valid_number
argument_list|(
name|arg
argument_list|)
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"invalid %s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|loss
operator|=
name|atof
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|loss
operator|>
literal|1
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"%s greater than 1.0"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|do_points
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|ED_TOK_NAME
argument_list|)
condition|)
block|{
if|if
condition|(
name|profile_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"duplicated token: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|profile_name
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|profile_name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|profile_name
index|[
sizeof|sizeof
argument_list|(
name|profile_name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|do_points
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|ED_TOK_DELAY
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_points
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"duplicated token: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|delay_first
operator|=
literal|1
expr_stmt|;
name|do_points
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|ED_TOK_PROB
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_points
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"duplicated token: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|delay_first
operator|=
literal|0
expr_stmt|;
name|do_points
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|do_points
condition|)
block|{
if|if
condition|(
operator|!
name|is_valid_number
argument_list|(
name|name
argument_list|)
operator|||
operator|!
name|is_valid_number
argument_list|(
name|arg
argument_list|)
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"invalid point found"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay_first
condition|)
block|{
name|points
index|[
name|points_no
index|]
operator|.
name|delay
operator|=
name|atof
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|points
index|[
name|points_no
index|]
operator|.
name|prob
operator|=
name|atof
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|points
index|[
name|points_no
index|]
operator|.
name|delay
operator|=
name|atof
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|points
index|[
name|points_no
index|]
operator|.
name|prob
operator|=
name|atof
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|points
index|[
name|points_no
index|]
operator|.
name|prob
operator|>
literal|1.0
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"probability greater than 1.0"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|points_no
expr_stmt|;
block|}
else|else
block|{
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"unrecognised command '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"'%s' not found, assuming 100"
argument_list|,
name|ED_TOK_SAMPLES
argument_list|)
expr_stmt|;
name|samples
operator|=
literal|100
expr_stmt|;
block|}
if|if
condition|(
name|loss
operator|==
operator|-
literal|1.0
condition|)
block|{
name|warnx
argument_list|(
literal|"'%s' not found, assuming no loss"
argument_list|,
name|ED_TOK_LOSS
argument_list|)
expr_stmt|;
name|loss
operator|=
literal|1
expr_stmt|;
block|}
comment|/* make sure that there are enough points. */
if|if
condition|(
name|points_no
operator|<
name|ED_MIN_SAMPLES_NO
condition|)
name|errx
argument_list|(
name|ED_EFMT
argument_list|(
literal|"too few samples, need at least %d"
argument_list|)
argument_list|,
name|ED_MIN_SAMPLES_NO
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|points
argument_list|,
name|points_no
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|point
argument_list|)
argument_list|,
name|compare_points
argument_list|)
expr_stmt|;
comment|/* interpolation */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|points_no
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|double
name|y1
init|=
name|points
index|[
name|i
index|]
operator|.
name|prob
operator|*
name|samples
decl_stmt|;
name|double
name|x1
init|=
name|points
index|[
name|i
index|]
operator|.
name|delay
decl_stmt|;
name|double
name|y2
init|=
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|prob
operator|*
name|samples
decl_stmt|;
name|double
name|x2
init|=
name|points
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|delay
decl_stmt|;
name|int
name|ix
init|=
name|y1
decl_stmt|;
name|int
name|stop
init|=
name|y2
decl_stmt|;
if|if
condition|(
name|x1
operator|==
name|x2
condition|)
block|{
for|for
control|(
init|;
name|ix
operator|<
name|stop
condition|;
operator|++
name|ix
control|)
name|p
operator|->
name|samples
index|[
name|ix
index|]
operator|=
name|x1
expr_stmt|;
block|}
else|else
block|{
name|double
name|m
init|=
operator|(
name|y2
operator|-
name|y1
operator|)
operator|/
operator|(
name|x2
operator|-
name|x1
operator|)
decl_stmt|;
name|double
name|c
init|=
name|y1
operator|-
name|m
operator|*
name|x1
decl_stmt|;
for|for
control|(
init|;
name|ix
operator|<
name|stop
condition|;
operator|++
name|ix
control|)
name|p
operator|->
name|samples
index|[
name|ix
index|]
operator|=
operator|(
name|ix
operator|-
name|c
operator|)
operator|/
name|m
expr_stmt|;
block|}
block|}
name|p
operator|->
name|samples_no
operator|=
name|samples
expr_stmt|;
name|p
operator|->
name|loss_level
operator|=
name|loss
operator|*
name|samples
expr_stmt|;
name|strncpy
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|profile_name
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * configuration of pipes, schedulers, flowsets.  * When we configure a new scheduler, an empty pipe is created, so:  *   * do_pipe = 1 -> "pipe N config ..." only for backward compatibility  *	sched N+Delta type fifo sched_mask ...  *	pipe N+Delta<parameters>  *	flowset N+Delta pipe N+Delta (no parameters)  *	sched N type wf2q+ sched_mask ...  *	pipe N<parameters>  *  * do_pipe = 2 -> flowset N config  *	flowset N parameters  *  * do_pipe = 3 -> sched N config  *	sched N parameters (default no pipe)  *	optional Pipe N config ...  * pipe ==>  */
end_comment

begin_function
name|void
name|ipfw_config_pipe
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|void
modifier|*
name|par
init|=
name|NULL
decl_stmt|;
name|struct
name|dn_id
modifier|*
name|buf
decl_stmt|,
modifier|*
name|base
decl_stmt|;
name|struct
name|dn_sch
modifier|*
name|sch
init|=
name|NULL
decl_stmt|;
name|struct
name|dn_link
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|struct
name|dn_fs
modifier|*
name|fs
init|=
name|NULL
decl_stmt|;
name|struct
name|dn_profile
modifier|*
name|pf
init|=
name|NULL
decl_stmt|;
name|struct
name|ipfw_flow_id
modifier|*
name|mask
init|=
name|NULL
decl_stmt|;
name|int
name|lmax
decl_stmt|;
name|uint32_t
name|_foo
init|=
literal|0
decl_stmt|,
modifier|*
name|flags
init|=
operator|&
name|_foo
decl_stmt|,
modifier|*
name|buckets
init|=
operator|&
name|_foo
decl_stmt|;
comment|/* 	 * allocate space for 1 header, 	 * 1 scheduler, 1 link, 1 flowset, 1 profile 	 */
name|lmax
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_id
argument_list|)
expr_stmt|;
comment|/* command header */
name|lmax
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_sch
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|dn_link
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|dn_fs
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|dn_profile
argument_list|)
expr_stmt|;
name|av
operator|++
expr_stmt|;
name|ac
operator|--
expr_stmt|;
comment|/* Pipe number */
if|if
condition|(
name|ac
operator|&&
name|isdigit
argument_list|(
operator|*
operator|*
name|av
argument_list|)
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
operator|*
name|av
argument_list|)
expr_stmt|;
name|av
operator|++
expr_stmt|;
name|ac
operator|--
expr_stmt|;
block|}
else|else
name|i
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"need a pipe/flowset/sched number"
argument_list|)
expr_stmt|;
name|base
operator|=
name|buf
operator|=
name|safe_calloc
argument_list|(
literal|1
argument_list|,
name|lmax
argument_list|)
expr_stmt|;
comment|/* all commands start with a 'CONFIGURE' and a version */
name|o_next
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dn_id
argument_list|)
argument_list|,
name|DN_CMD_CONFIG
argument_list|)
expr_stmt|;
name|base
operator|->
name|id
operator|=
name|DN_API_VERSION
expr_stmt|;
switch|switch
condition|(
name|co
operator|.
name|do_pipe
condition|)
block|{
case|case
literal|1
case|:
comment|/* "pipe N config ..." */
comment|/* Allocate space for the WF2Q+ scheduler, its link 		 * and the FIFO flowset. Set the number, but leave 		 * the scheduler subtype and other parameters to 0 		 * so the kernel will use appropriate defaults. 		 * XXX todo: add a flag to record if a parameter 		 * is actually configured. 		 * If we do a 'pipe config' mask -> sched_mask. 		 * The FIFO scheduler and link are derived from the 		 * WF2Q+ one in the kernel. 		 */
name|sch
operator|=
name|o_next
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sch
argument_list|)
argument_list|,
name|DN_SCH
argument_list|)
expr_stmt|;
name|p
operator|=
name|o_next
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|DN_LINK
argument_list|)
expr_stmt|;
name|fs
operator|=
name|o_next
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fs
argument_list|)
argument_list|,
name|DN_FS
argument_list|)
expr_stmt|;
name|sch
operator|->
name|sched_nr
operator|=
name|i
expr_stmt|;
name|sch
operator|->
name|oid
operator|.
name|subtype
operator|=
literal|0
expr_stmt|;
comment|/* defaults to WF2Q+ */
name|mask
operator|=
operator|&
name|sch
operator|->
name|sched_mask
expr_stmt|;
name|flags
operator|=
operator|&
name|sch
operator|->
name|flags
expr_stmt|;
name|buckets
operator|=
operator|&
name|sch
operator|->
name|buckets
expr_stmt|;
operator|*
name|flags
operator||=
name|DN_PIPE_CMD
expr_stmt|;
name|p
operator|->
name|link_nr
operator|=
name|i
expr_stmt|;
comment|/* This flowset is only for the FIFO scheduler */
name|fs
operator|->
name|fs_nr
operator|=
name|i
operator|+
literal|2
operator|*
name|DN_MAX_ID
expr_stmt|;
name|fs
operator|->
name|sched_nr
operator|=
name|i
operator|+
name|DN_MAX_ID
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* "queue N config ... " */
name|fs
operator|=
name|o_next
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fs
argument_list|)
argument_list|,
name|DN_FS
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_nr
operator|=
name|i
expr_stmt|;
name|mask
operator|=
operator|&
name|fs
operator|->
name|flow_mask
expr_stmt|;
name|flags
operator|=
operator|&
name|fs
operator|->
name|flags
expr_stmt|;
name|buckets
operator|=
operator|&
name|fs
operator|->
name|buckets
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* "sched N config ..." */
name|sch
operator|=
name|o_next
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sch
argument_list|)
argument_list|,
name|DN_SCH
argument_list|)
expr_stmt|;
name|fs
operator|=
name|o_next
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fs
argument_list|)
argument_list|,
name|DN_FS
argument_list|)
expr_stmt|;
name|sch
operator|->
name|sched_nr
operator|=
name|i
expr_stmt|;
name|mask
operator|=
operator|&
name|sch
operator|->
name|sched_mask
expr_stmt|;
name|flags
operator|=
operator|&
name|sch
operator|->
name|flags
expr_stmt|;
name|buckets
operator|=
operator|&
name|sch
operator|->
name|buckets
expr_stmt|;
comment|/* fs is used only with !MULTIQUEUE schedulers */
name|fs
operator|->
name|fs_nr
operator|=
name|i
operator|+
name|DN_MAX_ID
expr_stmt|;
name|fs
operator|->
name|sched_nr
operator|=
name|i
expr_stmt|;
break|break;
block|}
comment|/* set to -1 those fields for which we want to reuse existing 	 * values from the kernel. 	 * Also, *_nr and subtype = 0 mean reuse the value from the kernel. 	 * XXX todo: support reuse of the mask. 	 */
if|if
condition|(
name|p
condition|)
name|p
operator|->
name|bandwidth
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|fs
operator|->
name|par
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fs
operator|->
name|par
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
name|fs
operator|->
name|par
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|ac
operator|>
literal|0
condition|)
block|{
name|double
name|d
decl_stmt|;
name|int
name|tok
init|=
name|match_token
argument_list|(
name|dummynet_params
argument_list|,
operator|*
name|av
argument_list|)
decl_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|TOK_NOERROR
case|:
name|NEED
argument_list|(
name|fs
argument_list|,
literal|"noerror is only for pipes"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|flags
operator||=
name|DN_NOERROR
expr_stmt|;
break|break;
case|case
name|TOK_PLR
case|:
name|NEED
argument_list|(
name|fs
argument_list|,
literal|"plr is only for pipes"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"plr needs argument 0..1\n"
argument_list|)
expr_stmt|;
name|d
operator|=
name|strtod
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|1
condition|)
name|d
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|plr
operator|=
call|(
name|int
call|)
argument_list|(
name|d
operator|*
literal|0x7fffffff
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_QUEUE
case|:
name|NEED
argument_list|(
name|fs
argument_list|,
literal|"queue is only for pipes or flowsets"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"queue needs queue size\n"
argument_list|)
expr_stmt|;
name|end
operator|=
name|NULL
expr_stmt|;
name|fs
operator|->
name|qsize
operator|=
name|strtoul
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'K'
operator|||
operator|*
name|end
operator|==
literal|'k'
condition|)
block|{
name|fs
operator|->
name|flags
operator||=
name|DN_QSIZE_BYTES
expr_stmt|;
name|fs
operator|->
name|qsize
operator|*=
literal|1024
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|end
operator|==
literal|'B'
operator|||
name|_substrcmp2
argument_list|(
name|end
argument_list|,
literal|"by"
argument_list|,
literal|"bytes"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fs
operator|->
name|flags
operator||=
name|DN_QSIZE_BYTES
expr_stmt|;
block|}
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_BUCKETS
case|:
name|NEED
argument_list|(
name|fs
argument_list|,
literal|"buckets is only for pipes or flowsets"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"buckets needs argument\n"
argument_list|)
expr_stmt|;
operator|*
name|buckets
operator|=
name|strtoul
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_FLOW_MASK
case|:
case|case
name|TOK_SCHED_MASK
case|:
case|case
name|TOK_MASK
case|:
name|NEED
argument_list|(
name|mask
argument_list|,
literal|"tok_mask"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"mask needs mask specifier\n"
argument_list|)
expr_stmt|;
comment|/* 			 * per-flow queue, mask is dst_ip, dst_port, 			 * src_ip, src_port, proto measured in bits 			 */
name|par
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|mask
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|end
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|ac
operator|>=
literal|1
condition|)
block|{
name|uint32_t
modifier|*
name|p32
init|=
name|NULL
decl_stmt|;
name|uint16_t
modifier|*
name|p16
init|=
name|NULL
decl_stmt|;
name|uint32_t
modifier|*
name|p20
init|=
name|NULL
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|pa6
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|a
decl_stmt|;
name|tok
operator|=
name|match_token
argument_list|(
name|dummynet_params
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|TOK_ALL
case|:
comment|/* 				     * special case, all bits significant 				     * except 'extra' (the queue number) 				     */
name|mask
operator|->
name|dst_ip
operator|=
operator|~
literal|0
expr_stmt|;
name|mask
operator|->
name|src_ip
operator|=
operator|~
literal|0
expr_stmt|;
name|mask
operator|->
name|dst_port
operator|=
operator|~
literal|0
expr_stmt|;
name|mask
operator|->
name|src_port
operator|=
operator|~
literal|0
expr_stmt|;
name|mask
operator|->
name|proto
operator|=
operator|~
literal|0
expr_stmt|;
name|n2mask
argument_list|(
operator|&
name|mask
operator|->
name|dst_ip6
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|n2mask
argument_list|(
operator|&
name|mask
operator|->
name|src_ip6
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|mask
operator|->
name|flow_id6
operator|=
operator|~
literal|0
expr_stmt|;
operator|*
name|flags
operator||=
name|DN_HAVE_MASK
expr_stmt|;
goto|goto
name|end_mask
goto|;
case|case
name|TOK_QUEUE
case|:
name|mask
operator|->
name|extra
operator|=
operator|~
literal|0
expr_stmt|;
operator|*
name|flags
operator||=
name|DN_HAVE_MASK
expr_stmt|;
goto|goto
name|end_mask
goto|;
case|case
name|TOK_DSTIP
case|:
name|mask
operator|->
name|addr_type
operator|=
literal|4
expr_stmt|;
name|p32
operator|=
operator|&
name|mask
operator|->
name|dst_ip
expr_stmt|;
break|break;
case|case
name|TOK_SRCIP
case|:
name|mask
operator|->
name|addr_type
operator|=
literal|4
expr_stmt|;
name|p32
operator|=
operator|&
name|mask
operator|->
name|src_ip
expr_stmt|;
break|break;
case|case
name|TOK_DSTIP6
case|:
name|mask
operator|->
name|addr_type
operator|=
literal|6
expr_stmt|;
name|pa6
operator|=
operator|&
name|mask
operator|->
name|dst_ip6
expr_stmt|;
break|break;
case|case
name|TOK_SRCIP6
case|:
name|mask
operator|->
name|addr_type
operator|=
literal|6
expr_stmt|;
name|pa6
operator|=
operator|&
name|mask
operator|->
name|src_ip6
expr_stmt|;
break|break;
case|case
name|TOK_FLOWID
case|:
name|mask
operator|->
name|addr_type
operator|=
literal|6
expr_stmt|;
name|p20
operator|=
operator|&
name|mask
operator|->
name|flow_id6
expr_stmt|;
break|break;
case|case
name|TOK_DSTPORT
case|:
name|p16
operator|=
operator|&
name|mask
operator|->
name|dst_port
expr_stmt|;
break|break;
case|case
name|TOK_SRCPORT
case|:
name|p16
operator|=
operator|&
name|mask
operator|->
name|src_port
expr_stmt|;
break|break;
case|case
name|TOK_PROTO
case|:
break|break;
default|default:
name|ac
operator|++
expr_stmt|;
name|av
operator|--
expr_stmt|;
comment|/* backtrack */
goto|goto
name|end_mask
goto|;
block|}
if|if
condition|(
name|ac
operator|<
literal|1
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"mask: value missing"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|av
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|a
operator|=
name|strtoul
argument_list|(
name|av
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa6
operator|==
name|NULL
condition|)
name|a
operator|=
operator|(
name|a
operator|==
literal|32
operator|)
condition|?
operator|~
literal|0
else|:
operator|(
literal|1
operator|<<
name|a
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|a
operator|=
name|strtoul
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p32
operator|!=
name|NULL
condition|)
operator|*
name|p32
operator|=
name|a
expr_stmt|;
elseif|else
if|if
condition|(
name|p16
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|a
operator|>
literal|0xFFFF
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"port mask must be 16 bit"
argument_list|)
expr_stmt|;
operator|*
name|p16
operator|=
operator|(
name|uint16_t
operator|)
name|a
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p20
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|a
operator|>
literal|0xfffff
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"flow_id mask must be 20 bit"
argument_list|)
expr_stmt|;
operator|*
name|p20
operator|=
operator|(
name|uint32_t
operator|)
name|a
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pa6
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|a
operator|>
literal|128
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"in6addr invalid mask len"
argument_list|)
expr_stmt|;
else|else
name|n2mask
argument_list|(
name|pa6
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|a
operator|>
literal|0xFF
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"proto mask must be 8 bit"
argument_list|)
expr_stmt|;
name|mask
operator|->
name|proto
operator|=
operator|(
name|uint8_t
operator|)
name|a
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|!=
literal|0
condition|)
operator|*
name|flags
operator||=
name|DN_HAVE_MASK
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
block|}
comment|/* end while, config masks */
name|end_mask
label|:
break|break;
case|case
name|TOK_RED
case|:
case|case
name|TOK_GRED
case|:
name|NEED1
argument_list|(
literal|"red/gred needs w_q/min_th/max_th/max_p\n"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|flags
operator||=
name|DN_IS_RED
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|TOK_GRED
condition|)
name|fs
operator|->
name|flags
operator||=
name|DN_IS_GENTLE_RED
expr_stmt|;
comment|/* 			 * the format for parameters is w_q/min_th/max_th/max_p 			 */
if|if
condition|(
operator|(
name|end
operator|=
name|strsep
argument_list|(
operator|&
name|av
index|[
literal|0
index|]
argument_list|,
literal|"/"
argument_list|)
operator|)
condition|)
block|{
name|double
name|w_q
init|=
name|strtod
argument_list|(
name|end
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|w_q
operator|>
literal|1
operator|||
name|w_q
operator|<=
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"0< w_q<= 1"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|w_q
operator|=
call|(
name|int
call|)
argument_list|(
name|w_q
operator|*
operator|(
literal|1
operator|<<
name|SCALE_RED
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|end
operator|=
name|strsep
argument_list|(
operator|&
name|av
index|[
literal|0
index|]
argument_list|,
literal|"/"
argument_list|)
operator|)
condition|)
block|{
name|fs
operator|->
name|min_th
operator|=
name|strtoul
argument_list|(
name|end
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'K'
operator|||
operator|*
name|end
operator|==
literal|'k'
condition|)
name|fs
operator|->
name|min_th
operator|*=
literal|1024
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|end
operator|=
name|strsep
argument_list|(
operator|&
name|av
index|[
literal|0
index|]
argument_list|,
literal|"/"
argument_list|)
operator|)
condition|)
block|{
name|fs
operator|->
name|max_th
operator|=
name|strtoul
argument_list|(
name|end
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'K'
operator|||
operator|*
name|end
operator|==
literal|'k'
condition|)
name|fs
operator|->
name|max_th
operator|*=
literal|1024
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|end
operator|=
name|strsep
argument_list|(
operator|&
name|av
index|[
literal|0
index|]
argument_list|,
literal|"/"
argument_list|)
operator|)
condition|)
block|{
name|double
name|max_p
init|=
name|strtod
argument_list|(
name|end
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|max_p
operator|>
literal|1
operator|||
name|max_p
operator|<=
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"0< max_p<= 1"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|max_p
operator|=
call|(
name|int
call|)
argument_list|(
name|max_p
operator|*
operator|(
literal|1
operator|<<
name|SCALE_RED
operator|)
argument_list|)
expr_stmt|;
block|}
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_DROPTAIL
case|:
name|NEED
argument_list|(
name|fs
argument_list|,
literal|"droptail is only for flowsets"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|flags
operator|&=
operator|~
operator|(
name|DN_IS_RED
operator||
name|DN_IS_GENTLE_RED
operator|)
expr_stmt|;
break|break;
case|case
name|TOK_BW
case|:
name|NEED
argument_list|(
name|p
argument_list|,
literal|"bw is only for links"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"bw needs bandwidth or interface\n"
argument_list|)
expr_stmt|;
name|read_bandwidth
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|p
operator|->
name|bandwidth
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_DELAY
case|:
name|NEED
argument_list|(
name|p
argument_list|,
literal|"delay is only for links"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"delay needs argument 0..10000ms\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|delay
operator|=
name|strtoul
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_TYPE
case|:
block|{
name|int
name|l
decl_stmt|;
name|NEED
argument_list|(
name|sch
argument_list|,
literal|"type is only for schedulers"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"type needs a string"
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
operator|||
name|l
operator|>
literal|15
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"type %s too long\n"
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sch
operator|->
name|name
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sch
operator|->
name|oid
operator|.
name|subtype
operator|=
literal|0
expr_stmt|;
comment|/* use string */
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|TOK_WEIGHT
case|:
name|NEED
argument_list|(
name|fs
argument_list|,
literal|"weight is only for flowsets"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"weight needs argument\n"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|par
index|[
literal|0
index|]
operator|=
name|strtol
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_LMAX
case|:
name|NEED
argument_list|(
name|fs
argument_list|,
literal|"lmax is only for flowsets"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"lmax needs argument\n"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|par
index|[
literal|1
index|]
operator|=
name|strtol
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_PRI
case|:
name|NEED
argument_list|(
name|fs
argument_list|,
literal|"priority is only for flowsets"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"priority needs argument\n"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|par
index|[
literal|2
index|]
operator|=
name|strtol
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_SCHED
case|:
case|case
name|TOK_PIPE
case|:
name|NEED
argument_list|(
name|fs
argument_list|,
literal|"pipe/sched"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"pipe/link/sched needs number\n"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|sched_nr
operator|=
name|strtoul
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_PROFILE
case|:
name|NEED
argument_list|(
operator|(
operator|!
name|pf
operator|)
argument_list|,
literal|"profile already set"
argument_list|)
expr_stmt|;
name|NEED
argument_list|(
name|p
argument_list|,
literal|"profile"
argument_list|)
expr_stmt|;
block|{
name|NEED1
argument_list|(
literal|"extra delay needs the file name\n"
argument_list|)
expr_stmt|;
name|pf
operator|=
name|o_next
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pf
argument_list|)
argument_list|,
name|DN_PROFILE
argument_list|)
expr_stmt|;
name|load_extra_delays
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
name|pf
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|//XXX can't fail?
operator|--
name|ac
expr_stmt|;
operator|++
name|av
expr_stmt|;
block|}
break|break;
case|case
name|TOK_BURST
case|:
name|NEED
argument_list|(
name|p
argument_list|,
literal|"burst"
argument_list|)
expr_stmt|;
name|NEED1
argument_list|(
literal|"burst needs argument\n"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expand_number
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|(
name|int64_t
operator|*
operator|)
operator|&
name|p
operator|->
name|burst
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
name|errno
operator|!=
name|ERANGE
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"burst: invalid argument"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
name|p
operator|->
name|burst
operator|>
operator|(
literal|1ULL
operator|<<
literal|48
operator|)
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"burst: out of range (0..2^48-1)"
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"unrecognised option ``%s''"
argument_list|,
name|av
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check validity of parameters */
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|delay
operator|>
literal|10000
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"delay must be< 10000"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bandwidth
operator|==
operator|-
literal|1
condition|)
name|p
operator|->
name|bandwidth
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fs
condition|)
block|{
comment|/* XXX accept a 0 scheduler to keep the default */
if|if
condition|(
name|fs
operator|->
name|flags
operator|&
name|DN_QSIZE_BYTES
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|long
name|limit
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"net.inet.ip.dummynet.pipe_byte_limit"
argument_list|,
operator|&
name|limit
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|limit
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|qsize
operator|>
name|limit
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"queue size must be< %ldB"
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|len
decl_stmt|;
name|long
name|limit
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"net.inet.ip.dummynet.pipe_slot_limit"
argument_list|,
operator|&
name|limit
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|limit
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|qsize
operator|>
name|limit
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"2<= queue size<= %ld"
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|->
name|flags
operator|&
name|DN_IS_RED
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|int
name|lookup_depth
decl_stmt|,
name|avg_pkt_size
decl_stmt|;
name|double
name|w_q
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|min_th
operator|>=
name|fs
operator|->
name|max_th
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"min_th %d must be< than max_th %d"
argument_list|,
name|fs
operator|->
name|min_th
argument_list|,
name|fs
operator|->
name|max_th
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|max_th
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"max_th must be> 0"
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"net.inet.ip.dummynet.red_lookup_depth"
argument_list|,
operator|&
name|lookup_depth
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|lookup_depth
operator|=
literal|256
expr_stmt|;
if|if
condition|(
name|lookup_depth
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"net.inet.ip.dummynet.red_lookup_depth"
literal|" must be greater than zero"
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"net.inet.ip.dummynet.red_avg_pkt_size"
argument_list|,
operator|&
name|avg_pkt_size
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|avg_pkt_size
operator|=
literal|512
expr_stmt|;
if|if
condition|(
name|avg_pkt_size
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"net.inet.ip.dummynet.red_avg_pkt_size must"
literal|" be greater than zero"
argument_list|)
expr_stmt|;
comment|/* 		 * Ticks needed for sending a medium-sized packet. 		 * Unfortunately, when we are configuring a WF2Q+ queue, we 		 * do not have bandwidth information, because that is stored 		 * in the parent pipe, and also we have multiple queues 		 * competing for it. So we set s=0, which is not very 		 * correct. But on the other hand, why do we want RED with 		 * WF2Q+ ? 		 */
if|#
directive|if
literal|0
block|if (p.bandwidth==0)
comment|/* this is a WF2Q+ queue */
block|s = 0; 		else 			s = (double)ck.hz * avg_pkt_size * 8 / p.bandwidth;
endif|#
directive|endif
comment|/* 		 * max idle time (in ticks) before avg queue size becomes 0. 		 * NOTA:  (3/w_q) is approx the value x so that 		 * (1-w_q)^x< 10^-3. 		 */
name|w_q
operator|=
operator|(
operator|(
name|double
operator|)
name|fs
operator|->
name|w_q
operator|)
operator|/
operator|(
literal|1
operator|<<
name|SCALE_RED
operator|)
expr_stmt|;
if|#
directive|if
literal|0
comment|// go in kernel
block|idle = s * 3. / w_q; 		fs->lookup_step = (int)idle / lookup_depth; 		if (!fs->lookup_step) 			fs->lookup_step = 1; 		weight = 1 - w_q; 		for (t = fs->lookup_step; t> 1; --t) 			weight *= 1 - w_q; 		fs->lookup_weight = (int)(weight * (1<< SCALE_RED));
endif|#
directive|endif
block|}
block|}
name|i
operator|=
name|do_cmd
argument_list|(
name|IP_DUMMYNET3
argument_list|,
name|base
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
operator|-
operator|(
name|char
operator|*
operator|)
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"setsockopt(%s)"
argument_list|,
literal|"IP_DUMMYNET_CONFIGURE"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dummynet_flush
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dn_id
name|oid
decl_stmt|;
name|oid_fill
argument_list|(
operator|&
name|oid
argument_list|,
sizeof|sizeof
argument_list|(
name|oid
argument_list|)
argument_list|,
name|DN_CMD_FLUSH
argument_list|,
name|DN_API_VERSION
argument_list|)
expr_stmt|;
name|do_cmd
argument_list|(
name|IP_DUMMYNET3
argument_list|,
operator|&
name|oid
argument_list|,
name|oid
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse input for 'ipfw [pipe|sched|queue] show [range list]'  * Returns the number of ranges, and possibly stores them  * in the array v of size len.  */
end_comment

begin_function
specifier|static
name|int
name|parse_range
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|,
name|uint32_t
modifier|*
name|v
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|uint32_t
name|base
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
operator|||
name|len
operator|<
literal|2
condition|)
block|{
name|v
operator|=
name|base
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
operator|*
name|av
init|;
name|s
operator|!=
name|NULL
condition|;
name|av
operator|++
operator|,
name|ac
operator|--
control|)
block|{
name|v
index|[
literal|0
index|]
operator|=
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|=
operator|(
operator|*
name|endptr
operator|!=
literal|'-'
operator|)
condition|?
name|v
index|[
literal|0
index|]
else|:
name|strtoul
argument_list|(
name|endptr
operator|+
literal|1
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|==
literal|'\0'
condition|)
block|{
comment|/* prepare for next round */
name|s
operator|=
operator|(
name|ac
operator|>
literal|0
operator|)
condition|?
operator|*
operator|(
name|av
operator|+
literal|1
operator|)
else|:
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|','
condition|)
block|{
name|warn
argument_list|(
literal|"invalid number: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
operator|++
name|endptr
expr_stmt|;
continue|continue;
block|}
comment|/* continue processing from here */
name|s
operator|=
operator|++
name|endptr
expr_stmt|;
name|ac
operator|++
expr_stmt|;
name|av
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|v
index|[
literal|1
index|]
operator|<
name|v
index|[
literal|0
index|]
operator|||
name|v
index|[
literal|1
index|]
operator|<
literal|0
operator|||
name|v
index|[
literal|1
index|]
operator|>=
name|DN_MAX_ID
operator|-
literal|1
operator|||
name|v
index|[
literal|0
index|]
operator|<
literal|0
operator|||
name|v
index|[
literal|1
index|]
operator|>=
name|DN_MAX_ID
operator|-
literal|1
condition|)
block|{
continue|continue;
comment|/* invalid entry */
block|}
name|n
operator|++
expr_stmt|;
comment|/* translate if 'pipe list' */
if|if
condition|(
name|co
operator|.
name|do_pipe
operator|==
literal|1
condition|)
block|{
name|v
index|[
literal|0
index|]
operator|+=
name|DN_MAX_ID
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|+=
name|DN_MAX_ID
expr_stmt|;
block|}
name|v
operator|=
operator|(
name|n
operator|*
literal|2
operator|<
name|len
operator|)
condition|?
name|v
operator|+
literal|2
else|:
name|base
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* main entry point for dummynet list functions. co.do_pipe indicates  * which function we want to support.  * av may contain filtering arguments, either individual entries  * or ranges, or lists (space or commas are valid separators).  * Format for a range can be n1-n2 or n3 n4 n5 ...  * In a range n1 must be<= n2, otherwise the range is ignored.  * A number 'n4' is translate in a range 'n4-n4'  * All number must be> 0 and< DN_MAX_ID-1  */
end_comment

begin_function
name|void
name|dummynet_list
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|,
name|int
name|show_counters
parameter_list|)
block|{
name|struct
name|dn_id
modifier|*
name|oid
decl_stmt|,
modifier|*
name|x
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|,
name|l
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* # of ranges */
name|int
name|buflen
decl_stmt|;
name|int
name|max_size
decl_stmt|;
comment|/* largest obj passed up */
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
comment|/* skip 'list' | 'show' word */
name|n
operator|=
name|parse_range
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Count # of ranges. */
comment|/* Allocate space to store ranges */
name|l
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|oid
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|n
operator|*
literal|2
expr_stmt|;
name|oid
operator|=
name|safe_calloc
argument_list|(
literal|1
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|oid_fill
argument_list|(
name|oid
argument_list|,
name|l
argument_list|,
name|DN_CMD_GET
argument_list|,
name|DN_API_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
comment|/* store ranges in idx */
name|parse_range
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|oid
operator|+
literal|1
operator|)
argument_list|,
name|n
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the size of the largest object returned. If the 	 * response leaves at least this much spare space in the 	 * buffer, then surely the response is complete; otherwise 	 * there might be a risk of truncation and we will need to 	 * retry with a larger buffer. 	 * XXX don't bother with smaller structs. 	 */
name|max_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_size
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dn_sch
argument_list|)
condition|)
name|max_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_sch
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_size
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dn_flow
argument_list|)
condition|)
name|max_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_flow
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|co
operator|.
name|do_pipe
condition|)
block|{
case|case
literal|1
case|:
name|oid
operator|->
name|subtype
operator|=
name|DN_LINK
expr_stmt|;
comment|/* list pipe */
break|break;
case|case
literal|2
case|:
name|oid
operator|->
name|subtype
operator|=
name|DN_FS
expr_stmt|;
comment|/* list queue */
break|break;
case|case
literal|3
case|:
name|oid
operator|->
name|subtype
operator|=
name|DN_SCH
expr_stmt|;
comment|/* list sched */
break|break;
block|}
comment|/* 	 * Ask the kernel an estimate of the required space (result 	 * in oid.id), unless we are requesting a subset of objects, 	 * in which case the kernel does not give an exact answer. 	 * In any case, space might grow in the meantime due to the 	 * creation of new queues, so we must be prepared to retry. 	 */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|buflen
operator|=
literal|4
operator|*
literal|1024
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|do_cmd
argument_list|(
operator|-
name|IP_DUMMYNET3
argument_list|,
name|oid
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
operator|||
name|oid
operator|->
name|id
operator|<=
sizeof|sizeof
argument_list|(
operator|*
name|oid
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|buflen
operator|=
name|oid
operator|->
name|id
operator|+
name|max_size
expr_stmt|;
name|oid
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|oid
argument_list|)
expr_stmt|;
comment|/* restore */
block|}
comment|/* Try a few times, until the buffer fits */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
name|buflen
expr_stmt|;
name|x
operator|=
name|safe_realloc
argument_list|(
name|x
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|oid
argument_list|,
name|x
argument_list|,
name|oid
operator|->
name|len
argument_list|)
expr_stmt|;
name|ret
operator|=
name|do_cmd
argument_list|(
operator|-
name|IP_DUMMYNET3
argument_list|,
name|x
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
operator|||
name|x
operator|->
name|id
operator|<=
sizeof|sizeof
argument_list|(
operator|*
name|oid
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* no response */
if|if
condition|(
name|l
operator|+
name|max_size
operator|<=
name|buflen
condition|)
break|break;
comment|/* ok */
name|buflen
operator|*=
literal|2
expr_stmt|;
comment|/* double for next attempt */
block|}
name|list_pipes
argument_list|(
name|x
argument_list|,
name|O_NEXT
argument_list|(
name|x
argument_list|,
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|x
condition|)
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oid
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

