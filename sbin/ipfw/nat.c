begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2003 Luigi Rizzo  * Copyright (c) 1996 Alex Nash, Paul Traina, Poul-Henning Kamp  * Copyright (c) 1994 Ugen J.S.Antsilevich  *  * Idea and grammar partially left from:  * Copyright (c) 1993 Daniel Boulet  *  * Redistribution and use in source forms, with and without modification,  * are permitted provided that this entire comment appears intact.  *  * Redistribution in binary form may occur without any restrictions.  * Obviously, it would be nice if you gave credit where credit is due  * but requiring it would be too onerous.  *  * This software is provided ``AS IS'' without any warranties of any kind.  *  * NEW command line interface for IP firewall facility  *  * $FreeBSD$  *  * In-kernel nat support  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|"ipfw2.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_define
define|#
directive|define
name|IPFW_INTERNAL
end_define

begin_comment
comment|/* Access to protected structures in ip_fw.h. */
end_comment

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_comment
comment|/* def. of struct route */
end_comment

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<alias.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|_s_x
name|nat_params
index|[]
init|=
block|{
block|{
literal|"ip"
block|,
name|TOK_IP
block|}
block|,
block|{
literal|"if"
block|,
name|TOK_IF
block|}
block|,
block|{
literal|"log"
block|,
name|TOK_ALOG
block|}
block|,
block|{
literal|"deny_in"
block|,
name|TOK_DENY_INC
block|}
block|,
block|{
literal|"same_ports"
block|,
name|TOK_SAME_PORTS
block|}
block|,
block|{
literal|"unreg_only"
block|,
name|TOK_UNREG_ONLY
block|}
block|,
block|{
literal|"skip_global"
block|,
name|TOK_SKIP_GLOBAL
block|}
block|,
block|{
literal|"reset"
block|,
name|TOK_RESET_ADDR
block|}
block|,
block|{
literal|"reverse"
block|,
name|TOK_ALIAS_REV
block|}
block|,
block|{
literal|"proxy_only"
block|,
name|TOK_PROXY_ONLY
block|}
block|,
block|{
literal|"redirect_addr"
block|,
name|TOK_REDIR_ADDR
block|}
block|,
block|{
literal|"redirect_port"
block|,
name|TOK_REDIR_PORT
block|}
block|,
block|{
literal|"redirect_proto"
block|,
name|TOK_REDIR_PROTO
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
comment|/* terminator */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Search for interface with name "ifn", and fill n accordingly:  *  * n->ip	ip address of interface "ifn"  * n->if_name   copy of interface name "ifn"  */
end_comment

begin_function
specifier|static
name|void
name|set_addr_dynamic
parameter_list|(
specifier|const
name|char
modifier|*
name|ifn
parameter_list|,
name|struct
name|cfg_nat
modifier|*
name|n
parameter_list|)
block|{
name|size_t
name|needed
decl_stmt|;
name|int
name|mib
index|[
literal|6
index|]
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|lim
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|if_msghdr
modifier|*
name|ifm
decl_stmt|;
name|struct
name|ifa_msghdr
modifier|*
name|ifam
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|int
name|ifIndex
decl_stmt|,
name|ifMTU
decl_stmt|;
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_NET
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|PF_ROUTE
expr_stmt|;
name|mib
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mib
index|[
literal|3
index|]
operator|=
name|AF_INET
expr_stmt|;
name|mib
index|[
literal|4
index|]
operator|=
name|NET_RT_IFLIST
expr_stmt|;
name|mib
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/*  * Get interface data.  */
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
name|NULL
argument_list|,
operator|&
name|needed
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"iflist-sysctl-estimate"
argument_list|)
expr_stmt|;
name|buf
operator|=
name|safe_calloc
argument_list|(
literal|1
argument_list|,
name|needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
name|buf
argument_list|,
operator|&
name|needed
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"iflist-sysctl-get"
argument_list|)
expr_stmt|;
name|lim
operator|=
name|buf
operator|+
name|needed
expr_stmt|;
comment|/*  * Loop through interfaces until one with  * given name is found. This is done to  * find correct interface index for routing  * message processing.  */
name|ifIndex
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|next
operator|<
name|lim
condition|)
block|{
name|ifm
operator|=
operator|(
expr|struct
name|if_msghdr
operator|*
operator|)
name|next
expr_stmt|;
name|next
operator|+=
name|ifm
operator|->
name|ifm_msglen
expr_stmt|;
if|if
condition|(
name|ifm
operator|->
name|ifm_version
operator|!=
name|RTM_VERSION
condition|)
block|{
if|if
condition|(
name|co
operator|.
name|verbose
condition|)
name|warnx
argument_list|(
literal|"routing message version %d "
literal|"not understood"
argument_list|,
name|ifm
operator|->
name|ifm_version
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ifm
operator|->
name|ifm_type
operator|==
name|RTM_IFINFO
condition|)
block|{
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|(
name|ifm
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|ifn
argument_list|)
operator|==
name|sdl
operator|->
name|sdl_nlen
operator|&&
name|strncmp
argument_list|(
name|ifn
argument_list|,
name|sdl
operator|->
name|sdl_data
argument_list|,
name|sdl
operator|->
name|sdl_nlen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ifIndex
operator|=
name|ifm
operator|->
name|ifm_index
expr_stmt|;
name|ifMTU
operator|=
name|ifm
operator|->
name|ifm_data
operator|.
name|ifi_mtu
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|ifIndex
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown interface name %s"
argument_list|,
name|ifn
argument_list|)
expr_stmt|;
comment|/*  * Get interface address.  */
name|sin
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|next
operator|<
name|lim
condition|)
block|{
name|ifam
operator|=
operator|(
expr|struct
name|ifa_msghdr
operator|*
operator|)
name|next
expr_stmt|;
name|next
operator|+=
name|ifam
operator|->
name|ifam_msglen
expr_stmt|;
if|if
condition|(
name|ifam
operator|->
name|ifam_version
operator|!=
name|RTM_VERSION
condition|)
block|{
if|if
condition|(
name|co
operator|.
name|verbose
condition|)
name|warnx
argument_list|(
literal|"routing message version %d "
literal|"not understood"
argument_list|,
name|ifam
operator|->
name|ifam_version
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ifam
operator|->
name|ifam_type
operator|!=
name|RTM_NEWADDR
condition|)
break|break;
if|if
condition|(
name|ifam
operator|->
name|ifam_addrs
operator|&
name|RTA_IFA
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ifam
operator|+
literal|1
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|RTA_IFA
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|ifam
operator|->
name|ifam_addrs
operator|&
name|i
condition|)
name|cp
operator|+=
name|SA_SIZE
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|cp
operator|)
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|cp
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: cannot get interface address"
argument_list|,
name|ifn
argument_list|)
expr_stmt|;
name|n
operator|->
name|ip
operator|=
name|sin
operator|->
name|sin_addr
expr_stmt|;
name|strncpy
argument_list|(
name|n
operator|->
name|if_name
argument_list|,
name|ifn
argument_list|,
name|IF_NAMESIZE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX - The following functions, macros and definitions come from natd.c:  * it would be better to move them outside natd.c, in a file  * (redirect_support.[ch]?) shared by ipfw and natd, but for now i can live  * with it.  */
end_comment

begin_comment
comment|/*  * Definition of a port range, and macros to deal with values.  * FORMAT:  HI 16-bits == first port in range, 0 == all ports.  *	  LO 16-bits == number of ports in range  * NOTES:   - Port values are not stored in network byte order.  */
end_comment

begin_define
define|#
directive|define
name|port_range
value|u_long
end_define

begin_define
define|#
directive|define
name|GETLOPORT
parameter_list|(
name|x
parameter_list|)
value|((x)>> 0x10)
end_define

begin_define
define|#
directive|define
name|GETNUMPORTS
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x0000ffff)
end_define

begin_define
define|#
directive|define
name|GETHIPORT
parameter_list|(
name|x
parameter_list|)
value|(GETLOPORT((x)) + GETNUMPORTS((x)))
end_define

begin_comment
comment|/* Set y to be the low-port value in port_range variable x. */
end_comment

begin_define
define|#
directive|define
name|SETLOPORT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) = ((x)& 0x0000ffff) | ((y)<< 0x10))
end_define

begin_comment
comment|/* Set y to be the number of ports in port_range variable x. */
end_comment

begin_define
define|#
directive|define
name|SETNUMPORTS
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) = ((x)& 0xffff0000) | (y))
end_define

begin_function
specifier|static
name|void
name|StrToAddr
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
name|inet_aton
argument_list|(
name|str
argument_list|,
name|addr
argument_list|)
condition|)
return|return;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown host %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|addr
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|StrToPortRange
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|proto
parameter_list|,
name|port_range
modifier|*
name|portRange
parameter_list|)
block|{
name|char
modifier|*
name|sep
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|u_short
name|loPort
decl_stmt|;
name|u_short
name|hiPort
decl_stmt|;
comment|/* First see if this is a service, return corresponding port if so. */
name|sp
operator|=
name|getservbyname
argument_list|(
name|str
argument_list|,
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
name|SETLOPORT
argument_list|(
operator|*
name|portRange
argument_list|,
name|ntohs
argument_list|(
name|sp
operator|->
name|s_port
argument_list|)
argument_list|)
expr_stmt|;
name|SETNUMPORTS
argument_list|(
operator|*
name|portRange
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Not a service, see if it's a single port or port range. */
name|sep
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|==
name|NULL
condition|)
block|{
name|SETLOPORT
argument_list|(
operator|*
name|portRange
argument_list|,
name|strtol
argument_list|(
name|str
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|str
condition|)
block|{
comment|/* Single port. */
name|SETNUMPORTS
argument_list|(
operator|*
name|portRange
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Error in port range field. */
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"%s/%s: unknown service"
argument_list|,
name|str
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
comment|/* Port range, get the values and sanity check. */
name|sscanf
argument_list|(
name|str
argument_list|,
literal|"%hu-%hu"
argument_list|,
operator|&
name|loPort
argument_list|,
operator|&
name|hiPort
argument_list|)
expr_stmt|;
name|SETLOPORT
argument_list|(
operator|*
name|portRange
argument_list|,
name|loPort
argument_list|)
expr_stmt|;
name|SETNUMPORTS
argument_list|(
operator|*
name|portRange
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Error by default */
if|if
condition|(
name|loPort
operator|<=
name|hiPort
condition|)
name|SETNUMPORTS
argument_list|(
operator|*
name|portRange
argument_list|,
name|hiPort
operator|-
name|loPort
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GETNUMPORTS
argument_list|(
operator|*
name|portRange
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid port range %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|StrToProto
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"tcp"
argument_list|)
condition|)
return|return
name|IPPROTO_TCP
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"udp"
argument_list|)
condition|)
return|return
name|IPPROTO_UDP
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"sctp"
argument_list|)
condition|)
return|return
name|IPPROTO_SCTP
return|;
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"unknown protocol %s. Expected sctp, tcp or udp"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|StrToAddrAndPortRange
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|,
name|char
modifier|*
name|proto
parameter_list|,
name|port_range
modifier|*
name|portRange
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"%s is missing port number"
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
name|StrToAddr
argument_list|(
name|str
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|StrToPortRange
argument_list|(
name|ptr
argument_list|,
name|proto
argument_list|,
name|portRange
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* End of stuff taken from natd.c. */
end_comment

begin_comment
comment|/*  * The next 3 functions add support for the addr, port and proto redirect and  * their logic is loosely based on SetupAddressRedirect(), SetupPortRedirect()  * and SetupProtoRedirect() from natd.c.  *  * Every setup_* function fills at least one redirect entry  * (struct cfg_redir) and zero or more server pool entry (struct cfg_spool)  * in buf.  *  * The format of data in buf is:  *  *     cfg_nat    cfg_redir    cfg_spool    ......  cfg_spool  *  *    -------------------------------------        ------------  *   |          | .....X ... |          |         |           |  .....  *    ------------------------------------- ...... ------------  *                     ^  *                spool_cnt       n=0       ......   n=(X-1)  *  * len points to the amount of available space in buf  * space counts the memory consumed by every function  *  * XXX - Every function get all the argv params so it  * has to check, in optional parameters, that the next  * args is a valid option for the redir entry and not  * another token. Only redir_port and redir_proto are  * affected by this.  */
end_comment

begin_function
specifier|static
name|int
name|estimate_redir_addr
parameter_list|(
name|int
modifier|*
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|size_t
name|space
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_redir
argument_list|)
decl_stmt|;
name|char
modifier|*
name|sep
init|=
operator|*
operator|*
name|av
decl_stmt|;
name|u_int
name|c
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|sep
operator|=
name|strchr
argument_list|(
name|sep
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|c
operator|++
expr_stmt|;
name|sep
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>
literal|0
condition|)
name|c
operator|++
expr_stmt|;
name|space
operator|+=
name|c
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_spool
argument_list|)
expr_stmt|;
return|return
operator|(
name|space
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setup_redir_addr
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|struct
name|cfg_redir
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|sep
decl_stmt|;
name|size_t
name|space
decl_stmt|;
name|r
operator|=
operator|(
expr|struct
name|cfg_redir
operator|*
operator|)
name|buf
expr_stmt|;
name|r
operator|->
name|mode
operator|=
name|REDIR_ADDR
expr_stmt|;
comment|/* Skip cfg_redir at beginning of buf. */
name|buf
operator|=
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_redir
argument_list|)
index|]
expr_stmt|;
name|space
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_redir
argument_list|)
expr_stmt|;
comment|/* Extract local address. */
if|if
condition|(
operator|(
name|sep
operator|=
name|strtok
argument_list|(
operator|*
operator|*
name|av
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|cfg_spool
modifier|*
name|spool
decl_stmt|;
comment|/* Setup LSNAT server pool. */
name|r
operator|->
name|laddr
operator|.
name|s_addr
operator|=
name|INADDR_NONE
expr_stmt|;
while|while
condition|(
name|sep
operator|!=
name|NULL
condition|)
block|{
name|spool
operator|=
operator|(
expr|struct
name|cfg_spool
operator|*
operator|)
name|buf
expr_stmt|;
name|space
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_spool
argument_list|)
expr_stmt|;
name|StrToAddr
argument_list|(
name|sep
argument_list|,
operator|&
name|spool
operator|->
name|addr
argument_list|)
expr_stmt|;
name|spool
operator|->
name|port
operator|=
operator|~
literal|0
expr_stmt|;
name|r
operator|->
name|spool_cnt
operator|++
expr_stmt|;
comment|/* Point to the next possible cfg_spool. */
name|buf
operator|=
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_spool
argument_list|)
index|]
expr_stmt|;
name|sep
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|StrToAddr
argument_list|(
operator|*
operator|*
name|av
argument_list|,
operator|&
name|r
operator|->
name|laddr
argument_list|)
expr_stmt|;
operator|(
operator|*
name|av
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|ac
operator|)
operator|--
expr_stmt|;
comment|/* Extract public address. */
name|StrToAddr
argument_list|(
operator|*
operator|*
name|av
argument_list|,
operator|&
name|r
operator|->
name|paddr
argument_list|)
expr_stmt|;
operator|(
operator|*
name|av
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|ac
operator|)
operator|--
expr_stmt|;
return|return
operator|(
name|space
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|estimate_redir_port
parameter_list|(
name|int
modifier|*
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|size_t
name|space
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_redir
argument_list|)
decl_stmt|;
name|char
modifier|*
name|sep
init|=
operator|*
operator|*
name|av
decl_stmt|;
name|u_int
name|c
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|sep
operator|=
name|strchr
argument_list|(
name|sep
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|c
operator|++
expr_stmt|;
name|sep
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>
literal|0
condition|)
name|c
operator|++
expr_stmt|;
name|space
operator|+=
name|c
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_spool
argument_list|)
expr_stmt|;
return|return
operator|(
name|space
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setup_redir_port
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|struct
name|cfg_redir
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|sep
decl_stmt|,
modifier|*
name|protoName
decl_stmt|,
modifier|*
name|lsnat
init|=
name|NULL
decl_stmt|;
name|size_t
name|space
decl_stmt|;
name|u_short
name|numLocalPorts
decl_stmt|;
name|port_range
name|portRange
decl_stmt|;
name|numLocalPorts
operator|=
literal|0
expr_stmt|;
name|r
operator|=
operator|(
expr|struct
name|cfg_redir
operator|*
operator|)
name|buf
expr_stmt|;
name|r
operator|->
name|mode
operator|=
name|REDIR_PORT
expr_stmt|;
comment|/* Skip cfg_redir at beginning of buf. */
name|buf
operator|=
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_redir
argument_list|)
index|]
expr_stmt|;
name|space
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_redir
argument_list|)
expr_stmt|;
comment|/* 	 * Extract protocol. 	 */
name|r
operator|->
name|proto
operator|=
name|StrToProto
argument_list|(
operator|*
operator|*
name|av
argument_list|)
expr_stmt|;
name|protoName
operator|=
operator|*
operator|*
name|av
expr_stmt|;
operator|(
operator|*
name|av
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|ac
operator|)
operator|--
expr_stmt|;
comment|/* 	 * Extract local address. 	 */
if|if
condition|(
operator|(
name|sep
operator|=
name|strchr
argument_list|(
operator|*
operator|*
name|av
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|r
operator|->
name|laddr
operator|.
name|s_addr
operator|=
name|INADDR_NONE
expr_stmt|;
name|r
operator|->
name|lport
operator|=
operator|~
literal|0
expr_stmt|;
name|numLocalPorts
operator|=
literal|1
expr_stmt|;
name|lsnat
operator|=
operator|*
operator|*
name|av
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The sctp nat does not allow the port numbers to be mapped to 		 * new port numbers. Therefore, no ports are to be specified 		 * in the target port field. 		 */
if|if
condition|(
name|r
operator|->
name|proto
operator|==
name|IPPROTO_SCTP
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
operator|*
operator|*
name|av
argument_list|,
literal|':'
argument_list|)
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"redirect_port:"
literal|"port numbers do not change in sctp, so do "
literal|"not specify them as part of the target"
argument_list|)
expr_stmt|;
else|else
name|StrToAddr
argument_list|(
operator|*
operator|*
name|av
argument_list|,
operator|&
name|r
operator|->
name|laddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|StrToAddrAndPortRange
argument_list|(
operator|*
operator|*
name|av
argument_list|,
operator|&
name|r
operator|->
name|laddr
argument_list|,
name|protoName
argument_list|,
operator|&
name|portRange
argument_list|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"redirect_port: "
literal|"invalid local port range"
argument_list|)
expr_stmt|;
name|r
operator|->
name|lport
operator|=
name|GETLOPORT
argument_list|(
name|portRange
argument_list|)
expr_stmt|;
name|numLocalPorts
operator|=
name|GETNUMPORTS
argument_list|(
name|portRange
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
operator|*
name|av
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|ac
operator|)
operator|--
expr_stmt|;
comment|/* 	 * Extract public port and optionally address. 	 */
if|if
condition|(
operator|(
name|sep
operator|=
name|strchr
argument_list|(
operator|*
operator|*
name|av
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|StrToAddrAndPortRange
argument_list|(
operator|*
operator|*
name|av
argument_list|,
operator|&
name|r
operator|->
name|paddr
argument_list|,
name|protoName
argument_list|,
operator|&
name|portRange
argument_list|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"redirect_port: "
literal|"invalid public port range"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|paddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
name|StrToPortRange
argument_list|(
operator|*
operator|*
name|av
argument_list|,
name|protoName
argument_list|,
operator|&
name|portRange
argument_list|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"redirect_port: "
literal|"invalid public port range"
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|pport
operator|=
name|GETLOPORT
argument_list|(
name|portRange
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|proto
operator|==
name|IPPROTO_SCTP
condition|)
block|{
comment|/* so the logic below still works */
name|numLocalPorts
operator|=
name|GETNUMPORTS
argument_list|(
name|portRange
argument_list|)
expr_stmt|;
name|r
operator|->
name|lport
operator|=
name|r
operator|->
name|pport
expr_stmt|;
block|}
name|r
operator|->
name|pport_cnt
operator|=
name|GETNUMPORTS
argument_list|(
name|portRange
argument_list|)
expr_stmt|;
operator|(
operator|*
name|av
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|ac
operator|)
operator|--
expr_stmt|;
comment|/* 	 * Extract remote address and optionally port. 	 */
comment|/* 	 * NB: isdigit(**av) => we've to check that next parameter is really an 	 * option for this redirect entry, else stop here processing arg[cv]. 	 */
if|if
condition|(
operator|*
name|ac
operator|!=
literal|0
operator|&&
name|isdigit
argument_list|(
operator|*
operator|*
operator|*
name|av
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|sep
operator|=
name|strchr
argument_list|(
operator|*
operator|*
name|av
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|StrToAddrAndPortRange
argument_list|(
operator|*
operator|*
name|av
argument_list|,
operator|&
name|r
operator|->
name|raddr
argument_list|,
name|protoName
argument_list|,
operator|&
name|portRange
argument_list|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"redirect_port: "
literal|"invalid remote port range"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SETLOPORT
argument_list|(
name|portRange
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SETNUMPORTS
argument_list|(
name|portRange
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|StrToAddr
argument_list|(
operator|*
operator|*
name|av
argument_list|,
operator|&
name|r
operator|->
name|raddr
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|av
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|ac
operator|)
operator|--
expr_stmt|;
block|}
else|else
block|{
name|SETLOPORT
argument_list|(
name|portRange
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SETNUMPORTS
argument_list|(
name|portRange
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|raddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
block|}
name|r
operator|->
name|rport
operator|=
name|GETLOPORT
argument_list|(
name|portRange
argument_list|)
expr_stmt|;
name|r
operator|->
name|rport_cnt
operator|=
name|GETNUMPORTS
argument_list|(
name|portRange
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure port ranges match up, then add the redirect ports. 	 */
if|if
condition|(
name|numLocalPorts
operator|!=
name|r
operator|->
name|pport_cnt
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"redirect_port: "
literal|"port ranges must be equal in size"
argument_list|)
expr_stmt|;
comment|/* Remote port range is allowed to be '0' which means all ports. */
if|if
condition|(
name|r
operator|->
name|rport_cnt
operator|!=
name|numLocalPorts
operator|&&
operator|(
name|r
operator|->
name|rport_cnt
operator|!=
literal|1
operator|||
name|r
operator|->
name|rport
operator|!=
literal|0
operator|)
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"redirect_port: remote port must"
literal|"be 0 or equal to local port range in size"
argument_list|)
expr_stmt|;
comment|/* Setup LSNAT server pool. */
if|if
condition|(
name|lsnat
operator|!=
name|NULL
condition|)
block|{
name|struct
name|cfg_spool
modifier|*
name|spool
decl_stmt|;
name|sep
operator|=
name|strtok
argument_list|(
name|lsnat
argument_list|,
literal|","
argument_list|)
expr_stmt|;
while|while
condition|(
name|sep
operator|!=
name|NULL
condition|)
block|{
name|spool
operator|=
operator|(
expr|struct
name|cfg_spool
operator|*
operator|)
name|buf
expr_stmt|;
name|space
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_spool
argument_list|)
expr_stmt|;
comment|/* 			 * The sctp nat does not allow the port numbers to 			 * be mapped to new port numbers. Therefore, no ports 			 * are to be specified in the target port field. 			 */
if|if
condition|(
name|r
operator|->
name|proto
operator|==
name|IPPROTO_SCTP
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|sep
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"redirect_port:"
literal|"port numbers do not change in "
literal|"sctp, so do not specify them as "
literal|"part of the target"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|StrToAddr
argument_list|(
name|sep
argument_list|,
operator|&
name|spool
operator|->
name|addr
argument_list|)
expr_stmt|;
name|spool
operator|->
name|port
operator|=
name|r
operator|->
name|pport
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|StrToAddrAndPortRange
argument_list|(
name|sep
argument_list|,
operator|&
name|spool
operator|->
name|addr
argument_list|,
name|protoName
argument_list|,
operator|&
name|portRange
argument_list|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"redirect_port:"
literal|"invalid local port range"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GETNUMPORTS
argument_list|(
name|portRange
argument_list|)
operator|!=
literal|1
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"redirect_port: "
literal|"local port must be single in "
literal|"this context"
argument_list|)
expr_stmt|;
name|spool
operator|->
name|port
operator|=
name|GETLOPORT
argument_list|(
name|portRange
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|spool_cnt
operator|++
expr_stmt|;
comment|/* Point to the next possible cfg_spool. */
name|buf
operator|=
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_spool
argument_list|)
index|]
expr_stmt|;
name|sep
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|space
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setup_redir_proto
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|struct
name|cfg_redir
modifier|*
name|r
decl_stmt|;
name|struct
name|protoent
modifier|*
name|protoent
decl_stmt|;
name|size_t
name|space
decl_stmt|;
name|r
operator|=
operator|(
expr|struct
name|cfg_redir
operator|*
operator|)
name|buf
expr_stmt|;
name|r
operator|->
name|mode
operator|=
name|REDIR_PROTO
expr_stmt|;
comment|/* Skip cfg_redir at beginning of buf. */
name|buf
operator|=
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_redir
argument_list|)
index|]
expr_stmt|;
name|space
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_redir
argument_list|)
expr_stmt|;
comment|/* 	 * Extract protocol. 	 */
name|protoent
operator|=
name|getprotobyname
argument_list|(
operator|*
operator|*
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|protoent
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"redirect_proto: unknown protocol %s"
argument_list|,
operator|*
operator|*
name|av
argument_list|)
expr_stmt|;
else|else
name|r
operator|->
name|proto
operator|=
name|protoent
operator|->
name|p_proto
expr_stmt|;
operator|(
operator|*
name|av
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|ac
operator|)
operator|--
expr_stmt|;
comment|/* 	 * Extract local address. 	 */
name|StrToAddr
argument_list|(
operator|*
operator|*
name|av
argument_list|,
operator|&
name|r
operator|->
name|laddr
argument_list|)
expr_stmt|;
operator|(
operator|*
name|av
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|ac
operator|)
operator|--
expr_stmt|;
comment|/* 	 * Extract optional public address. 	 */
if|if
condition|(
operator|*
name|ac
operator|==
literal|0
condition|)
block|{
name|r
operator|->
name|paddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|r
operator|->
name|raddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
block|}
else|else
block|{
comment|/* see above in setup_redir_port() */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
operator|*
name|av
argument_list|)
condition|)
block|{
name|StrToAddr
argument_list|(
operator|*
operator|*
name|av
argument_list|,
operator|&
name|r
operator|->
name|paddr
argument_list|)
expr_stmt|;
operator|(
operator|*
name|av
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|ac
operator|)
operator|--
expr_stmt|;
comment|/* 			 * Extract optional remote address. 			 */
comment|/* see above in setup_redir_port() */
if|if
condition|(
operator|*
name|ac
operator|!=
literal|0
operator|&&
name|isdigit
argument_list|(
operator|*
operator|*
operator|*
name|av
argument_list|)
condition|)
block|{
name|StrToAddr
argument_list|(
operator|*
operator|*
name|av
argument_list|,
operator|&
name|r
operator|->
name|raddr
argument_list|)
expr_stmt|;
operator|(
operator|*
name|av
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|ac
operator|)
operator|--
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|space
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_nat_config
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|cfg_nat
modifier|*
name|n
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cnt
decl_stmt|,
name|flag
decl_stmt|,
name|off
decl_stmt|;
name|struct
name|cfg_redir
modifier|*
name|t
decl_stmt|;
name|struct
name|cfg_spool
modifier|*
name|s
decl_stmt|;
name|struct
name|protoent
modifier|*
name|p
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|cfg_nat
operator|*
operator|)
name|buf
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
name|off
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ipfw nat %u config"
argument_list|,
name|n
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|n
operator|->
name|if_name
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" if %s"
argument_list|,
name|n
operator|->
name|if_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|->
name|ip
operator|.
name|s_addr
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" ip %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|n
operator|->
name|ip
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|->
name|mode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|mode
operator|&
name|PKT_ALIAS_LOG
condition|)
block|{
name|printf
argument_list|(
literal|" log"
argument_list|)
expr_stmt|;
name|n
operator|->
name|mode
operator|&=
operator|~
name|PKT_ALIAS_LOG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|mode
operator|&
name|PKT_ALIAS_DENY_INCOMING
condition|)
block|{
name|printf
argument_list|(
literal|" deny_in"
argument_list|)
expr_stmt|;
name|n
operator|->
name|mode
operator|&=
operator|~
name|PKT_ALIAS_DENY_INCOMING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|mode
operator|&
name|PKT_ALIAS_SAME_PORTS
condition|)
block|{
name|printf
argument_list|(
literal|" same_ports"
argument_list|)
expr_stmt|;
name|n
operator|->
name|mode
operator|&=
operator|~
name|PKT_ALIAS_SAME_PORTS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|mode
operator|&
name|PKT_ALIAS_SKIP_GLOBAL
condition|)
block|{
name|printf
argument_list|(
literal|" skip_global"
argument_list|)
expr_stmt|;
name|n
operator|->
name|mode
operator|&=
operator|~
name|PKT_ALIAS_SKIP_GLOBAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|mode
operator|&
name|PKT_ALIAS_UNREGISTERED_ONLY
condition|)
block|{
name|printf
argument_list|(
literal|" unreg_only"
argument_list|)
expr_stmt|;
name|n
operator|->
name|mode
operator|&=
operator|~
name|PKT_ALIAS_UNREGISTERED_ONLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|mode
operator|&
name|PKT_ALIAS_RESET_ON_ADDR_CHANGE
condition|)
block|{
name|printf
argument_list|(
literal|" reset"
argument_list|)
expr_stmt|;
name|n
operator|->
name|mode
operator|&=
operator|~
name|PKT_ALIAS_RESET_ON_ADDR_CHANGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|mode
operator|&
name|PKT_ALIAS_REVERSE
condition|)
block|{
name|printf
argument_list|(
literal|" reverse"
argument_list|)
expr_stmt|;
name|n
operator|->
name|mode
operator|&=
operator|~
name|PKT_ALIAS_REVERSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|mode
operator|&
name|PKT_ALIAS_PROXY_ONLY
condition|)
block|{
name|printf
argument_list|(
literal|" proxy_only"
argument_list|)
expr_stmt|;
name|n
operator|->
name|mode
operator|&=
operator|~
name|PKT_ALIAS_PROXY_ONLY
expr_stmt|;
block|}
block|}
comment|/* Print all the redirect's data configuration. */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|n
operator|->
name|redir_cnt
condition|;
name|cnt
operator|++
control|)
block|{
name|t
operator|=
operator|(
expr|struct
name|cfg_redir
operator|*
operator|)
operator|&
name|buf
index|[
name|off
index|]
expr_stmt|;
name|off
operator|+=
name|SOF_REDIR
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|mode
condition|)
block|{
case|case
name|REDIR_ADDR
case|:
name|printf
argument_list|(
literal|" redirect_addr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|spool_cnt
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|t
operator|->
name|laddr
argument_list|)
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|spool_cnt
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|(
expr|struct
name|cfg_spool
operator|*
operator|)
operator|&
name|buf
index|[
name|off
index|]
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|s
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|+=
name|SOF_SPOOL
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|t
operator|->
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REDIR_PORT
case|:
name|p
operator|=
name|getprotobynumber
argument_list|(
name|t
operator|->
name|proto
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" redirect_port %s "
argument_list|,
name|p
operator|->
name|p_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|spool_cnt
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%u"
argument_list|,
name|inet_ntoa
argument_list|(
name|t
operator|->
name|laddr
argument_list|)
argument_list|,
name|t
operator|->
name|lport
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|pport_cnt
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"-%u"
argument_list|,
name|t
operator|->
name|lport
operator|+
name|t
operator|->
name|pport_cnt
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|spool_cnt
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|(
expr|struct
name|cfg_spool
operator|*
operator|)
operator|&
name|buf
index|[
name|off
index|]
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%u"
argument_list|,
name|inet_ntoa
argument_list|(
name|s
operator|->
name|addr
argument_list|)
argument_list|,
name|s
operator|->
name|port
argument_list|)
expr_stmt|;
name|off
operator|+=
name|SOF_SPOOL
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|paddr
operator|.
name|s_addr
condition|)
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|inet_ntoa
argument_list|(
name|t
operator|->
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%u"
argument_list|,
name|t
operator|->
name|pport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|spool_cnt
operator|&&
name|t
operator|->
name|pport_cnt
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"-%u"
argument_list|,
name|t
operator|->
name|pport
operator|+
name|t
operator|->
name|pport_cnt
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|raddr
operator|.
name|s_addr
condition|)
block|{
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|t
operator|->
name|raddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|rport
condition|)
block|{
name|printf
argument_list|(
literal|":%u"
argument_list|,
name|t
operator|->
name|rport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|spool_cnt
operator|&&
name|t
operator|->
name|rport_cnt
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"-%u"
argument_list|,
name|t
operator|->
name|rport
operator|+
name|t
operator|->
name|rport_cnt
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|REDIR_PROTO
case|:
name|p
operator|=
name|getprotobynumber
argument_list|(
name|t
operator|->
name|proto
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" redirect_proto %s %s"
argument_list|,
name|p
operator|->
name|p_name
argument_list|,
name|inet_ntoa
argument_list|(
name|t
operator|->
name|laddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|paddr
operator|.
name|s_addr
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|t
operator|->
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|raddr
operator|.
name|s_addr
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|t
operator|->
name|raddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"unknown redir mode"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipfw_config_nat
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|struct
name|cfg_nat
modifier|*
name|n
decl_stmt|;
comment|/* Nat instance configuration. */
name|int
name|i
decl_stmt|,
name|off
decl_stmt|,
name|tok
decl_stmt|,
name|ac1
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|buf
decl_stmt|,
modifier|*
modifier|*
name|av1
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|av
operator|++
expr_stmt|;
name|ac
operator|--
expr_stmt|;
comment|/* Nat id. */
if|if
condition|(
name|ac
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"missing nat id"
argument_list|)
expr_stmt|;
name|id
operator|=
operator|*
name|av
expr_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|id
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
operator|*
name|end
operator|!=
literal|'\0'
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"illegal nat id: %s"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|av
operator|++
expr_stmt|;
name|ac
operator|--
expr_stmt|;
if|if
condition|(
name|ac
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"missing option"
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_nat
argument_list|)
expr_stmt|;
name|ac1
operator|=
name|ac
expr_stmt|;
name|av1
operator|=
name|av
expr_stmt|;
while|while
condition|(
name|ac1
operator|>
literal|0
condition|)
block|{
name|tok
operator|=
name|match_token
argument_list|(
name|nat_params
argument_list|,
operator|*
name|av1
argument_list|)
expr_stmt|;
name|ac1
operator|--
expr_stmt|;
name|av1
operator|++
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|TOK_IP
case|:
case|case
name|TOK_IF
case|:
name|ac1
operator|--
expr_stmt|;
name|av1
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_ALOG
case|:
case|case
name|TOK_DENY_INC
case|:
case|case
name|TOK_SAME_PORTS
case|:
case|case
name|TOK_SKIP_GLOBAL
case|:
case|case
name|TOK_UNREG_ONLY
case|:
case|case
name|TOK_RESET_ADDR
case|:
case|case
name|TOK_ALIAS_REV
case|:
case|case
name|TOK_PROXY_ONLY
case|:
break|break;
case|case
name|TOK_REDIR_ADDR
case|:
if|if
condition|(
name|ac1
operator|<
literal|2
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"redirect_addr: "
literal|"not enough arguments"
argument_list|)
expr_stmt|;
name|len
operator|+=
name|estimate_redir_addr
argument_list|(
operator|&
name|ac1
argument_list|,
operator|&
name|av1
argument_list|)
expr_stmt|;
name|av1
operator|+=
literal|2
expr_stmt|;
name|ac1
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
name|TOK_REDIR_PORT
case|:
if|if
condition|(
name|ac1
operator|<
literal|3
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"redirect_port: "
literal|"not enough arguments"
argument_list|)
expr_stmt|;
name|av1
operator|++
expr_stmt|;
name|ac1
operator|--
expr_stmt|;
name|len
operator|+=
name|estimate_redir_port
argument_list|(
operator|&
name|ac1
argument_list|,
operator|&
name|av1
argument_list|)
expr_stmt|;
name|av1
operator|+=
literal|2
expr_stmt|;
name|ac1
operator|-=
literal|2
expr_stmt|;
comment|/* Skip optional remoteIP/port */
if|if
condition|(
name|ac1
operator|!=
literal|0
operator|&&
name|isdigit
argument_list|(
operator|*
operator|*
name|av1
argument_list|)
condition|)
block|{
name|av1
operator|++
expr_stmt|;
name|ac1
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|TOK_REDIR_PROTO
case|:
if|if
condition|(
name|ac1
operator|<
literal|2
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"redirect_proto: "
literal|"not enough arguments"
argument_list|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_redir
argument_list|)
expr_stmt|;
name|av1
operator|+=
literal|2
expr_stmt|;
name|ac1
operator|-=
literal|2
expr_stmt|;
comment|/* Skip optional remoteIP/port */
if|if
condition|(
name|ac1
operator|!=
literal|0
operator|&&
name|isdigit
argument_list|(
operator|*
operator|*
name|av1
argument_list|)
condition|)
block|{
name|av1
operator|++
expr_stmt|;
name|ac1
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ac1
operator|!=
literal|0
operator|&&
name|isdigit
argument_list|(
operator|*
operator|*
name|av1
argument_list|)
condition|)
block|{
name|av1
operator|++
expr_stmt|;
name|ac1
operator|--
expr_stmt|;
block|}
break|break;
default|default:
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"unrecognised option ``%s''"
argument_list|,
name|av1
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_OSERR
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
comment|/* Offset in buf: save space for n at the beginning. */
name|off
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
expr|struct
name|cfg_nat
operator|*
operator|)
name|buf
expr_stmt|;
name|n
operator|->
name|id
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|ac
operator|>
literal|0
condition|)
block|{
name|tok
operator|=
name|match_token
argument_list|(
name|nat_params
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|TOK_IP
case|:
if|if
condition|(
name|ac
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"missing option"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
operator|(
name|n
operator|->
name|ip
operator|)
argument_list|)
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"bad ip address ``%s''"
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_IF
case|:
if|if
condition|(
name|ac
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"missing option"
argument_list|)
expr_stmt|;
name|set_addr_dynamic
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
break|break;
case|case
name|TOK_ALOG
case|:
name|n
operator|->
name|mode
operator||=
name|PKT_ALIAS_LOG
expr_stmt|;
break|break;
case|case
name|TOK_DENY_INC
case|:
name|n
operator|->
name|mode
operator||=
name|PKT_ALIAS_DENY_INCOMING
expr_stmt|;
break|break;
case|case
name|TOK_SAME_PORTS
case|:
name|n
operator|->
name|mode
operator||=
name|PKT_ALIAS_SAME_PORTS
expr_stmt|;
break|break;
case|case
name|TOK_UNREG_ONLY
case|:
name|n
operator|->
name|mode
operator||=
name|PKT_ALIAS_UNREGISTERED_ONLY
expr_stmt|;
break|break;
case|case
name|TOK_SKIP_GLOBAL
case|:
name|n
operator|->
name|mode
operator||=
name|PKT_ALIAS_SKIP_GLOBAL
expr_stmt|;
break|break;
case|case
name|TOK_RESET_ADDR
case|:
name|n
operator|->
name|mode
operator||=
name|PKT_ALIAS_RESET_ON_ADDR_CHANGE
expr_stmt|;
break|break;
case|case
name|TOK_ALIAS_REV
case|:
name|n
operator|->
name|mode
operator||=
name|PKT_ALIAS_REVERSE
expr_stmt|;
break|break;
case|case
name|TOK_PROXY_ONLY
case|:
name|n
operator|->
name|mode
operator||=
name|PKT_ALIAS_PROXY_ONLY
expr_stmt|;
break|break;
comment|/* 			 * All the setup_redir_* functions work directly in 			 * the final buffer, see above for details. 			 */
case|case
name|TOK_REDIR_ADDR
case|:
case|case
name|TOK_REDIR_PORT
case|:
case|case
name|TOK_REDIR_PROTO
case|:
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|TOK_REDIR_ADDR
case|:
name|i
operator|=
name|setup_redir_addr
argument_list|(
operator|&
name|buf
index|[
name|off
index|]
argument_list|,
operator|&
name|ac
argument_list|,
operator|&
name|av
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_REDIR_PORT
case|:
name|i
operator|=
name|setup_redir_port
argument_list|(
operator|&
name|buf
index|[
name|off
index|]
argument_list|,
operator|&
name|ac
argument_list|,
operator|&
name|av
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_REDIR_PROTO
case|:
name|i
operator|=
name|setup_redir_proto
argument_list|(
operator|&
name|buf
index|[
name|off
index|]
argument_list|,
operator|&
name|ac
argument_list|,
operator|&
name|av
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|->
name|redir_cnt
operator|++
expr_stmt|;
name|off
operator|+=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|i
operator|=
name|do_cmd
argument_list|(
name|IP_FW_NAT_CFG
argument_list|,
name|buf
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"setsockopt(%s)"
argument_list|,
literal|"IP_FW_NAT_CFG"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|co
operator|.
name|do_quiet
condition|)
block|{
comment|/* After every modification, we show the resultant rule. */
name|int
name|_ac
init|=
literal|3
decl_stmt|;
specifier|const
name|char
modifier|*
name|_av
index|[]
init|=
block|{
literal|"show"
block|,
literal|"config"
block|,
name|id
block|}
decl_stmt|;
name|ipfw_show_nat
argument_list|(
name|_ac
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|_av
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ipfw_show_nat
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|struct
name|cfg_nat
modifier|*
name|n
decl_stmt|;
name|struct
name|cfg_redir
modifier|*
name|e
decl_stmt|;
name|int
name|cmd
decl_stmt|,
name|i
decl_stmt|,
name|nbytes
decl_stmt|,
name|do_cfg
decl_stmt|,
name|do_rule
decl_stmt|,
name|frule
decl_stmt|,
name|lrule
decl_stmt|,
name|nalloc
decl_stmt|,
name|size
decl_stmt|;
name|int
name|nat_cnt
decl_stmt|,
name|redir_cnt
decl_stmt|,
name|r
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|;
name|do_rule
operator|=
literal|0
expr_stmt|;
name|nalloc
operator|=
literal|1024
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|data
operator|=
name|NULL
expr_stmt|;
name|frule
operator|=
literal|0
expr_stmt|;
name|lrule
operator|=
name|IPFW_DEFAULT_RULE
expr_stmt|;
comment|/* max ipfw rule number */
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
if|if
condition|(
name|co
operator|.
name|test_only
condition|)
return|return;
comment|/* Parse parameters. */
for|for
control|(
name|cmd
operator|=
name|IP_FW_NAT_GET_LOG
operator|,
name|do_cfg
operator|=
literal|0
init|;
name|ac
operator|!=
literal|0
condition|;
name|ac
operator|--
operator|,
name|av
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"config"
argument_list|,
name|strlen
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|cmd
operator|=
name|IP_FW_NAT_GET_CONFIG
operator|,
name|do_cfg
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Convert command line rule #. */
name|frule
operator|=
name|lrule
operator|=
name|strtoul
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|==
literal|'-'
condition|)
name|lrule
operator|=
name|strtoul
argument_list|(
name|endptr
operator|+
literal|1
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|lrule
operator|==
literal|0
condition|)
name|err
argument_list|(
name|EX_USAGE
argument_list|,
literal|"invalid rule number: %s"
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|do_rule
operator|=
literal|1
expr_stmt|;
block|}
name|nbytes
operator|=
name|nalloc
expr_stmt|;
while|while
condition|(
name|nbytes
operator|>=
name|nalloc
condition|)
block|{
name|nalloc
operator|=
name|nalloc
operator|*
literal|2
expr_stmt|;
name|nbytes
operator|=
name|nalloc
expr_stmt|;
name|data
operator|=
name|safe_realloc
argument_list|(
name|data
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_cmd
argument_list|(
name|cmd
argument_list|,
name|data
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
name|nbytes
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"getsockopt(IP_FW_GET_%s)"
argument_list|,
operator|(
name|cmd
operator|==
name|IP_FW_NAT_GET_LOG
operator|)
condition|?
literal|"LOG"
else|:
literal|"CONFIG"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_cfg
condition|)
block|{
name|nat_cnt
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|nat_cnt
argument_list|)
init|;
name|nat_cnt
condition|;
name|nat_cnt
operator|--
control|)
block|{
name|n
operator|=
operator|(
expr|struct
name|cfg_nat
operator|*
operator|)
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|frule
operator|<=
name|n
operator|->
name|id
operator|&&
name|lrule
operator|>=
name|n
operator|->
name|id
condition|)
name|print_nat_config
argument_list|(
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_nat
argument_list|)
expr_stmt|;
for|for
control|(
name|redir_cnt
operator|=
literal|0
init|;
name|redir_cnt
operator|<
name|n
operator|->
name|redir_cnt
condition|;
name|redir_cnt
operator|++
control|)
block|{
name|e
operator|=
operator|(
expr|struct
name|cfg_redir
operator|*
operator|)
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_redir
argument_list|)
operator|+
name|e
operator|->
name|spool_cnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cfg_spool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
literal|1
condition|;
name|i
operator|+=
name|LIBALIAS_BUF_SIZE
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|p
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|data
operator|+
name|nbytes
condition|)
break|break;
name|bcopy
argument_list|(
name|p
argument_list|,
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_rule
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|frule
operator|<=
name|r
operator|&&
name|lrule
operator|>=
name|r
operator|)
condition|)
continue|continue;
block|}
name|printf
argument_list|(
literal|"nat %u: %s\n"
argument_list|,
name|r
argument_list|,
name|p
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

