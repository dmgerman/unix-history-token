begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2003,2010 Luigi Rizzo  * Copyright (c) 1996 Alex Nash, Paul Traina, Poul-Henning Kamp  * Copyright (c) 1994 Ugen J.S.Antsilevich  *  * Idea and grammar partially left from:  * Copyright (c) 1993 Daniel Boulet  *  * Redistribution and use in source forms, with and without modification,  * are permitted provided that this entire comment appears intact.  *  * Redistribution in binary form may occur without any restrictions.  * Obviously, it would be nice if you gave credit where credit is due  * but requiring it would be too onerous.  *  * This software is provided ``AS IS'' without any warranties of any kind.  *  * Command line interface for IP firewall facility  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"ipfw2.h"
end_include

begin_function
specifier|static
name|void
name|help
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ipfw syntax summary (but please do read the ipfw(8) manpage):\n\n"
literal|"\tipfw [-abcdefhnNqStTv]<command>\n\n"
literal|"where<command> is one of the following:\n\n"
literal|"add [num] [set N] [prob x] RULE-BODY\n"
literal|"{pipe|queue} N config PIPE-BODY\n"
literal|"[pipe|queue] {zero|delete|show} [N{,N}]\n"
literal|"nat N config {ip IPADDR|if IFNAME|log|deny_in|same_ports|unreg_only|reset|\n"
literal|"		reverse|proxy_only|redirect_addr linkspec|\n"
literal|"		redirect_port linkspec|redirect_proto linkspec}\n"
literal|"set [disable N... enable N...] | move [rule] X to Y | swap X Y | show\n"
literal|"set N {show|list|zero|resetlog|delete} [N{,N}] | flush\n"
literal|"table N {add ip[/bits] [value] | delete ip[/bits] | flush | list}\n"
literal|"table all {flush | list}\n"
literal|"\n"
literal|"RULE-BODY:	check-state [PARAMS] | ACTION [PARAMS] ADDR [OPTION_LIST]\n"
literal|"ACTION:	check-state | allow | count | deny | unreach{,6} CODE |\n"
literal|"               skipto N | {divert|tee} PORT | forward ADDR |\n"
literal|"               pipe N | queue N | nat N | setfib FIB | reass\n"
literal|"PARAMS: 	[log [logamount LOGLIMIT]] [altq QUEUE_NAME]\n"
literal|"ADDR:		[ MAC dst src ether_type ] \n"
literal|"		[ ip from IPADDR [ PORT ] to IPADDR [ PORTLIST ] ]\n"
literal|"		[ ipv6|ip6 from IP6ADDR [ PORT ] to IP6ADDR [ PORTLIST ] ]\n"
literal|"IPADDR:	[not] { any | me | ip/bits{x,y,z} | table(t[,v]) | IPLIST }\n"
literal|"IP6ADDR:	[not] { any | me | me6 | ip6/bits | IP6LIST }\n"
literal|"IP6LIST:	{ ip6 | ip6/bits }[,IP6LIST]\n"
literal|"IPLIST:	{ ip | ip/bits | ip:mask }[,IPLIST]\n"
literal|"OPTION_LIST:	OPTION [OPTION_LIST]\n"
literal|"OPTION:	bridged | diverted | diverted-loopback | diverted-output |\n"
literal|"	{dst-ip|src-ip} IPADDR | {dst-ip6|src-ip6|dst-ipv6|src-ipv6} IP6ADDR |\n"
literal|"	{dst-port|src-port} LIST |\n"
literal|"	estab | frag | {gid|uid} N | icmptypes LIST | in | out | ipid LIST |\n"
literal|"	iplen LIST | ipoptions SPEC | ipprecedence | ipsec | iptos SPEC |\n"
literal|"	ipttl LIST | ipversion VER | keep-state | layer2 | limit ... |\n"
literal|"	icmp6types LIST | ext6hdr LIST | flow-id N[,N] | fib FIB |\n"
literal|"	mac ... | mac-type LIST | proto LIST | {recv|xmit|via} {IF|IPADDR} |\n"
literal|"	setup | {tcpack|tcpseq|tcpwin} NN | tcpflags SPEC | tcpoptions SPEC |\n"
literal|"	tcpdatalen LIST | verrevpath | versrcreach | antispoof\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called with the arguments, including program name because getopt  * wants it to be present.  * Returns 0 if successful, 1 if empty command, errx() in case of errors.  * First thing we do is process parameters creating an argv[] array  * which includes the program name and a NULL entry at the end.  * If we are called with a single string, we split it on whitespace.  * Also, arguments with a trailing ',' are joined to the next one.  * The pointers (av[]) and data are in a single chunk of memory.  * av[0] points to the original program name, all other entries  * point into the allocated chunk.  */
end_comment

begin_function
specifier|static
name|int
name|ipfw_main
parameter_list|(
name|int
name|oldac
parameter_list|,
name|char
modifier|*
modifier|*
name|oldav
parameter_list|)
block|{
name|int
name|ch
decl_stmt|,
name|ac
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|,
modifier|*
modifier|*
name|save_av
decl_stmt|;
name|int
name|do_acct
init|=
literal|0
decl_stmt|;
comment|/* Show packet/byte count */
name|int
name|try_next
init|=
literal|0
decl_stmt|;
comment|/* set if pipe cmd not found */
name|int
name|av_size
decl_stmt|;
comment|/* compute the av size */
name|char
modifier|*
name|av_p
decl_stmt|;
comment|/* used to build the av list */
define|#
directive|define
name|WHITESP
value|" \t\f\v\n\r"
if|if
condition|(
name|oldac
operator|<
literal|2
condition|)
return|return
literal|1
return|;
comment|/* need at least one argument */
if|if
condition|(
name|oldac
operator|==
literal|2
condition|)
block|{
comment|/* 		 * If we are called with one argument, try to split it into 		 * words for subsequent parsing. Spaces after a ',' are 		 * removed by copying the string in-place. 		 */
name|char
modifier|*
name|arg
init|=
name|oldav
index|[
literal|1
index|]
decl_stmt|;
comment|/* The string is the first arg. */
name|int
name|l
init|=
name|strlen
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|int
name|copy
init|=
literal|0
decl_stmt|;
comment|/* 1 if we need to copy, 0 otherwise */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arg
index|[
name|i
index|]
operator|==
literal|'#'
condition|)
comment|/* comment marker */
break|break;
if|if
condition|(
name|copy
condition|)
block|{
name|arg
index|[
name|j
operator|++
index|]
operator|=
name|arg
index|[
name|i
index|]
expr_stmt|;
name|copy
operator|=
operator|!
name|strchr
argument_list|(
literal|","
name|WHITESP
argument_list|,
name|arg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copy
operator|=
operator|!
name|strchr
argument_list|(
name|WHITESP
argument_list|,
name|arg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
condition|)
name|arg
index|[
name|j
operator|++
index|]
operator|=
name|arg
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|copy
operator|&&
name|j
operator|>
literal|0
condition|)
comment|/* last char was a 'blank', remove it */
name|j
operator|--
expr_stmt|;
name|l
operator|=
name|j
expr_stmt|;
comment|/* the new argument length */
name|arg
index|[
name|j
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
comment|/* empty string! */
return|return
literal|1
return|;
comment|/* 		 * First, count number of arguments. Because of the previous 		 * processing, this is just the number of blanks plus 1. 		 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ac
operator|=
literal|1
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strchr
argument_list|(
name|WHITESP
argument_list|,
name|arg
index|[
name|i
index|]
argument_list|)
operator|!=
name|NULL
condition|)
name|ac
operator|++
expr_stmt|;
comment|/* 		 * Allocate the argument list structure as a single block 		 * of memory, containing pointers and the argument 		 * strings. We include one entry for the program name 		 * because getopt expects it, and a NULL at the end 		 * to simplify further parsing. 		 */
name|ac
operator|++
expr_stmt|;
comment|/* add 1 for the program name */
name|av_size
operator|=
operator|(
name|ac
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|+
name|l
operator|+
literal|1
expr_stmt|;
name|av
operator|=
name|safe_calloc
argument_list|(
name|av_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Init the argument pointer to the end of the array 		 * and copy arguments from arg[] to av[]. For each one, 		 * j is the initial character, i is the one past the end. 		 */
name|av_p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|av
index|[
name|ac
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|ac
operator|=
literal|1
operator|,
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|WHITESP
argument_list|,
name|arg
index|[
name|i
index|]
argument_list|)
operator|!=
name|NULL
operator|||
name|i
operator|==
name|l
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|l
operator|-
literal|1
condition|)
name|i
operator|++
expr_stmt|;
name|bcopy
argument_list|(
name|arg
operator|+
name|j
argument_list|,
name|av_p
argument_list|,
name|i
operator|-
name|j
argument_list|)
expr_stmt|;
name|av
index|[
name|ac
index|]
operator|=
name|av_p
expr_stmt|;
name|av_p
operator|+=
name|i
operator|-
name|j
expr_stmt|;
comment|/* the length of the string */
operator|*
name|av_p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ac
operator|++
expr_stmt|;
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * If an argument ends with ',' join with the next one. 		 */
name|int
name|first
decl_stmt|,
name|i
decl_stmt|,
name|l
init|=
literal|0
decl_stmt|;
comment|/* 		 * Allocate the argument list structure as a single block 		 * of memory, containing both pointers and the argument 		 * strings. We include some space for the program name 		 * because getopt expects it. 		 * We add an extra pointer to the end of the array, 		 * to make simpler further parsing. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldac
condition|;
name|i
operator|++
control|)
name|l
operator|+=
name|strlen
argument_list|(
name|oldav
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|av_size
operator|=
operator|(
name|oldac
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|+
name|l
operator|+
name|oldac
expr_stmt|;
name|av
operator|=
name|safe_calloc
argument_list|(
name|av_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Init the argument pointer to the end of the array 		 * and copy arguments from arg[] to av[] 		 */
name|av_p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|av
index|[
name|oldac
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|first
operator|=
name|i
operator|=
name|ac
operator|=
literal|1
operator|,
name|l
operator|=
literal|0
init|;
name|i
operator|<
name|oldac
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|arg
init|=
name|oldav
index|[
name|i
index|]
decl_stmt|;
name|int
name|k
init|=
name|strlen
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|l
operator|+=
name|k
expr_stmt|;
if|if
condition|(
name|arg
index|[
name|k
operator|-
literal|1
index|]
operator|!=
literal|','
operator|||
name|i
operator|==
name|oldac
operator|-
literal|1
condition|)
block|{
comment|/* Time to copy. */
name|av
index|[
name|ac
index|]
operator|=
name|av_p
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|first
operator|<=
name|i
condition|;
name|first
operator|++
control|)
block|{
name|strcat
argument_list|(
name|av_p
argument_list|,
name|oldav
index|[
name|first
index|]
argument_list|)
expr_stmt|;
name|av_p
operator|+=
name|strlen
argument_list|(
name|oldav
index|[
name|first
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|av_p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ac
operator|++
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
name|first
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * set the progname pointer to the original string 	 * and terminate the array with null 	 */
name|av
index|[
literal|0
index|]
operator|=
name|oldav
index|[
literal|0
index|]
expr_stmt|;
name|av
index|[
name|ac
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Set the force flag for non-interactive processes */
if|if
condition|(
operator|!
name|co
operator|.
name|do_force
condition|)
name|co
operator|.
name|do_force
operator|=
operator|!
name|isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EMULATE_SYSCTL
comment|/* sysctl emulation */
if|if
condition|(
name|ac
operator|>=
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"sysctl"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ac
operator|!=
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"sysctl emulation usage:\n"
literal|"	ipfw sysctl name[=value]\n"
literal|"	ipfw sysctl -a\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|=
name|strchr
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|"-a"
argument_list|)
condition|?
name|NULL
else|:
name|av
index|[
literal|2
index|]
expr_stmt|;
name|sysctlbyname
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ipfw sysctl x.y.z=value */
comment|/* assume an INT value, will extend later */
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"ipfw sysctl: missing value\n\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|strtol
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sysctlbyname
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* Save arguments for final freeing of memory. */
name|save_av
operator|=
name|av
expr_stmt|;
name|optind
operator|=
name|optreset
operator|=
literal|1
expr_stmt|;
comment|/* restart getopt() */
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"abcdefhinNp:qs:STtv"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|do_acct
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|co
operator|.
name|comment_only
operator|=
literal|1
expr_stmt|;
name|co
operator|.
name|do_compact
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|co
operator|.
name|do_compact
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|co
operator|.
name|do_dynamic
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|co
operator|.
name|do_expired
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|co
operator|.
name|do_force
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* help */
name|free
argument_list|(
name|save_av
argument_list|)
expr_stmt|;
name|help
argument_list|()
expr_stmt|;
break|break;
comment|/* NOTREACHED */
case|case
literal|'i'
case|:
name|co
operator|.
name|do_value_as_ip
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|co
operator|.
name|test_only
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|co
operator|.
name|do_resolv
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"An absolute pathname must be used "
literal|"with -p option."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'q'
case|:
name|co
operator|.
name|do_quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* sort */
name|co
operator|.
name|do_sort
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|co
operator|.
name|show_sets
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|co
operator|.
name|do_time
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|co
operator|.
name|do_time
operator|=
literal|2
expr_stmt|;
comment|/* numeric timestamp */
break|break;
case|case
literal|'v'
case|:
comment|/* verbose */
name|co
operator|.
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|free
argument_list|(
name|save_av
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ac
operator|-=
name|optind
expr_stmt|;
name|av
operator|+=
name|optind
expr_stmt|;
name|NEED1
argument_list|(
literal|"bad arguments, for usage summary ``ipfw''"
argument_list|)
expr_stmt|;
comment|/* 	 * An undocumented behaviour of ipfw1 was to allow rule numbers first, 	 * e.g. "100 add allow ..." instead of "add 100 allow ...". 	 * In case, swap first and second argument to get the normal form. 	 */
if|if
condition|(
name|ac
operator|>
literal|1
operator|&&
name|isdigit
argument_list|(
operator|*
name|av
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|av
index|[
literal|0
index|]
decl_stmt|;
name|av
index|[
literal|0
index|]
operator|=
name|av
index|[
literal|1
index|]
expr_stmt|;
name|av
index|[
literal|1
index|]
operator|=
name|p
expr_stmt|;
block|}
comment|/* 	 * Optional: pipe, queue or nat. 	 */
name|co
operator|.
name|do_nat
operator|=
literal|0
expr_stmt|;
name|co
operator|.
name|do_pipe
operator|=
literal|0
expr_stmt|;
name|co
operator|.
name|use_set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"nat"
argument_list|,
name|strlen
argument_list|(
operator|*
name|av
argument_list|)
argument_list|)
condition|)
name|co
operator|.
name|do_nat
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"pipe"
argument_list|,
name|strlen
argument_list|(
operator|*
name|av
argument_list|)
argument_list|)
condition|)
name|co
operator|.
name|do_pipe
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"queue"
argument_list|)
operator|==
literal|0
condition|)
name|co
operator|.
name|do_pipe
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"flowset"
argument_list|)
operator|==
literal|0
condition|)
name|co
operator|.
name|do_pipe
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"sched"
argument_list|)
operator|==
literal|0
condition|)
name|co
operator|.
name|do_pipe
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"set"
argument_list|,
name|strlen
argument_list|(
operator|*
name|av
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|ac
operator|>
literal|1
operator|&&
name|isdigit
argument_list|(
name|av
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|co
operator|.
name|use_set
operator|=
name|strtonum
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|resvd_set_number
argument_list|,
operator|&
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid set number %s\n"
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ac
operator|-=
literal|2
expr_stmt|;
name|av
operator|+=
literal|2
expr_stmt|;
name|co
operator|.
name|use_set
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|co
operator|.
name|do_pipe
operator|||
name|co
operator|.
name|do_nat
condition|)
block|{
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
block|}
name|NEED1
argument_list|(
literal|"missing command"
argument_list|)
expr_stmt|;
comment|/* 	 * For pipes, queues and nats we normally say 'nat|pipe NN config' 	 * but the code is easier to parse as 'nat|pipe config NN' 	 * so we swap the two arguments. 	 */
if|if
condition|(
operator|(
name|co
operator|.
name|do_pipe
operator|||
name|co
operator|.
name|do_nat
operator|)
operator|&&
name|ac
operator|>
literal|1
operator|&&
name|isdigit
argument_list|(
operator|*
name|av
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|av
index|[
literal|0
index|]
decl_stmt|;
name|av
index|[
literal|0
index|]
operator|=
name|av
index|[
literal|1
index|]
expr_stmt|;
name|av
index|[
literal|1
index|]
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|co
operator|.
name|use_set
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"add"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_add
argument_list|(
name|av
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|co
operator|.
name|do_nat
operator|&&
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"show"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_show_nat
argument_list|(
name|ac
argument_list|,
name|av
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|co
operator|.
name|do_pipe
operator|&&
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"config"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_config_pipe
argument_list|(
name|ac
argument_list|,
name|av
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|co
operator|.
name|do_nat
operator|&&
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"config"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_config_nat
argument_list|(
name|ac
argument_list|,
name|av
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_sets_handler
argument_list|(
name|av
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"table"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_table_handler
argument_list|(
name|ac
argument_list|,
name|av
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"enable"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_sysctl_handler
argument_list|(
name|av
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"disable"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_sysctl_handler
argument_list|(
name|av
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|try_next
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|co
operator|.
name|use_set
operator|||
name|try_next
condition|)
block|{
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_delete
argument_list|(
name|av
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"flush"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_flush
argument_list|(
name|co
operator|.
name|do_force
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"zero"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_zero
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|0
comment|/* IP_FW_ZERO */
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"resetlog"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_zero
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|1
comment|/* IP_FW_RESETLOG */
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"print"
argument_list|)
operator|==
literal|0
operator|||
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"list"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_list
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
name|do_acct
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"show"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_list
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|1
comment|/* show counters */
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"table"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_table_handler
argument_list|(
name|ac
argument_list|,
name|av
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"iflist"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_list_tifaces
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|_substrcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"talist"
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_list_ta
argument_list|(
name|ac
argument_list|,
name|av
argument_list|)
expr_stmt|;
else|else
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"bad command `%s'"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
block|}
comment|/* Free memory allocated in the argument parsing. */
name|free
argument_list|(
name|save_av
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ipfw_readfile
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
block|{
define|#
directive|define
name|MAX_ARGS
value|32
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|char
modifier|*
name|progname
init|=
name|av
index|[
literal|0
index|]
decl_stmt|;
comment|/* original program name */
specifier|const
name|char
modifier|*
name|cmd
init|=
name|NULL
decl_stmt|;
comment|/* preprocessor name, if any */
specifier|const
name|char
modifier|*
name|filename
init|=
name|av
index|[
name|ac
operator|-
literal|1
index|]
decl_stmt|;
comment|/* file to read */
name|int
name|c
decl_stmt|,
name|lineno
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
name|pid_t
name|preproc
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"cfNnp:qS"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|co
operator|.
name|do_compact
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|co
operator|.
name|do_force
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|co
operator|.
name|do_resolv
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|co
operator|.
name|test_only
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* 			 * ipfw -p cmd [args] filename 			 * 			 * We are done with getopt(). All arguments 			 * except the filename go to the preprocessor, 			 * so we need to do the following: 			 * - check that a filename is actually present; 			 * - advance av by optind-1 to skip arguments 			 *   already processed; 			 * - decrease ac by optind, to remove the args 			 *   already processed and the final filename; 			 * - set the last entry in av[] to NULL so 			 *   popen() can detect the end of the array; 			 * - set optind=ac to let getopt() terminate. 			 */
if|if
condition|(
name|optind
operator|==
name|ac
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"no filename argument"
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|optarg
expr_stmt|;
name|av
index|[
name|ac
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|av
operator|+=
name|optind
operator|-
literal|1
expr_stmt|;
name|ac
operator|-=
name|optind
expr_stmt|;
name|optind
operator|=
name|ac
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|co
operator|.
name|do_quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|co
operator|.
name|show_sets
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"bad arguments, for usage"
literal|" summary ``ipfw''"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cmd
operator|==
name|NULL
operator|&&
name|ac
operator|!=
name|optind
operator|+
literal|1
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"extraneous filename arguments %s"
argument_list|,
name|av
index|[
name|ac
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
literal|"fopen: %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|NULL
condition|)
block|{
comment|/* pipe through preprocessor */
name|int
name|pipedes
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pipedes
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"cannot create pipe"
argument_list|)
expr_stmt|;
name|preproc
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|preproc
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"cannot fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preproc
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Child, will run the preprocessor with the 			 * file on stdin and the pipe on stdout. 			 */
if|if
condition|(
name|dup2
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|dup2
argument_list|(
name|pipedes
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"dup2()"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipedes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipedes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|cmd
argument_list|,
name|av
argument_list|)
expr_stmt|;
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"execvp(%s) failed"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* parent, will reopen f as the pipe */
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipedes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fdopen
argument_list|(
name|pipedes
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|int
name|savederrno
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|preproc
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|errno
operator|=
name|savederrno
expr_stmt|;
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"fdopen()"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
block|{
comment|/* read commands */
name|char
name|linename
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|args
index|[
literal|2
index|]
decl_stmt|;
name|lineno
operator|++
expr_stmt|;
name|snprintf
argument_list|(
name|linename
argument_list|,
sizeof|sizeof
argument_list|(
name|linename
argument_list|)
argument_list|,
literal|"Line %d"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|setprogname
argument_list|(
name|linename
argument_list|)
expr_stmt|;
comment|/* XXX */
name|args
index|[
literal|0
index|]
operator|=
name|progname
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|buf
expr_stmt|;
name|ipfw_main
argument_list|(
literal|2
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|NULL
condition|)
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|preproc
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EX_OSERR
argument_list|,
literal|"waitpid()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|&&
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
name|EX_OK
condition|)
name|errx
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
literal|"preprocessor exited with status %d"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
name|errx
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
literal|"preprocessor exited with signal %d"
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|TCC
argument_list|)
block|{
name|WSADATA
name|wsaData
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|wVersionRequested
init|=
name|MAKEWORD
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|ret
operator|=
name|WSAStartup
argument_list|(
name|wVersionRequested
argument_list|,
operator|&
name|wsaData
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
comment|/* Tell the user that we could not find a usable */
comment|/* Winsock DLL.				  */
name|printf
argument_list|(
literal|"WSAStartup failed with error: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * If the last argument is an absolute pathname, interpret it 	 * as a file to be preprocessed. 	 */
if|if
condition|(
name|ac
operator|>
literal|1
operator|&&
name|av
index|[
name|ac
operator|-
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|av
index|[
name|ac
operator|-
literal|1
index|]
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
name|ipfw_readfile
argument_list|(
name|ac
argument_list|,
name|av
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
name|EX_USAGE
argument_list|,
literal|"pathname: %s"
argument_list|,
name|av
index|[
name|ac
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ipfw_main
argument_list|(
name|ac
argument_list|,
name|av
argument_list|)
condition|)
block|{
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"usage: ipfw [options]\n"
literal|"do \"ipfw -h\" or \"man ipfw\" for details"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|EX_OK
return|;
block|}
end_function

end_unit

