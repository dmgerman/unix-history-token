begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Spectra Logic Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * Authors: Ken Merry           (Spectra Logic Corporation)  */
end_comment

begin_comment
comment|/*  * ATA Extended Power Conditions (EPC) support  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/ata.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_pass.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<camlib.h>
end_include

begin_include
include|#
directive|include
file|"camcontrol.h"
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|EPC_ACTION_NONE
init|=
literal|0x00
block|,
name|EPC_ACTION_LIST
init|=
literal|0x01
block|,
name|EPC_ACTION_TIMER_SET
init|=
literal|0x02
block|,
name|EPC_ACTION_IMMEDIATE
init|=
literal|0x03
block|,
name|EPC_ACTION_GETMODE
init|=
literal|0x04
block|}
name|epc_action
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|scsi_nv
name|epc_flags
index|[]
init|=
block|{
block|{
literal|"Supported"
block|,
name|ATA_PCL_COND_SUPPORTED
block|}
block|,
block|{
literal|"Saveable"
block|,
name|ATA_PCL_COND_SUPPORTED
block|}
block|,
block|{
literal|"Changeable"
block|,
name|ATA_PCL_COND_CHANGEABLE
block|}
block|,
block|{
literal|"Default Timer Enabled"
block|,
name|ATA_PCL_DEFAULT_TIMER_EN
block|}
block|,
block|{
literal|"Saved Timer Enabled"
block|,
name|ATA_PCL_SAVED_TIMER_EN
block|}
block|,
block|{
literal|"Current Timer Enabled"
block|,
name|ATA_PCL_CURRENT_TIMER_EN
block|}
block|,
block|{
literal|"Hold Power Condition Not Supported"
block|,
name|ATA_PCL_HOLD_PC_NOT_SUP
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_nv
name|epc_power_cond_map
index|[]
init|=
block|{
block|{
literal|"Standby_z"
block|,
name|ATA_EPC_STANDBY_Z
block|}
block|,
block|{
literal|"z"
block|,
name|ATA_EPC_STANDBY_Z
block|}
block|,
block|{
literal|"Standby_y"
block|,
name|ATA_EPC_STANDBY_Y
block|}
block|,
block|{
literal|"y"
block|,
name|ATA_EPC_STANDBY_Y
block|}
block|,
block|{
literal|"Idle_a"
block|,
name|ATA_EPC_IDLE_A
block|}
block|,
block|{
literal|"a"
block|,
name|ATA_EPC_IDLE_A
block|}
block|,
block|{
literal|"Idle_b"
block|,
name|ATA_EPC_IDLE_B
block|}
block|,
block|{
literal|"b"
block|,
name|ATA_EPC_IDLE_B
block|}
block|,
block|{
literal|"Idle_c"
block|,
name|ATA_EPC_IDLE_C
block|}
block|,
block|{
literal|"c"
block|,
name|ATA_EPC_IDLE_C
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_nv
name|epc_rst_val
index|[]
init|=
block|{
block|{
literal|"default"
block|,
name|ATA_SF_EPC_RST_DFLT
block|}
block|,
block|{
literal|"saved"
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_nv
name|epc_ps_map
index|[]
init|=
block|{
block|{
literal|"unknown"
block|,
name|ATA_SF_EPC_SRC_UNKNOWN
block|}
block|,
block|{
literal|"battery"
block|,
name|ATA_SF_EPC_SRC_BAT
block|}
block|,
block|{
literal|"notbattery"
block|,
name|ATA_SF_EPC_SRC_NOT_BAT
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These aren't subcommands of the EPC SET FEATURES subcommand, but rather  * commands that determine the current capabilities and status of the drive.  * The EPC subcommands are limited to 4 bits, so we won't collide with any  * future values.  */
end_comment

begin_define
define|#
directive|define
name|CCTL_EPC_GET_STATUS
value|0x8001
end_define

begin_define
define|#
directive|define
name|CCTL_EPC_LIST
value|0x8002
end_define

begin_decl_stmt
specifier|static
name|struct
name|scsi_nv
name|epc_cmd_map
index|[]
init|=
block|{
block|{
literal|"restore"
block|,
name|ATA_SF_EPC_RESTORE
block|}
block|,
block|{
literal|"goto"
block|,
name|ATA_SF_EPC_GOTO
block|}
block|,
block|{
literal|"timer"
block|,
name|ATA_SF_EPC_SET_TIMER
block|}
block|,
block|{
literal|"state"
block|,
name|ATA_SF_EPC_SET_STATE
block|}
block|,
block|{
literal|"enable"
block|,
name|ATA_SF_EPC_ENABLE
block|}
block|,
block|{
literal|"disable"
block|,
name|ATA_SF_EPC_DISABLE
block|}
block|,
block|{
literal|"source"
block|,
name|ATA_SF_EPC_SET_SOURCE
block|}
block|,
block|{
literal|"status"
block|,
name|CCTL_EPC_GET_STATUS
block|}
block|,
block|{
literal|"list"
block|,
name|CCTL_EPC_LIST
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|epc_list
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|camcontrol_devtype
name|devtype
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|epc_print_pcl_desc
parameter_list|(
name|struct
name|ata_power_cond_log_desc
modifier|*
name|desc
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|epc_getmode
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|camcontrol_devtype
name|devtype
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|power_only
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|epc_set_features
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|camcontrol_devtype
name|devtype
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|action
parameter_list|,
name|int
name|power_cond
parameter_list|,
name|int
name|timer
parameter_list|,
name|int
name|enable
parameter_list|,
name|int
name|save
parameter_list|,
name|int
name|delayed_entry
parameter_list|,
name|int
name|hold
parameter_list|,
name|int
name|power_src
parameter_list|,
name|int
name|restore_src
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|epc_print_pcl_desc
parameter_list|(
name|struct
name|ata_power_cond_log_desc
modifier|*
name|desc
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|int
name|first
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|num_printed
decl_stmt|,
name|max_chars
decl_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|max_chars
operator|=
literal|75
expr_stmt|;
name|num_printed
operator|=
name|printf
argument_list|(
literal|"%sFlags: "
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|epc_flags
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|epc_flags
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|desc
operator|->
name|flags
operator|&
name|epc_flags
index|[
name|i
index|]
operator|.
name|value
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|first
operator|==
literal|0
condition|)
block|{
name|num_printed
operator|+=
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|num_printed
operator|+
name|strlen
argument_list|(
name|epc_flags
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|)
operator|>
name|max_chars
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|num_printed
operator|=
name|printf
argument_list|(
literal|"%s       "
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
name|num_printed
operator|+=
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|epc_flags
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|first
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"None"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sDefault timer setting: %.1f sec\n"
argument_list|,
name|prefix
argument_list|,
call|(
name|double
call|)
argument_list|(
name|le32dec
argument_list|(
name|desc
operator|->
name|default_timer
argument_list|)
operator|/
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sSaved timer setting: %.1f sec\n"
argument_list|,
name|prefix
argument_list|,
call|(
name|double
call|)
argument_list|(
name|le32dec
argument_list|(
name|desc
operator|->
name|saved_timer
argument_list|)
operator|/
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sCurrent timer setting: %.1f sec\n"
argument_list|,
name|prefix
argument_list|,
call|(
name|double
call|)
argument_list|(
name|le32dec
argument_list|(
name|desc
operator|->
name|current_timer
argument_list|)
operator|/
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sNominal time to active: %.1f sec\n"
argument_list|,
name|prefix
argument_list|,
call|(
name|double
call|)
argument_list|(
name|le32dec
argument_list|(
name|desc
operator|->
name|nom_time_to_active
argument_list|)
operator|/
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sMinimum timer: %.1f sec\n"
argument_list|,
name|prefix
argument_list|,
call|(
name|double
call|)
argument_list|(
name|le32dec
argument_list|(
name|desc
operator|->
name|min_timer
argument_list|)
operator|/
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sMaximum timer: %.1f sec\n"
argument_list|,
name|prefix
argument_list|,
call|(
name|double
call|)
argument_list|(
name|le32dec
argument_list|(
name|desc
operator|->
name|max_timer
argument_list|)
operator|/
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sNumber of transitions to power condition: %u\n"
argument_list|,
name|prefix
argument_list|,
name|le32dec
argument_list|(
name|desc
operator|->
name|num_transitions_to_pc
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sHours in power condition: %u\n"
argument_list|,
name|prefix
argument_list|,
name|le32dec
argument_list|(
name|desc
operator|->
name|hours_in_pc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|epc_list
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|camcontrol_devtype
name|devtype
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|ata_power_cond_log_idle
modifier|*
name|idle_log
decl_stmt|;
name|struct
name|ata_power_cond_log_standby
modifier|*
name|standby_log
decl_stmt|;
name|uint8_t
name|log_buf
index|[
sizeof|sizeof
argument_list|(
operator|*
name|idle_log
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|standby_log
argument_list|)
index|]
decl_stmt|;
name|uint16_t
name|log_addr
init|=
name|ATA_POWER_COND_LOG
decl_stmt|;
name|uint16_t
name|page_number
init|=
name|ATA_PCL_IDLE
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|lba
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|page_number
operator|&
literal|0xff00
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|page_number
operator|&
literal|0x00ff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|log_addr
operator|&
literal|0xff
operator|)
expr_stmt|;
name|error
operator|=
name|build_ata_cmd
argument_list|(
name|ccb
argument_list|,
comment|/*retry_count*/
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
operator||
name|CAM_DEV_QFRZDIS
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*protocol*/
name|AP_PROTO_DMA
operator||
name|AP_EXTEND
argument_list|,
comment|/*ata_flags*/
name|AP_FLAG_BYT_BLOK_BLOCKS
operator||
name|AP_FLAG_TLEN_SECT_CNT
operator||
name|AP_FLAG_TDIR_FROM_DEV
argument_list|,
comment|/*features*/
literal|0
argument_list|,
comment|/*sector_count*/
literal|2
argument_list|,
comment|/*lba*/
name|lba
argument_list|,
comment|/*command*/
name|ATA_READ_LOG_DMA_EXT
argument_list|,
comment|/*auxiliary*/
literal|0
argument_list|,
comment|/*data_ptr*/
name|log_buf
argument_list|,
comment|/*dxfer_len*/
sizeof|sizeof
argument_list|(
name|log_buf
argument_list|)
argument_list|,
comment|/*cdb_storage*/
name|NULL
argument_list|,
comment|/*cdb_storage_len*/
literal|0
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|60000
argument_list|,
comment|/*is48bit*/
literal|1
argument_list|,
comment|/*devtype*/
name|devtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: build_ata_cmd() failed, likely programmer error"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|retry_count
operator|>
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
name|error
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending ATA READ LOG EXT CCB"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|idle_log
operator|=
operator|(
expr|struct
name|ata_power_cond_log_idle
operator|*
operator|)
name|log_buf
expr_stmt|;
name|standby_log
operator|=
operator|(
expr|struct
name|ata_power_cond_log_standby
operator|*
operator|)
operator|&
name|log_buf
index|[
sizeof|sizeof
argument_list|(
operator|*
name|idle_log
argument_list|)
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"ATA Power Conditions Log:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Idle power conditions page:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Idle A condition:\n"
argument_list|)
expr_stmt|;
name|epc_print_pcl_desc
argument_list|(
operator|&
name|idle_log
operator|->
name|idle_a_desc
argument_list|,
literal|"      "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Idle B condition:\n"
argument_list|)
expr_stmt|;
name|epc_print_pcl_desc
argument_list|(
operator|&
name|idle_log
operator|->
name|idle_b_desc
argument_list|,
literal|"      "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Idle C condition:\n"
argument_list|)
expr_stmt|;
name|epc_print_pcl_desc
argument_list|(
operator|&
name|idle_log
operator|->
name|idle_c_desc
argument_list|,
literal|"      "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Standby power conditions page:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Standby Y condition:\n"
argument_list|)
expr_stmt|;
name|epc_print_pcl_desc
argument_list|(
operator|&
name|standby_log
operator|->
name|standby_y_desc
argument_list|,
literal|"      "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Standby Z condition:\n"
argument_list|)
expr_stmt|;
name|epc_print_pcl_desc
argument_list|(
operator|&
name|standby_log
operator|->
name|standby_z_desc
argument_list|,
literal|"      "
argument_list|)
expr_stmt|;
name|bailout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epc_getmode
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|camcontrol_devtype
name|devtype
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|power_only
parameter_list|)
block|{
name|struct
name|ata_params
modifier|*
name|ident
init|=
name|NULL
decl_stmt|;
name|struct
name|ata_identify_log_sup_cap
name|sup_cap
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode_name
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|error
init|=
literal|0
decl_stmt|,
name|ata_device
init|=
literal|0
decl_stmt|,
name|status
init|=
literal|0
decl_stmt|;
name|uint16_t
name|count
init|=
literal|0
decl_stmt|;
name|uint64_t
name|lba
init|=
literal|0
decl_stmt|;
name|uint32_t
name|page_number
decl_stmt|,
name|log_address
decl_stmt|;
name|uint64_t
name|caps
init|=
literal|0
decl_stmt|;
name|int
name|avail_bytes
init|=
literal|0
decl_stmt|;
name|int
name|res_available
init|=
literal|0
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|power_only
operator|!=
literal|0
condition|)
goto|goto
name|check_power_mode
goto|;
comment|/* 	 * Get standard ATA Identify data. 	 */
name|retval
operator|=
name|ata_do_identify
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|ccb
argument_list|,
operator|&
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Couldn't get identify data"
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * Get the ATA Identify Data Log (0x30), 	 * Supported Capabilities Page (0x03). 	 */
name|log_address
operator|=
name|ATA_IDENTIFY_DATA_LOG
expr_stmt|;
name|page_number
operator|=
name|ATA_IDL_SUP_CAP
expr_stmt|;
name|lba
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|page_number
operator|&
literal|0xff00
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|page_number
operator|&
literal|0x00ff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|log_address
operator|&
literal|0xff
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sup_cap
argument_list|,
sizeof|sizeof
argument_list|(
name|sup_cap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX KDM check the supported protocol. 	 */
name|retval
operator|=
name|build_ata_cmd
argument_list|(
name|ccb
argument_list|,
comment|/*retry_count*/
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
operator||
name|CAM_DEV_QFRZDIS
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*protocol*/
name|AP_PROTO_DMA
operator||
name|AP_EXTEND
argument_list|,
comment|/*ata_flags*/
name|AP_FLAG_BYT_BLOK_BLOCKS
operator||
name|AP_FLAG_TLEN_SECT_CNT
operator||
name|AP_FLAG_TDIR_FROM_DEV
argument_list|,
comment|/*features*/
literal|0
argument_list|,
comment|/*sector_count*/
literal|1
argument_list|,
comment|/*lba*/
name|lba
argument_list|,
comment|/*command*/
name|ATA_READ_LOG_DMA_EXT
argument_list|,
comment|/*auxiliary*/
literal|0
argument_list|,
comment|/*data_ptr*/
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|sup_cap
argument_list|,
comment|/*dxfer_len*/
sizeof|sizeof
argument_list|(
name|sup_cap
argument_list|)
argument_list|,
comment|/*cdb_storage*/
name|NULL
argument_list|,
comment|/*cdb_storage_len*/
literal|0
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|60000
argument_list|,
comment|/*is48bit*/
literal|1
argument_list|,
comment|/*devtype*/
name|devtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: build_ata_cmd() failed, likely a programmer error"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|retry_count
operator|>
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending ATA READ LOG CCB"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|avail_bytes
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|resid
expr_stmt|;
block|}
else|else
block|{
name|avail_bytes
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|dxfer_len
operator|-
name|ccb
operator|->
name|ataio
operator|.
name|resid
expr_stmt|;
block|}
if|if
condition|(
name|avail_bytes
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sup_cap
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Couldn't get enough of the ATA Supported "
literal|"Capabilities log, %d bytes returned"
argument_list|,
name|avail_bytes
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|caps
operator|=
name|le64dec
argument_list|(
name|sup_cap
operator|.
name|sup_cap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|caps
operator|&
name|ATA_SUP_CAP_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Supported capabilities bits are not valid"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|printf
argument_list|(
literal|"APM: %sSupported, %sEnabled\n"
argument_list|,
operator|(
name|ident
operator|->
name|support
operator|.
name|command2
operator|&
name|ATA_SUPPORT_APM
operator|)
condition|?
literal|""
else|:
literal|"NOT "
argument_list|,
operator|(
name|ident
operator|->
name|enabled
operator|.
name|command2
operator|&
name|ATA_SUPPORT_APM
operator|)
condition|?
literal|""
else|:
literal|"NOT "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"EPC: %sSupported, %sEnabled\n"
argument_list|,
operator|(
name|ident
operator|->
name|support2
operator|&
name|ATA_SUPPORT_EPC
operator|)
condition|?
literal|""
else|:
literal|"NOT "
argument_list|,
operator|(
name|ident
operator|->
name|enabled2
operator|&
name|ATA_ENABLED_EPC
operator|)
condition|?
literal|""
else|:
literal|"NOT "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Low Power Standby %sSupported\n"
argument_list|,
operator|(
name|caps
operator|&
name|ATA_SC_LP_STANDBY_SUP
operator|)
condition|?
literal|""
else|:
literal|"NOT "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Set EPC Power Source %sSupported\n"
argument_list|,
operator|(
name|caps
operator|&
name|ATA_SC_SET_EPC_PS_SUP
operator|)
condition|?
literal|""
else|:
literal|"NOT "
argument_list|)
expr_stmt|;
name|check_power_mode
label|:
name|retval
operator|=
name|build_ata_cmd
argument_list|(
name|ccb
argument_list|,
comment|/*retry_count*/
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
operator||
name|CAM_DEV_QFRZDIS
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*protocol*/
name|AP_PROTO_NON_DATA
operator||
name|AP_EXTEND
argument_list|,
comment|/*ata_flags*/
name|AP_FLAG_BYT_BLOK_BLOCKS
operator||
name|AP_FLAG_TLEN_NO_DATA
operator||
name|AP_FLAG_CHK_COND
argument_list|,
comment|/*features*/
name|ATA_SF_EPC
argument_list|,
comment|/*sector_count*/
literal|0
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*command*/
name|ATA_CHECK_POWER_MODE
argument_list|,
comment|/*auxiliary*/
literal|0
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
comment|/*cdb_storage*/
name|NULL
argument_list|,
comment|/*cdb_storage_len*/
literal|0
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|60000
argument_list|,
comment|/*is48bit*/
literal|0
argument_list|,
comment|/*devtype*/
name|devtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: build_ata_cmd() failed, likely a programmer error"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|retry_count
operator|>
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending ATA CHECK POWER MODE CCB"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * Check to see whether we got the requested ATA result if this 	 * is an SCSI ATA PASS-THROUGH command. 	 */
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|==
name|SCSI_STATUS_CHECK_COND
operator|)
condition|)
block|{
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|retval
operator|=
name|scsi_extract_sense_ccb
argument_list|(
name|ccb
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|sense_key
operator|==
name|SSD_KEY_RECOVERED_ERROR
operator|)
operator|&&
operator|(
name|asc
operator|==
literal|0x00
operator|)
operator|&&
operator|(
name|ascq
operator|==
literal|0x1d
operator|)
condition|)
block|{
name|res_available
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|res_available
operator|==
literal|0
operator|)
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|retval
operator|=
name|get_ata_status
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
operator|&
name|error
argument_list|,
operator|&
name|count
argument_list|,
operator|&
name|lba
argument_list|,
operator|&
name|ata_device
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Unable to get ATA CHECK POWER MODE result"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|mode_name
operator|=
name|scsi_nv_to_str
argument_list|(
name|epc_power_cond_map
argument_list|,
sizeof|sizeof
argument_list|(
name|epc_power_cond_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|epc_power_cond_map
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Current power state: "
argument_list|)
expr_stmt|;
comment|/* Note: ident can be null in power_only mode */
if|if
condition|(
operator|(
name|ident
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ident
operator|->
name|enabled2
operator|&
name|ATA_ENABLED_EPC
operator|)
condition|)
block|{
if|if
condition|(
name|mode_name
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|mode_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|0xff
condition|)
block|{
name|printf
argument_list|(
literal|"PM0:Active or PM1:Idle"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|count
condition|)
block|{
case|case
literal|0x00
case|:
name|printf
argument_list|(
literal|"PM2:Standby"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|printf
argument_list|(
literal|"PM1:Idle"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xff
case|:
name|printf
argument_list|(
literal|"PM0:Active or PM1:Idle"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"(0x%02x)\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_only
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
name|caps
operator|&
name|ATA_SC_LP_STANDBY_SUP
condition|)
block|{
name|uint32_t
name|wait_mode
decl_stmt|;
name|wait_mode
operator|=
operator|(
name|lba
operator|>>
literal|20
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|wait_mode
operator|==
literal|0xff
condition|)
block|{
name|printf
argument_list|(
literal|"Device not waiting to enter lower power "
literal|"condition"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mode_name
operator|=
name|scsi_nv_to_str
argument_list|(
name|epc_power_cond_map
argument_list|,
sizeof|sizeof
argument_list|(
name|epc_power_cond_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|epc_power_cond_map
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|wait_mode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Device waiting to enter mode %s (0x%02x)\n"
argument_list|,
operator|(
name|mode_name
operator|!=
name|NULL
operator|)
condition|?
name|mode_name
else|:
literal|"Unknown"
argument_list|,
name|wait_mode
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Device is %sheld in the current power condition\n"
argument_list|,
operator|(
name|lba
operator|&
literal|0x80000
operator|)
condition|?
literal|""
else|:
literal|"NOT "
argument_list|)
expr_stmt|;
block|}
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epc_set_features
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|camcontrol_devtype
name|devtype
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|action
parameter_list|,
name|int
name|power_cond
parameter_list|,
name|int
name|timer
parameter_list|,
name|int
name|enable
parameter_list|,
name|int
name|save
parameter_list|,
name|int
name|delayed_entry
parameter_list|,
name|int
name|hold
parameter_list|,
name|int
name|power_src
parameter_list|,
name|int
name|restore_src
parameter_list|)
block|{
name|uint64_t
name|lba
decl_stmt|;
name|uint16_t
name|count
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|lba
operator|=
name|action
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|ATA_SF_EPC_SET_TIMER
case|:
name|lba
operator||=
operator|(
operator|(
name|timer
operator|<<
name|ATA_SF_EPC_TIMER_SHIFT
operator|)
operator|&
name|ATA_SF_EPC_TIMER_MASK
operator|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|ATA_SF_EPC_SET_STATE
case|:
name|lba
operator||=
operator|(
name|enable
condition|?
name|ATA_SF_EPC_TIMER_EN
else|:
literal|0
operator|)
operator||
operator|(
name|save
condition|?
name|ATA_SF_EPC_TIMER_SAVE
else|:
literal|0
operator|)
expr_stmt|;
name|count
operator|=
name|power_cond
expr_stmt|;
break|break;
case|case
name|ATA_SF_EPC_GOTO
case|:
name|count
operator|=
name|power_cond
expr_stmt|;
name|lba
operator||=
operator|(
name|delayed_entry
condition|?
name|ATA_SF_EPC_GOTO_DELAY
else|:
literal|0
operator|)
operator||
operator|(
name|hold
condition|?
name|ATA_SF_EPC_GOTO_HOLD
else|:
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|ATA_SF_EPC_RESTORE
case|:
name|lba
operator||=
name|restore_src
operator||
operator|(
name|save
condition|?
name|ATA_SF_EPC_RST_SAVE
else|:
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|ATA_SF_EPC_ENABLE
case|:
case|case
name|ATA_SF_EPC_DISABLE
case|:
break|break;
case|case
name|ATA_SF_EPC_SET_SOURCE
case|:
name|count
operator|=
name|power_src
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|build_ata_cmd
argument_list|(
name|ccb
argument_list|,
comment|/*retry_count*/
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
operator||
name|CAM_DEV_QFRZDIS
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*protocol*/
name|AP_PROTO_NON_DATA
operator||
name|AP_EXTEND
argument_list|,
comment|/*ata_flags*/
name|AP_FLAG_BYT_BLOK_BLOCKS
operator||
name|AP_FLAG_TLEN_NO_DATA
operator||
name|AP_FLAG_TDIR_FROM_DEV
argument_list|,
comment|/*features*/
name|ATA_SF_EPC
argument_list|,
comment|/*sector_count*/
name|count
argument_list|,
comment|/*lba*/
name|lba
argument_list|,
comment|/*command*/
name|ATA_SETFEATURES
argument_list|,
comment|/*auxiliary*/
literal|0
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
comment|/*cdb_storage*/
name|NULL
argument_list|,
comment|/*cdb_storage_len*/
literal|0
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|60000
argument_list|,
comment|/*is48bit*/
literal|1
argument_list|,
comment|/*devtype*/
name|devtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: build_ata_cmd() failed, likely a programmer error"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|retry_count
operator|>
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
name|error
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending ATA SET FEATURES CCB"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bailout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|epc
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|verbosemode
name|__unused
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|action
init|=
operator|-
literal|1
decl_stmt|;
name|camcontrol_devtype
name|devtype
decl_stmt|;
name|double
name|timer_val
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|timer_tenths
init|=
literal|0
decl_stmt|,
name|power_cond
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|delayed_entry
init|=
literal|0
decl_stmt|,
name|hold
init|=
literal|0
decl_stmt|;
name|int
name|enable
init|=
operator|-
literal|1
decl_stmt|,
name|save
init|=
literal|0
decl_stmt|;
name|int
name|restore_src
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|power_src
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|power_only
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating CCB"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|CCB_CLEAR_ALL_EXCEPT_HDR
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
block|{
name|scsi_nv_status
name|status
decl_stmt|;
name|int
name|entry_num
decl_stmt|;
name|status
operator|=
name|scsi_get_nv
argument_list|(
name|epc_cmd_map
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|epc_cmd_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|epc_cmd_map
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|,
name|optarg
argument_list|,
operator|&
name|entry_num
argument_list|,
name|SCSI_NV_FLAG_IG_CASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCSI_NV_FOUND
condition|)
name|action
operator|=
name|epc_cmd_map
index|[
name|entry_num
index|]
operator|.
name|value
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"%s: %s: %s option %s"
argument_list|,
name|__func__
argument_list|,
operator|(
name|status
operator|==
name|SCSI_NV_AMBIGUOUS
operator|)
condition|?
literal|"ambiguous"
else|:
literal|"invalid"
argument_list|,
literal|"epc command"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
block|}
case|case
literal|'d'
case|:
name|enable
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|delayed_entry
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|enable
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|hold
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
block|{
name|scsi_nv_status
name|status
decl_stmt|;
name|int
name|entry_num
decl_stmt|;
name|status
operator|=
name|scsi_get_nv
argument_list|(
name|epc_power_cond_map
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|epc_power_cond_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|epc_power_cond_map
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|,
name|optarg
argument_list|,
operator|&
name|entry_num
argument_list|,
name|SCSI_NV_FLAG_IG_CASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCSI_NV_FOUND
condition|)
name|power_cond
operator|=
name|epc_power_cond_map
index|[
name|entry_num
index|]
operator|.
name|value
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"%s: %s: %s option %s"
argument_list|,
name|__func__
argument_list|,
operator|(
name|status
operator|==
name|SCSI_NV_AMBIGUOUS
operator|)
condition|?
literal|"ambiguous"
else|:
literal|"invalid"
argument_list|,
literal|"power condition"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
block|}
case|case
literal|'P'
case|:
name|power_only
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
block|{
name|scsi_nv_status
name|status
decl_stmt|;
name|int
name|entry_num
decl_stmt|;
name|status
operator|=
name|scsi_get_nv
argument_list|(
name|epc_rst_val
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|epc_rst_val
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|epc_rst_val
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|,
name|optarg
argument_list|,
operator|&
name|entry_num
argument_list|,
name|SCSI_NV_FLAG_IG_CASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCSI_NV_FOUND
condition|)
name|restore_src
operator|=
name|epc_rst_val
index|[
name|entry_num
index|]
operator|.
name|value
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"%s: %s: %s option %s"
argument_list|,
name|__func__
argument_list|,
operator|(
name|status
operator|==
name|SCSI_NV_AMBIGUOUS
operator|)
condition|?
literal|"ambiguous"
else|:
literal|"invalid"
argument_list|,
literal|"restore value source"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
block|}
case|case
literal|'s'
case|:
name|save
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
block|{
name|scsi_nv_status
name|status
decl_stmt|;
name|int
name|entry_num
decl_stmt|;
name|status
operator|=
name|scsi_get_nv
argument_list|(
name|epc_ps_map
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|epc_ps_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|epc_ps_map
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|,
name|optarg
argument_list|,
operator|&
name|entry_num
argument_list|,
name|SCSI_NV_FLAG_IG_CASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCSI_NV_FOUND
condition|)
name|power_src
operator|=
name|epc_ps_map
index|[
name|entry_num
index|]
operator|.
name|value
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"%s: %s: %s option %s"
argument_list|,
name|__func__
argument_list|,
operator|(
name|status
operator|==
name|SCSI_NV_AMBIGUOUS
operator|)
condition|?
literal|"ambiguous"
else|:
literal|"invalid"
argument_list|,
literal|"power source"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
block|}
case|case
literal|'T'
case|:
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|timer_val
operator|=
name|strtod
argument_list|(
name|optarg
argument_list|,
operator|&
name|endptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|timer_val
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid timer value %f"
argument_list|,
name|timer_val
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid timer value %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|timer_tenths
operator|=
name|timer_val
operator|*
literal|10
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|action
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"Must specify an action"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|error
operator|=
name|get_device_type
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
comment|/*printerrors*/
literal|1
argument_list|,
operator|&
name|devtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unable to determine device type"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|devtype
condition|)
block|{
case|case
name|CC_DT_ATA
case|:
case|case
name|CC_DT_ATA_BEHIND_SCSI
case|:
break|break;
default|default:
name|warnx
argument_list|(
literal|"The epc subcommand only works with ATA protocol "
literal|"devices"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/*NOTREACHED*/
block|}
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|ATA_SF_EPC_SET_TIMER
case|:
if|if
condition|(
name|timer_val
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"Must specify a timer value (-T time)"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
case|case
name|ATA_SF_EPC_SET_STATE
case|:
if|if
condition|(
name|enable
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"Must specify enable (-e) or disable (-d)"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|ATA_SF_EPC_GOTO
case|:
if|if
condition|(
name|power_cond
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"Must specify a power condition with -p"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
break|break;
case|case
name|ATA_SF_EPC_SET_SOURCE
case|:
if|if
condition|(
name|power_src
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"Must specify a power source (-S battery or "
literal|"-S notbattery) value"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
case|case
name|ATA_SF_EPC_RESTORE
case|:
if|if
condition|(
name|restore_src
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"Must specify a source for restored value, "
literal|"-r default or -r saved"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
case|case
name|ATA_SF_EPC_ENABLE
case|:
case|case
name|ATA_SF_EPC_DISABLE
case|:
case|case
name|CCTL_EPC_GET_STATUS
case|:
case|case
name|CCTL_EPC_LIST
case|:
default|default:
break|break;
block|}
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|CCTL_EPC_GET_STATUS
case|:
name|error
operator|=
name|epc_getmode
argument_list|(
name|device
argument_list|,
name|devtype
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|power_only
argument_list|)
expr_stmt|;
break|break;
case|case
name|CCTL_EPC_LIST
case|:
name|error
operator|=
name|epc_list
argument_list|(
name|device
argument_list|,
name|devtype
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATA_SF_EPC_RESTORE
case|:
case|case
name|ATA_SF_EPC_GOTO
case|:
case|case
name|ATA_SF_EPC_SET_TIMER
case|:
case|case
name|ATA_SF_EPC_SET_STATE
case|:
case|case
name|ATA_SF_EPC_ENABLE
case|:
case|case
name|ATA_SF_EPC_DISABLE
case|:
case|case
name|ATA_SF_EPC_SET_SOURCE
case|:
name|error
operator|=
name|epc_set_features
argument_list|(
name|device
argument_list|,
name|devtype
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|action
argument_list|,
name|power_cond
argument_list|,
name|timer_tenths
argument_list|,
name|enable
argument_list|,
name|save
argument_list|,
name|delayed_entry
argument_list|,
name|hold
argument_list|,
name|power_src
argument_list|,
name|restore_src
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"Not implemented yet"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
block|}
name|bailout
label|:
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

