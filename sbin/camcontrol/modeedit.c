begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Kelly Yancey<kbyanc@posi.net>  * Derived from work done by Julian Elischer<julian@tfs.com,  * julian@dialix.oz.au>, 1993, and Peter Dufault<dufault@hda.com>, 1994.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.   *      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.    * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<camlib.h>
end_include

begin_include
include|#
directive|include
file|"camcontrol.h"
end_include

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEFAULT_SCSI_MODE_DB
value|"/usr/share/misc/scsi_modes"
end_define

begin_define
define|#
directive|define
name|DEFAULT_EDITOR
value|"vi"
end_define

begin_define
define|#
directive|define
name|MAX_FORMAT_SPEC
value|4096
end_define

begin_comment
comment|/* Max CDB format specifier. */
end_comment

begin_define
define|#
directive|define
name|MAX_PAGENUM_LEN
value|10
end_define

begin_comment
comment|/* Max characters in page num. */
end_comment

begin_define
define|#
directive|define
name|MAX_PAGENAME_LEN
value|64
end_define

begin_comment
comment|/* Max characters in page name. */
end_comment

begin_define
define|#
directive|define
name|PAGEDEF_START
value|'{'
end_define

begin_comment
comment|/* Page definition delimiter. */
end_comment

begin_define
define|#
directive|define
name|PAGEDEF_END
value|'}'
end_define

begin_comment
comment|/* Page definition delimiter. */
end_comment

begin_define
define|#
directive|define
name|PAGENAME_START
value|'"'
end_define

begin_comment
comment|/* Page name delimiter. */
end_comment

begin_define
define|#
directive|define
name|PAGENAME_END
value|'"'
end_define

begin_comment
comment|/* Page name delimiter. */
end_comment

begin_define
define|#
directive|define
name|PAGEENTRY_END
value|';'
end_define

begin_comment
comment|/* Page entry terminator (optional). */
end_comment

begin_define
define|#
directive|define
name|MAX_COMMAND_SIZE
value|255
end_define

begin_comment
comment|/* Mode/Log sense data buffer size. */
end_comment

begin_define
define|#
directive|define
name|PAGE_CTRL_SHIFT
value|6
end_define

begin_comment
comment|/* Bit offset to page control field. */
end_comment

begin_comment
comment|/* Macros for working with mode pages. */
end_comment

begin_define
define|#
directive|define
name|MODE_PAGE_HEADER
parameter_list|(
name|mh
parameter_list|)
define|\
value|(struct scsi_mode_page_header *)find_mode_page_6(mh)
end_define

begin_define
define|#
directive|define
name|MODE_PAGE_DATA
parameter_list|(
name|mph
parameter_list|)
define|\
value|(u_int8_t *)(mph) + sizeof(struct scsi_mode_page_header)
end_define

begin_struct
struct|struct
name|editentry
block|{
name|STAILQ_ENTRY
argument_list|(
argument|editentry
argument_list|)
name|link
expr_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|type
decl_stmt|;
name|int
name|editable
decl_stmt|;
name|int
name|size
decl_stmt|;
union|union
block|{
name|int
name|ivalue
decl_stmt|;
name|char
modifier|*
name|svalue
decl_stmt|;
block|}
name|value
union|;
block|}
struct|;
end_struct

begin_macro
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|editentry
argument_list|)
end_macro

begin_expr_stmt
name|editlist
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* List of page entries. */
end_comment

begin_decl_stmt
name|int
name|editlist_changed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether any entries were changed. */
end_comment

begin_struct
struct|struct
name|pagename
block|{
name|SLIST_ENTRY
argument_list|(
argument|pagename
argument_list|)
name|link
expr_stmt|;
name|int
name|pagenum
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|pagename
argument_list|)
end_macro

begin_expr_stmt
name|namelist
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Page number to name mappings. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|format
index|[
name|MAX_FORMAT_SPEC
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for scsi cdb format def. */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|edit_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File handle for edit file. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|edit_path
index|[]
init|=
literal|"/tmp/camXXXXXX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function prototypes. */
end_comment

begin_function_decl
specifier|static
name|void
name|editentry_create
parameter_list|(
name|void
modifier|*
name|hook
parameter_list|,
name|int
name|letter
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|count
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|editentry_update
parameter_list|(
name|void
modifier|*
name|hook
parameter_list|,
name|int
name|letter
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|count
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|editentry_save
parameter_list|(
name|void
modifier|*
name|hook
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|editentry
modifier|*
name|editentry_lookup
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|editentry_set
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|newvalue
parameter_list|,
name|int
name|editonly
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|editlist_populate
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|modepage
parameter_list|,
name|int
name|page_control
parameter_list|,
name|int
name|dbd
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|editlist_save
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|modepage
parameter_list|,
name|int
name|page_control
parameter_list|,
name|int
name|dbd
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nameentry_create
parameter_list|(
name|int
name|pagenum
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pagename
modifier|*
name|nameentry_lookup
parameter_list|(
name|int
name|pagenum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|load_format
parameter_list|(
name|char
modifier|*
name|pagedb_path
parameter_list|,
name|int
name|page
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|modepage_write
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|editonly
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|modepage_read
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|modepage_edit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|modepage_dump
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|page
parameter_list|,
name|int
name|page_control
parameter_list|,
name|int
name|dbd
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cleanup_editfile
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mode_edit
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|page
parameter_list|,
name|int
name|page_control
parameter_list|,
name|int
name|dbd
parameter_list|,
name|int
name|edit
parameter_list|,
name|int
name|binary
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mode_list
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|page_control
parameter_list|,
name|int
name|dbd
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|returnerr
parameter_list|(
name|code
parameter_list|)
value|do {						\ 	errno = code;							\ 	return (-1);							\ } while (0)
end_define

begin_define
define|#
directive|define
name|RTRIM
parameter_list|(
name|string
parameter_list|)
value|do {						\ 	register int _length;						\ 	while (isspace(string[_length = strlen(string) - 1]))		\ 		string[_length] = '\0';					\ } while (0)
end_define

begin_function
specifier|static
name|void
name|editentry_create
parameter_list|(
name|void
modifier|*
name|hook
parameter_list|,
name|int
name|letter
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|count
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|editentry
modifier|*
name|newentry
decl_stmt|;
comment|/* Buffer to hold new entry. */
comment|/* Allocate memory for the new entry and a copy of the entry name. */
if|if
condition|(
operator|(
name|newentry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|editentry
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|newentry
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Trim any trailing whitespace for the entry name. */
name|RTRIM
argument_list|(
name|newentry
operator|->
name|name
argument_list|)
expr_stmt|;
name|newentry
operator|->
name|editable
operator|=
operator|(
name|arg
operator|!=
name|NULL
operator|)
expr_stmt|;
name|newentry
operator|->
name|type
operator|=
name|letter
expr_stmt|;
name|newentry
operator|->
name|size
operator|=
name|count
expr_stmt|;
comment|/* Placeholder; not accurate. */
name|newentry
operator|->
name|value
operator|.
name|svalue
operator|=
name|NULL
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|editlist
argument_list|,
name|newentry
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|editentry_update
parameter_list|(
name|void
modifier|*
name|hook
parameter_list|,
name|int
name|letter
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|count
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|editentry
modifier|*
name|dest
decl_stmt|;
comment|/* Buffer to hold entry to update. */
name|dest
operator|=
name|editentry_lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dest
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dest
operator|->
name|type
operator|=
name|letter
expr_stmt|;
name|dest
operator|->
name|size
operator|=
name|count
expr_stmt|;
comment|/* We get the real size now. */
switch|switch
condition|(
name|dest
operator|->
name|type
condition|)
block|{
case|case
literal|'i'
case|:
comment|/* Byte-sized integral type. */
case|case
literal|'b'
case|:
comment|/* Bit-sized integral types. */
case|case
literal|'t'
case|:
name|dest
operator|->
name|value
operator|.
name|ivalue
operator|=
operator|(
name|intptr_t
operator|)
name|arg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Character array. */
case|case
literal|'z'
case|:
comment|/* Null-padded string. */
name|editentry_set
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|editentry_save
parameter_list|(
name|void
modifier|*
name|hook
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|editentry
modifier|*
name|src
decl_stmt|;
comment|/* Entry value to save. */
name|src
operator|=
name|editentry_lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|src
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|src
operator|->
name|type
condition|)
block|{
case|case
literal|'i'
case|:
comment|/* Byte-sized integral type. */
case|case
literal|'b'
case|:
comment|/* Bit-sized integral types. */
case|case
literal|'t'
case|:
return|return
operator|(
name|src
operator|->
name|value
operator|.
name|ivalue
operator|)
return|;
comment|/* NOTREACHED */
case|case
literal|'c'
case|:
comment|/* Character array. */
case|case
literal|'z'
case|:
comment|/* Null-padded string. */
return|return
operator|(
operator|(
name|intptr_t
operator|)
name|src
operator|->
name|value
operator|.
name|svalue
operator|)
return|;
comment|/* NOTREACHED */
default|default:
comment|/* NOTREACHED */
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* This should never happen. */
block|}
end_function

begin_function
specifier|static
name|struct
name|editentry
modifier|*
name|editentry_lookup
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|editentry
modifier|*
name|scan
decl_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|scan
argument_list|,
argument|&editlist
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|scan
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|scan
operator|)
return|;
block|}
comment|/* Not found during list traversal. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|editentry_set
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|newvalue
parameter_list|,
name|int
name|editonly
parameter_list|)
block|{
name|struct
name|editentry
modifier|*
name|dest
decl_stmt|;
comment|/* Modepage entry to update. */
name|char
modifier|*
name|cval
decl_stmt|;
comment|/* Pointer to new string value. */
name|char
modifier|*
name|convertend
decl_stmt|;
comment|/* End-of-conversion pointer. */
name|int
name|ival
decl_stmt|;
comment|/* New integral value. */
name|int
name|resolution
decl_stmt|;
comment|/* Resolution in bits for integer conversion. */
comment|/*  * Macro to determine the maximum value of the given size for the current  * resolution.  * XXX Lovely x86's optimize out the case of shifting by 32 and gcc doesn't  *     currently workaround it (even for int64's), so we have to kludge it.  */
define|#
directive|define
name|RESOLUTION_MAX
parameter_list|(
name|size
parameter_list|)
value|((resolution * (size) == 32)? 		\ 	0xffffffff: (1<< (resolution * (size))) - 1)
name|assert
argument_list|(
name|newvalue
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|newvalue
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Nothing to do. */
if|if
condition|(
operator|(
name|dest
operator|=
name|editentry_lookup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|returnerr
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dest
operator|->
name|editable
operator|&&
name|editonly
condition|)
name|returnerr
argument_list|(
name|EPERM
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dest
operator|->
name|type
condition|)
block|{
case|case
literal|'i'
case|:
comment|/* Byte-sized integral type. */
case|case
literal|'b'
case|:
comment|/* Bit-sized integral types. */
case|case
literal|'t'
case|:
comment|/* Convert the value string to an integer. */
name|resolution
operator|=
operator|(
name|dest
operator|->
name|type
operator|==
literal|'i'
operator|)
condition|?
literal|8
else|:
literal|1
expr_stmt|;
name|ival
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|newvalue
argument_list|,
operator|&
name|convertend
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|convertend
operator|!=
literal|'\0'
condition|)
name|returnerr
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ival
operator|>
name|RESOLUTION_MAX
argument_list|(
name|dest
operator|->
name|size
argument_list|)
operator|||
name|ival
operator|<
literal|0
condition|)
block|{
name|int
name|newival
init|=
operator|(
name|ival
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|RESOLUTION_MAX
argument_list|(
name|dest
operator|->
name|size
argument_list|)
decl_stmt|;
name|warnx
argument_list|(
literal|"value %d is out of range for entry %s; clipping "
literal|"to %d"
argument_list|,
name|ival
argument_list|,
name|name
argument_list|,
name|newival
argument_list|)
expr_stmt|;
name|ival
operator|=
name|newival
expr_stmt|;
block|}
if|if
condition|(
name|dest
operator|->
name|value
operator|.
name|ivalue
operator|!=
name|ival
condition|)
name|editlist_changed
operator|=
literal|1
expr_stmt|;
name|dest
operator|->
name|value
operator|.
name|ivalue
operator|=
name|ival
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Character array. */
case|case
literal|'z'
case|:
comment|/* Null-padded string. */
if|if
condition|(
operator|(
name|cval
operator|=
name|malloc
argument_list|(
name|dest
operator|->
name|size
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cval
argument_list|,
name|dest
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cval
argument_list|,
name|newvalue
argument_list|,
name|dest
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|type
operator|==
literal|'z'
condition|)
block|{
comment|/* Convert trailing spaces to nulls. */
name|char
modifier|*
name|convertend
decl_stmt|;
for|for
control|(
name|convertend
operator|=
name|cval
operator|+
name|dest
operator|->
name|size
init|;
name|convertend
operator|>=
name|cval
condition|;
name|convertend
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|convertend
operator|==
literal|' '
condition|)
operator|*
name|convertend
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|convertend
operator|!=
literal|'\0'
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|dest
operator|->
name|value
operator|.
name|svalue
argument_list|,
name|cval
argument_list|,
name|dest
operator|->
name|size
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Nothing changed, free the newly allocated string. */
name|free
argument_list|(
name|cval
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dest
operator|->
name|value
operator|.
name|svalue
operator|!=
name|NULL
condition|)
block|{
comment|/* Free the current string buffer. */
name|free
argument_list|(
name|dest
operator|->
name|value
operator|.
name|svalue
argument_list|)
expr_stmt|;
name|dest
operator|->
name|value
operator|.
name|svalue
operator|=
name|NULL
expr_stmt|;
block|}
name|dest
operator|->
name|value
operator|.
name|svalue
operator|=
name|cval
expr_stmt|;
name|editlist_changed
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* NOTREACHED */
block|}
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|RESOLUTION_MAX
block|}
end_function

begin_function
specifier|static
name|void
name|nameentry_create
parameter_list|(
name|int
name|pagenum
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|pagename
modifier|*
name|newentry
decl_stmt|;
if|if
condition|(
name|pagenum
operator|<
literal|0
operator|||
name|name
operator|==
name|NULL
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return;
comment|/* Allocate memory for the new entry and a copy of the entry name. */
if|if
condition|(
operator|(
name|newentry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pagename
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|newentry
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Trim any trailing whitespace for the page name. */
name|RTRIM
argument_list|(
name|newentry
operator|->
name|name
argument_list|)
expr_stmt|;
name|newentry
operator|->
name|pagenum
operator|=
name|pagenum
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|namelist
argument_list|,
name|newentry
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pagename
modifier|*
name|nameentry_lookup
parameter_list|(
name|int
name|pagenum
parameter_list|)
block|{
name|struct
name|pagename
modifier|*
name|scan
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|scan
argument_list|,
argument|&namelist
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|pagenum
operator|==
name|scan
operator|->
name|pagenum
condition|)
return|return
operator|(
name|scan
operator|)
return|;
block|}
comment|/* Not found during list traversal. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|load_format
parameter_list|(
name|char
modifier|*
name|pagedb_path
parameter_list|,
name|int
name|page
parameter_list|)
block|{
name|FILE
modifier|*
name|pagedb
decl_stmt|;
name|char
name|str_pagenum
index|[
name|MAX_PAGENUM_LEN
index|]
decl_stmt|;
name|char
name|str_pagename
index|[
name|MAX_PAGENAME_LEN
index|]
decl_stmt|;
name|int
name|pagenum
decl_stmt|;
name|int
name|depth
decl_stmt|;
comment|/* Quoting depth. */
name|int
name|found
decl_stmt|;
name|int
name|lineno
decl_stmt|;
enum|enum
block|{
name|LOCATE
block|,
name|PAGENAME
block|,
name|PAGEDEF
block|}
name|state
enum|;
name|char
name|c
decl_stmt|;
define|#
directive|define
name|SETSTATE_LOCATE
value|do {						\ 	str_pagenum[0] = '\0';						\ 	str_pagename[0] = '\0';						\ 	pagenum = -1;							\ 	state = LOCATE;							\ } while (0)
define|#
directive|define
name|SETSTATE_PAGENAME
value|do {						\ 	str_pagename[0] = '\0';						\ 	state = PAGENAME;						\ } while (0)
define|#
directive|define
name|SETSTATE_PAGEDEF
value|do {						\ 	format[0] = '\0';						\ 	state = PAGEDEF;						\ } while (0)
define|#
directive|define
name|UPDATE_LINENO
value|do {						\ 	if (c == '\n')							\ 		lineno++;						\ } while (0)
define|#
directive|define
name|BUFFERFULL
parameter_list|(
name|buffer
parameter_list|)
value|(strlen(buffer) + 1>= sizeof(buffer))
if|if
condition|(
operator|(
name|pagedb
operator|=
name|fopen
argument_list|(
name|pagedb_path
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|returnerr
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|namelist
argument_list|)
expr_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|SETSTATE_LOCATE
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|pagedb
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
comment|/* Keep a line count to make error messages more useful. */
name|UPDATE_LINENO
expr_stmt|;
comment|/* Skip over comments anywhere in the mode database. */
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
do|do
block|{
name|c
operator|=
name|fgetc
argument_list|(
name|pagedb
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
name|UPDATE_LINENO
expr_stmt|;
continue|continue;
block|}
comment|/* Strip out newline characters. */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
comment|/* Keep track of the nesting depth for braces. */
if|if
condition|(
name|c
operator|==
name|PAGEDEF_START
condition|)
name|depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|PAGEDEF_END
condition|)
block|{
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|depth
operator|<
literal|0
condition|)
block|{
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"%s:%d: %s"
argument_list|,
name|pagedb_path
argument_list|,
name|lineno
argument_list|,
literal|"mismatched bracket"
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|LOCATE
case|:
comment|/* 			 * Locate the page the user is interested in, skipping 			 * all others. 			 */
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* Ignore all whitespace between pages. */
break|break;
block|}
elseif|else
if|if
condition|(
name|depth
operator|==
literal|0
operator|&&
name|c
operator|==
name|PAGEENTRY_END
condition|)
block|{
comment|/* 				 * A page entry terminator will reset page 				 * scanning (useful for assigning names to 				 * modes without providing a mode definition). 				 */
comment|/* Record the name of this page. */
name|pagenum
operator|=
name|strtol
argument_list|(
name|str_pagenum
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nameentry_create
argument_list|(
name|pagenum
argument_list|,
name|str_pagename
argument_list|)
expr_stmt|;
name|SETSTATE_LOCATE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|depth
operator|==
literal|0
operator|&&
name|c
operator|==
name|PAGENAME_START
condition|)
block|{
name|SETSTATE_PAGENAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|PAGEDEF_START
condition|)
block|{
name|pagenum
operator|=
name|strtol
argument_list|(
name|str_pagenum
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|1
condition|)
block|{
comment|/* Record the name of this page. */
name|nameentry_create
argument_list|(
name|pagenum
argument_list|,
name|str_pagename
argument_list|)
expr_stmt|;
comment|/* 					 * Only record the format if this is 					 * the page we are interested in. 					 */
if|if
condition|(
name|page
operator|==
name|pagenum
operator|&&
operator|!
name|found
condition|)
name|SETSTATE_PAGEDEF
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|PAGEDEF_END
condition|)
block|{
comment|/* Reset the processor state. */
name|SETSTATE_LOCATE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|depth
operator|==
literal|0
operator|&&
operator|!
name|BUFFERFULL
argument_list|(
name|str_pagenum
argument_list|)
condition|)
block|{
name|strncat
argument_list|(
name|str_pagenum
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
block|{
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"%s:%d: %s %d %s"
argument_list|,
name|pagedb_path
argument_list|,
name|lineno
argument_list|,
literal|"page identifier exceeds"
argument_list|,
sizeof|sizeof
argument_list|(
name|str_pagenum
argument_list|)
operator|-
literal|1
argument_list|,
literal|"characters"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PAGENAME
case|:
if|if
condition|(
name|c
operator|==
name|PAGENAME_END
condition|)
block|{
comment|/* 				 * Return to LOCATE state without resetting the 				 * page number buffer. 				 */
name|state
operator|=
name|LOCATE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|BUFFERFULL
argument_list|(
name|str_pagename
argument_list|)
condition|)
block|{
name|strncat
argument_list|(
name|str_pagename
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"%s:%d: %s %d %s"
argument_list|,
name|pagedb_path
argument_list|,
name|lineno
argument_list|,
literal|"page name exceeds"
argument_list|,
sizeof|sizeof
argument_list|(
name|str_pagenum
argument_list|)
operator|-
literal|1
argument_list|,
literal|"characters"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PAGEDEF
case|:
comment|/* 			 * Transfer the page definition into a format buffer 			 * suitable for use with CDB encoding/decoding routines. 			 */
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|SETSTATE_LOCATE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|BUFFERFULL
argument_list|(
name|format
argument_list|)
condition|)
block|{
name|strncat
argument_list|(
name|format
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"%s:%d: %s %d %s"
argument_list|,
name|pagedb_path
argument_list|,
name|lineno
argument_list|,
literal|"page definition exceeds"
argument_list|,
sizeof|sizeof
argument_list|(
name|format
argument_list|)
operator|-
literal|1
argument_list|,
literal|"characters"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* NOTREACHED */
block|}
comment|/* Repeat processing loop with next character. */
block|}
if|if
condition|(
name|ferror
argument_list|(
name|pagedb
argument_list|)
condition|)
name|err
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"%s"
argument_list|,
name|pagedb_path
argument_list|)
expr_stmt|;
comment|/* Close the SCSI page database. */
name|fclose
argument_list|(
name|pagedb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
comment|/* Never found a matching page. */
name|returnerr
argument_list|(
name|ESRCH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|editlist_populate
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|modepage
parameter_list|,
name|int
name|page_control
parameter_list|,
name|int
name|dbd
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|u_int8_t
name|data
index|[
name|MAX_COMMAND_SIZE
index|]
decl_stmt|;
comment|/* Buffer to hold sense data. */
name|u_int8_t
modifier|*
name|mode_pars
decl_stmt|;
comment|/* Pointer to modepage params. */
name|struct
name|scsi_mode_header_6
modifier|*
name|mh
decl_stmt|;
comment|/* Location of mode header. */
name|struct
name|scsi_mode_page_header
modifier|*
name|mph
decl_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|editlist
argument_list|)
expr_stmt|;
comment|/* Fetch changeable values; use to build initial editlist. */
name|mode_sense
argument_list|(
name|device
argument_list|,
name|modepage
argument_list|,
literal|1
argument_list|,
name|dbd
argument_list|,
name|retries
argument_list|,
name|timeout
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|mh
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|data
expr_stmt|;
name|mph
operator|=
name|MODE_PAGE_HEADER
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|mode_pars
operator|=
name|MODE_PAGE_DATA
argument_list|(
name|mph
argument_list|)
expr_stmt|;
comment|/* Decode the value data, creating edit_entries for each value. */
name|buff_decode_visit
argument_list|(
name|mode_pars
argument_list|,
name|mh
operator|->
name|data_length
argument_list|,
name|format
argument_list|,
name|editentry_create
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fetch the current/saved values; use to set editentry values. */
name|mode_sense
argument_list|(
name|device
argument_list|,
name|modepage
argument_list|,
name|page_control
argument_list|,
name|dbd
argument_list|,
name|retries
argument_list|,
name|timeout
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|buff_decode_visit
argument_list|(
name|mode_pars
argument_list|,
name|mh
operator|->
name|data_length
argument_list|,
name|format
argument_list|,
name|editentry_update
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|editlist_save
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|modepage
parameter_list|,
name|int
name|page_control
parameter_list|,
name|int
name|dbd
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|u_int8_t
name|data
index|[
name|MAX_COMMAND_SIZE
index|]
decl_stmt|;
comment|/* Buffer to hold sense data. */
name|u_int8_t
modifier|*
name|mode_pars
decl_stmt|;
comment|/* Pointer to modepage params. */
name|struct
name|scsi_mode_header_6
modifier|*
name|mh
decl_stmt|;
comment|/* Location of mode header. */
name|struct
name|scsi_mode_page_header
modifier|*
name|mph
decl_stmt|;
comment|/* Make sure that something changed before continuing. */
if|if
condition|(
operator|!
name|editlist_changed
condition|)
return|return;
comment|/* 	 * Preload the CDB buffer with the current mode page data. 	 * XXX If buff_encode_visit would return the number of bytes encoded 	 *     we *should* use that to build a header from scratch. As it is 	 *     now, we need mode_sense to find out the page length. 	 */
name|mode_sense
argument_list|(
name|device
argument_list|,
name|modepage
argument_list|,
name|page_control
argument_list|,
name|dbd
argument_list|,
name|retries
argument_list|,
name|timeout
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initial headers& offsets. */
name|mh
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|data
expr_stmt|;
name|mph
operator|=
name|MODE_PAGE_HEADER
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|mode_pars
operator|=
name|MODE_PAGE_DATA
argument_list|(
name|mph
argument_list|)
expr_stmt|;
comment|/* Encode the value data to be passed back to the device. */
name|buff_encode_visit
argument_list|(
name|mode_pars
argument_list|,
name|mh
operator|->
name|data_length
argument_list|,
name|format
argument_list|,
name|editentry_save
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Eliminate block descriptors. */
name|bcopy
argument_list|(
name|mph
argument_list|,
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|mh
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mh
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mph
argument_list|)
operator|+
name|mph
operator|->
name|page_length
argument_list|)
expr_stmt|;
comment|/* Recalculate headers& offsets. */
name|mh
operator|->
name|blk_desc_len
operator|=
literal|0
expr_stmt|;
comment|/* No block descriptors. */
name|mh
operator|->
name|dev_spec
operator|=
literal|0
expr_stmt|;
comment|/* Clear device-specific parameters. */
name|mph
operator|=
name|MODE_PAGE_HEADER
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|mode_pars
operator|=
name|MODE_PAGE_DATA
argument_list|(
name|mph
argument_list|)
expr_stmt|;
name|mph
operator|->
name|page_code
operator|&=
name|SMS_PAGE_CODE
expr_stmt|;
comment|/* Isolate just the page code. */
name|mh
operator|->
name|data_length
operator|=
literal|0
expr_stmt|;
comment|/* Reserved for MODE SELECT command. */
comment|/* 	 * Write the changes back to the device. If the user editted control 	 * page 3 (saved values) then request the changes be permanently 	 * recorded. 	 */
name|mode_select
argument_list|(
name|device
argument_list|,
operator|(
name|page_control
operator|<<
name|PAGE_CTRL_SHIFT
operator|==
name|SMS_PAGE_CTRL_SAVED
operator|)
argument_list|,
name|retries
argument_list|,
name|timeout
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|mh
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mh
argument_list|)
operator|+
name|mh
operator|->
name|blk_desc_len
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mph
argument_list|)
operator|+
name|mph
operator|->
name|page_length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|modepage_write
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|editonly
parameter_list|)
block|{
name|struct
name|editentry
modifier|*
name|scan
decl_stmt|;
name|int
name|written
init|=
literal|0
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|scan
argument_list|,
argument|&editlist
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|scan
operator|->
name|editable
operator|||
operator|!
name|editonly
condition|)
block|{
name|written
operator|++
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|type
operator|==
literal|'c'
operator|||
name|scan
operator|->
name|type
operator|==
literal|'z'
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:  %s\n"
argument_list|,
name|scan
operator|->
name|name
argument_list|,
name|scan
operator|->
name|value
operator|.
name|svalue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:  %d\n"
argument_list|,
name|scan
operator|->
name|name
argument_list|,
name|scan
operator|->
name|value
operator|.
name|ivalue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|written
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|modepage_read
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Pointer to dynamic line buffer.  */
name|char
modifier|*
name|line
decl_stmt|;
comment|/* Pointer to static fgetln buffer. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name portion of the line buffer. */
name|char
modifier|*
name|value
decl_stmt|;
comment|/* Value portion of line buffer.    */
name|int
name|length
decl_stmt|;
comment|/* Length of static fgetln buffer.  */
define|#
directive|define
name|ABORT_READ
parameter_list|(
name|message
parameter_list|,
name|param
parameter_list|)
value|do {					\ 	warnx(message, param);						\ 	free(buffer);							\ 	returnerr(EAGAIN);						\ } while (0)
while|while
condition|(
operator|(
name|line
operator|=
name|fgetln
argument_list|(
name|file
argument_list|,
operator|&
name|length
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Trim trailing whitespace (including optional newline). */
while|while
condition|(
name|length
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
name|line
index|[
name|length
operator|-
literal|1
index|]
argument_list|)
condition|)
name|length
operator|--
expr_stmt|;
comment|/* Allocate a buffer to hold the line + terminating null. */
if|if
condition|(
operator|(
name|buffer
operator|=
name|malloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|line
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|buffer
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Strip out comments. */
if|if
condition|(
operator|(
name|value
operator|=
name|strchr
argument_list|(
name|buffer
argument_list|,
literal|'#'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|value
operator|=
literal|'\0'
expr_stmt|;
comment|/* The name is first in the buffer. Trim whitespace.*/
name|name
operator|=
name|buffer
expr_stmt|;
name|RTRIM
argument_list|(
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|name
argument_list|)
condition|)
name|name
operator|++
expr_stmt|;
comment|/* Skip empty lines. */
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* The name ends at the colon; the value starts there. */
if|if
condition|(
operator|(
name|value
operator|=
name|strrchr
argument_list|(
name|buffer
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ABORT_READ
argument_list|(
literal|"no value associated with %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null-terminate name. */
name|value
operator|++
expr_stmt|;
comment|/* Value starts afterwards. */
comment|/* Trim leading and trailing whitespace. */
name|RTRIM
argument_list|(
name|value
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|value
argument_list|)
condition|)
name|value
operator|++
expr_stmt|;
comment|/* Make sure there is a value left. */
if|if
condition|(
name|strlen
argument_list|(
name|value
argument_list|)
operator|==
literal|0
condition|)
name|ABORT_READ
argument_list|(
literal|"no value associated with %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Update our in-memory copy of the modepage entry value. */
if|if
condition|(
name|editentry_set
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* No entry by the name. */
name|ABORT_READ
argument_list|(
literal|"no such modepage entry \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
block|{
comment|/* Invalid value. */
name|ABORT_READ
argument_list|(
literal|"Invalid value for entry \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
block|{
comment|/* Value out of range for entry type. */
name|ABORT_READ
argument_list|(
literal|"value out of range for %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|EPERM
condition|)
block|{
comment|/* Entry is not editable; not fatal. */
name|warnx
argument_list|(
literal|"modepage entry \"%s\" is read-only; "
literal|"skipping."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ferror
argument_list|(
name|file
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
return|;
undef|#
directive|undef
name|ABORT_READ
block|}
end_function

begin_function
specifier|static
name|void
name|modepage_edit
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|editor
decl_stmt|;
name|char
modifier|*
name|commandline
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|written
decl_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Not a tty, read changes from stdin. */
name|modepage_read
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Lookup editor to invoke. */
if|if
condition|(
operator|(
name|editor
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|editor
operator|=
name|DEFAULT_EDITOR
expr_stmt|;
comment|/* Create temp file for editor to modify. */
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|edit_path
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EX_CANTCREAT
argument_list|,
literal|"mkstemp failed"
argument_list|)
expr_stmt|;
name|atexit
argument_list|(
name|cleanup_editfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|edit_file
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_NOINPUT
argument_list|,
literal|"%s"
argument_list|,
name|edit_path
argument_list|)
expr_stmt|;
name|written
operator|=
name|modepage_write
argument_list|(
name|edit_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|edit_file
argument_list|)
expr_stmt|;
name|edit_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|written
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"no editable entries"
argument_list|)
expr_stmt|;
name|cleanup_editfile
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* 	 * Allocate memory to hold the command line (the 2 extra characters 	 * are to hold the argument separator (a space), and the terminating 	 * null character. 	 */
name|commandline
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|editor
argument_list|)
operator|+
name|strlen
argument_list|(
name|edit_path
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|commandline
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|commandline
argument_list|,
literal|"%s %s"
argument_list|,
name|editor
argument_list|,
name|edit_path
argument_list|)
expr_stmt|;
comment|/* Invoke the editor on the temp file. */
if|if
condition|(
name|system
argument_list|(
name|commandline
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
literal|"could not invoke %s"
argument_list|,
name|editor
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|commandline
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|edit_file
operator|=
name|fopen
argument_list|(
name|edit_path
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_NOINPUT
argument_list|,
literal|"%s"
argument_list|,
name|edit_path
argument_list|)
expr_stmt|;
comment|/* Read any changes made to the temp file. */
name|modepage_read
argument_list|(
name|edit_file
argument_list|)
expr_stmt|;
name|cleanup_editfile
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|modepage_dump
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|page
parameter_list|,
name|int
name|page_control
parameter_list|,
name|int
name|dbd
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|u_int8_t
name|data
index|[
name|MAX_COMMAND_SIZE
index|]
decl_stmt|;
comment|/* Buffer to hold sense data. */
name|u_int8_t
modifier|*
name|mode_pars
decl_stmt|;
comment|/* Pointer to modepage params. */
name|struct
name|scsi_mode_header_6
modifier|*
name|mh
decl_stmt|;
comment|/* Location of mode header. */
name|struct
name|scsi_mode_page_header
modifier|*
name|mph
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* Index for scanning mode params. */
name|mode_sense
argument_list|(
name|device
argument_list|,
name|page
argument_list|,
name|page_control
argument_list|,
name|dbd
argument_list|,
name|retries
argument_list|,
name|timeout
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|mh
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|data
expr_stmt|;
name|mph
operator|=
name|MODE_PAGE_HEADER
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|mode_pars
operator|=
name|MODE_PAGE_DATA
argument_list|(
name|mph
argument_list|)
expr_stmt|;
comment|/* Print the raw mode page data with newlines each 8 bytes. */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|mph
operator|->
name|page_length
condition|;
name|index
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x%c"
argument_list|,
name|mode_pars
index|[
name|index
index|]
argument_list|,
operator|(
operator|(
operator|(
name|index
operator|+
literal|1
operator|)
operator|%
literal|8
operator|)
operator|==
literal|0
operator|)
condition|?
literal|'\n'
else|:
literal|' '
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cleanup_editfile
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|edit_file
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|fclose
argument_list|(
name|edit_file
argument_list|)
operator|!=
literal|0
operator|||
name|unlink
argument_list|(
name|edit_path
argument_list|)
operator|!=
literal|0
condition|)
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|edit_path
argument_list|)
expr_stmt|;
name|edit_file
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mode_edit
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|page
parameter_list|,
name|int
name|page_control
parameter_list|,
name|int
name|dbd
parameter_list|,
name|int
name|edit
parameter_list|,
name|int
name|binary
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|char
modifier|*
name|pagedb_path
decl_stmt|;
comment|/* Path to modepage database. */
if|if
condition|(
name|edit
operator|&&
name|binary
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"cannot edit in binary mode."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binary
condition|)
block|{
if|if
condition|(
operator|(
name|pagedb_path
operator|=
name|getenv
argument_list|(
literal|"SCSI_MODES"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|pagedb_path
operator|=
name|DEFAULT_SCSI_MODE_DB
expr_stmt|;
if|if
condition|(
name|load_format
argument_list|(
name|pagedb_path
argument_list|,
name|page
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|edit
operator|||
name|verbose
operator|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* Modepage database file not found. */
name|warn
argument_list|(
literal|"cannot open modepage database \"%s\""
argument_list|,
name|pagedb_path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ESRCH
condition|)
block|{
comment|/* Modepage entry not found in database. */
name|warnx
argument_list|(
literal|"modepage %d not found in database"
literal|"\"%s\""
argument_list|,
name|page
argument_list|,
name|pagedb_path
argument_list|)
expr_stmt|;
block|}
comment|/* We can recover in display mode, otherwise we exit. */
if|if
condition|(
operator|!
name|edit
condition|)
block|{
name|warnx
argument_list|(
literal|"reverting to binary display only"
argument_list|)
expr_stmt|;
name|binary
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|exit
argument_list|(
name|EX_OSFILE
argument_list|)
expr_stmt|;
block|}
name|editlist_populate
argument_list|(
name|device
argument_list|,
name|page
argument_list|,
name|page_control
argument_list|,
name|dbd
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|edit
condition|)
block|{
if|if
condition|(
name|page_control
operator|<<
name|PAGE_CTRL_SHIFT
operator|!=
name|SMS_PAGE_CTRL_CURRENT
operator|&&
name|page_control
operator|<<
name|PAGE_CTRL_SHIFT
operator|!=
name|SMS_PAGE_CTRL_SAVED
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"it only makes sense to edit page 0 "
literal|"(current) or page 3 (saved values)"
argument_list|)
expr_stmt|;
name|modepage_edit
argument_list|()
expr_stmt|;
name|editlist_save
argument_list|(
name|device
argument_list|,
name|page
argument_list|,
name|page_control
argument_list|,
name|dbd
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|binary
operator|||
name|STAILQ_EMPTY
argument_list|(
operator|&
name|editlist
argument_list|)
condition|)
block|{
comment|/* Display without formatting information. */
name|modepage_dump
argument_list|(
name|device
argument_list|,
name|page
argument_list|,
name|page_control
argument_list|,
name|dbd
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Display with format. */
name|modepage_write
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mode_list
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|page_control
parameter_list|,
name|int
name|dbd
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|u_int8_t
name|data
index|[
name|MAX_COMMAND_SIZE
index|]
decl_stmt|;
comment|/* Buffer to hold sense data. */
name|u_int8_t
modifier|*
name|mode_pars
decl_stmt|;
comment|/* Pointer to modepage params. */
name|struct
name|scsi_mode_header_6
modifier|*
name|mh
decl_stmt|;
comment|/* Location of mode header. */
name|struct
name|scsi_mode_page_header
modifier|*
name|mph
decl_stmt|;
name|struct
name|pagename
modifier|*
name|nameentry
decl_stmt|;
name|char
modifier|*
name|pagedb_path
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|pagedb_path
operator|=
name|getenv
argument_list|(
literal|"SCSI_MODES"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|pagedb_path
operator|=
name|DEFAULT_SCSI_MODE_DB
expr_stmt|;
if|if
condition|(
name|load_format
argument_list|(
name|pagedb_path
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|verbose
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* Modepage database file not found. */
name|warn
argument_list|(
literal|"cannot open modepage database \"%s\""
argument_list|,
name|pagedb_path
argument_list|)
expr_stmt|;
block|}
comment|/* Build the list of all mode pages by querying the "all pages" page. */
name|mode_sense
argument_list|(
name|device
argument_list|,
name|SMS_ALL_PAGES_PAGE
argument_list|,
name|page_control
argument_list|,
name|dbd
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|mh
operator|=
operator|(
expr|struct
name|scsi_mode_header_6
operator|*
operator|)
name|data
expr_stmt|;
name|len
operator|=
name|mh
operator|->
name|blk_desc_len
expr_stmt|;
comment|/* Skip block descriptors. */
comment|/* Iterate through the pages in the reply. */
while|while
condition|(
name|len
operator|<
name|mh
operator|->
name|data_length
condition|)
block|{
comment|/* Locate the next mode page header. */
name|mph
operator|=
operator|(
expr|struct
name|scsi_mode_page_header
operator|*
operator|)
operator|(
operator|(
name|intptr_t
operator|)
name|mh
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mh
argument_list|)
operator|+
name|len
operator|)
expr_stmt|;
name|mode_pars
operator|=
name|MODE_PAGE_DATA
argument_list|(
name|mph
argument_list|)
expr_stmt|;
name|mph
operator|->
name|page_code
operator|&=
name|SMS_PAGE_CODE
expr_stmt|;
name|nameentry
operator|=
name|nameentry_lookup
argument_list|(
name|mph
operator|->
name|page_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameentry
operator|==
name|NULL
operator|||
name|nameentry
operator|->
name|name
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"0x%02x\n"
argument_list|,
name|mph
operator|->
name|page_code
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0x%02x\t%s\n"
argument_list|,
name|mph
operator|->
name|page_code
argument_list|,
name|nameentry
operator|->
name|name
argument_list|)
expr_stmt|;
name|len
operator|+=
name|mph
operator|->
name|page_length
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mph
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

