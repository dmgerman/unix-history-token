begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Sandvine Incorporated. All rights reserved.  * Copyright (c) 2002-2011 Andre Albsmeier<andre@albsmeier.net>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.   *      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.    * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This software is derived from Andre Albsmeier's fwprog.c which contained  * the following note:  *  * Many thanks goes to Marc Frajola<marc@terasolutions.com> from  * TeraSolutions for the initial idea and his programme for upgrading  * the firmware of I*M DDYS drives.  */
end_comment

begin_comment
comment|/*  * BEWARE:  *  * The fact that you see your favorite vendor listed below does not  * imply that your equipment won't break when you use this software  * with it. It only means that the firmware of at least one device type  * of each vendor listed has been programmed successfully using this code.  *  * The -s option simulates a download but does nothing apart from that.  * It can be used to check what chunk sizes would have been used with the  * specified device.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<camlib.h>
end_include

begin_include
include|#
directive|include
file|"progress.h"
end_include

begin_include
include|#
directive|include
file|"camcontrol.h"
end_include

begin_define
define|#
directive|define
name|CMD_TIMEOUT
value|50000
end_define

begin_comment
comment|/* 50 seconds */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|VENDOR_HITACHI
block|,
name|VENDOR_HP
block|,
name|VENDOR_IBM
block|,
name|VENDOR_PLEXTOR
block|,
name|VENDOR_QUALSTAR
block|,
name|VENDOR_QUANTUM
block|,
name|VENDOR_SAMSUNG
block|,
name|VENDOR_SEAGATE
block|,
name|VENDOR_UNKNOWN
block|}
name|fw_vendor_t
typedef|;
end_typedef

begin_struct
struct|struct
name|fw_vendor
block|{
name|fw_vendor_t
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|max_pkt_size
decl_stmt|;
name|u_int8_t
name|cdb_byte2
decl_stmt|;
name|u_int8_t
name|cdb_byte2_last
decl_stmt|;
name|int
name|inc_cdb_buffer_id
decl_stmt|;
name|int
name|inc_cdb_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|fw_vendor
name|vendors_list
index|[]
init|=
block|{
block|{
name|VENDOR_HITACHI
block|,
literal|"HITACHI"
block|,
literal|0x8000
block|,
literal|0x05
block|,
literal|0x05
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|VENDOR_HP
block|,
literal|"HP"
block|,
literal|0x8000
block|,
literal|0x07
block|,
literal|0x07
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|VENDOR_IBM
block|,
literal|"IBM"
block|,
literal|0x8000
block|,
literal|0x05
block|,
literal|0x05
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|VENDOR_PLEXTOR
block|,
literal|"PLEXTOR"
block|,
literal|0x2000
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|VENDOR_QUALSTAR
block|,
literal|"QUALSTAR"
block|,
literal|0x2030
block|,
literal|0x05
block|,
literal|0x05
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|VENDOR_QUANTUM
block|,
literal|"QUANTUM"
block|,
literal|0x2000
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|VENDOR_SAMSUNG
block|,
literal|"SAMSUNG"
block|,
literal|0x8000
block|,
literal|0x07
block|,
literal|0x07
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|VENDOR_SEAGATE
block|,
literal|"SEAGATE"
block|,
literal|0x8000
block|,
literal|0x07
block|,
literal|0x07
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* the next 2 are SATA disks going through SAS HBA */
block|{
name|VENDOR_SEAGATE
block|,
literal|"ATA ST"
block|,
literal|0x8000
block|,
literal|0x07
block|,
literal|0x07
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|VENDOR_HITACHI
block|,
literal|"ATA HDS"
block|,
literal|0x8000
block|,
literal|0x05
block|,
literal|0x05
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|VENDOR_UNKNOWN
block|,
name|NULL
block|,
literal|0x0000
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ATA_DOWNLOAD_MICROCODE
end_ifndef

begin_define
define|#
directive|define
name|ATA_DOWNLOAD_MICROCODE
value|0x92
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|USE_OFFSETS_FEATURE
value|0x3
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|LOW_SECTOR_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LOW_SECTOR_SIZE
value|512
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ATA_MAKE_LBA
parameter_list|(
name|o
parameter_list|,
name|p
parameter_list|)
define|\
value|((((((o) / LOW_SECTOR_SIZE)>> 8)& 0xff)<< 16) | \ 	  ((((o) / LOW_SECTOR_SIZE)& 0xff)<< 8) | \ 	  ((((p) / LOW_SECTOR_SIZE)>> 8)& 0xff))
end_define

begin_define
define|#
directive|define
name|ATA_MAKE_SECTORS
parameter_list|(
name|p
parameter_list|)
value|(((p) / 512)& 0xff)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|UNKNOWN_MAX_PKT_SIZE
end_ifndef

begin_define
define|#
directive|define
name|UNKNOWN_MAX_PKT_SIZE
value|0x8000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|const
name|struct
name|fw_vendor
modifier|*
name|fw_get_vendor
parameter_list|(
name|struct
name|cam_device
modifier|*
name|cam_dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|fw_read_img
parameter_list|(
specifier|const
name|char
modifier|*
name|fw_img_path
parameter_list|,
specifier|const
name|struct
name|fw_vendor
modifier|*
name|vp
parameter_list|,
name|int
modifier|*
name|num_bytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fw_download_img
parameter_list|(
name|struct
name|cam_device
modifier|*
name|cam_dev
parameter_list|,
specifier|const
name|struct
name|fw_vendor
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|img_size
parameter_list|,
name|int
name|sim_mode
parameter_list|,
name|int
name|printerrors
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
specifier|const
name|char
modifier|*
comment|/*name*/
parameter_list|,
specifier|const
name|char
modifier|*
comment|/*type*/
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Find entry in vendors list that belongs to  * the vendor of given cam device.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|fw_vendor
modifier|*
name|fw_get_vendor
parameter_list|(
name|struct
name|cam_device
modifier|*
name|cam_dev
parameter_list|)
block|{
name|char
name|vendor
index|[
name|SID_VENDOR_SIZE
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|struct
name|fw_vendor
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
name|cam_dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cam_strvis
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|vendor
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cam_dev
operator|->
name|inq_data
operator|.
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|cam_dev
operator|->
name|inq_data
operator|.
name|vendor
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|vendors_list
init|;
name|vp
operator|->
name|pattern
operator|!=
name|NULL
condition|;
name|vp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cam_strmatch
argument_list|(
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|vendor
argument_list|,
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|vp
operator|->
name|pattern
argument_list|,
name|strlen
argument_list|(
name|vendor
argument_list|)
argument_list|)
condition|)
break|break;
block|}
return|return
operator|(
name|vp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a buffer and read fw image file into it  * from given path. Number of bytes read is stored  * in num_bytes.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fw_read_img
parameter_list|(
specifier|const
name|char
modifier|*
name|fw_img_path
parameter_list|,
specifier|const
name|struct
name|fw_vendor
modifier|*
name|vp
parameter_list|,
name|int
modifier|*
name|num_bytes
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|off_t
name|img_size
decl_stmt|;
name|int
name|skip_bytes
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fw_img_path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Could not open image file %s"
argument_list|,
name|fw_img_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Could not stat image file %s"
argument_list|,
name|fw_img_path
argument_list|)
expr_stmt|;
goto|goto
name|bailout1
goto|;
block|}
if|if
condition|(
operator|(
name|img_size
operator|=
name|stbuf
operator|.
name|st_size
operator|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Zero length image file %s"
argument_list|,
name|fw_img_path
argument_list|)
expr_stmt|;
goto|goto
name|bailout1
goto|;
block|}
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|img_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Could not allocate buffer to read image file %s"
argument_list|,
name|fw_img_path
argument_list|)
expr_stmt|;
goto|goto
name|bailout1
goto|;
block|}
comment|/* Skip headers if applicable. */
switch|switch
condition|(
name|vp
operator|->
name|type
condition|)
block|{
case|case
name|VENDOR_SEAGATE
case|:
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
literal|16
argument_list|)
operator|!=
literal|16
condition|)
block|{
name|warn
argument_list|(
literal|"Could not read image file %s"
argument_list|,
name|fw_img_path
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"Unable to lseek"
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"SEAGATE,SEAGATE "
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|img_size
operator|%
literal|512
operator|==
literal|80
operator|)
condition|)
name|skip_bytes
operator|=
literal|80
expr_stmt|;
break|break;
case|case
name|VENDOR_QUALSTAR
case|:
name|skip_bytes
operator|=
name|img_size
operator|%
literal|1030
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|skip_bytes
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Skipping %d byte header.\n"
argument_list|,
name|skip_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|skip_bytes
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"Could not lseek"
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|img_size
operator|-=
name|skip_bytes
expr_stmt|;
block|}
comment|/* Read image into a buffer. */
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|img_size
argument_list|)
operator|!=
name|img_size
condition|)
block|{
name|warn
argument_list|(
literal|"Could not read image file %s"
argument_list|,
name|fw_img_path
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
operator|*
name|num_bytes
operator|=
name|img_size
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
name|bailout
label|:
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|bailout1
label|:
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|*
name|num_bytes
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Download firmware stored in buf to cam_dev. If simulation mode  * is enabled, only show what packet sizes would be sent to the   * device but do not sent any actual packets  */
end_comment

begin_function
specifier|static
name|int
name|fw_download_img
parameter_list|(
name|struct
name|cam_device
modifier|*
name|cam_dev
parameter_list|,
specifier|const
name|struct
name|fw_vendor
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|img_size
parameter_list|,
name|int
name|sim_mode
parameter_list|,
name|int
name|printerrors
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
specifier|const
name|char
modifier|*
name|imgname
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|scsi_write_buffer
name|cdb
decl_stmt|;
name|progress_t
name|progress
decl_stmt|;
name|int
name|size
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|pkt_count
init|=
literal|0
decl_stmt|;
name|int
name|max_pkt_size
decl_stmt|;
name|u_int32_t
name|pkt_size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|pkt_ptr
init|=
name|buf
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|;
name|int
name|last_pkt
init|=
literal|0
decl_stmt|;
name|int16_t
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|cam_dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Could not allocate CCB"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"scsi"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scsi_test_unit_ready
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"ata"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* cam_getccb cleans up the header, caller has to zero the payload */
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_ataio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"can't malloc memory for identify\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
argument_list|)
expr_stmt|;
name|cam_fill_ataio
argument_list|(
operator|&
name|ccb
operator|->
name|ataio
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*data_ptr*/
operator|(
name|uint8_t
operator|*
operator|)
name|ptr
argument_list|,
comment|/*dxfer_len*/
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
argument_list|,
name|timeout
condition|?
name|timeout
else|:
literal|30
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|ata_28bit_cmd
argument_list|(
operator|&
name|ccb
operator|->
name|ataio
argument_list|,
name|ATA_ATA_IDENTIFY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"weird disk type '%s'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Disable freezing the device queue. */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|cam_dev
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Error sending identify/test unit ready"
argument_list|)
expr_stmt|;
if|if
condition|(
name|printerrors
condition|)
name|cam_error_print
argument_list|(
name|cam_dev
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"Device is not ready"
argument_list|)
expr_stmt|;
if|if
condition|(
name|printerrors
condition|)
name|cam_error_print
argument_list|(
name|cam_dev
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|max_pkt_size
operator|=
name|vp
operator|->
name|max_pkt_size
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|max_pkt_size
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"ata"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|max_pkt_size
operator|=
name|UNKNOWN_MAX_PKT_SIZE
expr_stmt|;
block|}
name|pkt_size
operator|=
name|vp
operator|->
name|max_pkt_size
expr_stmt|;
name|progress_init
argument_list|(
operator|&
name|progress
argument_list|,
name|imgname
argument_list|,
name|size
operator|=
name|img_size
argument_list|)
expr_stmt|;
comment|/* Download single fw packets. */
do|do
block|{
if|if
condition|(
name|img_size
operator|<=
name|max_pkt_size
condition|)
block|{
name|last_pkt
operator|=
literal|1
expr_stmt|;
name|pkt_size
operator|=
name|img_size
expr_stmt|;
block|}
name|progress_update
argument_list|(
operator|&
name|progress
argument_list|,
name|size
operator|-
name|img_size
argument_list|)
expr_stmt|;
name|progress_draw
argument_list|(
operator|&
name|progress
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"scsi"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cdb
operator|.
name|opcode
operator|=
name|WRITE_BUFFER
expr_stmt|;
name|cdb
operator|.
name|control
operator|=
literal|0
expr_stmt|;
comment|/* Parameter list length. */
name|scsi_ulto3b
argument_list|(
name|pkt_size
argument_list|,
operator|&
name|cdb
operator|.
name|length
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|offset
operator|=
name|vp
operator|->
name|inc_cdb_offset
condition|?
operator|(
name|pkt_ptr
operator|-
name|buf
operator|)
else|:
literal|0
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|offset
argument_list|,
operator|&
name|cdb
operator|.
name|offset
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cdb
operator|.
name|byte2
operator|=
name|last_pkt
condition|?
name|vp
operator|->
name|cdb_byte2_last
else|:
name|vp
operator|->
name|cdb_byte2
expr_stmt|;
name|cdb
operator|.
name|buffer_id
operator|=
name|vp
operator|->
name|inc_cdb_buffer_id
condition|?
name|pkt_count
else|:
literal|0
expr_stmt|;
comment|/* Zero out payload of ccb union after ccb header. */
name|bzero
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|ccb
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy previously constructed cdb into ccb_scsiio struct. */
name|bcopy
argument_list|(
operator|&
name|cdb
argument_list|,
operator|&
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_write_buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill rest of ccb_scsiio struct. */
if|if
condition|(
operator|!
name|sim_mode
condition|)
block|{
name|cam_fill_csio
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* ccb_scsiio	*/
name|retry_count
argument_list|,
comment|/* retries	*/
name|NULL
argument_list|,
comment|/* cbfcnp	*/
name|CAM_DIR_OUT
operator||
name|CAM_DEV_QFRZDIS
argument_list|,
comment|/* flags	*/
name|CAM_TAG_ACTION_NONE
argument_list|,
comment|/* tag_action	*/
operator|(
name|u_char
operator|*
operator|)
name|pkt_ptr
argument_list|,
comment|/* data_ptr	*/
name|pkt_size
argument_list|,
comment|/* dxfer_len	*/
name|SSD_FULL_SIZE
argument_list|,
comment|/* sense_len	*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_write_buffer
argument_list|)
argument_list|,
comment|/* cdb_len	*/
name|timeout
condition|?
name|timeout
else|:
name|CMD_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* timeout	*/
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"ata"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_ataio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sim_mode
condition|)
block|{
name|uint32_t
name|off
decl_stmt|;
name|cam_fill_ataio
argument_list|(
operator|&
name|ccb
operator|->
name|ataio
argument_list|,
operator|(
name|last_pkt
operator|)
condition|?
literal|256
else|:
name|retry_count
argument_list|,
name|NULL
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
operator||
name|CAM_DEV_QFRZDIS
argument_list|,
name|CAM_TAG_ACTION_NONE
argument_list|,
comment|/*data_ptr*/
operator|(
name|uint8_t
operator|*
operator|)
name|pkt_ptr
argument_list|,
comment|/*dxfer_len*/
name|pkt_size
argument_list|,
name|timeout
condition|?
name|timeout
else|:
literal|30
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|off
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|pkt_ptr
operator|-
name|buf
argument_list|)
expr_stmt|;
name|ata_28bit_cmd
argument_list|(
operator|&
name|ccb
operator|->
name|ataio
argument_list|,
name|ATA_DOWNLOAD_MICROCODE
argument_list|,
name|USE_OFFSETS_FEATURE
argument_list|,
name|ATA_MAKE_LBA
argument_list|(
name|off
argument_list|,
name|pkt_size
argument_list|)
argument_list|,
name|ATA_MAKE_SECTORS
argument_list|(
name|pkt_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sim_mode
condition|)
block|{
comment|/* Execute the command. */
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|cam_dev
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"Error writing image to device"
argument_list|)
expr_stmt|;
if|if
condition|(
name|printerrors
condition|)
name|cam_error_print
argument_list|(
name|cam_dev
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
comment|/* Prepare next round. */
name|pkt_count
operator|++
expr_stmt|;
name|pkt_ptr
operator|+=
name|pkt_size
expr_stmt|;
name|img_size
operator|-=
name|pkt_size
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|last_pkt
condition|)
do|;
name|progress_complete
argument_list|(
operator|&
name|progress
argument_list|,
name|size
operator|-
name|img_size
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bailout
label|:
name|progress_complete
argument_list|(
operator|&
name|progress
argument_list|,
name|size
operator|-
name|img_size
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fwdownload
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|printerrors
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|struct
name|fw_vendor
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|fw_img_path
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|img_size
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|sim_mode
init|=
literal|0
decl_stmt|;
name|int
name|confirmed
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'s'
case|:
name|sim_mode
operator|=
literal|1
expr_stmt|;
name|confirmed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fw_img_path
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|confirmed
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|fw_img_path
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"you must specify a firmware image file using -f option"
argument_list|)
expr_stmt|;
name|vp
operator|=
name|fw_get_vendor
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"NULL vendor"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|type
operator|==
name|VENDOR_UNKNOWN
condition|)
name|warnx
argument_list|(
literal|"Unsupported device - flashing through an HBA?"
argument_list|)
expr_stmt|;
name|buf
operator|=
name|fw_read_img
argument_list|(
name|fw_img_path
argument_list|,
name|vp
argument_list|,
operator|&
name|img_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|confirmed
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"You are about to download firmware image (%s)"
literal|" into the following device:\n"
argument_list|,
name|fw_img_path
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nIt may damage your drive. "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_confirmation
argument_list|()
condition|)
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|sim_mode
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Running in simulation mode\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_download_img
argument_list|(
name|device
argument_list|,
name|vp
argument_list|,
name|buf
argument_list|,
name|img_size
argument_list|,
name|sim_mode
argument_list|,
name|printerrors
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|fw_img_path
argument_list|,
name|type
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Firmware download failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Firmware download successful\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

