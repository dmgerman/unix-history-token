begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Sandvine Incorporated. All rights reserved.  * Copyright (c) 2002-2011 Andre Albsmeier<andre@albsmeier.net>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.   *      * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.    * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This software is derived from Andre Albsmeier's fwprog.c which contained  * the following note:  *  * Many thanks goes to Marc Frajola<marc@terasolutions.com> from  * TeraSolutions for the initial idea and his programme for upgrading  * the firmware of I*M DDYS drives.  */
end_comment

begin_comment
comment|/*  * BEWARE:  *  * The fact that you see your favorite vendor listed below does not  * imply that your equipment won't break when you use this software  * with it. It only means that the firmware of at least one device type  * of each vendor listed has been programmed successfully using this code.  *  * The -s option simulates a download but does nothing apart from that.  * It can be used to check what chunk sizes would have been used with the  * specified device.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<camlib.h>
end_include

begin_include
include|#
directive|include
file|"progress.h"
end_include

begin_include
include|#
directive|include
file|"camcontrol.h"
end_include

begin_define
define|#
directive|define
name|WB_TIMEOUT
value|50000
end_define

begin_comment
comment|/* 50 seconds */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|VENDOR_HGST
block|,
name|VENDOR_HITACHI
block|,
name|VENDOR_HP
block|,
name|VENDOR_IBM
block|,
name|VENDOR_PLEXTOR
block|,
name|VENDOR_QUALSTAR
block|,
name|VENDOR_QUANTUM
block|,
name|VENDOR_SAMSUNG
block|,
name|VENDOR_SEAGATE
block|,
name|VENDOR_SMART
block|,
name|VENDOR_ATA
block|,
name|VENDOR_UNKNOWN
block|}
name|fw_vendor_t
typedef|;
end_typedef

begin_comment
comment|/*  * FW_TUR_READY:     The drive must return good status for a test unit ready.  *  * FW_TUR_NOT_READY: The drive must return not ready status for a test unit  *		     ready.  You may want this in a removable media drive.  *  * FW_TUR_NA:	     It doesn't matter whether the drive is ready or not.  * 		     This may be the case for a removable media drive.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|FW_TUR_NONE
block|,
name|FW_TUR_READY
block|,
name|FW_TUR_NOT_READY
block|,
name|FW_TUR_NA
block|}
name|fw_tur_status
typedef|;
end_typedef

begin_comment
comment|/*  * FW_TIMEOUT_DEFAULT:		Attempt to probe for a WRITE BUFFER timeout  *				value from the drive.  If we get an answer,  *				use the Recommended timeout.  Otherwise,  * 				use the default value from the table.  *  * FW_TIMEOUT_DEV_REPORTED:	The timeout value was probed directly from  *				the device.  *  * FW_TIMEOUT_NO_PROBE:		Do not ask the device for a WRITE BUFFER  * 				timeout value.  Use the device-specific  *				value.  *  * FW_TIMEOUT_USER_SPEC:	The user specified a timeout on the command  *				line with the -t option.  This overrides any  *				probe or default timeout.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|FW_TIMEOUT_DEFAULT
block|,
name|FW_TIMEOUT_DEV_REPORTED
block|,
name|FW_TIMEOUT_NO_PROBE
block|,
name|FW_TIMEOUT_USER_SPEC
block|}
name|fw_timeout_type
typedef|;
end_typedef

begin_comment
comment|/*  * type: 		Enumeration for the particular vendor.  *  * pattern:		Pattern to match for the Vendor ID from the SCSI  *			Inquiry data.  *  * dev_type:		SCSI device type to match, or T_ANY to match any  *			device from the given vendor.  Note that if there  *			is a specific device type listed for a particular  *			vendor, it must be listed before a T_ANY entry.  *  * max_pkt_size:	Maximum packet size when talking to a device.  Note  *			that although large data sizes may be supported by  *			the target device, they may not be supported by the  *			OS or the controller.  *  * cdb_byte2:		This specifies byte 2 (byte 1 when counting from 0)  *			of the CDB.  This is generally the WRITE BUFFER mode.  *  * cdb_byte2_last:	This specifies byte 2 for the last chunk of the  *			download.  *  * inc_cdb_buffer_id:	Increment the buffer ID by 1 for each chunk sent  *			down to the drive.  *  * inc_cdb_offset:	Increment the offset field in the CDB with the byte  *			offset into the firmware file.  *  * tur_status:		Pay attention to whether the device is ready before  *			upgrading the firmware, or not.  See above for the  *			values.  */
end_comment

begin_struct
struct|struct
name|fw_vendor
block|{
name|fw_vendor_t
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|dev_type
decl_stmt|;
name|int
name|max_pkt_size
decl_stmt|;
name|u_int8_t
name|cdb_byte2
decl_stmt|;
name|u_int8_t
name|cdb_byte2_last
decl_stmt|;
name|int
name|inc_cdb_buffer_id
decl_stmt|;
name|int
name|inc_cdb_offset
decl_stmt|;
name|fw_tur_status
name|tur_status
decl_stmt|;
name|int
name|timeout_ms
decl_stmt|;
name|fw_timeout_type
name|timeout_type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Vendor notes:  *  * HGST:     The packets need to be sent in multiples of 4K.  *  * IBM:      For LTO and TS drives, the buffer ID is ignored in mode 7 (and  * 	     some other modes).  It treats the request as a firmware download.  *           The offset (and therefore the length of each chunk sent) needs  *           to be a multiple of the offset boundary specified for firmware  *           (buffer ID 4) in the read buffer command.  At least for LTO-6,  *           that seems to be 0, but using a 32K chunk size should satisfy  *           most any alignment requirement.  *  * SmrtStor: Mode 5 is also supported, but since the firmware is 400KB or  *           so, we can't fit it in a single request in most cases.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fw_vendor
name|vendors_list
index|[]
init|=
block|{
block|{
name|VENDOR_HGST
block|,
literal|"HGST"
block|,
name|T_DIRECT
block|,
literal|0x1000
block|,
literal|0x07
block|,
literal|0x07
block|,
literal|1
block|,
literal|0
block|,
name|FW_TUR_READY
block|,
name|WB_TIMEOUT
block|,
name|FW_TIMEOUT_DEFAULT
block|}
block|,
block|{
name|VENDOR_HITACHI
block|,
literal|"HITACHI"
block|,
name|T_ANY
block|,
literal|0x8000
block|,
literal|0x05
block|,
literal|0x05
block|,
literal|1
block|,
literal|0
block|,
name|FW_TUR_READY
block|,
name|WB_TIMEOUT
block|,
name|FW_TIMEOUT_DEFAULT
block|}
block|,
block|{
name|VENDOR_HP
block|,
literal|"HP"
block|,
name|T_ANY
block|,
literal|0x8000
block|,
literal|0x07
block|,
literal|0x07
block|,
literal|0
block|,
literal|1
block|,
name|FW_TUR_READY
block|,
name|WB_TIMEOUT
block|,
name|FW_TIMEOUT_DEFAULT
block|}
block|,
block|{
name|VENDOR_IBM
block|,
literal|"IBM"
block|,
name|T_SEQUENTIAL
block|,
literal|0x8000
block|,
literal|0x07
block|,
literal|0x07
block|,
literal|0
block|,
literal|1
block|,
name|FW_TUR_NA
block|,
literal|300
operator|*
literal|1000
block|,
name|FW_TIMEOUT_DEFAULT
block|}
block|,
block|{
name|VENDOR_IBM
block|,
literal|"IBM"
block|,
name|T_ANY
block|,
literal|0x8000
block|,
literal|0x05
block|,
literal|0x05
block|,
literal|1
block|,
literal|0
block|,
name|FW_TUR_READY
block|,
name|WB_TIMEOUT
block|,
name|FW_TIMEOUT_DEFAULT
block|}
block|,
block|{
name|VENDOR_PLEXTOR
block|,
literal|"PLEXTOR"
block|,
name|T_ANY
block|,
literal|0x2000
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0
block|,
literal|1
block|,
name|FW_TUR_READY
block|,
name|WB_TIMEOUT
block|,
name|FW_TIMEOUT_DEFAULT
block|}
block|,
block|{
name|VENDOR_QUALSTAR
block|,
literal|"QUALSTAR"
block|,
name|T_ANY
block|,
literal|0x2030
block|,
literal|0x05
block|,
literal|0x05
block|,
literal|0
block|,
literal|0
block|,
name|FW_TUR_READY
block|,
name|WB_TIMEOUT
block|,
name|FW_TIMEOUT_DEFAULT
block|}
block|,
block|{
name|VENDOR_QUANTUM
block|,
literal|"QUANTUM"
block|,
name|T_ANY
block|,
literal|0x2000
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0
block|,
literal|1
block|,
name|FW_TUR_READY
block|,
name|WB_TIMEOUT
block|,
name|FW_TIMEOUT_DEFAULT
block|}
block|,
block|{
name|VENDOR_SAMSUNG
block|,
literal|"SAMSUNG"
block|,
name|T_ANY
block|,
literal|0x8000
block|,
literal|0x07
block|,
literal|0x07
block|,
literal|0
block|,
literal|1
block|,
name|FW_TUR_READY
block|,
name|WB_TIMEOUT
block|,
name|FW_TIMEOUT_DEFAULT
block|}
block|,
block|{
name|VENDOR_SEAGATE
block|,
literal|"SEAGATE"
block|,
name|T_ANY
block|,
literal|0x8000
block|,
literal|0x07
block|,
literal|0x07
block|,
literal|0
block|,
literal|1
block|,
name|FW_TUR_READY
block|,
name|WB_TIMEOUT
block|,
name|FW_TIMEOUT_DEFAULT
block|}
block|,
block|{
name|VENDOR_SMART
block|,
literal|"SmrtStor"
block|,
name|T_DIRECT
block|,
literal|0x8000
block|,
literal|0x07
block|,
literal|0x07
block|,
literal|0
block|,
literal|1
block|,
name|FW_TUR_READY
block|,
name|WB_TIMEOUT
block|,
name|FW_TIMEOUT_DEFAULT
block|}
block|,
comment|/* 	 * We match any ATA device.  This is really just a placeholder, 	 * since we won't actually send a WRITE BUFFER with any of the 	 * listed parameters.  If a SATA device is behind a SAS controller, 	 * the SCSI to ATA translation code (at least for LSI) doesn't 	 * generally translate a SCSI WRITE BUFFER into an ATA DOWNLOAD 	 * MICROCODE command.  So, we use the SCSI ATA PASS_THROUGH command 	 * to send the ATA DOWNLOAD MICROCODE command instead. 	 */
block|{
name|VENDOR_ATA
block|,
literal|"ATA"
block|,
name|T_ANY
block|,
literal|0x8000
block|,
literal|0x07
block|,
literal|0x07
block|,
literal|0
block|,
literal|1
block|,
name|FW_TUR_READY
block|,
name|WB_TIMEOUT
block|,
name|FW_TIMEOUT_NO_PROBE
block|}
block|,
block|{
name|VENDOR_UNKNOWN
block|,
name|NULL
block|,
name|T_ANY
block|,
literal|0x0000
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0
block|,
literal|0
block|,
name|FW_TUR_NONE
block|,
name|WB_TIMEOUT
block|,
name|FW_TIMEOUT_DEFAULT
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|fw_timeout_desc
block|{
name|fw_timeout_type
name|timeout_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|timeout_desc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|fw_timeout_desc
name|fw_timeout_desc_table
index|[]
init|=
block|{
block|{
name|FW_TIMEOUT_DEFAULT
block|,
literal|"the default"
block|}
block|,
block|{
name|FW_TIMEOUT_DEV_REPORTED
block|,
literal|"recommended by this particular device"
block|}
block|,
block|{
name|FW_TIMEOUT_NO_PROBE
block|,
literal|"the default"
block|}
block|,
block|{
name|FW_TIMEOUT_USER_SPEC
block|,
literal|"what was specified on the command line"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ATA_DOWNLOAD_MICROCODE
end_ifndef

begin_define
define|#
directive|define
name|ATA_DOWNLOAD_MICROCODE
value|0x92
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|USE_OFFSETS_FEATURE
value|0x3
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|LOW_SECTOR_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LOW_SECTOR_SIZE
value|512
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ATA_MAKE_LBA
parameter_list|(
name|o
parameter_list|,
name|p
parameter_list|)
define|\
value|((((((o) / LOW_SECTOR_SIZE)>> 8)& 0xff)<< 16) | \ 	  ((((o) / LOW_SECTOR_SIZE)& 0xff)<< 8) | \ 	  ((((p) / LOW_SECTOR_SIZE)>> 8)& 0xff))
end_define

begin_define
define|#
directive|define
name|ATA_MAKE_SECTORS
parameter_list|(
name|p
parameter_list|)
value|(((p) / 512)& 0xff)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|UNKNOWN_MAX_PKT_SIZE
end_ifndef

begin_define
define|#
directive|define
name|UNKNOWN_MAX_PKT_SIZE
value|0x8000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|fw_vendor
modifier|*
name|fw_get_vendor
parameter_list|(
name|struct
name|cam_device
modifier|*
name|cam_dev
parameter_list|,
name|struct
name|ata_params
modifier|*
name|ident_buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fw_get_timeout
parameter_list|(
name|struct
name|cam_device
modifier|*
name|cam_dev
parameter_list|,
name|struct
name|fw_vendor
modifier|*
name|vp
parameter_list|,
name|int
name|task_attr
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fw_validate_ibm
parameter_list|(
name|struct
name|cam_device
modifier|*
name|dev
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|fw_img_path
parameter_list|,
name|int
name|quiet
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|fw_read_img
parameter_list|(
name|struct
name|cam_device
modifier|*
name|dev
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|quiet
parameter_list|,
specifier|const
name|char
modifier|*
name|fw_img_path
parameter_list|,
name|struct
name|fw_vendor
modifier|*
name|vp
parameter_list|,
name|int
modifier|*
name|num_bytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fw_check_device_ready
parameter_list|(
name|struct
name|cam_device
modifier|*
name|dev
parameter_list|,
name|camcontrol_devtype
name|devtype
parameter_list|,
name|struct
name|fw_vendor
modifier|*
name|vp
parameter_list|,
name|int
name|printerrors
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fw_download_img
parameter_list|(
name|struct
name|cam_device
modifier|*
name|cam_dev
parameter_list|,
name|struct
name|fw_vendor
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|img_size
parameter_list|,
name|int
name|sim_mode
parameter_list|,
name|int
name|printerrors
parameter_list|,
name|int
name|quiet
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
specifier|const
name|char
modifier|*
comment|/*name*/
parameter_list|,
name|camcontrol_devtype
name|devtype
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Find entry in vendors list that belongs to  * the vendor of given cam device.  */
end_comment

begin_function
specifier|static
name|struct
name|fw_vendor
modifier|*
name|fw_get_vendor
parameter_list|(
name|struct
name|cam_device
modifier|*
name|cam_dev
parameter_list|,
name|struct
name|ata_params
modifier|*
name|ident_buf
parameter_list|)
block|{
name|char
name|vendor
index|[
literal|42
index|]
decl_stmt|;
name|struct
name|fw_vendor
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
name|cam_dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ident_buf
operator|!=
name|NULL
condition|)
block|{
name|cam_strvis
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|vendor
argument_list|,
name|ident_buf
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|ident_buf
operator|->
name|model
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|vendors_list
init|;
name|vp
operator|->
name|pattern
operator|!=
name|NULL
condition|;
name|vp
operator|++
control|)
block|{
if|if
condition|(
name|vp
operator|->
name|type
operator|==
name|VENDOR_ATA
condition|)
return|return
operator|(
name|vp
operator|)
return|;
block|}
block|}
else|else
block|{
name|cam_strvis
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|vendor
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cam_dev
operator|->
name|inq_data
operator|.
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|cam_dev
operator|->
name|inq_data
operator|.
name|vendor
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|vp
operator|=
name|vendors_list
init|;
name|vp
operator|->
name|pattern
operator|!=
name|NULL
condition|;
name|vp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cam_strmatch
argument_list|(
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|vendor
argument_list|,
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|vp
operator|->
name|pattern
argument_list|,
name|strlen
argument_list|(
name|vendor
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|dev_type
operator|==
name|T_ANY
operator|)
operator|||
operator|(
name|vp
operator|->
name|dev_type
operator|==
name|SID_TYPE
argument_list|(
operator|&
name|cam_dev
operator|->
name|inq_data
argument_list|)
operator|)
condition|)
break|break;
block|}
block|}
return|return
operator|(
name|vp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fw_get_timeout
parameter_list|(
name|struct
name|cam_device
modifier|*
name|cam_dev
parameter_list|,
name|struct
name|fw_vendor
modifier|*
name|vp
parameter_list|,
name|int
name|task_attr
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|scsi_report_supported_opcodes_one
modifier|*
name|one
decl_stmt|;
name|struct
name|scsi_report_supported_opcodes_timeout
modifier|*
name|td
decl_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|fill_len
init|=
literal|0
decl_stmt|,
name|cdb_len
init|=
literal|0
decl_stmt|,
name|rec_timeout
init|=
literal|0
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* 	 * If the user has specified a timeout on the command line, we let 	 * him override any default or probed value. 	 */
if|if
condition|(
name|timeout
operator|!=
literal|0
condition|)
block|{
name|vp
operator|->
name|timeout_type
operator|=
name|FW_TIMEOUT_USER_SPEC
expr_stmt|;
name|vp
operator|->
name|timeout_ms
operator|=
name|timeout
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * Check to see whether we should probe for a timeout for this 	 * device. 	 */
if|if
condition|(
name|vp
operator|->
name|timeout_type
operator|==
name|FW_TIMEOUT_NO_PROBE
condition|)
goto|goto
name|bailout
goto|;
name|retval
operator|=
name|scsigetopcodes
argument_list|(
comment|/*device*/
name|cam_dev
argument_list|,
comment|/*opcode_set*/
literal|1
argument_list|,
comment|/*opcode*/
name|WRITE_BUFFER
argument_list|,
comment|/*show_sa_errors*/
literal|1
argument_list|,
comment|/*sa_set*/
literal|0
argument_list|,
comment|/*service_action*/
literal|0
argument_list|,
comment|/*timeout_desc*/
literal|1
argument_list|,
comment|/*task_attr*/
name|task_attr
argument_list|,
comment|/*retry_count*/
name|retry_count
argument_list|,
comment|/*timeout*/
literal|10000
argument_list|,
comment|/*verbose*/
literal|0
argument_list|,
comment|/*fill_len*/
operator|&
name|fill_len
argument_list|,
comment|/*data_ptr*/
operator|&
name|buf
argument_list|)
expr_stmt|;
comment|/* 	 * It isn't an error if we can't get a timeout descriptor.  We just 	 * continue on with the default timeout. 	 */
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * Even if the drive didn't return a SCSI error, if we don't have 	 * enough data to contain the one opcode descriptor, the CDB 	 * structure and a timeout descriptor, we don't have the timeout 	 * value we're looking for.  So we'll just fall back to the 	 * default value. 	 */
if|if
condition|(
name|fill_len
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|one
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_write_buffer
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|td
argument_list|)
operator|)
condition|)
goto|goto
name|bailout
goto|;
name|one
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_one
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* 	 * If the drive claims to not support the WRITE BUFFER command... 	 * fall back to the default timeout value and let things fail on 	 * the actual firmware download. 	 */
if|if
condition|(
operator|(
name|one
operator|->
name|support
operator|&
name|RSO_ONE_SUP_MASK
operator|)
operator|==
name|RSO_ONE_SUP_NOT_SUP
condition|)
goto|goto
name|bailout
goto|;
name|cdb_len
operator|=
name|scsi_2btoul
argument_list|(
name|one
operator|->
name|cdb_length
argument_list|)
expr_stmt|;
name|td
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_timeout
operator|*
operator|)
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
operator|*
name|one
argument_list|)
operator|+
name|cdb_len
index|]
expr_stmt|;
name|rec_timeout
operator|=
name|scsi_4btoul
argument_list|(
name|td
operator|->
name|recommended_time
argument_list|)
expr_stmt|;
comment|/* 	 * If the recommended timeout is 0, then the device has probably 	 * returned a bogus value. 	 */
if|if
condition|(
name|rec_timeout
operator|==
literal|0
condition|)
goto|goto
name|bailout
goto|;
comment|/* CAM timeouts are in ms */
name|rec_timeout
operator|*=
literal|1000
expr_stmt|;
name|vp
operator|->
name|timeout_ms
operator|=
name|rec_timeout
expr_stmt|;
name|vp
operator|->
name|timeout_type
operator|=
name|FW_TIMEOUT_DEV_REPORTED
expr_stmt|;
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SVPD_IBM_FW_DESIGNATION
value|0x03
end_define

begin_comment
comment|/*  * IBM LTO and TS tape drives have an INQUIRY VPD page 0x3 with the following  * format:  */
end_comment

begin_struct
struct|struct
name|fw_ibm_tape_fw_designation
block|{
name|uint8_t
name|device
decl_stmt|;
name|uint8_t
name|page_code
decl_stmt|;
name|uint8_t
name|reserved
decl_stmt|;
name|uint8_t
name|length
decl_stmt|;
name|uint8_t
name|ascii_length
decl_stmt|;
name|uint8_t
name|reserved2
index|[
literal|3
index|]
decl_stmt|;
name|uint8_t
name|load_id
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|fw_rev
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|ptf_number
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|patch_number
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|ru_name
index|[
literal|8
index|]
decl_stmt|;
name|uint8_t
name|lib_seq_num
index|[
literal|5
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The firmware for IBM tape drives has the following header format.  The  * load_id and ru_name in the header file should match what is returned in  * VPD page 0x3.  */
end_comment

begin_struct
struct|struct
name|fw_ibm_tape_fw_header
block|{
name|uint8_t
name|unspec
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|length
index|[
literal|4
index|]
decl_stmt|;
comment|/* Firmware and header! */
name|uint8_t
name|load_id
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|fw_rev
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|reserved
index|[
literal|8
index|]
decl_stmt|;
name|uint8_t
name|ru_name
index|[
literal|8
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|fw_validate_ibm
parameter_list|(
name|struct
name|cam_device
modifier|*
name|dev
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|fw_img_path
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|fw_ibm_tape_fw_designation
name|vpd_page
decl_stmt|;
name|struct
name|fw_ibm_tape_fw_header
modifier|*
name|header
decl_stmt|;
name|char
name|drive_rev
index|[
sizeof|sizeof
argument_list|(
name|vpd_page
operator|.
name|fw_rev
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|file_rev
index|[
sizeof|sizeof
argument_list|(
name|vpd_page
operator|.
name|fw_rev
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|retval
init|=
literal|1
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't allocate CCB"
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* cam_getccb cleans up the header, caller has to zero the payload */
name|CCB_CLEAR_ALL_EXCEPT_HDR
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|vpd_page
argument_list|,
sizeof|sizeof
argument_list|(
name|vpd_page
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_inquiry
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* inq_buf */
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|vpd_page
argument_list|,
comment|/* inq_len */
sizeof|sizeof
argument_list|(
name|vpd_page
argument_list|)
argument_list|,
comment|/* evpd */
literal|1
argument_list|,
comment|/* page_code */
name|SVPD_IBM_FW_DESIGNATION
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|retry_count
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error getting firmware designation page"
argument_list|)
expr_stmt|;
name|cam_error_print
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|NULL
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|cam_error_print
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * Read the firmware header only. 	 */
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"unable to read %zu bytes from %s"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
argument_list|,
name|fw_img_path
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* Rewind the file back to 0 for the full file read. */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"Unable to lseek"
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|header
operator|=
operator|(
expr|struct
name|fw_ibm_tape_fw_header
operator|*
operator|)
name|buf
expr_stmt|;
name|bzero
argument_list|(
name|drive_rev
argument_list|,
sizeof|sizeof
argument_list|(
name|drive_rev
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|vpd_page
operator|.
name|fw_rev
argument_list|,
name|drive_rev
argument_list|,
sizeof|sizeof
argument_list|(
name|vpd_page
operator|.
name|fw_rev
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|file_rev
argument_list|,
sizeof|sizeof
argument_list|(
name|file_rev
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|header
operator|->
name|fw_rev
argument_list|,
name|file_rev
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|fw_rev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Current Drive Firmware version: %s\n"
argument_list|,
name|drive_rev
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Firmware File version: %s\n"
argument_list|,
name|file_rev
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For IBM tape drives the load ID and RU name reported by the 	 * drive should match what is in the firmware file. 	 */
if|if
condition|(
name|bcmp
argument_list|(
name|vpd_page
operator|.
name|load_id
argument_list|,
name|header
operator|->
name|load_id
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|vpd_page
operator|.
name|load_id
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|load_id
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Drive Firmware load ID 0x%x does not match firmware "
literal|"file load ID 0x%x"
argument_list|,
name|scsi_4btoul
argument_list|(
name|vpd_page
operator|.
name|load_id
argument_list|)
argument_list|,
name|scsi_4btoul
argument_list|(
name|header
operator|->
name|load_id
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
name|vpd_page
operator|.
name|ru_name
argument_list|,
name|header
operator|->
name|ru_name
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|vpd_page
operator|.
name|ru_name
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|ru_name
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Drive Firmware RU name 0x%jx does not match firmware "
literal|"file RU name 0x%jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|scsi_8btou64
argument_list|(
name|vpd_page
operator|.
name|ru_name
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|scsi_8btou64
argument_list|(
name|header
operator|->
name|ru_name
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Firmware file is valid for this drive.\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a buffer and read fw image file into it  * from given path. Number of bytes read is stored  * in num_bytes.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fw_read_img
parameter_list|(
name|struct
name|cam_device
modifier|*
name|dev
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|quiet
parameter_list|,
specifier|const
name|char
modifier|*
name|fw_img_path
parameter_list|,
name|struct
name|fw_vendor
modifier|*
name|vp
parameter_list|,
name|int
modifier|*
name|num_bytes
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|off_t
name|img_size
decl_stmt|;
name|int
name|skip_bytes
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fw_img_path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Could not open image file %s"
argument_list|,
name|fw_img_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Could not stat image file %s"
argument_list|,
name|fw_img_path
argument_list|)
expr_stmt|;
goto|goto
name|bailout1
goto|;
block|}
if|if
condition|(
operator|(
name|img_size
operator|=
name|stbuf
operator|.
name|st_size
operator|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Zero length image file %s"
argument_list|,
name|fw_img_path
argument_list|)
expr_stmt|;
goto|goto
name|bailout1
goto|;
block|}
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|img_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Could not allocate buffer to read image file %s"
argument_list|,
name|fw_img_path
argument_list|)
expr_stmt|;
goto|goto
name|bailout1
goto|;
block|}
comment|/* Skip headers if applicable. */
switch|switch
condition|(
name|vp
operator|->
name|type
condition|)
block|{
case|case
name|VENDOR_SEAGATE
case|:
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
literal|16
argument_list|)
operator|!=
literal|16
condition|)
block|{
name|warn
argument_list|(
literal|"Could not read image file %s"
argument_list|,
name|fw_img_path
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"Unable to lseek"
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"SEAGATE,SEAGATE "
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|img_size
operator|%
literal|512
operator|==
literal|80
operator|)
condition|)
name|skip_bytes
operator|=
literal|80
expr_stmt|;
break|break;
case|case
name|VENDOR_QUALSTAR
case|:
name|skip_bytes
operator|=
name|img_size
operator|%
literal|1030
expr_stmt|;
break|break;
case|case
name|VENDOR_IBM
case|:
block|{
if|if
condition|(
name|vp
operator|->
name|dev_type
operator|!=
name|T_SEQUENTIAL
condition|)
break|break;
if|if
condition|(
name|fw_validate_ibm
argument_list|(
name|dev
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|,
name|fw_img_path
argument_list|,
name|quiet
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
break|break;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|skip_bytes
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Skipping %d byte header.\n"
argument_list|,
name|skip_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|skip_bytes
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"Could not lseek"
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|img_size
operator|-=
name|skip_bytes
expr_stmt|;
block|}
comment|/* Read image into a buffer. */
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|img_size
argument_list|)
operator|!=
name|img_size
condition|)
block|{
name|warn
argument_list|(
literal|"Could not read image file %s"
argument_list|,
name|fw_img_path
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
operator|*
name|num_bytes
operator|=
name|img_size
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
name|bailout
label|:
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|bailout1
label|:
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|*
name|num_bytes
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 0 for "success", where success means that the device has met the  * requirement in the vendor structure for being ready or not ready when  * firmware is downloaded.  *  * Returns 1 for a failure to be ready to accept a firmware download.  * (e.g., a drive needs to be ready, but returns not ready)  *  * Returns -1 for any other failure.  */
end_comment

begin_function
specifier|static
name|int
name|fw_check_device_ready
parameter_list|(
name|struct
name|cam_device
modifier|*
name|dev
parameter_list|,
name|camcontrol_devtype
name|devtype
parameter_list|,
name|struct
name|fw_vendor
modifier|*
name|vp
parameter_list|,
name|int
name|printerrors
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int16_t
modifier|*
name|ptr
init|=
name|NULL
decl_stmt|;
name|size_t
name|dxfer_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Could not allocate CCB"
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|CCB_CLEAR_ALL_EXCEPT_HDR
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|devtype
operator|!=
name|CC_DT_SCSI
condition|)
block|{
name|dxfer_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|malloc
argument_list|(
name|dxfer_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't malloc memory for identify"
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bzero
argument_list|(
name|ptr
argument_list|,
name|dxfer_len
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|devtype
condition|)
block|{
case|case
name|CC_DT_SCSI
case|:
name|scsi_test_unit_ready
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
literal|0
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
literal|5000
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC_DT_ATA_BEHIND_SCSI
case|:
case|case
name|CC_DT_ATA
case|:
block|{
name|retval
operator|=
name|build_ata_cmd
argument_list|(
name|ccb
argument_list|,
comment|/*retries*/
literal|1
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*protocol*/
name|AP_PROTO_PIO_IN
argument_list|,
comment|/*ata_flags*/
name|AP_FLAG_BYT_BLOK_BYTES
operator||
name|AP_FLAG_TLEN_SECT_CNT
operator||
name|AP_FLAG_TDIR_FROM_DEV
argument_list|,
comment|/*features*/
literal|0
argument_list|,
comment|/*sector_count*/
operator|(
name|uint8_t
operator|)
name|dxfer_len
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*command*/
name|ATA_ATA_IDENTIFY
argument_list|,
comment|/*auxiliary*/
literal|0
argument_list|,
comment|/*data_ptr*/
operator|(
name|uint8_t
operator|*
operator|)
name|ptr
argument_list|,
comment|/*dxfer_len*/
name|dxfer_len
argument_list|,
comment|/*cdb_storage*/
name|NULL
argument_list|,
comment|/*cdb_storage_len*/
literal|0
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|30
operator|*
literal|1000
argument_list|,
comment|/*is48bit*/
literal|0
argument_list|,
comment|/*devtype*/
name|devtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"%s: build_ata_cmd() failed, likely "
literal|"programmer error"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
block|}
default|default:
name|warnx
argument_list|(
literal|"Unknown disk type %d"
argument_list|,
name|devtype
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/*NOTREACHED*/
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending %s CCB"
argument_list|,
operator|(
name|devtype
operator|==
name|CC_DT_SCSI
operator|)
condition|?
literal|"Test Unit Ready"
else|:
literal|"Identify"
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|vp
operator|->
name|tur_status
operator|==
name|FW_TUR_READY
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Device is not ready"
argument_list|)
expr_stmt|;
if|if
condition|(
name|printerrors
condition|)
name|cam_error_print
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|vp
operator|->
name|tur_status
operator|==
name|FW_TUR_NOT_READY
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Device cannot have media loaded when firmware is "
literal|"downloaded"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bailout
label|:
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Download firmware stored in buf to cam_dev. If simulation mode  * is enabled, only show what packet sizes would be sent to the   * device but do not sent any actual packets  */
end_comment

begin_function
specifier|static
name|int
name|fw_download_img
parameter_list|(
name|struct
name|cam_device
modifier|*
name|cam_dev
parameter_list|,
name|struct
name|fw_vendor
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|img_size
parameter_list|,
name|int
name|sim_mode
parameter_list|,
name|int
name|printerrors
parameter_list|,
name|int
name|quiet
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
specifier|const
name|char
modifier|*
name|imgname
parameter_list|,
name|camcontrol_devtype
name|devtype
parameter_list|)
block|{
name|struct
name|scsi_write_buffer
name|cdb
decl_stmt|;
name|progress_t
name|progress
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|NULL
decl_stmt|;
name|int
name|pkt_count
init|=
literal|0
decl_stmt|;
name|int
name|max_pkt_size
decl_stmt|;
name|u_int32_t
name|pkt_size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|pkt_ptr
init|=
name|buf
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|;
name|int
name|last_pkt
init|=
literal|0
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* 	 * Check to see whether the device is ready to accept a firmware 	 * download. 	 */
name|retval
operator|=
name|fw_check_device_ready
argument_list|(
name|cam_dev
argument_list|,
name|devtype
argument_list|,
name|vp
argument_list|,
name|printerrors
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
operator|(
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|cam_dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Could not allocate CCB"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|CCB_CLEAR_ALL_EXCEPT_HDR
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|max_pkt_size
operator|=
name|vp
operator|->
name|max_pkt_size
expr_stmt|;
if|if
condition|(
name|max_pkt_size
operator|==
literal|0
condition|)
name|max_pkt_size
operator|=
name|UNKNOWN_MAX_PKT_SIZE
expr_stmt|;
name|pkt_size
operator|=
name|max_pkt_size
expr_stmt|;
name|progress_init
argument_list|(
operator|&
name|progress
argument_list|,
name|imgname
argument_list|,
name|size
operator|=
name|img_size
argument_list|)
expr_stmt|;
comment|/* Download single fw packets. */
do|do
block|{
if|if
condition|(
name|img_size
operator|<=
name|max_pkt_size
condition|)
block|{
name|last_pkt
operator|=
literal|1
expr_stmt|;
name|pkt_size
operator|=
name|img_size
expr_stmt|;
block|}
name|progress_update
argument_list|(
operator|&
name|progress
argument_list|,
name|size
operator|-
name|img_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|sim_mode
operator|==
literal|0
operator|)
operator|&&
operator|(
name|quiet
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|sim_mode
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|printerrors
operator|==
literal|0
operator|)
operator|)
condition|)
name|progress_draw
argument_list|(
operator|&
name|progress
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|devtype
condition|)
block|{
case|case
name|CC_DT_SCSI
case|:
name|cdb
operator|.
name|opcode
operator|=
name|WRITE_BUFFER
expr_stmt|;
name|cdb
operator|.
name|control
operator|=
literal|0
expr_stmt|;
comment|/* Parameter list length. */
name|scsi_ulto3b
argument_list|(
name|pkt_size
argument_list|,
operator|&
name|cdb
operator|.
name|length
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|offset
operator|=
name|vp
operator|->
name|inc_cdb_offset
condition|?
operator|(
name|pkt_ptr
operator|-
name|buf
operator|)
else|:
literal|0
expr_stmt|;
name|scsi_ulto3b
argument_list|(
name|offset
argument_list|,
operator|&
name|cdb
operator|.
name|offset
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cdb
operator|.
name|byte2
operator|=
name|last_pkt
condition|?
name|vp
operator|->
name|cdb_byte2_last
else|:
name|vp
operator|->
name|cdb_byte2
expr_stmt|;
name|cdb
operator|.
name|buffer_id
operator|=
name|vp
operator|->
name|inc_cdb_buffer_id
condition|?
name|pkt_count
else|:
literal|0
expr_stmt|;
comment|/* Zero out payload of ccb union after ccb header. */
name|CCB_CLEAR_ALL_EXCEPT_HDR
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|)
expr_stmt|;
comment|/* 			 * Copy previously constructed cdb into ccb_scsiio 			 * struct. 			 */
name|bcopy
argument_list|(
operator|&
name|cdb
argument_list|,
operator|&
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_write_buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill rest of ccb_scsiio struct. */
name|cam_fill_csio
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* ccb_scsiio*/
name|retry_count
argument_list|,
comment|/* retries*/
name|NULL
argument_list|,
comment|/* cbfcnp*/
name|CAM_DIR_OUT
operator||
name|CAM_DEV_QFRZDIS
argument_list|,
comment|/* flags*/
name|CAM_TAG_ACTION_NONE
argument_list|,
comment|/* tag_action*/
operator|(
name|u_char
operator|*
operator|)
name|pkt_ptr
argument_list|,
comment|/* data_ptr*/
name|pkt_size
argument_list|,
comment|/* dxfer_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/* sense_len*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_write_buffer
argument_list|)
argument_list|,
comment|/* cdb_len*/
name|timeout
condition|?
name|timeout
else|:
name|WB_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* timeout*/
break|break;
case|case
name|CC_DT_ATA
case|:
case|case
name|CC_DT_ATA_BEHIND_SCSI
case|:
block|{
name|uint32_t
name|off
decl_stmt|;
name|off
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|pkt_ptr
operator|-
name|buf
argument_list|)
expr_stmt|;
name|retval
operator|=
name|build_ata_cmd
argument_list|(
name|ccb
argument_list|,
comment|/*retry_count*/
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
operator||
name|CAM_DEV_QFRZDIS
argument_list|,
comment|/*tag_action*/
name|CAM_TAG_ACTION_NONE
argument_list|,
comment|/*protocol*/
name|AP_PROTO_PIO_OUT
argument_list|,
comment|/*ata_flags*/
name|AP_FLAG_BYT_BLOK_BYTES
operator||
name|AP_FLAG_TLEN_SECT_CNT
operator||
name|AP_FLAG_TDIR_TO_DEV
argument_list|,
comment|/*features*/
name|USE_OFFSETS_FEATURE
argument_list|,
comment|/*sector_count*/
name|ATA_MAKE_SECTORS
argument_list|(
name|pkt_size
argument_list|)
argument_list|,
comment|/*lba*/
name|ATA_MAKE_LBA
argument_list|(
name|off
argument_list|,
name|pkt_size
argument_list|)
argument_list|,
comment|/*command*/
name|ATA_DOWNLOAD_MICROCODE
argument_list|,
comment|/*auxiliary*/
literal|0
argument_list|,
comment|/*data_ptr*/
operator|(
name|uint8_t
operator|*
operator|)
name|pkt_ptr
argument_list|,
comment|/*dxfer_len*/
name|pkt_size
argument_list|,
comment|/*cdb_storage*/
name|NULL
argument_list|,
comment|/*cdb_storage_len*/
literal|0
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
name|WB_TIMEOUT
argument_list|,
comment|/*is48bit*/
literal|0
argument_list|,
comment|/*devtype*/
name|devtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: build_ata_cmd() failed, likely "
literal|"programmer error"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
block|}
default|default:
name|warnx
argument_list|(
literal|"Unknown device type %d"
argument_list|,
name|devtype
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
operator|!
name|sim_mode
condition|)
block|{
comment|/* Execute the command. */
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|cam_dev
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"Error writing image to device"
argument_list|)
expr_stmt|;
if|if
condition|(
name|printerrors
condition|)
name|cam_error_print
argument_list|(
name|cam_dev
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|printerrors
condition|)
block|{
name|cam_error_print
argument_list|(
name|cam_dev
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_COMMAND
argument_list|,
literal|0
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* Prepare next round. */
name|pkt_count
operator|++
expr_stmt|;
name|pkt_ptr
operator|+=
name|pkt_size
expr_stmt|;
name|img_size
operator|-=
name|pkt_size
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|last_pkt
condition|)
do|;
name|bailout
label|:
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|progress_complete
argument_list|(
operator|&
name|progress
argument_list|,
name|size
operator|-
name|img_size
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fwdownload
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|printerrors
parameter_list|,
name|int
name|task_attr
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|NULL
decl_stmt|;
name|struct
name|fw_vendor
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|fw_img_path
init|=
name|NULL
decl_stmt|;
name|struct
name|ata_params
modifier|*
name|ident_buf
init|=
name|NULL
decl_stmt|;
name|camcontrol_devtype
name|devtype
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|img_size
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|sim_mode
init|=
literal|0
decl_stmt|;
name|int
name|confirmed
init|=
literal|0
decl_stmt|;
name|int
name|quiet
init|=
literal|0
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|fw_img_path
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sim_mode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|confirmed
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|fw_img_path
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"you must specify a firmware image file using -f "
literal|"option"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|get_device_type
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|printerrors
argument_list|,
operator|&
name|devtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unable to determine device type"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|devtype
operator|==
name|CC_DT_ATA
operator|)
operator|||
operator|(
name|devtype
operator|==
name|CC_DT_ATA_BEHIND_SCSI
operator|)
condition|)
block|{
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't allocate CCB"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|ata_do_identify
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|ccb
argument_list|,
operator|&
name|ident_buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|devtype
operator|!=
name|CC_DT_SCSI
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unsupported device type %d"
argument_list|,
name|devtype
argument_list|)
expr_stmt|;
name|vp
operator|=
name|fw_get_vendor
argument_list|(
name|device
argument_list|,
name|ident_buf
argument_list|)
expr_stmt|;
comment|/* 	 * Bail out if we have an unknown vendor and this isn't an ATA 	 * disk.  For a SCSI disk, we have no chance of working properly 	 * with the default values in the VENDOR_UNKNOWN case.  For an ATA 	 * disk connected via an ATA transport, we may work for drives that 	 * support the ATA_DOWNLOAD_MICROCODE command. 	 */
if|if
condition|(
operator|(
operator|(
name|vp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|vp
operator|->
name|type
operator|==
name|VENDOR_UNKNOWN
operator|)
operator|)
operator|&&
operator|(
name|devtype
operator|==
name|CC_DT_SCSI
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unsupported device"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|fw_get_timeout
argument_list|(
name|device
argument_list|,
name|vp
argument_list|,
name|task_attr
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Unable to get a firmware download timeout value"
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|buf
operator|=
name|fw_read_img
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|quiet
argument_list|,
name|fw_img_path
argument_list|,
name|vp
argument_list|,
operator|&
name|img_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|!
name|confirmed
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"You are about to download firmware image (%s)"
literal|" into the following device:\n"
argument_list|,
name|fw_img_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|devtype
operator|==
name|CC_DT_SCSI
condition|)
block|{
if|if
condition|(
name|scsidoinquiry
argument_list|(
name|device
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|MSG_SIMPLE_Q_TAG
argument_list|,
literal|0
argument_list|,
literal|5000
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Error sending inquiry"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s%d: "
argument_list|,
name|device
operator|->
name|device_name
argument_list|,
name|device
operator|->
name|dev_unit_num
argument_list|)
expr_stmt|;
name|ata_print_ident
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
name|camxferrate
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Using a timeout of %u ms, which is %s.\n"
argument_list|,
name|vp
operator|->
name|timeout_ms
argument_list|,
name|fw_timeout_desc_table
index|[
name|vp
operator|->
name|timeout_type
index|]
operator|.
name|timeout_desc
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nIt may damage your drive. "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_confirmation
argument_list|()
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|sim_mode
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|quiet
operator|==
literal|0
operator|)
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Running in simulation mode\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_download_img
argument_list|(
name|device
argument_list|,
name|vp
argument_list|,
name|buf
argument_list|,
name|img_size
argument_list|,
name|sim_mode
argument_list|,
name|printerrors
argument_list|,
name|quiet
argument_list|,
name|retry_count
argument_list|,
name|vp
operator|->
name|timeout_ms
argument_list|,
name|fw_img_path
argument_list|,
name|devtype
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Firmware download failed\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
elseif|else
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Firmware download successful\n"
argument_list|)
expr_stmt|;
name|bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

end_unit

