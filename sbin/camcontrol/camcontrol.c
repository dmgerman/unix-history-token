begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 1998, 1999, 2000, 2001, 2002 Kenneth D. Merry  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_pass.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<camlib.h>
end_include

begin_include
include|#
directive|include
file|"camcontrol.h"
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|CAM_ARG_NONE
init|=
literal|0x00000000
block|,
name|CAM_ARG_DEVLIST
init|=
literal|0x00000001
block|,
name|CAM_ARG_TUR
init|=
literal|0x00000002
block|,
name|CAM_ARG_INQUIRY
init|=
literal|0x00000003
block|,
name|CAM_ARG_STARTSTOP
init|=
literal|0x00000004
block|,
name|CAM_ARG_RESCAN
init|=
literal|0x00000005
block|,
name|CAM_ARG_READ_DEFECTS
init|=
literal|0x00000006
block|,
name|CAM_ARG_MODE_PAGE
init|=
literal|0x00000007
block|,
name|CAM_ARG_SCSI_CMD
init|=
literal|0x00000008
block|,
name|CAM_ARG_DEVTREE
init|=
literal|0x00000009
block|,
name|CAM_ARG_USAGE
init|=
literal|0x0000000a
block|,
name|CAM_ARG_DEBUG
init|=
literal|0x0000000b
block|,
name|CAM_ARG_RESET
init|=
literal|0x0000000c
block|,
name|CAM_ARG_FORMAT
init|=
literal|0x0000000d
block|,
name|CAM_ARG_TAG
init|=
literal|0x0000000e
block|,
name|CAM_ARG_RATE
init|=
literal|0x0000000f
block|,
name|CAM_ARG_OPT_MASK
init|=
literal|0x0000000f
block|,
name|CAM_ARG_VERBOSE
init|=
literal|0x00000010
block|,
name|CAM_ARG_DEVICE
init|=
literal|0x00000020
block|,
name|CAM_ARG_BUS
init|=
literal|0x00000040
block|,
name|CAM_ARG_TARGET
init|=
literal|0x00000080
block|,
name|CAM_ARG_LUN
init|=
literal|0x00000100
block|,
name|CAM_ARG_EJECT
init|=
literal|0x00000200
block|,
name|CAM_ARG_UNIT
init|=
literal|0x00000400
block|,
name|CAM_ARG_FORMAT_BLOCK
init|=
literal|0x00000800
block|,
name|CAM_ARG_FORMAT_BFI
init|=
literal|0x00001000
block|,
name|CAM_ARG_FORMAT_PHYS
init|=
literal|0x00002000
block|,
name|CAM_ARG_PLIST
init|=
literal|0x00004000
block|,
name|CAM_ARG_GLIST
init|=
literal|0x00008000
block|,
name|CAM_ARG_GET_SERIAL
init|=
literal|0x00010000
block|,
name|CAM_ARG_GET_STDINQ
init|=
literal|0x00020000
block|,
name|CAM_ARG_GET_XFERRATE
init|=
literal|0x00040000
block|,
name|CAM_ARG_INQ_MASK
init|=
literal|0x00070000
block|,
name|CAM_ARG_MODE_EDIT
init|=
literal|0x00080000
block|,
name|CAM_ARG_PAGE_CNTL
init|=
literal|0x00100000
block|,
name|CAM_ARG_TIMEOUT
init|=
literal|0x00200000
block|,
name|CAM_ARG_CMD_IN
init|=
literal|0x00400000
block|,
name|CAM_ARG_CMD_OUT
init|=
literal|0x00800000
block|,
name|CAM_ARG_DBD
init|=
literal|0x01000000
block|,
name|CAM_ARG_ERR_RECOVER
init|=
literal|0x02000000
block|,
name|CAM_ARG_RETRIES
init|=
literal|0x04000000
block|,
name|CAM_ARG_START_UNIT
init|=
literal|0x08000000
block|,
name|CAM_ARG_DEBUG_INFO
init|=
literal|0x10000000
block|,
name|CAM_ARG_DEBUG_TRACE
init|=
literal|0x20000000
block|,
name|CAM_ARG_DEBUG_SUBTRACE
init|=
literal|0x40000000
block|,
name|CAM_ARG_DEBUG_CDB
init|=
literal|0x80000000
block|,
name|CAM_ARG_FLAG_MASK
init|=
literal|0xfffffff0
block|}
name|cam_argmask
typedef|;
end_typedef

begin_struct
struct|struct
name|camcontrol_opts
block|{
name|char
modifier|*
name|optname
decl_stmt|;
name|cam_argmask
name|argnum
decl_stmt|;
specifier|const
name|char
modifier|*
name|subopt
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|scsicmd_opts
index|[]
init|=
literal|"c:i:o:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|readdefect_opts
index|[]
init|=
literal|"f:GP"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|negotiate_opts
index|[]
init|=
literal|"acD:O:qR:T:UW:"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|camcontrol_opts
name|option_table
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|MINIMALISTIC
block|{
literal|"tur"
block|,
name|CAM_ARG_TUR
block|,
name|NULL
block|}
block|,
block|{
literal|"inquiry"
block|,
name|CAM_ARG_INQUIRY
block|,
literal|"DSR"
block|}
block|,
block|{
literal|"start"
block|,
name|CAM_ARG_STARTSTOP
operator||
name|CAM_ARG_START_UNIT
block|,
name|NULL
block|}
block|,
block|{
literal|"stop"
block|,
name|CAM_ARG_STARTSTOP
block|,
name|NULL
block|}
block|,
block|{
literal|"eject"
block|,
name|CAM_ARG_STARTSTOP
operator||
name|CAM_ARG_EJECT
block|,
name|NULL
block|}
block|,
endif|#
directive|endif
comment|/* MINIMALISTIC */
block|{
literal|"rescan"
block|,
name|CAM_ARG_RESCAN
block|,
name|NULL
block|}
block|,
block|{
literal|"reset"
block|,
name|CAM_ARG_RESET
block|,
name|NULL
block|}
block|,
ifndef|#
directive|ifndef
name|MINIMALISTIC
block|{
literal|"cmd"
block|,
name|CAM_ARG_SCSI_CMD
block|,
name|scsicmd_opts
block|}
block|,
block|{
literal|"command"
block|,
name|CAM_ARG_SCSI_CMD
block|,
name|scsicmd_opts
block|}
block|,
block|{
literal|"defects"
block|,
name|CAM_ARG_READ_DEFECTS
block|,
name|readdefect_opts
block|}
block|,
block|{
literal|"defectlist"
block|,
name|CAM_ARG_READ_DEFECTS
block|,
name|readdefect_opts
block|}
block|,
endif|#
directive|endif
comment|/* MINIMALISTIC */
block|{
literal|"devlist"
block|,
name|CAM_ARG_DEVTREE
block|,
name|NULL
block|}
block|,
ifndef|#
directive|ifndef
name|MINIMALISTIC
block|{
literal|"periphlist"
block|,
name|CAM_ARG_DEVLIST
block|,
name|NULL
block|}
block|,
block|{
literal|"modepage"
block|,
name|CAM_ARG_MODE_PAGE
block|,
literal|"bdelm:P:"
block|}
block|,
block|{
literal|"tags"
block|,
name|CAM_ARG_TAG
block|,
literal|"N:q"
block|}
block|,
block|{
literal|"negotiate"
block|,
name|CAM_ARG_RATE
block|,
name|negotiate_opts
block|}
block|,
block|{
literal|"rate"
block|,
name|CAM_ARG_RATE
block|,
name|negotiate_opts
block|}
block|,
block|{
literal|"debug"
block|,
name|CAM_ARG_DEBUG
block|,
literal|"ITSc"
block|}
block|,
block|{
literal|"format"
block|,
name|CAM_ARG_FORMAT
block|,
literal|"qwy"
block|}
block|,
endif|#
directive|endif
comment|/* MINIMALISTIC */
block|{
literal|"help"
block|,
name|CAM_ARG_USAGE
block|,
name|NULL
block|}
block|,
block|{
literal|"-?"
block|,
name|CAM_ARG_USAGE
block|,
name|NULL
block|}
block|,
block|{
literal|"-h"
block|,
name|CAM_ARG_USAGE
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|CC_OR_NOT_FOUND
block|,
name|CC_OR_AMBIGUOUS
block|,
name|CC_OR_FOUND
block|}
name|camcontrol_optret
typedef|;
end_typedef

begin_decl_stmt
name|cam_argmask
name|arglist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bus
decl_stmt|,
name|target
decl_stmt|,
name|lun
decl_stmt|;
end_decl_stmt

begin_function_decl
name|camcontrol_optret
name|getoption
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|cam_argmask
modifier|*
name|argnum
parameter_list|,
name|char
modifier|*
modifier|*
name|subopt
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_function_decl
specifier|static
name|int
name|getdevlist
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getdevtree
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|testunitready
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|quiet
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsistart
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|startstop
parameter_list|,
name|int
name|loadeject
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsidoinquiry
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsiinquiry
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsiserial
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsixferrate
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MINIMALISTIC */
end_comment

begin_function_decl
specifier|static
name|int
name|parse_btl
parameter_list|(
name|char
modifier|*
name|tstr
parameter_list|,
name|int
modifier|*
name|bus
parameter_list|,
name|int
modifier|*
name|target
parameter_list|,
name|int
modifier|*
name|lun
parameter_list|,
name|cam_argmask
modifier|*
name|arglist
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dorescan_or_reset
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|rescan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rescan_or_reset_bus
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|rescan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scanlun_or_reset_dev
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|,
name|int
name|scan
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_function_decl
specifier|static
name|int
name|readdefects
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|modepage
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsicmd
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tagcontrol
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cts_print
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cpi_print
parameter_list|(
name|struct
name|ccb_pathinq
modifier|*
name|cpi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_cpi
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|struct
name|ccb_pathinq
modifier|*
name|cpi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_print_cts
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|user_settings
parameter_list|,
name|int
name|quiet
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ratecontrol
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsiformat
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MINIMALISTIC */
end_comment

begin_function
name|camcontrol_optret
name|getoption
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|cam_argmask
modifier|*
name|argnum
parameter_list|,
name|char
modifier|*
modifier|*
name|subopt
parameter_list|)
block|{
name|struct
name|camcontrol_opts
modifier|*
name|opts
decl_stmt|;
name|int
name|num_matches
init|=
literal|0
decl_stmt|;
for|for
control|(
name|opts
operator|=
name|option_table
init|;
operator|(
name|opts
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|opts
operator|->
name|optname
operator|!=
name|NULL
operator|)
condition|;
name|opts
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|opts
operator|->
name|optname
argument_list|,
name|arg
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|argnum
operator|=
name|opts
operator|->
name|argnum
expr_stmt|;
operator|*
name|subopt
operator|=
operator|(
name|char
operator|*
operator|)
name|opts
operator|->
name|subopt
expr_stmt|;
if|if
condition|(
operator|++
name|num_matches
operator|>
literal|1
condition|)
return|return
operator|(
name|CC_OR_AMBIGUOUS
operator|)
return|;
block|}
block|}
if|if
condition|(
name|num_matches
operator|>
literal|0
condition|)
return|return
operator|(
name|CC_OR_FOUND
operator|)
return|;
else|else
return|return
operator|(
name|CC_OR_NOT_FOUND
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_function
specifier|static
name|int
name|getdevlist
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|char
name|status
index|[
literal|32
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEVLIST
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DIR_NONE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|=
name|CAM_GDEVLIST_MORE_DEVS
expr_stmt|;
while|while
condition|(
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|==
name|CAM_GDEVLIST_MORE_DEVS
condition|)
block|{
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error getting device list"
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|status
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|cgdl
operator|.
name|status
condition|)
block|{
case|case
name|CAM_GDEVLIST_MORE_DEVS
case|:
name|strcpy
argument_list|(
name|status
argument_list|,
literal|"MORE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_GDEVLIST_LAST_DEVICE
case|:
name|strcpy
argument_list|(
name|status
argument_list|,
literal|"LAST"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_GDEVLIST_LIST_CHANGED
case|:
name|strcpy
argument_list|(
name|status
argument_list|,
literal|"CHANGED"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_GDEVLIST_ERROR
case|:
name|strcpy
argument_list|(
name|status
argument_list|,
literal|"ERROR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%d:  generation: %d index: %d status: %s\n"
argument_list|,
name|ccb
operator|->
name|cgdl
operator|.
name|periph_name
argument_list|,
name|ccb
operator|->
name|cgdl
operator|.
name|unit_number
argument_list|,
name|ccb
operator|->
name|cgdl
operator|.
name|generation
argument_list|,
name|ccb
operator|->
name|cgdl
operator|.
name|index
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* 		 * If the list has changed, we need to start over from the 		 * beginning. 		 */
if|if
condition|(
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|==
name|CAM_GDEVLIST_LIST_CHANGED
condition|)
name|ccb
operator|->
name|cgdl
operator|.
name|index
operator|=
literal|0
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MINIMALISTIC */
end_comment

begin_function
specifier|static
name|int
name|getdevtree
parameter_list|(
name|void
parameter_list|)
block|{
name|union
name|ccb
name|ccb
decl_stmt|;
name|int
name|bufsize
decl_stmt|,
name|i
decl_stmt|,
name|fd
decl_stmt|;
name|int
name|need_close
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|skip_device
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XPT_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"couldn't open %s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|.
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_dev_match
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEV_MATCH
expr_stmt|;
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
operator|*
literal|100
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|match_buf_len
operator|=
name|bufsize
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|matches
operator|=
operator|(
expr|struct
name|dev_match_result
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|.
name|cdm
operator|.
name|matches
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't malloc memory for matches"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ccb
operator|.
name|cdm
operator|.
name|num_matches
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We fetch all nodes, since we display most of them in the default 	 * case, and all in the verbose case. 	 */
name|ccb
operator|.
name|cdm
operator|.
name|num_patterns
operator|=
literal|0
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|pattern_buf_len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We do the ioctl multiple times if necessary, in case there are 	 * more than 100 nodes in the EDT. 	 */
do|do
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"error sending CAMIOCOMMAND ioctl"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|.
name|cdm
operator|.
name|status
operator|!=
name|CAM_DEV_MATCH_LAST
operator|)
operator|&&
operator|(
name|ccb
operator|.
name|cdm
operator|.
name|status
operator|!=
name|CAM_DEV_MATCH_MORE
operator|)
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"got CAM error %#x, CDM error %d\n"
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
argument_list|,
name|ccb
operator|.
name|cdm
operator|.
name|status
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccb
operator|.
name|cdm
operator|.
name|num_matches
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|DEV_MATCH_BUS
case|:
block|{
name|struct
name|bus_match_result
modifier|*
name|bus_result
decl_stmt|;
comment|/* 				 * Only print the bus information if the 				 * user turns on the verbose flag. 				 */
if|if
condition|(
operator|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
operator|)
operator|==
literal|0
condition|)
break|break;
name|bus_result
operator|=
operator|&
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|result
operator|.
name|bus_result
expr_stmt|;
if|if
condition|(
name|need_close
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|need_close
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"scbus%d on %s%d bus %d:\n"
argument_list|,
name|bus_result
operator|->
name|path_id
argument_list|,
name|bus_result
operator|->
name|dev_name
argument_list|,
name|bus_result
operator|->
name|unit_number
argument_list|,
name|bus_result
operator|->
name|bus_id
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DEV_MATCH_DEVICE
case|:
block|{
name|struct
name|device_match_result
modifier|*
name|dev_result
decl_stmt|;
name|char
name|vendor
index|[
literal|16
index|]
decl_stmt|,
name|product
index|[
literal|48
index|]
decl_stmt|,
name|revision
index|[
literal|16
index|]
decl_stmt|;
name|char
name|tmpstr
index|[
literal|256
index|]
decl_stmt|;
name|dev_result
operator|=
operator|&
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|result
operator|.
name|device_result
expr_stmt|;
if|if
condition|(
operator|(
name|dev_result
operator|->
name|flags
operator|&
name|DEV_RESULT_UNCONFIGURED
operator|)
operator|&&
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|skip_device
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
name|skip_device
operator|=
literal|0
expr_stmt|;
name|cam_strvis
argument_list|(
name|vendor
argument_list|,
name|dev_result
operator|->
name|inq_data
operator|.
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_result
operator|->
name|inq_data
operator|.
name|vendor
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|product
argument_list|,
name|dev_result
operator|->
name|inq_data
operator|.
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_result
operator|->
name|inq_data
operator|.
name|product
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|revision
argument_list|,
name|dev_result
operator|->
name|inq_data
operator|.
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_result
operator|->
name|inq_data
operator|.
name|revision
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpstr
argument_list|,
literal|"<%s %s %s>"
argument_list|,
name|vendor
argument_list|,
name|product
argument_list|,
name|revision
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_close
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|need_close
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%-33s  at scbus%d "
literal|"target %d lun %d ("
argument_list|,
name|tmpstr
argument_list|,
name|dev_result
operator|->
name|path_id
argument_list|,
name|dev_result
operator|->
name|target_id
argument_list|,
name|dev_result
operator|->
name|target_lun
argument_list|)
expr_stmt|;
name|need_close
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|DEV_MATCH_PERIPH
case|:
block|{
name|struct
name|periph_match_result
modifier|*
name|periph_result
decl_stmt|;
name|periph_result
operator|=
operator|&
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|result
operator|.
name|periph_result
expr_stmt|;
if|if
condition|(
name|skip_device
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|need_close
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%d"
argument_list|,
name|periph_result
operator|->
name|periph_name
argument_list|,
name|periph_result
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|need_close
operator|++
expr_stmt|;
break|break;
block|}
default|default:
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"unknown match type\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|ccb
operator|.
name|cdm
operator|.
name|status
operator|==
name|CAM_DEV_MATCH_MORE
operator|)
condition|)
do|;
if|if
condition|(
name|need_close
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_function
specifier|static
name|int
name|testunitready
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|scsi_test_unit_ready
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|perror
argument_list|(
literal|"error sending test unit ready"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Unit is ready\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Unit is not ready\n"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsistart
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|startstop
parameter_list|,
name|int
name|loadeject
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
comment|/* 	 * If we're stopping, send an ordered tag so the drive in question 	 * will finish any previously queued writes before stopping.  If 	 * the device isn't capable of tagged queueing, or if tagged 	 * queueing is turned off, the tag action is a no-op. 	 */
name|scsi_start_stop
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|startstop
condition|?
name|MSG_SIMPLE_Q_TAG
else|:
name|MSG_ORDERED_Q_TAG
argument_list|,
comment|/* start/stop */
name|startstop
argument_list|,
comment|/* load_eject */
name|loadeject
argument_list|,
comment|/* immediate */
literal|0
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|120000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending start unit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
if|if
condition|(
name|startstop
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Unit started successfully"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadeject
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|", Media loaded\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Unit stopped successfully"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadeject
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|", Media ejected\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|startstop
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Error received from start unit command\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Error received from stop unit command\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsidoinquiry
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'D'
case|:
name|arglist
operator||=
name|CAM_ARG_GET_STDINQ
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|arglist
operator||=
name|CAM_ARG_GET_XFERRATE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|arglist
operator||=
name|CAM_ARG_GET_SERIAL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * If the user didn't specify any inquiry options, he wants all of 	 * them. 	 */
if|if
condition|(
operator|(
name|arglist
operator|&
name|CAM_ARG_INQ_MASK
operator|)
operator|==
literal|0
condition|)
name|arglist
operator||=
name|CAM_ARG_INQ_MASK
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_GET_STDINQ
condition|)
name|error
operator|=
name|scsiinquiry
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_GET_SERIAL
condition|)
name|scsiserial
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_GET_XFERRATE
condition|)
name|error
operator|=
name|scsixferrate
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsiinquiry
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_buf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't allocate CCB"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* cam_getccb cleans up the header, caller has to zero the payload */
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|inq_buf
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inq_buf
operator|==
name|NULL
condition|)
block|{
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"can't malloc memory for inquiry\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
name|inq_buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inq_buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Note that although the size of the inquiry buffer is the full 	 * 256 bytes specified in the SCSI spec, we only tell the device 	 * that we have allocated SHORT_INQUIRY_LENGTH bytes.  There are 	 * two reasons for this: 	 * 	 *  - The SCSI spec says that when a length field is only 1 byte, 	 *    a value of 0 will be interpreted as 256.  Therefore 	 *    scsi_inquiry() will convert an inq_len (which is passed in as 	 *    a u_int32_t, but the field in the CDB is only 1 byte) of 256 	 *    to 0.  Evidently, very few devices meet the spec in that 	 *    regard.  Some devices, like many Seagate disks, take the 0 as  	 *    0, and don't return any data.  One Pioneer DVD-R drive 	 *    returns more data than the command asked for. 	 * 	 *    So, since there are numerous devices that just don't work 	 *    right with the full inquiry size, we don't send the full size. 	 *  	 *  - The second reason not to use the full inquiry data length is 	 *    that we don't need it here.  The only reason we issue a 	 *    standard inquiry is to get the vendor name, device name, 	 *    and revision so scsi_print_inquiry() can print them. 	 * 	 * If, at some point in the future, more inquiry data is needed for 	 * some reason, this code should use a procedure similar to the 	 * probe code.  i.e., issue a short inquiry, and determine from 	 * the additional length passed back from the device how much 	 * inquiry data the device supports.  Once the amount the device 	 * supports is determined, issue an inquiry for that amount and no 	 * more. 	 * 	 * KDM, 2/18/2000 	 */
name|scsi_inquiry
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* inq_buf */
operator|(
name|u_int8_t
operator|*
operator|)
name|inq_buf
argument_list|,
comment|/* inq_len */
name|SHORT_INQUIRY_LENGTH
argument_list|,
comment|/* evpd */
literal|0
argument_list|,
comment|/* page_code */
literal|0
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending SCSI inquiry"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|inq_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%d: "
argument_list|,
name|device
operator|->
name|device_name
argument_list|,
name|device
operator|->
name|dev_unit_num
argument_list|)
expr_stmt|;
name|scsi_print_inquiry
argument_list|(
name|inq_buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inq_buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsiserial
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|scsi_vpd_unit_serial_number
modifier|*
name|serial_buf
decl_stmt|;
name|char
name|serial_num
index|[
name|SVPD_SERIAL_NUM_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't allocate CCB"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* cam_getccb cleans up the header, caller has to zero the payload */
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|serial_buf
operator|=
operator|(
expr|struct
name|scsi_vpd_unit_serial_number
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|serial_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_buf
operator|==
name|NULL
condition|)
block|{
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"can't malloc memory for serial number"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|scsi_inquiry
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* inq_buf */
operator|(
name|u_int8_t
operator|*
operator|)
name|serial_buf
argument_list|,
comment|/* inq_len */
sizeof|sizeof
argument_list|(
operator|*
name|serial_buf
argument_list|)
argument_list|,
comment|/* evpd */
literal|1
argument_list|,
comment|/* page_code */
name|SVPD_UNIT_SERIAL_NUMBER
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error getting serial number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|serial_buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|serial_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|serial_buf
operator|->
name|serial_num
argument_list|,
name|serial_num
argument_list|,
name|serial_buf
operator|->
name|length
argument_list|)
expr_stmt|;
name|serial_num
index|[
name|serial_buf
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|arglist
operator|&
name|CAM_ARG_GET_STDINQ
operator|)
operator|||
operator|(
name|arglist
operator|&
name|CAM_ARG_GET_XFERRATE
operator|)
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%d: Serial Number "
argument_list|,
name|device
operator|->
name|device_name
argument_list|,
name|device
operator|->
name|dev_unit_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%.60s\n"
argument_list|,
name|serial_num
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|serial_buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsixferrate
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
block|{
name|u_int32_t
name|freq
decl_stmt|;
name|u_int32_t
name|speed
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int
name|mb
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't allocate CCB"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_trans_settings
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GET_TRAN_SETTINGS
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|flags
operator|=
name|CCB_TRANS_CURRENT_SETTINGS
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
specifier|const
name|char
name|error_string
index|[]
init|=
literal|"error getting transfer settings"
decl_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|warn
argument_list|(
name|error_string
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
name|error_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|xferrate_bailout
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|cts
operator|.
name|valid
operator|&
name|CCB_TRANS_SYNC_OFFSET_VALID
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|cts
operator|.
name|sync_offset
operator|!=
literal|0
operator|)
condition|)
block|{
name|freq
operator|=
name|scsi_calc_syncsrate
argument_list|(
name|ccb
operator|->
name|cts
operator|.
name|sync_period
argument_list|)
expr_stmt|;
name|speed
operator|=
name|freq
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|retval
operator|=
name|get_cpi
argument_list|(
name|device
argument_list|,
operator|&
name|cpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|xferrate_bailout
goto|;
name|speed
operator|=
name|cpi
operator|.
name|base_transfer_speed
expr_stmt|;
name|freq
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%d: "
argument_list|,
name|device
operator|->
name|device_name
argument_list|,
name|device
operator|->
name|dev_unit_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|cts
operator|.
name|valid
operator|&
name|CCB_TRANS_BUS_WIDTH_VALID
operator|)
operator|!=
literal|0
condition|)
name|speed
operator|*=
operator|(
literal|0x01
operator|<<
name|device
operator|->
name|bus_width
operator|)
expr_stmt|;
name|mb
operator|=
name|speed
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|mb
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d.%03dMB/s transfers "
argument_list|,
name|mb
argument_list|,
name|speed
operator|%
literal|1000
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%dKB/s transfers "
argument_list|,
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|cts
operator|.
name|valid
operator|&
name|CCB_TRANS_SYNC_OFFSET_VALID
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|cts
operator|.
name|sync_offset
operator|!=
literal|0
operator|)
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"(%d.%03dMHz, offset %d"
argument_list|,
name|freq
operator|/
literal|1000
argument_list|,
name|freq
operator|%
literal|1000
argument_list|,
name|ccb
operator|->
name|cts
operator|.
name|sync_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|cts
operator|.
name|valid
operator|&
name|CCB_TRANS_BUS_WIDTH_VALID
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|cts
operator|.
name|bus_width
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|cts
operator|.
name|valid
operator|&
name|CCB_TRANS_SYNC_OFFSET_VALID
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|cts
operator|.
name|sync_offset
operator|!=
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%dbit)"
argument_list|,
literal|8
operator|*
operator|(
literal|0x01
operator|<<
name|ccb
operator|->
name|cts
operator|.
name|bus_width
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|cts
operator|.
name|valid
operator|&
name|CCB_TRANS_SYNC_OFFSET_VALID
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|cts
operator|.
name|sync_offset
operator|!=
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|cts
operator|.
name|valid
operator|&
name|CCB_TRANS_TQ_VALID
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|cts
operator|.
name|flags
operator|&
name|CCB_TRANS_TAG_ENB
operator|)
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|", Tagged Queueing Enabled"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|xferrate_bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MINIMALISTIC */
end_comment

begin_comment
comment|/*  * Parse out a bus, or a bus, target and lun in the following  * format:  * bus  * bus:target  * bus:target:lun  *  * Returns the number of parsed components, or 0.  */
end_comment

begin_function
specifier|static
name|int
name|parse_btl
parameter_list|(
name|char
modifier|*
name|tstr
parameter_list|,
name|int
modifier|*
name|bus
parameter_list|,
name|int
modifier|*
name|target
parameter_list|,
name|int
modifier|*
name|lun
parameter_list|,
name|cam_argmask
modifier|*
name|arglist
parameter_list|)
block|{
name|char
modifier|*
name|tmpstr
decl_stmt|;
name|int
name|convs
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|tstr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
operator|*
name|bus
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|arglist
operator||=
name|CAM_ARG_BUS
expr_stmt|;
name|convs
operator|++
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
operator|*
name|target
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|arglist
operator||=
name|CAM_ARG_TARGET
expr_stmt|;
name|convs
operator|++
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
operator|*
name|lun
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|arglist
operator||=
name|CAM_ARG_LUN
expr_stmt|;
name|convs
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|convs
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dorescan_or_reset
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|rescan
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|must
index|[]
init|=
literal|"you must specify \"all\", a bus, or a bus:target:lun to %s"
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|bus
init|=
operator|-
literal|1
decl_stmt|,
name|target
init|=
operator|-
literal|1
decl_stmt|,
name|lun
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|tstr
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|warnx
argument_list|(
name|must
argument_list|,
name|rescan
condition|?
literal|"rescan"
else|:
literal|"reset"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|tstr
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|tstr
argument_list|,
literal|"all"
argument_list|,
name|strlen
argument_list|(
literal|"all"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|arglist
operator||=
name|CAM_ARG_BUS
expr_stmt|;
else|else
block|{
name|rv
operator|=
name|parse_btl
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
operator|&
name|bus
argument_list|,
operator|&
name|target
argument_list|,
operator|&
name|lun
argument_list|,
operator|&
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|1
operator|&&
name|rv
operator|!=
literal|3
condition|)
block|{
name|warnx
argument_list|(
name|must
argument_list|,
name|rescan
condition|?
literal|"rescan"
else|:
literal|"reset"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|arglist
operator|&
name|CAM_ARG_BUS
operator|)
operator|&&
operator|(
name|arglist
operator|&
name|CAM_ARG_TARGET
operator|)
operator|&&
operator|(
name|arglist
operator|&
name|CAM_ARG_LUN
operator|)
condition|)
name|error
operator|=
name|scanlun_or_reset_dev
argument_list|(
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|rescan
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|rescan_or_reset_bus
argument_list|(
name|bus
argument_list|,
name|rescan
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rescan_or_reset_bus
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|rescan
parameter_list|)
block|{
name|union
name|ccb
name|ccb
decl_stmt|,
name|matchccb
decl_stmt|;
name|int
name|curbus
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|retval
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XPT_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"error opening tranport layer device %s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bus
operator|!=
operator|-
literal|1
condition|)
block|{
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|rescan
condition|?
name|XPT_SCAN_BUS
else|:
name|XPT_RESET_BUS
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|path_id
operator|=
name|bus
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|CAM_LUN_WILDCARD
expr_stmt|;
name|ccb
operator|.
name|crcn
operator|.
name|flags
operator|=
name|CAM_FLAG_NONE
expr_stmt|;
comment|/* run this at a low priority */
name|ccb
operator|.
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"CAMIOCOMMAND ioctl failed"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s of bus %d was successful\n"
argument_list|,
name|rescan
condition|?
literal|"Re-scan"
else|:
literal|"Reset"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s of bus %d returned error %#x\n"
argument_list|,
name|rescan
condition|?
literal|"Re-scan"
else|:
literal|"Reset"
argument_list|,
name|bus
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 	 * The right way to handle this is to modify the xpt so that it can 	 * handle a wildcarded bus in a rescan or reset CCB.  At the moment 	 * that isn't implemented, so instead we enumerate the busses and 	 * send the rescan or reset to those busses in the case where the 	 * given bus is -1 (wildcard).  We don't send a rescan or reset 	 * to the xpt bus; sending a rescan to the xpt bus is effectively a 	 * no-op, sending a rescan to the xpt bus would result in a status of 	 * CAM_REQ_INVALID. 	 */
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|matchccb
operator|.
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_dev_match
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|matchccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEV_MATCH
expr_stmt|;
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
operator|*
literal|20
expr_stmt|;
name|matchccb
operator|.
name|cdm
operator|.
name|match_buf_len
operator|=
name|bufsize
expr_stmt|;
name|matchccb
operator|.
name|cdm
operator|.
name|matches
operator|=
operator|(
expr|struct
name|dev_match_result
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchccb
operator|.
name|cdm
operator|.
name|matches
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't malloc memory for matches"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|matchccb
operator|.
name|cdm
operator|.
name|num_matches
operator|=
literal|0
expr_stmt|;
name|matchccb
operator|.
name|cdm
operator|.
name|num_patterns
operator|=
literal|1
expr_stmt|;
name|matchccb
operator|.
name|cdm
operator|.
name|pattern_buf_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_pattern
argument_list|)
expr_stmt|;
name|matchccb
operator|.
name|cdm
operator|.
name|patterns
operator|=
operator|(
expr|struct
name|dev_match_pattern
operator|*
operator|)
name|malloc
argument_list|(
name|matchccb
operator|.
name|cdm
operator|.
name|pattern_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchccb
operator|.
name|cdm
operator|.
name|patterns
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't malloc memory for patterns"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|matchccb
operator|.
name|cdm
operator|.
name|patterns
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|DEV_MATCH_BUS
expr_stmt|;
name|matchccb
operator|.
name|cdm
operator|.
name|patterns
index|[
literal|0
index|]
operator|.
name|pattern
operator|.
name|bus_pattern
operator|.
name|flags
operator|=
name|BUS_MATCH_ANY
expr_stmt|;
do|do
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|matchccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"CAMIOCOMMAND ioctl failed"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|matchccb
operator|.
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
operator|)
operator|||
operator|(
operator|(
name|matchccb
operator|.
name|cdm
operator|.
name|status
operator|!=
name|CAM_DEV_MATCH_LAST
operator|)
operator|&&
operator|(
name|matchccb
operator|.
name|cdm
operator|.
name|status
operator|!=
name|CAM_DEV_MATCH_MORE
operator|)
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"got CAM error %#x, CDM error %d\n"
argument_list|,
name|matchccb
operator|.
name|ccb_h
operator|.
name|status
argument_list|,
name|matchccb
operator|.
name|cdm
operator|.
name|status
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|matchccb
operator|.
name|cdm
operator|.
name|num_matches
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bus_match_result
modifier|*
name|bus_result
decl_stmt|;
comment|/* This shouldn't happen. */
if|if
condition|(
name|matchccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|DEV_MATCH_BUS
condition|)
continue|continue;
name|bus_result
operator|=
operator|&
name|matchccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|result
operator|.
name|bus_result
expr_stmt|;
comment|/* 			 * We don't want to rescan or reset the xpt bus. 			 * See above. 			 */
if|if
condition|(
name|bus_result
operator|->
name|path_id
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|rescan
condition|?
name|XPT_SCAN_BUS
else|:
name|XPT_RESET_BUS
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|path_id
operator|=
name|bus_result
operator|->
name|path_id
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|CAM_LUN_WILDCARD
expr_stmt|;
name|ccb
operator|.
name|crcn
operator|.
name|flags
operator|=
name|CAM_FLAG_NONE
expr_stmt|;
comment|/* run this at a low priority */
name|ccb
operator|.
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"CAMIOCOMMAND ioctl failed"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s of bus %d was successful\n"
argument_list|,
name|rescan
condition|?
literal|"Re-scan"
else|:
literal|"Reset"
argument_list|,
name|bus_result
operator|->
name|path_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Don't bail out just yet, maybe the other 				 * rescan or reset commands will complete 				 * successfully. 				 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s of bus %d returned error "
literal|"%#x\n"
argument_list|,
name|rescan
condition|?
literal|"Re-scan"
else|:
literal|"Reset"
argument_list|,
name|bus_result
operator|->
name|path_id
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|matchccb
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|matchccb
operator|.
name|cdm
operator|.
name|status
operator|==
name|CAM_DEV_MATCH_MORE
operator|)
condition|)
do|;
name|bailout
label|:
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchccb
operator|.
name|cdm
operator|.
name|patterns
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|matchccb
operator|.
name|cdm
operator|.
name|patterns
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchccb
operator|.
name|cdm
operator|.
name|matches
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|matchccb
operator|.
name|cdm
operator|.
name|matches
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scanlun_or_reset_dev
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|,
name|int
name|scan
parameter_list|)
block|{
name|union
name|ccb
name|ccb
decl_stmt|;
name|struct
name|cam_device
modifier|*
name|device
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|device
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bus
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid bus number %d"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|target
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid target number %d"
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lun
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid lun number %d"
argument_list|,
name|lun
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XPT_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"error opening tranport layer device %s\n"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|device
operator|=
name|cam_open_btl
argument_list|(
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|O_RDWR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s"
argument_list|,
name|cam_errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
operator|(
name|scan
operator|)
condition|?
name|XPT_SCAN_LUN
else|:
name|XPT_RESET_DEV
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|path_id
operator|=
name|bus
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|target
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|lun
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|timeout
operator|=
literal|5000
expr_stmt|;
name|ccb
operator|.
name|crcn
operator|.
name|flags
operator|=
name|CAM_FLAG_NONE
expr_stmt|;
comment|/* run this at a low priority */
name|ccb
operator|.
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|scan
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"CAMIOCOMMAND ioctl failed"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending XPT_RESET_DEV CCB"
argument_list|)
expr_stmt|;
name|cam_close_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|scan
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
else|else
name|cam_close_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
comment|/* 	 * An error code of CAM_BDR_SENT is normal for a BDR request. 	 */
if|if
condition|(
operator|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
operator|)
operator|||
operator|(
operator|(
operator|!
name|scan
operator|)
operator|&&
operator|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_BDR_SENT
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s of %d:%d:%d was successful\n"
argument_list|,
name|scan
condition|?
literal|"Re-scan"
else|:
literal|"Reset"
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s of %d:%d:%d returned error %#x\n"
argument_list|,
name|scan
condition|?
literal|"Re-scan"
else|:
literal|"Reset"
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_function
specifier|static
name|int
name|readdefects
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|NULL
decl_stmt|;
name|struct
name|scsi_read_defect_data_10
modifier|*
name|rdd_cdb
decl_stmt|;
name|u_int8_t
modifier|*
name|defect_list
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|dlist_length
init|=
literal|65000
decl_stmt|;
name|u_int32_t
name|returned_length
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|num_returned
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|returned_format
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|c
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|lists_specified
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
block|{
name|char
modifier|*
name|tstr
decl_stmt|;
name|tstr
operator|=
name|optarg
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|tstr
argument_list|,
literal|"block"
argument_list|)
operator|==
literal|0
condition|)
name|arglist
operator||=
name|CAM_ARG_FORMAT_BLOCK
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tstr
argument_list|,
literal|"bfi"
argument_list|)
operator|==
literal|0
condition|)
name|arglist
operator||=
name|CAM_ARG_FORMAT_BFI
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tstr
argument_list|,
literal|"phys"
argument_list|)
operator|==
literal|0
condition|)
name|arglist
operator||=
name|CAM_ARG_FORMAT_PHYS
expr_stmt|;
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"invalid defect format %s"
argument_list|,
name|tstr
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
break|break;
block|}
case|case
literal|'G'
case|:
name|arglist
operator||=
name|CAM_ARG_GLIST
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|arglist
operator||=
name|CAM_ARG_PLIST
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
comment|/* 	 * Hopefully 65000 bytes is enough to hold the defect list.  If it 	 * isn't, the disk is probably dead already.  We'd have to go with 	 * 12 byte command (i.e. alloc_length is 32 bits instead of 16) 	 * to hold them all. 	 */
name|defect_list
operator|=
name|malloc
argument_list|(
name|dlist_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|defect_list
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't malloc memory for defect list"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
name|rdd_cdb
operator|=
operator|(
expr|struct
name|scsi_read_defect_data_10
operator|*
operator|)
operator|&
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
comment|/* 	 * cam_getccb() zeros the CCB header only.  So we need to zero the 	 * payload portion of the ccb. 	 */
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
operator||
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
operator|)
condition|?
name|CAM_PASS_ERR_RECOVER
else|:
literal|0
operator|)
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*data_ptr*/
name|defect_list
argument_list|,
comment|/*dxfer_len*/
name|dlist_length
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*cdb_len*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_defect_data_10
argument_list|)
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
name|rdd_cdb
operator|->
name|opcode
operator|=
name|READ_DEFECT_DATA_10
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_FORMAT_BLOCK
condition|)
name|rdd_cdb
operator|->
name|format
operator|=
name|SRDD10_BLOCK_FORMAT
expr_stmt|;
elseif|else
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_FORMAT_BFI
condition|)
name|rdd_cdb
operator|->
name|format
operator|=
name|SRDD10_BYTES_FROM_INDEX_FORMAT
expr_stmt|;
elseif|else
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_FORMAT_PHYS
condition|)
name|rdd_cdb
operator|->
name|format
operator|=
name|SRDD10_PHYSICAL_SECTOR_FORMAT
expr_stmt|;
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"no defect list format specified"
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_PLIST
condition|)
block|{
name|rdd_cdb
operator|->
name|format
operator||=
name|SRDD10_PLIST
expr_stmt|;
name|lists_specified
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_GLIST
condition|)
block|{
name|rdd_cdb
operator|->
name|format
operator||=
name|SRDD10_GLIST
expr_stmt|;
name|lists_specified
operator|++
expr_stmt|;
block|}
name|scsi_ulto2b
argument_list|(
name|dlist_length
argument_list|,
name|rdd_cdb
operator|->
name|alloc_length
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error reading defect list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
name|returned_length
operator|=
name|scsi_2btoul
argument_list|(
operator|(
operator|(
expr|struct
name|scsi_read_defect_data_hdr_10
operator|*
operator|)
name|defect_list
operator|)
operator|->
name|length
argument_list|)
expr_stmt|;
name|returned_format
operator|=
operator|(
operator|(
expr|struct
name|scsi_read_defect_data_hdr_10
operator|*
operator|)
name|defect_list
operator|)
operator|->
name|format
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|==
name|SCSI_STATUS_CHECK_COND
operator|)
operator|&&
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|sense
operator|=
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|scsi_extract_sense
argument_list|(
name|sense
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|)
expr_stmt|;
comment|/* 		 * According to the SCSI spec, if the disk doesn't support 		 * the requested format, it will generally return a sense 		 * key of RECOVERED ERROR, and an additional sense code 		 * of "DEFECT LIST NOT FOUND".  So, we check for that, and 		 * also check to make sure that the returned length is 		 * greater than 0, and then print out whatever format the 		 * disk gave us. 		 */
if|if
condition|(
operator|(
name|sense_key
operator|==
name|SSD_KEY_RECOVERED_ERROR
operator|)
operator|&&
operator|(
name|asc
operator|==
literal|0x1c
operator|)
operator|&&
operator|(
name|ascq
operator|==
literal|0x00
operator|)
operator|&&
operator|(
name|returned_length
operator|>
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"requested defect format not available"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|returned_format
operator|&
name|SRDDH10_DLIST_FORMAT_MASK
condition|)
block|{
case|case
name|SRDD10_BLOCK_FORMAT
case|:
name|warnx
argument_list|(
literal|"Device returned block format"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SRDD10_BYTES_FROM_INDEX_FORMAT
case|:
name|warnx
argument_list|(
literal|"Device returned bytes from index"
literal|" format"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SRDD10_PHYSICAL_SECTOR_FORMAT
case|:
name|warnx
argument_list|(
literal|"Device returned physical sector format"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"Device returned unknown defect"
literal|" data format %#x"
argument_list|,
name|returned_format
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
break|break;
comment|/* NOTREACHED */
block|}
block|}
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"Error returned from read defect data command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"Error returned from read defect data command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
comment|/* 	 * XXX KDM  I should probably clean up the printout format for the 	 * disk defects.  	 */
switch|switch
condition|(
name|returned_format
operator|&
name|SRDDH10_DLIST_FORMAT_MASK
condition|)
block|{
case|case
name|SRDDH10_PHYSICAL_SECTOR_FORMAT
case|:
block|{
name|struct
name|scsi_defect_desc_phys_sector
modifier|*
name|dlist
decl_stmt|;
name|dlist
operator|=
operator|(
expr|struct
name|scsi_defect_desc_phys_sector
operator|*
operator|)
operator|(
name|defect_list
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_defect_data_hdr_10
argument_list|)
operator|)
expr_stmt|;
name|num_returned
operator|=
name|returned_length
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_defect_desc_phys_sector
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got %d defect"
argument_list|,
name|num_returned
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lists_specified
operator|==
literal|0
operator|)
operator|||
operator|(
name|num_returned
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|num_returned
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_returned
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d:%d:%d\n"
argument_list|,
name|scsi_3btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|cylinder
argument_list|)
argument_list|,
name|dlist
index|[
name|i
index|]
operator|.
name|head
argument_list|,
name|scsi_4btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|sector
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SRDDH10_BYTES_FROM_INDEX_FORMAT
case|:
block|{
name|struct
name|scsi_defect_desc_bytes_from_index
modifier|*
name|dlist
decl_stmt|;
name|dlist
operator|=
operator|(
expr|struct
name|scsi_defect_desc_bytes_from_index
operator|*
operator|)
operator|(
name|defect_list
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_defect_data_hdr_10
argument_list|)
operator|)
expr_stmt|;
name|num_returned
operator|=
name|returned_length
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_defect_desc_bytes_from_index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got %d defect"
argument_list|,
name|num_returned
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lists_specified
operator|==
literal|0
operator|)
operator|||
operator|(
name|num_returned
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|num_returned
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_returned
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d:%d:%d\n"
argument_list|,
name|scsi_3btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|cylinder
argument_list|)
argument_list|,
name|dlist
index|[
name|i
index|]
operator|.
name|head
argument_list|,
name|scsi_4btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|bytes_from_index
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SRDDH10_BLOCK_FORMAT
case|:
block|{
name|struct
name|scsi_defect_desc_block
modifier|*
name|dlist
decl_stmt|;
name|dlist
operator|=
operator|(
expr|struct
name|scsi_defect_desc_block
operator|*
operator|)
operator|(
name|defect_list
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_defect_data_hdr_10
argument_list|)
operator|)
expr_stmt|;
name|num_returned
operator|=
name|returned_length
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_defect_desc_block
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got %d defect"
argument_list|,
name|num_returned
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lists_specified
operator|==
literal|0
operator|)
operator|||
operator|(
name|num_returned
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|num_returned
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_returned
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%u\n"
argument_list|,
name|scsi_4btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|address
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown defect format %d\n"
argument_list|,
name|returned_format
operator|&
name|SRDDH10_DLIST_FORMAT_MASK
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|defect_bailout
label|:
if|if
condition|(
name|defect_list
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|defect_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MINIMALISTIC */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void reassignblocks(struct cam_device *device, u_int32_t *blocks, int num_blocks) { 	union ccb *ccb; 	 	ccb = cam_getccb(device);  	cam_freeccb(ccb); }
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_function
name|void
name|mode_sense
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|mode_page
parameter_list|,
name|int
name|page_control
parameter_list|,
name|int
name|dbd
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|int
name|datalen
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"mode_sense: couldn't allocate CCB"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_mode_sense
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* dbd */
name|dbd
argument_list|,
comment|/* page_code */
name|page_control
operator|<<
literal|6
argument_list|,
comment|/* page */
name|mode_page
argument_list|,
comment|/* param_buf */
name|data
argument_list|,
comment|/* param_len */
name|datalen
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|cam_close_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"error sending mode sense command"
argument_list|)
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error sending mode sense command"
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mode_select
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|save_pages
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|int
name|datalen
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"mode_select: couldn't allocate CCB"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_mode_select
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* scsi_page_fmt */
literal|1
argument_list|,
comment|/* save_pages */
name|save_pages
argument_list|,
comment|/* param_buf */
name|data
argument_list|,
comment|/* param_len */
name|datalen
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|cam_close_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"error sending mode select command"
argument_list|)
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error sending mode select command"
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|modepage
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|mode_page
init|=
operator|-
literal|1
decl_stmt|,
name|page_control
init|=
literal|0
decl_stmt|;
name|int
name|binary
init|=
literal|0
decl_stmt|,
name|list
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|binary
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|arglist
operator||=
name|CAM_ARG_DBD
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|arglist
operator||=
name|CAM_ARG_MODE_EDIT
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|list
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mode_page
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_page
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid mode page %d"
argument_list|,
name|mode_page
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|page_control
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|page_control
operator|<
literal|0
operator|)
operator|||
operator|(
name|page_control
operator|>
literal|3
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid page control field %d"
argument_list|,
name|page_control
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_PAGE_CNTL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|mode_page
operator|==
operator|-
literal|1
operator|&&
name|list
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"you must specify a mode page!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
block|{
name|mode_list
argument_list|(
name|device
argument_list|,
name|page_control
argument_list|,
name|arglist
operator|&
name|CAM_ARG_DBD
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mode_edit
argument_list|(
name|device
argument_list|,
name|mode_page
argument_list|,
name|page_control
argument_list|,
name|arglist
operator|&
name|CAM_ARG_DBD
argument_list|,
name|arglist
operator|&
name|CAM_ARG_MODE_EDIT
argument_list|,
name|binary
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|scsicmd
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int32_t
name|flags
init|=
name|CAM_DIR_NONE
decl_stmt|;
name|u_int8_t
modifier|*
name|data_ptr
init|=
name|NULL
decl_stmt|;
name|u_int8_t
name|cdb
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|get_hook
name|hook
decl_stmt|;
name|int
name|c
decl_stmt|,
name|data_bytes
init|=
literal|0
decl_stmt|;
name|int
name|cdb_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|datastr
init|=
name|NULL
decl_stmt|,
modifier|*
name|tstr
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|fd_data
init|=
literal|0
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"scsicmd: error allocating ccb"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|tstr
operator|=
name|optarg
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
name|hook
operator|.
name|argc
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|hook
operator|.
name|argv
operator|=
name|argv
operator|+
name|optind
expr_stmt|;
name|hook
operator|.
name|got
operator|=
literal|0
expr_stmt|;
name|cdb_len
operator|=
name|buff_encode_visit
argument_list|(
name|cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb
argument_list|)
argument_list|,
name|tstr
argument_list|,
name|iget
argument_list|,
operator|&
name|hook
argument_list|)
expr_stmt|;
comment|/* 			 * Increment optind by the number of arguments the 			 * encoding routine processed.  After each call to 			 * getopt(3), optind points to the argument that 			 * getopt should process _next_.  In this case, 			 * that means it points to the first command string 			 * argument, if there is one.  Once we increment 			 * this, it should point to either the next command 			 * line argument, or it should be past the end of 			 * the list. 			 */
name|optind
operator|+=
name|hook
operator|.
name|got
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_CMD_OUT
condition|)
block|{
name|warnx
argument_list|(
literal|"command must either be "
literal|"read or write, not both"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
name|arglist
operator||=
name|CAM_ARG_CMD_IN
expr_stmt|;
name|flags
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|data_bytes
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_bytes
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid number of input bytes %d"
argument_list|,
name|data_bytes
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
name|hook
operator|.
name|argc
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|hook
operator|.
name|argv
operator|=
name|argv
operator|+
name|optind
expr_stmt|;
name|hook
operator|.
name|got
operator|=
literal|0
expr_stmt|;
name|optind
operator|++
expr_stmt|;
name|datastr
operator|=
name|cget
argument_list|(
operator|&
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * If the user supplied "-" instead of a format, he 			 * wants the data to be written to stdout. 			 */
if|if
condition|(
operator|(
name|datastr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|datastr
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
name|fd_data
operator|=
literal|1
expr_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|malloc
argument_list|(
name|data_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_ptr
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't malloc memory for data_ptr"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_CMD_IN
condition|)
block|{
name|warnx
argument_list|(
literal|"command must either be "
literal|"read or write, not both"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
name|arglist
operator||=
name|CAM_ARG_CMD_OUT
expr_stmt|;
name|flags
operator|=
name|CAM_DIR_OUT
expr_stmt|;
name|data_bytes
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_bytes
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid number of output bytes %d"
argument_list|,
name|data_bytes
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
name|hook
operator|.
name|argc
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|hook
operator|.
name|argv
operator|=
name|argv
operator|+
name|optind
expr_stmt|;
name|hook
operator|.
name|got
operator|=
literal|0
expr_stmt|;
name|datastr
operator|=
name|cget
argument_list|(
operator|&
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|malloc
argument_list|(
name|data_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_ptr
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't malloc memory for data_ptr"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
comment|/* 			 * If the user supplied "-" instead of a format, he 			 * wants the data to be read from stdin. 			 */
if|if
condition|(
operator|(
name|datastr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|datastr
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
name|fd_data
operator|=
literal|1
expr_stmt|;
else|else
name|buff_encode_visit
argument_list|(
name|data_ptr
argument_list|,
name|data_bytes
argument_list|,
name|datastr
argument_list|,
name|iget
argument_list|,
operator|&
name|hook
argument_list|)
expr_stmt|;
name|optind
operator|+=
name|hook
operator|.
name|got
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * If fd_data is set, and we're writing to the device, we need to 	 * read the data the user wants written from stdin. 	 */
if|if
condition|(
operator|(
name|fd_data
operator|==
literal|1
operator|)
operator|&&
operator|(
name|arglist
operator|&
name|CAM_ARG_CMD_OUT
operator|)
condition|)
block|{
name|size_t
name|amt_read
decl_stmt|;
name|int
name|amt_to_read
init|=
name|data_bytes
decl_stmt|;
name|u_int8_t
modifier|*
name|buf_ptr
init|=
name|data_ptr
decl_stmt|;
for|for
control|(
name|amt_read
operator|=
literal|0
init|;
name|amt_to_read
operator|>
literal|0
condition|;
name|amt_read
operator|=
name|read
argument_list|(
name|STDIN_FILENO
argument_list|,
name|buf_ptr
argument_list|,
name|amt_to_read
argument_list|)
control|)
block|{
if|if
condition|(
name|amt_read
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"error reading data from stdin"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
name|amt_to_read
operator|-=
name|amt_read
expr_stmt|;
name|buf_ptr
operator|+=
name|amt_read
expr_stmt|;
block|}
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
comment|/* Disable freezing the device queue */
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
comment|/* 	 * This is taken from the SCSI-3 draft spec. 	 * (T10/1157D revision 0.3) 	 * The top 3 bits of an opcode are the group code.  The next 5 bits 	 * are the command code. 	 * Group 0:  six byte commands 	 * Group 1:  ten byte commands 	 * Group 2:  ten byte commands 	 * Group 3:  reserved 	 * Group 4:  sixteen byte commands 	 * Group 5:  twelve byte commands 	 * Group 6:  vendor specific 	 * Group 7:  vendor specific 	 */
switch|switch
condition|(
operator|(
name|cdb
index|[
literal|0
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x7
condition|)
block|{
case|case
literal|0
case|:
name|cdb_len
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|cdb_len
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
comment|/* computed by buff_encode_visit */
break|break;
case|case
literal|4
case|:
name|cdb_len
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|cdb_len
operator|=
literal|12
expr_stmt|;
break|break;
block|}
comment|/* 	 * We should probably use csio_build_visit or something like that 	 * here, but it's easier to encode arguments as you go.  The 	 * alternative would be skipping the CDB argument and then encoding 	 * it here, since we've got the data buffer argument by now. 	 */
name|bcopy
argument_list|(
name|cdb
argument_list|,
operator|&
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|cdb_len
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*flags*/
name|flags
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|data_bytes
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*cdb_len*/
name|cdb_len
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"error sending command"
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"error sending command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|arglist
operator|&
name|CAM_ARG_CMD_IN
operator|)
operator|&&
operator|(
name|data_bytes
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|fd_data
operator|==
literal|0
condition|)
block|{
name|buff_decode_visit
argument_list|(
name|data_ptr
argument_list|,
name|data_bytes
argument_list|,
name|datastr
argument_list|,
name|arg_put
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|amt_written
decl_stmt|;
name|int
name|amt_to_write
init|=
name|data_bytes
decl_stmt|;
name|u_int8_t
modifier|*
name|buf_ptr
init|=
name|data_ptr
decl_stmt|;
for|for
control|(
name|amt_written
operator|=
literal|0
init|;
operator|(
name|amt_to_write
operator|>
literal|0
operator|)
operator|&&
operator|(
name|amt_written
operator|=
name|write
argument_list|(
literal|1
argument_list|,
name|buf_ptr
argument_list|,
name|amt_to_write
argument_list|)
operator|)
operator|>
literal|0
condition|;
control|)
block|{
name|amt_to_write
operator|-=
name|amt_written
expr_stmt|;
name|buf_ptr
operator|+=
name|amt_written
expr_stmt|;
block|}
if|if
condition|(
name|amt_written
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"error writing data to stdout"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|amt_written
operator|==
literal|0
operator|)
operator|&&
operator|(
name|amt_to_write
operator|>
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"only wrote %u bytes out of %u"
argument_list|,
name|data_bytes
operator|-
name|amt_to_write
argument_list|,
name|data_bytes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|scsicmd_bailout
label|:
if|if
condition|(
operator|(
name|data_bytes
operator|>
literal|0
operator|)
operator|&&
operator|(
name|data_ptr
operator|!=
name|NULL
operator|)
condition|)
name|free
argument_list|(
name|data_ptr
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|camdebug
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|fd
decl_stmt|;
name|int
name|bus
init|=
operator|-
literal|1
decl_stmt|,
name|target
init|=
operator|-
literal|1
decl_stmt|,
name|lun
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|tstr
decl_stmt|,
modifier|*
name|tmpstr
init|=
name|NULL
decl_stmt|;
name|union
name|ccb
name|ccb
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|ccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'I'
case|:
name|arglist
operator||=
name|CAM_ARG_DEBUG_INFO
expr_stmt|;
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator||=
name|CAM_DEBUG_INFO
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|arglist
operator||=
name|CAM_ARG_DEBUG_SUBTRACE
expr_stmt|;
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator||=
name|CAM_DEBUG_SUBTRACE
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|arglist
operator||=
name|CAM_ARG_DEBUG_TRACE
expr_stmt|;
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator||=
name|CAM_DEBUG_TRACE
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|arglist
operator||=
name|CAM_ARG_DEBUG_CDB
expr_stmt|;
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator||=
name|CAM_DEBUG_CDB
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XPT_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"error opening transport layer device %s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"you must specify \"off\", \"all\" or a bus,"
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"bus:target, or bus:target:lun"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|tstr
operator|=
operator|*
name|argv
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|tstr
argument_list|,
literal|"off"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator|=
name|CAM_DEBUG_NONE
expr_stmt|;
name|arglist
operator|&=
operator|~
operator|(
name|CAM_ARG_DEBUG_INFO
operator||
name|CAM_ARG_DEBUG_TRACE
operator||
name|CAM_ARG_DEBUG_SUBTRACE
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|tstr
argument_list|,
literal|"all"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|tstr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|bus
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_BUS
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|target
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_TARGET
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|lun
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_LUN
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"you must specify \"all\", \"off\", or a bus,"
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"bus:target, or bus:target:lun to debug"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEBUG
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|path_id
operator|=
name|bus
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|target
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|lun
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"CAMIOCOMMAND ioctl failed"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_FUNC_NOTAVAIL
condition|)
block|{
name|warnx
argument_list|(
literal|"CAM debugging not available"
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"you need to put options CAMDEBUG in"
literal|" your kernel config file!"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"XPT_DEBUG CCB failed with status %#x"
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator|==
name|CAM_DEBUG_NONE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debugging turned off\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debugging enabled for "
literal|"%d:%d:%d\n"
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tagcontrol
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|numtags
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|quiet
init|=
literal|0
decl_stmt|;
name|char
name|pathstr
index|[
literal|1024
index|]
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"tagcontrol: error allocating ccb"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'N'
case|:
name|numtags
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|numtags
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"tag count %d is< 0"
argument_list|,
name|numtags
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|tagcontrol_bailout
goto|;
block|}
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|cam_path_string
argument_list|(
name|device
argument_list|,
name|pathstr
argument_list|,
sizeof|sizeof
argument_list|(
name|pathstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numtags
operator|>=
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_relsim
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_REL_SIMQ
expr_stmt|;
name|ccb
operator|->
name|crs
operator|.
name|release_flags
operator|=
name|RELSIM_ADJUST_OPENINGS
expr_stmt|;
name|ccb
operator|->
name|crs
operator|.
name|openings
operator|=
name|numtags
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending XPT_REL_SIMQ CCB"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|tagcontrol_bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"XPT_REL_SIMQ CCB failed"
argument_list|)
expr_stmt|;
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|tagcontrol_bailout
goto|;
block|}
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%stagged openings now %d\n"
argument_list|,
name|pathstr
argument_list|,
name|ccb
operator|->
name|crs
operator|.
name|openings
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_getdev
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_STATS
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending XPT_GDEV_STATS CCB"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|tagcontrol_bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"XPT_GDEV_STATS CCB failed"
argument_list|)
expr_stmt|;
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|tagcontrol_bailout
goto|;
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"dev_openings  %d\n"
argument_list|,
name|ccb
operator|->
name|cgds
operator|.
name|dev_openings
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"dev_active    %d\n"
argument_list|,
name|ccb
operator|->
name|cgds
operator|.
name|dev_active
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"devq_openings %d\n"
argument_list|,
name|ccb
operator|->
name|cgds
operator|.
name|devq_openings
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"devq_queued   %d\n"
argument_list|,
name|ccb
operator|->
name|cgds
operator|.
name|devq_queued
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"held          %d\n"
argument_list|,
name|ccb
operator|->
name|cgds
operator|.
name|held
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"mintags       %d\n"
argument_list|,
name|ccb
operator|->
name|cgds
operator|.
name|mintags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"maxtags       %d\n"
argument_list|,
name|ccb
operator|->
name|cgds
operator|.
name|maxtags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"device openings: "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d\n"
argument_list|,
name|ccb
operator|->
name|cgds
operator|.
name|dev_openings
operator|+
name|ccb
operator|->
name|cgds
operator|.
name|dev_active
argument_list|)
expr_stmt|;
block|}
name|tagcontrol_bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cts_print
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
block|{
name|char
name|pathstr
index|[
literal|1024
index|]
decl_stmt|;
name|cam_path_string
argument_list|(
name|device
argument_list|,
name|pathstr
argument_list|,
sizeof|sizeof
argument_list|(
name|pathstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_RATE_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%ssync parameter: %d\n"
argument_list|,
name|pathstr
argument_list|,
name|cts
operator|->
name|sync_period
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|sync_offset
operator|!=
literal|0
condition|)
block|{
name|u_int
name|freq
decl_stmt|;
name|freq
operator|=
name|scsi_calc_syncsrate
argument_list|(
name|cts
operator|->
name|sync_period
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sfrequency: %d.%03dMHz\n"
argument_list|,
name|pathstr
argument_list|,
name|freq
operator|/
literal|1000
argument_list|,
name|freq
operator|%
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_OFFSET_VALID
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%soffset: %d\n"
argument_list|,
name|pathstr
argument_list|,
name|cts
operator|->
name|sync_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_BUS_WIDTH_VALID
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sbus width: %d bits\n"
argument_list|,
name|pathstr
argument_list|,
operator|(
literal|0x01
operator|<<
name|cts
operator|->
name|bus_width
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_DISC_VALID
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sdisconnection is %s\n"
argument_list|,
name|pathstr
argument_list|,
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_DISC_ENB
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_TQ_VALID
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%stagged queueing is %s\n"
argument_list|,
name|pathstr
argument_list|,
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_TAG_ENB
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a path inquiry CCB for the specified device.    */
end_comment

begin_function
specifier|static
name|int
name|get_cpi
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|struct
name|ccb_pathinq
modifier|*
name|cpi
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"get_cpi: couldn't allocate CCB"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_pathinq
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"get_cpi: error sending Path Inquiry CCB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|get_cpi_bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|get_cpi_bailout
goto|;
block|}
name|bcopy
argument_list|(
operator|&
name|ccb
operator|->
name|cpi
argument_list|,
name|cpi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_pathinq
argument_list|)
argument_list|)
expr_stmt|;
name|get_cpi_bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cpi_print
parameter_list|(
name|struct
name|ccb_pathinq
modifier|*
name|cpi
parameter_list|)
block|{
name|char
name|adapter_str
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|snprintf
argument_list|(
name|adapter_str
argument_list|,
sizeof|sizeof
argument_list|(
name|adapter_str
argument_list|)
argument_list|,
literal|"%s%d:"
argument_list|,
name|cpi
operator|->
name|dev_name
argument_list|,
name|cpi
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s SIM/HBA version: %d\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|version_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|0xff
condition|;
name|i
operator|=
name|i
operator|<<
literal|1
control|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
name|cpi
operator|->
name|hba_inquiry
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s supports "
argument_list|,
name|adapter_str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|PI_MDP_ABLE
case|:
name|str
operator|=
literal|"MDP message"
expr_stmt|;
break|break;
case|case
name|PI_WIDE_32
case|:
name|str
operator|=
literal|"32 bit wide SCSI"
expr_stmt|;
break|break;
case|case
name|PI_WIDE_16
case|:
name|str
operator|=
literal|"16 bit wide SCSI"
expr_stmt|;
break|break;
case|case
name|PI_SDTR_ABLE
case|:
name|str
operator|=
literal|"SDTR message"
expr_stmt|;
break|break;
case|case
name|PI_LINKED_CDB
case|:
name|str
operator|=
literal|"linked CDBs"
expr_stmt|;
break|break;
case|case
name|PI_TAG_ABLE
case|:
name|str
operator|=
literal|"tag queue messages"
expr_stmt|;
break|break;
case|case
name|PI_SOFT_RST
case|:
name|str
operator|=
literal|"soft reset alternative"
expr_stmt|;
break|break;
default|default:
name|str
operator|=
literal|"unknown PI bit set"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|0xff
condition|;
name|i
operator|=
name|i
operator|<<
literal|1
control|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
name|cpi
operator|->
name|hba_misc
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s "
argument_list|,
name|adapter_str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|PIM_SCANHILO
case|:
name|str
operator|=
literal|"bus scans from high ID to low ID"
expr_stmt|;
break|break;
case|case
name|PIM_NOREMOVE
case|:
name|str
operator|=
literal|"removable devices not included in scan"
expr_stmt|;
break|break;
case|case
name|PIM_NOINITIATOR
case|:
name|str
operator|=
literal|"initiator role not supported"
expr_stmt|;
break|break;
case|case
name|PIM_NOBUSRESET
case|:
name|str
operator|=
literal|"user has disabled initial BUS RESET or"
literal|" controller is in target/mixed mode"
expr_stmt|;
break|break;
default|default:
name|str
operator|=
literal|"unknown PIM bit set"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|0xff
condition|;
name|i
operator|=
name|i
operator|<<
literal|1
control|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
name|cpi
operator|->
name|target_sprt
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s supports "
argument_list|,
name|adapter_str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|PIT_PROCESSOR
case|:
name|str
operator|=
literal|"target mode processor mode"
expr_stmt|;
break|break;
case|case
name|PIT_PHASE
case|:
name|str
operator|=
literal|"target mode phase cog. mode"
expr_stmt|;
break|break;
case|case
name|PIT_DISCONNECT
case|:
name|str
operator|=
literal|"disconnects in target mode"
expr_stmt|;
break|break;
case|case
name|PIT_TERM_IO
case|:
name|str
operator|=
literal|"terminate I/O message in target mode"
expr_stmt|;
break|break;
case|case
name|PIT_GRP_6
case|:
name|str
operator|=
literal|"group 6 commands in target mode"
expr_stmt|;
break|break;
case|case
name|PIT_GRP_7
case|:
name|str
operator|=
literal|"group 7 commands in target mode"
expr_stmt|;
break|break;
default|default:
name|str
operator|=
literal|"unknown PIT bit set"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s HBA engine count: %d\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|hba_eng_cnt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s maximum target: %d\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|max_target
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s maximum LUN: %d\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|max_lun
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s highest path ID in subsystem: %d\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|hpath_id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s initiator ID: %d\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|initiator_id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s SIM vendor: %s\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|sim_vid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s HBA vendor: %s\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|hba_vid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s bus ID: %d\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|bus_id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s base transfer speed: "
argument_list|,
name|adapter_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpi
operator|->
name|base_transfer_speed
operator|>
literal|1000
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d.%03dMB/sec\n"
argument_list|,
name|cpi
operator|->
name|base_transfer_speed
operator|/
literal|1000
argument_list|,
name|cpi
operator|->
name|base_transfer_speed
operator|%
literal|1000
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%dKB/sec\n"
argument_list|,
operator|(
name|cpi
operator|->
name|base_transfer_speed
operator|%
literal|1000
operator|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_print_cts
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|user_settings
parameter_list|,
name|int
name|quiet
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"get_print_cts: error allocating ccb"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_trans_settings
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GET_TRAN_SETTINGS
expr_stmt|;
if|if
condition|(
name|user_settings
operator|==
literal|0
condition|)
name|ccb
operator|->
name|cts
operator|.
name|flags
operator|=
name|CCB_TRANS_CURRENT_SETTINGS
expr_stmt|;
else|else
name|ccb
operator|->
name|cts
operator|.
name|flags
operator|=
name|CCB_TRANS_USER_SETTINGS
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending XPT_GET_TRAN_SETTINGS CCB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|get_print_cts_bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"XPT_GET_TRANS_SETTINGS CCB failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|get_print_cts_bailout
goto|;
block|}
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|cts_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|cts
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
operator|&
name|ccb
operator|->
name|cts
argument_list|,
name|cts
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_trans_settings
argument_list|)
argument_list|)
expr_stmt|;
name|get_print_cts_bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ratecontrol
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|user_settings
init|=
literal|0
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|disc_enable
init|=
operator|-
literal|1
decl_stmt|,
name|tag_enable
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|offset
init|=
operator|-
literal|1
decl_stmt|;
name|double
name|syncrate
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bus_width
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|quiet
init|=
literal|0
decl_stmt|;
name|int
name|change_settings
init|=
literal|0
decl_stmt|,
name|send_tur
init|=
literal|0
decl_stmt|;
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"ratecontrol: error allocating ccb"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|send_tur
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|user_settings
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|strncasecmp
argument_list|(
name|optarg
argument_list|,
literal|"enable"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|disc_enable
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|optarg
argument_list|,
literal|"disable"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|disc_enable
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"-D argument \"%s\" is unknown"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|change_settings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|offset
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"offset value %d is< 0"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|change_settings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|++
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|syncrate
operator|=
name|atof
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|syncrate
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"sync rate %f is< 0"
argument_list|,
name|syncrate
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|change_settings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|strncasecmp
argument_list|(
name|optarg
argument_list|,
literal|"enable"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|tag_enable
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|optarg
argument_list|,
literal|"disable"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|tag_enable
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"-T argument \"%s\" is unknown"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|change_settings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|user_settings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|bus_width
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_width
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"bus width %d is< 0"
argument_list|,
name|bus_width
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|change_settings
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_pathinq
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Grab path inquiry information, so we can determine whether 	 * or not the initiator is capable of the things that the user 	 * requests. 	 */
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending XPT_PATH_INQ CCB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"XPT_PATH_INQ CCB failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|bcopy
argument_list|(
operator|&
name|ccb
operator|->
name|cpi
argument_list|,
operator|&
name|cpi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_pathinq
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_trans_settings
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Current Parameters:\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|get_print_cts
argument_list|(
name|device
argument_list|,
name|user_settings
argument_list|,
name|quiet
argument_list|,
operator|&
name|ccb
operator|->
name|cts
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|ratecontrol_bailout
goto|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cpi_print
argument_list|(
operator|&
name|cpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|change_settings
condition|)
block|{
if|if
condition|(
name|disc_enable
operator|!=
operator|-
literal|1
condition|)
block|{
name|ccb
operator|->
name|cts
operator|.
name|valid
operator||=
name|CCB_TRANS_DISC_VALID
expr_stmt|;
if|if
condition|(
name|disc_enable
operator|==
literal|0
condition|)
name|ccb
operator|->
name|cts
operator|.
name|flags
operator|&=
operator|~
name|CCB_TRANS_DISC_ENB
expr_stmt|;
else|else
name|ccb
operator|->
name|cts
operator|.
name|flags
operator||=
name|CCB_TRANS_DISC_ENB
expr_stmt|;
block|}
else|else
name|ccb
operator|->
name|cts
operator|.
name|valid
operator|&=
operator|~
name|CCB_TRANS_DISC_VALID
expr_stmt|;
if|if
condition|(
name|tag_enable
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
name|PI_TAG_ABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"HBA does not support tagged queueing, "
literal|"so you cannot modify tag settings"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|ccb
operator|->
name|cts
operator|.
name|valid
operator||=
name|CCB_TRANS_TQ_VALID
expr_stmt|;
if|if
condition|(
name|tag_enable
operator|==
literal|0
condition|)
name|ccb
operator|->
name|cts
operator|.
name|flags
operator|&=
operator|~
name|CCB_TRANS_TAG_ENB
expr_stmt|;
else|else
name|ccb
operator|->
name|cts
operator|.
name|flags
operator||=
name|CCB_TRANS_TAG_ENB
expr_stmt|;
block|}
else|else
name|ccb
operator|->
name|cts
operator|.
name|valid
operator|&=
operator|~
name|CCB_TRANS_TQ_VALID
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
name|PI_SDTR_ABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"HBA at %s%d is not cable of changing "
literal|"offset"
argument_list|,
name|cpi
operator|.
name|dev_name
argument_list|,
name|cpi
operator|.
name|unit_number
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|ccb
operator|->
name|cts
operator|.
name|valid
operator||=
name|CCB_TRANS_SYNC_OFFSET_VALID
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|sync_offset
operator|=
name|offset
expr_stmt|;
block|}
else|else
name|ccb
operator|->
name|cts
operator|.
name|valid
operator|&=
operator|~
name|CCB_TRANS_SYNC_OFFSET_VALID
expr_stmt|;
if|if
condition|(
name|syncrate
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|prelim_sync_period
decl_stmt|;
name|u_int
name|freq
decl_stmt|;
if|if
condition|(
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
name|PI_SDTR_ABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"HBA at %s%d is not cable of changing "
literal|"transfer rates"
argument_list|,
name|cpi
operator|.
name|dev_name
argument_list|,
name|cpi
operator|.
name|unit_number
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|ccb
operator|->
name|cts
operator|.
name|valid
operator||=
name|CCB_TRANS_SYNC_RATE_VALID
expr_stmt|;
comment|/* 			 * The sync rate the user gives us is in MHz. 			 * We need to translate it into KHz for this 			 * calculation. 			 */
name|syncrate
operator|*=
literal|1000
expr_stmt|;
comment|/* 			 * Next, we calculate a "preliminary" sync period 			 * in tenths of a nanosecond. 			 */
if|if
condition|(
name|syncrate
operator|==
literal|0
condition|)
name|prelim_sync_period
operator|=
literal|0
expr_stmt|;
else|else
name|prelim_sync_period
operator|=
literal|10000000
operator|/
name|syncrate
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|sync_period
operator|=
name|scsi_calc_syncparam
argument_list|(
name|prelim_sync_period
argument_list|)
expr_stmt|;
name|freq
operator|=
name|scsi_calc_syncsrate
argument_list|(
name|ccb
operator|->
name|cts
operator|.
name|sync_period
argument_list|)
expr_stmt|;
block|}
else|else
name|ccb
operator|->
name|cts
operator|.
name|valid
operator|&=
operator|~
name|CCB_TRANS_SYNC_RATE_VALID
expr_stmt|;
comment|/* 		 * The bus_width argument goes like this: 		 * 0 == 8 bit 		 * 1 == 16 bit 		 * 2 == 32 bit 		 * Therefore, if you shift the number of bits given on the 		 * command line right by 4, you should get the correct 		 * number. 		 */
if|if
condition|(
name|bus_width
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 			 * We might as well validate things here with a 			 * decipherable error message, rather than what 			 * will probably be an indecipherable error message 			 * by the time it gets back to us. 			 */
if|if
condition|(
operator|(
name|bus_width
operator|==
literal|16
operator|)
operator|&&
operator|(
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
name|PI_WIDE_16
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"HBA does not support 16 bit bus width"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bus_width
operator|==
literal|32
operator|)
operator|&&
operator|(
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
name|PI_WIDE_32
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"HBA does not support 32 bit bus width"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bus_width
operator|!=
literal|8
operator|)
operator|&&
operator|(
name|bus_width
operator|!=
literal|16
operator|)
operator|&&
operator|(
name|bus_width
operator|!=
literal|32
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid bus width %d"
argument_list|,
name|bus_width
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|ccb
operator|->
name|cts
operator|.
name|valid
operator||=
name|CCB_TRANS_BUS_WIDTH_VALID
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|bus_width
operator|=
name|bus_width
operator|>>
literal|4
expr_stmt|;
block|}
else|else
name|ccb
operator|->
name|cts
operator|.
name|valid
operator|&=
operator|~
name|CCB_TRANS_BUS_WIDTH_VALID
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SET_TRAN_SETTINGS
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending XPT_SET_TRAN_SETTINGS CCB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"XPT_SET_TRANS_SETTINGS CCB failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
block|}
if|if
condition|(
name|send_tur
condition|)
block|{
name|retval
operator|=
name|testunitready
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
operator|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * If the TUR didn't succeed, just bail. 		 */
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Test Unit Ready failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
comment|/* 		 * If the user wants things quiet, there's no sense in 		 * getting the transfer settings, if we're not going 		 * to print them. 		 */
if|if
condition|(
name|quiet
operator|!=
literal|0
condition|)
goto|goto
name|ratecontrol_bailout
goto|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"New Parameters:\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|get_print_cts
argument_list|(
name|device
argument_list|,
name|user_settings
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ratecontrol_bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsiformat
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|ycount
init|=
literal|0
decl_stmt|,
name|quiet
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|response
init|=
literal|0
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|use_timeout
init|=
literal|10800
operator|*
literal|1000
decl_stmt|;
name|int
name|immediate
init|=
literal|1
decl_stmt|;
name|struct
name|format_defect_list_header
name|fh
decl_stmt|;
name|u_int8_t
modifier|*
name|data_ptr
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|dxfer_len
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|byte2
init|=
literal|0
decl_stmt|;
name|int
name|num_warnings
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"scsiformat: error allocating ccb"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'q'
case|:
name|quiet
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|immediate
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|ycount
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"You are about to REMOVE ALL DATA from the "
literal|"following device:\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|scsidoinquiry
argument_list|(
name|device
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"scsiformat: error sending inquiry"
argument_list|)
expr_stmt|;
goto|goto
name|scsiformat_bailout
goto|;
block|}
block|}
if|if
condition|(
name|ycount
operator|==
literal|0
condition|)
block|{
do|do
block|{
name|char
name|str
index|[
literal|1024
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Are you SURE you want to do "
literal|"this? (yes/no) "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|str
argument_list|,
literal|"yes"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|response
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|str
argument_list|,
literal|"no"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|response
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Please answer"
literal|" \"yes\" or \"no\"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|response
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|response
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsiformat_bailout
goto|;
block|}
block|}
if|if
condition|(
name|timeout
operator|!=
literal|0
condition|)
name|use_timeout
operator|=
name|timeout
expr_stmt|;
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Current format timeout is %d seconds\n"
argument_list|,
name|use_timeout
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the user hasn't disabled questions and didn't specify a 	 * timeout on the command line, ask them if they want the current 	 * timeout. 	 */
if|if
condition|(
operator|(
name|ycount
operator|==
literal|0
operator|)
operator|&&
operator|(
name|timeout
operator|==
literal|0
operator|)
condition|)
block|{
name|char
name|str
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|new_timeout
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Enter new timeout in seconds or press\n"
literal|"return to keep the current timeout [%d] "
argument_list|,
name|use_timeout
operator|/
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|new_timeout
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_timeout
operator|!=
literal|0
condition|)
block|{
name|use_timeout
operator|=
name|new_timeout
operator|*
literal|1000
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Using new timeout value %d\n"
argument_list|,
name|use_timeout
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Keep this outside the if block below to silence any unused 	 * variable warnings. 	 */
name|bzero
argument_list|(
operator|&
name|fh
argument_list|,
sizeof|sizeof
argument_list|(
name|fh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we're in immediate mode, we've got to include the format 	 * header 	 */
if|if
condition|(
name|immediate
operator|!=
literal|0
condition|)
block|{
name|fh
operator|.
name|byte2
operator|=
name|FU_DLH_IMMED
expr_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|fh
expr_stmt|;
name|dxfer_len
operator|=
sizeof|sizeof
argument_list|(
name|fh
argument_list|)
expr_stmt|;
name|byte2
operator|=
name|FU_FMT_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Formatting..."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|scsi_format_unit
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* byte2 */
name|byte2
argument_list|,
comment|/* ileave */
literal|0
argument_list|,
comment|/* data_ptr */
name|data_ptr
argument_list|,
comment|/* dxfer_len */
name|dxfer_len
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|use_timeout
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|immediate
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
operator|)
condition|)
block|{
specifier|const
name|char
name|errstr
index|[]
init|=
literal|"error sending format command"
decl_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|warn
argument_list|(
name|errstr
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsiformat_bailout
goto|;
block|}
comment|/* 	 * If we ran in non-immediate mode, we already checked for errors 	 * above and printed out any necessary information.  If we're in 	 * immediate mode, we need to loop through and get status 	 * information periodically. 	 */
if|if
condition|(
name|immediate
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Format Complete\n"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|scsiformat_bailout
goto|;
block|}
do|do
block|{
name|cam_status
name|status
decl_stmt|;
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * There's really no need to do error recovery or 		 * retries here, since we're just going to sit in a 		 * loop and wait for the device to finish formatting. 		 */
name|scsi_test_unit_ready
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|0
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* 		 * If we get an error from the ioctl, bail out.  SCSI 		 * errors are expected. 		 */
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending CAMIOCOMMAND ioctl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsiformat_bailout
goto|;
block|}
name|status
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|status
operator|==
name|CAM_SCSI_STATUS_ERROR
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|sense
operator|=
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|scsi_extract_sense
argument_list|(
name|sense
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|)
expr_stmt|;
comment|/* 			 * According to the SCSI-2 and SCSI-3 specs, a 			 * drive that is in the middle of a format should 			 * return NOT READY with an ASC of "logical unit 			 * not ready, format in progress".  The sense key 			 * specific bytes will then be a progress indicator. 			 */
if|if
condition|(
operator|(
name|sense_key
operator|==
name|SSD_KEY_NOT_READY
operator|)
operator|&&
operator|(
name|asc
operator|==
literal|0x04
operator|)
operator|&&
operator|(
name|ascq
operator|==
literal|0x04
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|sense
operator|->
name|extra_len
operator|>=
literal|10
operator|)
operator|&&
operator|(
operator|(
name|sense
operator|->
name|sense_key_spec
index|[
literal|0
index|]
operator|&
name|SSD_SCS_VALID
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|quiet
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|val
decl_stmt|;
name|u_int64_t
name|percentage
decl_stmt|;
name|val
operator|=
name|scsi_2btoul
argument_list|(
operator|&
name|sense
operator|->
name|sense_key_spec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|percentage
operator|=
literal|10000
operator|*
name|val
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\rFormatting:  %qd.%02qd %% "
literal|"(%d/%d) done"
argument_list|,
name|percentage
operator|/
operator|(
literal|0x10000
operator|*
literal|100
operator|)
argument_list|,
operator|(
name|percentage
operator|/
literal|0x10000
operator|)
operator|%
literal|100
argument_list|,
name|val
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|quiet
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|++
name|num_warnings
operator|<=
literal|1
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Unexpected SCSI Sense Key "
literal|"Specific value returned "
literal|"during format:"
argument_list|)
expr_stmt|;
name|scsi_sense_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"Unable to print status "
literal|"information, but format will "
literal|"proceed."
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"will exit when format is "
literal|"complete"
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"Unexpected SCSI error during format"
argument_list|)
expr_stmt|;
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsiformat_bailout
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"Unexpected CAM status %#x"
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsiformat_bailout
goto|;
block|}
block|}
do|while
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
do|;
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nFormat Complete\n"
argument_list|)
expr_stmt|;
name|scsiformat_bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MINIMALISTIC */
end_comment

begin_function
name|void
name|usage
parameter_list|(
name|int
name|verbose
parameter_list|)
block|{
name|fprintf
argument_list|(
name|verbose
condition|?
name|stdout
else|:
name|stderr
argument_list|,
literal|"usage:  camcontrol<command>  [device id][generic args][command args]\n"
literal|"        camcontrol devlist    [-v]\n"
ifndef|#
directive|ifndef
name|MINIMALISTIC
literal|"        camcontrol periphlist [dev_id][-n dev_name] [-u unit]\n"
literal|"        camcontrol tur        [dev_id][generic args]\n"
literal|"        camcontrol inquiry    [dev_id][generic args] [-D] [-S] [-R]\n"
literal|"        camcontrol start      [dev_id][generic args]\n"
literal|"        camcontrol stop       [dev_id][generic args]\n"
literal|"        camcontrol eject      [dev_id][generic args]\n"
endif|#
directive|endif
comment|/* MINIMALISTIC */
literal|"        camcontrol rescan<all | bus[:target:lun]>\n"
literal|"        camcontrol reset<all | bus[:target:lun]>\n"
ifndef|#
directive|ifndef
name|MINIMALISTIC
literal|"        camcontrol defects    [dev_id][generic args]<-f format> [-P][-G]\n"
literal|"        camcontrol modepage   [dev_id][generic args]<-m page | -l>\n"
literal|"                              [-P pagectl][-e | -b][-d]\n"
literal|"        camcontrol cmd        [dev_id][generic args]<-c cmd [args]>\n"
literal|"                              [-i len fmt|-o len fmt [args]]\n"
literal|"        camcontrol debug      [-I][-T][-S][-c]<all|bus[:target[:lun]]|off>\n"
literal|"        camcontrol tags       [dev_id][generic args] [-N tags] [-q] [-v]\n"
literal|"        camcontrol negotiate  [dev_id][generic args] [-a][-c]\n"
literal|"                              [-D<enable|disable>][-O offset][-q]\n"
literal|"                              [-R syncrate][-v][-T<enable|disable>]\n"
literal|"                              [-U][-W bus_width]\n"
literal|"        camcontrol format     [dev_id][generic args][-q][-w][-y]\n"
endif|#
directive|endif
comment|/* MINIMALISTIC */
literal|"        camcontrol help\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verbose
condition|)
return|return;
ifndef|#
directive|ifndef
name|MINIMALISTIC
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Specify one of the following options:\n"
literal|"devlist     list all CAM devices\n"
literal|"periphlist  list all CAM peripheral drivers attached to a device\n"
literal|"tur         send a test unit ready to the named device\n"
literal|"inquiry     send a SCSI inquiry command to the named device\n"
literal|"start       send a Start Unit command to the device\n"
literal|"stop        send a Stop Unit command to the device\n"
literal|"eject       send a Stop Unit command to the device with the eject bit set\n"
literal|"rescan      rescan all busses, the given bus, or bus:target:lun\n"
literal|"reset       reset all busses, the given bus, or bus:target:lun\n"
literal|"defects     read the defect list of the specified device\n"
literal|"modepage    display or edit (-e) the given mode page\n"
literal|"cmd         send the given scsi command, may need -i or -o as well\n"
literal|"debug       turn debugging on/off for a bus, target, or lun, or all devices\n"
literal|"tags        report or set the number of transaction slots for a device\n"
literal|"negotiate   report or set device negotiation parameters\n"
literal|"format      send the SCSI FORMAT UNIT command to the named device\n"
literal|"help        this message\n"
literal|"Device Identifiers:\n"
literal|"bus:target        specify the bus and target, lun defaults to 0\n"
literal|"bus:target:lun    specify the bus, target and lun\n"
literal|"deviceUNIT        specify the device name, like \"da4\" or \"cd2\"\n"
literal|"Generic arguments:\n"
literal|"-v                be verbose, print out sense information\n"
literal|"-t timeout        command timeout in seconds, overrides default timeout\n"
literal|"-n dev_name       specify device name, e.g. \"da\", \"cd\"\n"
literal|"-u unit           specify unit number, e.g. \"0\", \"5\"\n"
literal|"-E                have the kernel attempt to perform SCSI error recovery\n"
literal|"-C count          specify the SCSI command retry count (needs -E to work)\n"
literal|"modepage arguments:\n"
literal|"-l                list all available mode pages\n"
literal|"-m page           specify the mode page to view or edit\n"
literal|"-e                edit the specified mode page\n"
literal|"-b                force view to binary mode\n"
literal|"-d                disable block descriptors for mode sense\n"
literal|"-P pgctl          page control field 0-3\n"
literal|"defects arguments:\n"
literal|"-f format         specify defect list format (block, bfi or phys)\n"
literal|"-G                get the grown defect list\n"
literal|"-P                get the permanant defect list\n"
literal|"inquiry arguments:\n"
literal|"-D                get the standard inquiry data\n"
literal|"-S                get the serial number\n"
literal|"-R                get the transfer rate, etc.\n"
literal|"cmd arguments:\n"
literal|"-c cdb [args]     specify the SCSI CDB\n"
literal|"-i len fmt        specify input data and input data format\n"
literal|"-o len fmt [args] specify output data and output data fmt\n"
literal|"debug arguments:\n"
literal|"-I                CAM_DEBUG_INFO -- scsi commands, errors, data\n"
literal|"-T                CAM_DEBUG_TRACE -- routine flow tracking\n"
literal|"-S                CAM_DEBUG_SUBTRACE -- internal routine command flow\n"
literal|"-c                CAM_DEBUG_CDB -- print out SCSI CDBs only\n"
literal|"tags arguments:\n"
literal|"-N tags           specify the number of tags to use for this device\n"
literal|"-q                be quiet, don't report the number of tags\n"
literal|"-v                report a number of tag-related parameters\n"
literal|"negotiate arguments:\n"
literal|"-a                send a test unit ready after negotiation\n"
literal|"-c                report/set current negotiation settings\n"
literal|"-D<arg>          \"enable\" or \"disable\" disconnection\n"
literal|"-O offset         set command delay offset\n"
literal|"-q                be quiet, don't report anything\n"
literal|"-R syncrate       synchronization rate in MHz\n"
literal|"-T<arg>          \"enable\" or \"disable\" tagged queueing\n"
literal|"-U                report/set user negotiation settings\n"
literal|"-W bus_width      set the bus width in bits (8, 16 or 32)\n"
literal|"-v                also print a Path Inquiry CCB for the controller\n"
literal|"format arguments:\n"
literal|"-q                be quiet, don't print status messages\n"
literal|"-w                don't send immediate format command\n"
literal|"-y                don't ask any questions\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MINIMALISTIC */
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|device
init|=
name|NULL
decl_stmt|;
name|int
name|unit
init|=
literal|0
decl_stmt|;
name|struct
name|cam_device
modifier|*
name|cam_dev
init|=
name|NULL
decl_stmt|;
name|int
name|timeout
init|=
literal|0
decl_stmt|,
name|retry_count
init|=
literal|1
decl_stmt|;
name|camcontrol_optret
name|optreturn
decl_stmt|;
name|char
modifier|*
name|tstr
decl_stmt|;
name|char
modifier|*
name|mainopt
init|=
literal|"C:En:t:u:v"
decl_stmt|;
name|char
modifier|*
name|subopt
init|=
name|NULL
decl_stmt|;
name|char
name|combinedopt
index|[
literal|256
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|optstart
init|=
literal|2
decl_stmt|;
name|int
name|devopen
init|=
literal|1
decl_stmt|;
name|arglist
operator|=
name|CAM_ARG_NONE
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get the base option. 	 */
name|optreturn
operator|=
name|getoption
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|arglist
argument_list|,
operator|&
name|subopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|optreturn
operator|==
name|CC_OR_AMBIGUOUS
condition|)
block|{
name|warnx
argument_list|(
literal|"ambiguous option %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optreturn
operator|==
name|CC_OR_NOT_FOUND
condition|)
block|{
name|warnx
argument_list|(
literal|"option %s not found"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Ahh, getopt(3) is a pain. 	 * 	 * This is a gross hack.  There really aren't many other good 	 * options (excuse the pun) for parsing options in a situation like 	 * this.  getopt is kinda braindead, so you end up having to run 	 * through the options twice, and give each invocation of getopt 	 * the option string for the other invocation. 	 *  	 * You would think that you could just have two groups of options. 	 * The first group would get parsed by the first invocation of 	 * getopt, and the second group would get parsed by the second 	 * invocation of getopt.  It doesn't quite work out that way.  When 	 * the first invocation of getopt finishes, it leaves optind pointing 	 * to the argument _after_ the first argument in the second group. 	 * So when the second invocation of getopt comes around, it doesn't 	 * recognize the first argument it gets and then bails out. 	 *  	 * A nice alternative would be to have a flag for getopt that says 	 * "just keep parsing arguments even when you encounter an unknown 	 * argument", but there isn't one.  So there's no real clean way to 	 * easily parse two sets of arguments without having one invocation 	 * of getopt know about the other. 	 *  	 * Without this hack, the first invocation of getopt would work as 	 * long as the generic arguments are first, but the second invocation 	 * (in the subfunction) would fail in one of two ways.  In the case 	 * where you don't set optreset, it would fail because optind may be 	 * pointing to the argument after the one it should be pointing at. 	 * In the case where you do set optreset, and reset optind, it would 	 * fail because getopt would run into the first set of options, which 	 * it doesn't understand. 	 * 	 * All of this would "sort of" work if you could somehow figure out 	 * whether optind had been incremented one option too far.  The 	 * mechanics of that, however, are more daunting than just giving 	 * both invocations all of the expect options for either invocation. 	 *  	 * Needless to say, I wouldn't mind if someone invented a better 	 * (non-GPL!) command line parsing interface than getopt.  I 	 * wouldn't mind if someone added more knobs to getopt to make it 	 * work better.  Who knows, I may talk myself into doing it someday, 	 * if the standards weenies let me.  As it is, it just leads to 	 * hackery like this and causes people to avoid it in some cases. 	 *  	 * KDM, September 8th, 1998 	 */
if|if
condition|(
name|subopt
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|combinedopt
argument_list|,
literal|"%s%s"
argument_list|,
name|mainopt
argument_list|,
name|subopt
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|combinedopt
argument_list|,
literal|"%s"
argument_list|,
name|mainopt
argument_list|)
expr_stmt|;
comment|/* 	 * For these options we do not parse optional device arguments and 	 * we do not open a passthrough device. 	 */
if|if
condition|(
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_OPT_MASK
operator|)
operator|==
name|CAM_ARG_RESCAN
operator|)
operator|||
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_OPT_MASK
operator|)
operator|==
name|CAM_ARG_RESET
operator|)
operator|||
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_OPT_MASK
operator|)
operator|==
name|CAM_ARG_DEVTREE
operator|)
operator|||
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_OPT_MASK
operator|)
operator|==
name|CAM_ARG_USAGE
operator|)
operator|||
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_OPT_MASK
operator|)
operator|==
name|CAM_ARG_DEBUG
operator|)
condition|)
name|devopen
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|MINIMALISTIC
if|if
condition|(
operator|(
name|devopen
operator|==
literal|1
operator|)
operator|&&
operator|(
name|argc
operator|>
literal|2
operator|&&
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|)
condition|)
block|{
name|char
name|name
index|[
literal|30
index|]
decl_stmt|;
name|int
name|rv
decl_stmt|;
comment|/* 		 * First catch people who try to do things like: 		 * camcontrol tur /dev/rsd0.ctl 		 * camcontrol doesn't take device nodes as arguments. 		 */
if|if
condition|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|warnx
argument_list|(
literal|"%s is not a valid device identifier"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"please read the camcontrol(8) man page"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* device specified as bus:target[:lun] */
name|rv
operator|=
name|parse_btl
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|bus
argument_list|,
operator|&
name|target
argument_list|,
operator|&
name|lun
argument_list|,
operator|&
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<
literal|2
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"numeric device specification must "
literal|"be either bus:target, or "
literal|"bus:target:lun"
argument_list|)
expr_stmt|;
name|optstart
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cam_get_device
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
operator|&
name|unit
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|cam_errbuf
argument_list|)
expr_stmt|;
name|device
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_DEVICE
operator||
name|CAM_ARG_UNIT
expr_stmt|;
name|optstart
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MINIMALISTIC */
comment|/* 	 * Start getopt processing at argv[2/3], since we've already 	 * accepted argv[1..2] as the command name, and as a possible 	 * device name. 	 */
name|optind
operator|=
name|optstart
expr_stmt|;
comment|/* 	 * Now we run through the argument list looking for generic 	 * options, and ignoring options that possibly belong to 	 * subfunctions. 	 */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'C'
case|:
name|retry_count
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry_count
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"retry count %d is< 0"
argument_list|,
name|retry_count
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_RETRIES
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|arglist
operator||=
name|CAM_ARG_ERR_RECOVER
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|arglist
operator||=
name|CAM_ARG_DEVICE
expr_stmt|;
name|tstr
operator|=
name|optarg
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
name|device
operator|=
operator|(
name|char
operator|*
operator|)
name|strdup
argument_list|(
name|tstr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|timeout
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid timeout %d"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|/* Convert the timeout from seconds to ms */
name|timeout
operator|*=
literal|1000
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_TIMEOUT
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|arglist
operator||=
name|CAM_ARG_UNIT
expr_stmt|;
name|unit
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|arglist
operator||=
name|CAM_ARG_VERBOSE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
ifndef|#
directive|ifndef
name|MINIMALISTIC
comment|/* 	 * For most commands we'll want to open the passthrough device 	 * associated with the specified device.  In the case of the rescan 	 * commands, we don't use a passthrough device at all, just the 	 * transport layer device. 	 */
if|if
condition|(
name|devopen
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|arglist
operator|&
operator|(
name|CAM_ARG_BUS
operator||
name|CAM_ARG_TARGET
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_DEVICE
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_UNIT
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"subcommand \"%s\" requires a valid device "
literal|"identifier"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cam_dev
operator|=
operator|(
operator|(
name|arglist
operator|&
operator|(
name|CAM_ARG_BUS
operator||
name|CAM_ARG_TARGET
operator|)
operator|)
condition|?
name|cam_open_btl
argument_list|(
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|O_RDWR
argument_list|,
name|NULL
argument_list|)
else|:
name|cam_open_spec_device
argument_list|(
name|device
argument_list|,
name|unit
argument_list|,
name|O_RDWR
argument_list|,
name|NULL
argument_list|)
operator|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|cam_errbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MINIMALISTIC */
comment|/* 	 * Reset optind to 2, and reset getopt, so these routines can parse 	 * the arguments again. 	 */
name|optind
operator|=
name|optstart
expr_stmt|;
name|optreset
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|arglist
operator|&
name|CAM_ARG_OPT_MASK
condition|)
block|{
ifndef|#
directive|ifndef
name|MINIMALISTIC
case|case
name|CAM_ARG_DEVLIST
case|:
name|error
operator|=
name|getdevlist
argument_list|(
name|cam_dev
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MINIMALISTIC */
case|case
name|CAM_ARG_DEVTREE
case|:
name|error
operator|=
name|getdevtree
argument_list|()
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|MINIMALISTIC
case|case
name|CAM_ARG_TUR
case|:
name|error
operator|=
name|testunitready
argument_list|(
name|cam_dev
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_INQUIRY
case|:
name|error
operator|=
name|scsidoinquiry
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_STARTSTOP
case|:
name|error
operator|=
name|scsistart
argument_list|(
name|cam_dev
argument_list|,
name|arglist
operator|&
name|CAM_ARG_START_UNIT
argument_list|,
name|arglist
operator|&
name|CAM_ARG_EJECT
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MINIMALISTIC */
case|case
name|CAM_ARG_RESCAN
case|:
name|error
operator|=
name|dorescan_or_reset
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_RESET
case|:
name|error
operator|=
name|dorescan_or_reset
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|MINIMALISTIC
case|case
name|CAM_ARG_READ_DEFECTS
case|:
name|error
operator|=
name|readdefects
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_MODE_PAGE
case|:
name|modepage
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_SCSI_CMD
case|:
name|error
operator|=
name|scsicmd
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_DEBUG
case|:
name|error
operator|=
name|camdebug
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_TAG
case|:
name|error
operator|=
name|tagcontrol
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_RATE
case|:
name|error
operator|=
name|ratecontrol
argument_list|(
name|cam_dev
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_FORMAT
case|:
name|error
operator|=
name|scsiformat
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MINIMALISTIC */
case|case
name|CAM_ARG_USAGE
case|:
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cam_dev
operator|!=
name|NULL
condition|)
name|cam_close_device
argument_list|(
name|cam_dev
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

