begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 1998 Kenneth D. Merry  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: camcontrol.c,v 1.4 1998/10/13 16:23:26 ken Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_pass.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<camlib.h>
end_include

begin_include
include|#
directive|include
file|"camcontrol.h"
end_include

begin_define
define|#
directive|define
name|DEFAULT_DEVICE
value|"da"
end_define

begin_define
define|#
directive|define
name|DEFAULT_UNIT
value|0
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|CAM_ARG_NONE
init|=
literal|0x00000000
block|,
name|CAM_ARG_DEVLIST
init|=
literal|0x00000001
block|,
name|CAM_ARG_TUR
init|=
literal|0x00000002
block|,
name|CAM_ARG_INQUIRY
init|=
literal|0x00000003
block|,
name|CAM_ARG_STARTSTOP
init|=
literal|0x00000004
block|,
name|CAM_ARG_RESCAN
init|=
literal|0x00000005
block|,
name|CAM_ARG_READ_DEFECTS
init|=
literal|0x00000006
block|,
name|CAM_ARG_MODE_PAGE
init|=
literal|0x00000007
block|,
name|CAM_ARG_SCSI_CMD
init|=
literal|0x00000008
block|,
name|CAM_ARG_DEVTREE
init|=
literal|0x00000009
block|,
name|CAM_ARG_USAGE
init|=
literal|0x0000000a
block|,
name|CAM_ARG_DEBUG
init|=
literal|0x0000000b
block|,
name|CAM_ARG_OPT_MASK
init|=
literal|0x0000000f
block|,
name|CAM_ARG_VERBOSE
init|=
literal|0x00000010
block|,
name|CAM_ARG_DEVICE
init|=
literal|0x00000020
block|,
name|CAM_ARG_BUS
init|=
literal|0x00000040
block|,
name|CAM_ARG_TARGET
init|=
literal|0x00000080
block|,
name|CAM_ARG_LUN
init|=
literal|0x00000100
block|,
name|CAM_ARG_EJECT
init|=
literal|0x00000200
block|,
name|CAM_ARG_UNIT
init|=
literal|0x00000400
block|,
name|CAM_ARG_FORMAT_BLOCK
init|=
literal|0x00000800
block|,
name|CAM_ARG_FORMAT_BFI
init|=
literal|0x00001000
block|,
name|CAM_ARG_FORMAT_PHYS
init|=
literal|0x00002000
block|,
name|CAM_ARG_PLIST
init|=
literal|0x00004000
block|,
name|CAM_ARG_GLIST
init|=
literal|0x00008000
block|,
name|CAM_ARG_GET_SERIAL
init|=
literal|0x00010000
block|,
name|CAM_ARG_GET_STDINQ
init|=
literal|0x00020000
block|,
name|CAM_ARG_GET_XFERRATE
init|=
literal|0x00040000
block|,
name|CAM_ARG_INQ_MASK
init|=
literal|0x00070000
block|,
name|CAM_ARG_MODE_EDIT
init|=
literal|0x00080000
block|,
name|CAM_ARG_PAGE_CNTL
init|=
literal|0x00100000
block|,
name|CAM_ARG_TIMEOUT
init|=
literal|0x00200000
block|,
name|CAM_ARG_CMD_IN
init|=
literal|0x00400000
block|,
name|CAM_ARG_CMD_OUT
init|=
literal|0x00800000
block|,
name|CAM_ARG_DBD
init|=
literal|0x01000000
block|,
name|CAM_ARG_ERR_RECOVER
init|=
literal|0x02000000
block|,
name|CAM_ARG_RETRIES
init|=
literal|0x04000000
block|,
name|CAM_ARG_START_UNIT
init|=
literal|0x08000000
block|,
name|CAM_ARG_DEBUG_INFO
init|=
literal|0x10000000
block|,
name|CAM_ARG_DEBUG_TRACE
init|=
literal|0x20000000
block|,
name|CAM_ARG_DEBUG_SUBTRACE
init|=
literal|0x40000000
block|,
name|CAM_ARG_DEBUG_CDB
init|=
literal|0x80000000
block|,
name|CAM_ARG_FLAG_MASK
init|=
literal|0xfffffff0
block|}
name|cam_argmask
typedef|;
end_typedef

begin_struct
struct|struct
name|camcontrol_opts
block|{
name|char
modifier|*
name|optname
decl_stmt|;
name|cam_argmask
name|argnum
decl_stmt|;
specifier|const
name|char
modifier|*
name|subopt
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|int
name|optreset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|scsicmd_opts
index|[]
init|=
literal|"c:i:o:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|readdefect_opts
index|[]
init|=
literal|"f:GP"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|camcontrol_opts
name|option_table
index|[]
init|=
block|{
block|{
literal|"tur"
block|,
name|CAM_ARG_TUR
block|,
name|NULL
block|}
block|,
block|{
literal|"inquiry"
block|,
name|CAM_ARG_INQUIRY
block|,
literal|"DSR"
block|}
block|,
block|{
literal|"start"
block|,
name|CAM_ARG_STARTSTOP
operator||
name|CAM_ARG_START_UNIT
block|,
name|NULL
block|}
block|,
block|{
literal|"stop"
block|,
name|CAM_ARG_STARTSTOP
block|,
name|NULL
block|}
block|,
block|{
literal|"eject"
block|,
name|CAM_ARG_STARTSTOP
operator||
name|CAM_ARG_EJECT
block|,
name|NULL
block|}
block|,
block|{
literal|"rescan"
block|,
name|CAM_ARG_RESCAN
block|,
name|NULL
block|}
block|,
block|{
literal|"cmd"
block|,
name|CAM_ARG_SCSI_CMD
block|,
name|scsicmd_opts
block|}
block|,
block|{
literal|"command"
block|,
name|CAM_ARG_SCSI_CMD
block|,
name|scsicmd_opts
block|}
block|,
block|{
literal|"defects"
block|,
name|CAM_ARG_READ_DEFECTS
block|,
name|readdefect_opts
block|}
block|,
block|{
literal|"defectlist"
block|,
name|CAM_ARG_READ_DEFECTS
block|,
name|readdefect_opts
block|}
block|,
block|{
literal|"devlist"
block|,
name|CAM_ARG_DEVTREE
block|,
name|NULL
block|}
block|,
block|{
literal|"periphlist"
block|,
name|CAM_ARG_DEVLIST
block|,
name|NULL
block|}
block|,
block|{
literal|"modepage"
block|,
name|CAM_ARG_MODE_PAGE
block|,
literal|"dem:P:"
block|}
block|,
block|{
literal|"debug"
block|,
name|CAM_ARG_DEBUG
block|,
literal|"ITSc"
block|}
block|,
block|{
literal|"help"
block|,
name|CAM_ARG_USAGE
block|,
name|NULL
block|}
block|,
block|{
literal|"-?"
block|,
name|CAM_ARG_USAGE
block|,
name|NULL
block|}
block|,
block|{
literal|"-h"
block|,
name|CAM_ARG_USAGE
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|CC_OR_NOT_FOUND
block|,
name|CC_OR_AMBIGUOUS
block|,
name|CC_OR_FOUND
block|}
name|camcontrol_optret
typedef|;
end_typedef

begin_decl_stmt
name|cam_argmask
name|arglist
decl_stmt|;
end_decl_stmt

begin_function_decl
name|camcontrol_optret
name|getoption
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|cam_argmask
modifier|*
name|argnum
parameter_list|,
name|char
modifier|*
modifier|*
name|subopt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getdevlist
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getdevtree
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|testunitready
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsistart
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|startstop
parameter_list|,
name|int
name|loadeject
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsidoinquiry
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsiinquiry
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsiserial
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsixferrate
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dorescan
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rescanbus
parameter_list|(
name|int
name|bus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scanlun
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|readdefects
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|modepage
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsicmd
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|camcontrol_optret
name|getoption
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|cam_argmask
modifier|*
name|argnum
parameter_list|,
name|char
modifier|*
modifier|*
name|subopt
parameter_list|)
block|{
name|struct
name|camcontrol_opts
modifier|*
name|opts
decl_stmt|;
name|int
name|num_matches
init|=
literal|0
decl_stmt|;
for|for
control|(
name|opts
operator|=
name|option_table
init|;
operator|(
name|opts
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|opts
operator|->
name|optname
operator|!=
name|NULL
operator|)
condition|;
name|opts
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|opts
operator|->
name|optname
argument_list|,
name|arg
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|argnum
operator|=
name|opts
operator|->
name|argnum
expr_stmt|;
operator|*
name|subopt
operator|=
operator|(
name|char
operator|*
operator|)
name|opts
operator|->
name|subopt
expr_stmt|;
if|if
condition|(
operator|++
name|num_matches
operator|>
literal|1
condition|)
return|return
operator|(
name|CC_OR_AMBIGUOUS
operator|)
return|;
block|}
block|}
if|if
condition|(
name|num_matches
operator|>
literal|0
condition|)
return|return
operator|(
name|CC_OR_FOUND
operator|)
return|;
else|else
return|return
operator|(
name|CC_OR_NOT_FOUND
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getdevlist
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|char
name|status
index|[
literal|32
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEVLIST
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DIR_NONE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|=
name|CAM_GDEVLIST_MORE_DEVS
expr_stmt|;
while|while
condition|(
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|==
name|CAM_GDEVLIST_MORE_DEVS
condition|)
block|{
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error getting device list"
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|status
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|cgdl
operator|.
name|status
condition|)
block|{
case|case
name|CAM_GDEVLIST_MORE_DEVS
case|:
name|strcpy
argument_list|(
name|status
argument_list|,
literal|"MORE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_GDEVLIST_LAST_DEVICE
case|:
name|strcpy
argument_list|(
name|status
argument_list|,
literal|"LAST"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_GDEVLIST_LIST_CHANGED
case|:
name|strcpy
argument_list|(
name|status
argument_list|,
literal|"CHANGED"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_GDEVLIST_ERROR
case|:
name|strcpy
argument_list|(
name|status
argument_list|,
literal|"ERROR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%d:  generation: %d index: %d status: %s\n"
argument_list|,
name|ccb
operator|->
name|cgdl
operator|.
name|periph_name
argument_list|,
name|ccb
operator|->
name|cgdl
operator|.
name|unit_number
argument_list|,
name|ccb
operator|->
name|cgdl
operator|.
name|generation
argument_list|,
name|ccb
operator|->
name|cgdl
operator|.
name|index
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* 		 * If the list has changed, we need to start over from the 		 * beginning. 		 */
if|if
condition|(
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|==
name|CAM_GDEVLIST_LIST_CHANGED
condition|)
name|ccb
operator|->
name|cgdl
operator|.
name|index
operator|=
literal|0
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getdevtree
parameter_list|(
name|void
parameter_list|)
block|{
name|union
name|ccb
name|ccb
decl_stmt|;
name|int
name|bufsize
decl_stmt|,
name|i
decl_stmt|,
name|fd
decl_stmt|;
name|int
name|need_close
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XPT_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"couldn't open %s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|.
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_dev_match
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEV_MATCH
expr_stmt|;
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
operator|*
literal|100
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|match_buf_len
operator|=
name|bufsize
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|matches
operator|=
operator|(
expr|struct
name|dev_match_result
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|num_matches
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We fetch all nodes, since we display most of them in the default 	 * case, and all in the verbose case. 	 */
name|ccb
operator|.
name|cdm
operator|.
name|num_patterns
operator|=
literal|0
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|pattern_buf_len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We do the ioctl multiple times if necessary, in case there are 	 * more than 100 nodes in the EDT. 	 */
do|do
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"error sending CAMIOCOMMAND ioctl"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|.
name|cdm
operator|.
name|status
operator|!=
name|CAM_DEV_MATCH_LAST
operator|)
operator|&&
operator|(
name|ccb
operator|.
name|cdm
operator|.
name|status
operator|!=
name|CAM_DEV_MATCH_MORE
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"got CAM error %#x, CDM error %d\n"
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
argument_list|,
name|ccb
operator|.
name|cdm
operator|.
name|status
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccb
operator|.
name|cdm
operator|.
name|num_matches
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|DEV_MATCH_BUS
case|:
block|{
name|struct
name|bus_match_result
modifier|*
name|bus_result
decl_stmt|;
comment|/* 				 * Only print the bus information if the 				 * user turns on the verbose flag. 				 */
if|if
condition|(
operator|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
operator|)
operator|==
literal|0
condition|)
break|break;
name|bus_result
operator|=
operator|&
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|result
operator|.
name|bus_result
expr_stmt|;
if|if
condition|(
name|need_close
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|need_close
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"scbus%d on %s%d bus %d:\n"
argument_list|,
name|bus_result
operator|->
name|path_id
argument_list|,
name|bus_result
operator|->
name|dev_name
argument_list|,
name|bus_result
operator|->
name|unit_number
argument_list|,
name|bus_result
operator|->
name|bus_id
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DEV_MATCH_DEVICE
case|:
block|{
name|struct
name|device_match_result
modifier|*
name|dev_result
decl_stmt|;
name|char
name|vendor
index|[
literal|16
index|]
decl_stmt|,
name|product
index|[
literal|48
index|]
decl_stmt|,
name|revision
index|[
literal|16
index|]
decl_stmt|;
name|char
name|tmpstr
index|[
literal|256
index|]
decl_stmt|;
name|dev_result
operator|=
operator|&
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|result
operator|.
name|device_result
expr_stmt|;
name|cam_strvis
argument_list|(
name|vendor
argument_list|,
name|dev_result
operator|->
name|inq_data
operator|.
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_result
operator|->
name|inq_data
operator|.
name|vendor
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|product
argument_list|,
name|dev_result
operator|->
name|inq_data
operator|.
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_result
operator|->
name|inq_data
operator|.
name|product
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|revision
argument_list|,
name|dev_result
operator|->
name|inq_data
operator|.
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_result
operator|->
name|inq_data
operator|.
name|revision
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpstr
argument_list|,
literal|"<%s %s %s>"
argument_list|,
name|vendor
argument_list|,
name|product
argument_list|,
name|revision
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_close
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|need_close
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%-33s  at scbus%d "
literal|"target %d lun %d ("
argument_list|,
name|tmpstr
argument_list|,
name|dev_result
operator|->
name|path_id
argument_list|,
name|dev_result
operator|->
name|target_id
argument_list|,
name|dev_result
operator|->
name|target_lun
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DEV_MATCH_PERIPH
case|:
block|{
name|struct
name|periph_match_result
modifier|*
name|periph_result
decl_stmt|;
name|periph_result
operator|=
operator|&
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|result
operator|.
name|periph_result
expr_stmt|;
if|if
condition|(
name|need_close
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%d"
argument_list|,
name|periph_result
operator|->
name|periph_name
argument_list|,
name|periph_result
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|need_close
operator|=
literal|1
expr_stmt|;
break|break;
block|}
default|default:
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"unknown match type\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|ccb
operator|.
name|cdm
operator|.
name|status
operator|==
name|CAM_DEV_MATCH_MORE
operator|)
condition|)
do|;
if|if
condition|(
name|need_close
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|testunitready
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|scsi_test_unit_ready
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending test unit ready"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
name|scsi_sense_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CAM status is %#x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Unit is ready\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Unit is not ready\n"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
name|scsi_sense_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CAM status is %#x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsistart
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|startstop
parameter_list|,
name|int
name|loadeject
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
comment|/* 	 * If we're stopping, send an ordered tag so the drive in question 	 * will finish any previously queued writes before stopping.  If 	 * the device isn't capable of tagged queueing, or if tagged 	 * queueing is turned off, the tag action is a no-op. 	 */
name|scsi_start_stop
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|startstop
condition|?
name|MSG_SIMPLE_Q_TAG
else|:
name|MSG_ORDERED_Q_TAG
argument_list|,
comment|/* start/stop */
name|startstop
argument_list|,
comment|/* load_eject */
name|loadeject
argument_list|,
comment|/* immediate */
literal|0
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|120000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending start unit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
name|scsi_sense_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CAM status is %#x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
if|if
condition|(
name|startstop
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Unit started successfully"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadeject
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|", Media loaded\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Unit stopped successfully"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadeject
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|", Media ejected\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|startstop
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Error received from start unit command\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Error received from stop unit command\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
name|scsi_sense_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CAM status is %#x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsidoinquiry
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'D'
case|:
name|arglist
operator||=
name|CAM_ARG_GET_STDINQ
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|arglist
operator||=
name|CAM_ARG_GET_XFERRATE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|arglist
operator||=
name|CAM_ARG_GET_SERIAL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * If the user didn't specify any inquiry options, he wants all of 	 * them. 	 */
if|if
condition|(
operator|(
name|arglist
operator|&
name|CAM_ARG_INQ_MASK
operator|)
operator|==
literal|0
condition|)
name|arglist
operator||=
name|CAM_ARG_INQ_MASK
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_GET_STDINQ
condition|)
name|error
operator|=
name|scsiinquiry
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_GET_SERIAL
condition|)
name|scsiserial
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_GET_XFERRATE
condition|)
name|error
operator|=
name|scsixferrate
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsiinquiry
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_buf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't allocate CCB"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* cam_getccb cleans up the header, caller has to zero the payload */
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
argument_list|)
expr_stmt|;
name|inq_buf
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inq_buf
operator|==
name|NULL
condition|)
block|{
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"can't malloc memory for inquiry\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
name|inq_buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inq_buf
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_inquiry
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* inq_buf */
operator|(
name|u_int8_t
operator|*
operator|)
name|inq_buf
argument_list|,
comment|/* inq_len */
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|,
comment|/* evpd */
literal|0
argument_list|,
comment|/* page_code */
literal|0
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending SCSI inquiry"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
name|scsi_sense_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CAM status is %#x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
name|scsi_sense_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CAM status is %#x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|inq_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|scsi_print_inquiry
argument_list|(
name|inq_buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inq_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_GET_SERIAL
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Serial Number "
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsiserial
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|scsi_vpd_unit_serial_number
modifier|*
name|serial_buf
decl_stmt|;
name|char
name|serial_num
index|[
name|SVPD_SERIAL_NUM_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't allocate CCB"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* cam_getccb cleans up the header, caller has to zero the payload */
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
argument_list|)
expr_stmt|;
name|serial_buf
operator|=
operator|(
expr|struct
name|scsi_vpd_unit_serial_number
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|serial_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_buf
operator|==
name|NULL
condition|)
block|{
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"can't malloc memory for serial number"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|scsi_inquiry
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* inq_buf */
operator|(
name|u_int8_t
operator|*
operator|)
name|serial_buf
argument_list|,
comment|/* inq_len */
sizeof|sizeof
argument_list|(
operator|*
name|serial_buf
argument_list|)
argument_list|,
comment|/* evpd */
literal|1
argument_list|,
comment|/* page_code */
name|SVPD_UNIT_SERIAL_NUMBER
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error getting serial number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
name|scsi_sense_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CAM status is %#x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|serial_buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
name|scsi_sense_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CAM status is %#x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|serial_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|serial_buf
operator|->
name|serial_num
argument_list|,
name|serial_num
argument_list|,
name|serial_buf
operator|->
name|length
argument_list|)
expr_stmt|;
name|serial_num
index|[
name|serial_buf
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_GET_STDINQ
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|arglist
operator|&
name|CAM_ARG_GET_XFERRATE
operator|)
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Serial Number "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%.60s\n"
argument_list|,
name|serial_num
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|serial_buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsixferrate
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
block|{
name|u_int32_t
name|freq
decl_stmt|;
name|u_int32_t
name|speed
decl_stmt|;
if|if
condition|(
name|device
operator|->
name|sync_period
operator|!=
literal|0
condition|)
name|freq
operator|=
name|scsi_calc_syncsrate
argument_list|(
name|device
operator|->
name|sync_period
argument_list|)
expr_stmt|;
else|else
name|freq
operator|=
literal|0
expr_stmt|;
name|speed
operator|=
name|freq
expr_stmt|;
name|speed
operator|*=
operator|(
literal|0x01
operator|<<
name|device
operator|->
name|bus_width
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d.%dMB/s transfers "
argument_list|,
name|speed
operator|/
literal|1000
argument_list|,
name|speed
operator|%
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|->
name|sync_period
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"(%d.%dMHz, offset %d"
argument_list|,
name|freq
operator|/
literal|1000
argument_list|,
name|freq
operator|%
literal|1000
argument_list|,
name|device
operator|->
name|sync_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|->
name|bus_width
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|device
operator|->
name|sync_period
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%dbit)"
argument_list|,
literal|8
operator|*
operator|(
literal|0x01
operator|<<
name|device
operator|->
name|bus_width
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|device
operator|->
name|sync_period
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|->
name|inq_data
operator|.
name|flags
operator|&
name|SID_CmdQue
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|", Tagged Queueing Enabled"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dorescan
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|bus
init|=
operator|-
literal|1
decl_stmt|,
name|target
init|=
operator|-
literal|1
decl_stmt|,
name|lun
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|tstr
decl_stmt|,
modifier|*
name|tmpstr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|warnx
argument_list|(
literal|"you must specify a bus, or a bus:target:lun to rescan"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Parse out a bus, or a bus, target and lun in the following 	 * format: 	 * bus 	 * bus:target:lun 	 * It is an error to specify a bus and target, but not a lun. 	 */
name|tstr
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|tstr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|bus
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_BUS
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|target
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_TARGET
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|lun
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_LUN
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"you must specify either a bus or"
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"a bus, target and lun for rescanning"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"you must at least specify a bus to rescan"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|arglist
operator|&
name|CAM_ARG_BUS
operator|)
operator|&&
operator|(
name|arglist
operator|&
name|CAM_ARG_TARGET
operator|)
operator|&&
operator|(
name|arglist
operator|&
name|CAM_ARG_LUN
operator|)
condition|)
name|error
operator|=
name|scanlun
argument_list|(
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_BUS
condition|)
name|error
operator|=
name|rescanbus
argument_list|(
name|bus
argument_list|)
expr_stmt|;
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"you must specify either a bus or"
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"a bus, target and lun for rescanning"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rescanbus
parameter_list|(
name|int
name|bus
parameter_list|)
block|{
name|union
name|ccb
name|ccb
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|bus
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid bus number %d"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XPT_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"error opening tranport layer device %s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_BUS
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|path_id
operator|=
name|bus
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|CAM_LUN_WILDCARD
expr_stmt|;
name|ccb
operator|.
name|crcn
operator|.
name|flags
operator|=
name|CAM_FLAG_NONE
expr_stmt|;
comment|/* run this at a low priority */
name|ccb
operator|.
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"CAMIOCOMMAND ioctl failed"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Re-scan of bus %d was successful\n"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Re-scan of bus %d returned error %#x\n"
argument_list|,
name|bus
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|scanlun
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
name|union
name|ccb
name|ccb
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|bus
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid bus number %d"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|target
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid target number %d"
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lun
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid lun number %d"
argument_list|,
name|lun
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XPT_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"error opening tranport layer device %s\n"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCAN_LUN
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|path_id
operator|=
name|bus
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|target
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|lun
expr_stmt|;
name|ccb
operator|.
name|crcn
operator|.
name|flags
operator|=
name|CAM_FLAG_NONE
expr_stmt|;
comment|/* run this at a low priority */
name|ccb
operator|.
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"CAMIOCOMMAND ioctl failed"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Re-scan of %d:%d:%d was successful\n"
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Re-scan of %d:%d:%d returned error %#x\n"
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|readdefects
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|NULL
decl_stmt|;
name|struct
name|scsi_read_defect_data_10
modifier|*
name|rdd_cdb
decl_stmt|;
name|u_int8_t
modifier|*
name|defect_list
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|dlist_length
init|=
literal|65000
decl_stmt|;
name|u_int32_t
name|returned_length
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|num_returned
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|returned_format
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|c
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|lists_specified
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
block|{
name|char
modifier|*
name|tstr
decl_stmt|;
name|tstr
operator|=
name|optarg
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|tstr
argument_list|,
literal|"block"
argument_list|)
operator|==
literal|0
condition|)
name|arglist
operator||=
name|CAM_ARG_FORMAT_BLOCK
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tstr
argument_list|,
literal|"bfi"
argument_list|)
operator|==
literal|0
condition|)
name|arglist
operator||=
name|CAM_ARG_FORMAT_BFI
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tstr
argument_list|,
literal|"phys"
argument_list|)
operator|==
literal|0
condition|)
name|arglist
operator||=
name|CAM_ARG_FORMAT_PHYS
expr_stmt|;
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"invalid defect format %s"
argument_list|,
name|tstr
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
break|break;
block|}
case|case
literal|'G'
case|:
name|arglist
operator||=
name|CAM_ARG_GLIST
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|arglist
operator||=
name|CAM_ARG_PLIST
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
comment|/* 	 * Hopefully 65000 bytes is enough to hold the defect list.  If it 	 * isn't, the disk is probably dead already.  We'd have to go with 	 * 12 byte command (i.e. alloc_length is 32 bits instead of 16) 	 * to hold them all. 	 */
name|defect_list
operator|=
name|malloc
argument_list|(
name|dlist_length
argument_list|)
expr_stmt|;
name|rdd_cdb
operator|=
operator|(
expr|struct
name|scsi_read_defect_data_10
operator|*
operator|)
operator|&
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
comment|/* 	 * cam_getccb() zeros the CCB header only.  So we need to zero the 	 * payload portion of the ccb. 	 */
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
operator||
operator|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
operator|)
condition|?
name|CAM_PASS_ERR_RECOVER
else|:
literal|0
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*data_ptr*/
name|defect_list
argument_list|,
comment|/*dxfer_len*/
name|dlist_length
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*cdb_len*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_defect_data_10
argument_list|)
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
name|rdd_cdb
operator|->
name|opcode
operator|=
name|READ_DEFECT_DATA_10
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_FORMAT_BLOCK
condition|)
name|rdd_cdb
operator|->
name|format
operator|=
name|SRDD10_BLOCK_FORMAT
expr_stmt|;
elseif|else
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_FORMAT_BFI
condition|)
name|rdd_cdb
operator|->
name|format
operator|=
name|SRDD10_BYTES_FROM_INDEX_FORMAT
expr_stmt|;
elseif|else
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_FORMAT_PHYS
condition|)
name|rdd_cdb
operator|->
name|format
operator|=
name|SRDD10_PHYSICAL_SECTOR_FORMAT
expr_stmt|;
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"no defect list format specified"
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_PLIST
condition|)
block|{
name|rdd_cdb
operator|->
name|format
operator||=
name|SRDD10_PLIST
expr_stmt|;
name|lists_specified
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_GLIST
condition|)
block|{
name|rdd_cdb
operator|->
name|format
operator||=
name|SRDD10_GLIST
expr_stmt|;
name|lists_specified
operator|++
expr_stmt|;
block|}
name|scsi_ulto2b
argument_list|(
name|dlist_length
argument_list|,
name|rdd_cdb
operator|->
name|alloc_length
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error reading defect list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
name|scsi_sense_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CAM status is %#x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|scsi_sense_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|returned_length
operator|=
name|scsi_2btoul
argument_list|(
operator|(
operator|(
expr|struct
name|scsi_read_defect_data_hdr_10
operator|*
operator|)
name|defect_list
operator|)
operator|->
name|length
argument_list|)
expr_stmt|;
name|returned_format
operator|=
operator|(
operator|(
expr|struct
name|scsi_read_defect_data_hdr_10
operator|*
operator|)
name|defect_list
operator|)
operator|->
name|format
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|sense
operator|=
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|scsi_extract_sense
argument_list|(
name|sense
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|)
expr_stmt|;
comment|/* 		 * According to the SCSI spec, if the disk doesn't support 		 * the requested format, it will generally return a sense 		 * key of RECOVERED ERROR, and an additional sense code 		 * of "DEFECT LIST NOT FOUND".  So, we check for that, and 		 * also check to make sure that the returned length is 		 * greater than 0, and then print out whatever format the 		 * disk gave us. 		 */
if|if
condition|(
operator|(
name|sense_key
operator|==
name|SSD_KEY_RECOVERED_ERROR
operator|)
operator|&&
operator|(
name|asc
operator|==
literal|0x1c
operator|)
operator|&&
operator|(
name|ascq
operator|==
literal|0x00
operator|)
operator|&&
operator|(
name|returned_length
operator|>
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"requested defect format not available"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|returned_format
operator|&
name|SRDDH10_DLIST_FORMAT_MASK
condition|)
block|{
case|case
name|SRDD10_BLOCK_FORMAT
case|:
name|warnx
argument_list|(
literal|"Device returned block format"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SRDD10_BYTES_FROM_INDEX_FORMAT
case|:
name|warnx
argument_list|(
literal|"Device returned bytes from index"
literal|" format"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SRDD10_PHYSICAL_SECTOR_FORMAT
case|:
name|warnx
argument_list|(
literal|"Device returned physical sector format"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"Device returned unknown defect"
literal|" data format %#x"
argument_list|,
name|returned_format
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
break|break;
comment|/* NOTREACHED */
block|}
block|}
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"Error returned from read defect data command"
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
block|}
comment|/* 	 * XXX KDM  I should probably clean up the printout format for the 	 * disk defects.  	 */
switch|switch
condition|(
name|returned_format
operator|&
name|SRDDH10_DLIST_FORMAT_MASK
condition|)
block|{
case|case
name|SRDDH10_PHYSICAL_SECTOR_FORMAT
case|:
block|{
name|struct
name|scsi_defect_desc_phys_sector
modifier|*
name|dlist
decl_stmt|;
name|dlist
operator|=
operator|(
expr|struct
name|scsi_defect_desc_phys_sector
operator|*
operator|)
operator|(
name|defect_list
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_defect_data_hdr_10
argument_list|)
operator|)
expr_stmt|;
name|num_returned
operator|=
name|returned_length
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_defect_desc_phys_sector
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got %d defect"
argument_list|,
name|num_returned
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lists_specified
operator|==
literal|0
operator|)
operator|||
operator|(
name|num_returned
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|num_returned
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_returned
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d:%d:%d\n"
argument_list|,
name|scsi_3btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|cylinder
argument_list|)
argument_list|,
name|dlist
index|[
name|i
index|]
operator|.
name|head
argument_list|,
name|scsi_4btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|sector
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SRDDH10_BYTES_FROM_INDEX_FORMAT
case|:
block|{
name|struct
name|scsi_defect_desc_bytes_from_index
modifier|*
name|dlist
decl_stmt|;
name|dlist
operator|=
operator|(
expr|struct
name|scsi_defect_desc_bytes_from_index
operator|*
operator|)
operator|(
name|defect_list
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_defect_data_hdr_10
argument_list|)
operator|)
expr_stmt|;
name|num_returned
operator|=
name|returned_length
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_defect_desc_bytes_from_index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got %d defect"
argument_list|,
name|num_returned
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lists_specified
operator|==
literal|0
operator|)
operator|||
operator|(
name|num_returned
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|num_returned
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_returned
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d:%d:%d\n"
argument_list|,
name|scsi_3btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|cylinder
argument_list|)
argument_list|,
name|dlist
index|[
name|i
index|]
operator|.
name|head
argument_list|,
name|scsi_4btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|bytes_from_index
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SRDDH10_BLOCK_FORMAT
case|:
block|{
name|struct
name|scsi_defect_desc_block
modifier|*
name|dlist
decl_stmt|;
name|dlist
operator|=
operator|(
expr|struct
name|scsi_defect_desc_block
operator|*
operator|)
operator|(
name|defect_list
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_read_defect_data_hdr_10
argument_list|)
operator|)
expr_stmt|;
name|num_returned
operator|=
name|returned_length
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_defect_desc_block
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got %d defect"
argument_list|,
name|num_returned
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lists_specified
operator|==
literal|0
operator|)
operator|||
operator|(
name|num_returned
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|num_returned
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_returned
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%u\n"
argument_list|,
name|scsi_4btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|address
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown defect format %d\n"
argument_list|,
name|returned_format
operator|&
name|SRDDH10_DLIST_FORMAT_MASK
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|defect_bailout
label|:
if|if
condition|(
name|defect_list
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|defect_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void reassignblocks(struct cam_device *device, u_int32_t *blocks, int num_blocks) { 	union ccb *ccb; 	 	ccb = cam_getccb(device);  	cam_freeccb(ccb); }
endif|#
directive|endif
end_endif

begin_function
name|void
name|mode_sense
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|mode_page
parameter_list|,
name|int
name|page_control
parameter_list|,
name|int
name|dbd
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|int
name|datalen
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"mode_sense: couldn't allocate CCB"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_mode_sense
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* dbd */
name|dbd
argument_list|,
comment|/* page_code */
name|page_control
operator|<<
literal|6
argument_list|,
comment|/* page */
name|mode_page
argument_list|,
comment|/* param_buf */
name|data
argument_list|,
comment|/* param_len */
name|datalen
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
name|scsi_sense_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CAM status is %#x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|cam_close_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"error sending mode sense command"
argument_list|)
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error sending mode sense command"
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mode_select
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|save_pages
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|int
name|datalen
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"mode_select: couldn't allocate CCB"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_mode_select
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* scsi_page_fmt */
literal|1
argument_list|,
comment|/* save_pages */
name|save_pages
argument_list|,
comment|/* param_buf */
name|data
argument_list|,
comment|/* param_len */
name|datalen
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
name|scsi_sense_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CAM status is %#x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|cam_close_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"error sending mode select command"
argument_list|)
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error sending mode select command"
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|modepage
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|mode_page
init|=
operator|-
literal|1
decl_stmt|,
name|page_control
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
name|arglist
operator||=
name|CAM_ARG_DBD
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|arglist
operator||=
name|CAM_ARG_MODE_EDIT
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mode_page
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_page
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid mode page %d"
argument_list|,
name|mode_page
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|page_control
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|page_control
operator|<
literal|0
operator|)
operator|||
operator|(
name|page_control
operator|>
literal|3
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid page control field %d"
argument_list|,
name|page_control
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_PAGE_CNTL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|mode_page
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"you must specify a mode page!"
argument_list|)
expr_stmt|;
name|mode_edit
argument_list|(
name|device
argument_list|,
name|mode_page
argument_list|,
name|page_control
argument_list|,
name|arglist
operator|&
name|CAM_ARG_DBD
argument_list|,
name|arglist
operator|&
name|CAM_ARG_MODE_EDIT
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsicmd
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int32_t
name|flags
init|=
name|CAM_DIR_NONE
decl_stmt|;
name|u_int8_t
modifier|*
name|data_ptr
init|=
name|NULL
decl_stmt|;
name|u_int8_t
name|cdb
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|get_hook
name|hook
decl_stmt|;
name|int
name|c
decl_stmt|,
name|data_bytes
init|=
literal|0
decl_stmt|;
name|int
name|cdb_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|datastr
init|=
name|NULL
decl_stmt|,
modifier|*
name|tstr
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|fd_data
init|=
literal|0
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"scsicmd: error allocating ccb"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|tstr
operator|=
name|optarg
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
name|hook
operator|.
name|argc
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|hook
operator|.
name|argv
operator|=
name|argv
operator|+
name|optind
expr_stmt|;
name|hook
operator|.
name|got
operator|=
literal|0
expr_stmt|;
name|buff_encode_visit
argument_list|(
name|cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb
argument_list|)
argument_list|,
name|tstr
argument_list|,
name|iget
argument_list|,
operator|&
name|hook
argument_list|)
expr_stmt|;
comment|/* 			 * Increment optind by the number of arguments the 			 * encoding routine processed.  After each call to 			 * getopt(3), optind points to the argument that 			 * getopt should process _next_.  In this case, 			 * that means it points to the first command string 			 * argument, if there is one.  Once we increment 			 * this, it should point to either the next command 			 * line argument, or it should be past the end of 			 * the list. 			 */
name|optind
operator|+=
name|hook
operator|.
name|got
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_CMD_OUT
condition|)
block|{
name|warnx
argument_list|(
literal|"command must either be "
literal|"read or write, not both"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
name|arglist
operator||=
name|CAM_ARG_CMD_IN
expr_stmt|;
name|flags
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|data_bytes
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_bytes
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid number of input bytes %d"
argument_list|,
name|data_bytes
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
name|hook
operator|.
name|argc
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|hook
operator|.
name|argv
operator|=
name|argv
operator|+
name|optind
expr_stmt|;
name|hook
operator|.
name|got
operator|=
literal|0
expr_stmt|;
name|optind
operator|++
expr_stmt|;
name|datastr
operator|=
name|cget
argument_list|(
operator|&
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * If the user supplied "-" instead of a format, he 			 * wants the data to be written to stdout. 			 */
if|if
condition|(
operator|(
name|datastr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|datastr
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
name|fd_data
operator|=
literal|1
expr_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|malloc
argument_list|(
name|data_bytes
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_CMD_IN
condition|)
block|{
name|warnx
argument_list|(
literal|"command must either be "
literal|"read or write, not both"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
name|arglist
operator||=
name|CAM_ARG_CMD_OUT
expr_stmt|;
name|flags
operator|=
name|CAM_DIR_OUT
expr_stmt|;
name|data_bytes
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_bytes
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid number of output bytes %d"
argument_list|,
name|data_bytes
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
name|hook
operator|.
name|argc
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|hook
operator|.
name|argv
operator|=
name|argv
operator|+
name|optind
expr_stmt|;
name|hook
operator|.
name|got
operator|=
literal|0
expr_stmt|;
name|datastr
operator|=
name|cget
argument_list|(
operator|&
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|malloc
argument_list|(
name|data_bytes
argument_list|)
expr_stmt|;
comment|/* 			 * If the user supplied "-" instead of a format, he 			 * wants the data to be read from stdin. 			 */
if|if
condition|(
operator|(
name|datastr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|datastr
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
name|fd_data
operator|=
literal|1
expr_stmt|;
else|else
name|buff_encode_visit
argument_list|(
name|data_ptr
argument_list|,
name|data_bytes
argument_list|,
name|datastr
argument_list|,
name|iget
argument_list|,
operator|&
name|hook
argument_list|)
expr_stmt|;
name|optind
operator|+=
name|hook
operator|.
name|got
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * If fd_data is set, and we're writing to the device, we need to 	 * read the data the user wants written from stdin. 	 */
if|if
condition|(
operator|(
name|fd_data
operator|==
literal|1
operator|)
operator|&&
operator|(
name|arglist
operator|&
name|CAM_ARG_CMD_OUT
operator|)
condition|)
block|{
name|size_t
name|amt_read
decl_stmt|;
name|int
name|amt_to_read
init|=
name|data_bytes
decl_stmt|;
name|u_int8_t
modifier|*
name|buf_ptr
init|=
name|data_ptr
decl_stmt|;
for|for
control|(
name|amt_read
operator|=
literal|0
init|;
name|amt_to_read
operator|>
literal|0
condition|;
name|amt_read
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|buf_ptr
argument_list|,
name|amt_to_read
argument_list|)
control|)
block|{
if|if
condition|(
name|amt_read
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"error reading data from stdin"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
name|amt_to_read
operator|-=
name|amt_read
expr_stmt|;
name|buf_ptr
operator|+=
name|amt_read
expr_stmt|;
block|}
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
comment|/* Disable freezing the device queue */
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
comment|/* 	 * This is taken from the SCSI-3 draft spec. 	 * (T10/1157D revision 0.3) 	 * The top 3 bits of an opcode are the group code.  The next 5 bits 	 * are the command code. 	 * Group 0:  six byte commands 	 * Group 1:  ten byte commands 	 * Group 2:  ten byte commands 	 * Group 3:  reserved 	 * Group 4:  sixteen byte commands 	 * Group 5:  twelve byte commands 	 * Group 6:  vendor specific 	 * Group 7:  vendor specific 	 */
switch|switch
condition|(
operator|(
name|cdb
index|[
literal|0
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x7
condition|)
block|{
case|case
literal|0
case|:
name|cdb_len
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|cdb_len
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
name|cdb_len
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cdb_len
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|cdb_len
operator|=
literal|12
expr_stmt|;
break|break;
block|}
comment|/* 	 * We should probably use csio_build_visit or something like that 	 * here, but it's easier to encode arguments as you go.  The 	 * alternative would be skipping the CDB argument and then encoding 	 * it here, since we've got the data buffer argument by now. 	 */
name|bcopy
argument_list|(
name|cdb
argument_list|,
operator|&
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|cdb_len
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*flags*/
name|flags
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|data_bytes
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*cdb_len*/
name|cdb_len
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"error sending command"
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"error sending command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
name|scsi_sense_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CAM status is %#x\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|arglist
operator|&
name|CAM_ARG_CMD_IN
operator|)
operator|&&
operator|(
name|data_bytes
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|fd_data
operator|==
literal|0
condition|)
block|{
name|buff_decode_visit
argument_list|(
name|data_ptr
argument_list|,
name|data_bytes
argument_list|,
name|datastr
argument_list|,
name|arg_put
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|amt_written
decl_stmt|;
name|int
name|amt_to_write
init|=
name|data_bytes
decl_stmt|;
name|u_int8_t
modifier|*
name|buf_ptr
init|=
name|data_ptr
decl_stmt|;
for|for
control|(
name|amt_written
operator|=
literal|0
init|;
operator|(
name|amt_to_write
operator|>
literal|0
operator|)
operator|&&
operator|(
name|amt_written
operator|=
name|write
argument_list|(
literal|1
argument_list|,
name|buf_ptr
argument_list|,
name|amt_to_write
argument_list|)
operator|)
operator|>
literal|0
condition|;
control|)
block|{
name|amt_to_write
operator|-=
name|amt_written
expr_stmt|;
name|buf_ptr
operator|+=
name|amt_written
expr_stmt|;
block|}
if|if
condition|(
name|amt_written
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"error writing data to stdout"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|amt_written
operator|==
literal|0
operator|)
operator|&&
operator|(
name|amt_to_write
operator|>
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"only wrote %u bytes out of %u"
argument_list|,
name|data_bytes
operator|-
name|amt_to_write
argument_list|,
name|data_bytes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|scsicmd_bailout
label|:
if|if
condition|(
operator|(
name|data_bytes
operator|>
literal|0
operator|)
operator|&&
operator|(
name|data_ptr
operator|!=
name|NULL
operator|)
condition|)
name|free
argument_list|(
name|data_ptr
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|camdebug
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|fd
decl_stmt|;
name|int
name|bus
init|=
operator|-
literal|1
decl_stmt|,
name|target
init|=
operator|-
literal|1
decl_stmt|,
name|lun
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|tstr
decl_stmt|,
modifier|*
name|tmpstr
init|=
name|NULL
decl_stmt|;
name|union
name|ccb
name|ccb
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|ccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'I'
case|:
name|arglist
operator||=
name|CAM_ARG_DEBUG_INFO
expr_stmt|;
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator||=
name|CAM_DEBUG_INFO
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|arglist
operator||=
name|CAM_ARG_DEBUG_TRACE
expr_stmt|;
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator||=
name|CAM_DEBUG_TRACE
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|arglist
operator||=
name|CAM_ARG_DEBUG_SUBTRACE
expr_stmt|;
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator||=
name|CAM_DEBUG_SUBTRACE
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|arglist
operator||=
name|CAM_ARG_DEBUG_CDB
expr_stmt|;
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator||=
name|CAM_DEBUG_CDB
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XPT_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"error opening transport layer device %s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"you must specify \"off\", \"all\" or a bus,"
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"bus:target, or bus:target:lun"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|tstr
operator|=
operator|*
name|argv
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|tstr
argument_list|,
literal|"off"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator|=
name|CAM_DEBUG_NONE
expr_stmt|;
name|arglist
operator|&=
operator|~
operator|(
name|CAM_ARG_DEBUG_INFO
operator||
name|CAM_ARG_DEBUG_TRACE
operator||
name|CAM_ARG_DEBUG_SUBTRACE
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|tstr
argument_list|,
literal|"all"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|tstr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|bus
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_BUS
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|target
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_TARGET
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|lun
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_LUN
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"you must specify \"all\", \"off\", or a bus,"
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"bus:target, or bus:target:lun to debug"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEBUG
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|path_id
operator|=
name|bus
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|target
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|lun
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"CAMIOCOMMAND ioctl failed"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_FUNC_NOTAVAIL
condition|)
block|{
name|warnx
argument_list|(
literal|"CAM debugging not available"
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"you need to put options CAMDEBUG in"
literal|" your kernel config file!"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"XPT_DEBUG CCB failed with status %#x"
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator|==
name|CAM_DEBUG_NONE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debugging turned off\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debugging enabled for "
literal|"%d:%d:%d\n"
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage:  camcontrol<command> [ generic args ] [ command args ]\n"
literal|"        camcontrol devlist    [-v]\n"
literal|"        camcontrol periphlist [-n dev_name] [-u unit]\n"
literal|"        camcontrol tur        [generic args]\n"
literal|"        camcontrol inquiry    [generic args] [-D] [-S] [-R]\n"
literal|"        camcontrol start      [generic args]\n"
literal|"        camcontrol stop       [generic args]\n"
literal|"        camcontrol eject      [generic args]\n"
literal|"        camcontrol rescan<bus[:target:lun]>\n"
literal|"        camcontrol defects    [generic args]<-f format> [-P][-G]\n"
literal|"        camcontrol modepage   [generic args]<-m page> [-P pagectl][-e][-d]\n"
literal|"        camcontrol cmd        [generic args]<-c cmd [args]> \n"
literal|"                              [-i len fmt|-o len fmt [args]]\n"
literal|"        camcontrol debug      [-I][-T][-S][-c]<all|bus[:target[:lun]]|off>\n"
literal|"Specify one of the following options:\n"
literal|"devlist     list all CAM devices\n"
literal|"periphlist  list all CAM peripheral drivers attached to a device\n"
literal|"tur         send a test unit ready to the named device\n"
literal|"inquiry     send a SCSI inquiry command to the named device\n"
literal|"start       send a Start Unit command to the device\n"
literal|"stop        send a Stop Unit command to the device\n"
literal|"eject       send a Stop Unit command to the device with the eject bit set\n"
literal|"rescan      rescan the given bus, or bus:target:lun\n"
literal|"defects     read the defect list of the specified device\n"
literal|"modepage    display or edit (-e) the given mode page\n"
literal|"cmd         send the given scsi command, may need -i or -o as well\n"
literal|"debug       turn debugging on/off for a bus, target, or lun, or all devices\n"
literal|"Generic arguments:\n"
literal|"-v                be verbose, print out sense information\n"
literal|"-t timeout        command timeout in seconds, overrides default timeout\n"
literal|"-n dev_name       specify device name (default is %s)\n"
literal|"-u unit           specify unit number (default is %d)\n"
literal|"-E                have the kernel attempt to perform SCSI error recovery\n"
literal|"-C count          specify the SCSI command retry count (needs -E to work)\n"
literal|"modepage arguments:\n"
literal|"-e                edit the specified mode page\n"
literal|"-B                disable block descriptors for mode sense\n"
literal|"-P pgctl          page control field 0-3\n"
literal|"defects arguments:\n"
literal|"-f format         specify defect list format (block, bfi or phys)\n"
literal|"-G                get the grown defect list\n"
literal|"-P                get the permanant defect list\n"
literal|"inquiry arguments:\n"
literal|"-D                get the standard inquiry data\n"
literal|"-S                get the serial number\n"
literal|"-R                get the transfer rate, etc.\n"
literal|"cmd arguments:\n"
literal|"-c cdb [args]     specify the SCSI CDB\n"
literal|"-i len fmt        specify input data and input data format\n"
literal|"-o len fmt [args] specify output data and output data fmt\n"
literal|"debug arguments:\n"
literal|"-I                CAM_DEBUG_INFO -- scsi commands, errors, data\n"
literal|"-T                CAM_DEBUG_TRACE -- routine flow tracking\n"
literal|"-S                CAM_DEBUG_SUBTRACE -- internal routine command flow\n"
literal|"-c                CAM_DEBUG_CDB -- print out SCSI CDBs only\n"
argument_list|,
name|DEFAULT_DEVICE
argument_list|,
name|DEFAULT_UNIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|device
init|=
name|NULL
decl_stmt|;
name|int
name|unit
init|=
literal|0
decl_stmt|;
name|struct
name|cam_device
modifier|*
name|cam_dev
init|=
name|NULL
decl_stmt|;
name|int
name|timeout
init|=
literal|0
decl_stmt|,
name|retry_count
init|=
literal|1
decl_stmt|;
name|camcontrol_optret
name|optreturn
decl_stmt|;
name|char
modifier|*
name|tstr
decl_stmt|;
name|char
modifier|*
name|mainopt
init|=
literal|"C:En:t:u:v"
decl_stmt|;
name|char
modifier|*
name|subopt
init|=
name|NULL
decl_stmt|;
name|char
name|combinedopt
index|[
literal|256
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|arglist
operator|=
name|CAM_ARG_NONE
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get the base option. 	 */
name|optreturn
operator|=
name|getoption
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|arglist
argument_list|,
operator|&
name|subopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|optreturn
operator|==
name|CC_OR_AMBIGUOUS
condition|)
block|{
name|warnx
argument_list|(
literal|"ambiguous option %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optreturn
operator|==
name|CC_OR_NOT_FOUND
condition|)
block|{
name|warnx
argument_list|(
literal|"option %s not found"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Ahh, getopt(3) is a pain. 	 * 	 * This is a gross hack.  There really aren't many other good 	 * options (excuse the pun) for parsing options in a situation like 	 * this.  getopt is kinda braindead, so you end up having to run 	 * through the options twice, and give each invocation of getopt 	 * the option string for the other invocation. 	 *  	 * You would think that you could just have two groups of options. 	 * The first group would get parsed by the first invocation of 	 * getopt, and the second group would get parsed by the second 	 * invocation of getopt.  It doesn't quite work out that way.  When 	 * the first invocation of getopt finishes, it leaves optind pointing 	 * to the argument _after_ the first argument in the second group. 	 * So when the second invocation of getopt comes around, it doesn't 	 * recognize the first argument it gets and then bails out. 	 *  	 * A nice alternative would be to have a flag for getopt that says 	 * "just keep parsing arguments even when you encounter an unknown 	 * argument", but there isn't one.  So there's no real clean way to 	 * easily parse two sets of arguments without having one invocation 	 * of getopt know about the other. 	 *  	 * Without this hack, the first invocation of getopt would work as 	 * long as the generic arguments are first, but the second invocation 	 * (in the subfunction) would fail in one of two ways.  In the case 	 * where you don't set optreset, it would fail because optind may be 	 * pointing to the argument after the one it should be pointing at. 	 * In the case where you do set optreset, and reset optind, it would 	 * fail because getopt would run into the first set of options, which 	 * it doesn't understand. 	 * 	 * All of this would "sort of" work if you could somehow figure out 	 * whether optind had been incremented one option too far.  The 	 * mechanics of that, however, are more daunting than just giving 	 * both invocations all of the expect options for either invocation. 	 *  	 * Needless to say, I wouldn't mind if someone invented a better 	 * (non-GPL!) command line parsing interface than getopt.  I 	 * wouldn't mind if someone added more knobs to getopt to make it 	 * work better.  Who knows, I may talk myself into doing it someday, 	 * if the standards weenies let me.  As it is, it just leads to 	 * hackery like this and causes people to avoid it in some cases. 	 *  	 * KDM, September 8th, 1998 	 */
if|if
condition|(
name|subopt
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|combinedopt
argument_list|,
literal|"%s%s"
argument_list|,
name|mainopt
argument_list|,
name|subopt
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|combinedopt
argument_list|,
literal|"%s"
argument_list|,
name|mainopt
argument_list|)
expr_stmt|;
comment|/* 	 * Start getopt processing at argv[2], since we've already accepted 	 * argv[1] as the command name. 	 */
name|optind
operator|=
literal|2
expr_stmt|;
comment|/* 	 * Now we run through the argument list looking for generic 	 * options, and ignoring options that possibly belong to 	 * subfunctions. 	 */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'C'
case|:
name|retry_count
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry_count
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"retry count %d is< 0"
argument_list|,
name|retry_count
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_RETRIES
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|arglist
operator||=
name|CAM_ARG_ERR_RECOVER
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|arglist
operator||=
name|CAM_ARG_DEVICE
expr_stmt|;
name|tstr
operator|=
name|optarg
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
name|device
operator|=
operator|(
name|char
operator|*
operator|)
name|strdup
argument_list|(
name|tstr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|timeout
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid timeout %d"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|/* Convert the timeout from seconds to ms */
name|timeout
operator|*=
literal|1000
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_TIMEOUT
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|arglist
operator||=
name|CAM_ARG_UNIT
expr_stmt|;
name|unit
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|arglist
operator||=
name|CAM_ARG_VERBOSE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|arglist
operator|&
name|CAM_ARG_DEVICE
operator|)
operator|==
literal|0
condition|)
name|device
operator|=
operator|(
name|char
operator|*
operator|)
name|strdup
argument_list|(
name|DEFAULT_DEVICE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arglist
operator|&
name|CAM_ARG_UNIT
operator|)
operator|==
literal|0
condition|)
name|unit
operator|=
name|DEFAULT_UNIT
expr_stmt|;
comment|/* 	 * For most commands we'll want to open the passthrough device 	 * associated with the specified device.  In the case of the rescan 	 * commands, we don't use a passthrough device at all, just the 	 * transport layer device. 	 */
if|if
condition|(
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_OPT_MASK
operator|)
operator|!=
name|CAM_ARG_RESCAN
operator|)
operator|&&
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_OPT_MASK
operator|)
operator|!=
name|CAM_ARG_DEVTREE
operator|)
operator|&&
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_OPT_MASK
operator|)
operator|!=
name|CAM_ARG_USAGE
operator|)
operator|&&
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_OPT_MASK
operator|)
operator|!=
name|CAM_ARG_DEBUG
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cam_dev
operator|=
name|cam_open_spec_device
argument_list|(
name|device
argument_list|,
name|unit
argument_list|,
name|O_RDWR
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|cam_errbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reset optind to 2, and reset getopt, so these routines cam parse 	 * the arguments again. 	 */
name|optind
operator|=
literal|2
expr_stmt|;
name|optreset
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|arglist
operator|&
name|CAM_ARG_OPT_MASK
condition|)
block|{
case|case
name|CAM_ARG_DEVLIST
case|:
name|error
operator|=
name|getdevlist
argument_list|(
name|cam_dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_DEVTREE
case|:
name|error
operator|=
name|getdevtree
argument_list|()
expr_stmt|;
break|break;
case|case
name|CAM_ARG_TUR
case|:
name|error
operator|=
name|testunitready
argument_list|(
name|cam_dev
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_INQUIRY
case|:
name|error
operator|=
name|scsidoinquiry
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_STARTSTOP
case|:
name|error
operator|=
name|scsistart
argument_list|(
name|cam_dev
argument_list|,
name|arglist
operator|&
name|CAM_ARG_START_UNIT
argument_list|,
name|arglist
operator|&
name|CAM_ARG_EJECT
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_RESCAN
case|:
name|error
operator|=
name|dorescan
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_READ_DEFECTS
case|:
name|error
operator|=
name|readdefects
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_MODE_PAGE
case|:
name|modepage
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_SCSI_CMD
case|:
name|error
operator|=
name|scsicmd
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_ARG_DEBUG
case|:
name|error
operator|=
name|camdebug
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cam_dev
operator|!=
name|NULL
condition|)
name|cam_close_device
argument_list|(
name|cam_dev
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

