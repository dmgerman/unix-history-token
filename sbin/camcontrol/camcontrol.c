begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-2007 Kenneth D. Merry  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_pass.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/smp_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/ata/ata_all.h>
end_include

begin_include
include|#
directive|include
file|<camlib.h>
end_include

begin_include
include|#
directive|include
file|"camcontrol.h"
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|CAM_CMD_NONE
init|=
literal|0x00000000
block|,
name|CAM_CMD_DEVLIST
init|=
literal|0x00000001
block|,
name|CAM_CMD_TUR
init|=
literal|0x00000002
block|,
name|CAM_CMD_INQUIRY
init|=
literal|0x00000003
block|,
name|CAM_CMD_STARTSTOP
init|=
literal|0x00000004
block|,
name|CAM_CMD_RESCAN
init|=
literal|0x00000005
block|,
name|CAM_CMD_READ_DEFECTS
init|=
literal|0x00000006
block|,
name|CAM_CMD_MODE_PAGE
init|=
literal|0x00000007
block|,
name|CAM_CMD_SCSI_CMD
init|=
literal|0x00000008
block|,
name|CAM_CMD_DEVTREE
init|=
literal|0x00000009
block|,
name|CAM_CMD_USAGE
init|=
literal|0x0000000a
block|,
name|CAM_CMD_DEBUG
init|=
literal|0x0000000b
block|,
name|CAM_CMD_RESET
init|=
literal|0x0000000c
block|,
name|CAM_CMD_FORMAT
init|=
literal|0x0000000d
block|,
name|CAM_CMD_TAG
init|=
literal|0x0000000e
block|,
name|CAM_CMD_RATE
init|=
literal|0x0000000f
block|,
name|CAM_CMD_DETACH
init|=
literal|0x00000010
block|,
name|CAM_CMD_REPORTLUNS
init|=
literal|0x00000011
block|,
name|CAM_CMD_READCAP
init|=
literal|0x00000012
block|,
name|CAM_CMD_IDENTIFY
init|=
literal|0x00000013
block|,
name|CAM_CMD_IDLE
init|=
literal|0x00000014
block|,
name|CAM_CMD_STANDBY
init|=
literal|0x00000015
block|,
name|CAM_CMD_SLEEP
init|=
literal|0x00000016
block|,
name|CAM_CMD_SMP_CMD
init|=
literal|0x00000017
block|,
name|CAM_CMD_SMP_RG
init|=
literal|0x00000018
block|,
name|CAM_CMD_SMP_PC
init|=
literal|0x00000019
block|,
name|CAM_CMD_SMP_PHYLIST
init|=
literal|0x0000001a
block|,
name|CAM_CMD_SMP_MANINFO
init|=
literal|0x0000001b
block|,
name|CAM_CMD_DOWNLOAD_FW
init|=
literal|0x0000001c
block|,
name|CAM_CMD_SECURITY
init|=
literal|0x0000001d
block|,
name|CAM_CMD_HPA
init|=
literal|0x0000001e
block|,
name|CAM_CMD_SANITIZE
init|=
literal|0x0000001f
block|,
name|CAM_CMD_PERSIST
init|=
literal|0x00000020
block|,
name|CAM_CMD_APM
init|=
literal|0x00000021
block|,
name|CAM_CMD_AAM
init|=
literal|0x00000022
block|,
name|CAM_CMD_ATTRIB
init|=
literal|0x00000023
block|,
name|CAM_CMD_OPCODES
init|=
literal|0x00000024
block|,
name|CAM_CMD_REPROBE
init|=
literal|0x00000025
block|}
name|cam_cmdmask
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CAM_ARG_NONE
init|=
literal|0x00000000
block|,
name|CAM_ARG_VERBOSE
init|=
literal|0x00000001
block|,
name|CAM_ARG_DEVICE
init|=
literal|0x00000002
block|,
name|CAM_ARG_BUS
init|=
literal|0x00000004
block|,
name|CAM_ARG_TARGET
init|=
literal|0x00000008
block|,
name|CAM_ARG_LUN
init|=
literal|0x00000010
block|,
name|CAM_ARG_EJECT
init|=
literal|0x00000020
block|,
name|CAM_ARG_UNIT
init|=
literal|0x00000040
block|,
name|CAM_ARG_FORMAT_BLOCK
init|=
literal|0x00000080
block|,
name|CAM_ARG_FORMAT_BFI
init|=
literal|0x00000100
block|,
name|CAM_ARG_FORMAT_PHYS
init|=
literal|0x00000200
block|,
name|CAM_ARG_PLIST
init|=
literal|0x00000400
block|,
name|CAM_ARG_GLIST
init|=
literal|0x00000800
block|,
name|CAM_ARG_GET_SERIAL
init|=
literal|0x00001000
block|,
name|CAM_ARG_GET_STDINQ
init|=
literal|0x00002000
block|,
name|CAM_ARG_GET_XFERRATE
init|=
literal|0x00004000
block|,
name|CAM_ARG_INQ_MASK
init|=
literal|0x00007000
block|,
name|CAM_ARG_MODE_EDIT
init|=
literal|0x00008000
block|,
name|CAM_ARG_PAGE_CNTL
init|=
literal|0x00010000
block|,
name|CAM_ARG_TIMEOUT
init|=
literal|0x00020000
block|,
name|CAM_ARG_CMD_IN
init|=
literal|0x00040000
block|,
name|CAM_ARG_CMD_OUT
init|=
literal|0x00080000
block|,
name|CAM_ARG_DBD
init|=
literal|0x00100000
block|,
name|CAM_ARG_ERR_RECOVER
init|=
literal|0x00200000
block|,
name|CAM_ARG_RETRIES
init|=
literal|0x00400000
block|,
name|CAM_ARG_START_UNIT
init|=
literal|0x00800000
block|,
name|CAM_ARG_DEBUG_INFO
init|=
literal|0x01000000
block|,
name|CAM_ARG_DEBUG_TRACE
init|=
literal|0x02000000
block|,
name|CAM_ARG_DEBUG_SUBTRACE
init|=
literal|0x04000000
block|,
name|CAM_ARG_DEBUG_CDB
init|=
literal|0x08000000
block|,
name|CAM_ARG_DEBUG_XPT
init|=
literal|0x10000000
block|,
name|CAM_ARG_DEBUG_PERIPH
init|=
literal|0x20000000
block|,
name|CAM_ARG_DEBUG_PROBE
init|=
literal|0x40000000
block|, }
name|cam_argmask
typedef|;
end_typedef

begin_struct
struct|struct
name|camcontrol_opts
block|{
specifier|const
name|char
modifier|*
name|optname
decl_stmt|;
name|uint32_t
name|cmdnum
decl_stmt|;
name|cam_argmask
name|argnum
decl_stmt|;
specifier|const
name|char
modifier|*
name|subopt
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_struct
struct|struct
name|ata_res_pass16
block|{
name|u_int16_t
name|reserved
index|[
literal|5
index|]
decl_stmt|;
name|u_int8_t
name|flags
decl_stmt|;
name|u_int8_t
name|error
decl_stmt|;
name|u_int8_t
name|sector_count_exp
decl_stmt|;
name|u_int8_t
name|sector_count
decl_stmt|;
name|u_int8_t
name|lba_low_exp
decl_stmt|;
name|u_int8_t
name|lba_low
decl_stmt|;
name|u_int8_t
name|lba_mid_exp
decl_stmt|;
name|u_int8_t
name|lba_mid
decl_stmt|;
name|u_int8_t
name|lba_high_exp
decl_stmt|;
name|u_int8_t
name|lba_high
decl_stmt|;
name|u_int8_t
name|device
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ata_set_max_pwd
block|{
name|u_int16_t
name|reserved1
decl_stmt|;
name|u_int8_t
name|password
index|[
literal|32
index|]
decl_stmt|;
name|u_int16_t
name|reserved2
index|[
literal|239
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
name|scsicmd_opts
index|[]
init|=
literal|"a:c:dfi:o:r"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|readdefect_opts
index|[]
init|=
literal|"f:GPqsS:X"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|negotiate_opts
index|[]
init|=
literal|"acD:M:O:qR:T:UW:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|smprg_opts
index|[]
init|=
literal|"l"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|smppc_opts
index|[]
init|=
literal|"a:A:d:lm:M:o:p:s:S:T:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|smpphylist_opts
index|[]
init|=
literal|"lq"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pwd_opt
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|camcontrol_opts
name|option_table
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|MINIMALISTIC
block|{
literal|"tur"
block|,
name|CAM_CMD_TUR
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"inquiry"
block|,
name|CAM_CMD_INQUIRY
block|,
name|CAM_ARG_NONE
block|,
literal|"DSR"
block|}
block|,
block|{
literal|"identify"
block|,
name|CAM_CMD_IDENTIFY
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"start"
block|,
name|CAM_CMD_STARTSTOP
block|,
name|CAM_ARG_START_UNIT
block|,
name|NULL
block|}
block|,
block|{
literal|"stop"
block|,
name|CAM_CMD_STARTSTOP
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"load"
block|,
name|CAM_CMD_STARTSTOP
block|,
name|CAM_ARG_START_UNIT
operator||
name|CAM_ARG_EJECT
block|,
name|NULL
block|}
block|,
block|{
literal|"eject"
block|,
name|CAM_CMD_STARTSTOP
block|,
name|CAM_ARG_EJECT
block|,
name|NULL
block|}
block|,
block|{
literal|"reportluns"
block|,
name|CAM_CMD_REPORTLUNS
block|,
name|CAM_ARG_NONE
block|,
literal|"clr:"
block|}
block|,
block|{
literal|"readcapacity"
block|,
name|CAM_CMD_READCAP
block|,
name|CAM_ARG_NONE
block|,
literal|"bhHNqs"
block|}
block|,
block|{
literal|"reprobe"
block|,
name|CAM_CMD_REPROBE
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
endif|#
directive|endif
comment|/* MINIMALISTIC */
block|{
literal|"rescan"
block|,
name|CAM_CMD_RESCAN
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"reset"
block|,
name|CAM_CMD_RESET
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
ifndef|#
directive|ifndef
name|MINIMALISTIC
block|{
literal|"cmd"
block|,
name|CAM_CMD_SCSI_CMD
block|,
name|CAM_ARG_NONE
block|,
name|scsicmd_opts
block|}
block|,
block|{
literal|"command"
block|,
name|CAM_CMD_SCSI_CMD
block|,
name|CAM_ARG_NONE
block|,
name|scsicmd_opts
block|}
block|,
block|{
literal|"smpcmd"
block|,
name|CAM_CMD_SMP_CMD
block|,
name|CAM_ARG_NONE
block|,
literal|"r:R:"
block|}
block|,
block|{
literal|"smprg"
block|,
name|CAM_CMD_SMP_RG
block|,
name|CAM_ARG_NONE
block|,
name|smprg_opts
block|}
block|,
block|{
literal|"smpreportgeneral"
block|,
name|CAM_CMD_SMP_RG
block|,
name|CAM_ARG_NONE
block|,
name|smprg_opts
block|}
block|,
block|{
literal|"smppc"
block|,
name|CAM_CMD_SMP_PC
block|,
name|CAM_ARG_NONE
block|,
name|smppc_opts
block|}
block|,
block|{
literal|"smpphycontrol"
block|,
name|CAM_CMD_SMP_PC
block|,
name|CAM_ARG_NONE
block|,
name|smppc_opts
block|}
block|,
block|{
literal|"smpplist"
block|,
name|CAM_CMD_SMP_PHYLIST
block|,
name|CAM_ARG_NONE
block|,
name|smpphylist_opts
block|}
block|,
block|{
literal|"smpphylist"
block|,
name|CAM_CMD_SMP_PHYLIST
block|,
name|CAM_ARG_NONE
block|,
name|smpphylist_opts
block|}
block|,
block|{
literal|"smpmaninfo"
block|,
name|CAM_CMD_SMP_MANINFO
block|,
name|CAM_ARG_NONE
block|,
literal|"l"
block|}
block|,
block|{
literal|"defects"
block|,
name|CAM_CMD_READ_DEFECTS
block|,
name|CAM_ARG_NONE
block|,
name|readdefect_opts
block|}
block|,
block|{
literal|"defectlist"
block|,
name|CAM_CMD_READ_DEFECTS
block|,
name|CAM_ARG_NONE
block|,
name|readdefect_opts
block|}
block|,
endif|#
directive|endif
comment|/* MINIMALISTIC */
block|{
literal|"devlist"
block|,
name|CAM_CMD_DEVTREE
block|,
name|CAM_ARG_NONE
block|,
literal|"-b"
block|}
block|,
ifndef|#
directive|ifndef
name|MINIMALISTIC
block|{
literal|"periphlist"
block|,
name|CAM_CMD_DEVLIST
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"modepage"
block|,
name|CAM_CMD_MODE_PAGE
block|,
name|CAM_ARG_NONE
block|,
literal|"bdelm:P:"
block|}
block|,
block|{
literal|"tags"
block|,
name|CAM_CMD_TAG
block|,
name|CAM_ARG_NONE
block|,
literal|"N:q"
block|}
block|,
block|{
literal|"negotiate"
block|,
name|CAM_CMD_RATE
block|,
name|CAM_ARG_NONE
block|,
name|negotiate_opts
block|}
block|,
block|{
literal|"rate"
block|,
name|CAM_CMD_RATE
block|,
name|CAM_ARG_NONE
block|,
name|negotiate_opts
block|}
block|,
block|{
literal|"debug"
block|,
name|CAM_CMD_DEBUG
block|,
name|CAM_ARG_NONE
block|,
literal|"IPTSXcp"
block|}
block|,
block|{
literal|"format"
block|,
name|CAM_CMD_FORMAT
block|,
name|CAM_ARG_NONE
block|,
literal|"qrwy"
block|}
block|,
block|{
literal|"sanitize"
block|,
name|CAM_CMD_SANITIZE
block|,
name|CAM_ARG_NONE
block|,
literal|"a:c:IP:qrUwy"
block|}
block|,
block|{
literal|"idle"
block|,
name|CAM_CMD_IDLE
block|,
name|CAM_ARG_NONE
block|,
literal|"t:"
block|}
block|,
block|{
literal|"standby"
block|,
name|CAM_CMD_STANDBY
block|,
name|CAM_ARG_NONE
block|,
literal|"t:"
block|}
block|,
block|{
literal|"sleep"
block|,
name|CAM_CMD_SLEEP
block|,
name|CAM_ARG_NONE
block|,
literal|""
block|}
block|,
block|{
literal|"apm"
block|,
name|CAM_CMD_APM
block|,
name|CAM_ARG_NONE
block|,
literal|"l:"
block|}
block|,
block|{
literal|"aam"
block|,
name|CAM_CMD_AAM
block|,
name|CAM_ARG_NONE
block|,
literal|"l:"
block|}
block|,
block|{
literal|"fwdownload"
block|,
name|CAM_CMD_DOWNLOAD_FW
block|,
name|CAM_ARG_NONE
block|,
literal|"f:qsy"
block|}
block|,
block|{
literal|"security"
block|,
name|CAM_CMD_SECURITY
block|,
name|CAM_ARG_NONE
block|,
literal|"d:e:fh:k:l:qs:T:U:y"
block|}
block|,
block|{
literal|"hpa"
block|,
name|CAM_CMD_HPA
block|,
name|CAM_ARG_NONE
block|,
literal|"Pflp:qs:U:y"
block|}
block|,
block|{
literal|"persist"
block|,
name|CAM_CMD_PERSIST
block|,
name|CAM_ARG_NONE
block|,
literal|"ai:I:k:K:o:ps:ST:U"
block|}
block|,
block|{
literal|"attrib"
block|,
name|CAM_CMD_ATTRIB
block|,
name|CAM_ARG_NONE
block|,
literal|"a:ce:F:p:r:s:T:w:V:"
block|}
block|,
block|{
literal|"opcodes"
block|,
name|CAM_CMD_OPCODES
block|,
name|CAM_ARG_NONE
block|,
literal|"No:s:T"
block|}
block|,
endif|#
directive|endif
comment|/* MINIMALISTIC */
block|{
literal|"help"
block|,
name|CAM_CMD_USAGE
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"-?"
block|,
name|CAM_CMD_USAGE
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"-h"
block|,
name|CAM_CMD_USAGE
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|cam_devitem
block|{
name|struct
name|device_match_result
name|dev_match
decl_stmt|;
name|int
name|num_periphs
decl_stmt|;
name|struct
name|periph_match_result
modifier|*
name|periph_matches
decl_stmt|;
name|struct
name|scsi_vpd_device_id
modifier|*
name|device_id
decl_stmt|;
name|int
name|device_id_len
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|cam_devitem
argument_list|)
name|links
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cam_devlist
block|{
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|cam_devitem
argument_list|)
name|dev_queue
expr_stmt|;
name|path_id_t
name|path_id
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|cam_cmdmask
name|cmdlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cam_argmask
name|arglist
decl_stmt|;
end_decl_stmt

begin_function_decl
name|camcontrol_optret
name|getoption
parameter_list|(
name|struct
name|camcontrol_opts
modifier|*
name|table
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|,
name|uint32_t
modifier|*
name|cmdnum
parameter_list|,
name|cam_argmask
modifier|*
name|argnum
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|subopt
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_function_decl
specifier|static
name|int
name|getdevlist
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MINIMALISTIC */
end_comment

begin_function_decl
specifier|static
name|int
name|getdevtree
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_function_decl
specifier|static
name|int
name|testunitready
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|quiet
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsistart
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|startstop
parameter_list|,
name|int
name|loadeject
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsiinquiry
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsiserial
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MINIMALISTIC */
end_comment

begin_function_decl
specifier|static
name|int
name|parse_btl
parameter_list|(
name|char
modifier|*
name|tstr
parameter_list|,
name|path_id_t
modifier|*
name|bus
parameter_list|,
name|target_id_t
modifier|*
name|target
parameter_list|,
name|lun_id_t
modifier|*
name|lun
parameter_list|,
name|cam_argmask
modifier|*
name|arglst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dorescan_or_reset
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|rescan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rescan_or_reset_bus
parameter_list|(
name|path_id_t
name|bus
parameter_list|,
name|int
name|rescan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scanlun_or_reset_dev
parameter_list|(
name|path_id_t
name|bus
parameter_list|,
name|target_id_t
name|target
parameter_list|,
name|lun_id_t
name|lun
parameter_list|,
name|int
name|scan
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_function_decl
specifier|static
name|int
name|readdefects
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|modepage
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsicmd
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smpcmd
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smpreportgeneral
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smpphycontrol
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smpmaninfo
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getdevid
parameter_list|(
name|struct
name|cam_devitem
modifier|*
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|buildbusdevlist
parameter_list|(
name|struct
name|cam_devlist
modifier|*
name|devlist
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|freebusdevlist
parameter_list|(
name|struct
name|cam_devlist
modifier|*
name|devlist
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cam_devitem
modifier|*
name|findsasdevice
parameter_list|(
name|struct
name|cam_devlist
modifier|*
name|devlist
parameter_list|,
name|uint64_t
name|sasaddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smpphylist
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tagcontrol
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cts_print
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cpi_print
parameter_list|(
name|struct
name|ccb_pathinq
modifier|*
name|cpi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_cpi
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|struct
name|ccb_pathinq
modifier|*
name|cpi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_cgd
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|struct
name|ccb_getdev
modifier|*
name|cgd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_print_cts
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|user_settings
parameter_list|,
name|int
name|quiet
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ratecontrol
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsiformat
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsisanitize
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsireportluns
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsireadcapacity
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atapm
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atasecurity
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atahpa
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsiprintoneopcode
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|req_opcode
parameter_list|,
name|int
name|sa_set
parameter_list|,
name|int
name|req_sa
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|valid_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsiprintopcodes
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|td_req
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|valid_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsiopcodes
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|verbose
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsireprobe
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MINIMALISTIC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<(b))?(a):(b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|max
end_ifndef

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)>(b))?(a):(b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|camcontrol_optret
name|getoption
parameter_list|(
name|struct
name|camcontrol_opts
modifier|*
name|table
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|,
name|uint32_t
modifier|*
name|cmdnum
parameter_list|,
name|cam_argmask
modifier|*
name|argnum
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|subopt
parameter_list|)
block|{
name|struct
name|camcontrol_opts
modifier|*
name|opts
decl_stmt|;
name|int
name|num_matches
init|=
literal|0
decl_stmt|;
for|for
control|(
name|opts
operator|=
name|table
init|;
operator|(
name|opts
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|opts
operator|->
name|optname
operator|!=
name|NULL
operator|)
condition|;
name|opts
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|opts
operator|->
name|optname
argument_list|,
name|arg
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|cmdnum
operator|=
name|opts
operator|->
name|cmdnum
expr_stmt|;
operator|*
name|argnum
operator|=
name|opts
operator|->
name|argnum
expr_stmt|;
operator|*
name|subopt
operator|=
name|opts
operator|->
name|subopt
expr_stmt|;
if|if
condition|(
operator|++
name|num_matches
operator|>
literal|1
condition|)
return|return
operator|(
name|CC_OR_AMBIGUOUS
operator|)
return|;
block|}
block|}
if|if
condition|(
name|num_matches
operator|>
literal|0
condition|)
return|return
operator|(
name|CC_OR_FOUND
operator|)
return|;
else|else
return|return
operator|(
name|CC_OR_NOT_FOUND
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_function
specifier|static
name|int
name|getdevlist
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|char
name|status
index|[
literal|32
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEVLIST
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DIR_NONE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|=
name|CAM_GDEVLIST_MORE_DEVS
expr_stmt|;
while|while
condition|(
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|==
name|CAM_GDEVLIST_MORE_DEVS
condition|)
block|{
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error getting device list"
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|status
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|cgdl
operator|.
name|status
condition|)
block|{
case|case
name|CAM_GDEVLIST_MORE_DEVS
case|:
name|strcpy
argument_list|(
name|status
argument_list|,
literal|"MORE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_GDEVLIST_LAST_DEVICE
case|:
name|strcpy
argument_list|(
name|status
argument_list|,
literal|"LAST"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_GDEVLIST_LIST_CHANGED
case|:
name|strcpy
argument_list|(
name|status
argument_list|,
literal|"CHANGED"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_GDEVLIST_ERROR
case|:
name|strcpy
argument_list|(
name|status
argument_list|,
literal|"ERROR"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%d:  generation: %d index: %d status: %s\n"
argument_list|,
name|ccb
operator|->
name|cgdl
operator|.
name|periph_name
argument_list|,
name|ccb
operator|->
name|cgdl
operator|.
name|unit_number
argument_list|,
name|ccb
operator|->
name|cgdl
operator|.
name|generation
argument_list|,
name|ccb
operator|->
name|cgdl
operator|.
name|index
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* 		 * If the list has changed, we need to start over from the 		 * beginning. 		 */
if|if
condition|(
name|ccb
operator|->
name|cgdl
operator|.
name|status
operator|==
name|CAM_GDEVLIST_LIST_CHANGED
condition|)
name|ccb
operator|->
name|cgdl
operator|.
name|index
operator|=
literal|0
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MINIMALISTIC */
end_comment

begin_function
specifier|static
name|int
name|getdevtree
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
block|{
name|union
name|ccb
name|ccb
decl_stmt|;
name|int
name|bufsize
decl_stmt|,
name|fd
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|need_close
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|skip_device
init|=
literal|0
decl_stmt|;
name|int
name|busonly
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
operator|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
operator|)
operator|==
literal|0
condition|)
name|busonly
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XPT_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"couldn't open %s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|ccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|path_id
operator|=
name|CAM_XPT_PATH_ID
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|CAM_LUN_WILDCARD
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEV_MATCH
expr_stmt|;
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
operator|*
literal|100
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|match_buf_len
operator|=
name|bufsize
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|matches
operator|=
operator|(
expr|struct
name|dev_match_result
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|.
name|cdm
operator|.
name|matches
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't malloc memory for matches"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ccb
operator|.
name|cdm
operator|.
name|num_matches
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We fetch all nodes, since we display most of them in the default 	 * case, and all in the verbose case. 	 */
name|ccb
operator|.
name|cdm
operator|.
name|num_patterns
operator|=
literal|0
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|pattern_buf_len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We do the ioctl multiple times if necessary, in case there are 	 * more than 100 nodes in the EDT. 	 */
do|do
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"error sending CAMIOCOMMAND ioctl"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|.
name|cdm
operator|.
name|status
operator|!=
name|CAM_DEV_MATCH_LAST
operator|)
operator|&&
operator|(
name|ccb
operator|.
name|cdm
operator|.
name|status
operator|!=
name|CAM_DEV_MATCH_MORE
operator|)
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"got CAM error %#x, CDM error %d\n"
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
argument_list|,
name|ccb
operator|.
name|cdm
operator|.
name|status
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccb
operator|.
name|cdm
operator|.
name|num_matches
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|DEV_MATCH_BUS
case|:
block|{
name|struct
name|bus_match_result
modifier|*
name|bus_result
decl_stmt|;
comment|/* 				 * Only print the bus information if the 				 * user turns on the verbose flag. 				 */
if|if
condition|(
operator|(
name|busonly
operator|==
literal|0
operator|)
operator|&&
operator|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
operator|)
operator|==
literal|0
condition|)
break|break;
name|bus_result
operator|=
operator|&
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|result
operator|.
name|bus_result
expr_stmt|;
if|if
condition|(
name|need_close
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|need_close
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"scbus%d on %s%d bus %d%s\n"
argument_list|,
name|bus_result
operator|->
name|path_id
argument_list|,
name|bus_result
operator|->
name|dev_name
argument_list|,
name|bus_result
operator|->
name|unit_number
argument_list|,
name|bus_result
operator|->
name|bus_id
argument_list|,
operator|(
name|busonly
condition|?
literal|""
else|:
literal|":"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DEV_MATCH_DEVICE
case|:
block|{
name|struct
name|device_match_result
modifier|*
name|dev_result
decl_stmt|;
name|char
name|vendor
index|[
literal|16
index|]
decl_stmt|,
name|product
index|[
literal|48
index|]
decl_stmt|,
name|revision
index|[
literal|16
index|]
decl_stmt|;
name|char
name|fw
index|[
literal|5
index|]
decl_stmt|,
name|tmpstr
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|busonly
operator|==
literal|1
condition|)
break|break;
name|dev_result
operator|=
operator|&
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|result
operator|.
name|device_result
expr_stmt|;
if|if
condition|(
operator|(
name|dev_result
operator|->
name|flags
operator|&
name|DEV_RESULT_UNCONFIGURED
operator|)
operator|&&
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|skip_device
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
name|skip_device
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dev_result
operator|->
name|protocol
operator|==
name|PROTO_SCSI
condition|)
block|{
name|cam_strvis
argument_list|(
name|vendor
argument_list|,
name|dev_result
operator|->
name|inq_data
operator|.
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_result
operator|->
name|inq_data
operator|.
name|vendor
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|product
argument_list|,
name|dev_result
operator|->
name|inq_data
operator|.
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_result
operator|->
name|inq_data
operator|.
name|product
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|revision
argument_list|,
name|dev_result
operator|->
name|inq_data
operator|.
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_result
operator|->
name|inq_data
operator|.
name|revision
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpstr
argument_list|,
literal|"<%s %s %s>"
argument_list|,
name|vendor
argument_list|,
name|product
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dev_result
operator|->
name|protocol
operator|==
name|PROTO_ATA
operator|||
name|dev_result
operator|->
name|protocol
operator|==
name|PROTO_SATAPM
condition|)
block|{
name|cam_strvis
argument_list|(
name|product
argument_list|,
name|dev_result
operator|->
name|ident_data
operator|.
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_result
operator|->
name|ident_data
operator|.
name|model
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|revision
argument_list|,
name|dev_result
operator|->
name|ident_data
operator|.
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_result
operator|->
name|ident_data
operator|.
name|revision
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpstr
argument_list|,
literal|"<%s %s>"
argument_list|,
name|product
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dev_result
operator|->
name|protocol
operator|==
name|PROTO_SEMB
condition|)
block|{
name|struct
name|sep_identify_data
modifier|*
name|sid
decl_stmt|;
name|sid
operator|=
operator|(
expr|struct
name|sep_identify_data
operator|*
operator|)
operator|&
name|dev_result
operator|->
name|ident_data
expr_stmt|;
name|cam_strvis
argument_list|(
name|vendor
argument_list|,
name|sid
operator|->
name|vendor_id
argument_list|,
sizeof|sizeof
argument_list|(
name|sid
operator|->
name|vendor_id
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|product
argument_list|,
name|sid
operator|->
name|product_id
argument_list|,
sizeof|sizeof
argument_list|(
name|sid
operator|->
name|product_id
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|revision
argument_list|,
name|sid
operator|->
name|product_rev
argument_list|,
sizeof|sizeof
argument_list|(
name|sid
operator|->
name|product_rev
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|fw
argument_list|,
name|sid
operator|->
name|firmware_rev
argument_list|,
sizeof|sizeof
argument_list|(
name|sid
operator|->
name|firmware_rev
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|fw
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpstr
argument_list|,
literal|"<%s %s %s %s>"
argument_list|,
name|vendor
argument_list|,
name|product
argument_list|,
name|revision
argument_list|,
name|fw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|tmpstr
argument_list|,
literal|"<>"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_close
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|need_close
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%-33s  at scbus%d "
literal|"target %d lun %jx ("
argument_list|,
name|tmpstr
argument_list|,
name|dev_result
operator|->
name|path_id
argument_list|,
name|dev_result
operator|->
name|target_id
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dev_result
operator|->
name|target_lun
argument_list|)
expr_stmt|;
name|need_close
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|DEV_MATCH_PERIPH
case|:
block|{
name|struct
name|periph_match_result
modifier|*
name|periph_result
decl_stmt|;
name|periph_result
operator|=
operator|&
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|result
operator|.
name|periph_result
expr_stmt|;
if|if
condition|(
name|busonly
operator|||
name|skip_device
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|need_close
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%d"
argument_list|,
name|periph_result
operator|->
name|periph_name
argument_list|,
name|periph_result
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|need_close
operator|++
expr_stmt|;
break|break;
block|}
default|default:
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"unknown match type\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|ccb
operator|.
name|cdm
operator|.
name|status
operator|==
name|CAM_DEV_MATCH_MORE
operator|)
condition|)
do|;
if|if
condition|(
name|need_close
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_function
specifier|static
name|int
name|testunitready
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|scsi_test_unit_ready
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|perror
argument_list|(
literal|"error sending test unit ready"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Unit is ready\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Unit is not ready\n"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsistart
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|startstop
parameter_list|,
name|int
name|loadeject
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
comment|/* 	 * If we're stopping, send an ordered tag so the drive in question 	 * will finish any previously queued writes before stopping.  If 	 * the device isn't capable of tagged queueing, or if tagged 	 * queueing is turned off, the tag action is a no-op. 	 */
name|scsi_start_stop
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|startstop
condition|?
name|MSG_SIMPLE_Q_TAG
else|:
name|MSG_ORDERED_Q_TAG
argument_list|,
comment|/* start/stop */
name|startstop
argument_list|,
comment|/* load_eject */
name|loadeject
argument_list|,
comment|/* immediate */
literal|0
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|120000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending start unit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
if|if
condition|(
name|startstop
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Unit started successfully"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadeject
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|", Media loaded\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Unit stopped successfully"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadeject
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|", Media ejected\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|startstop
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Error received from start unit command\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Error received from stop unit command\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scsidoinquiry
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'D'
case|:
name|arglist
operator||=
name|CAM_ARG_GET_STDINQ
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|arglist
operator||=
name|CAM_ARG_GET_XFERRATE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|arglist
operator||=
name|CAM_ARG_GET_SERIAL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * If the user didn't specify any inquiry options, he wants all of 	 * them. 	 */
if|if
condition|(
operator|(
name|arglist
operator|&
name|CAM_ARG_INQ_MASK
operator|)
operator|==
literal|0
condition|)
name|arglist
operator||=
name|CAM_ARG_INQ_MASK
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_GET_STDINQ
condition|)
name|error
operator|=
name|scsiinquiry
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_GET_SERIAL
condition|)
name|scsiserial
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_GET_XFERRATE
condition|)
name|error
operator|=
name|camxferrate
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsiinquiry
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_buf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't allocate CCB"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* cam_getccb cleans up the header, caller has to zero the payload */
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|inq_buf
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inq_buf
operator|==
name|NULL
condition|)
block|{
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"can't malloc memory for inquiry\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
name|inq_buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inq_buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Note that although the size of the inquiry buffer is the full 	 * 256 bytes specified in the SCSI spec, we only tell the device 	 * that we have allocated SHORT_INQUIRY_LENGTH bytes.  There are 	 * two reasons for this: 	 * 	 *  - The SCSI spec says that when a length field is only 1 byte, 	 *    a value of 0 will be interpreted as 256.  Therefore 	 *    scsi_inquiry() will convert an inq_len (which is passed in as 	 *    a u_int32_t, but the field in the CDB is only 1 byte) of 256 	 *    to 0.  Evidently, very few devices meet the spec in that 	 *    regard.  Some devices, like many Seagate disks, take the 0 as 	 *    0, and don't return any data.  One Pioneer DVD-R drive 	 *    returns more data than the command asked for. 	 * 	 *    So, since there are numerous devices that just don't work 	 *    right with the full inquiry size, we don't send the full size. 	 * 	 *  - The second reason not to use the full inquiry data length is 	 *    that we don't need it here.  The only reason we issue a 	 *    standard inquiry is to get the vendor name, device name, 	 *    and revision so scsi_print_inquiry() can print them. 	 * 	 * If, at some point in the future, more inquiry data is needed for 	 * some reason, this code should use a procedure similar to the 	 * probe code.  i.e., issue a short inquiry, and determine from 	 * the additional length passed back from the device how much 	 * inquiry data the device supports.  Once the amount the device 	 * supports is determined, issue an inquiry for that amount and no 	 * more. 	 * 	 * KDM, 2/18/2000 	 */
name|scsi_inquiry
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* inq_buf */
operator|(
name|u_int8_t
operator|*
operator|)
name|inq_buf
argument_list|,
comment|/* inq_len */
name|SHORT_INQUIRY_LENGTH
argument_list|,
comment|/* evpd */
literal|0
argument_list|,
comment|/* page_code */
literal|0
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending SCSI inquiry"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|inq_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%d: "
argument_list|,
name|device
operator|->
name|device_name
argument_list|,
name|device
operator|->
name|dev_unit_num
argument_list|)
expr_stmt|;
name|scsi_print_inquiry
argument_list|(
name|inq_buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inq_buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsiserial
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|scsi_vpd_unit_serial_number
modifier|*
name|serial_buf
decl_stmt|;
name|char
name|serial_num
index|[
name|SVPD_SERIAL_NUM_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't allocate CCB"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* cam_getccb cleans up the header, caller has to zero the payload */
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|serial_buf
operator|=
operator|(
expr|struct
name|scsi_vpd_unit_serial_number
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|serial_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_buf
operator|==
name|NULL
condition|)
block|{
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"can't malloc memory for serial number"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|scsi_inquiry
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* inq_buf */
operator|(
name|u_int8_t
operator|*
operator|)
name|serial_buf
argument_list|,
comment|/* inq_len */
sizeof|sizeof
argument_list|(
operator|*
name|serial_buf
argument_list|)
argument_list|,
comment|/* evpd */
literal|1
argument_list|,
comment|/* page_code */
name|SVPD_UNIT_SERIAL_NUMBER
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error getting serial number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|serial_buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|serial_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|serial_buf
operator|->
name|serial_num
argument_list|,
name|serial_num
argument_list|,
name|serial_buf
operator|->
name|length
argument_list|)
expr_stmt|;
name|serial_num
index|[
name|serial_buf
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|arglist
operator|&
name|CAM_ARG_GET_STDINQ
operator|)
operator|||
operator|(
name|arglist
operator|&
name|CAM_ARG_GET_XFERRATE
operator|)
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%d: Serial Number "
argument_list|,
name|device
operator|->
name|device_name
argument_list|,
name|device
operator|->
name|dev_unit_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%.60s\n"
argument_list|,
name|serial_num
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|serial_buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|camxferrate
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
block|{
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|u_int32_t
name|freq
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|speed
init|=
literal|0
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int
name|mb
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|get_cpi
argument_list|(
name|device
argument_list|,
operator|&
name|cpi
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't allocate CCB"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_trans_settings
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GET_TRAN_SETTINGS
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|type
operator|=
name|CTS_TYPE_CURRENT_SETTINGS
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
specifier|const
name|char
name|error_string
index|[]
init|=
literal|"error getting transfer settings"
decl_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|warn
argument_list|(
name|error_string
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
name|error_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|xferrate_bailout
goto|;
block|}
name|speed
operator|=
name|cpi
operator|.
name|base_transfer_speed
expr_stmt|;
name|freq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|cts
operator|.
name|transport
operator|==
name|XPORT_SPI
condition|)
block|{
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|spi
decl_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|!=
literal|0
condition|)
block|{
name|freq
operator|=
name|scsi_calc_syncsrate
argument_list|(
name|spi
operator|->
name|sync_period
argument_list|)
expr_stmt|;
name|speed
operator|=
name|freq
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|!=
literal|0
condition|)
block|{
name|speed
operator|*=
operator|(
literal|0x01
operator|<<
name|spi
operator|->
name|bus_width
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ccb
operator|->
name|cts
operator|.
name|transport
operator|==
name|XPORT_FC
condition|)
block|{
name|struct
name|ccb_trans_settings_fc
modifier|*
name|fc
init|=
operator|&
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|fc
decl_stmt|;
if|if
condition|(
name|fc
operator|->
name|valid
operator|&
name|CTS_FC_VALID_SPEED
condition|)
name|speed
operator|=
name|fc
operator|->
name|bitrate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ccb
operator|->
name|cts
operator|.
name|transport
operator|==
name|XPORT_SAS
condition|)
block|{
name|struct
name|ccb_trans_settings_sas
modifier|*
name|sas
init|=
operator|&
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|sas
decl_stmt|;
if|if
condition|(
name|sas
operator|->
name|valid
operator|&
name|CTS_SAS_VALID_SPEED
condition|)
name|speed
operator|=
name|sas
operator|->
name|bitrate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ccb
operator|->
name|cts
operator|.
name|transport
operator|==
name|XPORT_ATA
condition|)
block|{
name|struct
name|ccb_trans_settings_pata
modifier|*
name|pata
init|=
operator|&
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|ata
decl_stmt|;
if|if
condition|(
name|pata
operator|->
name|valid
operator|&
name|CTS_ATA_VALID_MODE
condition|)
name|speed
operator|=
name|ata_mode2speed
argument_list|(
name|pata
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ccb
operator|->
name|cts
operator|.
name|transport
operator|==
name|XPORT_SATA
condition|)
block|{
name|struct
name|ccb_trans_settings_sata
modifier|*
name|sata
init|=
operator|&
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|sata
decl_stmt|;
if|if
condition|(
name|sata
operator|->
name|valid
operator|&
name|CTS_SATA_VALID_REVISION
condition|)
name|speed
operator|=
name|ata_revision2speed
argument_list|(
name|sata
operator|->
name|revision
argument_list|)
expr_stmt|;
block|}
name|mb
operator|=
name|speed
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|mb
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%d: %d.%03dMB/s transfers"
argument_list|,
name|device
operator|->
name|device_name
argument_list|,
name|device
operator|->
name|dev_unit_num
argument_list|,
name|mb
argument_list|,
name|speed
operator|%
literal|1000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%d: %dKB/s transfers"
argument_list|,
name|device
operator|->
name|device_name
argument_list|,
name|device
operator|->
name|dev_unit_num
argument_list|,
name|speed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|cts
operator|.
name|transport
operator|==
name|XPORT_SPI
condition|)
block|{
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|spi
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|spi
operator|->
name|sync_offset
operator|!=
literal|0
operator|)
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" (%d.%03dMHz, offset %d"
argument_list|,
name|freq
operator|/
literal|1000
argument_list|,
name|freq
operator|%
literal|1000
argument_list|,
name|spi
operator|->
name|sync_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|spi
operator|->
name|bus_width
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|spi
operator|->
name|sync_offset
operator|!=
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%dbit)"
argument_list|,
literal|8
operator|*
operator|(
literal|0x01
operator|<<
name|spi
operator|->
name|bus_width
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|spi
operator|->
name|sync_offset
operator|!=
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ccb
operator|->
name|cts
operator|.
name|transport
operator|==
name|XPORT_ATA
condition|)
block|{
name|struct
name|ccb_trans_settings_pata
modifier|*
name|pata
init|=
operator|&
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|ata
decl_stmt|;
name|printf
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|pata
operator|->
name|valid
operator|&
name|CTS_ATA_VALID_MODE
condition|)
name|printf
argument_list|(
literal|"%s, "
argument_list|,
name|ata_mode2string
argument_list|(
name|pata
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pata
operator|->
name|valid
operator|&
name|CTS_ATA_VALID_ATAPI
operator|)
operator|&&
name|pata
operator|->
name|atapi
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"ATAPI %dbytes, "
argument_list|,
name|pata
operator|->
name|atapi
argument_list|)
expr_stmt|;
if|if
condition|(
name|pata
operator|->
name|valid
operator|&
name|CTS_ATA_VALID_BYTECOUNT
condition|)
name|printf
argument_list|(
literal|"PIO %dbytes"
argument_list|,
name|pata
operator|->
name|bytecount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ccb
operator|->
name|cts
operator|.
name|transport
operator|==
name|XPORT_SATA
condition|)
block|{
name|struct
name|ccb_trans_settings_sata
modifier|*
name|sata
init|=
operator|&
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|sata
decl_stmt|;
name|printf
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|sata
operator|->
name|valid
operator|&
name|CTS_SATA_VALID_REVISION
condition|)
name|printf
argument_list|(
literal|"SATA %d.x, "
argument_list|,
name|sata
operator|->
name|revision
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"SATA, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sata
operator|->
name|valid
operator|&
name|CTS_SATA_VALID_MODE
condition|)
name|printf
argument_list|(
literal|"%s, "
argument_list|,
name|ata_mode2string
argument_list|(
name|sata
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sata
operator|->
name|valid
operator|&
name|CTS_SATA_VALID_ATAPI
operator|)
operator|&&
name|sata
operator|->
name|atapi
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"ATAPI %dbytes, "
argument_list|,
name|sata
operator|->
name|atapi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sata
operator|->
name|valid
operator|&
name|CTS_SATA_VALID_BYTECOUNT
condition|)
name|printf
argument_list|(
literal|"PIO %dbytes"
argument_list|,
name|sata
operator|->
name|bytecount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|cts
operator|.
name|protocol
operator|==
name|PROTO_SCSI
condition|)
block|{
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|ccb
operator|->
name|cts
operator|.
name|proto_specific
operator|.
name|scsi
decl_stmt|;
if|if
condition|(
name|scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
condition|)
block|{
if|if
condition|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|", Command Queueing Enabled"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|xferrate_bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atahpa_print
parameter_list|(
name|struct
name|ata_params
modifier|*
name|parm
parameter_list|,
name|u_int64_t
name|hpasize
parameter_list|,
name|int
name|header
parameter_list|)
block|{
name|u_int32_t
name|lbasize
init|=
operator|(
name|u_int32_t
operator|)
name|parm
operator|->
name|lba_size_1
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|parm
operator|->
name|lba_size_2
operator|<<
literal|16
operator|)
decl_stmt|;
name|u_int64_t
name|lbasize48
init|=
operator|(
operator|(
name|u_int64_t
operator|)
name|parm
operator|->
name|lba_size48_1
operator|)
operator||
operator|(
operator|(
name|u_int64_t
operator|)
name|parm
operator|->
name|lba_size48_2
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int64_t
operator|)
name|parm
operator|->
name|lba_size48_3
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|u_int64_t
operator|)
name|parm
operator|->
name|lba_size48_4
operator|<<
literal|48
operator|)
decl_stmt|;
if|if
condition|(
name|header
condition|)
block|{
name|printf
argument_list|(
literal|"\nFeature                      "
literal|"Support  Enabled   Value\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Host Protected Area (HPA)      "
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|support
operator|.
name|command1
operator|&
name|ATA_SUPPORT_PROTECTED
condition|)
block|{
name|u_int64_t
name|lba
init|=
name|lbasize48
condition|?
name|lbasize48
else|:
name|lbasize
decl_stmt|;
name|printf
argument_list|(
literal|"yes      %s     %ju/%ju\n"
argument_list|,
operator|(
name|hpasize
operator|>
name|lba
operator|)
condition|?
literal|"yes"
else|:
literal|"no "
argument_list|,
name|lba
argument_list|,
name|hpasize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"HPA - Security                 "
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|support
operator|.
name|command1
operator|&
name|ATA_SUPPORT_MAXSECURITY
condition|)
name|printf
argument_list|(
literal|"yes\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"no\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"no\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|atasata
parameter_list|(
name|struct
name|ata_params
modifier|*
name|parm
parameter_list|)
block|{
if|if
condition|(
name|parm
operator|->
name|satacapabilities
operator|!=
literal|0xffff
operator|&&
name|parm
operator|->
name|satacapabilities
operator|!=
literal|0x0000
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atacapprint
parameter_list|(
name|struct
name|ata_params
modifier|*
name|parm
parameter_list|)
block|{
name|u_int32_t
name|lbasize
init|=
operator|(
name|u_int32_t
operator|)
name|parm
operator|->
name|lba_size_1
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|parm
operator|->
name|lba_size_2
operator|<<
literal|16
operator|)
decl_stmt|;
name|u_int64_t
name|lbasize48
init|=
operator|(
operator|(
name|u_int64_t
operator|)
name|parm
operator|->
name|lba_size48_1
operator|)
operator||
operator|(
operator|(
name|u_int64_t
operator|)
name|parm
operator|->
name|lba_size48_2
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int64_t
operator|)
name|parm
operator|->
name|lba_size48_3
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|u_int64_t
operator|)
name|parm
operator|->
name|lba_size48_4
operator|<<
literal|48
operator|)
decl_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"protocol              "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ATA/ATAPI-%d"
argument_list|,
name|ata_version
argument_list|(
name|parm
operator|->
name|version_major
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|satacapabilities
operator|&&
name|parm
operator|->
name|satacapabilities
operator|!=
literal|0xffff
condition|)
block|{
if|if
condition|(
name|parm
operator|->
name|satacapabilities
operator|&
name|ATA_SATA_GEN3
condition|)
name|printf
argument_list|(
literal|" SATA 3.x\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parm
operator|->
name|satacapabilities
operator|&
name|ATA_SATA_GEN2
condition|)
name|printf
argument_list|(
literal|" SATA 2.x\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parm
operator|->
name|satacapabilities
operator|&
name|ATA_SATA_GEN1
condition|)
name|printf
argument_list|(
literal|" SATA 1.x\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" SATA\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"device model          %.40s\n"
argument_list|,
name|parm
operator|->
name|model
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"firmware revision     %.8s\n"
argument_list|,
name|parm
operator|->
name|revision
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"serial number         %.20s\n"
argument_list|,
name|parm
operator|->
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|enabled
operator|.
name|extension
operator|&
name|ATA_SUPPORT_64BITWWN
condition|)
block|{
name|printf
argument_list|(
literal|"WWN                   %04x%04x%04x%04x\n"
argument_list|,
name|parm
operator|->
name|wwn
index|[
literal|0
index|]
argument_list|,
name|parm
operator|->
name|wwn
index|[
literal|1
index|]
argument_list|,
name|parm
operator|->
name|wwn
index|[
literal|2
index|]
argument_list|,
name|parm
operator|->
name|wwn
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parm
operator|->
name|enabled
operator|.
name|extension
operator|&
name|ATA_SUPPORT_MEDIASN
condition|)
block|{
name|printf
argument_list|(
literal|"media serial number   %.30s\n"
argument_list|,
name|parm
operator|->
name|media_serial
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"cylinders             %d\n"
argument_list|,
name|parm
operator|->
name|cylinders
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"heads                 %d\n"
argument_list|,
name|parm
operator|->
name|heads
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sectors/track         %d\n"
argument_list|,
name|parm
operator|->
name|sectors
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sector size           logical %u, physical %lu, offset %lu\n"
argument_list|,
name|ata_logical_sector_size
argument_list|(
name|parm
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ata_physical_sector_size
argument_list|(
name|parm
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ata_logical_sector_offset
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|config
operator|==
name|ATA_PROTO_CFA
operator|||
operator|(
name|parm
operator|->
name|support
operator|.
name|command2
operator|&
name|ATA_SUPPORT_CFA
operator|)
condition|)
name|printf
argument_list|(
literal|"CFA supported\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"LBA%ssupported         "
argument_list|,
name|parm
operator|->
name|capabilities1
operator|&
name|ATA_SUPPORT_LBA
condition|?
literal|" "
else|:
literal|" not "
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbasize
condition|)
name|printf
argument_list|(
literal|"%d sectors\n"
argument_list|,
name|lbasize
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"LBA48%ssupported       "
argument_list|,
name|parm
operator|->
name|support
operator|.
name|command2
operator|&
name|ATA_SUPPORT_ADDRESS48
condition|?
literal|" "
else|:
literal|" not "
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbasize48
condition|)
name|printf
argument_list|(
literal|"%ju sectors\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lbasize48
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PIO supported         PIO"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ata_max_pmode
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|ATA_PIO4
case|:
name|printf
argument_list|(
literal|"4"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATA_PIO3
case|:
name|printf
argument_list|(
literal|"3"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATA_PIO2
case|:
name|printf
argument_list|(
literal|"2"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATA_PIO1
case|:
name|printf
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|parm
operator|->
name|capabilities1
operator|&
name|ATA_SUPPORT_IORDY
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" w/o IORDY"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DMA%ssupported         "
argument_list|,
name|parm
operator|->
name|capabilities1
operator|&
name|ATA_SUPPORT_DMA
condition|?
literal|" "
else|:
literal|" not "
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|capabilities1
operator|&
name|ATA_SUPPORT_DMA
condition|)
block|{
if|if
condition|(
name|parm
operator|->
name|mwdmamodes
operator|&
literal|0xff
condition|)
block|{
name|printf
argument_list|(
literal|"WDMA"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|mwdmamodes
operator|&
literal|0x04
condition|)
name|printf
argument_list|(
literal|"2"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parm
operator|->
name|mwdmamodes
operator|&
literal|0x02
condition|)
name|printf
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parm
operator|->
name|mwdmamodes
operator|&
literal|0x01
condition|)
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|parm
operator|->
name|atavalid
operator|&
name|ATA_FLAG_88
operator|)
operator|&&
operator|(
name|parm
operator|->
name|udmamodes
operator|&
literal|0xff
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"UDMA"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|udmamodes
operator|&
literal|0x40
condition|)
name|printf
argument_list|(
literal|"6"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parm
operator|->
name|udmamodes
operator|&
literal|0x20
condition|)
name|printf
argument_list|(
literal|"5"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parm
operator|->
name|udmamodes
operator|&
literal|0x10
condition|)
name|printf
argument_list|(
literal|"4"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parm
operator|->
name|udmamodes
operator|&
literal|0x08
condition|)
name|printf
argument_list|(
literal|"3"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parm
operator|->
name|udmamodes
operator|&
literal|0x04
condition|)
name|printf
argument_list|(
literal|"2"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parm
operator|->
name|udmamodes
operator|&
literal|0x02
condition|)
name|printf
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parm
operator|->
name|udmamodes
operator|&
literal|0x01
condition|)
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|media_rotation_rate
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"media RPM             non-rotating\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm
operator|->
name|media_rotation_rate
operator|>=
literal|0x0401
operator|&&
name|parm
operator|->
name|media_rotation_rate
operator|<=
literal|0xFFFE
condition|)
block|{
name|printf
argument_list|(
literal|"media RPM             %d\n"
argument_list|,
name|parm
operator|->
name|media_rotation_rate
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nFeature                      "
literal|"Support  Enabled   Value           Vendor\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"read ahead                     %s	%s\n"
argument_list|,
name|parm
operator|->
name|support
operator|.
name|command1
operator|&
name|ATA_SUPPORT_LOOKAHEAD
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|parm
operator|->
name|enabled
operator|.
name|command1
operator|&
name|ATA_SUPPORT_LOOKAHEAD
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"write cache                    %s	%s\n"
argument_list|,
name|parm
operator|->
name|support
operator|.
name|command1
operator|&
name|ATA_SUPPORT_WRITECACHE
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|parm
operator|->
name|enabled
operator|.
name|command1
operator|&
name|ATA_SUPPORT_WRITECACHE
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"flush cache                    %s	%s\n"
argument_list|,
name|parm
operator|->
name|support
operator|.
name|command2
operator|&
name|ATA_SUPPORT_FLUSHCACHE
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|parm
operator|->
name|enabled
operator|.
name|command2
operator|&
name|ATA_SUPPORT_FLUSHCACHE
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"overlap                        %s\n"
argument_list|,
name|parm
operator|->
name|capabilities1
operator|&
name|ATA_SUPPORT_OVERLAP
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Tagged Command Queuing (TCQ)   %s	%s"
argument_list|,
name|parm
operator|->
name|support
operator|.
name|command2
operator|&
name|ATA_SUPPORT_QUEUED
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|parm
operator|->
name|enabled
operator|.
name|command2
operator|&
name|ATA_SUPPORT_QUEUED
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|support
operator|.
name|command2
operator|&
name|ATA_SUPPORT_QUEUED
condition|)
block|{
name|printf
argument_list|(
literal|"	%d tags\n"
argument_list|,
name|ATA_QUEUE_LEN
argument_list|(
name|parm
operator|->
name|queue
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Native Command Queuing (NCQ)   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|satacapabilities
operator|!=
literal|0xffff
operator|&&
operator|(
name|parm
operator|->
name|satacapabilities
operator|&
name|ATA_SUPPORT_NCQ
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"yes		%d tags\n"
argument_list|,
name|ATA_QUEUE_LEN
argument_list|(
name|parm
operator|->
name|queue
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"no\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"NCQ Queue Management           %s\n"
argument_list|,
name|atasata
argument_list|(
name|parm
argument_list|)
operator|&&
name|parm
operator|->
name|satacapabilities2
operator|&
name|ATA_SUPPORT_NCQ_QMANAGEMENT
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"NCQ Streaming                  %s\n"
argument_list|,
name|atasata
argument_list|(
name|parm
argument_list|)
operator|&&
name|parm
operator|->
name|satacapabilities2
operator|&
name|ATA_SUPPORT_NCQ_STREAM
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Receive& Send FPDMA Queued    %s\n"
argument_list|,
name|atasata
argument_list|(
name|parm
argument_list|)
operator|&&
name|parm
operator|->
name|satacapabilities2
operator|&
name|ATA_SUPPORT_RCVSND_FPDMA_QUEUED
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SMART                          %s	%s\n"
argument_list|,
name|parm
operator|->
name|support
operator|.
name|command1
operator|&
name|ATA_SUPPORT_SMART
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|parm
operator|->
name|enabled
operator|.
name|command1
operator|&
name|ATA_SUPPORT_SMART
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"microcode download             %s	%s\n"
argument_list|,
name|parm
operator|->
name|support
operator|.
name|command2
operator|&
name|ATA_SUPPORT_MICROCODE
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|parm
operator|->
name|enabled
operator|.
name|command2
operator|&
name|ATA_SUPPORT_MICROCODE
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"security                       %s	%s\n"
argument_list|,
name|parm
operator|->
name|support
operator|.
name|command1
operator|&
name|ATA_SUPPORT_SECURITY
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|parm
operator|->
name|enabled
operator|.
name|command1
operator|&
name|ATA_SUPPORT_SECURITY
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"power management               %s	%s\n"
argument_list|,
name|parm
operator|->
name|support
operator|.
name|command1
operator|&
name|ATA_SUPPORT_POWERMGT
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|parm
operator|->
name|enabled
operator|.
name|command1
operator|&
name|ATA_SUPPORT_POWERMGT
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"advanced power management      %s	%s"
argument_list|,
name|parm
operator|->
name|support
operator|.
name|command2
operator|&
name|ATA_SUPPORT_APM
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|parm
operator|->
name|enabled
operator|.
name|command2
operator|&
name|ATA_SUPPORT_APM
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|support
operator|.
name|command2
operator|&
name|ATA_SUPPORT_APM
condition|)
block|{
name|printf
argument_list|(
literal|"	%d/0x%02X\n"
argument_list|,
name|parm
operator|->
name|apm_value
operator|&
literal|0xff
argument_list|,
name|parm
operator|->
name|apm_value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"automatic acoustic management  %s	%s"
argument_list|,
name|parm
operator|->
name|support
operator|.
name|command2
operator|&
name|ATA_SUPPORT_AUTOACOUSTIC
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|parm
operator|->
name|enabled
operator|.
name|command2
operator|&
name|ATA_SUPPORT_AUTOACOUSTIC
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|support
operator|.
name|command2
operator|&
name|ATA_SUPPORT_AUTOACOUSTIC
condition|)
block|{
name|printf
argument_list|(
literal|"	%d/0x%02X	%d/0x%02X\n"
argument_list|,
name|ATA_ACOUSTIC_CURRENT
argument_list|(
name|parm
operator|->
name|acoustic
argument_list|)
argument_list|,
name|ATA_ACOUSTIC_CURRENT
argument_list|(
name|parm
operator|->
name|acoustic
argument_list|)
argument_list|,
name|ATA_ACOUSTIC_VENDOR
argument_list|(
name|parm
operator|->
name|acoustic
argument_list|)
argument_list|,
name|ATA_ACOUSTIC_VENDOR
argument_list|(
name|parm
operator|->
name|acoustic
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"media status notification      %s	%s\n"
argument_list|,
name|parm
operator|->
name|support
operator|.
name|command2
operator|&
name|ATA_SUPPORT_NOTIFY
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|parm
operator|->
name|enabled
operator|.
name|command2
operator|&
name|ATA_SUPPORT_NOTIFY
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"power-up in Standby            %s	%s\n"
argument_list|,
name|parm
operator|->
name|support
operator|.
name|command2
operator|&
name|ATA_SUPPORT_STANDBY
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|parm
operator|->
name|enabled
operator|.
name|command2
operator|&
name|ATA_SUPPORT_STANDBY
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"write-read-verify              %s	%s"
argument_list|,
name|parm
operator|->
name|support2
operator|&
name|ATA_SUPPORT_WRITEREADVERIFY
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|parm
operator|->
name|enabled2
operator|&
name|ATA_SUPPORT_WRITEREADVERIFY
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|support2
operator|&
name|ATA_SUPPORT_WRITEREADVERIFY
condition|)
block|{
name|printf
argument_list|(
literal|"	%d/0x%x\n"
argument_list|,
name|parm
operator|->
name|wrv_mode
argument_list|,
name|parm
operator|->
name|wrv_mode
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unload                         %s	%s\n"
argument_list|,
name|parm
operator|->
name|support
operator|.
name|extension
operator|&
name|ATA_SUPPORT_UNLOAD
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|parm
operator|->
name|enabled
operator|.
name|extension
operator|&
name|ATA_SUPPORT_UNLOAD
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"general purpose logging        %s	%s\n"
argument_list|,
name|parm
operator|->
name|support
operator|.
name|extension
operator|&
name|ATA_SUPPORT_GENLOG
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|parm
operator|->
name|enabled
operator|.
name|extension
operator|&
name|ATA_SUPPORT_GENLOG
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"free-fall                      %s	%s\n"
argument_list|,
name|parm
operator|->
name|support2
operator|&
name|ATA_SUPPORT_FREEFALL
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|parm
operator|->
name|enabled2
operator|&
name|ATA_SUPPORT_FREEFALL
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Data Set Management (DSM/TRIM) "
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|support_dsm
operator|&
name|ATA_SUPPORT_DSM_TRIM
condition|)
block|{
name|printf
argument_list|(
literal|"yes\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DSM - max 512byte blocks       "
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|max_dsm_blocks
operator|==
literal|0x00
condition|)
name|printf
argument_list|(
literal|"yes              not specified\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"yes              %d\n"
argument_list|,
name|parm
operator|->
name|max_dsm_blocks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DSM - deterministic read       "
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|support3
operator|&
name|ATA_SUPPORT_DRAT
condition|)
block|{
if|if
condition|(
name|parm
operator|->
name|support3
operator|&
name|ATA_SUPPORT_RZAT
condition|)
name|printf
argument_list|(
literal|"yes              zeroed\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"yes              any value\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"no\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"no\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|scsi_cam_pass_16_send
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|struct
name|ata_pass_16
modifier|*
name|ata_pass_16
decl_stmt|;
name|struct
name|ata_cmd
name|ata_cmd
decl_stmt|;
name|ata_pass_16
operator|=
operator|(
expr|struct
name|ata_pass_16
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|ata_cmd
operator|.
name|command
operator|=
name|ata_pass_16
operator|->
name|command
expr_stmt|;
name|ata_cmd
operator|.
name|control
operator|=
name|ata_pass_16
operator|->
name|control
expr_stmt|;
name|ata_cmd
operator|.
name|features
operator|=
name|ata_pass_16
operator|->
name|features
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|warnx
argument_list|(
literal|"sending ATA %s via pass_16 with timeout of %u msecs"
argument_list|,
name|ata_op_string
argument_list|(
operator|&
name|ata_cmd
argument_list|)
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|ccb_h
operator|.
name|timeout
argument_list|)
expr_stmt|;
block|}
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|quiet
operator|!=
literal|1
operator|||
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|warn
argument_list|(
literal|"error sending ATA %s via pass_16"
argument_list|,
name|ata_op_string
argument_list|(
operator|&
name|ata_cmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|ata_pass_16
operator|->
name|flags
operator|&
name|AP_FLAG_CHK_COND
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|quiet
operator|!=
literal|1
operator|||
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|warnx
argument_list|(
literal|"ATA %s via pass_16 failed"
argument_list|,
name|ata_op_string
argument_list|(
operator|&
name|ata_cmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_cam_send
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|warnx
argument_list|(
literal|"sending ATA %s with timeout of %u msecs"
argument_list|,
name|ata_op_string
argument_list|(
operator|&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|)
argument_list|)
argument_list|,
name|ccb
operator|->
name|ataio
operator|.
name|ccb_h
operator|.
name|timeout
argument_list|)
expr_stmt|;
block|}
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|quiet
operator|!=
literal|1
operator|||
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|warn
argument_list|(
literal|"error sending ATA %s"
argument_list|,
name|ata_op_string
argument_list|(
operator|&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|quiet
operator|!=
literal|1
operator|||
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|warnx
argument_list|(
literal|"ATA %s failed: %d"
argument_list|,
name|ata_op_string
argument_list|(
operator|&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|)
argument_list|)
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_do_pass_16
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|retries
parameter_list|,
name|u_int32_t
name|flags
parameter_list|,
name|u_int8_t
name|protocol
parameter_list|,
name|u_int8_t
name|ata_flags
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|command
parameter_list|,
name|u_int8_t
name|features
parameter_list|,
name|u_int64_t
name|lba
parameter_list|,
name|u_int8_t
name|sector_count
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int16_t
name|dxfer_len
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
if|if
condition|(
name|data_ptr
operator|!=
name|NULL
condition|)
block|{
name|ata_flags
operator||=
name|AP_FLAG_BYT_BLOK_BYTES
operator||
name|AP_FLAG_TLEN_SECT_CNT
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CAM_DIR_OUT
condition|)
name|ata_flags
operator||=
name|AP_FLAG_TDIR_TO_DEV
expr_stmt|;
else|else
name|ata_flags
operator||=
name|AP_FLAG_TDIR_FROM_DEV
expr_stmt|;
block|}
else|else
block|{
name|ata_flags
operator||=
name|AP_FLAG_TLEN_NO_DATA
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_ata_pass_16
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|retries
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|,
name|tag_action
argument_list|,
name|protocol
argument_list|,
name|ata_flags
argument_list|,
name|features
argument_list|,
name|sector_count
argument_list|,
name|lba
argument_list|,
name|command
argument_list|,
comment|/*control*/
literal|0
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
return|return
name|scsi_cam_pass_16_send
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|quiet
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_try_pass_16
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
block|{
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
if|if
condition|(
name|get_cpi
argument_list|(
name|device
argument_list|,
operator|&
name|cpi
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't get CPI"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cpi
operator|.
name|protocol
operator|==
name|PROTO_SCSI
condition|)
block|{
comment|/* possibly compatible with pass_16 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* likely not compatible with pass_16 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_do_28bit_cmd
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|retries
parameter_list|,
name|u_int32_t
name|flags
parameter_list|,
name|u_int8_t
name|protocol
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|command
parameter_list|,
name|u_int8_t
name|features
parameter_list|,
name|u_int32_t
name|lba
parameter_list|,
name|u_int8_t
name|sector_count
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int16_t
name|dxfer_len
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
switch|switch
condition|(
name|ata_try_pass_16
argument_list|(
name|device
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|1
case|:
comment|/* Try using SCSI Passthrough */
return|return
name|ata_do_pass_16
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retries
argument_list|,
name|flags
argument_list|,
name|protocol
argument_list|,
literal|0
argument_list|,
name|tag_action
argument_list|,
name|command
argument_list|,
name|features
argument_list|,
name|lba
argument_list|,
name|sector_count
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|timeout
argument_list|,
name|quiet
argument_list|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_ataio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|cam_fill_ataio
argument_list|(
operator|&
name|ccb
operator|->
name|ataio
argument_list|,
name|retries
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|ata_28bit_cmd
argument_list|(
operator|&
name|ccb
operator|->
name|ataio
argument_list|,
name|command
argument_list|,
name|features
argument_list|,
name|lba
argument_list|,
name|sector_count
argument_list|)
expr_stmt|;
return|return
name|ata_cam_send
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|quiet
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_do_cmd
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|retries
parameter_list|,
name|u_int32_t
name|flags
parameter_list|,
name|u_int8_t
name|protocol
parameter_list|,
name|u_int8_t
name|ata_flags
parameter_list|,
name|u_int8_t
name|tag_action
parameter_list|,
name|u_int8_t
name|command
parameter_list|,
name|u_int8_t
name|features
parameter_list|,
name|u_int64_t
name|lba
parameter_list|,
name|u_int8_t
name|sector_count
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int16_t
name|dxfer_len
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|force48bit
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|ata_try_pass_16
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|retval
operator|==
literal|1
condition|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Try using SCSI Passthrough */
name|error
operator|=
name|ata_do_pass_16
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retries
argument_list|,
name|flags
argument_list|,
name|protocol
argument_list|,
name|ata_flags
argument_list|,
name|tag_action
argument_list|,
name|command
argument_list|,
name|features
argument_list|,
name|lba
argument_list|,
name|sector_count
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ata_flags
operator|&
name|AP_FLAG_CHK_COND
condition|)
block|{
comment|/* Decode ata_res from sense data */
name|struct
name|ata_res_pass16
modifier|*
name|res_pass16
decl_stmt|;
name|struct
name|ata_res
modifier|*
name|res
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
comment|/* sense_data is 4 byte aligned */
name|ptr
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|res_pass16
argument_list|)
operator|/
literal|2
condition|;
name|i
operator|++
control|)
name|ptr
index|[
name|i
index|]
operator|=
name|le16toh
argument_list|(
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* sense_data is 4 byte aligned */
name|res_pass16
operator|=
operator|(
expr|struct
name|ata_res_pass16
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|res
operator|=
operator|&
name|ccb
operator|->
name|ataio
operator|.
name|res
expr_stmt|;
name|res
operator|->
name|flags
operator|=
name|res_pass16
operator|->
name|flags
expr_stmt|;
name|res
operator|->
name|status
operator|=
name|res_pass16
operator|->
name|status
expr_stmt|;
name|res
operator|->
name|error
operator|=
name|res_pass16
operator|->
name|error
expr_stmt|;
name|res
operator|->
name|lba_low
operator|=
name|res_pass16
operator|->
name|lba_low
expr_stmt|;
name|res
operator|->
name|lba_mid
operator|=
name|res_pass16
operator|->
name|lba_mid
expr_stmt|;
name|res
operator|->
name|lba_high
operator|=
name|res_pass16
operator|->
name|lba_high
expr_stmt|;
name|res
operator|->
name|device
operator|=
name|res_pass16
operator|->
name|device
expr_stmt|;
name|res
operator|->
name|lba_low_exp
operator|=
name|res_pass16
operator|->
name|lba_low_exp
expr_stmt|;
name|res
operator|->
name|lba_mid_exp
operator|=
name|res_pass16
operator|->
name|lba_mid_exp
expr_stmt|;
name|res
operator|->
name|lba_high_exp
operator|=
name|res_pass16
operator|->
name|lba_high_exp
expr_stmt|;
name|res
operator|->
name|sector_count
operator|=
name|res_pass16
operator|->
name|sector_count
expr_stmt|;
name|res
operator|->
name|sector_count_exp
operator|=
name|res_pass16
operator|->
name|sector_count_exp
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_ataio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|cam_fill_ataio
argument_list|(
operator|&
name|ccb
operator|->
name|ataio
argument_list|,
name|retries
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|,
name|tag_action
argument_list|,
name|data_ptr
argument_list|,
name|dxfer_len
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|force48bit
operator|||
name|lba
operator|>
name|ATA_MAX_28BIT_LBA
condition|)
name|ata_48bit_cmd
argument_list|(
operator|&
name|ccb
operator|->
name|ataio
argument_list|,
name|command
argument_list|,
name|features
argument_list|,
name|lba
argument_list|,
name|sector_count
argument_list|)
expr_stmt|;
else|else
name|ata_28bit_cmd
argument_list|(
operator|&
name|ccb
operator|->
name|ataio
argument_list|,
name|command
argument_list|,
name|features
argument_list|,
name|lba
argument_list|,
name|sector_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ata_flags
operator|&
name|AP_FLAG_CHK_COND
condition|)
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator||=
name|CAM_ATAIO_NEEDRESULT
expr_stmt|;
return|return
name|ata_cam_send
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_data
parameter_list|(
name|uint16_t
modifier|*
name|ptr
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" %3d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%04hx "
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|==
literal|7
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|%
literal|8
operator|)
operator|!=
literal|7
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|atahpa_proc_resp
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|is48bit
parameter_list|,
name|u_int64_t
modifier|*
name|hpasize
parameter_list|)
block|{
name|struct
name|ata_res
modifier|*
name|res
decl_stmt|;
name|res
operator|=
operator|&
name|ccb
operator|->
name|ataio
operator|.
name|res
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|status
operator|&
name|ATA_STATUS_ERROR
condition|)
block|{
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"error = 0x%02x, sector_count = 0x%04x, "
literal|"device = 0x%02x, status = 0x%02x\n"
argument_list|,
name|res
operator|->
name|error
argument_list|,
name|res
operator|->
name|sector_count
argument_list|,
name|res
operator|->
name|device
argument_list|,
name|res
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|error
operator|&
name|ATA_ERROR_ID_NOT_FOUND
condition|)
block|{
name|warnx
argument_list|(
literal|"Max address has already been set since "
literal|"last power-on or hardware reset"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%d: Raw native max data:\n"
argument_list|,
name|device
operator|->
name|device_name
argument_list|,
name|device
operator|->
name|dev_unit_num
argument_list|)
expr_stmt|;
comment|/* res is 4 byte aligned */
name|dump_data
argument_list|(
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|res
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_res
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"error = 0x%02x, sector_count = 0x%04x, device = 0x%02x, "
literal|"status = 0x%02x\n"
argument_list|,
name|res
operator|->
name|error
argument_list|,
name|res
operator|->
name|sector_count
argument_list|,
name|res
operator|->
name|device
argument_list|,
name|res
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hpasize
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|is48bit
condition|)
block|{
operator|*
name|hpasize
operator|=
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
operator|(
name|res
operator|->
name|lba_high_exp
operator|<<
literal|16
operator|)
operator||
operator|(
name|res
operator|->
name|lba_mid_exp
operator|<<
literal|8
operator|)
operator||
name|res
operator|->
name|lba_low_exp
argument_list|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|res
operator|->
name|lba_high
operator|<<
literal|16
operator|)
operator||
operator|(
name|res
operator|->
name|lba_mid
operator|<<
literal|8
operator|)
operator||
name|res
operator|->
name|lba_low
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|hpasize
operator|=
operator|(
operator|(
operator|(
name|res
operator|->
name|device
operator|&
literal|0x0f
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|res
operator|->
name|lba_high
operator|<<
literal|16
operator|)
operator||
operator|(
name|res
operator|->
name|lba_mid
operator|<<
literal|8
operator|)
operator||
name|res
operator|->
name|lba_low
operator|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_read_native_max
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|ata_params
modifier|*
name|parm
parameter_list|,
name|u_int64_t
modifier|*
name|hpasize
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_int
name|cmd
decl_stmt|,
name|is48bit
decl_stmt|;
name|u_int8_t
name|protocol
decl_stmt|;
name|is48bit
operator|=
name|parm
operator|->
name|support
operator|.
name|command2
operator|&
name|ATA_SUPPORT_ADDRESS48
expr_stmt|;
name|protocol
operator|=
name|AP_PROTO_NON_DATA
expr_stmt|;
if|if
condition|(
name|is48bit
condition|)
block|{
name|cmd
operator|=
name|ATA_READ_NATIVE_MAX_ADDRESS48
expr_stmt|;
name|protocol
operator||=
name|AP_EXTEND
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
name|ATA_READ_NATIVE_MAX_ADDRESS
expr_stmt|;
block|}
name|error
operator|=
name|ata_do_cmd
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
comment|/*protocol*/
name|protocol
argument_list|,
comment|/*ata_flags*/
name|AP_FLAG_CHK_COND
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*command*/
name|cmd
argument_list|,
comment|/*features*/
literal|0
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*sector_count*/
literal|0
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|timeout
condition|?
name|timeout
else|:
literal|1000
argument_list|,
name|is48bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|atahpa_proc_resp
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|is48bit
argument_list|,
name|hpasize
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atahpa_set_max
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|is48bit
parameter_list|,
name|u_int64_t
name|maxsize
parameter_list|,
name|int
name|persist
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_int
name|cmd
decl_stmt|;
name|u_int8_t
name|protocol
decl_stmt|;
name|protocol
operator|=
name|AP_PROTO_NON_DATA
expr_stmt|;
if|if
condition|(
name|is48bit
condition|)
block|{
name|cmd
operator|=
name|ATA_SET_MAX_ADDRESS48
expr_stmt|;
name|protocol
operator||=
name|AP_EXTEND
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
name|ATA_SET_MAX_ADDRESS
expr_stmt|;
block|}
comment|/* lba's are zero indexed so the max lba is requested max - 1 */
if|if
condition|(
name|maxsize
condition|)
name|maxsize
operator|--
expr_stmt|;
name|error
operator|=
name|ata_do_cmd
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
comment|/*protocol*/
name|protocol
argument_list|,
comment|/*ata_flags*/
name|AP_FLAG_CHK_COND
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*command*/
name|cmd
argument_list|,
comment|/*features*/
name|ATA_HPA_FEAT_MAX_ADDR
argument_list|,
comment|/*lba*/
name|maxsize
argument_list|,
comment|/*sector_count*/
name|persist
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|timeout
condition|?
name|timeout
else|:
literal|1000
argument_list|,
name|is48bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|atahpa_proc_resp
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|is48bit
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atahpa_password
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|is48bit
parameter_list|,
name|struct
name|ata_set_max_pwd
modifier|*
name|pwd
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_int
name|cmd
decl_stmt|;
name|u_int8_t
name|protocol
decl_stmt|;
name|protocol
operator|=
name|AP_PROTO_PIO_OUT
expr_stmt|;
name|cmd
operator|=
operator|(
name|is48bit
operator|)
condition|?
name|ATA_SET_MAX_ADDRESS48
else|:
name|ATA_SET_MAX_ADDRESS
expr_stmt|;
name|error
operator|=
name|ata_do_cmd
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
argument_list|,
comment|/*protocol*/
name|protocol
argument_list|,
comment|/*ata_flags*/
name|AP_FLAG_CHK_COND
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*command*/
name|cmd
argument_list|,
comment|/*features*/
name|ATA_HPA_FEAT_SET_PWD
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*sector_count*/
literal|0
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|pwd
argument_list|,
comment|/*dxfer_len*/
sizeof|sizeof
argument_list|(
expr|struct
name|ata_set_max_pwd
argument_list|)
argument_list|,
name|timeout
condition|?
name|timeout
else|:
literal|1000
argument_list|,
name|is48bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|atahpa_proc_resp
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|is48bit
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atahpa_lock
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|is48bit
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_int
name|cmd
decl_stmt|;
name|u_int8_t
name|protocol
decl_stmt|;
name|protocol
operator|=
name|AP_PROTO_NON_DATA
expr_stmt|;
name|cmd
operator|=
operator|(
name|is48bit
operator|)
condition|?
name|ATA_SET_MAX_ADDRESS48
else|:
name|ATA_SET_MAX_ADDRESS
expr_stmt|;
name|error
operator|=
name|ata_do_cmd
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
comment|/*protocol*/
name|protocol
argument_list|,
comment|/*ata_flags*/
name|AP_FLAG_CHK_COND
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*command*/
name|cmd
argument_list|,
comment|/*features*/
name|ATA_HPA_FEAT_LOCK
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*sector_count*/
literal|0
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|timeout
condition|?
name|timeout
else|:
literal|1000
argument_list|,
name|is48bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|atahpa_proc_resp
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|is48bit
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atahpa_unlock
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|is48bit
parameter_list|,
name|struct
name|ata_set_max_pwd
modifier|*
name|pwd
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_int
name|cmd
decl_stmt|;
name|u_int8_t
name|protocol
decl_stmt|;
name|protocol
operator|=
name|AP_PROTO_PIO_OUT
expr_stmt|;
name|cmd
operator|=
operator|(
name|is48bit
operator|)
condition|?
name|ATA_SET_MAX_ADDRESS48
else|:
name|ATA_SET_MAX_ADDRESS
expr_stmt|;
name|error
operator|=
name|ata_do_cmd
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
argument_list|,
comment|/*protocol*/
name|protocol
argument_list|,
comment|/*ata_flags*/
name|AP_FLAG_CHK_COND
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*command*/
name|cmd
argument_list|,
comment|/*features*/
name|ATA_HPA_FEAT_UNLOCK
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*sector_count*/
literal|0
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|pwd
argument_list|,
comment|/*dxfer_len*/
sizeof|sizeof
argument_list|(
expr|struct
name|ata_set_max_pwd
argument_list|)
argument_list|,
name|timeout
condition|?
name|timeout
else|:
literal|1000
argument_list|,
name|is48bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|atahpa_proc_resp
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|is48bit
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atahpa_freeze_lock
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|is48bit
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_int
name|cmd
decl_stmt|;
name|u_int8_t
name|protocol
decl_stmt|;
name|protocol
operator|=
name|AP_PROTO_NON_DATA
expr_stmt|;
name|cmd
operator|=
operator|(
name|is48bit
operator|)
condition|?
name|ATA_SET_MAX_ADDRESS48
else|:
name|ATA_SET_MAX_ADDRESS
expr_stmt|;
name|error
operator|=
name|ata_do_cmd
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
comment|/*protocol*/
name|protocol
argument_list|,
comment|/*ata_flags*/
name|AP_FLAG_CHK_COND
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*command*/
name|cmd
argument_list|,
comment|/*features*/
name|ATA_HPA_FEAT_FREEZE
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*sector_count*/
literal|0
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
name|timeout
condition|?
name|timeout
else|:
literal|1000
argument_list|,
name|is48bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|atahpa_proc_resp
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|is48bit
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ata_do_identify
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|struct
name|ata_params
modifier|*
modifier|*
name|ident_bufp
parameter_list|)
block|{
name|struct
name|ata_params
modifier|*
name|ident_buf
decl_stmt|;
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|struct
name|ccb_getdev
name|cgd
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|int16_t
modifier|*
name|ptr
decl_stmt|;
name|u_int8_t
name|command
decl_stmt|,
name|retry_command
decl_stmt|;
if|if
condition|(
name|get_cpi
argument_list|(
name|device
argument_list|,
operator|&
name|cpi
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't get CPI"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Neither PROTO_ATAPI or PROTO_SATAPM are used in cpi.protocol */
if|if
condition|(
name|cpi
operator|.
name|protocol
operator|==
name|PROTO_ATA
condition|)
block|{
if|if
condition|(
name|get_cgd
argument_list|(
name|device
argument_list|,
operator|&
name|cgd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't get CGD"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|command
operator|=
operator|(
name|cgd
operator|.
name|protocol
operator|==
name|PROTO_ATA
operator|)
condition|?
name|ATA_ATA_IDENTIFY
else|:
name|ATA_ATAPI_IDENTIFY
expr_stmt|;
name|retry_command
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* We don't know which for sure so try both */
name|command
operator|=
name|ATA_ATA_IDENTIFY
expr_stmt|;
name|retry_command
operator|=
name|ATA_ATAPI_IDENTIFY
expr_stmt|;
block|}
name|ptr
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't calloc memory for identify\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|error
operator|=
name|ata_do_28bit_cmd
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
comment|/*protocol*/
name|AP_PROTO_PIO_IN
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*command*/
name|command
argument_list|,
comment|/*features*/
literal|0
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*sector_count*/
operator|(
name|u_int8_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|ptr
argument_list|,
comment|/*dxfer_len*/
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|30
operator|*
literal|1000
argument_list|,
comment|/*quiet*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|retry_command
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|error
operator|=
name|ata_do_28bit_cmd
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_IN
argument_list|,
comment|/*protocol*/
name|AP_PROTO_PIO_IN
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*command*/
name|retry_command
argument_list|,
comment|/*features*/
literal|0
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*sector_count*/
operator|(
name|u_int8_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|ptr
argument_list|,
comment|/*dxfer_len*/
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|30
operator|*
literal|1000
argument_list|,
comment|/*quiet*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|error
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|ptr
index|[
name|i
index|]
operator|=
name|le16toh
argument_list|(
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%d: Raw identify data:\n"
argument_list|,
name|device
operator|->
name|device_name
argument_list|,
name|device
operator|->
name|dev_unit_num
argument_list|)
expr_stmt|;
name|dump_data
argument_list|(
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* check for invalid (all zero) response */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid identify response detected"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ident_buf
operator|=
operator|(
expr|struct
name|ata_params
operator|*
operator|)
name|ptr
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ident_buf
operator|->
name|model
argument_list|,
literal|"FX"
argument_list|,
literal|2
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|ident_buf
operator|->
name|model
argument_list|,
literal|"NEC"
argument_list|,
literal|3
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|ident_buf
operator|->
name|model
argument_list|,
literal|"Pioneer"
argument_list|,
literal|7
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|ident_buf
operator|->
name|model
argument_list|,
literal|"SHARP"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|ata_bswap
argument_list|(
name|ident_buf
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|ident_buf
operator|->
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|ata_bswap
argument_list|(
name|ident_buf
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|ident_buf
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|ata_bswap
argument_list|(
name|ident_buf
operator|->
name|serial
argument_list|,
sizeof|sizeof
argument_list|(
name|ident_buf
operator|->
name|serial
argument_list|)
argument_list|)
expr_stmt|;
name|ata_bswap
argument_list|(
name|ident_buf
operator|->
name|media_serial
argument_list|,
sizeof|sizeof
argument_list|(
name|ident_buf
operator|->
name|media_serial
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ata_btrim
argument_list|(
name|ident_buf
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|ident_buf
operator|->
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|ata_bpack
argument_list|(
name|ident_buf
operator|->
name|model
argument_list|,
name|ident_buf
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|ident_buf
operator|->
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|ata_btrim
argument_list|(
name|ident_buf
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|ident_buf
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|ata_bpack
argument_list|(
name|ident_buf
operator|->
name|revision
argument_list|,
name|ident_buf
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|ident_buf
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|ata_btrim
argument_list|(
name|ident_buf
operator|->
name|serial
argument_list|,
sizeof|sizeof
argument_list|(
name|ident_buf
operator|->
name|serial
argument_list|)
argument_list|)
expr_stmt|;
name|ata_bpack
argument_list|(
name|ident_buf
operator|->
name|serial
argument_list|,
name|ident_buf
operator|->
name|serial
argument_list|,
sizeof|sizeof
argument_list|(
name|ident_buf
operator|->
name|serial
argument_list|)
argument_list|)
expr_stmt|;
name|ata_btrim
argument_list|(
name|ident_buf
operator|->
name|media_serial
argument_list|,
sizeof|sizeof
argument_list|(
name|ident_buf
operator|->
name|media_serial
argument_list|)
argument_list|)
expr_stmt|;
name|ata_bpack
argument_list|(
name|ident_buf
operator|->
name|media_serial
argument_list|,
name|ident_buf
operator|->
name|media_serial
argument_list|,
sizeof|sizeof
argument_list|(
name|ident_buf
operator|->
name|media_serial
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ident_bufp
operator|=
name|ident_buf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ataidentify
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ata_params
modifier|*
name|ident_buf
decl_stmt|;
name|u_int64_t
name|hpasize
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't allocate CCB"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ata_do_identify
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|ccb
argument_list|,
operator|&
name|ident_buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ident_buf
operator|->
name|support
operator|.
name|command1
operator|&
name|ATA_SUPPORT_PROTECTED
condition|)
block|{
if|if
condition|(
name|ata_read_native_max
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|ccb
argument_list|,
name|ident_buf
argument_list|,
operator|&
name|hpasize
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|hpasize
operator|=
literal|0
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s%d: "
argument_list|,
name|device
operator|->
name|device_name
argument_list|,
name|device
operator|->
name|dev_unit_num
argument_list|)
expr_stmt|;
name|ata_print_ident
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
name|camxferrate
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|atacapprint
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
name|atahpa_print
argument_list|(
name|ident_buf
argument_list|,
name|hpasize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MINIMALISTIC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_enum
enum|enum
block|{
name|ATA_SECURITY_ACTION_PRINT
block|,
name|ATA_SECURITY_ACTION_FREEZE
block|,
name|ATA_SECURITY_ACTION_UNLOCK
block|,
name|ATA_SECURITY_ACTION_DISABLE
block|,
name|ATA_SECURITY_ACTION_ERASE
block|,
name|ATA_SECURITY_ACTION_ERASE_ENHANCED
block|,
name|ATA_SECURITY_ACTION_SET_PASSWORD
block|}
enum|;
end_enum

begin_function
specifier|static
name|void
name|atasecurity_print_time
parameter_list|(
name|u_int16_t
name|tw
parameter_list|)
block|{
if|if
condition|(
name|tw
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"unspecified"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tw
operator|>=
literal|255
condition|)
name|printf
argument_list|(
literal|"> 508 min"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%i min"
argument_list|,
literal|2
operator|*
name|tw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|atasecurity_erase_timeout_msecs
parameter_list|(
name|u_int16_t
name|timeout
parameter_list|)
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
return|return
literal|2
operator|*
literal|3600
operator|*
literal|1000
return|;
comment|/* default: two hours */
elseif|else
if|if
condition|(
name|timeout
operator|>
literal|255
condition|)
return|return
operator|(
literal|508
operator|+
literal|60
operator|)
operator|*
literal|60
operator|*
literal|1000
return|;
comment|/* spec says> 508 minutes */
return|return
operator|(
operator|(
literal|2
operator|*
name|timeout
operator|)
operator|+
literal|5
operator|)
operator|*
literal|60
operator|*
literal|1000
return|;
comment|/* add a 5min margin */
block|}
end_function

begin_function
specifier|static
name|void
name|atasecurity_notify
parameter_list|(
name|u_int8_t
name|command
parameter_list|,
name|struct
name|ata_security_password
modifier|*
name|pwd
parameter_list|)
block|{
name|struct
name|ata_cmd
name|cmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|command
operator|=
name|command
expr_stmt|;
name|printf
argument_list|(
literal|"Issuing %s"
argument_list|,
name|ata_op_string
argument_list|(
operator|&
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
condition|)
block|{
name|char
name|pass
index|[
sizeof|sizeof
argument_list|(
name|pwd
operator|->
name|password
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
comment|/* pwd->password may not be null terminated */
name|pass
index|[
sizeof|sizeof
argument_list|(
name|pwd
operator|->
name|password
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncpy
argument_list|(
name|pass
argument_list|,
name|pwd
operator|->
name|password
argument_list|,
sizeof|sizeof
argument_list|(
name|pwd
operator|->
name|password
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" password='%s', user='%s'"
argument_list|,
name|pass
argument_list|,
operator|(
name|pwd
operator|->
name|ctrl
operator|&
name|ATA_SECURITY_PASSWORD_MASTER
operator|)
condition|?
literal|"master"
else|:
literal|"user"
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
name|ATA_SECURITY_SET_PASSWORD
condition|)
block|{
name|printf
argument_list|(
literal|", mode='%s'"
argument_list|,
operator|(
name|pwd
operator|->
name|ctrl
operator|&
name|ATA_SECURITY_LEVEL_MAXIMUM
operator|)
condition|?
literal|"maximum"
else|:
literal|"high"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|atasecurity_freeze
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|atasecurity_notify
argument_list|(
name|ATA_SECURITY_FREEZE_LOCK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ata_do_28bit_cmd
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
comment|/*protocol*/
name|AP_PROTO_NON_DATA
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*command*/
name|ATA_SECURITY_FREEZE_LOCK
argument_list|,
comment|/*features*/
literal|0
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*sector_count*/
literal|0
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
comment|/*timeout*/
name|timeout
argument_list|,
comment|/*quiet*/
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atasecurity_unlock
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|,
name|struct
name|ata_security_password
modifier|*
name|pwd
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|atasecurity_notify
argument_list|(
name|ATA_SECURITY_UNLOCK
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
return|return
name|ata_do_28bit_cmd
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
argument_list|,
comment|/*protocol*/
name|AP_PROTO_PIO_OUT
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*command*/
name|ATA_SECURITY_UNLOCK
argument_list|,
comment|/*features*/
literal|0
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*sector_count*/
literal|0
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|pwd
argument_list|,
comment|/*dxfer_len*/
sizeof|sizeof
argument_list|(
operator|*
name|pwd
argument_list|)
argument_list|,
comment|/*timeout*/
name|timeout
argument_list|,
comment|/*quiet*/
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atasecurity_disable
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|,
name|struct
name|ata_security_password
modifier|*
name|pwd
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|atasecurity_notify
argument_list|(
name|ATA_SECURITY_DISABLE_PASSWORD
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
return|return
name|ata_do_28bit_cmd
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
argument_list|,
comment|/*protocol*/
name|AP_PROTO_PIO_OUT
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*command*/
name|ATA_SECURITY_DISABLE_PASSWORD
argument_list|,
comment|/*features*/
literal|0
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*sector_count*/
literal|0
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|pwd
argument_list|,
comment|/*dxfer_len*/
sizeof|sizeof
argument_list|(
operator|*
name|pwd
argument_list|)
argument_list|,
comment|/*timeout*/
name|timeout
argument_list|,
comment|/*quiet*/
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atasecurity_erase_confirm
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|struct
name|ata_params
modifier|*
name|ident_buf
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\nYou are about to ERASE ALL DATA from the following"
literal|" device:\n%s%d,%s%d: "
argument_list|,
name|device
operator|->
name|device_name
argument_list|,
name|device
operator|->
name|dev_unit_num
argument_list|,
name|device
operator|->
name|given_dev_name
argument_list|,
name|device
operator|->
name|given_unit_number
argument_list|)
expr_stmt|;
name|ata_print_ident
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|str
index|[
literal|50
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"\nAre you SURE you want to ERASE ALL DATA? (yes/no) "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|str
argument_list|,
literal|"yes"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|str
argument_list|,
literal|"no"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Please answer \"yes\" or "
literal|"\"no\"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* NOTREACHED */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atasecurity_erase
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|,
name|u_int32_t
name|erase_timeout
parameter_list|,
name|struct
name|ata_security_password
modifier|*
name|pwd
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|atasecurity_notify
argument_list|(
name|ATA_SECURITY_ERASE_PREPARE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|ata_do_28bit_cmd
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
comment|/*protocol*/
name|AP_PROTO_NON_DATA
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*command*/
name|ATA_SECURITY_ERASE_PREPARE
argument_list|,
comment|/*features*/
literal|0
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*sector_count*/
literal|0
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
comment|/*timeout*/
name|timeout
argument_list|,
comment|/*quiet*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|atasecurity_notify
argument_list|(
name|ATA_SECURITY_ERASE_UNIT
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ata_do_28bit_cmd
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
argument_list|,
comment|/*protocol*/
name|AP_PROTO_PIO_OUT
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*command*/
name|ATA_SECURITY_ERASE_UNIT
argument_list|,
comment|/*features*/
literal|0
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*sector_count*/
literal|0
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|pwd
argument_list|,
comment|/*dxfer_len*/
sizeof|sizeof
argument_list|(
operator|*
name|pwd
argument_list|)
argument_list|,
comment|/*timeout*/
name|erase_timeout
argument_list|,
comment|/*quiet*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|quiet
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\nErase Complete\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atasecurity_set_password
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|,
name|struct
name|ata_security_password
modifier|*
name|pwd
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|atasecurity_notify
argument_list|(
name|ATA_SECURITY_SET_PASSWORD
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
return|return
name|ata_do_28bit_cmd
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_OUT
argument_list|,
comment|/*protocol*/
name|AP_PROTO_PIO_OUT
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*command*/
name|ATA_SECURITY_SET_PASSWORD
argument_list|,
comment|/*features*/
literal|0
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*sector_count*/
literal|0
argument_list|,
comment|/*data_ptr*/
operator|(
name|u_int8_t
operator|*
operator|)
name|pwd
argument_list|,
comment|/*dxfer_len*/
sizeof|sizeof
argument_list|(
operator|*
name|pwd
argument_list|)
argument_list|,
comment|/*timeout*/
name|timeout
argument_list|,
comment|/*quiet*/
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atasecurity_print
parameter_list|(
name|struct
name|ata_params
modifier|*
name|parm
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\nSecurity Option           Value\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|printf
argument_list|(
literal|"status                    %04x\n"
argument_list|,
name|parm
operator|->
name|security_status
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"supported                 %s\n"
argument_list|,
name|parm
operator|->
name|security_status
operator|&
name|ATA_SECURITY_SUPPORTED
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|parm
operator|->
name|security_status
operator|&
name|ATA_SECURITY_SUPPORTED
operator|)
condition|)
return|return;
name|printf
argument_list|(
literal|"enabled                   %s\n"
argument_list|,
name|parm
operator|->
name|security_status
operator|&
name|ATA_SECURITY_ENABLED
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"drive locked              %s\n"
argument_list|,
name|parm
operator|->
name|security_status
operator|&
name|ATA_SECURITY_LOCKED
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"security config frozen    %s\n"
argument_list|,
name|parm
operator|->
name|security_status
operator|&
name|ATA_SECURITY_FROZEN
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"count expired             %s\n"
argument_list|,
name|parm
operator|->
name|security_status
operator|&
name|ATA_SECURITY_COUNT_EXP
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"security level            %s\n"
argument_list|,
name|parm
operator|->
name|security_status
operator|&
name|ATA_SECURITY_LEVEL
condition|?
literal|"maximum"
else|:
literal|"high"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enhanced erase supported  %s\n"
argument_list|,
name|parm
operator|->
name|security_status
operator|&
name|ATA_SECURITY_ENH_SUPP
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"erase time                "
argument_list|)
expr_stmt|;
name|atasecurity_print_time
argument_list|(
name|parm
operator|->
name|erase_time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enhanced erase time       "
argument_list|)
expr_stmt|;
name|atasecurity_print_time
argument_list|(
name|parm
operator|->
name|enhanced_erase_time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"master password rev       %04x%s\n"
argument_list|,
name|parm
operator|->
name|master_passwd_revision
argument_list|,
name|parm
operator|->
name|master_passwd_revision
operator|==
literal|0x0000
operator|||
name|parm
operator|->
name|master_passwd_revision
operator|==
literal|0xFFFF
condition|?
literal|" (unsupported)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Validates and copies the password in optarg to the passed buffer.  * If the password in optarg is the same length as the buffer then  * the data will still be copied but no null termination will occur.  */
end_comment

begin_function
specifier|static
name|int
name|ata_getpwd
parameter_list|(
name|u_int8_t
modifier|*
name|passwd
parameter_list|,
name|int
name|max
parameter_list|,
name|char
name|opt
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|max
condition|)
block|{
name|warnx
argument_list|(
literal|"-%c password is too long"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"-%c password is missing"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|warnx
argument_list|(
literal|"-%c password starts with '-' (generic arg?)"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|passwd
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|passwd
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"-%c password conflicts with existing password from -%c"
argument_list|,
name|opt
argument_list|,
name|pwd_opt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Callers pass in a buffer which does NOT need to be terminated */
name|strncpy
argument_list|(
name|passwd
argument_list|,
name|optarg
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|pwd_opt
operator|=
name|opt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_enum
enum|enum
block|{
name|ATA_HPA_ACTION_PRINT
block|,
name|ATA_HPA_ACTION_SET_MAX
block|,
name|ATA_HPA_ACTION_SET_PWD
block|,
name|ATA_HPA_ACTION_LOCK
block|,
name|ATA_HPA_ACTION_UNLOCK
block|,
name|ATA_HPA_ACTION_FREEZE_LOCK
block|}
enum|;
end_enum

begin_function
specifier|static
name|int
name|atahpa_set_confirm
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|struct
name|ata_params
modifier|*
name|ident_buf
parameter_list|,
name|u_int64_t
name|maxsize
parameter_list|,
name|int
name|persist
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\nYou are about to configure HPA to limit the user accessible\n"
literal|"sectors to %ju %s on the device:\n%s%d,%s%d: "
argument_list|,
name|maxsize
argument_list|,
name|persist
condition|?
literal|"persistently"
else|:
literal|"temporarily"
argument_list|,
name|device
operator|->
name|device_name
argument_list|,
name|device
operator|->
name|dev_unit_num
argument_list|,
name|device
operator|->
name|given_dev_name
argument_list|,
name|device
operator|->
name|given_unit_number
argument_list|)
expr_stmt|;
name|ata_print_ident
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|str
index|[
literal|50
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"\nAre you SURE you want to configure HPA? (yes/no) "
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|fgets
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
name|stdin
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|strncasecmp
argument_list|(
name|str
argument_list|,
literal|"yes"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncasecmp
argument_list|(
name|str
argument_list|,
literal|"no"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Please answer \"yes\" or "
literal|"\"no\"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* NOTREACHED */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atahpa
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ata_params
modifier|*
name|ident_buf
decl_stmt|;
name|struct
name|ccb_getdev
name|cgd
decl_stmt|;
name|struct
name|ata_set_max_pwd
name|pwd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|confirm
decl_stmt|,
name|quiet
decl_stmt|,
name|c
decl_stmt|,
name|action
decl_stmt|,
name|actions
decl_stmt|,
name|persist
decl_stmt|;
name|int
name|security
decl_stmt|,
name|is48bit
decl_stmt|,
name|pwdsize
decl_stmt|;
name|u_int64_t
name|hpasize
decl_stmt|,
name|maxsize
decl_stmt|;
name|actions
operator|=
literal|0
expr_stmt|;
name|confirm
operator|=
literal|0
expr_stmt|;
name|quiet
operator|=
literal|0
expr_stmt|;
name|maxsize
operator|=
literal|0
expr_stmt|;
name|persist
operator|=
literal|0
expr_stmt|;
name|security
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pwd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pwd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* default action is to print hpa information */
name|action
operator|=
name|ATA_HPA_ACTION_PRINT
expr_stmt|;
name|pwdsize
operator|=
sizeof|sizeof
argument_list|(
name|pwd
operator|.
name|password
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'s'
case|:
name|action
operator|=
name|ATA_HPA_ACTION_SET_MAX
expr_stmt|;
name|maxsize
operator|=
name|strtoumax
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|actions
operator|++
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|ata_getpwd
argument_list|(
name|pwd
operator|.
name|password
argument_list|,
name|pwdsize
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|action
operator|=
name|ATA_HPA_ACTION_SET_PWD
expr_stmt|;
name|security
operator|=
literal|1
expr_stmt|;
name|actions
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|action
operator|=
name|ATA_HPA_ACTION_LOCK
expr_stmt|;
name|security
operator|=
literal|1
expr_stmt|;
name|actions
operator|++
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
name|ata_getpwd
argument_list|(
name|pwd
operator|.
name|password
argument_list|,
name|pwdsize
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|action
operator|=
name|ATA_HPA_ACTION_UNLOCK
expr_stmt|;
name|security
operator|=
literal|1
expr_stmt|;
name|actions
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|action
operator|=
name|ATA_HPA_ACTION_FREEZE_LOCK
expr_stmt|;
name|security
operator|=
literal|1
expr_stmt|;
name|actions
operator|++
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|persist
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|confirm
operator|++
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|actions
operator|>
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"too many hpa actions specified"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|get_cgd
argument_list|(
name|device
argument_list|,
operator|&
name|cgd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't get CGD"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't allocate CCB"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|error
operator|=
name|ata_do_identify
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|ccb
argument_list|,
operator|&
name|ident_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d: "
argument_list|,
name|device
operator|->
name|device_name
argument_list|,
name|device
operator|->
name|dev_unit_num
argument_list|)
expr_stmt|;
name|ata_print_ident
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
name|camxferrate
argument_list|(
name|device
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|==
name|ATA_HPA_ACTION_PRINT
condition|)
block|{
name|error
operator|=
name|ata_read_native_max
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|ccb
argument_list|,
name|ident_buf
argument_list|,
operator|&
name|hpasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|atahpa_print
argument_list|(
name|ident_buf
argument_list|,
name|hpasize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|ident_buf
operator|->
name|support
operator|.
name|command1
operator|&
name|ATA_SUPPORT_PROTECTED
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"HPA is not supported by this device"
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|security
operator|&&
operator|!
operator|(
name|ident_buf
operator|->
name|support
operator|.
name|command1
operator|&
name|ATA_SUPPORT_MAXSECURITY
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"HPA Security is not supported by this device"
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|is48bit
operator|=
name|ident_buf
operator|->
name|support
operator|.
name|command2
operator|&
name|ATA_SUPPORT_ADDRESS48
expr_stmt|;
comment|/* 	 * The ATA spec requires: 	 * 1. Read native max addr is called directly before set max addr 	 * 2. Read native max addr is NOT called before any other set max call 	 */
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|ATA_HPA_ACTION_SET_MAX
case|:
if|if
condition|(
name|confirm
operator|==
literal|0
operator|&&
name|atahpa_set_confirm
argument_list|(
name|device
argument_list|,
name|ident_buf
argument_list|,
name|maxsize
argument_list|,
name|persist
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|error
operator|=
name|ata_read_native_max
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|ccb
argument_list|,
name|ident_buf
argument_list|,
operator|&
name|hpasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|atahpa_set_max
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|ccb
argument_list|,
name|is48bit
argument_list|,
name|maxsize
argument_list|,
name|persist
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* redo identify to get new lba values */
name|error
operator|=
name|ata_do_identify
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|ccb
argument_list|,
operator|&
name|ident_buf
argument_list|)
expr_stmt|;
name|atahpa_print
argument_list|(
name|ident_buf
argument_list|,
name|hpasize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ATA_HPA_ACTION_SET_PWD
case|:
name|error
operator|=
name|atahpa_password
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|ccb
argument_list|,
name|is48bit
argument_list|,
operator|&
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"HPA password has been set\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATA_HPA_ACTION_LOCK
case|:
name|error
operator|=
name|atahpa_lock
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|ccb
argument_list|,
name|is48bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"HPA has been locked\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATA_HPA_ACTION_UNLOCK
case|:
name|error
operator|=
name|atahpa_unlock
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|ccb
argument_list|,
name|is48bit
argument_list|,
operator|&
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"HPA has been unlocked\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATA_HPA_ACTION_FREEZE_LOCK
case|:
name|error
operator|=
name|atahpa_freeze_lock
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|ccb
argument_list|,
name|is48bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"HPA has been frozen\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Option currently not supported"
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atasecurity
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ata_params
modifier|*
name|ident_buf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|confirm
decl_stmt|,
name|quiet
decl_stmt|,
name|c
decl_stmt|,
name|action
decl_stmt|,
name|actions
decl_stmt|,
name|setpwd
decl_stmt|;
name|int
name|security_enabled
decl_stmt|,
name|erase_timeout
decl_stmt|,
name|pwdsize
decl_stmt|;
name|struct
name|ata_security_password
name|pwd
decl_stmt|;
name|actions
operator|=
literal|0
expr_stmt|;
name|setpwd
operator|=
literal|0
expr_stmt|;
name|erase_timeout
operator|=
literal|0
expr_stmt|;
name|confirm
operator|=
literal|0
expr_stmt|;
name|quiet
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pwd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pwd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* default action is to print security information */
name|action
operator|=
name|ATA_SECURITY_ACTION_PRINT
expr_stmt|;
comment|/* user is master by default as its safer that way */
name|pwd
operator|.
name|ctrl
operator||=
name|ATA_SECURITY_PASSWORD_MASTER
expr_stmt|;
name|pwdsize
operator|=
sizeof|sizeof
argument_list|(
name|pwd
operator|.
name|password
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|action
operator|=
name|ATA_SECURITY_ACTION_FREEZE
expr_stmt|;
name|actions
operator|++
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"user"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pwd
operator|.
name|ctrl
operator||=
name|ATA_SECURITY_PASSWORD_USER
expr_stmt|;
name|pwd
operator|.
name|ctrl
operator|&=
operator|~
name|ATA_SECURITY_PASSWORD_MASTER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"master"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pwd
operator|.
name|ctrl
operator||=
name|ATA_SECURITY_PASSWORD_MASTER
expr_stmt|;
name|pwd
operator|.
name|ctrl
operator|&=
operator|~
name|ATA_SECURITY_PASSWORD_USER
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"-U argument '%s' is invalid (must be "
literal|"'user' or 'master')"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"high"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pwd
operator|.
name|ctrl
operator||=
name|ATA_SECURITY_LEVEL_HIGH
expr_stmt|;
name|pwd
operator|.
name|ctrl
operator|&=
operator|~
name|ATA_SECURITY_LEVEL_MAXIMUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"maximum"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pwd
operator|.
name|ctrl
operator||=
name|ATA_SECURITY_LEVEL_MAXIMUM
expr_stmt|;
name|pwd
operator|.
name|ctrl
operator|&=
operator|~
name|ATA_SECURITY_LEVEL_HIGH
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"-l argument '%s' is unknown (must be "
literal|"'high' or 'maximum')"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|ata_getpwd
argument_list|(
name|pwd
operator|.
name|password
argument_list|,
name|pwdsize
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|action
operator|=
name|ATA_SECURITY_ACTION_UNLOCK
expr_stmt|;
name|actions
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|ata_getpwd
argument_list|(
name|pwd
operator|.
name|password
argument_list|,
name|pwdsize
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|action
operator|=
name|ATA_SECURITY_ACTION_DISABLE
expr_stmt|;
name|actions
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|ata_getpwd
argument_list|(
name|pwd
operator|.
name|password
argument_list|,
name|pwdsize
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|action
operator|=
name|ATA_SECURITY_ACTION_ERASE
expr_stmt|;
name|actions
operator|++
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|ata_getpwd
argument_list|(
name|pwd
operator|.
name|password
argument_list|,
name|pwdsize
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|pwd
operator|.
name|ctrl
operator||=
name|ATA_SECURITY_ERASE_ENHANCED
expr_stmt|;
name|action
operator|=
name|ATA_SECURITY_ACTION_ERASE_ENHANCED
expr_stmt|;
name|actions
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|ata_getpwd
argument_list|(
name|pwd
operator|.
name|password
argument_list|,
name|pwdsize
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|setpwd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|ATA_SECURITY_ACTION_PRINT
condition|)
name|action
operator|=
name|ATA_SECURITY_ACTION_SET_PASSWORD
expr_stmt|;
comment|/* 			 * Don't increment action as this can be combined 			 * with other actions. 			 */
break|break;
case|case
literal|'y'
case|:
name|confirm
operator|++
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|++
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|erase_timeout
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
operator|*
literal|1000
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|actions
operator|>
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"too many security actions specified"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't allocate CCB"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|error
operator|=
name|ata_do_identify
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|ccb
argument_list|,
operator|&
name|ident_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d: "
argument_list|,
name|device
operator|->
name|device_name
argument_list|,
name|device
operator|->
name|dev_unit_num
argument_list|)
expr_stmt|;
name|ata_print_ident
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
name|camxferrate
argument_list|(
name|device
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|==
name|ATA_SECURITY_ACTION_PRINT
condition|)
block|{
name|atasecurity_print
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ident_buf
operator|->
name|support
operator|.
name|command1
operator|&
name|ATA_SUPPORT_SECURITY
operator|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Security not supported"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* default timeout 15 seconds the same as linux hdparm */
name|timeout
operator|=
name|timeout
condition|?
name|timeout
else|:
literal|15
operator|*
literal|1000
expr_stmt|;
name|security_enabled
operator|=
name|ident_buf
operator|->
name|security_status
operator|&
name|ATA_SECURITY_ENABLED
expr_stmt|;
comment|/* first set the password if requested */
if|if
condition|(
name|setpwd
operator|==
literal|1
condition|)
block|{
comment|/* confirm we can erase before setting the password if erasing */
if|if
condition|(
name|confirm
operator|==
literal|0
operator|&&
operator|(
name|action
operator|==
name|ATA_SECURITY_ACTION_ERASE_ENHANCED
operator|||
name|action
operator|==
name|ATA_SECURITY_ACTION_ERASE
operator|)
operator|&&
name|atasecurity_erase_confirm
argument_list|(
name|device
argument_list|,
name|ident_buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|pwd
operator|.
name|ctrl
operator|&
name|ATA_SECURITY_PASSWORD_MASTER
condition|)
block|{
name|pwd
operator|.
name|revision
operator|=
name|ident_buf
operator|->
name|master_passwd_revision
expr_stmt|;
if|if
condition|(
name|pwd
operator|.
name|revision
operator|!=
literal|0
operator|&&
name|pwd
operator|.
name|revision
operator|!=
literal|0xfff
operator|&&
operator|--
name|pwd
operator|.
name|revision
operator|==
literal|0
condition|)
block|{
name|pwd
operator|.
name|revision
operator|=
literal|0xfffe
expr_stmt|;
block|}
block|}
name|error
operator|=
name|atasecurity_set_password
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
operator|&
name|pwd
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|security_enabled
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|ATA_SECURITY_ACTION_FREEZE
case|:
name|error
operator|=
name|atasecurity_freeze
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATA_SECURITY_ACTION_UNLOCK
case|:
if|if
condition|(
name|security_enabled
condition|)
block|{
if|if
condition|(
name|ident_buf
operator|->
name|security_status
operator|&
name|ATA_SECURITY_LOCKED
condition|)
block|{
name|error
operator|=
name|atasecurity_unlock
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
operator|&
name|pwd
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"Can't unlock, drive is not locked"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"Can't unlock, security is disabled"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|ATA_SECURITY_ACTION_DISABLE
case|:
if|if
condition|(
name|security_enabled
condition|)
block|{
comment|/* First unlock the drive if its locked */
if|if
condition|(
name|ident_buf
operator|->
name|security_status
operator|&
name|ATA_SECURITY_LOCKED
condition|)
block|{
name|error
operator|=
name|atasecurity_unlock
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
operator|&
name|pwd
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|atasecurity_disable
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
operator|&
name|pwd
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"Can't disable security (already disabled)"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|ATA_SECURITY_ACTION_ERASE
case|:
if|if
condition|(
name|security_enabled
condition|)
block|{
if|if
condition|(
name|erase_timeout
operator|==
literal|0
condition|)
block|{
name|erase_timeout
operator|=
name|atasecurity_erase_timeout_msecs
argument_list|(
name|ident_buf
operator|->
name|erase_time
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|atasecurity_erase
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|erase_timeout
argument_list|,
operator|&
name|pwd
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"Can't secure erase (security is disabled)"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|ATA_SECURITY_ACTION_ERASE_ENHANCED
case|:
if|if
condition|(
name|security_enabled
condition|)
block|{
if|if
condition|(
name|ident_buf
operator|->
name|security_status
operator|&
name|ATA_SECURITY_ENH_SUPP
condition|)
block|{
if|if
condition|(
name|erase_timeout
operator|==
literal|0
condition|)
block|{
name|erase_timeout
operator|=
name|atasecurity_erase_timeout_msecs
argument_list|(
name|ident_buf
operator|->
name|enhanced_erase_time
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|atasecurity_erase
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|erase_timeout
argument_list|,
operator|&
name|pwd
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"Enhanced erase is not supported"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"Can't secure erase (enhanced), "
literal|"(security is disabled)"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MINIMALISTIC */
end_comment

begin_comment
comment|/*  * Parse out a bus, or a bus, target and lun in the following  * format:  * bus  * bus:target  * bus:target:lun  *  * Returns the number of parsed components, or 0.  */
end_comment

begin_function
specifier|static
name|int
name|parse_btl
parameter_list|(
name|char
modifier|*
name|tstr
parameter_list|,
name|path_id_t
modifier|*
name|bus
parameter_list|,
name|target_id_t
modifier|*
name|target
parameter_list|,
name|lun_id_t
modifier|*
name|lun
parameter_list|,
name|cam_argmask
modifier|*
name|arglst
parameter_list|)
block|{
name|char
modifier|*
name|tmpstr
decl_stmt|;
name|int
name|convs
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|tstr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
operator|*
name|bus
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|arglst
operator||=
name|CAM_ARG_BUS
expr_stmt|;
name|convs
operator|++
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
operator|*
name|target
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|arglst
operator||=
name|CAM_ARG_TARGET
expr_stmt|;
name|convs
operator|++
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
operator|*
name|lun
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|arglst
operator||=
name|CAM_ARG_LUN
expr_stmt|;
name|convs
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|convs
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dorescan_or_reset
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|rescan
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|must
index|[]
init|=
literal|"you must specify \"all\", a bus, or a bus:target:lun to %s"
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|path_id_t
name|bus
init|=
name|CAM_BUS_WILDCARD
decl_stmt|;
name|target_id_t
name|target
init|=
name|CAM_TARGET_WILDCARD
decl_stmt|;
name|lun_id_t
name|lun
init|=
name|CAM_LUN_WILDCARD
decl_stmt|;
name|char
modifier|*
name|tstr
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|warnx
argument_list|(
name|must
argument_list|,
name|rescan
condition|?
literal|"rescan"
else|:
literal|"reset"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|tstr
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|tstr
argument_list|,
literal|"all"
argument_list|,
name|strlen
argument_list|(
literal|"all"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|arglist
operator||=
name|CAM_ARG_BUS
expr_stmt|;
else|else
block|{
name|rv
operator|=
name|parse_btl
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
operator|&
name|bus
argument_list|,
operator|&
name|target
argument_list|,
operator|&
name|lun
argument_list|,
operator|&
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|1
operator|&&
name|rv
operator|!=
literal|3
condition|)
block|{
name|warnx
argument_list|(
name|must
argument_list|,
name|rescan
condition|?
literal|"rescan"
else|:
literal|"reset"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|arglist
operator|&
name|CAM_ARG_BUS
operator|)
operator|&&
operator|(
name|arglist
operator|&
name|CAM_ARG_TARGET
operator|)
operator|&&
operator|(
name|arglist
operator|&
name|CAM_ARG_LUN
operator|)
condition|)
name|error
operator|=
name|scanlun_or_reset_dev
argument_list|(
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|rescan
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|rescan_or_reset_bus
argument_list|(
name|bus
argument_list|,
name|rescan
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rescan_or_reset_bus
parameter_list|(
name|path_id_t
name|bus
parameter_list|,
name|int
name|rescan
parameter_list|)
block|{
name|union
name|ccb
name|ccb
decl_stmt|,
name|matchccb
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|retval
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XPT_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"error opening transport layer device %s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bus
operator|!=
name|CAM_BUS_WILDCARD
condition|)
block|{
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|rescan
condition|?
name|XPT_SCAN_BUS
else|:
name|XPT_RESET_BUS
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|path_id
operator|=
name|bus
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|CAM_LUN_WILDCARD
expr_stmt|;
name|ccb
operator|.
name|crcn
operator|.
name|flags
operator|=
name|CAM_FLAG_NONE
expr_stmt|;
comment|/* run this at a low priority */
name|ccb
operator|.
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"CAMIOCOMMAND ioctl failed"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s of bus %d was successful\n"
argument_list|,
name|rescan
condition|?
literal|"Re-scan"
else|:
literal|"Reset"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s of bus %d returned error %#x\n"
argument_list|,
name|rescan
condition|?
literal|"Re-scan"
else|:
literal|"Reset"
argument_list|,
name|bus
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* 	 * The right way to handle this is to modify the xpt so that it can 	 * handle a wildcarded bus in a rescan or reset CCB.  At the moment 	 * that isn't implemented, so instead we enumerate the busses and 	 * send the rescan or reset to those busses in the case where the 	 * given bus is -1 (wildcard).  We don't send a rescan or reset 	 * to the xpt bus; sending a rescan to the xpt bus is effectively a 	 * no-op, sending a rescan to the xpt bus would result in a status of 	 * CAM_REQ_INVALID. 	 */
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|matchccb
operator|.
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_dev_match
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|matchccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEV_MATCH
expr_stmt|;
name|matchccb
operator|.
name|ccb_h
operator|.
name|path_id
operator|=
name|CAM_BUS_WILDCARD
expr_stmt|;
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
operator|*
literal|20
expr_stmt|;
name|matchccb
operator|.
name|cdm
operator|.
name|match_buf_len
operator|=
name|bufsize
expr_stmt|;
name|matchccb
operator|.
name|cdm
operator|.
name|matches
operator|=
operator|(
expr|struct
name|dev_match_result
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchccb
operator|.
name|cdm
operator|.
name|matches
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't malloc memory for matches"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|matchccb
operator|.
name|cdm
operator|.
name|num_matches
operator|=
literal|0
expr_stmt|;
name|matchccb
operator|.
name|cdm
operator|.
name|num_patterns
operator|=
literal|1
expr_stmt|;
name|matchccb
operator|.
name|cdm
operator|.
name|pattern_buf_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_pattern
argument_list|)
expr_stmt|;
name|matchccb
operator|.
name|cdm
operator|.
name|patterns
operator|=
operator|(
expr|struct
name|dev_match_pattern
operator|*
operator|)
name|malloc
argument_list|(
name|matchccb
operator|.
name|cdm
operator|.
name|pattern_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchccb
operator|.
name|cdm
operator|.
name|patterns
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't malloc memory for patterns"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|matchccb
operator|.
name|cdm
operator|.
name|patterns
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|DEV_MATCH_BUS
expr_stmt|;
name|matchccb
operator|.
name|cdm
operator|.
name|patterns
index|[
literal|0
index|]
operator|.
name|pattern
operator|.
name|bus_pattern
operator|.
name|flags
operator|=
name|BUS_MATCH_ANY
expr_stmt|;
do|do
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|matchccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"CAMIOCOMMAND ioctl failed"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|matchccb
operator|.
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
operator|)
operator|||
operator|(
operator|(
name|matchccb
operator|.
name|cdm
operator|.
name|status
operator|!=
name|CAM_DEV_MATCH_LAST
operator|)
operator|&&
operator|(
name|matchccb
operator|.
name|cdm
operator|.
name|status
operator|!=
name|CAM_DEV_MATCH_MORE
operator|)
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"got CAM error %#x, CDM error %d\n"
argument_list|,
name|matchccb
operator|.
name|ccb_h
operator|.
name|status
argument_list|,
name|matchccb
operator|.
name|cdm
operator|.
name|status
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|matchccb
operator|.
name|cdm
operator|.
name|num_matches
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bus_match_result
modifier|*
name|bus_result
decl_stmt|;
comment|/* This shouldn't happen. */
if|if
condition|(
name|matchccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|DEV_MATCH_BUS
condition|)
continue|continue;
name|bus_result
operator|=
operator|&
name|matchccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|result
operator|.
name|bus_result
expr_stmt|;
comment|/* 			 * We don't want to rescan or reset the xpt bus. 			 * See above. 			 */
if|if
condition|(
name|bus_result
operator|->
name|path_id
operator|==
name|CAM_XPT_PATH_ID
condition|)
continue|continue;
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|rescan
condition|?
name|XPT_SCAN_BUS
else|:
name|XPT_RESET_BUS
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|path_id
operator|=
name|bus_result
operator|->
name|path_id
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|CAM_LUN_WILDCARD
expr_stmt|;
name|ccb
operator|.
name|crcn
operator|.
name|flags
operator|=
name|CAM_FLAG_NONE
expr_stmt|;
comment|/* run this at a low priority */
name|ccb
operator|.
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"CAMIOCOMMAND ioctl failed"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s of bus %d was successful\n"
argument_list|,
name|rescan
condition|?
literal|"Re-scan"
else|:
literal|"Reset"
argument_list|,
name|bus_result
operator|->
name|path_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Don't bail out just yet, maybe the other 				 * rescan or reset commands will complete 				 * successfully. 				 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s of bus %d returned error "
literal|"%#x\n"
argument_list|,
name|rescan
condition|?
literal|"Re-scan"
else|:
literal|"Reset"
argument_list|,
name|bus_result
operator|->
name|path_id
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|matchccb
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|matchccb
operator|.
name|cdm
operator|.
name|status
operator|==
name|CAM_DEV_MATCH_MORE
operator|)
condition|)
do|;
name|bailout
label|:
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchccb
operator|.
name|cdm
operator|.
name|patterns
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|matchccb
operator|.
name|cdm
operator|.
name|patterns
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchccb
operator|.
name|cdm
operator|.
name|matches
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|matchccb
operator|.
name|cdm
operator|.
name|matches
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scanlun_or_reset_dev
parameter_list|(
name|path_id_t
name|bus
parameter_list|,
name|target_id_t
name|target
parameter_list|,
name|lun_id_t
name|lun
parameter_list|,
name|int
name|scan
parameter_list|)
block|{
name|union
name|ccb
name|ccb
decl_stmt|;
name|struct
name|cam_device
modifier|*
name|device
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|device
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bus
operator|==
name|CAM_BUS_WILDCARD
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid bus number %d"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|target
operator|==
name|CAM_TARGET_WILDCARD
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid target number %d"
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lun
operator|==
name|CAM_LUN_WILDCARD
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid lun number %jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lun
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XPT_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"error opening transport layer device %s\n"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|device
operator|=
name|cam_open_btl
argument_list|(
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|O_RDWR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s"
argument_list|,
name|cam_errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
operator|(
name|scan
operator|)
condition|?
name|XPT_SCAN_LUN
else|:
name|XPT_RESET_DEV
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|path_id
operator|=
name|bus
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|target
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|lun
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|timeout
operator|=
literal|5000
expr_stmt|;
name|ccb
operator|.
name|crcn
operator|.
name|flags
operator|=
name|CAM_FLAG_NONE
expr_stmt|;
comment|/* run this at a low priority */
name|ccb
operator|.
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|scan
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"CAMIOCOMMAND ioctl failed"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending XPT_RESET_DEV CCB"
argument_list|)
expr_stmt|;
name|cam_close_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|scan
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
else|else
name|cam_close_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
comment|/* 	 * An error code of CAM_BDR_SENT is normal for a BDR request. 	 */
if|if
condition|(
operator|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
operator|)
operator|||
operator|(
operator|(
operator|!
name|scan
operator|)
operator|&&
operator|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_BDR_SENT
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s of %d:%d:%jx was successful\n"
argument_list|,
name|scan
condition|?
literal|"Re-scan"
else|:
literal|"Reset"
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lun
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s of %d:%d:%jx returned error %#x\n"
argument_list|,
name|scan
condition|?
literal|"Re-scan"
else|:
literal|"Reset"
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lun
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_decl_stmt
specifier|static
name|struct
name|scsi_nv
name|defect_list_type_map
index|[]
init|=
block|{
block|{
literal|"block"
block|,
name|SRDD10_BLOCK_FORMAT
block|}
block|,
block|{
literal|"extbfi"
block|,
name|SRDD10_EXT_BFI_FORMAT
block|}
block|,
block|{
literal|"extphys"
block|,
name|SRDD10_EXT_PHYS_FORMAT
block|}
block|,
block|{
literal|"longblock"
block|,
name|SRDD10_LONG_BLOCK_FORMAT
block|}
block|,
block|{
literal|"bfi"
block|,
name|SRDD10_BYTES_FROM_INDEX_FORMAT
block|}
block|,
block|{
literal|"phys"
block|,
name|SRDD10_PHYSICAL_SECTOR_FORMAT
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|readdefects
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|NULL
decl_stmt|;
name|struct
name|scsi_read_defect_data_hdr_10
modifier|*
name|hdr10
init|=
name|NULL
decl_stmt|;
name|struct
name|scsi_read_defect_data_hdr_12
modifier|*
name|hdr12
init|=
name|NULL
decl_stmt|;
name|size_t
name|hdr_size
init|=
literal|0
decl_stmt|,
name|entry_size
init|=
literal|0
decl_stmt|;
name|int
name|use_12byte
init|=
literal|0
decl_stmt|;
name|int
name|hex_format
init|=
literal|0
decl_stmt|;
name|u_int8_t
modifier|*
name|defect_list
init|=
name|NULL
decl_stmt|;
name|u_int8_t
name|list_format
init|=
literal|0
decl_stmt|;
name|int
name|list_type_set
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|dlist_length
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|returned_length
init|=
literal|0
decl_stmt|,
name|valid_len
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|num_returned
init|=
literal|0
decl_stmt|,
name|num_valid
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|max_possible_size
init|=
literal|0
decl_stmt|,
name|hdr_max
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|starting_offset
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|returned_format
decl_stmt|,
name|returned_type
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|summary
init|=
literal|0
decl_stmt|,
name|quiet
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|lists_specified
init|=
literal|0
decl_stmt|;
name|int
name|get_length
init|=
literal|1
decl_stmt|,
name|first_pass
init|=
literal|1
decl_stmt|;
name|int
name|mads
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
block|{
name|scsi_nv_status
name|status
decl_stmt|;
name|int
name|entry_num
init|=
literal|0
decl_stmt|;
name|status
operator|=
name|scsi_get_nv
argument_list|(
name|defect_list_type_map
argument_list|,
sizeof|sizeof
argument_list|(
name|defect_list_type_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|defect_list_type_map
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|optarg
argument_list|,
operator|&
name|entry_num
argument_list|,
name|SCSI_NV_FLAG_IG_CASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCSI_NV_FOUND
condition|)
block|{
name|list_format
operator|=
name|defect_list_type_map
index|[
name|entry_num
index|]
operator|.
name|value
expr_stmt|;
name|list_type_set
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"%s: %s %s option %s"
argument_list|,
name|__func__
argument_list|,
operator|(
name|status
operator|==
name|SCSI_NV_AMBIGUOUS
operator|)
condition|?
literal|"ambiguous"
else|:
literal|"invalid"
argument_list|,
literal|"defect list type"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
break|break;
block|}
case|case
literal|'G'
case|:
name|arglist
operator||=
name|CAM_ARG_GLIST
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|arglist
operator||=
name|CAM_ARG_PLIST
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|summary
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|starting_offset
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"invalid starting offset %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
break|break;
block|}
case|case
literal|'X'
case|:
name|hex_format
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|list_type_set
operator|==
literal|0
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"no defect list format specified"
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_PLIST
condition|)
block|{
name|list_format
operator||=
name|SRDD10_PLIST
expr_stmt|;
name|lists_specified
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_GLIST
condition|)
block|{
name|list_format
operator||=
name|SRDD10_GLIST
expr_stmt|;
name|lists_specified
operator|++
expr_stmt|;
block|}
comment|/* 	 * This implies a summary, and was the previous behavior. 	 */
if|if
condition|(
name|lists_specified
operator|==
literal|0
condition|)
name|summary
operator|=
literal|1
expr_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|retry_12byte
label|:
comment|/* 	 * We start off asking for just the header to determine how much 	 * defect data is available.  Some Hitachi drives return an error 	 * if you ask for more data than the drive has.  Once we know the 	 * length, we retry the command with the returned length. 	 */
if|if
condition|(
name|use_12byte
operator|==
literal|0
condition|)
name|dlist_length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|hdr10
argument_list|)
expr_stmt|;
else|else
name|dlist_length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|hdr12
argument_list|)
expr_stmt|;
name|retry
label|:
if|if
condition|(
name|defect_list
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|defect_list
argument_list|)
expr_stmt|;
name|defect_list
operator|=
name|NULL
expr_stmt|;
block|}
name|defect_list
operator|=
name|malloc
argument_list|(
name|dlist_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|defect_list
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't malloc memory for defect list"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
name|next_batch
label|:
name|bzero
argument_list|(
name|defect_list
argument_list|,
name|dlist_length
argument_list|)
expr_stmt|;
comment|/* 	 * cam_getccb() zeros the CCB header only.  So we need to zero the 	 * payload portion of the ccb. 	 */
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_read_defects
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*list_format*/
name|list_format
argument_list|,
comment|/*addr_desc_index*/
name|starting_offset
argument_list|,
comment|/*data_ptr*/
name|defect_list
argument_list|,
comment|/*dxfer_len*/
name|dlist_length
argument_list|,
comment|/*minimum_cmd_size*/
name|use_12byte
condition|?
literal|12
else|:
literal|0
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error reading defect list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
name|valid_len
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|resid
expr_stmt|;
if|if
condition|(
name|use_12byte
operator|==
literal|0
condition|)
block|{
name|hdr10
operator|=
operator|(
expr|struct
name|scsi_read_defect_data_hdr_10
operator|*
operator|)
name|defect_list
expr_stmt|;
name|hdr_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|hdr10
argument_list|)
expr_stmt|;
name|hdr_max
operator|=
name|SRDDH10_MAX_LENGTH
expr_stmt|;
if|if
condition|(
name|valid_len
operator|>=
name|hdr_size
condition|)
block|{
name|returned_length
operator|=
name|scsi_2btoul
argument_list|(
name|hdr10
operator|->
name|length
argument_list|)
expr_stmt|;
name|returned_format
operator|=
name|hdr10
operator|->
name|format
expr_stmt|;
block|}
else|else
block|{
name|returned_length
operator|=
literal|0
expr_stmt|;
name|returned_format
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|hdr12
operator|=
operator|(
expr|struct
name|scsi_read_defect_data_hdr_12
operator|*
operator|)
name|defect_list
expr_stmt|;
name|hdr_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|hdr12
argument_list|)
expr_stmt|;
name|hdr_max
operator|=
name|SRDDH12_MAX_LENGTH
expr_stmt|;
if|if
condition|(
name|valid_len
operator|>=
name|hdr_size
condition|)
block|{
name|returned_length
operator|=
name|scsi_4btoul
argument_list|(
name|hdr12
operator|->
name|length
argument_list|)
expr_stmt|;
name|returned_format
operator|=
name|hdr12
operator|->
name|format
expr_stmt|;
block|}
else|else
block|{
name|returned_length
operator|=
literal|0
expr_stmt|;
name|returned_format
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|returned_type
operator|=
name|returned_format
operator|&
name|SRDDH10_DLIST_FORMAT_MASK
expr_stmt|;
switch|switch
condition|(
name|returned_type
condition|)
block|{
case|case
name|SRDD10_BLOCK_FORMAT
case|:
name|entry_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_defect_desc_block
argument_list|)
expr_stmt|;
break|break;
case|case
name|SRDD10_LONG_BLOCK_FORMAT
case|:
name|entry_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_defect_desc_long_block
argument_list|)
expr_stmt|;
break|break;
case|case
name|SRDD10_EXT_PHYS_FORMAT
case|:
case|case
name|SRDD10_PHYSICAL_SECTOR_FORMAT
case|:
name|entry_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_defect_desc_phys_sector
argument_list|)
expr_stmt|;
break|break;
case|case
name|SRDD10_EXT_BFI_FORMAT
case|:
case|case
name|SRDD10_BYTES_FROM_INDEX_FORMAT
case|:
name|entry_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_defect_desc_bytes_from_index
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"Unknown defect format 0x%x\n"
argument_list|,
name|returned_type
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
break|break;
block|}
name|max_possible_size
operator|=
operator|(
name|hdr_max
operator|/
name|entry_size
operator|)
operator|*
name|entry_size
expr_stmt|;
name|num_returned
operator|=
name|returned_length
operator|/
name|entry_size
expr_stmt|;
name|num_valid
operator|=
name|min
argument_list|(
name|returned_length
argument_list|,
name|valid_len
operator|-
name|hdr_size
argument_list|)
expr_stmt|;
name|num_valid
operator|/=
name|entry_size
expr_stmt|;
if|if
condition|(
name|get_length
operator|!=
literal|0
condition|)
block|{
name|get_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|sense
operator|=
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|scsi_extract_sense_len
argument_list|(
name|sense
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|,
comment|/*show_errors*/
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * If the drive is reporting that it just doesn't 			 * support the defect list format, go ahead and use 			 * the length it reported.  Otherwise, the length 			 * may not be valid, so use the maximum. 			 */
if|if
condition|(
operator|(
name|sense_key
operator|==
name|SSD_KEY_RECOVERED_ERROR
operator|)
operator|&&
operator|(
name|asc
operator|==
literal|0x1c
operator|)
operator|&&
operator|(
name|ascq
operator|==
literal|0x00
operator|)
operator|&&
operator|(
name|returned_length
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|use_12byte
operator|==
literal|0
operator|)
operator|&&
operator|(
name|returned_length
operator|>=
name|max_possible_size
operator|)
condition|)
block|{
name|get_length
operator|=
literal|1
expr_stmt|;
name|use_12byte
operator|=
literal|1
expr_stmt|;
goto|goto
name|retry_12byte
goto|;
block|}
name|dlist_length
operator|=
name|returned_length
operator|+
name|hdr_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sense_key
operator|==
name|SSD_KEY_RECOVERED_ERROR
operator|)
operator|&&
operator|(
name|asc
operator|==
literal|0x1f
operator|)
operator|&&
operator|(
name|ascq
operator|==
literal|0x00
operator|)
operator|&&
operator|(
name|returned_length
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* Partial defect list transfer */
comment|/* 				 * Hitachi drives return this error 				 * along with a partial defect list if they 				 * have more defects than the 10 byte 				 * command can support.  Retry with the 12 				 * byte command. 				 */
if|if
condition|(
name|use_12byte
operator|==
literal|0
condition|)
block|{
name|get_length
operator|=
literal|1
expr_stmt|;
name|use_12byte
operator|=
literal|1
expr_stmt|;
goto|goto
name|retry_12byte
goto|;
block|}
name|dlist_length
operator|=
name|returned_length
operator|+
name|hdr_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sense_key
operator|==
name|SSD_KEY_ILLEGAL_REQUEST
operator|)
operator|&&
operator|(
name|asc
operator|==
literal|0x24
operator|)
operator|&&
operator|(
name|ascq
operator|==
literal|0x00
operator|)
condition|)
block|{
comment|/* Invalid field in CDB */
comment|/* 				 * SBC-3 says that if the drive has more 				 * defects than can be reported with the 				 * 10 byte command, it should return this 	 			 * error and no data.  Retry with the 12 				 * byte command. 				 */
if|if
condition|(
name|use_12byte
operator|==
literal|0
condition|)
block|{
name|get_length
operator|=
literal|1
expr_stmt|;
name|use_12byte
operator|=
literal|1
expr_stmt|;
goto|goto
name|retry_12byte
goto|;
block|}
name|dlist_length
operator|=
name|returned_length
operator|+
name|hdr_size
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * If we got a SCSI error and no valid length, 				 * just use the 10 byte maximum.  The 12 				 * byte maximum is too large. 				 */
if|if
condition|(
name|returned_length
operator|==
literal|0
condition|)
name|dlist_length
operator|=
name|SRDD10_MAX_LENGTH
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|use_12byte
operator|==
literal|0
operator|)
operator|&&
operator|(
name|returned_length
operator|>=
name|max_possible_size
operator|)
condition|)
block|{
name|get_length
operator|=
literal|1
expr_stmt|;
name|use_12byte
operator|=
literal|1
expr_stmt|;
goto|goto
name|retry_12byte
goto|;
block|}
name|dlist_length
operator|=
name|returned_length
operator|+
name|hdr_size
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"Error reading defect header"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|use_12byte
operator|==
literal|0
operator|)
operator|&&
operator|(
name|returned_length
operator|>=
name|max_possible_size
operator|)
condition|)
block|{
name|get_length
operator|=
literal|1
expr_stmt|;
name|use_12byte
operator|=
literal|1
expr_stmt|;
goto|goto
name|retry_12byte
goto|;
block|}
name|dlist_length
operator|=
name|returned_length
operator|+
name|hdr_size
expr_stmt|;
block|}
if|if
condition|(
name|summary
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%u"
argument_list|,
name|num_returned
argument_list|)
expr_stmt|;
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" defect%s"
argument_list|,
operator|(
name|num_returned
operator|!=
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
comment|/* 		 * We always limit the list length to the 10-byte maximum 		 * length (0xffff).  The reason is that some controllers 		 * can't handle larger I/Os, and we can transfer the entire 		 * 10 byte list in one shot.  For drives that support the 12 		 * byte read defects command, we'll step through the list 		 * by specifying a starting offset.  For drives that don't 		 * support the 12 byte command's starting offset, we'll 		 * just display the first 64K. 		 */
name|dlist_length
operator|=
name|min
argument_list|(
name|dlist_length
argument_list|,
name|SRDD10_MAX_LENGTH
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|==
name|SCSI_STATUS_CHECK_COND
operator|)
operator|&&
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|sense
operator|=
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|scsi_extract_sense_len
argument_list|(
name|sense
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|,
comment|/*show_errors*/
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * According to the SCSI spec, if the disk doesn't support 		 * the requested format, it will generally return a sense 		 * key of RECOVERED ERROR, and an additional sense code 		 * of "DEFECT LIST NOT FOUND".  HGST drives also return 		 * Primary/Grown defect list not found errors.  So just 		 * check for an ASC of 0x1c. 		 */
if|if
condition|(
operator|(
name|sense_key
operator|==
name|SSD_KEY_RECOVERED_ERROR
operator|)
operator|&&
operator|(
name|asc
operator|==
literal|0x1c
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|format_str
decl_stmt|;
name|format_str
operator|=
name|scsi_nv_to_str
argument_list|(
name|defect_list_type_map
argument_list|,
sizeof|sizeof
argument_list|(
name|defect_list_type_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|defect_list_type_map
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|list_format
operator|&
name|SRDD10_DLIST_FORMAT_MASK
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"requested defect format %s not available"
argument_list|,
name|format_str
condition|?
name|format_str
else|:
literal|"unknown"
argument_list|)
expr_stmt|;
name|format_str
operator|=
name|scsi_nv_to_str
argument_list|(
name|defect_list_type_map
argument_list|,
sizeof|sizeof
argument_list|(
name|defect_list_type_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|defect_list_type_map
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|returned_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|format_str
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Device returned %s format"
argument_list|,
name|format_str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"Device returned unknown defect"
literal|" data format %#x"
argument_list|,
name|returned_type
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
block|}
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"Error returned from read defect data command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"Error returned from read defect data command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
if|if
condition|(
name|first_pass
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Got %d defect"
argument_list|,
name|num_returned
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lists_specified
operator|==
literal|0
operator|)
operator|||
operator|(
name|num_returned
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s.\n"
argument_list|)
expr_stmt|;
goto|goto
name|defect_bailout
goto|;
block|}
elseif|else
if|if
condition|(
name|num_returned
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s:\n"
argument_list|)
expr_stmt|;
name|first_pass
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * XXX KDM  I should probably clean up the printout format for the 	 * disk defects. 	 */
switch|switch
condition|(
name|returned_type
condition|)
block|{
case|case
name|SRDD10_PHYSICAL_SECTOR_FORMAT
case|:
case|case
name|SRDD10_EXT_PHYS_FORMAT
case|:
block|{
name|struct
name|scsi_defect_desc_phys_sector
modifier|*
name|dlist
decl_stmt|;
name|dlist
operator|=
operator|(
expr|struct
name|scsi_defect_desc_phys_sector
operator|*
operator|)
operator|(
name|defect_list
operator|+
name|hdr_size
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_valid
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|sector
decl_stmt|;
name|sector
operator|=
name|scsi_4btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|sector
argument_list|)
expr_stmt|;
if|if
condition|(
name|returned_type
operator|==
name|SRDD10_EXT_PHYS_FORMAT
condition|)
block|{
name|mads
operator|=
operator|(
name|sector
operator|&
name|SDD_EXT_PHYS_MADS
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|sector
operator|&=
operator|~
name|SDD_EXT_PHYS_FLAG_MASK
expr_stmt|;
block|}
if|if
condition|(
name|hex_format
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d:%d:%d%s"
argument_list|,
name|scsi_3btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|cylinder
argument_list|)
argument_list|,
name|dlist
index|[
name|i
index|]
operator|.
name|head
argument_list|,
name|scsi_4btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|sector
argument_list|)
argument_list|,
name|mads
condition|?
literal|" - "
else|:
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"0x%x:0x%x:0x%x%s"
argument_list|,
name|scsi_3btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|cylinder
argument_list|)
argument_list|,
name|dlist
index|[
name|i
index|]
operator|.
name|head
argument_list|,
name|scsi_4btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|sector
argument_list|)
argument_list|,
name|mads
condition|?
literal|" - "
else|:
literal|"\n"
argument_list|)
expr_stmt|;
name|mads
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|num_valid
operator|<
name|num_returned
condition|)
block|{
name|starting_offset
operator|+=
name|num_valid
expr_stmt|;
goto|goto
name|next_batch
goto|;
block|}
break|break;
block|}
case|case
name|SRDD10_BYTES_FROM_INDEX_FORMAT
case|:
case|case
name|SRDD10_EXT_BFI_FORMAT
case|:
block|{
name|struct
name|scsi_defect_desc_bytes_from_index
modifier|*
name|dlist
decl_stmt|;
name|dlist
operator|=
operator|(
expr|struct
name|scsi_defect_desc_bytes_from_index
operator|*
operator|)
operator|(
name|defect_list
operator|+
name|hdr_size
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_valid
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|bfi
decl_stmt|;
name|bfi
operator|=
name|scsi_4btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|bytes_from_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|returned_type
operator|==
name|SRDD10_EXT_BFI_FORMAT
condition|)
block|{
name|mads
operator|=
operator|(
name|bfi
operator|&
name|SDD_EXT_BFI_MADS
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|bfi
operator|&=
operator|~
name|SDD_EXT_BFI_FLAG_MASK
expr_stmt|;
block|}
if|if
condition|(
name|hex_format
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d:%d:%d%s"
argument_list|,
name|scsi_3btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|cylinder
argument_list|)
argument_list|,
name|dlist
index|[
name|i
index|]
operator|.
name|head
argument_list|,
name|scsi_4btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|bytes_from_index
argument_list|)
argument_list|,
name|mads
condition|?
literal|" - "
else|:
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"0x%x:0x%x:0x%x%s"
argument_list|,
name|scsi_3btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|cylinder
argument_list|)
argument_list|,
name|dlist
index|[
name|i
index|]
operator|.
name|head
argument_list|,
name|scsi_4btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|bytes_from_index
argument_list|)
argument_list|,
name|mads
condition|?
literal|" - "
else|:
literal|"\n"
argument_list|)
expr_stmt|;
name|mads
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|num_valid
operator|<
name|num_returned
condition|)
block|{
name|starting_offset
operator|+=
name|num_valid
expr_stmt|;
goto|goto
name|next_batch
goto|;
block|}
break|break;
block|}
case|case
name|SRDDH10_BLOCK_FORMAT
case|:
block|{
name|struct
name|scsi_defect_desc_block
modifier|*
name|dlist
decl_stmt|;
name|dlist
operator|=
operator|(
expr|struct
name|scsi_defect_desc_block
operator|*
operator|)
operator|(
name|defect_list
operator|+
name|hdr_size
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_valid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hex_format
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%u\n"
argument_list|,
name|scsi_4btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|address
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"0x%x\n"
argument_list|,
name|scsi_4btoul
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|address
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_valid
operator|<
name|num_returned
condition|)
block|{
name|starting_offset
operator|+=
name|num_valid
expr_stmt|;
goto|goto
name|next_batch
goto|;
block|}
break|break;
block|}
case|case
name|SRDD10_LONG_BLOCK_FORMAT
case|:
block|{
name|struct
name|scsi_defect_desc_long_block
modifier|*
name|dlist
decl_stmt|;
name|dlist
operator|=
operator|(
expr|struct
name|scsi_defect_desc_long_block
operator|*
operator|)
operator|(
name|defect_list
operator|+
name|hdr_size
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_valid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hex_format
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|scsi_8btou64
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|address
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|scsi_8btou64
argument_list|(
name|dlist
index|[
name|i
index|]
operator|.
name|address
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_valid
operator|<
name|num_returned
condition|)
block|{
name|starting_offset
operator|+=
name|num_valid
expr_stmt|;
goto|goto
name|next_batch
goto|;
block|}
break|break;
block|}
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown defect format 0x%x\n"
argument_list|,
name|returned_type
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|defect_bailout
label|:
if|if
condition|(
name|defect_list
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|defect_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MINIMALISTIC */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void reassignblocks(struct cam_device *device, u_int32_t *blocks, int num_blocks) { 	union ccb *ccb;  	ccb = cam_getccb(device);  	cam_freeccb(ccb); }
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MINIMALISTIC
end_ifndef

begin_function
name|void
name|mode_sense
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|mode_page
parameter_list|,
name|int
name|page_control
parameter_list|,
name|int
name|dbd
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|int
name|datalen
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"mode_sense: couldn't allocate CCB"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_mode_sense
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* dbd */
name|dbd
argument_list|,
comment|/* page_code */
name|page_control
operator|<<
literal|6
argument_list|,
comment|/* page */
name|mode_page
argument_list|,
comment|/* param_buf */
name|data
argument_list|,
comment|/* param_len */
name|datalen
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|cam_close_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"error sending mode sense command"
argument_list|)
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error sending mode sense command"
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mode_select
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|save_pages
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|int
name|datalen
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"mode_select: couldn't allocate CCB"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_mode_select
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* scsi_page_fmt */
literal|1
argument_list|,
comment|/* save_pages */
name|save_pages
argument_list|,
comment|/* param_buf */
name|data
argument_list|,
comment|/* param_len */
name|datalen
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|cam_close_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"error sending mode select command"
argument_list|)
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error sending mode select command"
argument_list|)
expr_stmt|;
block|}
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|modepage
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|mode_page
init|=
operator|-
literal|1
decl_stmt|,
name|page_control
init|=
literal|0
decl_stmt|;
name|int
name|binary
init|=
literal|0
decl_stmt|,
name|list
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|binary
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|arglist
operator||=
name|CAM_ARG_DBD
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|arglist
operator||=
name|CAM_ARG_MODE_EDIT
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|list
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mode_page
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_page
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid mode page %d"
argument_list|,
name|mode_page
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|page_control
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|page_control
operator|<
literal|0
operator|)
operator|||
operator|(
name|page_control
operator|>
literal|3
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid page control field %d"
argument_list|,
name|page_control
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_PAGE_CNTL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|mode_page
operator|==
operator|-
literal|1
operator|&&
name|list
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"you must specify a mode page!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
block|{
name|mode_list
argument_list|(
name|device
argument_list|,
name|page_control
argument_list|,
name|arglist
operator|&
name|CAM_ARG_DBD
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mode_edit
argument_list|(
name|device
argument_list|,
name|mode_page
argument_list|,
name|page_control
argument_list|,
name|arglist
operator|&
name|CAM_ARG_DBD
argument_list|,
name|arglist
operator|&
name|CAM_ARG_MODE_EDIT
argument_list|,
name|binary
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|scsicmd
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int32_t
name|flags
init|=
name|CAM_DIR_NONE
decl_stmt|;
name|u_int8_t
modifier|*
name|data_ptr
init|=
name|NULL
decl_stmt|;
name|u_int8_t
name|cdb
index|[
literal|20
index|]
decl_stmt|;
name|u_int8_t
name|atacmd
index|[
literal|12
index|]
decl_stmt|;
name|struct
name|get_hook
name|hook
decl_stmt|;
name|int
name|c
decl_stmt|,
name|data_bytes
init|=
literal|0
decl_stmt|;
name|int
name|cdb_len
init|=
literal|0
decl_stmt|;
name|int
name|atacmd_len
init|=
literal|0
decl_stmt|;
name|int
name|dmacmd
init|=
literal|0
decl_stmt|;
name|int
name|fpdmacmd
init|=
literal|0
decl_stmt|;
name|int
name|need_res
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|datastr
init|=
name|NULL
decl_stmt|,
modifier|*
name|tstr
decl_stmt|,
modifier|*
name|resstr
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|fd_data
init|=
literal|0
decl_stmt|,
name|fd_res
init|=
literal|0
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"scsicmd: error allocating ccb"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|tstr
operator|=
name|optarg
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
name|hook
operator|.
name|argc
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|hook
operator|.
name|argv
operator|=
name|argv
operator|+
name|optind
expr_stmt|;
name|hook
operator|.
name|got
operator|=
literal|0
expr_stmt|;
name|atacmd_len
operator|=
name|buff_encode_visit
argument_list|(
name|atacmd
argument_list|,
sizeof|sizeof
argument_list|(
name|atacmd
argument_list|)
argument_list|,
name|tstr
argument_list|,
name|iget
argument_list|,
operator|&
name|hook
argument_list|)
expr_stmt|;
comment|/* 			 * Increment optind by the number of arguments the 			 * encoding routine processed.  After each call to 			 * getopt(3), optind points to the argument that 			 * getopt should process _next_.  In this case, 			 * that means it points to the first command string 			 * argument, if there is one.  Once we increment 			 * this, it should point to either the next command 			 * line argument, or it should be past the end of 			 * the list. 			 */
name|optind
operator|+=
name|hook
operator|.
name|got
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|tstr
operator|=
name|optarg
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
name|hook
operator|.
name|argc
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|hook
operator|.
name|argv
operator|=
name|argv
operator|+
name|optind
expr_stmt|;
name|hook
operator|.
name|got
operator|=
literal|0
expr_stmt|;
name|cdb_len
operator|=
name|buff_encode_visit
argument_list|(
name|cdb
argument_list|,
sizeof|sizeof
argument_list|(
name|cdb
argument_list|)
argument_list|,
name|tstr
argument_list|,
name|iget
argument_list|,
operator|&
name|hook
argument_list|)
expr_stmt|;
comment|/* 			 * Increment optind by the number of arguments the 			 * encoding routine processed.  After each call to 			 * getopt(3), optind points to the argument that 			 * getopt should process _next_.  In this case, 			 * that means it points to the first command string 			 * argument, if there is one.  Once we increment 			 * this, it should point to either the next command 			 * line argument, or it should be past the end of 			 * the list. 			 */
name|optind
operator|+=
name|hook
operator|.
name|got
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dmacmd
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fpdmacmd
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_CMD_OUT
condition|)
block|{
name|warnx
argument_list|(
literal|"command must either be "
literal|"read or write, not both"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
name|arglist
operator||=
name|CAM_ARG_CMD_IN
expr_stmt|;
name|flags
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|data_bytes
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_bytes
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid number of input bytes %d"
argument_list|,
name|data_bytes
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
name|hook
operator|.
name|argc
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|hook
operator|.
name|argv
operator|=
name|argv
operator|+
name|optind
expr_stmt|;
name|hook
operator|.
name|got
operator|=
literal|0
expr_stmt|;
name|optind
operator|++
expr_stmt|;
name|datastr
operator|=
name|cget
argument_list|(
operator|&
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * If the user supplied "-" instead of a format, he 			 * wants the data to be written to stdout. 			 */
if|if
condition|(
operator|(
name|datastr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|datastr
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
name|fd_data
operator|=
literal|1
expr_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|malloc
argument_list|(
name|data_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_ptr
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't malloc memory for data_ptr"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_CMD_IN
condition|)
block|{
name|warnx
argument_list|(
literal|"command must either be "
literal|"read or write, not both"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
name|arglist
operator||=
name|CAM_ARG_CMD_OUT
expr_stmt|;
name|flags
operator|=
name|CAM_DIR_OUT
expr_stmt|;
name|data_bytes
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_bytes
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid number of output bytes %d"
argument_list|,
name|data_bytes
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
name|hook
operator|.
name|argc
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|hook
operator|.
name|argv
operator|=
name|argv
operator|+
name|optind
expr_stmt|;
name|hook
operator|.
name|got
operator|=
literal|0
expr_stmt|;
name|datastr
operator|=
name|cget
argument_list|(
operator|&
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|malloc
argument_list|(
name|data_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_ptr
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't malloc memory for data_ptr"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
name|bzero
argument_list|(
name|data_ptr
argument_list|,
name|data_bytes
argument_list|)
expr_stmt|;
comment|/* 			 * If the user supplied "-" instead of a format, he 			 * wants the data to be read from stdin. 			 */
if|if
condition|(
operator|(
name|datastr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|datastr
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
name|fd_data
operator|=
literal|1
expr_stmt|;
else|else
name|buff_encode_visit
argument_list|(
name|data_ptr
argument_list|,
name|data_bytes
argument_list|,
name|datastr
argument_list|,
name|iget
argument_list|,
operator|&
name|hook
argument_list|)
expr_stmt|;
name|optind
operator|+=
name|hook
operator|.
name|got
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|need_res
operator|=
literal|1
expr_stmt|;
name|hook
operator|.
name|argc
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|hook
operator|.
name|argv
operator|=
name|argv
operator|+
name|optind
expr_stmt|;
name|hook
operator|.
name|got
operator|=
literal|0
expr_stmt|;
name|resstr
operator|=
name|cget
argument_list|(
operator|&
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|resstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|resstr
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
name|fd_res
operator|=
literal|1
expr_stmt|;
name|optind
operator|+=
name|hook
operator|.
name|got
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * If fd_data is set, and we're writing to the device, we need to 	 * read the data the user wants written from stdin. 	 */
if|if
condition|(
operator|(
name|fd_data
operator|==
literal|1
operator|)
operator|&&
operator|(
name|arglist
operator|&
name|CAM_ARG_CMD_OUT
operator|)
condition|)
block|{
name|ssize_t
name|amt_read
decl_stmt|;
name|int
name|amt_to_read
init|=
name|data_bytes
decl_stmt|;
name|u_int8_t
modifier|*
name|buf_ptr
init|=
name|data_ptr
decl_stmt|;
for|for
control|(
name|amt_read
operator|=
literal|0
init|;
name|amt_to_read
operator|>
literal|0
condition|;
name|amt_read
operator|=
name|read
argument_list|(
name|STDIN_FILENO
argument_list|,
name|buf_ptr
argument_list|,
name|amt_to_read
argument_list|)
control|)
block|{
if|if
condition|(
name|amt_read
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"error reading data from stdin"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
name|amt_to_read
operator|-=
name|amt_read
expr_stmt|;
name|buf_ptr
operator|+=
name|amt_read
expr_stmt|;
block|}
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
comment|/* Disable freezing the device queue */
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|cdb_len
condition|)
block|{
comment|/* 		 * This is taken from the SCSI-3 draft spec. 		 * (T10/1157D revision 0.3) 		 * The top 3 bits of an opcode are the group code. 		 * The next 5 bits are the command code. 		 * Group 0:  six byte commands 		 * Group 1:  ten byte commands 		 * Group 2:  ten byte commands 		 * Group 3:  reserved 		 * Group 4:  sixteen byte commands 		 * Group 5:  twelve byte commands 		 * Group 6:  vendor specific 		 * Group 7:  vendor specific 		 */
switch|switch
condition|(
operator|(
name|cdb
index|[
literal|0
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x7
condition|)
block|{
case|case
literal|0
case|:
name|cdb_len
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|cdb_len
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
comment|/* computed by buff_encode_visit */
break|break;
case|case
literal|4
case|:
name|cdb_len
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|cdb_len
operator|=
literal|12
expr_stmt|;
break|break;
block|}
comment|/* 		 * We should probably use csio_build_visit or something like that 		 * here, but it's easier to encode arguments as you go.  The 		 * alternative would be skipping the CDB argument and then encoding 		 * it here, since we've got the data buffer argument by now. 		 */
name|bcopy
argument_list|(
name|cdb
argument_list|,
operator|&
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|cdb_len
argument_list|)
expr_stmt|;
name|cam_fill_csio
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*flags*/
name|flags
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|data_bytes
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*cdb_len*/
name|cdb_len
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atacmd_len
operator|=
literal|12
expr_stmt|;
name|bcopy
argument_list|(
name|atacmd
argument_list|,
operator|&
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|command
argument_list|,
name|atacmd_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_res
condition|)
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator||=
name|CAM_ATAIO_NEEDRESULT
expr_stmt|;
if|if
condition|(
name|dmacmd
condition|)
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator||=
name|CAM_ATAIO_DMA
expr_stmt|;
if|if
condition|(
name|fpdmacmd
condition|)
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator||=
name|CAM_ATAIO_FPDMA
expr_stmt|;
name|cam_fill_ataio
argument_list|(
operator|&
name|ccb
operator|->
name|ataio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*flags*/
name|flags
argument_list|,
comment|/*tag_action*/
literal|0
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|data_bytes
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
specifier|const
name|char
name|warnstr
index|[]
init|=
literal|"error sending command"
decl_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|warn
argument_list|(
name|warnstr
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
name|warnstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
if|if
condition|(
name|atacmd_len
operator|&&
name|need_res
condition|)
block|{
if|if
condition|(
name|fd_res
operator|==
literal|0
condition|)
block|{
name|buff_decode_visit
argument_list|(
operator|&
name|ccb
operator|->
name|ataio
operator|.
name|res
operator|.
name|status
argument_list|,
literal|11
argument_list|,
name|resstr
argument_list|,
name|arg_put
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X\n"
argument_list|,
name|ccb
operator|->
name|ataio
operator|.
name|res
operator|.
name|status
argument_list|,
name|ccb
operator|->
name|ataio
operator|.
name|res
operator|.
name|error
argument_list|,
name|ccb
operator|->
name|ataio
operator|.
name|res
operator|.
name|lba_low
argument_list|,
name|ccb
operator|->
name|ataio
operator|.
name|res
operator|.
name|lba_mid
argument_list|,
name|ccb
operator|->
name|ataio
operator|.
name|res
operator|.
name|lba_high
argument_list|,
name|ccb
operator|->
name|ataio
operator|.
name|res
operator|.
name|device
argument_list|,
name|ccb
operator|->
name|ataio
operator|.
name|res
operator|.
name|lba_low_exp
argument_list|,
name|ccb
operator|->
name|ataio
operator|.
name|res
operator|.
name|lba_mid_exp
argument_list|,
name|ccb
operator|->
name|ataio
operator|.
name|res
operator|.
name|lba_high_exp
argument_list|,
name|ccb
operator|->
name|ataio
operator|.
name|res
operator|.
name|sector_count
argument_list|,
name|ccb
operator|->
name|ataio
operator|.
name|res
operator|.
name|sector_count_exp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|arglist
operator|&
name|CAM_ARG_CMD_IN
operator|)
operator|&&
operator|(
name|data_bytes
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|fd_data
operator|==
literal|0
condition|)
block|{
name|buff_decode_visit
argument_list|(
name|data_ptr
argument_list|,
name|data_bytes
argument_list|,
name|datastr
argument_list|,
name|arg_put
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ssize_t
name|amt_written
decl_stmt|;
name|int
name|amt_to_write
init|=
name|data_bytes
decl_stmt|;
name|u_int8_t
modifier|*
name|buf_ptr
init|=
name|data_ptr
decl_stmt|;
for|for
control|(
name|amt_written
operator|=
literal|0
init|;
operator|(
name|amt_to_write
operator|>
literal|0
operator|)
operator|&&
operator|(
name|amt_written
operator|=
name|write
argument_list|(
literal|1
argument_list|,
name|buf_ptr
argument_list|,
name|amt_to_write
argument_list|)
operator|)
operator|>
literal|0
condition|;
control|)
block|{
name|amt_to_write
operator|-=
name|amt_written
expr_stmt|;
name|buf_ptr
operator|+=
name|amt_written
expr_stmt|;
block|}
if|if
condition|(
name|amt_written
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"error writing data to stdout"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsicmd_bailout
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|amt_written
operator|==
literal|0
operator|)
operator|&&
operator|(
name|amt_to_write
operator|>
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"only wrote %u bytes out of %u"
argument_list|,
name|data_bytes
operator|-
name|amt_to_write
argument_list|,
name|data_bytes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|scsicmd_bailout
label|:
if|if
condition|(
operator|(
name|data_bytes
operator|>
literal|0
operator|)
operator|&&
operator|(
name|data_ptr
operator|!=
name|NULL
operator|)
condition|)
name|free
argument_list|(
name|data_ptr
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|camdebug
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|fd
decl_stmt|;
name|path_id_t
name|bus
init|=
name|CAM_BUS_WILDCARD
decl_stmt|;
name|target_id_t
name|target
init|=
name|CAM_TARGET_WILDCARD
decl_stmt|;
name|lun_id_t
name|lun
init|=
name|CAM_LUN_WILDCARD
decl_stmt|;
name|char
modifier|*
name|tstr
decl_stmt|,
modifier|*
name|tmpstr
init|=
name|NULL
decl_stmt|;
name|union
name|ccb
name|ccb
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|ccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'I'
case|:
name|arglist
operator||=
name|CAM_ARG_DEBUG_INFO
expr_stmt|;
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator||=
name|CAM_DEBUG_INFO
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|arglist
operator||=
name|CAM_ARG_DEBUG_PERIPH
expr_stmt|;
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator||=
name|CAM_DEBUG_PERIPH
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|arglist
operator||=
name|CAM_ARG_DEBUG_SUBTRACE
expr_stmt|;
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator||=
name|CAM_DEBUG_SUBTRACE
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|arglist
operator||=
name|CAM_ARG_DEBUG_TRACE
expr_stmt|;
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator||=
name|CAM_DEBUG_TRACE
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|arglist
operator||=
name|CAM_ARG_DEBUG_XPT
expr_stmt|;
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator||=
name|CAM_DEBUG_XPT
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|arglist
operator||=
name|CAM_ARG_DEBUG_CDB
expr_stmt|;
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator||=
name|CAM_DEBUG_CDB
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|arglist
operator||=
name|CAM_ARG_DEBUG_PROBE
expr_stmt|;
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator||=
name|CAM_DEBUG_PROBE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XPT_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"error opening transport layer device %s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"you must specify \"off\", \"all\" or a bus,"
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"bus:target, or bus:target:lun"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|tstr
operator|=
operator|*
name|argv
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|tstr
argument_list|,
literal|"off"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator|=
name|CAM_DEBUG_NONE
expr_stmt|;
name|arglist
operator|&=
operator|~
operator|(
name|CAM_ARG_DEBUG_INFO
operator||
name|CAM_ARG_DEBUG_PERIPH
operator||
name|CAM_ARG_DEBUG_TRACE
operator||
name|CAM_ARG_DEBUG_SUBTRACE
operator||
name|CAM_ARG_DEBUG_XPT
operator||
name|CAM_ARG_DEBUG_PROBE
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|tstr
argument_list|,
literal|"all"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|tstr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|bus
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_BUS
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|target
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_TARGET
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|lun
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_LUN
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"you must specify \"all\", \"off\", or a bus,"
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"bus:target, or bus:target:lun to debug"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEBUG
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|path_id
operator|=
name|bus
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|target
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|lun
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"CAMIOCOMMAND ioctl failed"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_FUNC_NOTAVAIL
condition|)
block|{
name|warnx
argument_list|(
literal|"CAM debugging not available"
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"you need to put options CAMDEBUG in"
literal|" your kernel config file!"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"XPT_DEBUG CCB failed with status %#x"
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ccb
operator|.
name|cdbg
operator|.
name|flags
operator|==
name|CAM_DEBUG_NONE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debugging turned off\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debugging enabled for "
literal|"%d:%d:%jx\n"
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lun
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tagcontrol
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|numtags
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|quiet
init|=
literal|0
decl_stmt|;
name|char
name|pathstr
index|[
literal|1024
index|]
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"tagcontrol: error allocating ccb"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'N'
case|:
name|numtags
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|numtags
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"tag count %d is< 0"
argument_list|,
name|numtags
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|tagcontrol_bailout
goto|;
block|}
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|cam_path_string
argument_list|(
name|device
argument_list|,
name|pathstr
argument_list|,
sizeof|sizeof
argument_list|(
name|pathstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numtags
operator|>=
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_relsim
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_REL_SIMQ
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DEV_QFREEZE
expr_stmt|;
name|ccb
operator|->
name|crs
operator|.
name|release_flags
operator|=
name|RELSIM_ADJUST_OPENINGS
expr_stmt|;
name|ccb
operator|->
name|crs
operator|.
name|openings
operator|=
name|numtags
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending XPT_REL_SIMQ CCB"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|tagcontrol_bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"XPT_REL_SIMQ CCB failed"
argument_list|)
expr_stmt|;
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|tagcontrol_bailout
goto|;
block|}
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%stagged openings now %d\n"
argument_list|,
name|pathstr
argument_list|,
name|ccb
operator|->
name|crs
operator|.
name|openings
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_getdevstats
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_STATS
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending XPT_GDEV_STATS CCB"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|tagcontrol_bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"XPT_GDEV_STATS CCB failed"
argument_list|)
expr_stmt|;
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|tagcontrol_bailout
goto|;
block|}
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"dev_openings  %d\n"
argument_list|,
name|ccb
operator|->
name|cgds
operator|.
name|dev_openings
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"dev_active    %d\n"
argument_list|,
name|ccb
operator|->
name|cgds
operator|.
name|dev_active
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"allocated     %d\n"
argument_list|,
name|ccb
operator|->
name|cgds
operator|.
name|allocated
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"queued        %d\n"
argument_list|,
name|ccb
operator|->
name|cgds
operator|.
name|queued
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"held          %d\n"
argument_list|,
name|ccb
operator|->
name|cgds
operator|.
name|held
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"mintags       %d\n"
argument_list|,
name|ccb
operator|->
name|cgds
operator|.
name|mintags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"maxtags       %d\n"
argument_list|,
name|ccb
operator|->
name|cgds
operator|.
name|maxtags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"device openings: "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d\n"
argument_list|,
name|ccb
operator|->
name|cgds
operator|.
name|dev_openings
operator|+
name|ccb
operator|->
name|cgds
operator|.
name|dev_active
argument_list|)
expr_stmt|;
block|}
name|tagcontrol_bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cts_print
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
block|{
name|char
name|pathstr
index|[
literal|1024
index|]
decl_stmt|;
name|cam_path_string
argument_list|(
name|device
argument_list|,
name|pathstr
argument_list|,
sizeof|sizeof
argument_list|(
name|pathstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|transport
operator|==
name|XPORT_SPI
condition|)
block|{
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%ssync parameter: %d\n"
argument_list|,
name|pathstr
argument_list|,
name|spi
operator|->
name|sync_period
argument_list|)
expr_stmt|;
if|if
condition|(
name|spi
operator|->
name|sync_offset
operator|!=
literal|0
condition|)
block|{
name|u_int
name|freq
decl_stmt|;
name|freq
operator|=
name|scsi_calc_syncsrate
argument_list|(
name|spi
operator|->
name|sync_period
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sfrequency: %d.%03dMHz\n"
argument_list|,
name|pathstr
argument_list|,
name|freq
operator|/
literal|1000
argument_list|,
name|freq
operator|%
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%soffset: %d\n"
argument_list|,
name|pathstr
argument_list|,
name|spi
operator|->
name|sync_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sbus width: %d bits\n"
argument_list|,
name|pathstr
argument_list|,
operator|(
literal|0x01
operator|<<
name|spi
operator|->
name|bus_width
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_DISC
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sdisconnection is %s\n"
argument_list|,
name|pathstr
argument_list|,
operator|(
name|spi
operator|->
name|flags
operator|&
name|CTS_SPI_FLAGS_DISC_ENB
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cts
operator|->
name|transport
operator|==
name|XPORT_FC
condition|)
block|{
name|struct
name|ccb_trans_settings_fc
modifier|*
name|fc
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|fc
decl_stmt|;
if|if
condition|(
name|fc
operator|->
name|valid
operator|&
name|CTS_FC_VALID_WWNN
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sWWNN: 0x%llx\n"
argument_list|,
name|pathstr
argument_list|,
operator|(
name|long
name|long
operator|)
name|fc
operator|->
name|wwnn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|->
name|valid
operator|&
name|CTS_FC_VALID_WWPN
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sWWPN: 0x%llx\n"
argument_list|,
name|pathstr
argument_list|,
operator|(
name|long
name|long
operator|)
name|fc
operator|->
name|wwpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|->
name|valid
operator|&
name|CTS_FC_VALID_PORT
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sPortID: 0x%x\n"
argument_list|,
name|pathstr
argument_list|,
name|fc
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|->
name|valid
operator|&
name|CTS_FC_VALID_SPEED
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%stransfer speed: %d.%03dMB/s\n"
argument_list|,
name|pathstr
argument_list|,
name|fc
operator|->
name|bitrate
operator|/
literal|1000
argument_list|,
name|fc
operator|->
name|bitrate
operator|%
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|transport
operator|==
name|XPORT_SAS
condition|)
block|{
name|struct
name|ccb_trans_settings_sas
modifier|*
name|sas
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|sas
decl_stmt|;
if|if
condition|(
name|sas
operator|->
name|valid
operator|&
name|CTS_SAS_VALID_SPEED
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%stransfer speed: %d.%03dMB/s\n"
argument_list|,
name|pathstr
argument_list|,
name|sas
operator|->
name|bitrate
operator|/
literal|1000
argument_list|,
name|sas
operator|->
name|bitrate
operator|%
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|transport
operator|==
name|XPORT_ATA
condition|)
block|{
name|struct
name|ccb_trans_settings_pata
modifier|*
name|pata
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|ata
decl_stmt|;
if|if
condition|(
operator|(
name|pata
operator|->
name|valid
operator|&
name|CTS_ATA_VALID_MODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sATA mode: %s\n"
argument_list|,
name|pathstr
argument_list|,
name|ata_mode2string
argument_list|(
name|pata
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pata
operator|->
name|valid
operator|&
name|CTS_ATA_VALID_ATAPI
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sATAPI packet length: %d\n"
argument_list|,
name|pathstr
argument_list|,
name|pata
operator|->
name|atapi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pata
operator|->
name|valid
operator|&
name|CTS_ATA_VALID_BYTECOUNT
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sPIO transaction length: %d\n"
argument_list|,
name|pathstr
argument_list|,
name|pata
operator|->
name|bytecount
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cts
operator|->
name|transport
operator|==
name|XPORT_SATA
condition|)
block|{
name|struct
name|ccb_trans_settings_sata
modifier|*
name|sata
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|sata
decl_stmt|;
if|if
condition|(
operator|(
name|sata
operator|->
name|valid
operator|&
name|CTS_SATA_VALID_REVISION
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sSATA revision: %d.x\n"
argument_list|,
name|pathstr
argument_list|,
name|sata
operator|->
name|revision
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sata
operator|->
name|valid
operator|&
name|CTS_SATA_VALID_MODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sATA mode: %s\n"
argument_list|,
name|pathstr
argument_list|,
name|ata_mode2string
argument_list|(
name|sata
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sata
operator|->
name|valid
operator|&
name|CTS_SATA_VALID_ATAPI
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sATAPI packet length: %d\n"
argument_list|,
name|pathstr
argument_list|,
name|sata
operator|->
name|atapi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sata
operator|->
name|valid
operator|&
name|CTS_SATA_VALID_BYTECOUNT
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sPIO transaction length: %d\n"
argument_list|,
name|pathstr
argument_list|,
name|sata
operator|->
name|bytecount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sata
operator|->
name|valid
operator|&
name|CTS_SATA_VALID_PM
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sPMP presence: %d\n"
argument_list|,
name|pathstr
argument_list|,
name|sata
operator|->
name|pm_present
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sata
operator|->
name|valid
operator|&
name|CTS_SATA_VALID_TAGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sNumber of tags: %d\n"
argument_list|,
name|pathstr
argument_list|,
name|sata
operator|->
name|tags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sata
operator|->
name|valid
operator|&
name|CTS_SATA_VALID_CAPS
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%sSATA capabilities: %08x\n"
argument_list|,
name|pathstr
argument_list|,
name|sata
operator|->
name|caps
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cts
operator|->
name|protocol
operator|==
name|PROTO_ATA
condition|)
block|{
name|struct
name|ccb_trans_settings_ata
modifier|*
name|ata
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|ata
decl_stmt|;
if|if
condition|(
name|ata
operator|->
name|valid
operator|&
name|CTS_ATA_VALID_TQ
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%stagged queueing: %s\n"
argument_list|,
name|pathstr
argument_list|,
operator|(
name|ata
operator|->
name|flags
operator|&
name|CTS_ATA_FLAGS_TAG_ENB
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cts
operator|->
name|protocol
operator|==
name|PROTO_SCSI
condition|)
block|{
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
if|if
condition|(
name|scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%stagged queueing: %s\n"
argument_list|,
name|pathstr
argument_list|,
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Get a path inquiry CCB for the specified device.  */
end_comment

begin_function
specifier|static
name|int
name|get_cpi
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|struct
name|ccb_pathinq
modifier|*
name|cpi
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"get_cpi: couldn't allocate CCB"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_pathinq
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"get_cpi: error sending Path Inquiry CCB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|get_cpi_bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|get_cpi_bailout
goto|;
block|}
name|bcopy
argument_list|(
operator|&
name|ccb
operator|->
name|cpi
argument_list|,
name|cpi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_pathinq
argument_list|)
argument_list|)
expr_stmt|;
name|get_cpi_bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a get device CCB for the specified device.  */
end_comment

begin_function
specifier|static
name|int
name|get_cgd
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|struct
name|ccb_getdev
modifier|*
name|cgd
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"get_cgd: couldn't allocate CCB"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_pathinq
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"get_cgd: error sending Path Inquiry CCB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|get_cgd_bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|get_cgd_bailout
goto|;
block|}
name|bcopy
argument_list|(
operator|&
name|ccb
operator|->
name|cgd
argument_list|,
name|cgd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_getdev
argument_list|)
argument_list|)
expr_stmt|;
name|get_cgd_bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 1 if the device has the VPD page, 0 if it does not, and -1 on an  * error.  */
end_comment

begin_function
name|int
name|dev_has_vpd_page
parameter_list|(
name|struct
name|cam_device
modifier|*
name|dev
parameter_list|,
name|uint8_t
name|page_id
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|verbosemode
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|NULL
decl_stmt|;
name|struct
name|scsi_vpd_supported_page_list
name|sup_pages
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"Unable to allocate CCB"
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* cam_getccb cleans up the header, caller has to zero the payload */
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sup_pages
argument_list|,
sizeof|sizeof
argument_list|(
name|sup_pages
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_inquiry
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* inq_buf */
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|sup_pages
argument_list|,
comment|/* inq_len */
sizeof|sizeof
argument_list|(
name|sup_pages
argument_list|)
argument_list|,
comment|/* evpd */
literal|1
argument_list|,
comment|/* page_code */
name|SVPD_SUPPORTED_PAGE_LIST
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|retry_count
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|verbosemode
operator|!=
literal|0
condition|)
name|cam_error_print
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sup_pages
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sup_pages
operator|.
name|list
index|[
name|i
index|]
operator|==
name|page_id
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
name|bailout
label|:
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * devtype is filled in with the type of device.  * Returns 0 for success, non-zero for failure.  */
end_comment

begin_function
name|int
name|get_device_type
parameter_list|(
name|struct
name|cam_device
modifier|*
name|dev
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|verbosemode
parameter_list|,
name|camcontrol_devtype
modifier|*
name|devtype
parameter_list|)
block|{
name|struct
name|ccb_getdev
name|cgd
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|=
name|get_cgd
argument_list|(
name|dev
argument_list|,
operator|&
name|cgd
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
switch|switch
condition|(
name|cgd
operator|.
name|protocol
condition|)
block|{
case|case
name|PROTO_SCSI
case|:
break|break;
case|case
name|PROTO_ATA
case|:
case|case
name|PROTO_ATAPI
case|:
case|case
name|PROTO_SATAPM
case|:
operator|*
name|devtype
operator|=
name|CC_DT_ATA
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/*NOTREACHED*/
default|default:
operator|*
name|devtype
operator|=
name|CC_DT_UNKNOWN
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/*NOTREACHED*/
block|}
comment|/* 	 * Check for the ATA Information VPD page (0x89).  If this is an 	 * ATA device behind a SCSI to ATA translation layer, this VPD page 	 * should be present. 	 * 	 * If that VPD page isn't present, or we get an error back from the 	 * INQUIRY command, we'll just treat it as a normal SCSI device. 	 */
name|retval
operator|=
name|dev_has_vpd_page
argument_list|(
name|dev
argument_list|,
name|SVPD_ATA_INFORMATION
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|verbosemode
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|1
condition|)
operator|*
name|devtype
operator|=
name|CC_DT_ATA_BEHIND_SCSI
expr_stmt|;
else|else
operator|*
name|devtype
operator|=
name|CC_DT_SCSI
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|build_ata_cmd
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|uint32_t
name|retry_count
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|uint8_t
name|tag_action
parameter_list|,
name|uint8_t
name|protocol
parameter_list|,
name|uint8_t
name|ata_flags
parameter_list|,
name|uint16_t
name|features
parameter_list|,
name|uint16_t
name|sector_count
parameter_list|,
name|uint64_t
name|lba
parameter_list|,
name|uint8_t
name|command
parameter_list|,
name|uint8_t
modifier|*
name|data_ptr
parameter_list|,
name|uint16_t
name|dxfer_len
parameter_list|,
name|uint8_t
name|sense_len
parameter_list|,
name|uint32_t
name|timeout
parameter_list|,
name|int
name|is48bit
parameter_list|,
name|camcontrol_devtype
name|devtype
parameter_list|)
block|{
if|if
condition|(
name|devtype
operator|==
name|CC_DT_ATA
condition|)
block|{
name|cam_fill_ataio
argument_list|(
operator|&
name|ccb
operator|->
name|ataio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*flags*/
name|flags
argument_list|,
comment|/*tag_action*/
name|tag_action
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|dxfer_len
argument_list|,
comment|/*timeout*/
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|is48bit
operator|||
name|lba
operator|>
name|ATA_MAX_28BIT_LBA
condition|)
name|ata_48bit_cmd
argument_list|(
operator|&
name|ccb
operator|->
name|ataio
argument_list|,
name|command
argument_list|,
name|features
argument_list|,
name|lba
argument_list|,
name|sector_count
argument_list|)
expr_stmt|;
else|else
name|ata_28bit_cmd
argument_list|(
operator|&
name|ccb
operator|->
name|ataio
argument_list|,
name|command
argument_list|,
name|features
argument_list|,
name|lba
argument_list|,
name|sector_count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is48bit
operator|||
name|lba
operator|>
name|ATA_MAX_28BIT_LBA
condition|)
name|protocol
operator||=
name|AP_EXTEND
expr_stmt|;
name|scsi_ata_pass_16
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*flags*/
name|flags
argument_list|,
comment|/*tag_action*/
name|tag_action
argument_list|,
comment|/*protocol*/
name|protocol
argument_list|,
comment|/*ata_flags*/
name|ata_flags
argument_list|,
comment|/*features*/
name|features
argument_list|,
comment|/*sector_count*/
name|sector_count
argument_list|,
comment|/*lba*/
name|lba
argument_list|,
comment|/*command*/
name|command
argument_list|,
comment|/*control*/
literal|0
argument_list|,
comment|/*data_ptr*/
name|data_ptr
argument_list|,
comment|/*dxfer_len*/
name|dxfer_len
argument_list|,
comment|/*sense_len*/
name|sense_len
argument_list|,
comment|/*timeout*/
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cpi_print
parameter_list|(
name|struct
name|ccb_pathinq
modifier|*
name|cpi
parameter_list|)
block|{
name|char
name|adapter_str
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|snprintf
argument_list|(
name|adapter_str
argument_list|,
sizeof|sizeof
argument_list|(
name|adapter_str
argument_list|)
argument_list|,
literal|"%s%d:"
argument_list|,
name|cpi
operator|->
name|dev_name
argument_list|,
name|cpi
operator|->
name|unit_number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s SIM/HBA version: %d\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|version_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|0xff
condition|;
name|i
operator|=
name|i
operator|<<
literal|1
control|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
name|cpi
operator|->
name|hba_inquiry
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s supports "
argument_list|,
name|adapter_str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|PI_MDP_ABLE
case|:
name|str
operator|=
literal|"MDP message"
expr_stmt|;
break|break;
case|case
name|PI_WIDE_32
case|:
name|str
operator|=
literal|"32 bit wide SCSI"
expr_stmt|;
break|break;
case|case
name|PI_WIDE_16
case|:
name|str
operator|=
literal|"16 bit wide SCSI"
expr_stmt|;
break|break;
case|case
name|PI_SDTR_ABLE
case|:
name|str
operator|=
literal|"SDTR message"
expr_stmt|;
break|break;
case|case
name|PI_LINKED_CDB
case|:
name|str
operator|=
literal|"linked CDBs"
expr_stmt|;
break|break;
case|case
name|PI_TAG_ABLE
case|:
name|str
operator|=
literal|"tag queue messages"
expr_stmt|;
break|break;
case|case
name|PI_SOFT_RST
case|:
name|str
operator|=
literal|"soft reset alternative"
expr_stmt|;
break|break;
case|case
name|PI_SATAPM
case|:
name|str
operator|=
literal|"SATA Port Multiplier"
expr_stmt|;
break|break;
default|default:
name|str
operator|=
literal|"unknown PI bit set"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|0xff
condition|;
name|i
operator|=
name|i
operator|<<
literal|1
control|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
name|cpi
operator|->
name|hba_misc
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s "
argument_list|,
name|adapter_str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|PIM_SCANHILO
case|:
name|str
operator|=
literal|"bus scans from high ID to low ID"
expr_stmt|;
break|break;
case|case
name|PIM_NOREMOVE
case|:
name|str
operator|=
literal|"removable devices not included in scan"
expr_stmt|;
break|break;
case|case
name|PIM_NOINITIATOR
case|:
name|str
operator|=
literal|"initiator role not supported"
expr_stmt|;
break|break;
case|case
name|PIM_NOBUSRESET
case|:
name|str
operator|=
literal|"user has disabled initial BUS RESET or"
literal|" controller is in target/mixed mode"
expr_stmt|;
break|break;
case|case
name|PIM_NO_6_BYTE
case|:
name|str
operator|=
literal|"do not send 6-byte commands"
expr_stmt|;
break|break;
case|case
name|PIM_SEQSCAN
case|:
name|str
operator|=
literal|"scan bus sequentially"
expr_stmt|;
break|break;
default|default:
name|str
operator|=
literal|"unknown PIM bit set"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|0xff
condition|;
name|i
operator|=
name|i
operator|<<
literal|1
control|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
name|cpi
operator|->
name|target_sprt
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s supports "
argument_list|,
name|adapter_str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|PIT_PROCESSOR
case|:
name|str
operator|=
literal|"target mode processor mode"
expr_stmt|;
break|break;
case|case
name|PIT_PHASE
case|:
name|str
operator|=
literal|"target mode phase cog. mode"
expr_stmt|;
break|break;
case|case
name|PIT_DISCONNECT
case|:
name|str
operator|=
literal|"disconnects in target mode"
expr_stmt|;
break|break;
case|case
name|PIT_TERM_IO
case|:
name|str
operator|=
literal|"terminate I/O message in target mode"
expr_stmt|;
break|break;
case|case
name|PIT_GRP_6
case|:
name|str
operator|=
literal|"group 6 commands in target mode"
expr_stmt|;
break|break;
case|case
name|PIT_GRP_7
case|:
name|str
operator|=
literal|"group 7 commands in target mode"
expr_stmt|;
break|break;
default|default:
name|str
operator|=
literal|"unknown PIT bit set"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s HBA engine count: %d\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|hba_eng_cnt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s maximum target: %d\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|max_target
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s maximum LUN: %d\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|max_lun
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s highest path ID in subsystem: %d\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|hpath_id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s initiator ID: %d\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|initiator_id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s SIM vendor: %s\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|sim_vid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s HBA vendor: %s\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|hba_vid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s HBA vendor ID: 0x%04x\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|hba_vendor
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s HBA device ID: 0x%04x\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|hba_device
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s HBA subvendor ID: 0x%04x\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|hba_subvendor
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s HBA subdevice ID: 0x%04x\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|hba_subdevice
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s bus ID: %d\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|bus_id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s base transfer speed: "
argument_list|,
name|adapter_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpi
operator|->
name|base_transfer_speed
operator|>
literal|1000
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d.%03dMB/sec\n"
argument_list|,
name|cpi
operator|->
name|base_transfer_speed
operator|/
literal|1000
argument_list|,
name|cpi
operator|->
name|base_transfer_speed
operator|%
literal|1000
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%dKB/sec\n"
argument_list|,
operator|(
name|cpi
operator|->
name|base_transfer_speed
operator|%
literal|1000
operator|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s maximum transfer size: %u bytes\n"
argument_list|,
name|adapter_str
argument_list|,
name|cpi
operator|->
name|maxio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_print_cts
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|user_settings
parameter_list|,
name|int
name|quiet
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"get_print_cts: error allocating ccb"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_trans_settings
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GET_TRAN_SETTINGS
expr_stmt|;
if|if
condition|(
name|user_settings
operator|==
literal|0
condition|)
name|ccb
operator|->
name|cts
operator|.
name|type
operator|=
name|CTS_TYPE_CURRENT_SETTINGS
expr_stmt|;
else|else
name|ccb
operator|->
name|cts
operator|.
name|type
operator|=
name|CTS_TYPE_USER_SETTINGS
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending XPT_GET_TRAN_SETTINGS CCB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|get_print_cts_bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"XPT_GET_TRANS_SETTINGS CCB failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|get_print_cts_bailout
goto|;
block|}
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|cts_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|cts
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
operator|&
name|ccb
operator|->
name|cts
argument_list|,
name|cts
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_trans_settings
argument_list|)
argument_list|)
expr_stmt|;
name|get_print_cts_bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ratecontrol
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|user_settings
init|=
literal|0
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|disc_enable
init|=
operator|-
literal|1
decl_stmt|,
name|tag_enable
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|mode
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|offset
init|=
operator|-
literal|1
decl_stmt|;
name|double
name|syncrate
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bus_width
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|quiet
init|=
literal|0
decl_stmt|;
name|int
name|change_settings
init|=
literal|0
decl_stmt|,
name|send_tur
init|=
literal|0
decl_stmt|;
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"ratecontrol: error allocating ccb"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|send_tur
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|user_settings
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|strncasecmp
argument_list|(
name|optarg
argument_list|,
literal|"enable"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|disc_enable
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|optarg
argument_list|,
literal|"disable"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|disc_enable
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"-D argument \"%s\" is unknown"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|change_settings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|mode
operator|=
name|ata_string2mode
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"unknown mode '%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|change_settings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|offset
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"offset value %d is< 0"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|change_settings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|++
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|syncrate
operator|=
name|atof
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|syncrate
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"sync rate %f is< 0"
argument_list|,
name|syncrate
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|change_settings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|strncasecmp
argument_list|(
name|optarg
argument_list|,
literal|"enable"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|tag_enable
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|optarg
argument_list|,
literal|"disable"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|tag_enable
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"-T argument \"%s\" is unknown"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|change_settings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|user_settings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|bus_width
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_width
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"bus width %d is< 0"
argument_list|,
name|bus_width
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|change_settings
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_pathinq
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Grab path inquiry information, so we can determine whether 	 * or not the initiator is capable of the things that the user 	 * requests. 	 */
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending XPT_PATH_INQ CCB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"XPT_PATH_INQ CCB failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|bcopy
argument_list|(
operator|&
name|ccb
operator|->
name|cpi
argument_list|,
operator|&
name|cpi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_pathinq
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_trans_settings
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s parameters:\n"
argument_list|,
name|user_settings
condition|?
literal|"User"
else|:
literal|"Current"
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|get_print_cts
argument_list|(
name|device
argument_list|,
name|user_settings
argument_list|,
name|quiet
argument_list|,
operator|&
name|ccb
operator|->
name|cts
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|ratecontrol_bailout
goto|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cpi_print
argument_list|(
operator|&
name|cpi
argument_list|)
expr_stmt|;
if|if
condition|(
name|change_settings
condition|)
block|{
name|int
name|didsettings
init|=
literal|0
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
name|NULL
decl_stmt|;
name|struct
name|ccb_trans_settings_pata
modifier|*
name|pata
init|=
name|NULL
decl_stmt|;
name|struct
name|ccb_trans_settings_sata
modifier|*
name|sata
init|=
name|NULL
decl_stmt|;
name|struct
name|ccb_trans_settings_ata
modifier|*
name|ata
init|=
name|NULL
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ccb
operator|->
name|cts
operator|.
name|transport
operator|==
name|XPORT_SPI
condition|)
name|spi
operator|=
operator|&
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|spi
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|cts
operator|.
name|transport
operator|==
name|XPORT_ATA
condition|)
name|pata
operator|=
operator|&
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|ata
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|cts
operator|.
name|transport
operator|==
name|XPORT_SATA
condition|)
name|sata
operator|=
operator|&
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|sata
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|cts
operator|.
name|protocol
operator|==
name|PROTO_ATA
condition|)
name|ata
operator|=
operator|&
name|ccb
operator|->
name|cts
operator|.
name|proto_specific
operator|.
name|ata
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|cts
operator|.
name|protocol
operator|==
name|PROTO_SCSI
condition|)
name|scsi
operator|=
operator|&
name|ccb
operator|->
name|cts
operator|.
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|xport_specific
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|cts
operator|.
name|proto_specific
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spi
operator|&&
name|disc_enable
operator|!=
operator|-
literal|1
condition|)
block|{
name|spi
operator|->
name|valid
operator||=
name|CTS_SPI_VALID_DISC
expr_stmt|;
if|if
condition|(
name|disc_enable
operator|==
literal|0
condition|)
name|spi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
else|else
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|didsettings
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tag_enable
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
name|PI_TAG_ABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"HBA does not support tagged queueing, "
literal|"so you cannot modify tag settings"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
if|if
condition|(
name|ata
condition|)
block|{
name|ata
operator|->
name|valid
operator||=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
if|if
condition|(
name|tag_enable
operator|==
literal|0
condition|)
name|ata
operator|->
name|flags
operator|&=
operator|~
name|CTS_ATA_FLAGS_TAG_ENB
expr_stmt|;
else|else
name|ata
operator|->
name|flags
operator||=
name|CTS_ATA_FLAGS_TAG_ENB
expr_stmt|;
name|didsettings
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scsi
condition|)
block|{
name|scsi
operator|->
name|valid
operator||=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
if|if
condition|(
name|tag_enable
operator|==
literal|0
condition|)
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
else|else
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|didsettings
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|spi
operator|&&
name|offset
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
name|PI_SDTR_ABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"HBA is not capable of changing offset"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|spi
operator|->
name|valid
operator||=
name|CTS_SPI_VALID_SYNC_OFFSET
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
name|offset
expr_stmt|;
name|didsettings
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|spi
operator|&&
name|syncrate
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|prelim_sync_period
decl_stmt|;
if|if
condition|(
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
name|PI_SDTR_ABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"HBA is not capable of changing "
literal|"transfer rates"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|spi
operator|->
name|valid
operator||=
name|CTS_SPI_VALID_SYNC_RATE
expr_stmt|;
comment|/* 			 * The sync rate the user gives us is in MHz. 			 * We need to translate it into KHz for this 			 * calculation. 			 */
name|syncrate
operator|*=
literal|1000
expr_stmt|;
comment|/* 			 * Next, we calculate a "preliminary" sync period 			 * in tenths of a nanosecond. 			 */
if|if
condition|(
name|syncrate
operator|==
literal|0
condition|)
name|prelim_sync_period
operator|=
literal|0
expr_stmt|;
else|else
name|prelim_sync_period
operator|=
literal|10000000
operator|/
name|syncrate
expr_stmt|;
name|spi
operator|->
name|sync_period
operator|=
name|scsi_calc_syncparam
argument_list|(
name|prelim_sync_period
argument_list|)
expr_stmt|;
name|didsettings
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sata
operator|&&
name|syncrate
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
name|PI_SDTR_ABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"HBA is not capable of changing "
literal|"transfer rates"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
if|if
condition|(
operator|!
name|user_settings
condition|)
block|{
name|warnx
argument_list|(
literal|"You can modify only user rate "
literal|"settings for SATA"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|sata
operator|->
name|revision
operator|=
name|ata_speed2revision
argument_list|(
name|syncrate
operator|*
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|sata
operator|->
name|revision
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid rate %f"
argument_list|,
name|syncrate
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|sata
operator|->
name|valid
operator||=
name|CTS_SATA_VALID_REVISION
expr_stmt|;
name|didsettings
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pata
operator|||
name|sata
operator|)
operator|&&
name|mode
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
name|PI_SDTR_ABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"HBA is not capable of changing "
literal|"transfer rates"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
if|if
condition|(
operator|!
name|user_settings
condition|)
block|{
name|warnx
argument_list|(
literal|"You can modify only user mode "
literal|"settings for ATA/SATA"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
if|if
condition|(
name|pata
condition|)
block|{
name|pata
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|pata
operator|->
name|valid
operator||=
name|CTS_ATA_VALID_MODE
expr_stmt|;
block|}
else|else
block|{
name|sata
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|sata
operator|->
name|valid
operator||=
name|CTS_SATA_VALID_MODE
expr_stmt|;
block|}
name|didsettings
operator|++
expr_stmt|;
block|}
comment|/* 		 * The bus_width argument goes like this: 		 * 0 == 8 bit 		 * 1 == 16 bit 		 * 2 == 32 bit 		 * Therefore, if you shift the number of bits given on the 		 * command line right by 4, you should get the correct 		 * number. 		 */
if|if
condition|(
name|spi
operator|&&
name|bus_width
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 			 * We might as well validate things here with a 			 * decipherable error message, rather than what 			 * will probably be an indecipherable error message 			 * by the time it gets back to us. 			 */
if|if
condition|(
operator|(
name|bus_width
operator|==
literal|16
operator|)
operator|&&
operator|(
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
name|PI_WIDE_16
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"HBA does not support 16 bit bus width"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bus_width
operator|==
literal|32
operator|)
operator|&&
operator|(
operator|(
name|cpi
operator|.
name|hba_inquiry
operator|&
name|PI_WIDE_32
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"HBA does not support 32 bit bus width"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bus_width
operator|!=
literal|8
operator|)
operator|&&
operator|(
name|bus_width
operator|!=
literal|16
operator|)
operator|&&
operator|(
name|bus_width
operator|!=
literal|32
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid bus width %d"
argument_list|,
name|bus_width
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|spi
operator|->
name|valid
operator||=
name|CTS_SPI_VALID_BUS_WIDTH
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|bus_width
operator|>>
literal|4
expr_stmt|;
name|didsettings
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|didsettings
operator|==
literal|0
condition|)
block|{
goto|goto
name|ratecontrol_bailout
goto|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SET_TRAN_SETTINGS
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending XPT_SET_TRAN_SETTINGS CCB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"XPT_SET_TRANS_SETTINGS CCB failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
block|}
if|if
condition|(
name|send_tur
condition|)
block|{
name|retval
operator|=
name|testunitready
argument_list|(
name|device
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
operator|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * If the TUR didn't succeed, just bail. 		 */
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Test Unit Ready failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|ratecontrol_bailout
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|change_settings
operator|||
name|send_tur
operator|)
operator|&&
operator|!
name|quiet
operator|&&
operator|(
name|ccb
operator|->
name|cts
operator|.
name|transport
operator|==
name|XPORT_ATA
operator|||
name|ccb
operator|->
name|cts
operator|.
name|transport
operator|==
name|XPORT_SATA
operator|||
name|send_tur
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"New parameters:\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|get_print_cts
argument_list|(
name|device
argument_list|,
name|user_settings
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ratecontrol_bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsiformat
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|ycount
init|=
literal|0
decl_stmt|,
name|quiet
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|use_timeout
init|=
literal|10800
operator|*
literal|1000
decl_stmt|;
name|int
name|immediate
init|=
literal|1
decl_stmt|;
name|struct
name|format_defect_list_header
name|fh
decl_stmt|;
name|u_int8_t
modifier|*
name|data_ptr
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|dxfer_len
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|byte2
init|=
literal|0
decl_stmt|;
name|int
name|num_warnings
init|=
literal|0
decl_stmt|;
name|int
name|reportonly
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"scsiformat: error allocating ccb"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'q'
case|:
name|quiet
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|reportonly
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|immediate
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|ycount
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|reportonly
condition|)
goto|goto
name|doreport
goto|;
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"You are about to REMOVE ALL DATA from the "
literal|"following device:\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|scsidoinquiry
argument_list|(
name|device
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"scsiformat: error sending inquiry"
argument_list|)
expr_stmt|;
goto|goto
name|scsiformat_bailout
goto|;
block|}
block|}
if|if
condition|(
name|ycount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|get_confirmation
argument_list|()
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsiformat_bailout
goto|;
block|}
block|}
if|if
condition|(
name|timeout
operator|!=
literal|0
condition|)
name|use_timeout
operator|=
name|timeout
expr_stmt|;
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Current format timeout is %d seconds\n"
argument_list|,
name|use_timeout
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the user hasn't disabled questions and didn't specify a 	 * timeout on the command line, ask them if they want the current 	 * timeout. 	 */
if|if
condition|(
operator|(
name|ycount
operator|==
literal|0
operator|)
operator|&&
operator|(
name|timeout
operator|==
literal|0
operator|)
condition|)
block|{
name|char
name|str
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|new_timeout
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Enter new timeout in seconds or press\n"
literal|"return to keep the current timeout [%d] "
argument_list|,
name|use_timeout
operator|/
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|new_timeout
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_timeout
operator|!=
literal|0
condition|)
block|{
name|use_timeout
operator|=
name|new_timeout
operator|*
literal|1000
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Using new timeout value %d\n"
argument_list|,
name|use_timeout
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Keep this outside the if block below to silence any unused 	 * variable warnings. 	 */
name|bzero
argument_list|(
operator|&
name|fh
argument_list|,
sizeof|sizeof
argument_list|(
name|fh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we're in immediate mode, we've got to include the format 	 * header 	 */
if|if
condition|(
name|immediate
operator|!=
literal|0
condition|)
block|{
name|fh
operator|.
name|byte2
operator|=
name|FU_DLH_IMMED
expr_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|fh
expr_stmt|;
name|dxfer_len
operator|=
sizeof|sizeof
argument_list|(
name|fh
argument_list|)
expr_stmt|;
name|byte2
operator|=
name|FU_FMT_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Formatting..."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|scsi_format_unit
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* byte2 */
name|byte2
argument_list|,
comment|/* ileave */
literal|0
argument_list|,
comment|/* data_ptr */
name|data_ptr
argument_list|,
comment|/* dxfer_len */
name|dxfer_len
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|use_timeout
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|immediate
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
operator|)
condition|)
block|{
specifier|const
name|char
name|errstr
index|[]
init|=
literal|"error sending format command"
decl_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|warn
argument_list|(
name|errstr
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsiformat_bailout
goto|;
block|}
comment|/* 	 * If we ran in non-immediate mode, we already checked for errors 	 * above and printed out any necessary information.  If we're in 	 * immediate mode, we need to loop through and get status 	 * information periodically. 	 */
if|if
condition|(
name|immediate
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Format Complete\n"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|scsiformat_bailout
goto|;
block|}
name|doreport
label|:
do|do
block|{
name|cam_status
name|status
decl_stmt|;
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * There's really no need to do error recovery or 		 * retries here, since we're just going to sit in a 		 * loop and wait for the device to finish formatting. 		 */
name|scsi_test_unit_ready
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|0
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* 		 * If we get an error from the ioctl, bail out.  SCSI 		 * errors are expected. 		 */
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending CAMIOCOMMAND ioctl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsiformat_bailout
goto|;
block|}
name|status
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|status
operator|==
name|CAM_SCSI_STATUS_ERROR
operator|)
operator|&&
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|sense
operator|=
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|scsi_extract_sense_len
argument_list|(
name|sense
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|,
comment|/*show_errors*/
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * According to the SCSI-2 and SCSI-3 specs, a 			 * drive that is in the middle of a format should 			 * return NOT READY with an ASC of "logical unit 			 * not ready, format in progress".  The sense key 			 * specific bytes will then be a progress indicator. 			 */
if|if
condition|(
operator|(
name|sense_key
operator|==
name|SSD_KEY_NOT_READY
operator|)
operator|&&
operator|(
name|asc
operator|==
literal|0x04
operator|)
operator|&&
operator|(
name|ascq
operator|==
literal|0x04
operator|)
condition|)
block|{
name|uint8_t
name|sks
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|scsi_get_sks
argument_list|(
name|sense
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
argument_list|,
name|sks
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|quiet
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|val
decl_stmt|;
name|u_int64_t
name|percentage
decl_stmt|;
name|val
operator|=
name|scsi_2btoul
argument_list|(
operator|&
name|sks
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|percentage
operator|=
literal|10000
operator|*
name|val
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\rFormatting:  %ju.%02u %% "
literal|"(%d/%d) done"
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|percentage
operator|/
operator|(
literal|0x10000
operator|*
literal|100
operator|)
argument_list|)
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|percentage
operator|/
literal|0x10000
operator|)
operator|%
literal|100
argument_list|)
argument_list|,
name|val
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|quiet
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|++
name|num_warnings
operator|<=
literal|1
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Unexpected SCSI Sense Key "
literal|"Specific value returned "
literal|"during format:"
argument_list|)
expr_stmt|;
name|scsi_sense_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"Unable to print status "
literal|"information, but format will "
literal|"proceed."
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"will exit when format is "
literal|"complete"
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"Unexpected SCSI error during format"
argument_list|)
expr_stmt|;
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsiformat_bailout
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"Unexpected CAM status %#x"
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsiformat_bailout
goto|;
block|}
block|}
do|while
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
do|;
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nFormat Complete\n"
argument_list|)
expr_stmt|;
name|scsiformat_bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsisanitize
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int8_t
name|action
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|ycount
init|=
literal|0
decl_stmt|,
name|quiet
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|use_timeout
init|=
literal|10800
operator|*
literal|1000
decl_stmt|;
name|int
name|immediate
init|=
literal|1
decl_stmt|;
name|int
name|invert
init|=
literal|0
decl_stmt|;
name|int
name|passes
init|=
literal|0
decl_stmt|;
name|int
name|ause
init|=
literal|0
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|pattern
init|=
name|NULL
decl_stmt|;
name|u_int8_t
modifier|*
name|data_ptr
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|dxfer_len
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|byte2
init|=
literal|0
decl_stmt|;
name|int
name|num_warnings
init|=
literal|0
decl_stmt|;
name|int
name|reportonly
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"scsisanitize: error allocating ccb"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"overwrite"
argument_list|)
operator|==
literal|0
condition|)
name|action
operator|=
name|SSZ_SERVICE_ACTION_OVERWRITE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"block"
argument_list|)
operator|==
literal|0
condition|)
name|action
operator|=
name|SSZ_SERVICE_ACTION_BLOCK_ERASE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"crypto"
argument_list|)
operator|==
literal|0
condition|)
name|action
operator|=
name|SSZ_SERVICE_ACTION_CRYPTO_ERASE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"exitfailure"
argument_list|)
operator|==
literal|0
condition|)
name|action
operator|=
name|SSZ_SERVICE_ACTION_EXIT_MODE_FAILURE
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"invalid service operation \"%s\""
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
break|break;
case|case
literal|'c'
case|:
name|passes
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passes
operator|<
literal|1
operator|||
name|passes
operator|>
literal|31
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid passes value %d"
argument_list|,
name|passes
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
break|break;
case|case
literal|'I'
case|:
name|invert
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|pattern
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|++
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|ause
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|reportonly
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|immediate
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|ycount
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|reportonly
condition|)
goto|goto
name|doreport
goto|;
if|if
condition|(
name|action
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"an action is required"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|SSZ_SERVICE_ACTION_OVERWRITE
condition|)
block|{
name|struct
name|scsi_sanitize_parameter_list
modifier|*
name|pl
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|ssize_t
name|sz
decl_stmt|,
name|amt
decl_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"overwrite action requires -P argument"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|pattern
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"cannot open pattern file %s"
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"cannot stat pattern file %s"
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
name|sz
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|SSZPL_MAX_PATTERN_LENGTH
condition|)
block|{
name|warnx
argument_list|(
literal|"pattern file size exceeds maximum value %d"
argument_list|,
name|SSZPL_MAX_PATTERN_LENGTH
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
name|dxfer_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|pl
argument_list|)
operator|+
name|sz
expr_stmt|;
name|data_ptr
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|dxfer_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_ptr
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"cannot allocate parameter list buffer"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
name|amt
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|data_ptr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|pl
argument_list|)
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"cannot read pattern file"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
elseif|else
if|if
condition|(
name|amt
operator|!=
name|sz
condition|)
block|{
name|warnx
argument_list|(
literal|"short pattern file read"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
name|pl
operator|=
operator|(
expr|struct
name|scsi_sanitize_parameter_list
operator|*
operator|)
name|data_ptr
expr_stmt|;
if|if
condition|(
name|passes
operator|==
literal|0
condition|)
name|pl
operator|->
name|byte1
operator|=
literal|1
expr_stmt|;
else|else
name|pl
operator|->
name|byte1
operator|=
name|passes
expr_stmt|;
if|if
condition|(
name|invert
operator|!=
literal|0
condition|)
name|pl
operator|->
name|byte1
operator||=
name|SSZPL_INVERT
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|sz
argument_list|,
name|pl
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
name|passes
operator|!=
literal|0
condition|)
name|arg
operator|=
literal|"-c"
expr_stmt|;
elseif|else
if|if
condition|(
name|invert
operator|!=
literal|0
condition|)
name|arg
operator|=
literal|"-I"
expr_stmt|;
elseif|else
if|if
condition|(
name|pattern
operator|!=
name|NULL
condition|)
name|arg
operator|=
literal|"-P"
expr_stmt|;
else|else
name|arg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s argument only valid with overwrite "
literal|"operation"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
block|}
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"You are about to REMOVE ALL DATA from the "
literal|"following device:\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|scsidoinquiry
argument_list|(
name|device
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"scsisanitize: error sending inquiry"
argument_list|)
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
block|}
if|if
condition|(
name|ycount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|get_confirmation
argument_list|()
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
block|}
if|if
condition|(
name|timeout
operator|!=
literal|0
condition|)
name|use_timeout
operator|=
name|timeout
expr_stmt|;
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Current sanitize timeout is %d seconds\n"
argument_list|,
name|use_timeout
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the user hasn't disabled questions and didn't specify a 	 * timeout on the command line, ask them if they want the current 	 * timeout. 	 */
if|if
condition|(
operator|(
name|ycount
operator|==
literal|0
operator|)
operator|&&
operator|(
name|timeout
operator|==
literal|0
operator|)
condition|)
block|{
name|char
name|str
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|new_timeout
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Enter new timeout in seconds or press\n"
literal|"return to keep the current timeout [%d] "
argument_list|,
name|use_timeout
operator|/
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|new_timeout
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_timeout
operator|!=
literal|0
condition|)
block|{
name|use_timeout
operator|=
name|new_timeout
operator|*
literal|1000
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Using new timeout value %d\n"
argument_list|,
name|use_timeout
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
name|byte2
operator|=
name|action
expr_stmt|;
if|if
condition|(
name|ause
operator|!=
literal|0
condition|)
name|byte2
operator||=
name|SSZ_UNRESTRICTED_EXIT
expr_stmt|;
if|if
condition|(
name|immediate
operator|!=
literal|0
condition|)
name|byte2
operator||=
name|SSZ_IMMED
expr_stmt|;
name|scsi_sanitize
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* byte2 */
name|byte2
argument_list|,
comment|/* control */
literal|0
argument_list|,
comment|/* data_ptr */
name|data_ptr
argument_list|,
comment|/* dxfer_len */
name|dxfer_len
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
name|use_timeout
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending sanitize command"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
condition|)
block|{
name|sense
operator|=
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|scsi_extract_sense_len
argument_list|(
name|sense
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|,
comment|/*show_errors*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense_key
operator|==
name|SSD_KEY_ILLEGAL_REQUEST
operator|&&
name|asc
operator|==
literal|0x20
operator|&&
name|ascq
operator|==
literal|0x00
condition|)
name|warnx
argument_list|(
literal|"sanitize is not supported by "
literal|"this device"
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"error sanitizing this device"
argument_list|)
expr_stmt|;
block|}
else|else
name|warnx
argument_list|(
literal|"error sanitizing this device"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
comment|/* 	 * If we ran in non-immediate mode, we already checked for errors 	 * above and printed out any necessary information.  If we're in 	 * immediate mode, we need to loop through and get status 	 * information periodically. 	 */
if|if
condition|(
name|immediate
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Sanitize Complete\n"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|scsisanitize_bailout
goto|;
block|}
name|doreport
label|:
do|do
block|{
name|cam_status
name|status
decl_stmt|;
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * There's really no need to do error recovery or 		 * retries here, since we're just going to sit in a 		 * loop and wait for the device to finish sanitizing. 		 */
name|scsi_test_unit_ready
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/* retries */
literal|0
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* timeout */
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* 		 * If we get an error from the ioctl, bail out.  SCSI 		 * errors are expected. 		 */
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending CAMIOCOMMAND ioctl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
name|status
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|status
operator|==
name|CAM_SCSI_STATUS_ERROR
operator|)
operator|&&
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|sense_key
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|sense
operator|=
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|scsi_extract_sense_len
argument_list|(
name|sense
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
argument_list|,
operator|&
name|error_code
argument_list|,
operator|&
name|sense_key
argument_list|,
operator|&
name|asc
argument_list|,
operator|&
name|ascq
argument_list|,
comment|/*show_errors*/
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * According to the SCSI-3 spec, a drive that is in the 			 * middle of a sanitize should return NOT READY with an 			 * ASC of "logical unit not ready, sanitize in 			 * progress". The sense key specific bytes will then 			 * be a progress indicator. 			 */
if|if
condition|(
operator|(
name|sense_key
operator|==
name|SSD_KEY_NOT_READY
operator|)
operator|&&
operator|(
name|asc
operator|==
literal|0x04
operator|)
operator|&&
operator|(
name|ascq
operator|==
literal|0x1b
operator|)
condition|)
block|{
name|uint8_t
name|sks
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|scsi_get_sks
argument_list|(
name|sense
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
argument_list|,
name|sks
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|quiet
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|val
decl_stmt|;
name|u_int64_t
name|percentage
decl_stmt|;
name|val
operator|=
name|scsi_2btoul
argument_list|(
operator|&
name|sks
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|percentage
operator|=
literal|10000
operator|*
name|val
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\rSanitizing:  %ju.%02u %% "
literal|"(%d/%d) done"
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|percentage
operator|/
operator|(
literal|0x10000
operator|*
literal|100
operator|)
argument_list|)
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|percentage
operator|/
literal|0x10000
operator|)
operator|%
literal|100
argument_list|)
argument_list|,
name|val
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|quiet
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|++
name|num_warnings
operator|<=
literal|1
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Unexpected SCSI Sense Key "
literal|"Specific value returned "
literal|"during sanitize:"
argument_list|)
expr_stmt|;
name|scsi_sense_print
argument_list|(
name|device
argument_list|,
operator|&
name|ccb
operator|->
name|csio
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"Unable to print status "
literal|"information, but sanitze will "
literal|"proceed."
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"will exit when sanitize is "
literal|"complete"
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"Unexpected SCSI error during sanitize"
argument_list|)
expr_stmt|;
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"Unexpected CAM status %#x"
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|scsisanitize_bailout
goto|;
block|}
block|}
do|while
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
do|;
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nSanitize Complete\n"
argument_list|)
expr_stmt|;
name|scsisanitize_bailout
label|:
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_ptr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|data_ptr
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsireportluns
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|c
decl_stmt|,
name|countonly
decl_stmt|,
name|lunsonly
decl_stmt|;
name|struct
name|scsi_report_luns_data
modifier|*
name|lundata
decl_stmt|;
name|int
name|alloc_len
decl_stmt|;
name|uint8_t
name|report_type
decl_stmt|;
name|uint32_t
name|list_len
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|lundata
operator|=
name|NULL
expr_stmt|;
name|report_type
operator|=
name|RPL_REPORT_DEFAULT
expr_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating ccb"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|countonly
operator|=
literal|0
expr_stmt|;
name|lunsonly
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|countonly
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lunsonly
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
condition|)
name|report_type
operator|=
name|RPL_REPORT_DEFAULT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"wellknown"
argument_list|)
operator|==
literal|0
condition|)
name|report_type
operator|=
name|RPL_REPORT_WELLKNOWN
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
name|report_type
operator|=
name|RPL_REPORT_ALL
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"%s: invalid report type \"%s\""
argument_list|,
name|__func__
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|countonly
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|lunsonly
operator|!=
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: you can only specify one of -c or -l"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * According to SPC-4, the allocation length must be at least 16 	 * bytes -- enough for the header and one LUN. 	 */
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|lundata
argument_list|)
operator|+
literal|8
expr_stmt|;
name|retry
label|:
name|lundata
operator|=
name|malloc
argument_list|(
name|alloc_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|lundata
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: error mallocing %d bytes"
argument_list|,
name|__func__
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|scsi_report_luns
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*select_report*/
name|report_type
argument_list|,
comment|/*rpl_buf*/
name|lundata
argument_list|,
comment|/*alloc_len*/
name|alloc_len
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending REPORT LUNS command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|list_len
operator|=
name|scsi_4btoul
argument_list|(
name|lundata
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * If we need to list the LUNs, and our allocation 	 * length was too short, reallocate and retry. 	 */
if|if
condition|(
operator|(
name|countonly
operator|==
literal|0
operator|)
operator|&&
operator|(
name|list_len
operator|>
operator|(
name|alloc_len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|lundata
argument_list|)
operator|)
operator|)
condition|)
block|{
name|alloc_len
operator|=
name|list_len
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|lundata
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lundata
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|lunsonly
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%u LUN%s found\n"
argument_list|,
name|list_len
operator|/
literal|8
argument_list|,
operator|(
operator|(
name|list_len
operator|/
literal|8
operator|)
operator|>
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|countonly
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|list_len
operator|/
literal|8
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|no_more
decl_stmt|;
name|no_more
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|lundata
operator|->
name|luns
index|[
name|i
index|]
operator|.
name|lundata
argument_list|)
condition|;
name|j
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|","
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lundata
operator|->
name|luns
index|[
name|i
index|]
operator|.
name|lundata
index|[
name|j
index|]
operator|&
name|RPL_LUNDATA_ATYP_MASK
condition|)
block|{
case|case
name|RPL_LUNDATA_ATYP_PERIPH
case|:
if|if
condition|(
operator|(
name|lundata
operator|->
name|luns
index|[
name|i
index|]
operator|.
name|lundata
index|[
name|j
index|]
operator|&
name|RPL_LUNDATA_PERIPH_BUS_MASK
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d:"
argument_list|,
name|lundata
operator|->
name|luns
index|[
name|i
index|]
operator|.
name|lundata
index|[
name|j
index|]
operator|&
name|RPL_LUNDATA_PERIPH_BUS_MASK
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|j
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|lundata
operator|->
name|luns
index|[
name|i
index|]
operator|.
name|lundata
index|[
name|j
operator|+
literal|2
index|]
operator|&
name|RPL_LUNDATA_PERIPH_BUS_MASK
operator|)
operator|==
literal|0
operator|)
condition|)
name|no_more
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d"
argument_list|,
name|lundata
operator|->
name|luns
index|[
name|i
index|]
operator|.
name|lundata
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|RPL_LUNDATA_ATYP_FLAT
case|:
block|{
name|uint8_t
name|tmplun
index|[
literal|2
index|]
decl_stmt|;
name|tmplun
index|[
literal|0
index|]
operator|=
name|lundata
operator|->
name|luns
index|[
name|i
index|]
operator|.
name|lundata
index|[
name|j
index|]
operator|&
name|RPL_LUNDATA_FLAT_LUN_MASK
expr_stmt|;
name|tmplun
index|[
literal|1
index|]
operator|=
name|lundata
operator|->
name|luns
index|[
name|i
index|]
operator|.
name|lundata
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d"
argument_list|,
name|scsi_2btoul
argument_list|(
name|tmplun
argument_list|)
argument_list|)
expr_stmt|;
name|no_more
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|RPL_LUNDATA_ATYP_LUN
case|:
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d:%d:%d"
argument_list|,
operator|(
name|lundata
operator|->
name|luns
index|[
name|i
index|]
operator|.
name|lundata
index|[
name|j
operator|+
literal|1
index|]
operator|&
name|RPL_LUNDATA_LUN_BUS_MASK
operator|)
operator|>>
literal|5
argument_list|,
name|lundata
operator|->
name|luns
index|[
name|i
index|]
operator|.
name|lundata
index|[
name|j
index|]
operator|&
name|RPL_LUNDATA_LUN_TARG_MASK
argument_list|,
name|lundata
operator|->
name|luns
index|[
name|i
index|]
operator|.
name|lundata
index|[
name|j
operator|+
literal|1
index|]
operator|&
name|RPL_LUNDATA_LUN_LUN_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|RPL_LUNDATA_ATYP_EXTLUN
case|:
block|{
name|int
name|field_len_code
decl_stmt|,
name|eam_code
decl_stmt|;
name|eam_code
operator|=
name|lundata
operator|->
name|luns
index|[
name|i
index|]
operator|.
name|lundata
index|[
name|j
index|]
operator|&
name|RPL_LUNDATA_EXT_EAM_MASK
expr_stmt|;
name|field_len_code
operator|=
operator|(
name|lundata
operator|->
name|luns
index|[
name|i
index|]
operator|.
name|lundata
index|[
name|j
index|]
operator|&
name|RPL_LUNDATA_EXT_LEN_MASK
operator|)
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|eam_code
operator|==
name|RPL_LUNDATA_EXT_EAM_WK
operator|)
operator|&&
operator|(
name|field_len_code
operator|==
literal|0x00
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d"
argument_list|,
name|lundata
operator|->
name|luns
index|[
name|i
index|]
operator|.
name|lundata
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|eam_code
operator|==
name|RPL_LUNDATA_EXT_EAM_NOT_SPEC
operator|)
operator|&&
operator|(
name|field_len_code
operator|==
literal|0x03
operator|)
condition|)
block|{
name|uint8_t
name|tmp_lun
index|[
literal|8
index|]
decl_stmt|;
comment|/* 					 * This format takes up all 8 bytes. 					 * If we aren't starting at offset 0, 					 * that's a bug. 					 */
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Invalid "
literal|"offset %d for "
literal|"Extended LUN not "
literal|"specified format"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|no_more
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
name|tmp_lun
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_lun
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|lundata
operator|->
name|luns
index|[
name|i
index|]
operator|.
name|lundata
index|[
name|j
operator|+
literal|1
index|]
argument_list|,
operator|&
name|tmp_lun
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_lun
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%#jx"
argument_list|,
operator|(
name|intmax_t
operator|)
name|scsi_8btou64
argument_list|(
name|tmp_lun
argument_list|)
argument_list|)
expr_stmt|;
name|no_more
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown Extended LUN"
literal|"Address method %#x, length "
literal|"code %#x"
argument_list|,
name|eam_code
argument_list|,
name|field_len_code
argument_list|)
expr_stmt|;
name|no_more
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown LUN address method "
literal|"%#x\n"
argument_list|,
name|lundata
operator|->
name|luns
index|[
name|i
index|]
operator|.
name|lundata
index|[
literal|0
index|]
operator|&
name|RPL_LUNDATA_ATYP_MASK
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * For the flat addressing method, there are no 			 * other levels after it. 			 */
if|if
condition|(
name|no_more
operator|!=
literal|0
condition|)
break|break;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lundata
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsireadcapacity
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|blocksizeonly
decl_stmt|,
name|humanize
decl_stmt|,
name|numblocks
decl_stmt|,
name|quiet
decl_stmt|,
name|sizeonly
decl_stmt|,
name|baseten
decl_stmt|;
name|struct
name|scsi_read_capacity_data
name|rcap
decl_stmt|;
name|struct
name|scsi_read_capacity_data_long
name|rcaplong
decl_stmt|;
name|uint64_t
name|maxsector
decl_stmt|;
name|uint32_t
name|block_len
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|c
decl_stmt|;
name|blocksizeonly
operator|=
literal|0
expr_stmt|;
name|humanize
operator|=
literal|0
expr_stmt|;
name|numblocks
operator|=
literal|0
expr_stmt|;
name|quiet
operator|=
literal|0
expr_stmt|;
name|sizeonly
operator|=
literal|0
expr_stmt|;
name|baseten
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating ccb"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|blocksizeonly
operator|++
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|humanize
operator|++
expr_stmt|;
name|baseten
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|humanize
operator|++
expr_stmt|;
name|baseten
operator|++
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|numblocks
operator|++
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sizeonly
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|blocksizeonly
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|numblocks
operator|!=
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: you can only specify one of -b or -N"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|blocksizeonly
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|sizeonly
operator|!=
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: you can only specify one of -b or -s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|humanize
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|quiet
operator|!=
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: you can only specify one of -h/-H or -q"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|humanize
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|blocksizeonly
operator|!=
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: you can only specify one of -h/-H or -b"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|scsi_read_capacity
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
operator|&
name|rcap
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending READ CAPACITY command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|maxsector
operator|=
name|scsi_4btoul
argument_list|(
name|rcap
operator|.
name|addr
argument_list|)
expr_stmt|;
name|block_len
operator|=
name|scsi_4btoul
argument_list|(
name|rcap
operator|.
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * A last block of 2^32-1 means that the true capacity is over 2TB, 	 * and we need to issue the long READ CAPACITY to get the real 	 * capacity.  Otherwise, we're all set. 	 */
if|if
condition|(
name|maxsector
operator|!=
literal|0xffffffff
condition|)
goto|goto
name|do_print
goto|;
name|scsi_read_capacity_16
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*reladdr*/
literal|0
argument_list|,
comment|/*pmi*/
literal|0
argument_list|,
comment|/*rcap_buf*/
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|rcaplong
argument_list|,
comment|/*rcap_buf_len*/
sizeof|sizeof
argument_list|(
name|rcaplong
argument_list|)
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending READ CAPACITY (16) command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|maxsector
operator|=
name|scsi_8btou64
argument_list|(
name|rcaplong
operator|.
name|addr
argument_list|)
expr_stmt|;
name|block_len
operator|=
name|scsi_4btoul
argument_list|(
name|rcaplong
operator|.
name|length
argument_list|)
expr_stmt|;
name|do_print
label|:
if|if
condition|(
name|blocksizeonly
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Humanize implies !quiet, and also implies numblocks. 		 */
if|if
condition|(
name|humanize
operator|!=
literal|0
condition|)
block|{
name|char
name|tmpstr
index|[
literal|6
index|]
decl_stmt|;
name|int64_t
name|tmpbytes
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|tmpbytes
operator|=
operator|(
name|maxsector
operator|+
literal|1
operator|)
operator|*
name|block_len
expr_stmt|;
name|ret
operator|=
name|humanize_number
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|tmpbytes
argument_list|,
literal|""
argument_list|,
name|HN_AUTOSCALE
argument_list|,
name|HN_B
operator||
name|HN_DECIMAL
operator||
operator|(
operator|(
name|baseten
operator|!=
literal|0
operator|)
condition|?
name|HN_DIVISOR_1000
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: humanize_number failed!"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Device Size: %s%s"
argument_list|,
name|tmpstr
argument_list|,
operator|(
name|sizeonly
operator|==
literal|0
operator|)
condition|?
literal|", "
else|:
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numblocks
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%ju%s"
argument_list|,
operator|(
name|quiet
operator|==
literal|0
operator|)
condition|?
literal|"Blocks: "
else|:
literal|""
argument_list|,
operator|(
name|uintmax_t
operator|)
name|maxsector
operator|+
literal|1
argument_list|,
operator|(
name|sizeonly
operator|==
literal|0
operator|)
condition|?
literal|", "
else|:
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%ju%s"
argument_list|,
operator|(
name|quiet
operator|==
literal|0
operator|)
condition|?
literal|"Last Block: "
else|:
literal|""
argument_list|,
operator|(
name|uintmax_t
operator|)
name|maxsector
argument_list|,
operator|(
name|sizeonly
operator|==
literal|0
operator|)
condition|?
literal|", "
else|:
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sizeonly
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%u%s\n"
argument_list|,
operator|(
name|quiet
operator|==
literal|0
operator|)
condition|?
literal|"Block Length: "
else|:
literal|""
argument_list|,
name|block_len
argument_list|,
operator|(
name|quiet
operator|==
literal|0
operator|)
condition|?
literal|" bytes"
else|:
literal|""
argument_list|)
expr_stmt|;
name|bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smpcmd
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|uint8_t
modifier|*
name|smp_request
init|=
name|NULL
decl_stmt|,
modifier|*
name|smp_response
init|=
name|NULL
decl_stmt|;
name|int
name|request_size
init|=
literal|0
decl_stmt|,
name|response_size
init|=
literal|0
decl_stmt|;
name|int
name|fd_request
init|=
literal|0
decl_stmt|,
name|fd_response
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|datastr
init|=
name|NULL
decl_stmt|;
name|struct
name|get_hook
name|hook
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|/* 	 * Note that at the moment we don't support sending SMP CCBs to 	 * devices that aren't probed by CAM. 	 */
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating CCB"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'R'
case|:
name|arglist
operator||=
name|CAM_ARG_CMD_IN
expr_stmt|;
name|response_size
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|response_size
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid number of response bytes %d"
argument_list|,
name|response_size
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|smpcmd_bailout
goto|;
block|}
name|hook
operator|.
name|argc
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|hook
operator|.
name|argv
operator|=
name|argv
operator|+
name|optind
expr_stmt|;
name|hook
operator|.
name|got
operator|=
literal|0
expr_stmt|;
name|optind
operator|++
expr_stmt|;
name|datastr
operator|=
name|cget
argument_list|(
operator|&
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * If the user supplied "-" instead of a format, he 			 * wants the data to be written to stdout. 			 */
if|if
condition|(
operator|(
name|datastr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|datastr
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
name|fd_response
operator|=
literal|1
expr_stmt|;
name|smp_response
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|malloc
argument_list|(
name|response_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|smp_response
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"can't malloc memory for SMP response"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|smpcmd_bailout
goto|;
block|}
break|break;
case|case
literal|'r'
case|:
name|arglist
operator||=
name|CAM_ARG_CMD_OUT
expr_stmt|;
name|request_size
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|request_size
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid number of request bytes %d"
argument_list|,
name|request_size
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|smpcmd_bailout
goto|;
block|}
name|hook
operator|.
name|argc
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|hook
operator|.
name|argv
operator|=
name|argv
operator|+
name|optind
expr_stmt|;
name|hook
operator|.
name|got
operator|=
literal|0
expr_stmt|;
name|datastr
operator|=
name|cget
argument_list|(
operator|&
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|smp_request
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|malloc
argument_list|(
name|request_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|smp_request
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"can't malloc memory for SMP request"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|smpcmd_bailout
goto|;
block|}
name|bzero
argument_list|(
name|smp_request
argument_list|,
name|request_size
argument_list|)
expr_stmt|;
comment|/* 			 * If the user supplied "-" instead of a format, he 			 * wants the data to be read from stdin. 			 */
if|if
condition|(
operator|(
name|datastr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|datastr
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
name|fd_request
operator|=
literal|1
expr_stmt|;
else|else
name|buff_encode_visit
argument_list|(
name|smp_request
argument_list|,
name|request_size
argument_list|,
name|datastr
argument_list|,
name|iget
argument_list|,
operator|&
name|hook
argument_list|)
expr_stmt|;
name|optind
operator|+=
name|hook
operator|.
name|got
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * If fd_data is set, and we're writing to the device, we need to 	 * read the data the user wants written from stdin. 	 */
if|if
condition|(
operator|(
name|fd_request
operator|==
literal|1
operator|)
operator|&&
operator|(
name|arglist
operator|&
name|CAM_ARG_CMD_OUT
operator|)
condition|)
block|{
name|ssize_t
name|amt_read
decl_stmt|;
name|int
name|amt_to_read
init|=
name|request_size
decl_stmt|;
name|u_int8_t
modifier|*
name|buf_ptr
init|=
name|smp_request
decl_stmt|;
for|for
control|(
name|amt_read
operator|=
literal|0
init|;
name|amt_to_read
operator|>
literal|0
condition|;
name|amt_read
operator|=
name|read
argument_list|(
name|STDIN_FILENO
argument_list|,
name|buf_ptr
argument_list|,
name|amt_to_read
argument_list|)
control|)
block|{
if|if
condition|(
name|amt_read
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"error reading data from stdin"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|smpcmd_bailout
goto|;
block|}
name|amt_to_read
operator|-=
name|amt_read
expr_stmt|;
name|buf_ptr
operator|+=
name|amt_read
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_CMD_IN
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_CMD_OUT
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: need both the request (-r) and response (-R) "
literal|"arguments"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|smpcmd_bailout
goto|;
block|}
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
name|cam_fill_smpio
argument_list|(
operator|&
name|ccb
operator|->
name|smpio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*flags*/
name|flags
argument_list|,
comment|/*smp_request*/
name|smp_request
argument_list|,
comment|/*smp_request_len*/
name|request_size
argument_list|,
comment|/*smp_response*/
name|smp_response
argument_list|,
comment|/*smp_response_len*/
name|response_size
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|smpio
operator|.
name|flags
operator|=
name|SMP_FLAG_NONE
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
specifier|const
name|char
name|warnstr
index|[]
init|=
literal|"error sending command"
decl_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|warn
argument_list|(
name|warnstr
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
name|warnstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|response_size
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|fd_response
operator|==
literal|0
condition|)
block|{
name|buff_decode_visit
argument_list|(
name|smp_response
argument_list|,
name|response_size
argument_list|,
name|datastr
argument_list|,
name|arg_put
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ssize_t
name|amt_written
decl_stmt|;
name|int
name|amt_to_write
init|=
name|response_size
decl_stmt|;
name|u_int8_t
modifier|*
name|buf_ptr
init|=
name|smp_response
decl_stmt|;
for|for
control|(
name|amt_written
operator|=
literal|0
init|;
operator|(
name|amt_to_write
operator|>
literal|0
operator|)
operator|&&
operator|(
name|amt_written
operator|=
name|write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|buf_ptr
argument_list|,
name|amt_to_write
argument_list|)
operator|)
operator|>
literal|0
condition|;
control|)
block|{
name|amt_to_write
operator|-=
name|amt_written
expr_stmt|;
name|buf_ptr
operator|+=
name|amt_written
expr_stmt|;
block|}
if|if
condition|(
name|amt_written
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"error writing data to stdout"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|smpcmd_bailout
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|amt_written
operator|==
literal|0
operator|)
operator|&&
operator|(
name|amt_to_write
operator|>
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"only wrote %u bytes out of %u"
argument_list|,
name|response_size
operator|-
name|amt_to_write
argument_list|,
name|response_size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|smpcmd_bailout
label|:
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|smp_request
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|smp_request
argument_list|)
expr_stmt|;
if|if
condition|(
name|smp_response
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|smp_response
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smpreportgeneral
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|smp_report_general_request
modifier|*
name|request
init|=
name|NULL
decl_stmt|;
name|struct
name|smp_report_general_response
modifier|*
name|response
init|=
name|NULL
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|,
name|long_response
init|=
literal|0
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/* 	 * Note that at the moment we don't support sending SMP CCBs to 	 * devices that aren't probed by CAM. 	 */
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating CCB"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
name|long_response
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|request
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: unable to allocate %zd bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|response
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|response
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: unable to allocate %zd bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|response
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|try_long
label|:
name|smp_report_general
argument_list|(
operator|&
name|ccb
operator|->
name|smpio
argument_list|,
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
name|request
argument_list|,
comment|/*request_len*/
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|response
argument_list|,
comment|/*response_len*/
sizeof|sizeof
argument_list|(
operator|*
name|response
argument_list|)
argument_list|,
comment|/*long_response*/
name|long_response
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
specifier|const
name|char
name|warnstr
index|[]
init|=
literal|"error sending command"
decl_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|warn
argument_list|(
name|warnstr
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
name|warnstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * If the device supports the long response bit, try again and see 	 * if we can get all of the data. 	 */
if|if
condition|(
operator|(
name|response
operator|->
name|long_response
operator|&
name|SMP_RG_LONG_RESPONSE
operator|)
operator|&&
operator|(
name|long_response
operator|==
literal|0
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|long_response
operator|=
literal|1
expr_stmt|;
goto|goto
name|try_long
goto|;
block|}
comment|/* 	 * XXX KDM detect and decode SMP errors here. 	 */
name|sb
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating sbuf"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|smp_report_general_sbuf
argument_list|(
name|response
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|response
argument_list|)
argument_list|,
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: sbuf_finish"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|bailout
label|:
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|camcontrol_opts
name|phy_ops
index|[]
init|=
block|{
block|{
literal|"nop"
block|,
name|SMP_PC_PHY_OP_NOP
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"linkreset"
block|,
name|SMP_PC_PHY_OP_LINK_RESET
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"hardreset"
block|,
name|SMP_PC_PHY_OP_HARD_RESET
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"disable"
block|,
name|SMP_PC_PHY_OP_DISABLE
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"clearerrlog"
block|,
name|SMP_PC_PHY_OP_CLEAR_ERR_LOG
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"clearaffiliation"
block|,
name|SMP_PC_PHY_OP_CLEAR_AFFILIATON
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"sataportsel"
block|,
name|SMP_PC_PHY_OP_TRANS_SATA_PSS
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"clearitnl"
block|,
name|SMP_PC_PHY_OP_CLEAR_STP_ITN_LS
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
literal|"setdevname"
block|,
name|SMP_PC_PHY_OP_SET_ATT_DEV_NAME
block|,
name|CAM_ARG_NONE
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|smpphycontrol
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|smp_phy_control_request
modifier|*
name|request
init|=
name|NULL
decl_stmt|;
name|struct
name|smp_phy_control_response
modifier|*
name|response
init|=
name|NULL
decl_stmt|;
name|int
name|long_response
init|=
literal|0
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|phy
init|=
operator|-
literal|1
decl_stmt|;
name|uint32_t
name|phy_operation
init|=
name|SMP_PC_PHY_OP_NOP
decl_stmt|;
name|int
name|phy_op_set
init|=
literal|0
decl_stmt|;
name|uint64_t
name|attached_dev_name
init|=
literal|0
decl_stmt|;
name|int
name|dev_name_set
init|=
literal|0
decl_stmt|;
name|uint32_t
name|min_plr
init|=
literal|0
decl_stmt|,
name|max_plr
init|=
literal|0
decl_stmt|;
name|uint32_t
name|pp_timeout_val
init|=
literal|0
decl_stmt|;
name|int
name|slumber_partial
init|=
literal|0
decl_stmt|;
name|int
name|set_pp_timeout_val
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* 	 * Note that at the moment we don't support sending SMP CCBs to 	 * devices that aren't probed by CAM. 	 */
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating CCB"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
block|{
name|int
name|enable
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"enable"
argument_list|)
operator|==
literal|0
condition|)
name|enable
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"disable"
argument_list|)
operator|==
literal|0
condition|)
name|enable
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"%s: Invalid argument %s"
argument_list|,
name|__func__
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'s'
case|:
name|slumber_partial
operator||=
name|enable
operator|<<
name|SMP_PC_SAS_SLUMBER_SHIFT
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|slumber_partial
operator||=
name|enable
operator|<<
name|SMP_PC_SAS_PARTIAL_SHIFT
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|slumber_partial
operator||=
name|enable
operator|<<
name|SMP_PC_SATA_SLUMBER_SHIFT
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|slumber_partial
operator||=
name|enable
operator|<<
name|SMP_PC_SATA_PARTIAL_SHIFT
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"%s: programmer error"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/*NOTREACHED*/
block|}
break|break;
block|}
case|case
literal|'d'
case|:
name|attached_dev_name
operator|=
operator|(
name|uintmax_t
operator|)
name|strtoumax
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dev_name_set
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|long_response
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* 			 * We don't do extensive checking here, so this 			 * will continue to work when new speeds come out. 			 */
name|min_plr
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|min_plr
operator|==
literal|0
operator|)
operator|||
operator|(
name|min_plr
operator|>
literal|0xf
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: invalid link rate %x"
argument_list|,
name|__func__
argument_list|,
name|min_plr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
case|case
literal|'M'
case|:
comment|/* 			 * We don't do extensive checking here, so this 			 * will continue to work when new speeds come out. 			 */
name|max_plr
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|max_plr
operator|==
literal|0
operator|)
operator|||
operator|(
name|max_plr
operator|>
literal|0xf
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: invalid link rate %x"
argument_list|,
name|__func__
argument_list|,
name|max_plr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
case|case
literal|'o'
case|:
block|{
name|camcontrol_optret
name|optreturn
decl_stmt|;
name|cam_argmask
name|argnums
decl_stmt|;
specifier|const
name|char
modifier|*
name|subopt
decl_stmt|;
if|if
condition|(
name|phy_op_set
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: only one phy operation argument "
literal|"(-o) allowed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|phy_op_set
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Allow the user to specify the phy operation 			 * numerically, as well as with a name.  This will 			 * future-proof it a bit, so options that are added 			 * in future specs can be used. 			 */
if|if
condition|(
name|isdigit
argument_list|(
name|optarg
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|phy_operation
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|phy_operation
operator|==
literal|0
operator|)
operator|||
operator|(
name|phy_operation
operator|>
literal|0xff
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: invalid phy operation %#x"
argument_list|,
name|__func__
argument_list|,
name|phy_operation
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
block|}
name|optreturn
operator|=
name|getoption
argument_list|(
name|phy_ops
argument_list|,
name|optarg
argument_list|,
operator|&
name|phy_operation
argument_list|,
operator|&
name|argnums
argument_list|,
operator|&
name|subopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|optreturn
operator|==
name|CC_OR_AMBIGUOUS
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: ambiguous option %s"
argument_list|,
name|__func__
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
elseif|else
if|if
condition|(
name|optreturn
operator|==
name|CC_OR_NOT_FOUND
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: option %s not found"
argument_list|,
name|__func__
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
block|}
case|case
literal|'p'
case|:
name|phy
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|pp_timeout_val
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp_timeout_val
operator|>
literal|15
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: invalid partial pathway timeout "
literal|"value %u, need a value less than 16"
argument_list|,
name|__func__
argument_list|,
name|pp_timeout_val
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|set_pp_timeout_val
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|phy
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: a PHY (-p phy) argument is required"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|dev_name_set
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|phy_operation
operator|!=
name|SMP_PC_PHY_OP_SET_ATT_DEV_NAME
operator|)
operator|)
operator|||
operator|(
operator|(
name|phy_operation
operator|==
name|SMP_PC_PHY_OP_SET_ATT_DEV_NAME
operator|)
operator|&&
operator|(
name|dev_name_set
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: -d name and -o setdevname arguments both "
literal|"required to set device name"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|request
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: unable to allocate %zd bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|response
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|response
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: unable to allocate %zd bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|smp_phy_control
argument_list|(
operator|&
name|ccb
operator|->
name|smpio
argument_list|,
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
name|request
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|request
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|response
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|response
argument_list|)
argument_list|,
name|long_response
argument_list|,
comment|/*expected_exp_change_count*/
literal|0
argument_list|,
name|phy
argument_list|,
name|phy_operation
argument_list|,
operator|(
name|set_pp_timeout_val
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|attached_dev_name
argument_list|,
name|min_plr
argument_list|,
name|max_plr
argument_list|,
name|slumber_partial
argument_list|,
name|pp_timeout_val
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
specifier|const
name|char
name|warnstr
index|[]
init|=
literal|"error sending command"
decl_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|warn
argument_list|(
name|warnstr
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
name|warnstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
comment|/* 			 * Use CAM_EPF_NORMAL so we only get one line of 			 * SMP command decoding. 			 */
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_NORMAL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* XXX KDM print out something here for success? */
name|bailout
label|:
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|response
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smpmaninfo
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|smp_report_manuf_info_request
name|request
decl_stmt|;
name|struct
name|smp_report_manuf_info_response
name|response
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
init|=
name|NULL
decl_stmt|;
name|int
name|long_response
init|=
literal|0
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* 	 * Note that at the moment we don't support sending SMP CCBs to 	 * devices that aren't probed by CAM. 	 */
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating CCB"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
name|long_response
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|bzero
argument_list|(
operator|&
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|response
argument_list|,
sizeof|sizeof
argument_list|(
name|response
argument_list|)
argument_list|)
expr_stmt|;
name|smp_report_manuf_info
argument_list|(
operator|&
name|ccb
operator|->
name|smpio
argument_list|,
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
operator|&
name|request
argument_list|,
sizeof|sizeof
argument_list|(
name|request
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|response
argument_list|,
sizeof|sizeof
argument_list|(
name|response
argument_list|)
argument_list|,
name|long_response
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
specifier|const
name|char
name|warnstr
index|[]
init|=
literal|"error sending command"
decl_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|warn
argument_list|(
name|warnstr
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
name|warnstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|sb
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating sbuf"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|smp_report_manuf_info_sbuf
argument_list|(
operator|&
name|response
argument_list|,
sizeof|sizeof
argument_list|(
name|response
argument_list|)
argument_list|,
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: sbuf_finish"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|bailout
label|:
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getdevid
parameter_list|(
name|struct
name|cam_devitem
modifier|*
name|item
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|NULL
decl_stmt|;
name|struct
name|cam_device
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|cam_open_btl
argument_list|(
name|item
operator|->
name|dev_match
operator|.
name|path_id
argument_list|,
name|item
operator|->
name|dev_match
operator|.
name|target_id
argument_list|,
name|item
operator|->
name|dev_match
operator|.
name|target_lun
argument_list|,
name|O_RDWR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s"
argument_list|,
name|cam_errbuf
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|item
operator|->
name|device_id_len
operator|=
literal|0
expr_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating CCB"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * On the first try, we just probe for the size of the data, and 	 * then allocate that much memory and try again. 	 */
name|retry
label|:
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEV_ADVINFO
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|ccb
operator|->
name|cdai
operator|.
name|flags
operator|=
name|CDAI_FLAG_NONE
expr_stmt|;
name|ccb
operator|->
name|cdai
operator|.
name|buftype
operator|=
name|CDAI_TYPE_SCSI_DEVID
expr_stmt|;
name|ccb
operator|->
name|cdai
operator|.
name|bufsiz
operator|=
name|item
operator|->
name|device_id_len
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|device_id_len
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|cdai
operator|.
name|buf
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|item
operator|->
name|device_id
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: error sending XPT_GDEV_ADVINFO CCB"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: CAM status %#x"
argument_list|,
name|__func__
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|item
operator|->
name|device_id_len
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This is our first time through.  Allocate the buffer, 		 * and then go back to get the data. 		 */
if|if
condition|(
name|ccb
operator|->
name|cdai
operator|.
name|provsiz
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: invalid .provsiz field returned with "
literal|"XPT_GDEV_ADVINFO CCB"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|item
operator|->
name|device_id_len
operator|=
name|ccb
operator|->
name|cdai
operator|.
name|provsiz
expr_stmt|;
name|item
operator|->
name|device_id
operator|=
name|malloc
argument_list|(
name|item
operator|->
name|device_id_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|device_id
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: unable to allocate %d bytes"
argument_list|,
name|__func__
argument_list|,
name|item
operator|->
name|device_id_len
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|bailout
label|:
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
name|cam_close_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX KDM merge this code with getdevtree()?  */
end_comment

begin_function
specifier|static
name|int
name|buildbusdevlist
parameter_list|(
name|struct
name|cam_devlist
modifier|*
name|devlist
parameter_list|)
block|{
name|union
name|ccb
name|ccb
decl_stmt|;
name|int
name|bufsize
decl_stmt|,
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|dev_match_pattern
modifier|*
name|patterns
decl_stmt|;
name|struct
name|cam_devitem
modifier|*
name|item
init|=
name|NULL
decl_stmt|;
name|int
name|skip_device
init|=
literal|0
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XPT_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"couldn't open %s"
argument_list|,
name|XPT_DEVICE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|ccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|path_id
operator|=
name|CAM_XPT_PATH_ID
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_id
operator|=
name|CAM_TARGET_WILDCARD
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|target_lun
operator|=
name|CAM_LUN_WILDCARD
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEV_MATCH
expr_stmt|;
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
operator|*
literal|100
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|match_buf_len
operator|=
name|bufsize
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|matches
operator|=
operator|(
expr|struct
name|dev_match_result
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|.
name|cdm
operator|.
name|matches
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't malloc memory for matches"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ccb
operator|.
name|cdm
operator|.
name|num_matches
operator|=
literal|0
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|num_patterns
operator|=
literal|2
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|pattern_buf_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_pattern
argument_list|)
operator|*
name|ccb
operator|.
name|cdm
operator|.
name|num_patterns
expr_stmt|;
name|patterns
operator|=
operator|(
expr|struct
name|dev_match_pattern
operator|*
operator|)
name|malloc
argument_list|(
name|ccb
operator|.
name|cdm
operator|.
name|pattern_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|patterns
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't malloc memory for patterns"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|ccb
operator|.
name|cdm
operator|.
name|patterns
operator|=
name|patterns
expr_stmt|;
name|bzero
argument_list|(
name|patterns
argument_list|,
name|ccb
operator|.
name|cdm
operator|.
name|pattern_buf_len
argument_list|)
expr_stmt|;
name|patterns
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|DEV_MATCH_DEVICE
expr_stmt|;
name|patterns
index|[
literal|0
index|]
operator|.
name|pattern
operator|.
name|device_pattern
operator|.
name|flags
operator|=
name|DEV_MATCH_PATH
expr_stmt|;
name|patterns
index|[
literal|0
index|]
operator|.
name|pattern
operator|.
name|device_pattern
operator|.
name|path_id
operator|=
name|devlist
operator|->
name|path_id
expr_stmt|;
name|patterns
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|DEV_MATCH_PERIPH
expr_stmt|;
name|patterns
index|[
literal|1
index|]
operator|.
name|pattern
operator|.
name|periph_pattern
operator|.
name|flags
operator|=
name|PERIPH_MATCH_PATH
expr_stmt|;
name|patterns
index|[
literal|1
index|]
operator|.
name|pattern
operator|.
name|periph_pattern
operator|.
name|path_id
operator|=
name|devlist
operator|->
name|path_id
expr_stmt|;
comment|/* 	 * We do the ioctl multiple times if necessary, in case there are 	 * more than 100 nodes in the EDT. 	 */
do|do
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"error sending CAMIOCOMMAND ioctl"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|.
name|cdm
operator|.
name|status
operator|!=
name|CAM_DEV_MATCH_LAST
operator|)
operator|&&
operator|(
name|ccb
operator|.
name|cdm
operator|.
name|status
operator|!=
name|CAM_DEV_MATCH_MORE
operator|)
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"got CAM error %#x, CDM error %d\n"
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
argument_list|,
name|ccb
operator|.
name|cdm
operator|.
name|status
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccb
operator|.
name|cdm
operator|.
name|num_matches
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|DEV_MATCH_DEVICE
case|:
block|{
name|struct
name|device_match_result
modifier|*
name|dev_result
decl_stmt|;
name|dev_result
operator|=
operator|&
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|result
operator|.
name|device_result
expr_stmt|;
if|if
condition|(
name|dev_result
operator|->
name|flags
operator|&
name|DEV_RESULT_UNCONFIGURED
condition|)
block|{
name|skip_device
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
name|skip_device
operator|=
literal|0
expr_stmt|;
name|item
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: unable to allocate %zd bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bzero
argument_list|(
name|item
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dev_result
argument_list|,
operator|&
name|item
operator|->
name|dev_match
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dev_result
argument_list|)
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|devlist
operator|->
name|dev_queue
argument_list|,
name|item
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|getdevid
argument_list|(
name|item
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
block|}
case|case
name|DEV_MATCH_PERIPH
case|:
block|{
name|struct
name|periph_match_result
modifier|*
name|periph_result
decl_stmt|;
name|periph_result
operator|=
operator|&
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|result
operator|.
name|periph_result
expr_stmt|;
if|if
condition|(
name|skip_device
operator|!=
literal|0
condition|)
break|break;
name|item
operator|->
name|num_periphs
operator|++
expr_stmt|;
name|item
operator|->
name|periph_matches
operator|=
name|realloc
argument_list|(
name|item
operator|->
name|periph_matches
argument_list|,
name|item
operator|->
name|num_periphs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|periph_match_result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|periph_matches
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: error allocating periph "
literal|"list"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bcopy
argument_list|(
name|periph_result
argument_list|,
operator|&
name|item
operator|->
name|periph_matches
index|[
name|item
operator|->
name|num_periphs
operator|-
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|periph_result
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unexpected match "
literal|"type %d\n"
argument_list|,
name|__func__
argument_list|,
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/*NOTREACHED*/
block|}
block|}
block|}
do|while
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|ccb
operator|.
name|cdm
operator|.
name|status
operator|==
name|CAM_DEV_MATCH_MORE
operator|)
condition|)
do|;
name|bailout
label|:
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patterns
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ccb
operator|.
name|cdm
operator|.
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|freebusdevlist
argument_list|(
name|devlist
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|freebusdevlist
parameter_list|(
name|struct
name|cam_devlist
modifier|*
name|devlist
parameter_list|)
block|{
name|struct
name|cam_devitem
modifier|*
name|item
decl_stmt|,
modifier|*
name|item2
decl_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|item
argument_list|,
argument|&devlist->dev_queue
argument_list|,
argument|links
argument_list|,
argument|item2
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|devlist
operator|->
name|dev_queue
argument_list|,
name|item
argument_list|,
name|cam_devitem
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|item
operator|->
name|device_id
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|item
operator|->
name|periph_matches
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|cam_devitem
modifier|*
name|findsasdevice
parameter_list|(
name|struct
name|cam_devlist
modifier|*
name|devlist
parameter_list|,
name|uint64_t
name|sasaddr
parameter_list|)
block|{
name|struct
name|cam_devitem
modifier|*
name|item
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|item
argument_list|,
argument|&devlist->dev_queue
argument_list|,
argument|links
argument_list|)
block|{
name|struct
name|scsi_vpd_id_descriptor
modifier|*
name|idd
decl_stmt|;
comment|/* 		 * XXX KDM look for LUN IDs as well? 		 */
name|idd
operator|=
name|scsi_get_devid
argument_list|(
name|item
operator|->
name|device_id
argument_list|,
name|item
operator|->
name|device_id_len
argument_list|,
name|scsi_devid_is_sas_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|idd
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|scsi_8btou64
argument_list|(
name|idd
operator|->
name|identifier
argument_list|)
operator|==
name|sasaddr
condition|)
return|return
operator|(
name|item
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smpphylist
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|smp_report_general_request
modifier|*
name|rgrequest
init|=
name|NULL
decl_stmt|;
name|struct
name|smp_report_general_response
modifier|*
name|rgresponse
init|=
name|NULL
decl_stmt|;
name|struct
name|smp_discover_request
modifier|*
name|disrequest
init|=
name|NULL
decl_stmt|;
name|struct
name|smp_discover_response
modifier|*
name|disresponse
init|=
name|NULL
decl_stmt|;
name|struct
name|cam_devlist
name|devlist
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|long_response
init|=
literal|0
decl_stmt|;
name|int
name|num_phys
init|=
literal|0
decl_stmt|;
name|int
name|quiet
init|=
literal|0
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
comment|/* 	 * Note that at the moment we don't support sending SMP CCBs to 	 * devices that aren't probed by CAM. 	 */
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating CCB"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|devlist
operator|.
name|dev_queue
argument_list|)
expr_stmt|;
name|rgrequest
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rgrequest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rgrequest
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: unable to allocate %zd bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rgrequest
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|rgresponse
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rgresponse
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rgresponse
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: unable to allocate %zd bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rgresponse
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
name|long_response
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|smp_report_general
argument_list|(
operator|&
name|ccb
operator|->
name|smpio
argument_list|,
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
name|rgrequest
argument_list|,
comment|/*request_len*/
sizeof|sizeof
argument_list|(
operator|*
name|rgrequest
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|rgresponse
argument_list|,
comment|/*response_len*/
sizeof|sizeof
argument_list|(
operator|*
name|rgresponse
argument_list|)
argument_list|,
comment|/*long_response*/
name|long_response
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
condition|)
block|{
specifier|const
name|char
name|warnstr
index|[]
init|=
literal|"error sending command"
decl_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|warn
argument_list|(
name|warnstr
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
name|warnstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|num_phys
operator|=
name|rgresponse
operator|->
name|num_phys
expr_stmt|;
if|if
condition|(
name|num_phys
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s: No Phys reported\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|devlist
operator|.
name|path_id
operator|=
name|device
operator|->
name|path_id
expr_stmt|;
name|retval
operator|=
name|buildbusdevlist
argument_list|(
operator|&
name|devlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d PHYs:\n"
argument_list|,
name|num_phys
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"PHY  Attached SAS Address\n"
argument_list|)
expr_stmt|;
block|}
name|disrequest
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|disrequest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disrequest
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: unable to allocate %zd bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|disrequest
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|disresponse
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|disresponse
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disresponse
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: unable to allocate %zd bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|disresponse
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_phys
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cam_devitem
modifier|*
name|item
decl_stmt|;
name|struct
name|device_match_result
modifier|*
name|dev_match
decl_stmt|;
name|char
name|vendor
index|[
literal|16
index|]
decl_stmt|,
name|product
index|[
literal|48
index|]
decl_stmt|,
name|revision
index|[
literal|16
index|]
decl_stmt|;
name|char
name|tmpstr
index|[
literal|256
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
name|smp_discover
argument_list|(
operator|&
name|ccb
operator|->
name|smpio
argument_list|,
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
name|disrequest
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|disrequest
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|disresponse
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|disresponse
argument_list|)
argument_list|,
name|long_response
argument_list|,
comment|/*ignore_zone_group*/
literal|0
argument_list|,
comment|/*phy*/
name|i
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|retval
operator|=
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|disresponse
operator|->
name|function_result
operator|!=
name|SMP_FR_PHY_VACANT
operator|)
operator|)
condition|)
block|{
specifier|const
name|char
name|warnstr
index|[]
init|=
literal|"error sending command"
decl_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
name|warn
argument_list|(
name|warnstr
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
name|warnstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAM_ARG_VERBOSE
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|disresponse
operator|->
name|function_result
operator|==
name|SMP_FR_PHY_VACANT
condition|)
block|{
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%3d<vacant>\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|disresponse
operator|->
name|attached_device
operator|==
name|SMP_DIS_AD_TYPE_NONE
condition|)
block|{
name|item
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|item
operator|=
name|findsasdevice
argument_list|(
operator|&
name|devlist
argument_list|,
name|scsi_8btou64
argument_list|(
name|disresponse
operator|->
name|attached_sas_address
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|quiet
operator|==
literal|0
operator|)
operator|||
operator|(
name|item
operator|!=
name|NULL
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%3d  0x%016jx"
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|scsi_8btou64
argument_list|(
name|disresponse
operator|->
name|attached_sas_address
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|quiet
operator|!=
literal|0
condition|)
continue|continue;
name|dev_match
operator|=
operator|&
name|item
operator|->
name|dev_match
expr_stmt|;
if|if
condition|(
name|dev_match
operator|->
name|protocol
operator|==
name|PROTO_SCSI
condition|)
block|{
name|cam_strvis
argument_list|(
name|vendor
argument_list|,
name|dev_match
operator|->
name|inq_data
operator|.
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_match
operator|->
name|inq_data
operator|.
name|vendor
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|product
argument_list|,
name|dev_match
operator|->
name|inq_data
operator|.
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_match
operator|->
name|inq_data
operator|.
name|product
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|revision
argument_list|,
name|dev_match
operator|->
name|inq_data
operator|.
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_match
operator|->
name|inq_data
operator|.
name|revision
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpstr
argument_list|,
literal|"<%s %s %s>"
argument_list|,
name|vendor
argument_list|,
name|product
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dev_match
operator|->
name|protocol
operator|==
name|PROTO_ATA
operator|)
operator|||
operator|(
name|dev_match
operator|->
name|protocol
operator|==
name|PROTO_SATAPM
operator|)
condition|)
block|{
name|cam_strvis
argument_list|(
name|product
argument_list|,
name|dev_match
operator|->
name|ident_data
operator|.
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_match
operator|->
name|ident_data
operator|.
name|model
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|cam_strvis
argument_list|(
name|revision
argument_list|,
name|dev_match
operator|->
name|ident_data
operator|.
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_match
operator|->
name|ident_data
operator|.
name|revision
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpstr
argument_list|,
literal|"<%s %s>"
argument_list|,
name|product
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|tmpstr
argument_list|,
literal|"<>"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"   %-33s "
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
comment|/* 		 * If we have 0 periphs, that's a bug... 		 */
if|if
condition|(
name|item
operator|->
name|num_periphs
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|item
operator|->
name|num_periphs
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%d"
argument_list|,
name|item
operator|->
name|periph_matches
index|[
name|j
index|]
operator|.
name|periph_name
argument_list|,
name|item
operator|->
name|periph_matches
index|[
name|j
index|]
operator|.
name|unit_number
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|bailout
label|:
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rgrequest
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rgresponse
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|disrequest
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|disresponse
argument_list|)
expr_stmt|;
name|freebusdevlist
argument_list|(
operator|&
name|devlist
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atapm
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|t
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|c
decl_stmt|;
name|u_char
name|cmd
decl_stmt|,
name|sc
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating ccb"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'t'
case|:
name|t
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"idle"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|t
operator|==
operator|-
literal|1
condition|)
name|cmd
operator|=
name|ATA_IDLE_IMMEDIATE
expr_stmt|;
else|else
name|cmd
operator|=
name|ATA_IDLE_CMD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"standby"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|t
operator|==
operator|-
literal|1
condition|)
name|cmd
operator|=
name|ATA_STANDBY_IMMEDIATE
expr_stmt|;
else|else
name|cmd
operator|=
name|ATA_STANDBY_CMD
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
name|ATA_SLEEP
expr_stmt|;
name|t
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|<
literal|0
condition|)
name|sc
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|<=
operator|(
literal|240
operator|*
literal|5
operator|)
condition|)
name|sc
operator|=
operator|(
name|t
operator|+
literal|4
operator|)
operator|/
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|<=
operator|(
literal|252
operator|*
literal|5
operator|)
condition|)
comment|/* special encoding for 21 minutes */
name|sc
operator|=
literal|252
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|<=
operator|(
literal|11
operator|*
literal|30
operator|*
literal|60
operator|)
condition|)
name|sc
operator|=
operator|(
name|t
operator|-
literal|1
operator|)
operator|/
operator|(
literal|30
operator|*
literal|60
operator|)
operator|+
literal|241
expr_stmt|;
else|else
name|sc
operator|=
literal|253
expr_stmt|;
name|retval
operator|=
name|ata_do_28bit_cmd
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
comment|/*protocol*/
name|AP_PROTO_NON_DATA
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*command*/
name|cmd
argument_list|,
comment|/*features*/
literal|0
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*sector_count*/
name|sc
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|30
operator|*
literal|1000
argument_list|,
comment|/*quiet*/
literal|1
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ataaxm
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|l
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|c
decl_stmt|;
name|u_char
name|cmd
decl_stmt|,
name|sc
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating ccb"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
name|l
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|sc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"apm"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|==
operator|-
literal|1
condition|)
name|cmd
operator|=
literal|0x85
expr_stmt|;
else|else
block|{
name|cmd
operator|=
literal|0x05
expr_stmt|;
name|sc
operator|=
name|l
expr_stmt|;
block|}
block|}
else|else
comment|/* aam */
block|{
if|if
condition|(
name|l
operator|==
operator|-
literal|1
condition|)
name|cmd
operator|=
literal|0xC2
expr_stmt|;
else|else
block|{
name|cmd
operator|=
literal|0x42
expr_stmt|;
name|sc
operator|=
name|l
expr_stmt|;
block|}
block|}
name|retval
operator|=
name|ata_do_28bit_cmd
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*flags*/
name|CAM_DIR_NONE
argument_list|,
comment|/*protocol*/
name|AP_PROTO_NON_DATA
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*command*/
name|ATA_SETFEATURES
argument_list|,
comment|/*features*/
name|cmd
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*sector_count*/
name|sc
argument_list|,
comment|/*data_ptr*/
name|NULL
argument_list|,
comment|/*dxfer_len*/
literal|0
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|30
operator|*
literal|1000
argument_list|,
comment|/*quiet*/
literal|1
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scsigetopcodes
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|opcode_set
parameter_list|,
name|int
name|opcode
parameter_list|,
name|int
name|show_sa_errors
parameter_list|,
name|int
name|sa_set
parameter_list|,
name|int
name|service_action
parameter_list|,
name|int
name|timeout_desc
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|verbosemode
parameter_list|,
name|uint32_t
modifier|*
name|fill_len
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|data_ptr
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|NULL
decl_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|alloc_len
init|=
literal|0
decl_stmt|,
name|num_opcodes
decl_stmt|;
name|uint32_t
name|valid_len
init|=
literal|0
decl_stmt|;
name|uint32_t
name|avail_len
init|=
literal|0
decl_stmt|;
name|struct
name|scsi_report_supported_opcodes_all
modifier|*
name|all_hdr
decl_stmt|;
name|struct
name|scsi_report_supported_opcodes_one
modifier|*
name|one
decl_stmt|;
name|int
name|options
init|=
literal|0
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* 	 * Make it clear that we haven't yet allocated or filled anything. 	 */
operator|*
name|fill_len
operator|=
literal|0
expr_stmt|;
operator|*
name|data_ptr
operator|=
name|NULL
expr_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"couldn't allocate CCB"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* cam_getccb cleans up the header, caller has to zero the payload */
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode_set
operator|!=
literal|0
condition|)
block|{
name|options
operator||=
name|RSO_OPTIONS_OC
expr_stmt|;
name|num_opcodes
operator|=
literal|1
expr_stmt|;
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|one
argument_list|)
operator|+
name|CAM_MAX_CDBLEN
expr_stmt|;
block|}
else|else
block|{
name|num_opcodes
operator|=
literal|256
expr_stmt|;
name|alloc_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|all_hdr
argument_list|)
operator|+
operator|(
name|num_opcodes
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_supported_opcodes_descr
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout_desc
operator|!=
literal|0
condition|)
block|{
name|options
operator||=
name|RSO_RCTD
expr_stmt|;
name|alloc_len
operator|+=
name|num_opcodes
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_report_supported_opcodes_timeout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sa_set
operator|!=
literal|0
condition|)
block|{
name|options
operator||=
name|RSO_OPTIONS_OC_SA
expr_stmt|;
if|if
condition|(
name|show_sa_errors
operator|!=
literal|0
condition|)
name|options
operator|&=
operator|~
name|RSO_OPTIONS_OC
expr_stmt|;
block|}
name|retry_alloc
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
name|buf
operator|=
name|malloc
argument_list|(
name|alloc_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"Unable to allocate %u bytes"
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bzero
argument_list|(
name|buf
argument_list|,
name|alloc_len
argument_list|)
expr_stmt|;
name|scsi_report_supported_opcodes
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*options*/
name|options
argument_list|,
comment|/*req_opcode*/
name|opcode
argument_list|,
comment|/*req_service_action*/
name|service_action
argument_list|,
comment|/*data_ptr*/
name|buf
argument_list|,
comment|/*dxfer_len*/
name|alloc_len
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|10000
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|retry_count
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"error sending REPORT SUPPORTED OPERATION CODES"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|verbosemode
operator|!=
literal|0
condition|)
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|valid_len
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|resid
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|options
operator|&
name|RSO_OPTIONS_MASK
operator|)
operator|==
name|RSO_OPTIONS_ALL
operator|)
operator|&&
operator|(
name|valid_len
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|all_hdr
argument_list|)
operator|)
condition|)
block|{
name|all_hdr
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_all
operator|*
operator|)
name|buf
expr_stmt|;
name|avail_len
operator|=
name|scsi_4btoul
argument_list|(
name|all_hdr
operator|->
name|length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|all_hdr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|options
operator|&
name|RSO_OPTIONS_MASK
operator|)
operator|!=
name|RSO_OPTIONS_ALL
operator|)
operator|&&
operator|(
name|valid_len
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|one
argument_list|)
operator|)
condition|)
block|{
name|uint32_t
name|cdb_length
decl_stmt|;
name|one
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_one
operator|*
operator|)
name|buf
expr_stmt|;
name|cdb_length
operator|=
name|scsi_2btoul
argument_list|(
name|one
operator|->
name|cdb_length
argument_list|)
expr_stmt|;
name|avail_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|one
argument_list|)
operator|+
name|cdb_length
expr_stmt|;
if|if
condition|(
name|one
operator|->
name|support
operator|&
name|RSO_ONE_CTDP
condition|)
block|{
name|struct
name|scsi_report_supported_opcodes_timeout
modifier|*
name|td
decl_stmt|;
name|td
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_timeout
operator|*
operator|)
operator|&
name|buf
index|[
name|avail_len
index|]
expr_stmt|;
if|if
condition|(
name|valid_len
operator|>=
operator|(
name|avail_len
operator|+
sizeof|sizeof
argument_list|(
name|td
operator|->
name|length
argument_list|)
operator|)
condition|)
block|{
name|avail_len
operator|+=
name|scsi_2btoul
argument_list|(
name|td
operator|->
name|length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|td
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|avail_len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|td
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * avail_len could be zero if we didn't get enough data back from 	 * thet target to determine 	 */
if|if
condition|(
operator|(
name|avail_len
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|avail_len
operator|>
name|valid_len
operator|)
condition|)
block|{
name|alloc_len
operator|=
name|avail_len
expr_stmt|;
goto|goto
name|retry_alloc
goto|;
block|}
operator|*
name|fill_len
operator|=
name|valid_len
expr_stmt|;
operator|*
name|data_ptr
operator|=
name|buf
expr_stmt|;
name|bailout
label|:
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsiprintoneopcode
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|req_opcode
parameter_list|,
name|int
name|sa_set
parameter_list|,
name|int
name|req_sa
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|valid_len
parameter_list|)
block|{
name|struct
name|scsi_report_supported_opcodes_one
modifier|*
name|one
decl_stmt|;
name|struct
name|scsi_report_supported_opcodes_timeout
modifier|*
name|td
decl_stmt|;
name|uint32_t
name|cdb_len
init|=
literal|0
decl_stmt|,
name|td_len
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|op_desc
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|one
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_one
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* 	 * If we don't have the full single opcode descriptor, no point in 	 * continuing. 	 */
if|if
condition|(
name|valid_len
operator|<
name|__offsetof
argument_list|(
expr|struct
name|scsi_report_supported_opcodes_one
argument_list|,
name|cdb_length
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Only %u bytes returned, not enough to verify support"
argument_list|,
name|valid_len
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|op_desc
operator|=
name|scsi_op_desc
argument_list|(
name|req_opcode
argument_list|,
operator|&
name|device
operator|->
name|inq_data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s (0x%02x)"
argument_list|,
name|op_desc
operator|!=
name|NULL
condition|?
name|op_desc
else|:
literal|"UNKNOWN"
argument_list|,
name|req_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_set
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", SA 0x%x"
argument_list|,
name|req_sa
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|one
operator|->
name|support
operator|&
name|RSO_ONE_SUP_MASK
condition|)
block|{
case|case
name|RSO_ONE_SUP_UNAVAIL
case|:
name|printf
argument_list|(
literal|"No command support information currently available\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSO_ONE_SUP_NOT_SUP
case|:
name|printf
argument_list|(
literal|"Command not supported\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/*NOTREACHED*/
case|case
name|RSO_ONE_SUP_AVAIL
case|:
name|printf
argument_list|(
literal|"Command is supported, complies with a SCSI standard\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSO_ONE_SUP_VENDOR
case|:
name|printf
argument_list|(
literal|"Command is supported, vendor-specific "
literal|"implementation\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown command support flags 0x%#x\n"
argument_list|,
name|one
operator|->
name|support
operator|&
name|RSO_ONE_SUP_MASK
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * If we don't have the CDB length, it isn't exactly an error, the 	 * command probably isn't supported. 	 */
if|if
condition|(
name|valid_len
operator|<
name|__offsetof
argument_list|(
expr|struct
name|scsi_report_supported_opcodes_one
argument_list|,
name|cdb_usage
argument_list|)
condition|)
goto|goto
name|bailout
goto|;
name|cdb_len
operator|=
name|scsi_2btoul
argument_list|(
name|one
operator|->
name|cdb_length
argument_list|)
expr_stmt|;
comment|/* 	 * If our valid data doesn't include the full reported length, 	 * return.  The caller should have detected this and adjusted his 	 * allocation length to get all of the available data. 	 */
if|if
condition|(
name|valid_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|one
argument_list|)
operator|+
name|cdb_len
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * If all we have is the opcode, there is no point in printing out 	 * the usage bitmap. 	 */
if|if
condition|(
name|cdb_len
operator|<=
literal|1
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|printf
argument_list|(
literal|"CDB usage bitmap:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cdb_len
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|one
operator|->
name|cdb_usage
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't have a timeout descriptor, we're done. 	 */
if|if
condition|(
operator|(
name|one
operator|->
name|support
operator|&
name|RSO_ONE_CTDP
operator|)
operator|==
literal|0
condition|)
goto|goto
name|bailout
goto|;
comment|/* 	 * If we don't have enough valid length to include the timeout 	 * descriptor length, we're done. 	 */
if|if
condition|(
name|valid_len
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|one
argument_list|)
operator|+
name|cdb_len
operator|+
sizeof|sizeof
argument_list|(
name|td
operator|->
name|length
argument_list|)
operator|)
condition|)
goto|goto
name|bailout
goto|;
name|td
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_timeout
operator|*
operator|)
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
operator|*
name|one
argument_list|)
operator|+
name|cdb_len
index|]
expr_stmt|;
name|td_len
operator|=
name|scsi_2btoul
argument_list|(
name|td
operator|->
name|length
argument_list|)
expr_stmt|;
name|td_len
operator|+=
sizeof|sizeof
argument_list|(
name|td
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't have the full timeout descriptor, we're done. 	 */
if|if
condition|(
name|td_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|td
argument_list|)
condition|)
goto|goto
name|bailout
goto|;
comment|/* 	 * If we don't have enough valid length to contain the full timeout 	 * descriptor, we're done. 	 */
if|if
condition|(
name|valid_len
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|one
argument_list|)
operator|+
name|cdb_len
operator|+
name|td_len
operator|)
condition|)
goto|goto
name|bailout
goto|;
name|printf
argument_list|(
literal|"Timeout information:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Command-specific:    0x%02x\n"
argument_list|,
name|td
operator|->
name|cmd_specific
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Nominal timeout:     %u seconds\n"
argument_list|,
name|scsi_4btoul
argument_list|(
name|td
operator|->
name|nominal_time
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Recommended timeout: %u seconds\n"
argument_list|,
name|scsi_4btoul
argument_list|(
name|td
operator|->
name|recommended_time
argument_list|)
argument_list|)
expr_stmt|;
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsiprintopcodes
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|td_req
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|valid_len
parameter_list|)
block|{
name|struct
name|scsi_report_supported_opcodes_all
modifier|*
name|hdr
decl_stmt|;
name|struct
name|scsi_report_supported_opcodes_descr
modifier|*
name|desc
decl_stmt|;
name|uint32_t
name|avail_len
init|=
literal|0
decl_stmt|,
name|used_len
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|cur_ptr
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|valid_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: not enough returned data (%u bytes) opcode list"
argument_list|,
name|__func__
argument_list|,
name|valid_len
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|hdr
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_all
operator|*
operator|)
name|buf
expr_stmt|;
name|avail_len
operator|=
name|scsi_4btoul
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
name|avail_len
operator|+=
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * Take the lesser of the amount of data the drive claims is 	 * available, and the amount of data the HBA says was returned. 	 */
name|avail_len
operator|=
name|MIN
argument_list|(
name|avail_len
argument_list|,
name|valid_len
argument_list|)
expr_stmt|;
name|used_len
operator|=
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-6s %4s %8s "
argument_list|,
literal|"Opcode"
argument_list|,
literal|"SA"
argument_list|,
literal|"CDB len"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_req
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%5s %6s %6s "
argument_list|,
literal|"CS"
argument_list|,
literal|"Nom"
argument_list|,
literal|"Rec"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Description\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|avail_len
operator|-
name|used_len
operator|)
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
condition|)
block|{
name|struct
name|scsi_report_supported_opcodes_timeout
modifier|*
name|td
decl_stmt|;
name|uint32_t
name|td_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|op_desc
init|=
name|NULL
decl_stmt|;
name|cur_ptr
operator|=
operator|&
name|buf
index|[
name|used_len
index|]
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_descr
operator|*
operator|)
name|cur_ptr
expr_stmt|;
name|op_desc
operator|=
name|scsi_op_desc
argument_list|(
name|desc
operator|->
name|opcode
argument_list|,
operator|&
name|device
operator|->
name|inq_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_desc
operator|==
name|NULL
condition|)
name|op_desc
operator|=
literal|"UNKNOWN"
expr_stmt|;
name|printf
argument_list|(
literal|"0x%02x   %#4x %8u "
argument_list|,
name|desc
operator|->
name|opcode
argument_list|,
name|scsi_2btoul
argument_list|(
name|desc
operator|->
name|service_action
argument_list|)
argument_list|,
name|scsi_2btoul
argument_list|(
name|desc
operator|->
name|cdb_length
argument_list|)
argument_list|)
expr_stmt|;
name|used_len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|flags
operator|&
name|RSO_CTDP
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|op_desc
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If we don't have enough space to fit a timeout 		 * descriptor, then we're done. 		 */
if|if
condition|(
name|avail_len
operator|-
name|used_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|td
argument_list|)
condition|)
block|{
name|used_len
operator|=
name|avail_len
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|op_desc
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cur_ptr
operator|=
operator|&
name|buf
index|[
name|used_len
index|]
expr_stmt|;
name|td
operator|=
operator|(
expr|struct
name|scsi_report_supported_opcodes_timeout
operator|*
operator|)
name|cur_ptr
expr_stmt|;
name|td_len
operator|=
name|scsi_2btoul
argument_list|(
name|td
operator|->
name|length
argument_list|)
expr_stmt|;
name|td_len
operator|+=
sizeof|sizeof
argument_list|(
name|td
operator|->
name|length
argument_list|)
expr_stmt|;
name|used_len
operator|+=
name|td_len
expr_stmt|;
comment|/* 		 * If the given timeout descriptor length is less than what 		 * we understand, skip it. 		 */
if|if
condition|(
name|td_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|td
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|op_desc
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|" 0x%02x %6u %6u  %s\n"
argument_list|,
name|td
operator|->
name|cmd_specific
argument_list|,
name|scsi_4btoul
argument_list|(
name|td
operator|->
name|nominal_time
argument_list|)
argument_list|,
name|scsi_4btoul
argument_list|(
name|td
operator|->
name|recommended_time
argument_list|)
argument_list|,
name|op_desc
argument_list|)
expr_stmt|;
block|}
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsiopcodes
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|verbosemode
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|uint32_t
name|opcode
init|=
literal|0
decl_stmt|,
name|service_action
init|=
literal|0
decl_stmt|;
name|int
name|td_set
init|=
literal|0
decl_stmt|,
name|opcode_set
init|=
literal|0
decl_stmt|,
name|sa_set
init|=
literal|0
decl_stmt|;
name|int
name|show_sa_errors
init|=
literal|1
decl_stmt|;
name|uint32_t
name|valid_len
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'N'
case|:
name|show_sa_errors
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|opcode
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid opcode \"%s\", must be a number"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|opcode
operator|>
literal|0xff
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid opcode 0x%#x, must be between"
literal|"0 and 0xff inclusive"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|opcode_set
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|service_action
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid service action \"%s\", must "
literal|"be a number"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|service_action
operator|>
literal|0xffff
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid service action 0x%#x, must "
literal|"be between 0 and 0xffff inclusive"
argument_list|,
name|service_action
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
name|sa_set
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|td_set
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|sa_set
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|opcode_set
operator|==
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"You must specify an opcode with -o if a service "
literal|"action is given"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|retval
operator|=
name|scsigetopcodes
argument_list|(
name|device
argument_list|,
name|opcode_set
argument_list|,
name|opcode
argument_list|,
name|show_sa_errors
argument_list|,
name|sa_set
argument_list|,
name|service_action
argument_list|,
name|td_set
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|verbosemode
argument_list|,
operator|&
name|valid_len
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
operator|(
name|opcode_set
operator|!=
literal|0
operator|)
operator|||
operator|(
name|sa_set
operator|!=
literal|0
operator|)
condition|)
block|{
name|retval
operator|=
name|scsiprintoneopcode
argument_list|(
name|device
argument_list|,
name|opcode
argument_list|,
name|sa_set
argument_list|,
name|service_action
argument_list|,
name|buf
argument_list|,
name|valid_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|scsiprintopcodes
argument_list|(
name|device
argument_list|,
name|td_set
argument_list|,
name|buf
argument_list|,
name|valid_len
argument_list|)
expr_stmt|;
block|}
name|bailout
label|:
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MINIMALISTIC */
end_comment

begin_function
specifier|static
name|int
name|scsireprobe
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating ccb"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_REPROBE_LUN
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending XPT_REPROBE_LUN CCB"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|int
name|printlong
parameter_list|)
block|{
name|fprintf
argument_list|(
name|printlong
condition|?
name|stdout
else|:
name|stderr
argument_list|,
literal|"usage:  camcontrol<command>  [device id][generic args][command args]\n"
literal|"        camcontrol devlist    [-b] [-v]\n"
ifndef|#
directive|ifndef
name|MINIMALISTIC
literal|"        camcontrol periphlist [dev_id][-n dev_name] [-u unit]\n"
literal|"        camcontrol tur        [dev_id][generic args]\n"
literal|"        camcontrol inquiry    [dev_id][generic args] [-D] [-S] [-R]\n"
literal|"        camcontrol identify   [dev_id][generic args] [-v]\n"
literal|"        camcontrol reportluns [dev_id][generic args] [-c] [-l] [-r report]\n"
literal|"        camcontrol readcap    [dev_id][generic args] [-b] [-h] [-H] [-N]\n"
literal|"                              [-q] [-s]\n"
literal|"        camcontrol start      [dev_id][generic args]\n"
literal|"        camcontrol stop       [dev_id][generic args]\n"
literal|"        camcontrol load       [dev_id][generic args]\n"
literal|"        camcontrol eject      [dev_id][generic args]\n"
literal|"        camcontrol reprobe    [dev_id][generic args]\n"
endif|#
directive|endif
comment|/* MINIMALISTIC */
literal|"        camcontrol rescan<all | bus[:target:lun]>\n"
literal|"        camcontrol reset<all | bus[:target:lun]>\n"
ifndef|#
directive|ifndef
name|MINIMALISTIC
literal|"        camcontrol defects    [dev_id][generic args]<-f format> [-P][-G]\n"
literal|"                              [-q][-s][-S offset][-X]\n"
literal|"        camcontrol modepage   [dev_id][generic args]<-m page | -l>\n"
literal|"                              [-P pagectl][-e | -b][-d]\n"
literal|"        camcontrol cmd        [dev_id][generic args]\n"
literal|"<-a cmd [args] | -c cmd [args]>\n"
literal|"                              [-d] [-f] [-i len fmt|-o len fmt [args]] [-r fmt]\n"
literal|"        camcontrol smpcmd     [dev_id][generic args]\n"
literal|"<-r len fmt [args]><-R len fmt [args]>\n"
literal|"        camcontrol smprg      [dev_id][generic args][-l]\n"
literal|"        camcontrol smppc      [dev_id][generic args]<-p phy> [-l]\n"
literal|"                              [-o operation][-d name][-m rate][-M rate]\n"
literal|"                              [-T pp_timeout][-a enable|disable]\n"
literal|"                              [-A enable|disable][-s enable|disable]\n"
literal|"                              [-S enable|disable]\n"
literal|"        camcontrol smpphylist [dev_id][generic args][-l][-q]\n"
literal|"        camcontrol smpmaninfo [dev_id][generic args][-l]\n"
literal|"        camcontrol debug      [-I][-P][-T][-S][-X][-c]\n"
literal|"<all|bus[:target[:lun]]|off>\n"
literal|"        camcontrol tags       [dev_id][generic args] [-N tags] [-q] [-v]\n"
literal|"        camcontrol negotiate  [dev_id][generic args] [-a][-c]\n"
literal|"                              [-D<enable|disable>][-M mode][-O offset]\n"
literal|"                              [-q][-R syncrate][-v][-T<enable|disable>]\n"
literal|"                              [-U][-W bus_width]\n"
literal|"        camcontrol format     [dev_id][generic args][-q][-r][-w][-y]\n"
literal|"        camcontrol sanitize   [dev_id][generic args]\n"
literal|"                              [-a overwrite|block|crypto|exitfailure]\n"
literal|"                              [-c passes][-I][-P pattern][-q][-U][-r][-w]\n"
literal|"                              [-y]\n"
literal|"        camcontrol idle       [dev_id][generic args][-t time]\n"
literal|"        camcontrol standby    [dev_id][generic args][-t time]\n"
literal|"        camcontrol sleep      [dev_id][generic args]\n"
literal|"        camcontrol apm        [dev_id][generic args][-l level]\n"
literal|"        camcontrol aam        [dev_id][generic args][-l level]\n"
literal|"        camcontrol fwdownload [dev_id][generic args]<-f fw_image> [-q]\n"
literal|"                              [-s][-y]\n"
literal|"        camcontrol security   [dev_id][generic args]\n"
literal|"<-d pwd | -e pwd | -f | -h pwd | -k pwd>\n"
literal|"                              [-l<high|maximum>] [-q] [-s pwd] [-T timeout]\n"
literal|"                              [-U<user|master>] [-y]\n"
literal|"        camcontrol hpa        [dev_id][generic args] [-f] [-l] [-P] [-p pwd]\n"
literal|"                              [-q] [-s max_sectors] [-U pwd] [-y]\n"
literal|"        camcontrol persist    [dev_id][generic args]<-i action|-o action>\n"
literal|"                              [-a][-I tid][-k key][-K sa_key][-p][-R rtp]\n"
literal|"                              [-s scope][-S][-T type][-U]\n"
literal|"        camcontrol attrib     [dev_id][generic args]<-r action|-w attr>\n"
literal|"                              [-a attr_num][-c][-e elem][-F form1,form1]\n"
literal|"                              [-p part][-s start][-T type][-V vol]\n"
literal|"        camcontrol opcodes    [dev_id][generic args][-o opcode][-s SA]\n"
literal|"                              [-N][-T]\n"
endif|#
directive|endif
comment|/* MINIMALISTIC */
literal|"        camcontrol help\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|printlong
condition|)
return|return;
ifndef|#
directive|ifndef
name|MINIMALISTIC
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Specify one of the following options:\n"
literal|"devlist     list all CAM devices\n"
literal|"periphlist  list all CAM peripheral drivers attached to a device\n"
literal|"tur         send a test unit ready to the named device\n"
literal|"inquiry     send a SCSI inquiry command to the named device\n"
literal|"identify    send a ATA identify command to the named device\n"
literal|"reportluns  send a SCSI report luns command to the device\n"
literal|"readcap     send a SCSI read capacity command to the device\n"
literal|"start       send a Start Unit command to the device\n"
literal|"stop        send a Stop Unit command to the device\n"
literal|"load        send a Start Unit command to the device with the load bit set\n"
literal|"eject       send a Stop Unit command to the device with the eject bit set\n"
literal|"reprobe     update capacity information of the given device\n"
literal|"rescan      rescan all busses, the given bus, or bus:target:lun\n"
literal|"reset       reset all busses, the given bus, or bus:target:lun\n"
literal|"defects     read the defect list of the specified device\n"
literal|"modepage    display or edit (-e) the given mode page\n"
literal|"cmd         send the given SCSI command, may need -i or -o as well\n"
literal|"smpcmd      send the given SMP command, requires -o and -i\n"
literal|"smprg       send the SMP Report General command\n"
literal|"smppc       send the SMP PHY Control command, requires -p\n"
literal|"smpphylist  display phys attached to a SAS expander\n"
literal|"smpmaninfo  send the SMP Report Manufacturer Info command\n"
literal|"debug       turn debugging on/off for a bus, target, or lun, or all devices\n"
literal|"tags        report or set the number of transaction slots for a device\n"
literal|"negotiate   report or set device negotiation parameters\n"
literal|"format      send the SCSI FORMAT UNIT command to the named device\n"
literal|"sanitize    send the SCSI SANITIZE command to the named device\n"
literal|"idle        send the ATA IDLE command to the named device\n"
literal|"standby     send the ATA STANDBY command to the named device\n"
literal|"sleep       send the ATA SLEEP command to the named device\n"
literal|"fwdownload  program firmware of the named device with the given image\n"
literal|"security    report or send ATA security commands to the named device\n"
literal|"persist     send the SCSI PERSISTENT RESERVE IN or OUT commands\n"
literal|"attrib      send the SCSI READ or WRITE ATTRIBUTE commands\n"
literal|"opcodes     send the SCSI REPORT SUPPORTED OPCODES command\n"
literal|"help        this message\n"
literal|"Device Identifiers:\n"
literal|"bus:target        specify the bus and target, lun defaults to 0\n"
literal|"bus:target:lun    specify the bus, target and lun\n"
literal|"deviceUNIT        specify the device name, like \"da4\" or \"cd2\"\n"
literal|"Generic arguments:\n"
literal|"-v                be verbose, print out sense information\n"
literal|"-t timeout        command timeout in seconds, overrides default timeout\n"
literal|"-n dev_name       specify device name, e.g. \"da\", \"cd\"\n"
literal|"-u unit           specify unit number, e.g. \"0\", \"5\"\n"
literal|"-E                have the kernel attempt to perform SCSI error recovery\n"
literal|"-C count          specify the SCSI command retry count (needs -E to work)\n"
literal|"modepage arguments:\n"
literal|"-l                list all available mode pages\n"
literal|"-m page           specify the mode page to view or edit\n"
literal|"-e                edit the specified mode page\n"
literal|"-b                force view to binary mode\n"
literal|"-d                disable block descriptors for mode sense\n"
literal|"-P pgctl          page control field 0-3\n"
literal|"defects arguments:\n"
literal|"-f format         specify defect list format (block, bfi or phys)\n"
literal|"-G                get the grown defect list\n"
literal|"-P                get the permanent defect list\n"
literal|"inquiry arguments:\n"
literal|"-D                get the standard inquiry data\n"
literal|"-S                get the serial number\n"
literal|"-R                get the transfer rate, etc.\n"
literal|"reportluns arguments:\n"
literal|"-c                only report a count of available LUNs\n"
literal|"-l                only print out luns, and not a count\n"
literal|"-r<reporttype>   specify \"default\", \"wellknown\" or \"all\"\n"
literal|"readcap arguments\n"
literal|"-b                only report the blocksize\n"
literal|"-h                human readable device size, base 2\n"
literal|"-H                human readable device size, base 10\n"
literal|"-N                print the number of blocks instead of last block\n"
literal|"-q                quiet, print numbers only\n"
literal|"-s                only report the last block/device size\n"
literal|"cmd arguments:\n"
literal|"-c cdb [args]     specify the SCSI CDB\n"
literal|"-i len fmt        specify input data and input data format\n"
literal|"-o len fmt [args] specify output data and output data fmt\n"
literal|"smpcmd arguments:\n"
literal|"-r len fmt [args] specify the SMP command to be sent\n"
literal|"-R len fmt [args] specify SMP response format\n"
literal|"smprg arguments:\n"
literal|"-l                specify the long response format\n"
literal|"smppc arguments:\n"
literal|"-p phy            specify the PHY to operate on\n"
literal|"-l                specify the long request/response format\n"
literal|"-o operation      specify the phy control operation\n"
literal|"-d name           set the attached device name\n"
literal|"-m rate           set the minimum physical link rate\n"
literal|"-M rate           set the maximum physical link rate\n"
literal|"-T pp_timeout     set the partial pathway timeout value\n"
literal|"-a enable|disable enable or disable SATA slumber\n"
literal|"-A enable|disable enable or disable SATA partial phy power\n"
literal|"-s enable|disable enable or disable SAS slumber\n"
literal|"-S enable|disable enable or disable SAS partial phy power\n"
literal|"smpphylist arguments:\n"
literal|"-l                specify the long response format\n"
literal|"-q                only print phys with attached devices\n"
literal|"smpmaninfo arguments:\n"
literal|"-l                specify the long response format\n"
literal|"debug arguments:\n"
literal|"-I                CAM_DEBUG_INFO -- scsi commands, errors, data\n"
literal|"-T                CAM_DEBUG_TRACE -- routine flow tracking\n"
literal|"-S                CAM_DEBUG_SUBTRACE -- internal routine command flow\n"
literal|"-c                CAM_DEBUG_CDB -- print out SCSI CDBs only\n"
literal|"tags arguments:\n"
literal|"-N tags           specify the number of tags to use for this device\n"
literal|"-q                be quiet, don't report the number of tags\n"
literal|"-v                report a number of tag-related parameters\n"
literal|"negotiate arguments:\n"
literal|"-a                send a test unit ready after negotiation\n"
literal|"-c                report/set current negotiation settings\n"
literal|"-D<arg>          \"enable\" or \"disable\" disconnection\n"
literal|"-M mode           set ATA mode\n"
literal|"-O offset         set command delay offset\n"
literal|"-q                be quiet, don't report anything\n"
literal|"-R syncrate       synchronization rate in MHz\n"
literal|"-T<arg>          \"enable\" or \"disable\" tagged queueing\n"
literal|"-U                report/set user negotiation settings\n"
literal|"-W bus_width      set the bus width in bits (8, 16 or 32)\n"
literal|"-v                also print a Path Inquiry CCB for the controller\n"
literal|"format arguments:\n"
literal|"-q                be quiet, don't print status messages\n"
literal|"-r                run in report only mode\n"
literal|"-w                don't send immediate format command\n"
literal|"-y                don't ask any questions\n"
literal|"sanitize arguments:\n"
literal|"-a operation      operation mode: overwrite, block, crypto or exitfailure\n"
literal|"-c passes         overwrite passes to perform (1 to 31)\n"
literal|"-I                invert overwrite pattern after each pass\n"
literal|"-P pattern        path to overwrite pattern file\n"
literal|"-q                be quiet, don't print status messages\n"
literal|"-r                run in report only mode\n"
literal|"-U                run operation in unrestricted completion exit mode\n"
literal|"-w                don't send immediate sanitize command\n"
literal|"-y                don't ask any questions\n"
literal|"idle/standby arguments:\n"
literal|"-t<arg>          number of seconds before respective state.\n"
literal|"fwdownload arguments:\n"
literal|"-f fw_image       path to firmware image file\n"
literal|"-q                don't print informational messages, only errors\n"
literal|"-s                run in simulation mode\n"
literal|"-v                print info for every firmware segment sent to device\n"
literal|"-y                don't ask any questions\n"
literal|"security arguments:\n"
literal|"-d pwd            disable security using the given password for the selected\n"
literal|"                  user\n"
literal|"-e pwd            erase the device using the given pwd for the selected user\n"
literal|"-f                freeze the security configuration of the specified device\n"
literal|"-h pwd            enhanced erase the device using the given pwd for the\n"
literal|"                  selected user\n"
literal|"-k pwd            unlock the device using the given pwd for the selected\n"
literal|"                  user\n"
literal|"-l<high|maximum> specifies which security level to set: high or maximum\n"
literal|"-q                be quiet, do not print any status messages\n"
literal|"-s pwd            password the device (enable security) using the given\n"
literal|"                  pwd for the selected user\n"
literal|"-T timeout        overrides the timeout (seconds) used for erase operation\n"
literal|"-U<user|master>  specifies which user to set: user or master\n"
literal|"-y                don't ask any questions\n"
literal|"hpa arguments:\n"
literal|"-f                freeze the HPA configuration of the device\n"
literal|"-l                lock the HPA configuration of the device\n"
literal|"-P                make the HPA max sectors persist\n"
literal|"-p pwd            Set the HPA configuration password required for unlock\n"
literal|"                  calls\n"
literal|"-q                be quiet, do not print any status messages\n"
literal|"-s sectors        configures the maximum user accessible sectors of the\n"
literal|"                  device\n"
literal|"-U pwd            unlock the HPA configuration of the device\n"
literal|"-y                don't ask any questions\n"
literal|"persist arguments:\n"
literal|"-i action         specify read_keys, read_reservation, report_cap, or\n"
literal|"                  read_full_status\n"
literal|"-o action         specify register, register_ignore, reserve, release,\n"
literal|"                  clear, preempt, preempt_abort, register_move, replace_lost\n"
literal|"-a                set the All Target Ports (ALL_TG_PT) bit\n"
literal|"-I tid            specify a Transport ID, e.g.: sas,0x1234567812345678\n"
literal|"-k key            specify the Reservation Key\n"
literal|"-K sa_key         specify the Service Action Reservation Key\n"
literal|"-p                set the Activate Persist Through Power Loss bit\n"
literal|"-R rtp            specify the Relative Target Port\n"
literal|"-s scope          specify the scope: lun, extent, element or a number\n"
literal|"-S                specify Transport ID for register, requires -I\n"
literal|"-T res_type       specify the reservation type: read_shared, wr_ex, rd_ex,\n"
literal|"                  ex_ac, wr_ex_ro, ex_ac_ro, wr_ex_ar, ex_ac_ar\n"
literal|"-U                unregister the current initiator for register_move\n"
literal|"attrib arguments:\n"
literal|"-r action         specify attr_values, attr_list, lv_list, part_list, or\n"
literal|"                  supp_attr\n"
literal|"-w attr           specify an attribute to write, one -w argument per attr\n"
literal|"-a attr_num       only display this attribute number\n"
literal|"-c                get cached attributes\n"
literal|"-e elem_addr      request attributes for the given element in a changer\n"
literal|"-F form1,form2    output format, comma separated list: text_esc, text_raw,\n"
literal|"                  nonascii_esc, nonascii_trim, nonascii_raw, field_all,\n"
literal|"                  field_none, field_desc, field_num, field_size, field_rw\n"
literal|"-p partition      request attributes for the given partition\n"
literal|"-s start_attr     request attributes starting at the given number\n"
literal|"-T elem_type      specify the element type (used with -e)\n"
literal|"-V logical_vol    specify the logical volume ID\n"
literal|"opcodes arguments:\n"
literal|"-o opcode         specify the individual opcode to list\n"
literal|"-s service_action specify the service action for the opcode\n"
literal|"-N                do not return SCSI error for unsupported SA\n"
literal|"-T                request nominal and recommended timeout values\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MINIMALISTIC */
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|device
init|=
name|NULL
decl_stmt|;
name|int
name|unit
init|=
literal|0
decl_stmt|;
name|struct
name|cam_device
modifier|*
name|cam_dev
init|=
name|NULL
decl_stmt|;
name|int
name|timeout
init|=
literal|0
decl_stmt|,
name|retry_count
init|=
literal|1
decl_stmt|;
name|camcontrol_optret
name|optreturn
decl_stmt|;
name|char
modifier|*
name|tstr
decl_stmt|;
specifier|const
name|char
modifier|*
name|mainopt
init|=
literal|"C:En:t:u:v"
decl_stmt|;
specifier|const
name|char
modifier|*
name|subopt
init|=
name|NULL
decl_stmt|;
name|char
name|combinedopt
index|[
literal|256
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|optstart
init|=
literal|2
decl_stmt|;
name|int
name|devopen
init|=
literal|1
decl_stmt|;
ifndef|#
directive|ifndef
name|MINIMALISTIC
name|path_id_t
name|bus
decl_stmt|;
name|target_id_t
name|target
decl_stmt|;
name|lun_id_t
name|lun
decl_stmt|;
endif|#
directive|endif
comment|/* MINIMALISTIC */
name|cmdlist
operator|=
name|CAM_CMD_NONE
expr_stmt|;
name|arglist
operator|=
name|CAM_ARG_NONE
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get the base option. 	 */
name|optreturn
operator|=
name|getoption
argument_list|(
name|option_table
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cmdlist
argument_list|,
operator|&
name|arglist
argument_list|,
operator|&
name|subopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|optreturn
operator|==
name|CC_OR_AMBIGUOUS
condition|)
block|{
name|warnx
argument_list|(
literal|"ambiguous option %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optreturn
operator|==
name|CC_OR_NOT_FOUND
condition|)
block|{
name|warnx
argument_list|(
literal|"option %s not found"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Ahh, getopt(3) is a pain. 	 * 	 * This is a gross hack.  There really aren't many other good 	 * options (excuse the pun) for parsing options in a situation like 	 * this.  getopt is kinda braindead, so you end up having to run 	 * through the options twice, and give each invocation of getopt 	 * the option string for the other invocation. 	 * 	 * You would think that you could just have two groups of options. 	 * The first group would get parsed by the first invocation of 	 * getopt, and the second group would get parsed by the second 	 * invocation of getopt.  It doesn't quite work out that way.  When 	 * the first invocation of getopt finishes, it leaves optind pointing 	 * to the argument _after_ the first argument in the second group. 	 * So when the second invocation of getopt comes around, it doesn't 	 * recognize the first argument it gets and then bails out. 	 * 	 * A nice alternative would be to have a flag for getopt that says 	 * "just keep parsing arguments even when you encounter an unknown 	 * argument", but there isn't one.  So there's no real clean way to 	 * easily parse two sets of arguments without having one invocation 	 * of getopt know about the other. 	 * 	 * Without this hack, the first invocation of getopt would work as 	 * long as the generic arguments are first, but the second invocation 	 * (in the subfunction) would fail in one of two ways.  In the case 	 * where you don't set optreset, it would fail because optind may be 	 * pointing to the argument after the one it should be pointing at. 	 * In the case where you do set optreset, and reset optind, it would 	 * fail because getopt would run into the first set of options, which 	 * it doesn't understand. 	 * 	 * All of this would "sort of" work if you could somehow figure out 	 * whether optind had been incremented one option too far.  The 	 * mechanics of that, however, are more daunting than just giving 	 * both invocations all of the expect options for either invocation. 	 * 	 * Needless to say, I wouldn't mind if someone invented a better 	 * (non-GPL!) command line parsing interface than getopt.  I 	 * wouldn't mind if someone added more knobs to getopt to make it 	 * work better.  Who knows, I may talk myself into doing it someday, 	 * if the standards weenies let me.  As it is, it just leads to 	 * hackery like this and causes people to avoid it in some cases. 	 * 	 * KDM, September 8th, 1998 	 */
if|if
condition|(
name|subopt
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|combinedopt
argument_list|,
literal|"%s%s"
argument_list|,
name|mainopt
argument_list|,
name|subopt
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|combinedopt
argument_list|,
literal|"%s"
argument_list|,
name|mainopt
argument_list|)
expr_stmt|;
comment|/* 	 * For these options we do not parse optional device arguments and 	 * we do not open a passthrough device. 	 */
if|if
condition|(
operator|(
name|cmdlist
operator|==
name|CAM_CMD_RESCAN
operator|)
operator|||
operator|(
name|cmdlist
operator|==
name|CAM_CMD_RESET
operator|)
operator|||
operator|(
name|cmdlist
operator|==
name|CAM_CMD_DEVTREE
operator|)
operator|||
operator|(
name|cmdlist
operator|==
name|CAM_CMD_USAGE
operator|)
operator|||
operator|(
name|cmdlist
operator|==
name|CAM_CMD_DEBUG
operator|)
condition|)
name|devopen
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|MINIMALISTIC
if|if
condition|(
operator|(
name|devopen
operator|==
literal|1
operator|)
operator|&&
operator|(
name|argc
operator|>
literal|2
operator|&&
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|)
condition|)
block|{
name|char
name|name
index|[
literal|30
index|]
decl_stmt|;
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* device specified as bus:target[:lun] */
name|rv
operator|=
name|parse_btl
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|bus
argument_list|,
operator|&
name|target
argument_list|,
operator|&
name|lun
argument_list|,
operator|&
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<
literal|2
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"numeric device specification must "
literal|"be either bus:target, or "
literal|"bus:target:lun"
argument_list|)
expr_stmt|;
comment|/* default to 0 if lun was not specified */
if|if
condition|(
operator|(
name|arglist
operator|&
name|CAM_ARG_LUN
operator|)
operator|==
literal|0
condition|)
block|{
name|lun
operator|=
literal|0
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_LUN
expr_stmt|;
block|}
name|optstart
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cam_get_device
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
operator|&
name|unit
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|cam_errbuf
argument_list|)
expr_stmt|;
name|device
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_DEVICE
operator||
name|CAM_ARG_UNIT
expr_stmt|;
name|optstart
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MINIMALISTIC */
comment|/* 	 * Start getopt processing at argv[2/3], since we've already 	 * accepted argv[1..2] as the command name, and as a possible 	 * device name. 	 */
name|optind
operator|=
name|optstart
expr_stmt|;
comment|/* 	 * Now we run through the argument list looking for generic 	 * options, and ignoring options that possibly belong to 	 * subfunctions. 	 */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'C'
case|:
name|retry_count
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry_count
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"retry count %d is< 0"
argument_list|,
name|retry_count
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_RETRIES
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|arglist
operator||=
name|CAM_ARG_ERR_RECOVER
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|arglist
operator||=
name|CAM_ARG_DEVICE
expr_stmt|;
name|tstr
operator|=
name|optarg
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
name|device
operator|=
operator|(
name|char
operator|*
operator|)
name|strdup
argument_list|(
name|tstr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|timeout
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid timeout %d"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|/* Convert the timeout from seconds to ms */
name|timeout
operator|*=
literal|1000
expr_stmt|;
name|arglist
operator||=
name|CAM_ARG_TIMEOUT
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|arglist
operator||=
name|CAM_ARG_UNIT
expr_stmt|;
name|unit
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|arglist
operator||=
name|CAM_ARG_VERBOSE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
ifndef|#
directive|ifndef
name|MINIMALISTIC
comment|/* 	 * For most commands we'll want to open the passthrough device 	 * associated with the specified device.  In the case of the rescan 	 * commands, we don't use a passthrough device at all, just the 	 * transport layer device. 	 */
if|if
condition|(
name|devopen
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|arglist
operator|&
operator|(
name|CAM_ARG_BUS
operator||
name|CAM_ARG_TARGET
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_DEVICE
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|arglist
operator|&
name|CAM_ARG_UNIT
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"subcommand \"%s\" requires a valid device "
literal|"identifier"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cam_dev
operator|=
operator|(
operator|(
name|arglist
operator|&
operator|(
name|CAM_ARG_BUS
operator||
name|CAM_ARG_TARGET
operator|)
operator|)
condition|?
name|cam_open_btl
argument_list|(
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|O_RDWR
argument_list|,
name|NULL
argument_list|)
else|:
name|cam_open_spec_device
argument_list|(
name|device
argument_list|,
name|unit
argument_list|,
name|O_RDWR
argument_list|,
name|NULL
argument_list|)
operator|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|cam_errbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MINIMALISTIC */
comment|/* 	 * Reset optind to 2, and reset getopt, so these routines can parse 	 * the arguments again. 	 */
name|optind
operator|=
name|optstart
expr_stmt|;
name|optreset
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|cmdlist
condition|)
block|{
ifndef|#
directive|ifndef
name|MINIMALISTIC
case|case
name|CAM_CMD_DEVLIST
case|:
name|error
operator|=
name|getdevlist
argument_list|(
name|cam_dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_HPA
case|:
name|error
operator|=
name|atahpa
argument_list|(
name|cam_dev
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MINIMALISTIC */
case|case
name|CAM_CMD_DEVTREE
case|:
name|error
operator|=
name|getdevtree
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|MINIMALISTIC
case|case
name|CAM_CMD_TUR
case|:
name|error
operator|=
name|testunitready
argument_list|(
name|cam_dev
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_INQUIRY
case|:
name|error
operator|=
name|scsidoinquiry
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_IDENTIFY
case|:
name|error
operator|=
name|ataidentify
argument_list|(
name|cam_dev
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_STARTSTOP
case|:
name|error
operator|=
name|scsistart
argument_list|(
name|cam_dev
argument_list|,
name|arglist
operator|&
name|CAM_ARG_START_UNIT
argument_list|,
name|arglist
operator|&
name|CAM_ARG_EJECT
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MINIMALISTIC */
case|case
name|CAM_CMD_RESCAN
case|:
name|error
operator|=
name|dorescan_or_reset
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_RESET
case|:
name|error
operator|=
name|dorescan_or_reset
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|MINIMALISTIC
case|case
name|CAM_CMD_READ_DEFECTS
case|:
name|error
operator|=
name|readdefects
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_MODE_PAGE
case|:
name|modepage
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_SCSI_CMD
case|:
name|error
operator|=
name|scsicmd
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_SMP_CMD
case|:
name|error
operator|=
name|smpcmd
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_SMP_RG
case|:
name|error
operator|=
name|smpreportgeneral
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_SMP_PC
case|:
name|error
operator|=
name|smpphycontrol
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_SMP_PHYLIST
case|:
name|error
operator|=
name|smpphylist
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_SMP_MANINFO
case|:
name|error
operator|=
name|smpmaninfo
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_DEBUG
case|:
name|error
operator|=
name|camdebug
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_TAG
case|:
name|error
operator|=
name|tagcontrol
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_RATE
case|:
name|error
operator|=
name|ratecontrol
argument_list|(
name|cam_dev
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_FORMAT
case|:
name|error
operator|=
name|scsiformat
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_REPORTLUNS
case|:
name|error
operator|=
name|scsireportluns
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_READCAP
case|:
name|error
operator|=
name|scsireadcapacity
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_IDLE
case|:
case|case
name|CAM_CMD_STANDBY
case|:
case|case
name|CAM_CMD_SLEEP
case|:
name|error
operator|=
name|atapm
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_APM
case|:
case|case
name|CAM_CMD_AAM
case|:
name|error
operator|=
name|ataaxm
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_SECURITY
case|:
name|error
operator|=
name|atasecurity
argument_list|(
name|cam_dev
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_DOWNLOAD_FW
case|:
name|error
operator|=
name|fwdownload
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|arglist
operator|&
name|CAM_ARG_VERBOSE
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_SANITIZE
case|:
name|error
operator|=
name|scsisanitize
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_PERSIST
case|:
name|error
operator|=
name|scsipersist
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|arglist
operator|&
name|CAM_ARG_VERBOSE
argument_list|,
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_ATTRIB
case|:
name|error
operator|=
name|scsiattrib
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|arglist
operator|&
name|CAM_ARG_VERBOSE
argument_list|,
name|arglist
operator|&
name|CAM_ARG_ERR_RECOVER
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_OPCODES
case|:
name|error
operator|=
name|scsiopcodes
argument_list|(
name|cam_dev
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|,
name|arglist
operator|&
name|CAM_ARG_VERBOSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_CMD_REPROBE
case|:
name|error
operator|=
name|scsireprobe
argument_list|(
name|cam_dev
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MINIMALISTIC */
case|case
name|CAM_CMD_USAGE
case|:
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cam_dev
operator|!=
name|NULL
condition|)
name|cam_close_device
argument_list|(
name|cam_dev
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

