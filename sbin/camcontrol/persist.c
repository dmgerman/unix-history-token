begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 Spectra Logic Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * Authors: Ken Merry           (Spectra Logic Corporation)  */
end_comment

begin_comment
comment|/*  * SCSI Persistent Reservation support for camcontrol(8).  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_pass.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<camlib.h>
end_include

begin_include
include|#
directive|include
file|"camcontrol.h"
end_include

begin_struct
struct|struct
name|persist_transport_id
block|{
name|struct
name|scsi_transportid_header
modifier|*
name|hdr
decl_stmt|;
name|unsigned
name|int
name|alloc_len
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|persist_transport_id
argument_list|)
name|links
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Service Actions for PERSISTENT RESERVE IN.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsi_nv
name|persist_in_actions
index|[]
init|=
block|{
block|{
literal|"read_keys"
block|,
name|SPRI_RK
block|}
block|,
block|{
literal|"read_reservation"
block|,
name|SPRI_RR
block|}
block|,
block|{
literal|"report_capabilities"
block|,
name|SPRI_RC
block|}
block|,
block|{
literal|"read_full_status"
block|,
name|SPRI_RS
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Service Actions for PERSISTENT RESERVE OUT.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsi_nv
name|persist_out_actions
index|[]
init|=
block|{
block|{
literal|"register"
block|,
name|SPRO_REGISTER
block|}
block|,
block|{
literal|"reserve"
block|,
name|SPRO_RESERVE
block|}
block|,
block|{
literal|"release"
block|,
name|SPRO_RELEASE
block|}
block|,
block|{
literal|"clear"
block|,
name|SPRO_CLEAR
block|}
block|,
block|{
literal|"preempt"
block|,
name|SPRO_PREEMPT
block|}
block|,
block|{
literal|"preempt_abort"
block|,
name|SPRO_PRE_ABO
block|}
block|,
block|{
literal|"register_ignore"
block|,
name|SPRO_REG_IGNO
block|}
block|,
block|{
literal|"register_move"
block|,
name|SPRO_REG_MOVE
block|}
block|,
block|{
literal|"replace_lost"
block|,
name|SPRO_REPL_LOST_RES
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Known reservation scopes.  As of SPC-4, only LU_SCOPE is used in the  * spec.  The others are obsolete.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsi_nv
name|persist_scope_table
index|[]
init|=
block|{
block|{
literal|"lun"
block|,
name|SPR_LU_SCOPE
block|}
block|,
block|{
literal|"extent"
block|,
name|SPR_EXTENT_SCOPE
block|}
block|,
block|{
literal|"element"
block|,
name|SPR_ELEMENT_SCOPE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Reservation types.  The longer name for a given reservation type is  * listed first, so that it makes more sense when we print out the  * reservation type.  We step through the table linearly when looking for  * the text name for a particular numeric reservation type value.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsi_nv
name|persist_type_table
index|[]
init|=
block|{
block|{
literal|"read_shared"
block|,
name|SPR_TYPE_RD_SHARED
block|}
block|,
block|{
literal|"write_exclusive"
block|,
name|SPR_TYPE_WR_EX
block|}
block|,
block|{
literal|"wr_ex"
block|,
name|SPR_TYPE_WR_EX
block|}
block|,
block|{
literal|"read_exclusive"
block|,
name|SPR_TYPE_RD_EX
block|}
block|,
block|{
literal|"rd_ex"
block|,
name|SPR_TYPE_RD_EX
block|}
block|,
block|{
literal|"exclusive_access"
block|,
name|SPR_TYPE_EX_AC
block|}
block|,
block|{
literal|"ex_ac"
block|,
name|SPR_TYPE_EX_AC
block|}
block|,
block|{
literal|"write_exclusive_reg_only"
block|,
name|SPR_TYPE_WR_EX_RO
block|}
block|,
block|{
literal|"wr_ex_ro"
block|,
name|SPR_TYPE_WR_EX_RO
block|}
block|,
block|{
literal|"exclusive_access_reg_only"
block|,
name|SPR_TYPE_EX_AC_RO
block|}
block|,
block|{
literal|"ex_ac_ro"
block|,
name|SPR_TYPE_EX_AC_RO
block|}
block|,
block|{
literal|"write_exclusive_all_regs"
block|,
name|SPR_TYPE_WR_EX_AR
block|}
block|,
block|{
literal|"wr_ex_ar"
block|,
name|SPR_TYPE_WR_EX_AR
block|}
block|,
block|{
literal|"exclusive_access_all_regs"
block|,
name|SPR_TYPE_EX_AC_AR
block|}
block|,
block|{
literal|"ex_ac_ar"
block|,
name|SPR_TYPE_EX_AC_AR
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Print out the standard scope/type field.  */
end_comment

begin_function
specifier|static
name|void
name|persist_print_scopetype
parameter_list|(
name|uint8_t
name|scopetype
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tmpstr
decl_stmt|;
name|int
name|num_entries
decl_stmt|;
name|num_entries
operator|=
sizeof|sizeof
argument_list|(
name|persist_scope_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|persist_scope_table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tmpstr
operator|=
name|scsi_nv_to_str
argument_list|(
name|persist_scope_table
argument_list|,
name|num_entries
argument_list|,
name|scopetype
operator|&
name|SPR_SCOPE_MASK
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Scope: %s (%#x)\n"
argument_list|,
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
condition|?
name|tmpstr
else|:
literal|"Unknown"
argument_list|,
operator|(
name|scopetype
operator|&
name|SPR_SCOPE_MASK
operator|)
operator|>>
name|SPR_SCOPE_SHIFT
argument_list|)
expr_stmt|;
name|num_entries
operator|=
sizeof|sizeof
argument_list|(
name|persist_type_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|persist_type_table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tmpstr
operator|=
name|scsi_nv_to_str
argument_list|(
name|persist_type_table
argument_list|,
name|num_entries
argument_list|,
name|scopetype
operator|&
name|SPR_TYPE_MASK
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Type: %s (%#x)\n"
argument_list|,
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
condition|?
name|tmpstr
else|:
literal|"Unknown"
argument_list|,
name|scopetype
operator|&
name|SPR_TYPE_MASK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|persist_print_transportid
parameter_list|(
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|sb
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to allocate sbuf\n"
argument_list|)
expr_stmt|;
name|scsi_transportid_sbuf
argument_list|(
name|sb
argument_list|,
operator|(
expr|struct
name|scsi_transportid_header
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out a persistent reservation.  This is used with the READ  * RESERVATION (0x01) service action of the PERSISTENT RESERVE IN command.  */
end_comment

begin_function
specifier|static
name|void
name|persist_print_res
parameter_list|(
name|struct
name|scsi_per_res_in_header
modifier|*
name|hdr
parameter_list|,
name|uint32_t
name|valid_len
parameter_list|)
block|{
name|uint32_t
name|length
decl_stmt|;
name|struct
name|scsi_per_res_in_rsrv
modifier|*
name|res
decl_stmt|;
name|length
operator|=
name|scsi_4btoul
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
name|length
operator|=
name|MIN
argument_list|(
name|length
argument_list|,
name|valid_len
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
expr|struct
name|scsi_per_res_in_rsrv
operator|*
operator|)
name|hdr
expr_stmt|;
if|if
condition|(
name|length
operator|<
sizeof|sizeof
argument_list|(
name|res
operator|->
name|data
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|res
operator|->
name|data
operator|.
name|extent_length
argument_list|)
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"No reservations.\n"
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"unable to print reservation, only got %u "
literal|"valid bytes"
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"PRgeneration: %#x\n"
argument_list|,
name|scsi_4btoul
argument_list|(
name|res
operator|->
name|header
operator|.
name|generation
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Reservation Key: %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|scsi_8btou64
argument_list|(
name|res
operator|->
name|data
operator|.
name|reservation
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Scope address: %#x\n"
argument_list|,
name|scsi_4btoul
argument_list|(
name|res
operator|->
name|data
operator|.
name|scope_addr
argument_list|)
argument_list|)
expr_stmt|;
name|persist_print_scopetype
argument_list|(
name|res
operator|->
name|data
operator|.
name|scopetype
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Extent length: %u\n"
argument_list|,
name|scsi_2btoul
argument_list|(
name|res
operator|->
name|data
operator|.
name|extent_length
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out persistent reservation keys.  This is used with the READ KEYS  * service action of the PERSISTENT RESERVE IN command.  */
end_comment

begin_function
specifier|static
name|void
name|persist_print_keys
parameter_list|(
name|struct
name|scsi_per_res_in_header
modifier|*
name|hdr
parameter_list|,
name|uint32_t
name|valid_len
parameter_list|)
block|{
name|uint32_t
name|length
decl_stmt|,
name|num_keys
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|scsi_per_res_key
modifier|*
name|key
decl_stmt|;
name|length
operator|=
name|scsi_4btoul
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
name|length
operator|=
name|MIN
argument_list|(
name|length
argument_list|,
name|valid_len
argument_list|)
expr_stmt|;
name|num_keys
operator|=
name|length
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|key
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"PRgeneration: %#x\n"
argument_list|,
name|scsi_4btoul
argument_list|(
name|hdr
operator|->
name|generation
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%u key%s%s\n"
argument_list|,
name|num_keys
argument_list|,
operator|(
name|num_keys
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|,
operator|(
name|num_keys
operator|==
literal|0
operator|)
condition|?
literal|"."
else|:
literal|":"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|key
operator|=
operator|(
expr|struct
name|scsi_per_res_key
operator|*
operator|)
operator|&
name|hdr
index|[
literal|1
index|]
init|;
name|i
operator|<
name|num_keys
condition|;
name|i
operator|++
operator|,
name|key
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%u: %#jx\n"
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|scsi_8btou64
argument_list|(
name|key
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print out persistent reservation capabilities.  This is used with the  * REPORT CAPABILITIES service action of the PERSISTENT RESERVE IN command.  */
end_comment

begin_function
specifier|static
name|void
name|persist_print_cap
parameter_list|(
name|struct
name|scsi_per_res_cap
modifier|*
name|cap
parameter_list|,
name|uint32_t
name|valid_len
parameter_list|)
block|{
name|uint32_t
name|length
decl_stmt|;
name|int
name|check_type_mask
init|=
literal|0
decl_stmt|;
name|length
operator|=
name|scsi_2btoul
argument_list|(
name|cap
operator|->
name|length
argument_list|)
expr_stmt|;
name|length
operator|=
name|MIN
argument_list|(
name|length
argument_list|,
name|valid_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|__offsetof
argument_list|(
expr|struct
name|scsi_per_res_cap
argument_list|,
name|type_mask
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Insufficient data (%u bytes) to report "
literal|"full capabilities\n"
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|length
operator|>=
name|__offsetof
argument_list|(
expr|struct
name|scsi_per_res_cap
argument_list|,
name|reserved
argument_list|)
condition|)
name|check_type_mask
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Replace Lost Reservation Capable (RLR_C): %d\n"
argument_list|,
operator|(
name|cap
operator|->
name|flags1
operator|&
name|SPRI_RLR_C
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Compatible Reservation Handling (CRH): %d\n"
argument_list|,
operator|(
name|cap
operator|->
name|flags1
operator|&
name|SPRI_CRH
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Specify Initiator Ports Capable (SIP_C): %d\n"
argument_list|,
operator|(
name|cap
operator|->
name|flags1
operator|&
name|SPRI_SIP_C
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"All Target Ports Capable (ATP_C): %d\n"
argument_list|,
operator|(
name|cap
operator|->
name|flags1
operator|&
name|SPRI_ATP_C
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Persist Through Power Loss Capable (PTPL_C): %d\n"
argument_list|,
operator|(
name|cap
operator|->
name|flags1
operator|&
name|SPRI_PTPL_C
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"ALLOW COMMANDS field: (%#x)\n"
argument_list|,
operator|(
name|cap
operator|->
name|flags2
operator|&
name|SPRI_ALLOW_CMD_MASK
operator|)
operator|>>
name|SPRI_ALLOW_CMD_SHIFT
argument_list|)
expr_stmt|;
comment|/* 	 * These cases are cut-and-pasted from SPC4r36l.  There is no 	 * succinct way to describe these otherwise, and even with the 	 * verbose description, the user will probably have to refer to 	 * the spec to fully understand what is going on. 	 */
switch|switch
condition|(
name|cap
operator|->
name|flags2
operator|&
name|SPRI_ALLOW_CMD_MASK
condition|)
block|{
case|case
name|SPRI_ALLOW_1
case|:
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    The device server allows the TEST UNIT READY command through Write\n"
literal|"    Exclusive type reservations and Exclusive Access type reservations\n"
literal|"    and does not provide information about whether the following commands\n"
literal|"    are allowed through Write Exclusive type reservations:\n"
literal|"        a) the MODE SENSE command, READ ATTRIBUTE command, READ BUFFER\n"
literal|"           command, RECEIVE COPY RESULTS command, RECEIVE DIAGNOSTIC\n"
literal|"           RESULTS command, REPORT SUPPORTED OPERATION CODES command,\n"
literal|"           and REPORT SUPPORTED TASK MANAGEMENT FUNCTION command; and\n"
literal|"        b) the READ DEFECT DATA command (see SBC-3).\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPRI_ALLOW_2
case|:
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    The device server allows the TEST UNIT READY command through Write\n"
literal|"    Exclusive type reservations and Exclusive Access type reservations\n"
literal|"    and does not allow the following commands through Write Exclusive type\n"
literal|"    reservations:\n"
literal|"        a) the MODE SENSE command, READ ATTRIBUTE command, READ BUFFER\n"
literal|"           command, RECEIVE DIAGNOSTIC RESULTS command, REPORT SUPPORTED\n"
literal|"           OPERATION CODES command, and REPORT SUPPORTED TASK MANAGEMENT\n"
literal|"           FUNCTION command; and\n"
literal|"        b) the READ DEFECT DATA command.\n"
literal|"    The device server does not allow the RECEIVE COPY RESULTS command\n"
literal|"    through Write Exclusive type reservations or Exclusive Access type\n"
literal|"    reservations.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPRI_ALLOW_3
case|:
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    The device server allows the TEST UNIT READY command through Write\n"
literal|"    Exclusive type reservations and Exclusive Access type reservations\n"
literal|"    and allows the following commands through Write Exclusive type\n"
literal|"    reservations:\n"
literal|"        a) the MODE SENSE command, READ ATTRIBUTE command, READ BUFFER\n"
literal|"           command, RECEIVE DIAGNOSTIC RESULTS command, REPORT SUPPORTED\n"
literal|"           OPERATION CODES command, and REPORT SUPPORTED TASK MANAGEMENT\n"
literal|"           FUNCTION command; and\n"
literal|"        b) the READ DEFECT DATA command.\n"
literal|"    The device server does not allow the RECEIVE COPY RESULTS command\n"
literal|"    through Write Exclusive type reservations or Exclusive Access type\n"
literal|"    reservations.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPRI_ALLOW_4
case|:
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    The device server allows the TEST UNIT READY command and the RECEIVE\n"
literal|"    COPY RESULTS command through Write Exclusive type reservations and\n"
literal|"    Exclusive Access type reservations and allows the following commands\n"
literal|"    through Write Exclusive type reservations:\n"
literal|"        a) the MODE SENSE command, READ ATTRIBUTE command, READ BUFFER\n"
literal|"           command, RECEIVE DIAGNOSTIC RESULTS command, REPORT SUPPORTED\n"
literal|"           OPERATION CODES command, and REPORT SUPPORTED TASK MANAGEMENT\n"
literal|"           FUNCTION command; and\n"
literal|"        b) the READ DEFECT DATA command.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPRI_ALLOW_NA
case|:
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    No information is provided about whether certain commands are allowed\n"
literal|"    through certain types of persistent reservations.\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    Unknown ALLOW COMMANDS value %#x\n"
argument_list|,
operator|(
name|cap
operator|->
name|flags2
operator|&
name|SPRI_ALLOW_CMD_MASK
operator|)
operator|>>
name|SPRI_ALLOW_CMD_SHIFT
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Persist Through Power Loss Activated (PTPL_A): %d\n"
argument_list|,
operator|(
name|cap
operator|->
name|flags2
operator|&
name|SPRI_PTPL_A
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|check_type_mask
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cap
operator|->
name|flags2
operator|&
name|SPRI_TMV
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Supported Persistent Reservation Types:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    Write Exclusive - All Registrants "
literal|"(WR_EX_AR): %d\n"
argument_list|,
operator|(
name|cap
operator|->
name|type_mask
index|[
literal|0
index|]
operator|&
name|SPRI_TM_WR_EX_AR
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    Exclusive Access - Registrants Only "
literal|"(EX_AC_RO): %d\n"
argument_list|,
operator|(
name|cap
operator|->
name|type_mask
index|[
literal|0
index|]
operator|&
name|SPRI_TM_EX_AC_RO
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    Write Exclusive - Registrants Only "
literal|"(WR_EX_RO): %d\n"
argument_list|,
operator|(
name|cap
operator|->
name|type_mask
index|[
literal|0
index|]
operator|&
name|SPRI_TM_WR_EX_RO
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    Exclusive Access (EX_AC): %d\n"
argument_list|,
operator|(
name|cap
operator|->
name|type_mask
index|[
literal|0
index|]
operator|&
name|SPRI_TM_EX_AC
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    Write Exclusive (WR_EX): %d\n"
argument_list|,
operator|(
name|cap
operator|->
name|type_mask
index|[
literal|0
index|]
operator|&
name|SPRI_TM_WR_EX
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    Exclusive Access - All Registrants "
literal|"(EX_AC_AR): %d\n"
argument_list|,
operator|(
name|cap
operator|->
name|type_mask
index|[
literal|1
index|]
operator|&
name|SPRI_TM_EX_AC_AR
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Persistent Reservation Type Mask is NOT "
literal|"valid\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|persist_print_full
parameter_list|(
name|struct
name|scsi_per_res_in_header
modifier|*
name|hdr
parameter_list|,
name|uint32_t
name|valid_len
parameter_list|)
block|{
name|uint32_t
name|length
decl_stmt|,
name|len_to_go
init|=
literal|0
decl_stmt|;
name|struct
name|scsi_per_res_in_full_desc
modifier|*
name|desc
decl_stmt|;
name|uint8_t
modifier|*
name|cur_pos
decl_stmt|;
name|int
name|i
decl_stmt|;
name|length
operator|=
name|scsi_4btoul
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
name|length
operator|=
name|MIN
argument_list|(
name|length
argument_list|,
name|valid_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"No reservations.\n"
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"unable to print reservation, only got %u "
literal|"valid bytes"
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"PRgeneration: %#x\n"
argument_list|,
name|scsi_4btoul
argument_list|(
name|hdr
operator|->
name|generation
argument_list|)
argument_list|)
expr_stmt|;
name|cur_pos
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|hdr
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|len_to_go
operator|=
name|length
operator|,
name|i
operator|=
literal|0
operator|,
name|desc
operator|=
operator|(
expr|struct
name|scsi_per_res_in_full_desc
operator|*
operator|)
name|cur_pos
init|;
name|len_to_go
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
condition|;
name|desc
operator|=
operator|(
expr|struct
name|scsi_per_res_in_full_desc
operator|*
operator|)
name|cur_pos
operator|,
name|i
operator|++
control|)
block|{
name|uint32_t
name|additional_length
decl_stmt|,
name|cur_length
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Reservation Key: %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|scsi_8btou64
argument_list|(
name|desc
operator|->
name|res_key
operator|.
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"All Target Ports (ALL_TG_PT): %d\n"
argument_list|,
operator|(
name|desc
operator|->
name|flags
operator|&
name|SPRI_FULL_ALL_TG_PT
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Reservation Holder (R_HOLDER): %d\n"
argument_list|,
operator|(
name|desc
operator|->
name|flags
operator|&
name|SPRI_FULL_R_HOLDER
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|flags
operator|&
name|SPRI_FULL_R_HOLDER
condition|)
name|persist_print_scopetype
argument_list|(
name|desc
operator|->
name|scopetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|flags
operator|&
name|SPRI_FULL_ALL_TG_PT
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Relative Target Port ID: %#x\n"
argument_list|,
name|scsi_2btoul
argument_list|(
name|desc
operator|->
name|rel_trgt_port_id
argument_list|)
argument_list|)
expr_stmt|;
name|additional_length
operator|=
name|scsi_4btoul
argument_list|(
name|desc
operator|->
name|additional_length
argument_list|)
expr_stmt|;
name|persist_print_transportid
argument_list|(
name|desc
operator|->
name|transport_id
argument_list|,
name|additional_length
argument_list|)
expr_stmt|;
name|cur_length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
operator|+
name|additional_length
expr_stmt|;
name|len_to_go
operator|-=
name|cur_length
expr_stmt|;
name|cur_pos
operator|+=
name|cur_length
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|scsipersist
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|combinedopt
parameter_list|,
name|int
name|task_attr
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|verbosemode
parameter_list|,
name|int
name|err_recover
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
name|NULL
decl_stmt|;
name|int
name|c
decl_stmt|,
name|in
init|=
literal|0
decl_stmt|,
name|out
init|=
literal|0
decl_stmt|;
name|int
name|action
init|=
operator|-
literal|1
decl_stmt|,
name|num_ids
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint32_t
name|res_len
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|rel_tgt_port
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|res_buf
init|=
name|NULL
decl_stmt|;
name|int
name|scope
init|=
name|SPR_LU_SCOPE
decl_stmt|,
name|res_type
init|=
literal|0
decl_stmt|,
name|key_set
init|=
literal|0
decl_stmt|,
name|sa_key_set
init|=
literal|0
decl_stmt|;
name|struct
name|persist_transport_id
modifier|*
name|id
decl_stmt|,
modifier|*
name|id2
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|persist_transport_id
argument_list|)
name|transport_id_list
expr_stmt|;
name|uint64_t
name|key
init|=
literal|0
decl_stmt|,
name|sa_key
init|=
literal|0
decl_stmt|;
name|struct
name|scsi_nv
modifier|*
name|table
init|=
name|NULL
decl_stmt|;
name|size_t
name|table_size
init|=
literal|0
decl_stmt|,
name|id_len
init|=
literal|0
decl_stmt|;
name|uint32_t
name|valid_len
init|=
literal|0
decl_stmt|;
name|int
name|all_tg_pt
init|=
literal|0
decl_stmt|,
name|aptpl
init|=
literal|0
decl_stmt|,
name|spec_i_pt
init|=
literal|0
decl_stmt|,
name|unreg
init|=
literal|0
decl_stmt|,
name|rel_port_set
init|=
literal|0
decl_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|transport_id_list
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating CCB"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|CCB_CLEAR_ALL_EXCEPT_HDR
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|combinedopt
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|all_tg_pt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
block|{
name|int
name|error_str_len
init|=
literal|128
decl_stmt|;
name|char
name|error_str
index|[
name|error_str_len
index|]
decl_stmt|;
name|char
modifier|*
name|id_str
decl_stmt|;
name|id
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating %zu bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bzero
argument_list|(
name|id
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|id_str
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|id_str
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error duplicating string %s"
argument_list|,
name|__func__
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|error
operator|=
name|scsi_parse_transportid
argument_list|(
name|id_str
argument_list|,
operator|&
name|id
operator|->
name|hdr
argument_list|,
operator|&
name|id
operator|->
name|alloc_len
argument_list|,
name|error_str
argument_list|,
name|error_str_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|id_str
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|free
argument_list|(
name|id_str
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|transport_id_list
argument_list|,
name|id
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|num_ids
operator|++
expr_stmt|;
name|id_len
operator|+=
name|id
operator|->
name|alloc_len
expr_stmt|;
break|break;
block|}
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|uint64_t
name|tmpval
decl_stmt|;
name|tmpval
operator|=
name|strtoumax
argument_list|(
name|optarg
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: invalid key argument %s"
argument_list|,
name|__func__
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'k'
condition|)
block|{
name|key
operator|=
name|tmpval
expr_stmt|;
name|key_set
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sa_key
operator|=
name|tmpval
expr_stmt|;
name|sa_key_set
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'i'
case|:
case|case
literal|'o'
case|:
block|{
name|scsi_nv_status
name|status
decl_stmt|;
name|int
name|table_entry
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'i'
condition|)
block|{
name|in
operator|=
literal|1
expr_stmt|;
name|table
operator|=
name|persist_in_actions
expr_stmt|;
name|table_size
operator|=
sizeof|sizeof
argument_list|(
name|persist_in_actions
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|persist_in_actions
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
literal|1
expr_stmt|;
name|table
operator|=
name|persist_out_actions
expr_stmt|;
name|table_size
operator|=
sizeof|sizeof
argument_list|(
name|persist_out_actions
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|persist_out_actions
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in
operator|+
name|out
operator|)
operator|>
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: only one in (-i) or out (-o) "
literal|"action is allowed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|status
operator|=
name|scsi_get_nv
argument_list|(
name|table
argument_list|,
name|table_size
argument_list|,
name|optarg
argument_list|,
operator|&
name|table_entry
argument_list|,
name|SCSI_NV_FLAG_IG_CASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCSI_NV_FOUND
condition|)
name|action
operator|=
name|table
index|[
name|table_entry
index|]
operator|.
name|value
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"%s: %s %s option %s"
argument_list|,
name|__func__
argument_list|,
operator|(
name|status
operator|==
name|SCSI_NV_AMBIGUOUS
operator|)
condition|?
literal|"ambiguous"
else|:
literal|"invalid"
argument_list|,
name|in
condition|?
literal|"in"
else|:
literal|"out"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
block|}
case|case
literal|'p'
case|:
name|aptpl
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|rel_tgt_port
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: invalid relative target port %s"
argument_list|,
name|__func__
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|rel_port_set
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
literal|'s'
case|:
block|{
name|size_t
name|scope_size
decl_stmt|;
name|struct
name|scsi_nv
modifier|*
name|scope_table
init|=
name|NULL
decl_stmt|;
name|scsi_nv_status
name|status
decl_stmt|;
name|int
name|table_entry
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|;
comment|/* 			 * First check to see if the user gave us a numeric 			 * argument.  If so, we'll try using it. 			 */
if|if
condition|(
name|isdigit
argument_list|(
name|optarg
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|scope
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: invalid scope %s"
argument_list|,
name|__func__
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|scope
operator|=
operator|(
name|scope
operator|<<
name|SPR_SCOPE_SHIFT
operator|)
operator|&
name|SPR_SCOPE_MASK
expr_stmt|;
break|break;
block|}
name|scope_size
operator|=
sizeof|sizeof
argument_list|(
name|persist_scope_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|persist_scope_table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|scope_table
operator|=
name|persist_scope_table
expr_stmt|;
name|status
operator|=
name|scsi_get_nv
argument_list|(
name|scope_table
argument_list|,
name|scope_size
argument_list|,
name|optarg
argument_list|,
operator|&
name|table_entry
argument_list|,
name|SCSI_NV_FLAG_IG_CASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCSI_NV_FOUND
condition|)
name|scope
operator|=
name|scope_table
index|[
name|table_entry
index|]
operator|.
name|value
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"%s: %s scope %s"
argument_list|,
name|__func__
argument_list|,
operator|(
name|status
operator|==
name|SCSI_NV_AMBIGUOUS
operator|)
condition|?
literal|"ambiguous"
else|:
literal|"invalid"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
block|}
case|case
literal|'S'
case|:
name|spec_i_pt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
block|{
name|size_t
name|res_type_size
decl_stmt|;
name|struct
name|scsi_nv
modifier|*
name|rtype_table
init|=
name|NULL
decl_stmt|;
name|scsi_nv_status
name|status
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|;
name|int
name|table_entry
init|=
literal|0
decl_stmt|;
comment|/* 			 * First check to see if the user gave us a numeric 			 * argument.  If so, we'll try using it. 			 */
if|if
condition|(
name|isdigit
argument_list|(
name|optarg
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|res_type
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: invalid reservation type %s"
argument_list|,
name|__func__
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
block|}
name|res_type_size
operator|=
sizeof|sizeof
argument_list|(
name|persist_type_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|persist_type_table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rtype_table
operator|=
name|persist_type_table
expr_stmt|;
name|status
operator|=
name|scsi_get_nv
argument_list|(
name|rtype_table
argument_list|,
name|res_type_size
argument_list|,
name|optarg
argument_list|,
operator|&
name|table_entry
argument_list|,
name|SCSI_NV_FLAG_IG_CASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCSI_NV_FOUND
condition|)
name|res_type
operator|=
name|rtype_table
index|[
name|table_entry
index|]
operator|.
name|value
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"%s: %s reservation type %s"
argument_list|,
name|__func__
argument_list|,
operator|(
name|status
operator|==
name|SCSI_NV_AMBIGUOUS
operator|)
condition|?
literal|"ambiguous"
else|:
literal|"invalid"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
block|}
case|case
literal|'U'
case|:
name|unreg
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|in
operator|+
name|out
operator|)
operator|!=
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: you must specify one of -i or -o"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * Note that we don't really try to figure out whether the user 	 * needs to specify one or both keys.  There are a number of 	 * scenarios, and sometimes 0 is a valid and desired value. 	 */
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SPRI_RK
case|:
case|case
name|SPRI_RR
case|:
case|case
name|SPRI_RS
case|:
comment|/* 			 * Allocate the maximum length possible for these 			 * service actions.  According to the spec, the 			 * target is supposed to return the available 			 * length in the header, regardless of the 			 * allocation length.  In practice, though, with 			 * the READ FULL STATUS (SPRI_RS) service action, 			 * some Seagate drives (in particular a 			 * Constellation ES,<SEAGATE ST32000444SS 0006>) 			 * don't return the available length if you only 			 * allocate the length of the header.  So just 			 * allocate the maximum here so we don't miss 			 * anything. 			 */
name|res_len
operator|=
name|SPRI_MAX_LEN
expr_stmt|;
break|break;
case|case
name|SPRI_RC
case|:
name|res_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_cap
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* In theory we should catch this above */
name|warnx
argument_list|(
literal|"%s: invalid action %d"
argument_list|,
name|__func__
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
block|}
block|}
else|else
block|{
comment|/* 		 * XXX KDM need to add length for transport IDs for the 		 * register and move service action and the register 		 * service action with the SPEC_I_PT bit set. 		 */
if|if
condition|(
name|action
operator|==
name|SPRO_REG_MOVE
condition|)
block|{
if|if
condition|(
name|num_ids
operator|!=
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: register and move requires a "
literal|"single transport ID (-I)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|rel_port_set
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: register and move requires a "
literal|"relative target port (-R)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|res_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_reg_move
argument_list|)
operator|+
name|id_len
expr_stmt|;
block|}
else|else
block|{
name|res_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_out_parms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|action
operator|==
name|SPRO_REGISTER
operator|)
operator|&&
operator|(
name|num_ids
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 				 * If the user specifies any IDs with the 				 * register service action, turn on the 				 * spec_i_pt bit. 				 */
name|spec_i_pt
operator|=
literal|1
expr_stmt|;
name|res_len
operator|+=
name|id_len
expr_stmt|;
name|res_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_out_trans_ids
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|retry
label|:
if|if
condition|(
name|res_buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|res_buf
argument_list|)
expr_stmt|;
name|res_buf
operator|=
name|NULL
expr_stmt|;
block|}
name|res_buf
operator|=
name|malloc
argument_list|(
name|res_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_buf
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: error allocating %d bytes"
argument_list|,
name|__func__
argument_list|,
name|res_len
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bzero
argument_list|(
name|res_buf
argument_list|,
name|res_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
name|scsi_persistent_reserve_in
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*tag_action*/
name|task_attr
argument_list|,
comment|/*service_action*/
name|action
argument_list|,
comment|/*data_ptr*/
name|res_buf
argument_list|,
comment|/*dxfer_len*/
name|res_len
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SPRO_REGISTER
case|:
if|if
condition|(
name|spec_i_pt
operator|!=
literal|0
condition|)
block|{
name|struct
name|scsi_per_res_out_trans_ids
modifier|*
name|id_hdr
decl_stmt|;
name|uint8_t
modifier|*
name|bufptr
decl_stmt|;
name|bufptr
operator|=
name|res_buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_out_parms
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_out_trans_ids
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|id
argument_list|,
argument|&transport_id_list
argument_list|,
argument|links
argument_list|)
block|{
name|bcopy
argument_list|(
name|id
operator|->
name|hdr
argument_list|,
name|bufptr
argument_list|,
name|id
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
name|bufptr
operator|+=
name|id
operator|->
name|alloc_len
expr_stmt|;
block|}
name|id_hdr
operator|=
operator|(
expr|struct
name|scsi_per_res_out_trans_ids
operator|*
operator|)
operator|(
name|res_buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_per_res_out_parms
argument_list|)
operator|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|id_len
argument_list|,
name|id_hdr
operator|->
name|additional_length
argument_list|)
expr_stmt|;
block|}
case|case
name|SPRO_REG_IGNO
case|:
case|case
name|SPRO_PREEMPT
case|:
case|case
name|SPRO_PRE_ABO
case|:
case|case
name|SPRO_RESERVE
case|:
case|case
name|SPRO_RELEASE
case|:
case|case
name|SPRO_CLEAR
case|:
case|case
name|SPRO_REPL_LOST_RES
case|:
block|{
name|struct
name|scsi_per_res_out_parms
modifier|*
name|parms
decl_stmt|;
name|parms
operator|=
operator|(
expr|struct
name|scsi_per_res_out_parms
operator|*
operator|)
name|res_buf
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|key
argument_list|,
name|parms
operator|->
name|res_key
operator|.
name|key
argument_list|)
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|sa_key
argument_list|,
name|parms
operator|->
name|serv_act_res_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_i_pt
operator|!=
literal|0
condition|)
name|parms
operator|->
name|flags
operator||=
name|SPR_SPEC_I_PT
expr_stmt|;
if|if
condition|(
name|all_tg_pt
operator|!=
literal|0
condition|)
name|parms
operator|->
name|flags
operator||=
name|SPR_ALL_TG_PT
expr_stmt|;
if|if
condition|(
name|aptpl
operator|!=
literal|0
condition|)
name|parms
operator|->
name|flags
operator||=
name|SPR_APTPL
expr_stmt|;
break|break;
block|}
case|case
name|SPRO_REG_MOVE
case|:
block|{
name|struct
name|scsi_per_res_reg_move
modifier|*
name|reg_move
decl_stmt|;
name|uint8_t
modifier|*
name|bufptr
decl_stmt|;
name|reg_move
operator|=
operator|(
expr|struct
name|scsi_per_res_reg_move
operator|*
operator|)
name|res_buf
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|key
argument_list|,
name|reg_move
operator|->
name|res_key
operator|.
name|key
argument_list|)
expr_stmt|;
name|scsi_u64to8b
argument_list|(
name|sa_key
argument_list|,
name|reg_move
operator|->
name|serv_act_res_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|unreg
operator|!=
literal|0
condition|)
name|reg_move
operator|->
name|flags
operator||=
name|SPR_REG_MOVE_UNREG
expr_stmt|;
if|if
condition|(
name|aptpl
operator|!=
literal|0
condition|)
name|reg_move
operator|->
name|flags
operator||=
name|SPR_REG_MOVE_APTPL
expr_stmt|;
name|scsi_ulto2b
argument_list|(
name|rel_tgt_port
argument_list|,
name|reg_move
operator|->
name|rel_trgt_port_id
argument_list|)
expr_stmt|;
name|id
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|transport_id_list
argument_list|)
expr_stmt|;
comment|/* 			 * This shouldn't happen, since we already checked 			 * the number of IDs above. 			 */
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: No transport IDs found!"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bufptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|reg_move
index|[
literal|1
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|id
operator|->
name|hdr
argument_list|,
name|bufptr
argument_list|,
name|id
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
name|scsi_ulto4b
argument_list|(
name|id
operator|->
name|alloc_len
argument_list|,
name|reg_move
operator|->
name|transport_id_length
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
name|scsi_persistent_reserve_out
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*tag_action*/
name|task_attr
argument_list|,
comment|/*service_action*/
name|action
argument_list|,
comment|/*scope*/
name|scope
argument_list|,
comment|/*res_type*/
name|res_type
argument_list|,
comment|/*data_ptr*/
name|res_buf
argument_list|,
comment|/*dxfer_len*/
name|res_len
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
block|}
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|err_recover
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending PERSISTENT RESERVE %s"
argument_list|,
operator|(
name|in
operator|!=
literal|0
operator|)
condition|?
literal|"IN"
else|:
literal|"OUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosemode
operator|!=
literal|0
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|verbosemode
operator|!=
literal|0
condition|)
block|{
name|cam_error_print
argument_list|(
name|device
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|in
operator|==
literal|0
condition|)
goto|goto
name|bailout
goto|;
name|valid_len
operator|=
name|res_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|resid
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SPRI_RK
case|:
case|case
name|SPRI_RR
case|:
case|case
name|SPRI_RS
case|:
block|{
name|struct
name|scsi_per_res_in_header
modifier|*
name|hdr
decl_stmt|;
name|uint32_t
name|hdr_len
decl_stmt|;
if|if
condition|(
name|valid_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: only got %d valid bytes, need %zd"
argument_list|,
name|__func__
argument_list|,
name|valid_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|hdr
operator|=
operator|(
expr|struct
name|scsi_per_res_in_header
operator|*
operator|)
name|res_buf
expr_stmt|;
name|hdr_len
operator|=
name|scsi_4btoul
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_len
operator|>
operator|(
name|res_len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|)
condition|)
block|{
name|res_len
operator|=
name|hdr_len
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|action
operator|==
name|SPRI_RK
condition|)
block|{
name|persist_print_keys
argument_list|(
name|hdr
argument_list|,
name|valid_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|SPRI_RR
condition|)
block|{
name|persist_print_res
argument_list|(
name|hdr
argument_list|,
name|valid_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|persist_print_full
argument_list|(
name|hdr
argument_list|,
name|valid_len
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SPRI_RC
case|:
block|{
name|struct
name|scsi_per_res_cap
modifier|*
name|cap
decl_stmt|;
name|uint32_t
name|cap_len
decl_stmt|;
if|if
condition|(
name|valid_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|cap
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: only got %u valid bytes, need %zd"
argument_list|,
name|__func__
argument_list|,
name|valid_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cap
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|cap
operator|=
operator|(
expr|struct
name|scsi_per_res_cap
operator|*
operator|)
name|res_buf
expr_stmt|;
name|cap_len
operator|=
name|scsi_2btoul
argument_list|(
name|cap
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap_len
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|cap
argument_list|)
condition|)
block|{
comment|/* 			 * We should be able to deal with this, 			 * it's just more trouble. 			 */
name|warnx
argument_list|(
literal|"%s: reported size %u is different "
literal|"than expected size %zd"
argument_list|,
name|__func__
argument_list|,
name|cap_len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cap
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If there is more data available, grab it all, 		 * even though we don't really know what to do with 		 * the extra data since it obviously wasn't in the 		 * spec when this code was written. 		 */
if|if
condition|(
name|cap_len
operator|>
name|res_len
condition|)
block|{
name|res_len
operator|=
name|cap_len
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|persist_print_cap
argument_list|(
name|cap
argument_list|,
name|valid_len
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
name|bailout
label|:
name|free
argument_list|(
name|res_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|id
argument_list|,
argument|&transport_id_list
argument_list|,
argument|links
argument_list|,
argument|id2
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|transport_id_list
argument_list|,
name|id
argument_list|,
name|persist_transport_id
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

