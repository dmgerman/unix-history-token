begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2009, 2010 Jeffrey W. Roberson<jeff@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dir.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<libufs.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"fsck.h"
end_include

begin_define
define|#
directive|define
name|DOTDOT_OFFSET
value|DIRECTSIZ(1)
end_define

begin_define
define|#
directive|define
name|SUJ_HASHSIZE
value|2048
end_define

begin_define
define|#
directive|define
name|SUJ_HASHMASK
value|(SUJ_HASHSIZE - 1)
end_define

begin_define
define|#
directive|define
name|SUJ_HASH
parameter_list|(
name|x
parameter_list|)
value|((x * 2654435761)& SUJ_HASHMASK)
end_define

begin_struct
struct|struct
name|suj_seg
block|{
name|TAILQ_ENTRY
argument_list|(
argument|suj_seg
argument_list|)
name|ss_next
expr_stmt|;
name|struct
name|jsegrec
name|ss_rec
decl_stmt|;
name|uint8_t
modifier|*
name|ss_blk
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|suj_rec
block|{
name|TAILQ_ENTRY
argument_list|(
argument|suj_rec
argument_list|)
name|sr_next
expr_stmt|;
name|union
name|jrec
modifier|*
name|sr_rec
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|srechd
argument_list|,
name|suj_rec
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|suj_ino
block|{
name|LIST_ENTRY
argument_list|(
argument|suj_ino
argument_list|)
name|si_next
expr_stmt|;
name|struct
name|srechd
name|si_recs
decl_stmt|;
name|struct
name|srechd
name|si_newrecs
decl_stmt|;
name|struct
name|srechd
name|si_movs
decl_stmt|;
name|struct
name|jtrncrec
modifier|*
name|si_trunc
decl_stmt|;
name|ino_t
name|si_ino
decl_stmt|;
name|char
name|si_skipparent
decl_stmt|;
name|char
name|si_hasrecs
decl_stmt|;
name|char
name|si_blkadj
decl_stmt|;
name|char
name|si_linkadj
decl_stmt|;
name|int
name|si_mode
decl_stmt|;
name|nlink_t
name|si_nlinkadj
decl_stmt|;
name|nlink_t
name|si_nlink
decl_stmt|;
name|nlink_t
name|si_dotlinks
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|inohd
argument_list|,
name|suj_ino
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|suj_blk
block|{
name|LIST_ENTRY
argument_list|(
argument|suj_blk
argument_list|)
name|sb_next
expr_stmt|;
name|struct
name|srechd
name|sb_recs
decl_stmt|;
name|ufs2_daddr_t
name|sb_blk
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|blkhd
argument_list|,
name|suj_blk
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|data_blk
block|{
name|LIST_ENTRY
argument_list|(
argument|data_blk
argument_list|)
name|db_next
expr_stmt|;
name|uint8_t
modifier|*
name|db_buf
decl_stmt|;
name|ufs2_daddr_t
name|db_blk
decl_stmt|;
name|int
name|db_size
decl_stmt|;
name|int
name|db_dirty
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ino_blk
block|{
name|LIST_ENTRY
argument_list|(
argument|ino_blk
argument_list|)
name|ib_next
expr_stmt|;
name|uint8_t
modifier|*
name|ib_buf
decl_stmt|;
name|int
name|ib_dirty
decl_stmt|;
name|ufs2_daddr_t
name|ib_blk
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|iblkhd
argument_list|,
name|ino_blk
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|suj_cg
block|{
name|LIST_ENTRY
argument_list|(
argument|suj_cg
argument_list|)
name|sc_next
expr_stmt|;
name|struct
name|blkhd
name|sc_blkhash
index|[
name|SUJ_HASHSIZE
index|]
decl_stmt|;
name|struct
name|inohd
name|sc_inohash
index|[
name|SUJ_HASHSIZE
index|]
decl_stmt|;
name|struct
name|iblkhd
name|sc_iblkhash
index|[
name|SUJ_HASHSIZE
index|]
decl_stmt|;
name|struct
name|ino_blk
modifier|*
name|sc_lastiblk
decl_stmt|;
name|struct
name|suj_ino
modifier|*
name|sc_lastino
decl_stmt|;
name|struct
name|suj_blk
modifier|*
name|sc_lastblk
decl_stmt|;
name|uint8_t
modifier|*
name|sc_cgbuf
decl_stmt|;
name|struct
name|cg
modifier|*
name|sc_cgp
decl_stmt|;
name|int
name|sc_dirty
decl_stmt|;
name|int
name|sc_cgx
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|LIST_HEAD
argument_list|(
argument|cghd
argument_list|,
argument|suj_cg
argument_list|)
end_macro

begin_expr_stmt
name|cghash
index|[
name|SUJ_HASHSIZE
index|]
expr_stmt|;
end_expr_stmt

begin_macro
name|LIST_HEAD
argument_list|(
argument|dblkhd
argument_list|,
argument|data_blk
argument_list|)
end_macro

begin_expr_stmt
name|dbhash
index|[
name|SUJ_HASHSIZE
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|suj_cg
modifier|*
name|lastcg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|data_blk
modifier|*
name|lastblk
decl_stmt|;
end_decl_stmt

begin_macro
name|TAILQ_HEAD
argument_list|(
argument|seghd
argument_list|,
argument|suj_seg
argument_list|)
end_macro

begin_expr_stmt
name|allsegs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uint64_t
name|oldseq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uufsd
modifier|*
name|disk
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fs
modifier|*
name|fs
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|sujino
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Summary statistics.  */
end_comment

begin_decl_stmt
name|uint64_t
name|freefrags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|freeblocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|freeinos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|freedir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|jbytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|jrecs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|jmpbuf
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|ino_visitor
function_decl|)
parameter_list|(
name|ino_t
parameter_list|,
name|ufs_lbn_t
parameter_list|,
name|ufs2_daddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|void
name|err_suj
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
operator|...
argument_list|)
name|__dead2
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ino_trunc
parameter_list|(
name|ino_t
parameter_list|,
name|off_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ino_decr
parameter_list|(
name|ino_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ino_adjust
parameter_list|(
name|struct
name|suj_ino
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ino_build
parameter_list|(
name|struct
name|suj_ino
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|blk_isfree
parameter_list|(
name|ufs2_daddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
modifier|*
name|errmalloc
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
name|void
modifier|*
name|a
decl_stmt|;
name|a
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"malloc(%zu)"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When hit a fatal error in journalling check, print out  * the error and then offer to fallback to normal fsck.  */
end_comment

begin_function
specifier|static
name|void
name|err_suj
parameter_list|(
specifier|const
name|char
modifier|*
specifier|restrict
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|preen
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s: "
argument_list|,
name|cdevname
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stdout
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|jmpbuf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open the given provider, load superblock.  */
end_comment

begin_function
specifier|static
name|void
name|opendisk
parameter_list|(
specifier|const
name|char
modifier|*
name|devnam
parameter_list|)
block|{
if|if
condition|(
name|disk
operator|!=
name|NULL
condition|)
return|return;
name|disk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|disk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"malloc(%zu)"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|disk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ufs_disk_fillout
argument_list|(
name|disk
argument_list|,
name|devnam
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ufs_disk_fillout(%s) failed: %s"
argument_list|,
name|devnam
argument_list|,
name|disk
operator|->
name|d_error
argument_list|)
expr_stmt|;
block|}
name|fs
operator|=
operator|&
name|disk
operator|->
name|d_fs
expr_stmt|;
if|if
condition|(
name|real_dev_bsize
operator|==
literal|0
operator|&&
name|ioctl
argument_list|(
name|disk
operator|->
name|d_fd
argument_list|,
name|DIOCGSECTORSIZE
argument_list|,
operator|&
name|real_dev_bsize
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|real_dev_bsize
operator|=
name|secsize
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"dev_bsize %ld\n"
argument_list|,
name|real_dev_bsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark file system as clean, write the super-block back, close the disk.  */
end_comment

begin_function
specifier|static
name|void
name|closedisk
parameter_list|(
specifier|const
name|char
modifier|*
name|devnam
parameter_list|)
block|{
name|struct
name|csum
modifier|*
name|cgsum
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Recompute the fs summary info from correct cs summaries. 	 */
name|bzero
argument_list|(
operator|&
name|fs
operator|->
name|fs_cstotal
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|csum_total
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|i
operator|++
control|)
block|{
name|cgsum
operator|=
operator|&
name|fs
operator|->
name|fs_cs
argument_list|(
name|fs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nffree
operator|+=
name|cgsum
operator|->
name|cs_nffree
expr_stmt|;
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nbfree
operator|+=
name|cgsum
operator|->
name|cs_nbfree
expr_stmt|;
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nifree
operator|+=
name|cgsum
operator|->
name|cs_nifree
expr_stmt|;
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_ndir
operator|+=
name|cgsum
operator|->
name|cs_ndir
expr_stmt|;
block|}
name|fs
operator|->
name|fs_pendinginodes
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|fs_pendingblocks
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|fs_clean
operator|=
literal|1
expr_stmt|;
name|fs
operator|->
name|fs_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_mtime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbwrite
argument_list|(
name|disk
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"sbwrite(%s)"
argument_list|,
name|devnam
argument_list|)
expr_stmt|;
if|if
condition|(
name|ufs_disk_close
argument_list|(
name|disk
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ufs_disk_close(%s)"
argument_list|,
name|devnam
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|disk
operator|=
name|NULL
expr_stmt|;
name|fs
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lookup a cg by number in the hash so we can keep track of which cgs  * need stats rebuilt.  */
end_comment

begin_function
specifier|static
name|struct
name|suj_cg
modifier|*
name|cg_lookup
parameter_list|(
name|int
name|cgx
parameter_list|)
block|{
name|struct
name|cghd
modifier|*
name|hd
decl_stmt|;
name|struct
name|suj_cg
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|cgx
operator|<
literal|0
operator|||
name|cgx
operator|>=
name|fs
operator|->
name|fs_ncg
condition|)
name|err_suj
argument_list|(
literal|"Bad cg number %d\n"
argument_list|,
name|cgx
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastcg
operator|&&
name|lastcg
operator|->
name|sc_cgx
operator|==
name|cgx
condition|)
return|return
operator|(
name|lastcg
operator|)
return|;
name|hd
operator|=
operator|&
name|cghash
index|[
name|SUJ_HASH
argument_list|(
name|cgx
argument_list|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sc
argument_list|,
argument|hd
argument_list|,
argument|sc_next
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_cgx
operator|==
name|cgx
condition|)
block|{
name|lastcg
operator|=
name|sc
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
name|sc
operator|=
name|errmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cgbuf
operator|=
name|errmalloc
argument_list|(
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cgp
operator|=
operator|(
expr|struct
name|cg
operator|*
operator|)
name|sc
operator|->
name|sc_cgbuf
expr_stmt|;
name|sc
operator|->
name|sc_cgx
operator|=
name|cgx
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|hd
argument_list|,
name|sc
argument_list|,
name|sc_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
name|disk
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|sc
operator|->
name|sc_cgx
argument_list|)
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_cgbuf
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err_suj
argument_list|(
literal|"Unable to read cylinder group %d\n"
argument_list|,
name|sc
operator|->
name|sc_cgx
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup an inode number in the hash and allocate a suj_ino if it does  * not exist.  */
end_comment

begin_function
specifier|static
name|struct
name|suj_ino
modifier|*
name|ino_lookup
parameter_list|(
name|ino_t
name|ino
parameter_list|,
name|int
name|creat
parameter_list|)
block|{
name|struct
name|suj_ino
modifier|*
name|sino
decl_stmt|;
name|struct
name|inohd
modifier|*
name|hd
decl_stmt|;
name|struct
name|suj_cg
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|cg_lookup
argument_list|(
name|ino_to_cg
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_lastino
operator|&&
name|sc
operator|->
name|sc_lastino
operator|->
name|si_ino
operator|==
name|ino
condition|)
return|return
operator|(
name|sc
operator|->
name|sc_lastino
operator|)
return|;
name|hd
operator|=
operator|&
name|sc
operator|->
name|sc_inohash
index|[
name|SUJ_HASH
argument_list|(
name|ino
argument_list|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sino
argument_list|,
argument|hd
argument_list|,
argument|si_next
argument_list|)
if|if
condition|(
name|sino
operator|->
name|si_ino
operator|==
name|ino
condition|)
return|return
operator|(
name|sino
operator|)
return|;
if|if
condition|(
name|creat
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sino
operator|=
name|errmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sino
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sino
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sino
argument_list|)
argument_list|)
expr_stmt|;
name|sino
operator|->
name|si_ino
operator|=
name|ino
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sino
operator|->
name|si_recs
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sino
operator|->
name|si_newrecs
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sino
operator|->
name|si_movs
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|hd
argument_list|,
name|sino
argument_list|,
name|si_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|sino
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup a block number in the hash and allocate a suj_blk if it does  * not exist.  */
end_comment

begin_function
specifier|static
name|struct
name|suj_blk
modifier|*
name|blk_lookup
parameter_list|(
name|ufs2_daddr_t
name|blk
parameter_list|,
name|int
name|creat
parameter_list|)
block|{
name|struct
name|suj_blk
modifier|*
name|sblk
decl_stmt|;
name|struct
name|suj_cg
modifier|*
name|sc
decl_stmt|;
name|struct
name|blkhd
modifier|*
name|hd
decl_stmt|;
name|sc
operator|=
name|cg_lookup
argument_list|(
name|dtog
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_lastblk
operator|&&
name|sc
operator|->
name|sc_lastblk
operator|->
name|sb_blk
operator|==
name|blk
condition|)
return|return
operator|(
name|sc
operator|->
name|sc_lastblk
operator|)
return|;
name|hd
operator|=
operator|&
name|sc
operator|->
name|sc_blkhash
index|[
name|SUJ_HASH
argument_list|(
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sblk
argument_list|,
argument|hd
argument_list|,
argument|sb_next
argument_list|)
if|if
condition|(
name|sblk
operator|->
name|sb_blk
operator|==
name|blk
condition|)
return|return
operator|(
name|sblk
operator|)
return|;
if|if
condition|(
name|creat
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sblk
operator|=
name|errmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sblk
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sblk
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sblk
argument_list|)
argument_list|)
expr_stmt|;
name|sblk
operator|->
name|sb_blk
operator|=
name|blk
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sblk
operator|->
name|sb_recs
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|hd
argument_list|,
name|sblk
argument_list|,
name|sb_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|sblk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|data_blk
modifier|*
name|dblk_lookup
parameter_list|(
name|ufs2_daddr_t
name|blk
parameter_list|)
block|{
name|struct
name|data_blk
modifier|*
name|dblk
decl_stmt|;
name|struct
name|dblkhd
modifier|*
name|hd
decl_stmt|;
name|hd
operator|=
operator|&
name|dbhash
index|[
name|SUJ_HASH
argument_list|(
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|)
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|lastblk
operator|&&
name|lastblk
operator|->
name|db_blk
operator|==
name|blk
condition|)
return|return
operator|(
name|lastblk
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|dblk
argument_list|,
argument|hd
argument_list|,
argument|db_next
argument_list|)
if|if
condition|(
name|dblk
operator|->
name|db_blk
operator|==
name|blk
condition|)
return|return
operator|(
name|dblk
operator|)
return|;
comment|/* 	 * The inode block wasn't located, allocate a new one. 	 */
name|dblk
operator|=
name|errmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dblk
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dblk
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dblk
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|hd
argument_list|,
name|dblk
argument_list|,
name|db_next
argument_list|)
expr_stmt|;
name|dblk
operator|->
name|db_blk
operator|=
name|blk
expr_stmt|;
return|return
operator|(
name|dblk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
modifier|*
name|dblk_read
parameter_list|(
name|ufs2_daddr_t
name|blk
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|data_blk
modifier|*
name|dblk
decl_stmt|;
name|dblk
operator|=
name|dblk_lookup
argument_list|(
name|blk
argument_list|)
expr_stmt|;
comment|/* 	 * I doubt size mismatches can happen in practice but it is trivial 	 * to handle. 	 */
if|if
condition|(
name|size
operator|!=
name|dblk
operator|->
name|db_size
condition|)
block|{
if|if
condition|(
name|dblk
operator|->
name|db_buf
condition|)
name|free
argument_list|(
name|dblk
operator|->
name|db_buf
argument_list|)
expr_stmt|;
name|dblk
operator|->
name|db_buf
operator|=
name|errmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|dblk
operator|->
name|db_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
name|disk
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|)
argument_list|,
name|dblk
operator|->
name|db_buf
argument_list|,
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err_suj
argument_list|(
literal|"Failed to read data block %jd\n"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dblk
operator|->
name|db_buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dblk_dirty
parameter_list|(
name|ufs2_daddr_t
name|blk
parameter_list|)
block|{
name|struct
name|data_blk
modifier|*
name|dblk
decl_stmt|;
name|dblk
operator|=
name|dblk_lookup
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|dblk
operator|->
name|db_dirty
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dblk_write
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|data_blk
modifier|*
name|dblk
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SUJ_HASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|dblk
argument_list|,
argument|&dbhash[i]
argument_list|,
argument|db_next
argument_list|)
block|{
if|if
condition|(
name|dblk
operator|->
name|db_dirty
operator|==
literal|0
operator|||
name|dblk
operator|->
name|db_size
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|bwrite
argument_list|(
name|disk
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|dblk
operator|->
name|db_blk
argument_list|)
argument_list|,
name|dblk
operator|->
name|db_buf
argument_list|,
name|dblk
operator|->
name|db_size
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err_suj
argument_list|(
literal|"Unable to write block %jd\n"
argument_list|,
name|dblk
operator|->
name|db_blk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|union
name|dinode
modifier|*
name|ino_read
parameter_list|(
name|ino_t
name|ino
parameter_list|)
block|{
name|struct
name|ino_blk
modifier|*
name|iblk
decl_stmt|;
name|struct
name|iblkhd
modifier|*
name|hd
decl_stmt|;
name|struct
name|suj_cg
modifier|*
name|sc
decl_stmt|;
name|ufs2_daddr_t
name|blk
decl_stmt|;
name|int
name|off
decl_stmt|;
name|blk
operator|=
name|ino_to_fsba
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|sc
operator|=
name|cg_lookup
argument_list|(
name|ino_to_cg
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|)
argument_list|)
expr_stmt|;
name|iblk
operator|=
name|sc
operator|->
name|sc_lastiblk
expr_stmt|;
if|if
condition|(
name|iblk
operator|&&
name|iblk
operator|->
name|ib_blk
operator|==
name|blk
condition|)
goto|goto
name|found
goto|;
name|hd
operator|=
operator|&
name|sc
operator|->
name|sc_iblkhash
index|[
name|SUJ_HASH
argument_list|(
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|iblk
argument_list|,
argument|hd
argument_list|,
argument|ib_next
argument_list|)
if|if
condition|(
name|iblk
operator|->
name|ib_blk
operator|==
name|blk
condition|)
goto|goto
name|found
goto|;
comment|/* 	 * The inode block wasn't located, allocate a new one. 	 */
name|iblk
operator|=
name|errmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|iblk
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|iblk
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iblk
argument_list|)
argument_list|)
expr_stmt|;
name|iblk
operator|->
name|ib_buf
operator|=
name|errmalloc
argument_list|(
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|iblk
operator|->
name|ib_blk
operator|=
name|blk
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|hd
argument_list|,
name|iblk
argument_list|,
name|ib_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
name|disk
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|)
argument_list|,
name|iblk
operator|->
name|ib_buf
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err_suj
argument_list|(
literal|"Failed to read inode block %jd\n"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|found
label|:
name|sc
operator|->
name|sc_lastiblk
operator|=
name|iblk
expr_stmt|;
name|off
operator|=
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
return|return
operator|(
expr|union
name|dinode
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|ufs1_dinode
operator|*
operator|)
name|iblk
operator|->
name|ib_buf
operator|)
index|[
name|off
index|]
return|;
else|else
return|return
operator|(
expr|union
name|dinode
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|ufs2_dinode
operator|*
operator|)
name|iblk
operator|->
name|ib_buf
operator|)
index|[
name|off
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ino_dirty
parameter_list|(
name|ino_t
name|ino
parameter_list|)
block|{
name|struct
name|ino_blk
modifier|*
name|iblk
decl_stmt|;
name|struct
name|iblkhd
modifier|*
name|hd
decl_stmt|;
name|struct
name|suj_cg
modifier|*
name|sc
decl_stmt|;
name|ufs2_daddr_t
name|blk
decl_stmt|;
name|blk
operator|=
name|ino_to_fsba
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|sc
operator|=
name|cg_lookup
argument_list|(
name|ino_to_cg
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|)
argument_list|)
expr_stmt|;
name|iblk
operator|=
name|sc
operator|->
name|sc_lastiblk
expr_stmt|;
if|if
condition|(
name|iblk
operator|&&
name|iblk
operator|->
name|ib_blk
operator|==
name|blk
condition|)
block|{
name|iblk
operator|->
name|ib_dirty
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|hd
operator|=
operator|&
name|sc
operator|->
name|sc_iblkhash
index|[
name|SUJ_HASH
argument_list|(
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|iblk
argument_list|,
argument|hd
argument_list|,
argument|ib_next
argument_list|)
block|{
if|if
condition|(
name|iblk
operator|->
name|ib_blk
operator|==
name|blk
condition|)
block|{
name|iblk
operator|->
name|ib_dirty
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|ino_read
argument_list|(
name|ino
argument_list|)
expr_stmt|;
name|ino_dirty
argument_list|(
name|ino
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iblk_write
parameter_list|(
name|struct
name|ino_blk
modifier|*
name|iblk
parameter_list|)
block|{
if|if
condition|(
name|iblk
operator|->
name|ib_dirty
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|bwrite
argument_list|(
name|disk
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|iblk
operator|->
name|ib_blk
argument_list|)
argument_list|,
name|iblk
operator|->
name|ib_buf
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err_suj
argument_list|(
literal|"Failed to write inode block %jd\n"
argument_list|,
name|iblk
operator|->
name|ib_blk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|blk_overlaps
parameter_list|(
name|struct
name|jblkrec
modifier|*
name|brec
parameter_list|,
name|ufs2_daddr_t
name|start
parameter_list|,
name|int
name|frags
parameter_list|)
block|{
name|ufs2_daddr_t
name|bstart
decl_stmt|;
name|ufs2_daddr_t
name|bend
decl_stmt|;
name|ufs2_daddr_t
name|end
decl_stmt|;
name|end
operator|=
name|start
operator|+
name|frags
expr_stmt|;
name|bstart
operator|=
name|brec
operator|->
name|jb_blkno
operator|+
name|brec
operator|->
name|jb_oldfrags
expr_stmt|;
name|bend
operator|=
name|bstart
operator|+
name|brec
operator|->
name|jb_frags
expr_stmt|;
if|if
condition|(
name|start
operator|<
name|bend
operator|&&
name|end
operator|>
name|bstart
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|blk_equals
parameter_list|(
name|struct
name|jblkrec
modifier|*
name|brec
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|ufs_lbn_t
name|lbn
parameter_list|,
name|ufs2_daddr_t
name|start
parameter_list|,
name|int
name|frags
parameter_list|)
block|{
if|if
condition|(
name|brec
operator|->
name|jb_ino
operator|!=
name|ino
operator|||
name|brec
operator|->
name|jb_lbn
operator|!=
name|lbn
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|brec
operator|->
name|jb_blkno
operator|+
name|brec
operator|->
name|jb_oldfrags
operator|!=
name|start
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|brec
operator|->
name|jb_frags
operator|!=
name|frags
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|blk_setmask
parameter_list|(
name|struct
name|jblkrec
modifier|*
name|brec
parameter_list|,
name|int
modifier|*
name|mask
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|brec
operator|->
name|jb_oldfrags
init|;
name|i
operator|<
name|brec
operator|->
name|jb_oldfrags
operator|+
name|brec
operator|->
name|jb_frags
condition|;
name|i
operator|++
control|)
operator|*
name|mask
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine whether a given block has been reallocated to a new location.  * Returns a mask of overlapping bits if any frags have been reused or  * zero if the block has not been re-used and the contents can be trusted.  *  * This is used to ensure that an orphaned pointer due to truncate is safe  * to be freed.  The mask value can be used to free partial blocks.  */
end_comment

begin_function
specifier|static
name|int
name|blk_freemask
parameter_list|(
name|ufs2_daddr_t
name|blk
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|ufs_lbn_t
name|lbn
parameter_list|,
name|int
name|frags
parameter_list|)
block|{
name|struct
name|suj_blk
modifier|*
name|sblk
decl_stmt|;
name|struct
name|suj_rec
modifier|*
name|srec
decl_stmt|;
name|struct
name|jblkrec
modifier|*
name|brec
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|off
decl_stmt|;
comment|/* 	 * To be certain we're not freeing a reallocated block we lookup 	 * this block in the blk hash and see if there is an allocation 	 * journal record that overlaps with any fragments in the block 	 * we're concerned with.  If any fragments have ben reallocated 	 * the block has already been freed and re-used for another purpose. 	 */
name|mask
operator|=
literal|0
expr_stmt|;
name|sblk
operator|=
name|blk_lookup
argument_list|(
name|blknum
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|off
operator|=
name|blk
operator|-
name|sblk
operator|->
name|sb_blk
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|srec
argument_list|,
argument|&sblk->sb_recs
argument_list|,
argument|sr_next
argument_list|)
block|{
name|brec
operator|=
operator|(
expr|struct
name|jblkrec
operator|*
operator|)
name|srec
operator|->
name|sr_rec
expr_stmt|;
comment|/* 		 * If the block overlaps but does not match 		 * exactly it's a new allocation.  If it matches 		 * exactly this record refers to the current 		 * location. 		 */
if|if
condition|(
name|blk_overlaps
argument_list|(
name|brec
argument_list|,
name|blk
argument_list|,
name|frags
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|blk_equals
argument_list|(
name|brec
argument_list|,
name|ino
argument_list|,
name|lbn
argument_list|,
name|blk
argument_list|,
name|frags
argument_list|)
operator|==
literal|1
condition|)
name|mask
operator|=
literal|0
expr_stmt|;
else|else
name|blk_setmask
argument_list|(
name|brec
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"blk_freemask: blk %jd sblk %jd off %d mask 0x%X\n"
argument_list|,
name|blk
argument_list|,
name|sblk
operator|->
name|sb_blk
argument_list|,
name|off
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|mask
operator|>>
name|off
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether it is safe to follow an indirect.  It is not safe  * if any part of the indirect has been reallocated or the last journal  * entry was an allocation.  Just allocated indirects may not have valid  * pointers yet and all of their children will have their own records.  * It is also not safe to follow an indirect if the cg bitmap has been  * cleared as a new allocation may write to the block prior to the journal  * being written.  *  * Returns 1 if it's safe to follow the indirect and 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|blk_isindir
parameter_list|(
name|ufs2_daddr_t
name|blk
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|ufs_lbn_t
name|lbn
parameter_list|)
block|{
name|struct
name|suj_blk
modifier|*
name|sblk
decl_stmt|;
name|struct
name|jblkrec
modifier|*
name|brec
decl_stmt|;
name|sblk
operator|=
name|blk_lookup
argument_list|(
name|blk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sblk
operator|->
name|sb_recs
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|brec
operator|=
operator|(
expr|struct
name|jblkrec
operator|*
operator|)
name|TAILQ_LAST
argument_list|(
operator|&
name|sblk
operator|->
name|sb_recs
argument_list|,
name|srechd
argument_list|)
operator|->
name|sr_rec
expr_stmt|;
if|if
condition|(
name|blk_equals
argument_list|(
name|brec
argument_list|,
name|ino
argument_list|,
name|lbn
argument_list|,
name|blk
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
condition|)
if|if
condition|(
name|brec
operator|->
name|jb_op
operator|==
name|JOP_FREEBLK
condition|)
return|return
operator|(
operator|!
name|blk_isfree
argument_list|(
name|blk
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear an inode from the cg bitmap.  If the inode was already clear return  * 0 so the caller knows it does not have to check the inode contents.  */
end_comment

begin_function
specifier|static
name|int
name|ino_free
parameter_list|(
name|ino_t
name|ino
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|suj_cg
modifier|*
name|sc
decl_stmt|;
name|uint8_t
modifier|*
name|inosused
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|int
name|cg
decl_stmt|;
name|cg
operator|=
name|ino_to_cg
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|ino
operator|=
name|ino
operator|%
name|fs
operator|->
name|fs_ipg
expr_stmt|;
name|sc
operator|=
name|cg_lookup
argument_list|(
name|cg
argument_list|)
expr_stmt|;
name|cgp
operator|=
name|sc
operator|->
name|sc_cgp
expr_stmt|;
name|inosused
operator|=
name|cg_inosused
argument_list|(
name|cgp
argument_list|)
expr_stmt|;
comment|/* 	 * The bitmap may never have made it to the disk so we have to 	 * conditionally clear.  We can avoid writing the cg in this case. 	 */
if|if
condition|(
name|isclr
argument_list|(
name|inosused
argument_list|,
name|ino
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|freeinos
operator|++
expr_stmt|;
name|clrbit
argument_list|(
name|inosused
argument_list|,
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|ino
operator|<
name|cgp
operator|->
name|cg_irotor
condition|)
name|cgp
operator|->
name|cg_irotor
operator|=
name|ino
expr_stmt|;
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nifree
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
condition|)
block|{
name|freedir
operator|++
expr_stmt|;
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_ndir
operator|--
expr_stmt|;
block|}
name|sc
operator|->
name|sc_dirty
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free 'frags' frags starting at filesystem block 'bno' skipping any frags  * set in the mask.  */
end_comment

begin_function
specifier|static
name|void
name|blk_free
parameter_list|(
name|ufs2_daddr_t
name|bno
parameter_list|,
name|int
name|mask
parameter_list|,
name|int
name|frags
parameter_list|)
block|{
name|ufs1_daddr_t
name|fragno
decl_stmt|,
name|cgbno
decl_stmt|;
name|struct
name|suj_cg
modifier|*
name|sc
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cg
decl_stmt|;
name|uint8_t
modifier|*
name|blksfree
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Freeing %d frags at blk %jd\n"
argument_list|,
name|frags
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|cg
operator|=
name|dtog
argument_list|(
name|fs
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|sc
operator|=
name|cg_lookup
argument_list|(
name|cg
argument_list|)
expr_stmt|;
name|cgp
operator|=
name|sc
operator|->
name|sc_cgp
expr_stmt|;
name|cgbno
operator|=
name|dtogd
argument_list|(
name|fs
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|blksfree
operator|=
name|cg_blksfree
argument_list|(
name|cgp
argument_list|)
expr_stmt|;
comment|/* 	 * If it's not allocated we only wrote the journal entry 	 * and never the bitmaps.  Here we unconditionally clear and 	 * resolve the cg summary later. 	 */
if|if
condition|(
name|frags
operator|==
name|fs
operator|->
name|fs_frag
operator|&&
name|mask
operator|==
literal|0
condition|)
block|{
name|fragno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|cgbno
argument_list|)
expr_stmt|;
name|ffs_setblock
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
name|fragno
argument_list|)
expr_stmt|;
name|freeblocks
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * deallocate the fragment 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|frags
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
operator|&&
name|isclr
argument_list|(
name|blksfree
argument_list|,
name|cgbno
operator|+
name|i
argument_list|)
condition|)
block|{
name|freefrags
operator|++
expr_stmt|;
name|setbit
argument_list|(
name|blksfree
argument_list|,
name|cgbno
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_dirty
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns 1 if the whole block starting at 'bno' is marked free and 0  * otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|blk_isfree
parameter_list|(
name|ufs2_daddr_t
name|bno
parameter_list|)
block|{
name|struct
name|suj_cg
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|cg_lookup
argument_list|(
name|dtog
argument_list|(
name|fs
argument_list|,
name|bno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ffs_isblock
argument_list|(
name|fs
argument_list|,
name|cg_blksfree
argument_list|(
name|sc
operator|->
name|sc_cgp
argument_list|)
argument_list|,
name|dtogd
argument_list|(
name|fs
argument_list|,
name|bno
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch an indirect block to find the block at a given lbn.  The lbn  * may be negative to fetch a specific indirect block pointer or positive  * to fetch a specific block.  */
end_comment

begin_function
specifier|static
name|ufs2_daddr_t
name|indir_blkatoff
parameter_list|(
name|ufs2_daddr_t
name|blk
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|ufs_lbn_t
name|cur
parameter_list|,
name|ufs_lbn_t
name|lbn
parameter_list|)
block|{
name|ufs2_daddr_t
modifier|*
name|bap2
decl_stmt|;
name|ufs2_daddr_t
modifier|*
name|bap1
decl_stmt|;
name|ufs_lbn_t
name|lbnadd
decl_stmt|;
name|ufs_lbn_t
name|base
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|blk
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|level
operator|=
name|lbn_level
argument_list|(
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
operator|-
literal|1
condition|)
name|err_suj
argument_list|(
literal|"Invalid indir lbn %jd\n"
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
operator|&&
name|lbn
operator|<
literal|0
condition|)
name|err_suj
argument_list|(
literal|"Invalid lbn %jd\n"
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
name|bap2
operator|=
operator|(
name|void
operator|*
operator|)
name|dblk_read
argument_list|(
name|blk
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bap1
operator|=
operator|(
name|void
operator|*
operator|)
name|bap2
expr_stmt|;
name|lbnadd
operator|=
literal|1
expr_stmt|;
name|base
operator|=
operator|-
operator|(
name|cur
operator|+
name|level
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|level
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|lbnadd
operator|*=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbn
operator|>
literal|0
condition|)
name|i
operator|=
operator|(
name|lbn
operator|-
name|base
operator|)
operator|/
name|lbnadd
expr_stmt|;
else|else
name|i
operator|=
operator|(
operator|-
name|lbn
operator|-
name|base
operator|)
operator|/
name|lbnadd
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|)
name|err_suj
argument_list|(
literal|"Invalid indirect index %d produced by lbn %jd\n"
argument_list|,
name|i
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|cur
operator|=
name|base
operator|+
operator|(
name|i
operator|*
name|lbnadd
operator|)
expr_stmt|;
else|else
name|cur
operator|=
operator|-
operator|(
name|base
operator|+
operator|(
name|i
operator|*
name|lbnadd
operator|)
operator|)
operator|-
operator|(
name|level
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|blk
operator|=
name|bap1
index|[
name|i
index|]
expr_stmt|;
else|else
name|blk
operator|=
name|bap2
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|lbn
condition|)
return|return
operator|(
name|blk
operator|)
return|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|err_suj
argument_list|(
literal|"Invalid lbn %jd at level 0\n"
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
return|return
name|indir_blkatoff
argument_list|(
name|blk
argument_list|,
name|ino
argument_list|,
name|cur
argument_list|,
name|lbn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finds the disk block address at the specified lbn within the inode  * specified by ip.  This follows the whole tree and honors di_size and  * di_extsize so it is a true test of reachability.  The lbn may be  * negative if an extattr or indirect block is requested.  */
end_comment

begin_function
specifier|static
name|ufs2_daddr_t
name|ino_blkatoff
parameter_list|(
name|union
name|dinode
modifier|*
name|ip
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|ufs_lbn_t
name|lbn
parameter_list|,
name|int
modifier|*
name|frags
parameter_list|)
block|{
name|ufs_lbn_t
name|tmpval
decl_stmt|;
name|ufs_lbn_t
name|cur
decl_stmt|;
name|ufs_lbn_t
name|next
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Handle extattr blocks first. 	 */
if|if
condition|(
name|lbn
operator|<
literal|0
operator|&&
name|lbn
operator|>=
operator|-
name|NXADDR
condition|)
block|{
name|lbn
operator|=
operator|-
literal|1
operator|-
name|lbn
expr_stmt|;
if|if
condition|(
name|lbn
operator|>
name|lblkno
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|dp2
operator|.
name|di_extsize
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|frags
operator|=
name|numfrags
argument_list|(
name|fs
argument_list|,
name|sblksize
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|dp2
operator|.
name|di_extsize
argument_list|,
name|lbn
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ip
operator|->
name|dp2
operator|.
name|di_extb
index|[
name|lbn
index|]
operator|)
return|;
block|}
comment|/* 	 * Now direct and indirect. 	 */
if|if
condition|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_mode
argument_list|)
operator|==
name|IFLNK
operator|&&
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_size
argument_list|)
operator|<
name|fs
operator|->
name|fs_maxsymlinklen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lbn
operator|>=
literal|0
operator|&&
name|lbn
operator|<
name|NDADDR
condition|)
block|{
operator|*
name|frags
operator|=
name|numfrags
argument_list|(
name|fs
argument_list|,
name|sblksize
argument_list|(
name|fs
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_size
argument_list|)
argument_list|,
name|lbn
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_db
index|[
name|lbn
index|]
argument_list|)
operator|)
return|;
block|}
operator|*
name|frags
operator|=
name|fs
operator|->
name|fs_frag
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tmpval
operator|=
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|,
name|cur
operator|=
name|NDADDR
init|;
name|i
operator|<
name|NIADDR
condition|;
name|i
operator|++
operator|,
name|tmpval
operator|*=
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|,
name|cur
operator|=
name|next
control|)
block|{
name|next
operator|=
name|cur
operator|+
name|tmpval
expr_stmt|;
if|if
condition|(
name|lbn
operator|==
operator|-
name|cur
operator|-
name|i
condition|)
return|return
operator|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_ib
index|[
name|i
index|]
argument_list|)
operator|)
return|;
comment|/* 		 * Determine whether the lbn in question is within this tree. 		 */
if|if
condition|(
name|lbn
operator|<
literal|0
operator|&&
operator|-
name|lbn
operator|>=
name|next
condition|)
continue|continue;
if|if
condition|(
name|lbn
operator|>
literal|0
operator|&&
name|lbn
operator|>=
name|next
condition|)
continue|continue;
return|return
name|indir_blkatoff
argument_list|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_ib
index|[
name|i
index|]
argument_list|)
argument_list|,
name|ino
argument_list|,
operator|-
name|cur
operator|-
name|i
argument_list|,
name|lbn
argument_list|)
return|;
block|}
name|err_suj
argument_list|(
literal|"lbn %jd not in ino\n"
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Determine whether a block exists at a particular lbn in an inode.  * Returns 1 if found, 0 if not.  lbn may be negative for indirects  * or ext blocks.  */
end_comment

begin_function
specifier|static
name|int
name|blk_isat
parameter_list|(
name|ino_t
name|ino
parameter_list|,
name|ufs_lbn_t
name|lbn
parameter_list|,
name|ufs2_daddr_t
name|blk
parameter_list|,
name|int
modifier|*
name|frags
parameter_list|)
block|{
name|union
name|dinode
modifier|*
name|ip
decl_stmt|;
name|ufs2_daddr_t
name|nblk
decl_stmt|;
name|ip
operator|=
name|ino_read
argument_list|(
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_nlink
argument_list|)
operator|==
literal|0
operator|||
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_mode
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nblk
operator|=
name|ino_blkatoff
argument_list|(
name|ip
argument_list|,
name|ino
argument_list|,
name|lbn
argument_list|,
name|frags
argument_list|)
expr_stmt|;
return|return
operator|(
name|nblk
operator|==
name|blk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear the directory entry at diroff that should point to child.  Minimal  * checking is done and it is assumed that this path was verified with isat.  */
end_comment

begin_function
specifier|static
name|void
name|ino_clrat
parameter_list|(
name|ino_t
name|parent
parameter_list|,
name|off_t
name|diroff
parameter_list|,
name|ino_t
name|child
parameter_list|)
block|{
name|union
name|dinode
modifier|*
name|dip
decl_stmt|;
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|ufs2_daddr_t
name|blk
decl_stmt|;
name|uint8_t
modifier|*
name|block
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|int
name|blksize
decl_stmt|;
name|int
name|frags
decl_stmt|;
name|int
name|doff
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Clearing inode %d from parent %d at offset %jd\n"
argument_list|,
name|child
argument_list|,
name|parent
argument_list|,
name|diroff
argument_list|)
expr_stmt|;
name|lbn
operator|=
name|lblkno
argument_list|(
name|fs
argument_list|,
name|diroff
argument_list|)
expr_stmt|;
name|doff
operator|=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|diroff
argument_list|)
expr_stmt|;
name|dip
operator|=
name|ino_read
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|blk
operator|=
name|ino_blkatoff
argument_list|(
name|dip
argument_list|,
name|parent
argument_list|,
name|lbn
argument_list|,
operator|&
name|frags
argument_list|)
expr_stmt|;
name|blksize
operator|=
name|sblksize
argument_list|(
name|fs
argument_list|,
name|DIP
argument_list|(
name|dip
argument_list|,
name|di_size
argument_list|)
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
name|block
operator|=
name|dblk_read
argument_list|(
name|blk
argument_list|,
name|blksize
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|&
name|block
index|[
name|doff
index|]
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|!=
name|child
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Inode %d does not exist in %d at %jd"
argument_list|,
name|child
argument_list|,
name|parent
argument_list|,
name|diroff
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_ino
operator|=
literal|0
expr_stmt|;
name|dblk_dirty
argument_list|(
name|blk
argument_list|)
expr_stmt|;
comment|/* 	 * The actual .. reference count will already have been removed 	 * from the parent by the .. remref record. 	 */
block|}
end_function

begin_comment
comment|/*  * Determines whether a pointer to an inode exists within a directory  * at a specified offset.  Returns the mode of the found entry.  */
end_comment

begin_function
specifier|static
name|int
name|ino_isat
parameter_list|(
name|ino_t
name|parent
parameter_list|,
name|off_t
name|diroff
parameter_list|,
name|ino_t
name|child
parameter_list|,
name|int
modifier|*
name|mode
parameter_list|,
name|int
modifier|*
name|isdot
parameter_list|)
block|{
name|union
name|dinode
modifier|*
name|dip
decl_stmt|;
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|ufs2_daddr_t
name|blk
decl_stmt|;
name|uint8_t
modifier|*
name|block
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|int
name|blksize
decl_stmt|;
name|int
name|frags
decl_stmt|;
name|int
name|dpoff
decl_stmt|;
name|int
name|doff
decl_stmt|;
operator|*
name|isdot
operator|=
literal|0
expr_stmt|;
name|dip
operator|=
name|ino_read
argument_list|(
name|parent
argument_list|)
expr_stmt|;
operator|*
name|mode
operator|=
name|DIP
argument_list|(
name|dip
argument_list|,
name|di_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|mode
operator|&
name|IFMT
operator|)
operator|!=
name|IFDIR
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
comment|/* 			 * This can happen if the parent inode 			 * was reallocated. 			 */
if|if
condition|(
operator|*
name|mode
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Directory %d has bad mode %o\n"
argument_list|,
name|parent
argument_list|,
operator|*
name|mode
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Directory %d zero inode\n"
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|lbn
operator|=
name|lblkno
argument_list|(
name|fs
argument_list|,
name|diroff
argument_list|)
expr_stmt|;
name|doff
operator|=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|diroff
argument_list|)
expr_stmt|;
name|blksize
operator|=
name|sblksize
argument_list|(
name|fs
argument_list|,
name|DIP
argument_list|(
name|dip
argument_list|,
name|di_size
argument_list|)
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
if|if
condition|(
name|diroff
operator|+
name|DIRECTSIZ
argument_list|(
literal|1
argument_list|)
operator|>
name|DIP
argument_list|(
name|dip
argument_list|,
name|di_size
argument_list|)
operator|||
name|doff
operator|>=
name|blksize
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ino %d absent from %d due to offset %jd"
literal|" exceeding size %jd\n"
argument_list|,
name|child
argument_list|,
name|parent
argument_list|,
name|diroff
argument_list|,
name|DIP
argument_list|(
name|dip
argument_list|,
name|di_size
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|blk
operator|=
name|ino_blkatoff
argument_list|(
name|dip
argument_list|,
name|parent
argument_list|,
name|lbn
argument_list|,
operator|&
name|frags
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Sparse directory %d"
argument_list|,
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|block
operator|=
name|dblk_read
argument_list|(
name|blk
argument_list|,
name|blksize
argument_list|)
expr_stmt|;
comment|/* 	 * Walk through the records from the start of the block to be 	 * certain we hit a valid record and not some junk in the middle 	 * of a file name.  Stop when we reach or pass the expected offset. 	 */
name|dpoff
operator|=
operator|(
name|doff
operator|/
name|DIRBLKSIZ
operator|)
operator|*
name|DIRBLKSIZ
expr_stmt|;
do|do
block|{
name|dp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|&
name|block
index|[
name|dpoff
index|]
expr_stmt|;
if|if
condition|(
name|dpoff
operator|==
name|doff
condition|)
break|break;
if|if
condition|(
name|dp
operator|->
name|d_reclen
operator|==
literal|0
condition|)
break|break;
name|dpoff
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
block|}
do|while
condition|(
name|dpoff
operator|<=
name|doff
condition|)
do|;
if|if
condition|(
name|dpoff
operator|>
name|fs
operator|->
name|fs_bsize
condition|)
name|err_suj
argument_list|(
literal|"Corrupt directory block in dir ino %d\n"
argument_list|,
name|parent
argument_list|)
expr_stmt|;
comment|/* Not found. */
if|if
condition|(
name|dpoff
operator|!=
name|doff
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ino %d not found in %d, lbn %jd, dpoff %d\n"
argument_list|,
name|child
argument_list|,
name|parent
argument_list|,
name|lbn
argument_list|,
name|dpoff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We found the item in question.  Record the mode and whether it's 	 * a . or .. link for the caller. 	 */
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|==
name|child
condition|)
block|{
if|if
condition|(
name|child
operator|==
name|parent
condition|)
operator|*
name|isdot
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|dp
operator|->
name|d_namlen
operator|==
literal|2
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
operator|*
name|isdot
operator|=
literal|1
expr_stmt|;
operator|*
name|mode
operator|=
name|DTTOIF
argument_list|(
name|dp
operator|->
name|d_type
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ino %d doesn't match dirent ino %d in parent %d\n"
argument_list|,
name|child
argument_list|,
name|dp
operator|->
name|d_ino
argument_list|,
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|VISIT_INDIR
value|0x0001
end_define

begin_define
define|#
directive|define
name|VISIT_EXT
value|0x0002
end_define

begin_define
define|#
directive|define
name|VISIT_ROOT
value|0x0004
end_define

begin_comment
comment|/* Operation came via root& valid pointers. */
end_comment

begin_comment
comment|/*  * Read an indirect level which may or may not be linked into an inode.  */
end_comment

begin_function
specifier|static
name|void
name|indir_visit
parameter_list|(
name|ino_t
name|ino
parameter_list|,
name|ufs_lbn_t
name|lbn
parameter_list|,
name|ufs2_daddr_t
name|blk
parameter_list|,
name|uint64_t
modifier|*
name|frags
parameter_list|,
name|ino_visitor
name|visitor
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ufs2_daddr_t
modifier|*
name|bap2
decl_stmt|;
name|ufs1_daddr_t
modifier|*
name|bap1
decl_stmt|;
name|ufs_lbn_t
name|lbnadd
decl_stmt|;
name|ufs2_daddr_t
name|nblk
decl_stmt|;
name|ufs_lbn_t
name|nlbn
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Don't visit indirect blocks with contents we can't trust.  This 	 * should only happen when indir_visit() is called to complete a 	 * truncate that never finished and not when a pointer is found via 	 * an inode. 	 */
if|if
condition|(
name|blk
operator|==
literal|0
condition|)
return|return;
name|level
operator|=
name|lbn_level
argument_list|(
name|lbn
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
operator|-
literal|1
condition|)
name|err_suj
argument_list|(
literal|"Invalid level for lbn %jd\n"
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|VISIT_ROOT
operator|)
operator|==
literal|0
operator|&&
name|blk_isindir
argument_list|(
name|blk
argument_list|,
name|ino
argument_list|,
name|lbn
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"blk %jd ino %d lbn %jd(%d) is not indir.\n"
argument_list|,
name|blk
argument_list|,
name|ino
argument_list|,
name|lbn
argument_list|,
name|level
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|lbnadd
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|level
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|lbnadd
operator|*=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|bap1
operator|=
operator|(
name|void
operator|*
operator|)
name|dblk_read
argument_list|(
name|blk
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bap2
operator|=
operator|(
name|void
operator|*
operator|)
name|bap1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fs
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|nblk
operator|=
operator|*
name|bap1
operator|++
expr_stmt|;
else|else
name|nblk
operator|=
operator|*
name|bap2
operator|++
expr_stmt|;
if|if
condition|(
name|nblk
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
name|nlbn
operator|=
operator|-
name|lbn
operator|+
name|i
operator|*
name|lbnadd
expr_stmt|;
operator|(
operator|*
name|frags
operator|)
operator|+=
name|fs
operator|->
name|fs_frag
expr_stmt|;
name|visitor
argument_list|(
name|ino
argument_list|,
name|nlbn
argument_list|,
name|nblk
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nlbn
operator|=
operator|(
name|lbn
operator|+
literal|1
operator|)
operator|-
operator|(
name|i
operator|*
name|lbnadd
operator|)
expr_stmt|;
name|indir_visit
argument_list|(
name|ino
argument_list|,
name|nlbn
argument_list|,
name|nblk
argument_list|,
name|frags
argument_list|,
name|visitor
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|flags
operator|&
name|VISIT_INDIR
condition|)
block|{
operator|(
operator|*
name|frags
operator|)
operator|+=
name|fs
operator|->
name|fs_frag
expr_stmt|;
name|visitor
argument_list|(
name|ino
argument_list|,
name|lbn
argument_list|,
name|blk
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Visit each block in an inode as specified by 'flags' and call a  * callback function.  The callback may inspect or free blocks.  The  * count of frags found according to the size in the file is returned.  * This is not valid for sparse files but may be used to determine  * the correct di_blocks for a file.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|ino_visit
parameter_list|(
name|union
name|dinode
modifier|*
name|ip
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|ino_visitor
name|visitor
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ufs_lbn_t
name|nextlbn
decl_stmt|;
name|ufs_lbn_t
name|tmpval
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|uint64_t
name|size
decl_stmt|;
name|uint64_t
name|fragcnt
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|frags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_size
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_mode
argument_list|)
operator|&
name|IFMT
expr_stmt|;
name|fragcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|VISIT_EXT
operator|)
operator|&&
name|fs
operator|->
name|fs_magic
operator|==
name|FS_UFS2_MAGIC
operator|&&
name|ip
operator|->
name|dp2
operator|.
name|di_extsize
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NXADDR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|dp2
operator|.
name|di_extb
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|frags
operator|=
name|sblksize
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|dp2
operator|.
name|di_extsize
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|frags
operator|=
name|numfrags
argument_list|(
name|fs
argument_list|,
name|frags
argument_list|)
expr_stmt|;
name|fragcnt
operator|+=
name|frags
expr_stmt|;
name|visitor
argument_list|(
name|ino
argument_list|,
operator|-
literal|1
operator|-
name|i
argument_list|,
name|ip
operator|->
name|dp2
operator|.
name|di_extb
index|[
name|i
index|]
argument_list|,
name|frags
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Skip datablocks for short links and devices. */
if|if
condition|(
name|mode
operator|==
name|IFBLK
operator|||
name|mode
operator|==
name|IFCHR
operator|||
operator|(
name|mode
operator|==
name|IFLNK
operator|&&
name|size
operator|<
name|fs
operator|->
name|fs_maxsymlinklen
operator|)
condition|)
return|return
operator|(
name|fragcnt
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDADDR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_db
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|frags
operator|=
name|sblksize
argument_list|(
name|fs
argument_list|,
name|size
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|frags
operator|=
name|numfrags
argument_list|(
name|fs
argument_list|,
name|frags
argument_list|)
expr_stmt|;
name|fragcnt
operator|+=
name|frags
expr_stmt|;
name|visitor
argument_list|(
name|ino
argument_list|,
name|i
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_db
index|[
name|i
index|]
argument_list|)
argument_list|,
name|frags
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We know the following indirects are real as we're following 	 * real pointers to them. 	 */
name|flags
operator||=
name|VISIT_ROOT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tmpval
operator|=
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|,
name|lbn
operator|=
name|NDADDR
init|;
name|i
operator|<
name|NIADDR
condition|;
name|i
operator|++
operator|,
name|lbn
operator|=
name|nextlbn
control|)
block|{
name|nextlbn
operator|=
name|lbn
operator|+
name|tmpval
expr_stmt|;
name|tmpval
operator|*=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_ib
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|indir_visit
argument_list|(
name|ino
argument_list|,
operator|-
name|lbn
operator|-
name|i
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_ib
index|[
name|i
index|]
argument_list|)
argument_list|,
operator|&
name|fragcnt
argument_list|,
name|visitor
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fragcnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Null visitor function used when we just want to count blocks and  * record the lbn.  */
end_comment

begin_decl_stmt
name|ufs_lbn_t
name|visitlbn
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|null_visit
parameter_list|(
name|ino_t
name|ino
parameter_list|,
name|ufs_lbn_t
name|lbn
parameter_list|,
name|ufs2_daddr_t
name|blk
parameter_list|,
name|int
name|frags
parameter_list|)
block|{
if|if
condition|(
name|lbn
operator|>
literal|0
condition|)
name|visitlbn
operator|=
name|lbn
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Recalculate di_blocks when we discover that a block allocation or  * free was not successfully completed.  The kernel does not roll this back  * because it would be too expensive to compute which indirects were  * reachable at the time the inode was written.  */
end_comment

begin_function
specifier|static
name|void
name|ino_adjblks
parameter_list|(
name|struct
name|suj_ino
modifier|*
name|sino
parameter_list|)
block|{
name|union
name|dinode
modifier|*
name|ip
decl_stmt|;
name|uint64_t
name|blocks
decl_stmt|;
name|uint64_t
name|frags
decl_stmt|;
name|off_t
name|isize
decl_stmt|;
name|off_t
name|size
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|ino
operator|=
name|sino
operator|->
name|si_ino
expr_stmt|;
name|ip
operator|=
name|ino_read
argument_list|(
name|ino
argument_list|)
expr_stmt|;
comment|/* No need to adjust zero'd inodes. */
if|if
condition|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_mode
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Visit all blocks and count them as well as recording the last 	 * valid lbn in the file.  If the file size doesn't agree with the 	 * last lbn we need to truncate to fix it.  Otherwise just adjust 	 * the blocks count. 	 */
name|visitlbn
operator|=
literal|0
expr_stmt|;
name|frags
operator|=
name|ino_visit
argument_list|(
name|ip
argument_list|,
name|ino
argument_list|,
name|null_visit
argument_list|,
name|VISIT_INDIR
operator||
name|VISIT_EXT
argument_list|)
expr_stmt|;
name|blocks
operator|=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|frags
argument_list|)
expr_stmt|;
comment|/* 	 * We assume the size and direct block list is kept coherent by 	 * softdep.  For files that have extended into indirects we truncate 	 * to the size in the inode or the maximum size permitted by 	 * populated indirects. 	 */
if|if
condition|(
name|visitlbn
operator|>=
name|NDADDR
condition|)
block|{
name|isize
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_size
argument_list|)
expr_stmt|;
name|size
operator|=
name|lblktosize
argument_list|(
name|fs
argument_list|,
name|visitlbn
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isize
operator|>
name|size
condition|)
name|isize
operator|=
name|size
expr_stmt|;
comment|/* Always truncate to free any unpopulated indirects. */
name|ino_trunc
argument_list|(
name|sino
operator|->
name|si_ino
argument_list|,
name|isize
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|blocks
operator|==
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_blocks
argument_list|)
condition|)
return|return;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ino %d adjusting block count from %jd to %jd\n"
argument_list|,
name|ino
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_blocks
argument_list|)
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|di_blocks
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
name|ino_dirty
argument_list|(
name|ino
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|blk_free_visit
parameter_list|(
name|ino_t
name|ino
parameter_list|,
name|ufs_lbn_t
name|lbn
parameter_list|,
name|ufs2_daddr_t
name|blk
parameter_list|,
name|int
name|frags
parameter_list|)
block|{
name|int
name|mask
decl_stmt|;
name|mask
operator|=
name|blk_freemask
argument_list|(
name|blk
argument_list|,
name|ino
argument_list|,
name|lbn
argument_list|,
name|frags
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"blk %jd freemask 0x%X\n"
argument_list|,
name|blk
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|blk_free
argument_list|(
name|blk
argument_list|,
name|mask
argument_list|,
name|frags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a block or tree of blocks that was previously rooted in ino at  * the given lbn.  If the lbn is an indirect all children are freed  * recursively.  */
end_comment

begin_function
specifier|static
name|void
name|blk_free_lbn
parameter_list|(
name|ufs2_daddr_t
name|blk
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|ufs_lbn_t
name|lbn
parameter_list|,
name|int
name|frags
parameter_list|,
name|int
name|follow
parameter_list|)
block|{
name|uint64_t
name|resid
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|mask
operator|=
name|blk_freemask
argument_list|(
name|blk
argument_list|,
name|ino
argument_list|,
name|lbn
argument_list|,
name|frags
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"blk %jd freemask 0x%X\n"
argument_list|,
name|blk
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lbn
operator|<=
operator|-
name|NDADDR
operator|&&
name|follow
operator|&&
name|mask
operator|==
literal|0
condition|)
name|indir_visit
argument_list|(
name|ino
argument_list|,
name|lbn
argument_list|,
name|blk
argument_list|,
operator|&
name|resid
argument_list|,
name|blk_free_visit
argument_list|,
name|VISIT_INDIR
argument_list|)
expr_stmt|;
else|else
name|blk_free
argument_list|(
name|blk
argument_list|,
name|mask
argument_list|,
name|frags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ino_setskip
parameter_list|(
name|struct
name|suj_ino
modifier|*
name|sino
parameter_list|,
name|ino_t
name|parent
parameter_list|)
block|{
name|int
name|isdot
decl_stmt|;
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|ino_isat
argument_list|(
name|sino
operator|->
name|si_ino
argument_list|,
name|DOTDOT_OFFSET
argument_list|,
name|parent
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|isdot
argument_list|)
condition|)
name|sino
operator|->
name|si_skipparent
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ino_remref
parameter_list|(
name|ino_t
name|parent
parameter_list|,
name|ino_t
name|child
parameter_list|,
name|uint64_t
name|diroff
parameter_list|,
name|int
name|isdotdot
parameter_list|)
block|{
name|struct
name|suj_ino
modifier|*
name|sino
decl_stmt|;
name|struct
name|suj_rec
modifier|*
name|srec
decl_stmt|;
name|struct
name|jrefrec
modifier|*
name|rrec
decl_stmt|;
comment|/* 	 * Lookup this inode to see if we have a record for it. 	 */
name|sino
operator|=
name|ino_lookup
argument_list|(
name|child
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Tell any child directories we've already removed their 	 * parent link cnt.  Don't try to adjust our link down again. 	 */
if|if
condition|(
name|sino
operator|!=
name|NULL
operator|&&
name|isdotdot
operator|==
literal|0
condition|)
name|ino_setskip
argument_list|(
name|sino
argument_list|,
name|parent
argument_list|)
expr_stmt|;
comment|/* 	 * No valid record for this inode.  Just drop the on-disk 	 * link by one. 	 */
if|if
condition|(
name|sino
operator|==
name|NULL
operator|||
name|sino
operator|->
name|si_hasrecs
operator|==
literal|0
condition|)
block|{
name|ino_decr
argument_list|(
name|child
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Use ino_adjust() if ino_check() has already processed this 	 * child.  If we lose the last non-dot reference to a 	 * directory it will be discarded. 	 */
if|if
condition|(
name|sino
operator|->
name|si_linkadj
condition|)
block|{
name|sino
operator|->
name|si_nlink
operator|--
expr_stmt|;
if|if
condition|(
name|isdotdot
condition|)
name|sino
operator|->
name|si_dotlinks
operator|--
expr_stmt|;
name|ino_adjust
argument_list|(
name|sino
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we haven't yet processed this inode we need to make 	 * sure we will successfully discover the lost path.  If not 	 * use nlinkadj to remember. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|srec
argument_list|,
argument|&sino->si_recs
argument_list|,
argument|sr_next
argument_list|)
block|{
name|rrec
operator|=
operator|(
expr|struct
name|jrefrec
operator|*
operator|)
name|srec
operator|->
name|sr_rec
expr_stmt|;
if|if
condition|(
name|rrec
operator|->
name|jr_parent
operator|==
name|parent
operator|&&
name|rrec
operator|->
name|jr_diroff
operator|==
name|diroff
condition|)
return|return;
block|}
name|sino
operator|->
name|si_nlinkadj
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free the children of a directory when the directory is discarded.  */
end_comment

begin_function
specifier|static
name|void
name|ino_free_children
parameter_list|(
name|ino_t
name|ino
parameter_list|,
name|ufs_lbn_t
name|lbn
parameter_list|,
name|ufs2_daddr_t
name|blk
parameter_list|,
name|int
name|frags
parameter_list|)
block|{
name|struct
name|suj_ino
modifier|*
name|sino
decl_stmt|;
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|off_t
name|diroff
decl_stmt|;
name|uint8_t
modifier|*
name|block
decl_stmt|;
name|int
name|skipparent
decl_stmt|;
name|int
name|isdotdot
decl_stmt|;
name|int
name|dpoff
decl_stmt|;
name|int
name|size
decl_stmt|;
name|sino
operator|=
name|ino_lookup
argument_list|(
name|ino
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sino
condition|)
name|skipparent
operator|=
name|sino
operator|->
name|si_skipparent
expr_stmt|;
else|else
name|skipparent
operator|=
literal|0
expr_stmt|;
name|size
operator|=
name|lfragtosize
argument_list|(
name|fs
argument_list|,
name|frags
argument_list|)
expr_stmt|;
name|block
operator|=
name|dblk_read
argument_list|(
name|blk
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|&
name|block
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|dpoff
operator|=
literal|0
init|;
name|dpoff
operator|<
name|size
operator|&&
name|dp
operator|->
name|d_reclen
condition|;
name|dpoff
operator|+=
name|dp
operator|->
name|d_reclen
control|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|&
name|block
index|[
name|dpoff
index|]
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|==
literal|0
operator|||
name|dp
operator|->
name|d_ino
operator|==
name|WINO
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_namlen
operator|==
literal|1
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
continue|continue;
name|isdotdot
operator|=
name|dp
operator|->
name|d_namlen
operator|==
literal|2
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
expr_stmt|;
if|if
condition|(
name|isdotdot
operator|&&
name|skipparent
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Directory %d removing ino %d name %s\n"
argument_list|,
name|ino
argument_list|,
name|dp
operator|->
name|d_ino
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|diroff
operator|=
name|lblktosize
argument_list|(
name|fs
argument_list|,
name|lbn
argument_list|)
operator|+
name|dpoff
expr_stmt|;
name|ino_remref
argument_list|(
name|ino
argument_list|,
name|dp
operator|->
name|d_ino
argument_list|,
name|diroff
argument_list|,
name|isdotdot
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Reclaim an inode, freeing all blocks and decrementing all children's  * link counts.  Free the inode back to the cg.  */
end_comment

begin_function
specifier|static
name|void
name|ino_reclaim
parameter_list|(
name|union
name|dinode
modifier|*
name|ip
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|uint32_t
name|gen
decl_stmt|;
if|if
condition|(
name|ino
operator|==
name|ROOTINO
condition|)
name|err_suj
argument_list|(
literal|"Attempting to free ROOTINO\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Truncating and freeing ino %d, nlink %d, mode %o\n"
argument_list|,
name|ino
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_nlink
argument_list|)
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_mode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We are freeing an inode or directory. */
if|if
condition|(
operator|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_mode
argument_list|)
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
condition|)
name|ino_visit
argument_list|(
name|ip
argument_list|,
name|ino
argument_list|,
name|ino_free_children
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|di_nlink
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ino_visit
argument_list|(
name|ip
argument_list|,
name|ino
argument_list|,
name|blk_free_visit
argument_list|,
name|VISIT_EXT
operator||
name|VISIT_INDIR
argument_list|)
expr_stmt|;
comment|/* Here we have to clear the inode and release any blocks it holds. */
name|gen
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|bzero
argument_list|(
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ufs1_dinode
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bzero
argument_list|(
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ufs2_dinode
argument_list|)
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|di_gen
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|ino_dirty
argument_list|(
name|ino
argument_list|)
expr_stmt|;
name|ino_free
argument_list|(
name|ino
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Adjust an inode's link count down by one when a directory goes away.  */
end_comment

begin_function
specifier|static
name|void
name|ino_decr
parameter_list|(
name|ino_t
name|ino
parameter_list|)
block|{
name|union
name|dinode
modifier|*
name|ip
decl_stmt|;
name|int
name|reqlink
decl_stmt|;
name|int
name|nlink
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|ip
operator|=
name|ino_read
argument_list|(
name|ino
argument_list|)
expr_stmt|;
name|nlink
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_nlink
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlink
operator|<
literal|1
condition|)
name|err_suj
argument_list|(
literal|"Inode %d link count %d invalid\n"
argument_list|,
name|ino
argument_list|,
name|nlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
name|err_suj
argument_list|(
literal|"Inode %d has a link of %d with 0 mode\n"
argument_list|,
name|ino
argument_list|,
name|nlink
argument_list|)
expr_stmt|;
name|nlink
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
condition|)
name|reqlink
operator|=
literal|2
expr_stmt|;
else|else
name|reqlink
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nlink
operator|<
name|reqlink
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ino %d not enough links to live %d< %d\n"
argument_list|,
name|ino
argument_list|,
name|nlink
argument_list|,
name|reqlink
argument_list|)
expr_stmt|;
name|ino_reclaim
argument_list|(
name|ip
argument_list|,
name|ino
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return;
block|}
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|di_nlink
argument_list|,
name|nlink
argument_list|)
expr_stmt|;
name|ino_dirty
argument_list|(
name|ino
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adjust the inode link count to 'nlink'.  If the count reaches zero  * free it.  */
end_comment

begin_function
specifier|static
name|void
name|ino_adjust
parameter_list|(
name|struct
name|suj_ino
modifier|*
name|sino
parameter_list|)
block|{
name|struct
name|jrefrec
modifier|*
name|rrec
decl_stmt|;
name|struct
name|suj_rec
modifier|*
name|srec
decl_stmt|;
name|struct
name|suj_ino
modifier|*
name|stmp
decl_stmt|;
name|union
name|dinode
modifier|*
name|ip
decl_stmt|;
name|nlink_t
name|nlink
decl_stmt|;
name|int
name|recmode
decl_stmt|;
name|int
name|reqlink
decl_stmt|;
name|int
name|isdot
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|nlink
operator|=
name|sino
operator|->
name|si_nlink
expr_stmt|;
name|ino
operator|=
name|sino
operator|->
name|si_ino
expr_stmt|;
name|mode
operator|=
name|sino
operator|->
name|si_mode
operator|&
name|IFMT
expr_stmt|;
comment|/* 	 * If it's a directory with no dot links, it was truncated before 	 * the name was cleared.  We need to clear the dirent that 	 * points at it. 	 */
if|if
condition|(
name|mode
operator|==
name|IFDIR
operator|&&
name|nlink
operator|==
literal|1
operator|&&
name|sino
operator|->
name|si_dotlinks
operator|==
literal|0
condition|)
block|{
name|sino
operator|->
name|si_nlink
operator|=
name|nlink
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|srec
argument_list|,
argument|&sino->si_recs
argument_list|,
argument|sr_next
argument_list|)
block|{
name|rrec
operator|=
operator|(
expr|struct
name|jrefrec
operator|*
operator|)
name|srec
operator|->
name|sr_rec
expr_stmt|;
if|if
condition|(
name|ino_isat
argument_list|(
name|rrec
operator|->
name|jr_parent
argument_list|,
name|rrec
operator|->
name|jr_diroff
argument_list|,
name|ino
argument_list|,
operator|&
name|recmode
argument_list|,
operator|&
name|isdot
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|ino_clrat
argument_list|(
name|rrec
operator|->
name|jr_parent
argument_list|,
name|rrec
operator|->
name|jr_diroff
argument_list|,
name|ino
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|srec
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Directory %d name not found"
argument_list|,
name|ino
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If it's a directory with no real names pointing to it go ahead 	 * and truncate it.  This will free any children. 	 */
if|if
condition|(
name|mode
operator|==
name|IFDIR
operator|&&
name|nlink
operator|-
name|sino
operator|->
name|si_dotlinks
operator|==
literal|0
condition|)
block|{
name|sino
operator|->
name|si_nlink
operator|=
name|nlink
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Mark any .. links so they know not to free this inode 		 * when they are removed. 		 */
name|TAILQ_FOREACH
argument_list|(
argument|srec
argument_list|,
argument|&sino->si_recs
argument_list|,
argument|sr_next
argument_list|)
block|{
name|rrec
operator|=
operator|(
expr|struct
name|jrefrec
operator|*
operator|)
name|srec
operator|->
name|sr_rec
expr_stmt|;
if|if
condition|(
name|rrec
operator|->
name|jr_diroff
operator|==
name|DOTDOT_OFFSET
condition|)
block|{
name|stmp
operator|=
name|ino_lookup
argument_list|(
name|rrec
operator|->
name|jr_parent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmp
condition|)
name|ino_setskip
argument_list|(
name|stmp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ip
operator|=
name|ino_read
argument_list|(
name|ino
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_mode
argument_list|)
operator|&
name|IFMT
expr_stmt|;
if|if
condition|(
name|nlink
operator|>
name|LINK_MAX
condition|)
name|err_suj
argument_list|(
literal|"ino %d nlink manipulation error, new link %d, old link %d\n"
argument_list|,
name|ino
argument_list|,
name|nlink
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_nlink
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Adjusting ino %d, nlink %d, old link %d lastmode %o\n"
argument_list|,
name|ino
argument_list|,
name|nlink
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_nlink
argument_list|)
argument_list|,
name|sino
operator|->
name|si_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ino %d, zero inode freeing bitmap\n"
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|ino_free
argument_list|(
name|ino
argument_list|,
name|sino
operator|->
name|si_mode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX Should be an assert? */
if|if
condition|(
name|mode
operator|!=
name|sino
operator|->
name|si_mode
operator|&&
name|debug
condition|)
name|printf
argument_list|(
literal|"ino %d, mode %o != %o\n"
argument_list|,
name|ino
argument_list|,
name|mode
argument_list|,
name|sino
operator|->
name|si_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
condition|)
name|reqlink
operator|=
literal|2
expr_stmt|;
else|else
name|reqlink
operator|=
literal|1
expr_stmt|;
comment|/* If the inode doesn't have enough links to live, free it. */
if|if
condition|(
name|nlink
operator|<
name|reqlink
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ino %d not enough links to live %d< %d\n"
argument_list|,
name|ino
argument_list|,
name|nlink
argument_list|,
name|reqlink
argument_list|)
expr_stmt|;
name|ino_reclaim
argument_list|(
name|ip
argument_list|,
name|ino
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If required write the updated link count. */
if|if
condition|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_nlink
argument_list|)
operator|==
name|nlink
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ino %d, link matches, skipping.\n"
argument_list|,
name|ino
argument_list|)
expr_stmt|;
return|return;
block|}
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|di_nlink
argument_list|,
name|nlink
argument_list|)
expr_stmt|;
name|ino_dirty
argument_list|(
name|ino
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Truncate some or all blocks in an indirect, freeing any that are required  * and zeroing the indirect.  */
end_comment

begin_function
specifier|static
name|void
name|indir_trunc
parameter_list|(
name|ino_t
name|ino
parameter_list|,
name|ufs_lbn_t
name|lbn
parameter_list|,
name|ufs2_daddr_t
name|blk
parameter_list|,
name|ufs_lbn_t
name|lastlbn
parameter_list|)
block|{
name|ufs2_daddr_t
modifier|*
name|bap2
decl_stmt|;
name|ufs1_daddr_t
modifier|*
name|bap1
decl_stmt|;
name|ufs_lbn_t
name|lbnadd
decl_stmt|;
name|ufs2_daddr_t
name|nblk
decl_stmt|;
name|ufs_lbn_t
name|next
decl_stmt|;
name|ufs_lbn_t
name|nlbn
decl_stmt|;
name|int
name|dirty
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|blk
operator|==
literal|0
condition|)
return|return;
name|dirty
operator|=
literal|0
expr_stmt|;
name|level
operator|=
name|lbn_level
argument_list|(
name|lbn
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
operator|-
literal|1
condition|)
name|err_suj
argument_list|(
literal|"Invalid level for lbn %jd\n"
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
name|lbnadd
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|level
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|lbnadd
operator|*=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|bap1
operator|=
operator|(
name|void
operator|*
operator|)
name|dblk_read
argument_list|(
name|blk
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|bap2
operator|=
operator|(
name|void
operator|*
operator|)
name|bap1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fs
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|nblk
operator|=
operator|*
name|bap1
operator|++
expr_stmt|;
else|else
name|nblk
operator|=
operator|*
name|bap2
operator|++
expr_stmt|;
if|if
condition|(
name|nblk
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
block|{
name|nlbn
operator|=
operator|(
name|lbn
operator|+
literal|1
operator|)
operator|-
operator|(
name|i
operator|*
name|lbnadd
operator|)
expr_stmt|;
comment|/* 			 * Calculate the lbn of the next indirect to 			 * determine if any of this indirect must be 			 * reclaimed. 			 */
name|next
operator|=
operator|-
operator|(
name|lbn
operator|+
name|level
operator|)
operator|+
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|lbnadd
operator|)
expr_stmt|;
if|if
condition|(
name|next
operator|<=
name|lastlbn
condition|)
continue|continue;
name|indir_trunc
argument_list|(
name|ino
argument_list|,
name|nlbn
argument_list|,
name|nblk
argument_list|,
name|lastlbn
argument_list|)
expr_stmt|;
comment|/* If all of this indirect was reclaimed, free it. */
name|nlbn
operator|=
name|next
operator|-
name|lbnadd
expr_stmt|;
if|if
condition|(
name|nlbn
operator|<
name|lastlbn
condition|)
continue|continue;
block|}
else|else
block|{
name|nlbn
operator|=
operator|-
name|lbn
operator|+
name|i
operator|*
name|lbnadd
expr_stmt|;
if|if
condition|(
name|nlbn
operator|<
name|lastlbn
condition|)
continue|continue;
block|}
name|dirty
operator|=
literal|1
expr_stmt|;
name|blk_free
argument_list|(
name|nblk
argument_list|,
literal|0
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
operator|*
operator|(
name|bap1
operator|-
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
else|else
operator|*
operator|(
name|bap2
operator|-
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dirty
condition|)
name|dblk_dirty
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Truncate an inode to the minimum of the given size or the last populated  * block after any over size have been discarded.  The kernel would allocate  * the last block in the file but fsck does not and neither do we.  This  * code never extends files, only shrinks them.  */
end_comment

begin_function
specifier|static
name|void
name|ino_trunc
parameter_list|(
name|ino_t
name|ino
parameter_list|,
name|off_t
name|size
parameter_list|)
block|{
name|union
name|dinode
modifier|*
name|ip
decl_stmt|;
name|ufs2_daddr_t
name|bn
decl_stmt|;
name|uint64_t
name|totalfrags
decl_stmt|;
name|ufs_lbn_t
name|nextlbn
decl_stmt|;
name|ufs_lbn_t
name|lastlbn
decl_stmt|;
name|ufs_lbn_t
name|tmpval
decl_stmt|;
name|ufs_lbn_t
name|lbn
decl_stmt|;
name|ufs_lbn_t
name|i
decl_stmt|;
name|int
name|frags
decl_stmt|;
name|off_t
name|cursize
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|ip
operator|=
name|ino_read
argument_list|(
name|ino
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_mode
argument_list|)
operator|&
name|IFMT
expr_stmt|;
name|cursize
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Truncating ino %d, mode %o to size %jd from size %jd\n"
argument_list|,
name|ino
argument_list|,
name|mode
argument_list|,
name|size
argument_list|,
name|cursize
argument_list|)
expr_stmt|;
comment|/* Skip datablocks for short links and devices. */
if|if
condition|(
name|mode
operator|==
literal|0
operator|||
name|mode
operator|==
name|IFBLK
operator|||
name|mode
operator|==
name|IFCHR
operator|||
operator|(
name|mode
operator|==
name|IFLNK
operator|&&
name|cursize
operator|<
name|fs
operator|->
name|fs_maxsymlinklen
operator|)
condition|)
return|return;
comment|/* Don't extend. */
if|if
condition|(
name|size
operator|>
name|cursize
condition|)
name|size
operator|=
name|cursize
expr_stmt|;
name|lastlbn
operator|=
name|lblkno
argument_list|(
name|fs
argument_list|,
name|blkroundup
argument_list|(
name|fs
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lastlbn
init|;
name|i
operator|<
name|NDADDR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_db
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|frags
operator|=
name|sblksize
argument_list|(
name|fs
argument_list|,
name|cursize
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|frags
operator|=
name|numfrags
argument_list|(
name|fs
argument_list|,
name|frags
argument_list|)
expr_stmt|;
name|blk_free
argument_list|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_db
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0
argument_list|,
name|frags
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|di_db
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Follow indirect blocks, freeing anything required. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tmpval
operator|=
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|,
name|lbn
operator|=
name|NDADDR
init|;
name|i
operator|<
name|NIADDR
condition|;
name|i
operator|++
operator|,
name|lbn
operator|=
name|nextlbn
control|)
block|{
name|nextlbn
operator|=
name|lbn
operator|+
name|tmpval
expr_stmt|;
name|tmpval
operator|*=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* If we're not freeing any in this indirect range skip it. */
if|if
condition|(
name|lastlbn
operator|>=
name|nextlbn
condition|)
continue|continue;
if|if
condition|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_ib
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|indir_trunc
argument_list|(
name|ino
argument_list|,
operator|-
name|lbn
operator|-
name|i
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_ib
index|[
name|i
index|]
argument_list|)
argument_list|,
name|lastlbn
argument_list|)
expr_stmt|;
comment|/* If we freed everything in this indirect free the indir. */
if|if
condition|(
name|lastlbn
operator|>
name|lbn
condition|)
continue|continue;
name|blk_free
argument_list|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_ib
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0
argument_list|,
name|frags
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|di_ib
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ino_dirty
argument_list|(
name|ino
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we've freed any whole blocks that exceed the desired 	 * truncation size, figure out how many blocks remain and what the 	 * last populated lbn is.  We will set the size to this last lbn 	 * rather than worrying about allocating the final lbn as the kernel 	 * would've done.  This is consistent with normal fsck behavior. 	 */
name|visitlbn
operator|=
literal|0
expr_stmt|;
name|totalfrags
operator|=
name|ino_visit
argument_list|(
name|ip
argument_list|,
name|ino
argument_list|,
name|null_visit
argument_list|,
name|VISIT_INDIR
operator||
name|VISIT_EXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|lblktosize
argument_list|(
name|fs
argument_list|,
name|visitlbn
operator|+
literal|1
argument_list|)
condition|)
name|size
operator|=
name|lblktosize
argument_list|(
name|fs
argument_list|,
name|visitlbn
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If we're truncating direct blocks we have to adjust frags 	 * accordingly. 	 */
if|if
condition|(
name|visitlbn
operator|<
name|NDADDR
operator|&&
name|totalfrags
condition|)
block|{
name|long
name|oldspace
decl_stmt|,
name|newspace
decl_stmt|;
name|bn
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_db
index|[
name|visitlbn
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bn
operator|==
literal|0
condition|)
name|err_suj
argument_list|(
literal|"Bad blk at ino %d lbn %jd\n"
argument_list|,
name|ino
argument_list|,
name|visitlbn
argument_list|)
expr_stmt|;
name|oldspace
operator|=
name|sblksize
argument_list|(
name|fs
argument_list|,
name|cursize
argument_list|,
name|visitlbn
argument_list|)
expr_stmt|;
name|newspace
operator|=
name|sblksize
argument_list|(
name|fs
argument_list|,
name|size
argument_list|,
name|visitlbn
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldspace
operator|!=
name|newspace
condition|)
block|{
name|bn
operator|+=
name|numfrags
argument_list|(
name|fs
argument_list|,
name|newspace
argument_list|)
expr_stmt|;
name|frags
operator|=
name|numfrags
argument_list|(
name|fs
argument_list|,
name|oldspace
operator|-
name|newspace
argument_list|)
expr_stmt|;
name|blk_free
argument_list|(
name|bn
argument_list|,
literal|0
argument_list|,
name|frags
argument_list|)
expr_stmt|;
name|totalfrags
operator|-=
name|frags
expr_stmt|;
block|}
block|}
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|di_blocks
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|totalfrags
argument_list|)
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|di_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* 	 * If we've truncated into the middle of a block or frag we have 	 * to zero it here.  Otherwise the file could extend into 	 * uninitialized space later. 	 */
name|off
operator|=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|&&
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_mode
argument_list|)
operator|!=
name|IFDIR
condition|)
block|{
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|long
name|clrsize
decl_stmt|;
name|bn
operator|=
name|ino_blkatoff
argument_list|(
name|ip
argument_list|,
name|ino
argument_list|,
name|visitlbn
argument_list|,
operator|&
name|frags
argument_list|)
expr_stmt|;
if|if
condition|(
name|bn
operator|==
literal|0
condition|)
name|err_suj
argument_list|(
literal|"Block missing from ino %d at lbn %jd\n"
argument_list|,
name|ino
argument_list|,
name|visitlbn
argument_list|)
expr_stmt|;
name|clrsize
operator|=
name|frags
operator|*
name|fs
operator|->
name|fs_fsize
expr_stmt|;
name|buf
operator|=
name|dblk_read
argument_list|(
name|bn
argument_list|,
name|clrsize
argument_list|)
expr_stmt|;
name|clrsize
operator|-=
name|off
expr_stmt|;
name|buf
operator|+=
name|off
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|clrsize
argument_list|)
expr_stmt|;
name|dblk_dirty
argument_list|(
name|bn
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Process records available for one inode and determine whether the  * link count is correct or needs adjusting.  */
end_comment

begin_function
specifier|static
name|void
name|ino_check
parameter_list|(
name|struct
name|suj_ino
modifier|*
name|sino
parameter_list|)
block|{
name|struct
name|suj_rec
modifier|*
name|srec
decl_stmt|;
name|struct
name|jrefrec
modifier|*
name|rrec
decl_stmt|;
name|nlink_t
name|dotlinks
decl_stmt|;
name|int
name|newlinks
decl_stmt|;
name|int
name|removes
decl_stmt|;
name|int
name|nlink
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|int
name|isdot
decl_stmt|;
name|int
name|isat
decl_stmt|;
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|sino
operator|->
name|si_hasrecs
operator|==
literal|0
condition|)
return|return;
name|ino
operator|=
name|sino
operator|->
name|si_ino
expr_stmt|;
name|rrec
operator|=
operator|(
expr|struct
name|jrefrec
operator|*
operator|)
name|TAILQ_FIRST
argument_list|(
operator|&
name|sino
operator|->
name|si_recs
argument_list|)
operator|->
name|sr_rec
expr_stmt|;
name|nlink
operator|=
name|rrec
operator|->
name|jr_nlink
expr_stmt|;
name|newlinks
operator|=
literal|0
expr_stmt|;
name|dotlinks
operator|=
literal|0
expr_stmt|;
name|removes
operator|=
name|sino
operator|->
name|si_nlinkadj
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|srec
argument_list|,
argument|&sino->si_recs
argument_list|,
argument|sr_next
argument_list|)
block|{
name|rrec
operator|=
operator|(
expr|struct
name|jrefrec
operator|*
operator|)
name|srec
operator|->
name|sr_rec
expr_stmt|;
name|isat
operator|=
name|ino_isat
argument_list|(
name|rrec
operator|->
name|jr_parent
argument_list|,
name|rrec
operator|->
name|jr_diroff
argument_list|,
name|rrec
operator|->
name|jr_ino
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|isdot
argument_list|)
expr_stmt|;
if|if
condition|(
name|isat
operator|&&
operator|(
name|mode
operator|&
name|IFMT
operator|)
operator|!=
operator|(
name|rrec
operator|->
name|jr_mode
operator|&
name|IFMT
operator|)
condition|)
name|err_suj
argument_list|(
literal|"Inode mode/directory type mismatch %o != %o\n"
argument_list|,
name|mode
argument_list|,
name|rrec
operator|->
name|jr_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"jrefrec: op %d ino %d, nlink %d, parent %d, "
literal|"diroff %jd, mode %o, isat %d, isdot %d\n"
argument_list|,
name|rrec
operator|->
name|jr_op
argument_list|,
name|rrec
operator|->
name|jr_ino
argument_list|,
name|rrec
operator|->
name|jr_nlink
argument_list|,
name|rrec
operator|->
name|jr_parent
argument_list|,
name|rrec
operator|->
name|jr_diroff
argument_list|,
name|rrec
operator|->
name|jr_mode
argument_list|,
name|isat
argument_list|,
name|isdot
argument_list|)
expr_stmt|;
name|mode
operator|=
name|rrec
operator|->
name|jr_mode
operator|&
name|IFMT
expr_stmt|;
if|if
condition|(
name|rrec
operator|->
name|jr_op
operator|==
name|JOP_REMREF
condition|)
name|removes
operator|++
expr_stmt|;
name|newlinks
operator|+=
name|isat
expr_stmt|;
if|if
condition|(
name|isdot
condition|)
name|dotlinks
operator|+=
name|isat
expr_stmt|;
block|}
comment|/* 	 * The number of links that remain are the starting link count 	 * subtracted by the total number of removes with the total 	 * links discovered back in.  An incomplete remove thus 	 * makes no change to the link count but an add increases 	 * by one. 	 */
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ino %d nlink %d newlinks %d removes %d dotlinks %d\n"
argument_list|,
name|ino
argument_list|,
name|nlink
argument_list|,
name|newlinks
argument_list|,
name|removes
argument_list|,
name|dotlinks
argument_list|)
expr_stmt|;
name|nlink
operator|+=
name|newlinks
expr_stmt|;
name|nlink
operator|-=
name|removes
expr_stmt|;
name|sino
operator|->
name|si_linkadj
operator|=
literal|1
expr_stmt|;
name|sino
operator|->
name|si_nlink
operator|=
name|nlink
expr_stmt|;
name|sino
operator|->
name|si_dotlinks
operator|=
name|dotlinks
expr_stmt|;
name|sino
operator|->
name|si_mode
operator|=
name|mode
expr_stmt|;
name|ino_adjust
argument_list|(
name|sino
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process records available for one block and determine whether it is  * still allocated and whether the owning inode needs to be updated or  * a free completed.  */
end_comment

begin_function
specifier|static
name|void
name|blk_check
parameter_list|(
name|struct
name|suj_blk
modifier|*
name|sblk
parameter_list|)
block|{
name|struct
name|suj_rec
modifier|*
name|srec
decl_stmt|;
name|struct
name|jblkrec
modifier|*
name|brec
decl_stmt|;
name|struct
name|suj_ino
modifier|*
name|sino
decl_stmt|;
name|ufs2_daddr_t
name|blk
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|frags
decl_stmt|;
name|int
name|isat
decl_stmt|;
comment|/* 	 * Each suj_blk actually contains records for any fragments in that 	 * block.  As a result we must evaluate each record individually. 	 */
name|sino
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|srec
argument_list|,
argument|&sblk->sb_recs
argument_list|,
argument|sr_next
argument_list|)
block|{
name|brec
operator|=
operator|(
expr|struct
name|jblkrec
operator|*
operator|)
name|srec
operator|->
name|sr_rec
expr_stmt|;
name|frags
operator|=
name|brec
operator|->
name|jb_frags
expr_stmt|;
name|blk
operator|=
name|brec
operator|->
name|jb_blkno
operator|+
name|brec
operator|->
name|jb_oldfrags
expr_stmt|;
name|isat
operator|=
name|blk_isat
argument_list|(
name|brec
operator|->
name|jb_ino
argument_list|,
name|brec
operator|->
name|jb_lbn
argument_list|,
name|blk
argument_list|,
operator|&
name|frags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sino
operator|==
name|NULL
operator|||
name|sino
operator|->
name|si_ino
operator|!=
name|brec
operator|->
name|jb_ino
condition|)
block|{
name|sino
operator|=
name|ino_lookup
argument_list|(
name|brec
operator|->
name|jb_ino
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sino
operator|->
name|si_blkadj
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"op %d blk %jd ino %d lbn %jd frags %d isat %d (%d)\n"
argument_list|,
name|brec
operator|->
name|jb_op
argument_list|,
name|blk
argument_list|,
name|brec
operator|->
name|jb_ino
argument_list|,
name|brec
operator|->
name|jb_lbn
argument_list|,
name|brec
operator|->
name|jb_frags
argument_list|,
name|isat
argument_list|,
name|frags
argument_list|)
expr_stmt|;
comment|/* 		 * If we found the block at this address we still have to 		 * determine if we need to free the tail end that was 		 * added by adding contiguous fragments from the same block. 		 */
if|if
condition|(
name|isat
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|frags
operator|==
name|brec
operator|->
name|jb_frags
condition|)
continue|continue;
name|mask
operator|=
name|blk_freemask
argument_list|(
name|blk
argument_list|,
name|brec
operator|->
name|jb_ino
argument_list|,
name|brec
operator|->
name|jb_lbn
argument_list|,
name|brec
operator|->
name|jb_frags
argument_list|)
expr_stmt|;
name|mask
operator|>>=
name|frags
expr_stmt|;
name|blk
operator|+=
name|frags
expr_stmt|;
name|frags
operator|=
name|brec
operator|->
name|jb_frags
operator|-
name|frags
expr_stmt|;
name|blk_free
argument_list|(
name|blk
argument_list|,
name|mask
argument_list|,
name|frags
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 	 * The block wasn't found, attempt to free it.  It won't be 		 * freed if it was actually reallocated.  If this was an 		 * allocation we don't want to follow indirects as they 		 * may not be written yet.  Any children of the indirect will 		 * have their own records.  If it's a free we need to 		 * recursively free children. 		 */
name|blk_free_lbn
argument_list|(
name|blk
argument_list|,
name|brec
operator|->
name|jb_ino
argument_list|,
name|brec
operator|->
name|jb_lbn
argument_list|,
name|brec
operator|->
name|jb_frags
argument_list|,
name|brec
operator|->
name|jb_op
operator|==
name|JOP_FREEBLK
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Walk the list of inode records for this cg and resolve moved and duplicate  * inode references now that we have a complete picture.  */
end_comment

begin_function
specifier|static
name|void
name|cg_build
parameter_list|(
name|struct
name|suj_cg
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|suj_ino
modifier|*
name|sino
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SUJ_HASHSIZE
condition|;
name|i
operator|++
control|)
name|LIST_FOREACH
argument_list|(
argument|sino
argument_list|,
argument|&sc->sc_inohash[i]
argument_list|,
argument|si_next
argument_list|)
name|ino_build
argument_list|(
name|sino
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle inodes requiring truncation.  This must be done prior to  * looking up any inodes in directories.  */
end_comment

begin_function
specifier|static
name|void
name|cg_trunc
parameter_list|(
name|struct
name|suj_cg
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|suj_ino
modifier|*
name|sino
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SUJ_HASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|sino
argument_list|,
argument|&sc->sc_inohash[i]
argument_list|,
argument|si_next
argument_list|)
block|{
if|if
condition|(
name|sino
operator|->
name|si_trunc
condition|)
block|{
name|ino_trunc
argument_list|(
name|sino
operator|->
name|si_ino
argument_list|,
name|sino
operator|->
name|si_trunc
operator|->
name|jt_size
argument_list|)
expr_stmt|;
name|sino
operator|->
name|si_blkadj
operator|=
literal|0
expr_stmt|;
name|sino
operator|->
name|si_trunc
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sino
operator|->
name|si_blkadj
condition|)
name|ino_adjblks
argument_list|(
name|sino
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Free any partially allocated blocks and then resolve inode block  * counts.  */
end_comment

begin_function
specifier|static
name|void
name|cg_check_blk
parameter_list|(
name|struct
name|suj_cg
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|suj_blk
modifier|*
name|sblk
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SUJ_HASHSIZE
condition|;
name|i
operator|++
control|)
name|LIST_FOREACH
argument_list|(
argument|sblk
argument_list|,
argument|&sc->sc_blkhash[i]
argument_list|,
argument|sb_next
argument_list|)
name|blk_check
argument_list|(
name|sblk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Walk the list of inode records for this cg, recovering any  * changes which were not complete at the time of crash.  */
end_comment

begin_function
specifier|static
name|void
name|cg_check_ino
parameter_list|(
name|struct
name|suj_cg
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|suj_ino
modifier|*
name|sino
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SUJ_HASHSIZE
condition|;
name|i
operator|++
control|)
name|LIST_FOREACH
argument_list|(
argument|sino
argument_list|,
argument|&sc->sc_inohash[i]
argument_list|,
argument|si_next
argument_list|)
name|ino_check
argument_list|(
name|sino
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a potentially dirty cg.  Recalculate the summary information and  * update the superblock summary.  */
end_comment

begin_function
specifier|static
name|void
name|cg_write
parameter_list|(
name|struct
name|suj_cg
modifier|*
name|sc
parameter_list|)
block|{
name|ufs1_daddr_t
name|fragno
decl_stmt|,
name|cgbno
decl_stmt|,
name|maxbno
decl_stmt|;
name|u_int8_t
modifier|*
name|blksfree
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|int
name|blk
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dirty
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Fix the frag and cluster summary. 	 */
name|cgp
operator|=
name|sc
operator|->
name|sc_cgp
expr_stmt|;
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nbfree
operator|=
literal|0
expr_stmt|;
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nffree
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cgp
operator|->
name|cg_frsum
argument_list|,
sizeof|sizeof
argument_list|(
name|cgp
operator|->
name|cg_frsum
argument_list|)
argument_list|)
expr_stmt|;
name|maxbno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_fpg
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|fs
operator|->
name|fs_contigsumsize
condition|;
name|i
operator|++
control|)
name|cg_clustersum
argument_list|(
name|cgp
argument_list|)
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|cg_clustersfree
argument_list|(
name|cgp
argument_list|)
argument_list|,
name|howmany
argument_list|(
name|maxbno
argument_list|,
name|CHAR_BIT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|blksfree
operator|=
name|cg_blksfree
argument_list|(
name|cgp
argument_list|)
expr_stmt|;
for|for
control|(
name|cgbno
operator|=
literal|0
init|;
name|cgbno
operator|<
name|maxbno
condition|;
name|cgbno
operator|++
control|)
block|{
if|if
condition|(
name|ffs_isfreeblock
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
name|cgbno
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ffs_isblock
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
name|cgbno
argument_list|)
condition|)
block|{
name|ffs_clusteracct
argument_list|(
name|fs
argument_list|,
name|cgp
argument_list|,
name|cgbno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
continue|continue;
block|}
name|fragno
operator|=
name|blkstofrags
argument_list|(
name|fs
argument_list|,
name|cgbno
argument_list|)
expr_stmt|;
name|blk
operator|=
name|blkmap
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
name|fragno
argument_list|)
expr_stmt|;
name|ffs_fragacct
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|,
name|cgp
operator|->
name|cg_frsum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fs
operator|->
name|fs_frag
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|isset
argument_list|(
name|blksfree
argument_list|,
name|fragno
operator|+
name|i
argument_list|)
condition|)
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
comment|/* 	 * Update the superblock cg summary from our now correct values 	 * before writing the block. 	 */
name|fs
operator|->
name|fs_cs
argument_list|(
name|fs
argument_list|,
name|sc
operator|->
name|sc_cgx
argument_list|)
operator|=
name|cgp
operator|->
name|cg_cs
expr_stmt|;
if|if
condition|(
name|bwrite
argument_list|(
name|disk
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|sc
operator|->
name|sc_cgx
argument_list|)
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_cgbuf
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err_suj
argument_list|(
literal|"Unable to write cylinder group %d\n"
argument_list|,
name|sc
operator|->
name|sc_cgx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write out any modified inodes.  */
end_comment

begin_function
specifier|static
name|void
name|cg_write_inos
parameter_list|(
name|struct
name|suj_cg
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ino_blk
modifier|*
name|iblk
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SUJ_HASHSIZE
condition|;
name|i
operator|++
control|)
name|LIST_FOREACH
argument_list|(
argument|iblk
argument_list|,
argument|&sc->sc_iblkhash[i]
argument_list|,
argument|ib_next
argument_list|)
if|if
condition|(
name|iblk
operator|->
name|ib_dirty
condition|)
name|iblk_write
argument_list|(
name|iblk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cg_apply
parameter_list|(
name|void
function_decl|(
modifier|*
name|apply
function_decl|)
parameter_list|(
name|struct
name|suj_cg
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|suj_cg
modifier|*
name|scg
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SUJ_HASHSIZE
condition|;
name|i
operator|++
control|)
name|LIST_FOREACH
argument_list|(
argument|scg
argument_list|,
argument|&cghash[i]
argument_list|,
argument|sc_next
argument_list|)
name|apply
argument_list|(
name|scg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process the unlinked but referenced file list.  Freeing all inodes.  */
end_comment

begin_function
specifier|static
name|void
name|ino_unlinked
parameter_list|(
name|void
parameter_list|)
block|{
name|union
name|dinode
modifier|*
name|ip
decl_stmt|;
name|uint16_t
name|mode
decl_stmt|;
name|ino_t
name|inon
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|ino
operator|=
name|fs
operator|->
name|fs_sujfree
expr_stmt|;
name|fs
operator|->
name|fs_sujfree
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ino
operator|!=
literal|0
condition|)
block|{
name|ip
operator|=
name|ino_read
argument_list|(
name|ino
argument_list|)
expr_stmt|;
name|mode
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_mode
argument_list|)
operator|&
name|IFMT
expr_stmt|;
name|inon
operator|=
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_freelink
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|ip
argument_list|,
name|di_freelink
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * XXX Should this be an errx? 		 */
if|if
condition|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_nlink
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Freeing unlinked ino %d mode %o\n"
argument_list|,
name|ino
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|ino_reclaim
argument_list|(
name|ip
argument_list|,
name|ino
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Skipping ino %d mode %o with link %d\n"
argument_list|,
name|ino
argument_list|,
name|mode
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_nlink
argument_list|)
argument_list|)
expr_stmt|;
name|ino
operator|=
name|inon
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Append a new record to the list of records requiring processing.  */
end_comment

begin_function
specifier|static
name|void
name|ino_append
parameter_list|(
name|union
name|jrec
modifier|*
name|rec
parameter_list|)
block|{
name|struct
name|jrefrec
modifier|*
name|refrec
decl_stmt|;
name|struct
name|jmvrec
modifier|*
name|mvrec
decl_stmt|;
name|struct
name|suj_ino
modifier|*
name|sino
decl_stmt|;
name|struct
name|suj_rec
modifier|*
name|srec
decl_stmt|;
name|mvrec
operator|=
operator|&
name|rec
operator|->
name|rec_jmvrec
expr_stmt|;
name|refrec
operator|=
operator|&
name|rec
operator|->
name|rec_jrefrec
expr_stmt|;
if|if
condition|(
name|debug
operator|&&
name|mvrec
operator|->
name|jm_op
operator|==
name|JOP_MVREF
condition|)
name|printf
argument_list|(
literal|"ino move: ino %d, parent %d, diroff %jd, oldoff %jd\n"
argument_list|,
name|mvrec
operator|->
name|jm_ino
argument_list|,
name|mvrec
operator|->
name|jm_parent
argument_list|,
name|mvrec
operator|->
name|jm_newoff
argument_list|,
name|mvrec
operator|->
name|jm_oldoff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|debug
operator|&&
operator|(
name|refrec
operator|->
name|jr_op
operator|==
name|JOP_ADDREF
operator|||
name|refrec
operator|->
name|jr_op
operator|==
name|JOP_REMREF
operator|)
condition|)
name|printf
argument_list|(
literal|"ino ref: op %d, ino %d, nlink %d, "
literal|"parent %d, diroff %jd\n"
argument_list|,
name|refrec
operator|->
name|jr_op
argument_list|,
name|refrec
operator|->
name|jr_ino
argument_list|,
name|refrec
operator|->
name|jr_nlink
argument_list|,
name|refrec
operator|->
name|jr_parent
argument_list|,
name|refrec
operator|->
name|jr_diroff
argument_list|)
expr_stmt|;
name|sino
operator|=
name|ino_lookup
argument_list|(
operator|(
operator|(
expr|struct
name|jrefrec
operator|*
operator|)
name|rec
operator|)
operator|->
name|jr_ino
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sino
operator|->
name|si_hasrecs
operator|=
literal|1
expr_stmt|;
name|srec
operator|=
name|errmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|srec
argument_list|)
argument_list|)
expr_stmt|;
name|srec
operator|->
name|sr_rec
operator|=
name|rec
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sino
operator|->
name|si_newrecs
argument_list|,
name|srec
argument_list|,
name|sr_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a reference adjustment to the sino list and eliminate dups.  The  * primary loop in ino_build_ref() checks for dups but new ones may be  * created as a result of offset adjustments.  */
end_comment

begin_function
specifier|static
name|void
name|ino_add_ref
parameter_list|(
name|struct
name|suj_ino
modifier|*
name|sino
parameter_list|,
name|struct
name|suj_rec
modifier|*
name|srec
parameter_list|)
block|{
name|struct
name|jrefrec
modifier|*
name|refrec
decl_stmt|;
name|struct
name|suj_rec
modifier|*
name|srn
decl_stmt|;
name|struct
name|jrefrec
modifier|*
name|rrn
decl_stmt|;
name|refrec
operator|=
operator|(
expr|struct
name|jrefrec
operator|*
operator|)
name|srec
operator|->
name|sr_rec
expr_stmt|;
comment|/* 	 * We walk backwards so that the oldest link count is preserved.  If 	 * an add record conflicts with a remove keep the remove.  Redundant 	 * removes are eliminated in ino_build_ref.  Otherwise we keep the 	 * oldest record at a given location. 	 */
for|for
control|(
name|srn
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|sino
operator|->
name|si_recs
argument_list|,
name|srechd
argument_list|)
init|;
name|srn
condition|;
name|srn
operator|=
name|TAILQ_PREV
argument_list|(
name|srn
argument_list|,
name|srechd
argument_list|,
name|sr_next
argument_list|)
control|)
block|{
name|rrn
operator|=
operator|(
expr|struct
name|jrefrec
operator|*
operator|)
name|srn
operator|->
name|sr_rec
expr_stmt|;
if|if
condition|(
name|rrn
operator|->
name|jr_parent
operator|!=
name|refrec
operator|->
name|jr_parent
operator|||
name|rrn
operator|->
name|jr_diroff
operator|!=
name|refrec
operator|->
name|jr_diroff
condition|)
continue|continue;
if|if
condition|(
name|rrn
operator|->
name|jr_op
operator|==
name|JOP_REMREF
operator|||
name|refrec
operator|->
name|jr_op
operator|==
name|JOP_ADDREF
condition|)
block|{
name|rrn
operator|->
name|jr_mode
operator|=
name|refrec
operator|->
name|jr_mode
expr_stmt|;
return|return;
block|}
comment|/* 		 * Adding a remove. 		 * 		 * Replace the record in place with the old nlink in case 		 * we replace the head of the list.  Abandon srec as a dup. 		 */
name|refrec
operator|->
name|jr_nlink
operator|=
name|rrn
operator|->
name|jr_nlink
expr_stmt|;
name|srn
operator|->
name|sr_rec
operator|=
name|srec
operator|->
name|sr_rec
expr_stmt|;
return|return;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sino
operator|->
name|si_recs
argument_list|,
name|srec
argument_list|,
name|sr_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a duplicate of a reference at a previous location.  */
end_comment

begin_function
specifier|static
name|void
name|ino_dup_ref
parameter_list|(
name|struct
name|suj_ino
modifier|*
name|sino
parameter_list|,
name|struct
name|jrefrec
modifier|*
name|refrec
parameter_list|,
name|off_t
name|diroff
parameter_list|)
block|{
name|struct
name|jrefrec
modifier|*
name|rrn
decl_stmt|;
name|struct
name|suj_rec
modifier|*
name|srn
decl_stmt|;
name|rrn
operator|=
name|errmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|refrec
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rrn
operator|=
operator|*
name|refrec
expr_stmt|;
name|rrn
operator|->
name|jr_op
operator|=
name|JOP_ADDREF
expr_stmt|;
name|rrn
operator|->
name|jr_diroff
operator|=
name|diroff
expr_stmt|;
name|srn
operator|=
name|errmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|srn
argument_list|)
argument_list|)
expr_stmt|;
name|srn
operator|->
name|sr_rec
operator|=
operator|(
expr|union
name|jrec
operator|*
operator|)
name|rrn
expr_stmt|;
name|ino_add_ref
argument_list|(
name|sino
argument_list|,
name|srn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a reference to the list at all known locations.  We follow the offset  * changes for a single instance and create duplicate add refs at each so  * that we can tolerate any version of the directory block.  Eliminate  * removes which collide with adds that are seen in the journal.  They should  * not adjust the link count down.  */
end_comment

begin_function
specifier|static
name|void
name|ino_build_ref
parameter_list|(
name|struct
name|suj_ino
modifier|*
name|sino
parameter_list|,
name|struct
name|suj_rec
modifier|*
name|srec
parameter_list|)
block|{
name|struct
name|jrefrec
modifier|*
name|refrec
decl_stmt|;
name|struct
name|jmvrec
modifier|*
name|mvrec
decl_stmt|;
name|struct
name|suj_rec
modifier|*
name|srp
decl_stmt|;
name|struct
name|suj_rec
modifier|*
name|srn
decl_stmt|;
name|struct
name|jrefrec
modifier|*
name|rrn
decl_stmt|;
name|off_t
name|diroff
decl_stmt|;
name|refrec
operator|=
operator|(
expr|struct
name|jrefrec
operator|*
operator|)
name|srec
operator|->
name|sr_rec
expr_stmt|;
comment|/* 	 * Search for a mvrec that matches this offset.  Whether it's an add 	 * or a remove we can delete the mvref after creating a dup record in 	 * the old location. 	 */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sino
operator|->
name|si_movs
argument_list|)
condition|)
block|{
name|diroff
operator|=
name|refrec
operator|->
name|jr_diroff
expr_stmt|;
for|for
control|(
name|srn
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|sino
operator|->
name|si_movs
argument_list|,
name|srechd
argument_list|)
init|;
name|srn
condition|;
name|srn
operator|=
name|srp
control|)
block|{
name|srp
operator|=
name|TAILQ_PREV
argument_list|(
name|srn
argument_list|,
name|srechd
argument_list|,
name|sr_next
argument_list|)
expr_stmt|;
name|mvrec
operator|=
operator|(
expr|struct
name|jmvrec
operator|*
operator|)
name|srn
operator|->
name|sr_rec
expr_stmt|;
if|if
condition|(
name|mvrec
operator|->
name|jm_parent
operator|!=
name|refrec
operator|->
name|jr_parent
operator|||
name|mvrec
operator|->
name|jm_newoff
operator|!=
name|diroff
condition|)
continue|continue;
name|diroff
operator|=
name|mvrec
operator|->
name|jm_oldoff
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sino
operator|->
name|si_movs
argument_list|,
name|srn
argument_list|,
name|sr_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|srn
argument_list|)
expr_stmt|;
name|ino_dup_ref
argument_list|(
name|sino
argument_list|,
name|refrec
argument_list|,
name|diroff
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If a remove wasn't eliminated by an earlier add just append it to 	 * the list. 	 */
if|if
condition|(
name|refrec
operator|->
name|jr_op
operator|==
name|JOP_REMREF
condition|)
block|{
name|ino_add_ref
argument_list|(
name|sino
argument_list|,
name|srec
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Walk the list of records waiting to be added to the list.  We 	 * must check for moves that apply to our current offset and remove 	 * them from the list.  Remove any duplicates to eliminate removes 	 * with corresponding adds. 	 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|srn
argument_list|,
argument|&sino->si_newrecs
argument_list|,
argument|sr_next
argument_list|,
argument|srp
argument_list|)
block|{
switch|switch
condition|(
name|srn
operator|->
name|sr_rec
operator|->
name|rec_jrefrec
operator|.
name|jr_op
condition|)
block|{
case|case
name|JOP_ADDREF
case|:
comment|/* 			 * This should actually be an error we should 			 * have a remove for every add journaled. 			 */
name|rrn
operator|=
operator|(
expr|struct
name|jrefrec
operator|*
operator|)
name|srn
operator|->
name|sr_rec
expr_stmt|;
if|if
condition|(
name|rrn
operator|->
name|jr_parent
operator|!=
name|refrec
operator|->
name|jr_parent
operator|||
name|rrn
operator|->
name|jr_diroff
operator|!=
name|refrec
operator|->
name|jr_diroff
condition|)
break|break;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sino
operator|->
name|si_newrecs
argument_list|,
name|srn
argument_list|,
name|sr_next
argument_list|)
expr_stmt|;
break|break;
case|case
name|JOP_REMREF
case|:
comment|/* 			 * Once we remove the current iteration of the 			 * record at this address we're done. 			 */
name|rrn
operator|=
operator|(
expr|struct
name|jrefrec
operator|*
operator|)
name|srn
operator|->
name|sr_rec
expr_stmt|;
if|if
condition|(
name|rrn
operator|->
name|jr_parent
operator|!=
name|refrec
operator|->
name|jr_parent
operator|||
name|rrn
operator|->
name|jr_diroff
operator|!=
name|refrec
operator|->
name|jr_diroff
condition|)
break|break;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sino
operator|->
name|si_newrecs
argument_list|,
name|srn
argument_list|,
name|sr_next
argument_list|)
expr_stmt|;
name|ino_add_ref
argument_list|(
name|sino
argument_list|,
name|srec
argument_list|)
expr_stmt|;
return|return;
case|case
name|JOP_MVREF
case|:
comment|/* 			 * Update our diroff based on any moves that match 			 * and remove the move. 			 */
name|mvrec
operator|=
operator|(
expr|struct
name|jmvrec
operator|*
operator|)
name|srn
operator|->
name|sr_rec
expr_stmt|;
if|if
condition|(
name|mvrec
operator|->
name|jm_parent
operator|!=
name|refrec
operator|->
name|jr_parent
operator|||
name|mvrec
operator|->
name|jm_oldoff
operator|!=
name|refrec
operator|->
name|jr_diroff
condition|)
break|break;
name|ino_dup_ref
argument_list|(
name|sino
argument_list|,
name|refrec
argument_list|,
name|mvrec
operator|->
name|jm_oldoff
argument_list|)
expr_stmt|;
name|refrec
operator|->
name|jr_diroff
operator|=
name|mvrec
operator|->
name|jm_newoff
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sino
operator|->
name|si_newrecs
argument_list|,
name|srn
argument_list|,
name|sr_next
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err_suj
argument_list|(
literal|"ino_build_ref: Unknown op %d\n"
argument_list|,
name|srn
operator|->
name|sr_rec
operator|->
name|rec_jrefrec
operator|.
name|jr_op
argument_list|)
expr_stmt|;
block|}
block|}
name|ino_add_ref
argument_list|(
name|sino
argument_list|,
name|srec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Walk the list of new records and add them in-order resolving any  * dups and adjusted offsets.  */
end_comment

begin_function
specifier|static
name|void
name|ino_build
parameter_list|(
name|struct
name|suj_ino
modifier|*
name|sino
parameter_list|)
block|{
name|struct
name|suj_rec
modifier|*
name|srec
decl_stmt|;
while|while
condition|(
operator|(
name|srec
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sino
operator|->
name|si_newrecs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sino
operator|->
name|si_newrecs
argument_list|,
name|srec
argument_list|,
name|sr_next
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|srec
operator|->
name|sr_rec
operator|->
name|rec_jrefrec
operator|.
name|jr_op
condition|)
block|{
case|case
name|JOP_ADDREF
case|:
case|case
name|JOP_REMREF
case|:
name|ino_build_ref
argument_list|(
name|sino
argument_list|,
name|srec
argument_list|)
expr_stmt|;
break|break;
case|case
name|JOP_MVREF
case|:
comment|/* 			 * Add this mvrec to the queue of pending mvs. 			 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sino
operator|->
name|si_movs
argument_list|,
name|srec
argument_list|,
name|sr_next
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err_suj
argument_list|(
literal|"ino_build: Unknown op %d\n"
argument_list|,
name|srec
operator|->
name|sr_rec
operator|->
name|rec_jrefrec
operator|.
name|jr_op
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sino
operator|->
name|si_recs
argument_list|)
condition|)
name|sino
operator|->
name|si_hasrecs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Modify journal records so they refer to the base block number  * and a start and end frag range.  This is to facilitate the discovery  * of overlapping fragment allocations.  */
end_comment

begin_function
specifier|static
name|void
name|blk_build
parameter_list|(
name|struct
name|jblkrec
modifier|*
name|blkrec
parameter_list|)
block|{
name|struct
name|suj_rec
modifier|*
name|srec
decl_stmt|;
name|struct
name|suj_blk
modifier|*
name|sblk
decl_stmt|;
name|struct
name|jblkrec
modifier|*
name|blkrn
decl_stmt|;
name|ufs2_daddr_t
name|blk
decl_stmt|;
name|int
name|frag
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"blk_build: op %d blkno %jd frags %d oldfrags %d "
literal|"ino %d lbn %jd\n"
argument_list|,
name|blkrec
operator|->
name|jb_op
argument_list|,
name|blkrec
operator|->
name|jb_blkno
argument_list|,
name|blkrec
operator|->
name|jb_frags
argument_list|,
name|blkrec
operator|->
name|jb_oldfrags
argument_list|,
name|blkrec
operator|->
name|jb_ino
argument_list|,
name|blkrec
operator|->
name|jb_lbn
argument_list|)
expr_stmt|;
name|blk
operator|=
name|blknum
argument_list|(
name|fs
argument_list|,
name|blkrec
operator|->
name|jb_blkno
argument_list|)
expr_stmt|;
name|frag
operator|=
name|fragnum
argument_list|(
name|fs
argument_list|,
name|blkrec
operator|->
name|jb_blkno
argument_list|)
expr_stmt|;
name|sblk
operator|=
name|blk_lookup
argument_list|(
name|blk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Rewrite the record using oldfrags to indicate the offset into 	 * the block.  Leave jb_frags as the actual allocated count. 	 */
name|blkrec
operator|->
name|jb_blkno
operator|-=
name|frag
expr_stmt|;
name|blkrec
operator|->
name|jb_oldfrags
operator|=
name|frag
expr_stmt|;
if|if
condition|(
name|blkrec
operator|->
name|jb_oldfrags
operator|+
name|blkrec
operator|->
name|jb_frags
operator|>
name|fs
operator|->
name|fs_frag
condition|)
name|err_suj
argument_list|(
literal|"Invalid fragment count %d oldfrags %d\n"
argument_list|,
name|blkrec
operator|->
name|jb_frags
argument_list|,
name|frag
argument_list|)
expr_stmt|;
comment|/* 	 * Detect dups.  If we detect a dup we always discard the oldest 	 * record as it is superseded by the new record.  This speeds up 	 * later stages but also eliminates free records which are used 	 * to indicate that the contents of indirects can be trusted. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|srec
argument_list|,
argument|&sblk->sb_recs
argument_list|,
argument|sr_next
argument_list|)
block|{
name|blkrn
operator|=
operator|(
expr|struct
name|jblkrec
operator|*
operator|)
name|srec
operator|->
name|sr_rec
expr_stmt|;
if|if
condition|(
name|blkrn
operator|->
name|jb_ino
operator|!=
name|blkrec
operator|->
name|jb_ino
operator|||
name|blkrn
operator|->
name|jb_lbn
operator|!=
name|blkrec
operator|->
name|jb_lbn
operator|||
name|blkrn
operator|->
name|jb_blkno
operator|!=
name|blkrec
operator|->
name|jb_blkno
operator|||
name|blkrn
operator|->
name|jb_frags
operator|!=
name|blkrec
operator|->
name|jb_frags
operator|||
name|blkrn
operator|->
name|jb_oldfrags
operator|!=
name|blkrec
operator|->
name|jb_oldfrags
condition|)
continue|continue;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Removed dup.\n"
argument_list|)
expr_stmt|;
comment|/* Discard the free which is a dup with an alloc. */
if|if
condition|(
name|blkrec
operator|->
name|jb_op
operator|==
name|JOP_FREEBLK
condition|)
return|return;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sblk
operator|->
name|sb_recs
argument_list|,
name|srec
argument_list|,
name|sr_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|srec
argument_list|)
expr_stmt|;
break|break;
block|}
name|srec
operator|=
name|errmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|srec
argument_list|)
argument_list|)
expr_stmt|;
name|srec
operator|->
name|sr_rec
operator|=
operator|(
expr|union
name|jrec
operator|*
operator|)
name|blkrec
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sblk
operator|->
name|sb_recs
argument_list|,
name|srec
argument_list|,
name|sr_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ino_build_trunc
parameter_list|(
name|struct
name|jtrncrec
modifier|*
name|rec
parameter_list|)
block|{
name|struct
name|suj_ino
modifier|*
name|sino
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"ino_build_trunc: op %d ino %d, size %jd\n"
argument_list|,
name|rec
operator|->
name|jt_op
argument_list|,
name|rec
operator|->
name|jt_ino
argument_list|,
name|rec
operator|->
name|jt_size
argument_list|)
expr_stmt|;
name|sino
operator|=
name|ino_lookup
argument_list|(
name|rec
operator|->
name|jt_ino
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|jt_op
operator|==
name|JOP_SYNC
condition|)
block|{
name|sino
operator|->
name|si_trunc
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sino
operator|->
name|si_trunc
operator|==
name|NULL
operator|||
name|sino
operator|->
name|si_trunc
operator|->
name|jt_size
operator|>
name|rec
operator|->
name|jt_size
condition|)
name|sino
operator|->
name|si_trunc
operator|=
name|rec
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Build up tables of the operations we need to recover.  */
end_comment

begin_function
specifier|static
name|void
name|suj_build
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|suj_seg
modifier|*
name|seg
decl_stmt|;
name|union
name|jrec
modifier|*
name|rec
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|i
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|seg
argument_list|,
argument|&allsegs
argument_list|,
argument|ss_next
argument_list|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"seg %jd has %d records, oldseq %jd.\n"
argument_list|,
name|seg
operator|->
name|ss_rec
operator|.
name|jsr_seq
argument_list|,
name|seg
operator|->
name|ss_rec
operator|.
name|jsr_cnt
argument_list|,
name|seg
operator|->
name|ss_rec
operator|.
name|jsr_oldest
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|rec
operator|=
operator|(
expr|union
name|jrec
operator|*
operator|)
name|seg
operator|->
name|ss_blk
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seg
operator|->
name|ss_rec
operator|.
name|jsr_cnt
condition|;
name|off
operator|+=
name|JREC_SIZE
operator|,
name|rec
operator|++
control|)
block|{
comment|/* skip the segrec. */
if|if
condition|(
operator|(
name|off
operator|%
name|real_dev_bsize
operator|)
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|rec
operator|->
name|rec_jrefrec
operator|.
name|jr_op
condition|)
block|{
case|case
name|JOP_ADDREF
case|:
case|case
name|JOP_REMREF
case|:
case|case
name|JOP_MVREF
case|:
name|ino_append
argument_list|(
name|rec
argument_list|)
expr_stmt|;
break|break;
case|case
name|JOP_NEWBLK
case|:
case|case
name|JOP_FREEBLK
case|:
name|blk_build
argument_list|(
operator|(
expr|struct
name|jblkrec
operator|*
operator|)
name|rec
argument_list|)
expr_stmt|;
break|break;
case|case
name|JOP_TRUNC
case|:
case|case
name|JOP_SYNC
case|:
name|ino_build_trunc
argument_list|(
operator|(
expr|struct
name|jtrncrec
operator|*
operator|)
name|rec
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err_suj
argument_list|(
literal|"Unknown journal operation %d (%d)\n"
argument_list|,
name|rec
operator|->
name|rec_jrefrec
operator|.
name|jr_op
argument_list|,
name|off
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Prune the journal segments to those we care about based on the  * oldest sequence in the newest segment.  Order the segment list  * based on sequence number.  */
end_comment

begin_function
specifier|static
name|void
name|suj_prune
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|suj_seg
modifier|*
name|seg
decl_stmt|;
name|struct
name|suj_seg
modifier|*
name|segn
decl_stmt|;
name|uint64_t
name|newseq
decl_stmt|;
name|int
name|discard
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Pruning up to %jd\n"
argument_list|,
name|oldseq
argument_list|)
expr_stmt|;
comment|/* First free the expired segments. */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|seg
argument_list|,
argument|&allsegs
argument_list|,
argument|ss_next
argument_list|,
argument|segn
argument_list|)
block|{
if|if
condition|(
name|seg
operator|->
name|ss_rec
operator|.
name|jsr_seq
operator|>=
name|oldseq
condition|)
continue|continue;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|allsegs
argument_list|,
name|seg
argument_list|,
name|ss_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|seg
operator|->
name|ss_blk
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|seg
argument_list|)
expr_stmt|;
block|}
comment|/* Next ensure that segments are ordered properly. */
name|seg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|allsegs
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Empty journal\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|newseq
operator|=
name|seg
operator|->
name|ss_rec
operator|.
name|jsr_seq
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|seg
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|allsegs
argument_list|,
name|seghd
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|->
name|ss_rec
operator|.
name|jsr_seq
operator|>=
name|newseq
condition|)
break|break;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|allsegs
argument_list|,
name|seg
argument_list|,
name|ss_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|allsegs
argument_list|,
name|seg
argument_list|,
name|ss_next
argument_list|)
expr_stmt|;
name|newseq
operator|=
name|seg
operator|->
name|ss_rec
operator|.
name|jsr_seq
expr_stmt|;
block|}
if|if
condition|(
name|newseq
operator|!=
name|oldseq
condition|)
block|{
name|err_suj
argument_list|(
literal|"Journal file sequence mismatch %jd != %jd\n"
argument_list|,
name|newseq
argument_list|,
name|oldseq
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The kernel may asynchronously write segments which can create 	 * gaps in the sequence space.  Throw away any segments after the 	 * gap as the kernel guarantees only those that are contiguously 	 * reachable are marked as completed. 	 */
name|discard
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|seg
argument_list|,
argument|&allsegs
argument_list|,
argument|ss_next
argument_list|,
argument|segn
argument_list|)
block|{
if|if
condition|(
operator|!
name|discard
operator|&&
name|newseq
operator|++
operator|==
name|seg
operator|->
name|ss_rec
operator|.
name|jsr_seq
condition|)
block|{
name|jrecs
operator|+=
name|seg
operator|->
name|ss_rec
operator|.
name|jsr_cnt
expr_stmt|;
name|jbytes
operator|+=
name|seg
operator|->
name|ss_rec
operator|.
name|jsr_blocks
operator|*
name|real_dev_bsize
expr_stmt|;
continue|continue;
block|}
name|discard
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Journal order mismatch %jd != %jd pruning\n"
argument_list|,
name|newseq
operator|-
literal|1
argument_list|,
name|seg
operator|->
name|ss_rec
operator|.
name|jsr_seq
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|allsegs
argument_list|,
name|seg
argument_list|,
name|ss_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|seg
operator|->
name|ss_blk
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|seg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Processing journal segments from %jd to %jd\n"
argument_list|,
name|oldseq
argument_list|,
name|newseq
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify the journal inode before attempting to read records.  */
end_comment

begin_function
specifier|static
name|int
name|suj_verifyino
parameter_list|(
name|union
name|dinode
modifier|*
name|ip
parameter_list|)
block|{
if|if
condition|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_nlink
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid link count %d for journal inode %d\n"
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_nlink
argument_list|)
argument_list|,
name|sujino
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_flags
argument_list|)
operator|&
operator|(
name|SF_IMMUTABLE
operator||
name|SF_NOUNLINK
operator|)
operator|)
operator|!=
operator|(
name|SF_IMMUTABLE
operator||
name|SF_NOUNLINK
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid flags 0x%X for journal inode %d\n"
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_flags
argument_list|)
argument_list|,
name|sujino
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_mode
argument_list|)
operator|!=
operator|(
name|IFREG
operator||
name|IREAD
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid mode %o for journal inode %d\n"
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_mode
argument_list|)
argument_list|,
name|sujino
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_size
argument_list|)
operator|<
name|SUJ_MIN
operator|||
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_size
argument_list|)
operator|>
name|SUJ_MAX
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid size %jd for journal inode %d\n"
argument_list|,
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_size
argument_list|)
argument_list|,
name|sujino
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|DIP
argument_list|(
name|ip
argument_list|,
name|di_modrev
argument_list|)
operator|!=
name|fs
operator|->
name|fs_mtime
condition|)
block|{
name|printf
argument_list|(
literal|"Journal timestamp does not match fs mount time\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|jblocks
block|{
name|struct
name|jextent
modifier|*
name|jb_extent
decl_stmt|;
comment|/* Extent array. */
name|int
name|jb_avail
decl_stmt|;
comment|/* Available extents. */
name|int
name|jb_used
decl_stmt|;
comment|/* Last used extent. */
name|int
name|jb_head
decl_stmt|;
comment|/* Allocator head. */
name|int
name|jb_off
decl_stmt|;
comment|/* Allocator extent offset. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|jextent
block|{
name|ufs2_daddr_t
name|je_daddr
decl_stmt|;
comment|/* Disk block address. */
name|int
name|je_blocks
decl_stmt|;
comment|/* Disk block count. */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|jblocks
modifier|*
name|suj_jblocks
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|jblocks
modifier|*
name|jblocks_create
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|jblocks
modifier|*
name|jblocks
decl_stmt|;
name|int
name|size
decl_stmt|;
name|jblocks
operator|=
name|errmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|jblocks
argument_list|)
argument_list|)
expr_stmt|;
name|jblocks
operator|->
name|jb_avail
operator|=
literal|10
expr_stmt|;
name|jblocks
operator|->
name|jb_used
operator|=
literal|0
expr_stmt|;
name|jblocks
operator|->
name|jb_head
operator|=
literal|0
expr_stmt|;
name|jblocks
operator|->
name|jb_off
operator|=
literal|0
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|jextent
argument_list|)
operator|*
name|jblocks
operator|->
name|jb_avail
expr_stmt|;
name|jblocks
operator|->
name|jb_extent
operator|=
name|errmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|jblocks
operator|->
name|jb_extent
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|jblocks
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the next available disk block and the amount of contiguous  * free space it contains.  */
end_comment

begin_function
specifier|static
name|ufs2_daddr_t
name|jblocks_next
parameter_list|(
name|struct
name|jblocks
modifier|*
name|jblocks
parameter_list|,
name|int
name|bytes
parameter_list|,
name|int
modifier|*
name|actual
parameter_list|)
block|{
name|struct
name|jextent
modifier|*
name|jext
decl_stmt|;
name|ufs2_daddr_t
name|daddr
decl_stmt|;
name|int
name|freecnt
decl_stmt|;
name|int
name|blocks
decl_stmt|;
name|blocks
operator|=
name|bytes
operator|/
name|disk
operator|->
name|d_bsize
expr_stmt|;
name|jext
operator|=
operator|&
name|jblocks
operator|->
name|jb_extent
index|[
name|jblocks
operator|->
name|jb_head
index|]
expr_stmt|;
name|freecnt
operator|=
name|jext
operator|->
name|je_blocks
operator|-
name|jblocks
operator|->
name|jb_off
expr_stmt|;
if|if
condition|(
name|freecnt
operator|==
literal|0
condition|)
block|{
name|jblocks
operator|->
name|jb_off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|jblocks
operator|->
name|jb_head
operator|>
name|jblocks
operator|->
name|jb_used
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|jext
operator|=
operator|&
name|jblocks
operator|->
name|jb_extent
index|[
name|jblocks
operator|->
name|jb_head
index|]
expr_stmt|;
name|freecnt
operator|=
name|jext
operator|->
name|je_blocks
expr_stmt|;
block|}
if|if
condition|(
name|freecnt
operator|>
name|blocks
condition|)
name|freecnt
operator|=
name|blocks
expr_stmt|;
operator|*
name|actual
operator|=
name|freecnt
operator|*
name|disk
operator|->
name|d_bsize
expr_stmt|;
name|daddr
operator|=
name|jext
operator|->
name|je_daddr
operator|+
name|jblocks
operator|->
name|jb_off
expr_stmt|;
return|return
operator|(
name|daddr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Advance the allocation head by a specified number of bytes, consuming  * one journal segment.  */
end_comment

begin_function
specifier|static
name|void
name|jblocks_advance
parameter_list|(
name|struct
name|jblocks
modifier|*
name|jblocks
parameter_list|,
name|int
name|bytes
parameter_list|)
block|{
name|jblocks
operator|->
name|jb_off
operator|+=
name|bytes
operator|/
name|disk
operator|->
name|d_bsize
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jblocks_destroy
parameter_list|(
name|struct
name|jblocks
modifier|*
name|jblocks
parameter_list|)
block|{
name|free
argument_list|(
name|jblocks
operator|->
name|jb_extent
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|jblocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jblocks_add
parameter_list|(
name|struct
name|jblocks
modifier|*
name|jblocks
parameter_list|,
name|ufs2_daddr_t
name|daddr
parameter_list|,
name|int
name|blocks
parameter_list|)
block|{
name|struct
name|jextent
modifier|*
name|jext
decl_stmt|;
name|int
name|size
decl_stmt|;
name|jext
operator|=
operator|&
name|jblocks
operator|->
name|jb_extent
index|[
name|jblocks
operator|->
name|jb_used
index|]
expr_stmt|;
comment|/* Adding the first block. */
if|if
condition|(
name|jext
operator|->
name|je_daddr
operator|==
literal|0
condition|)
block|{
name|jext
operator|->
name|je_daddr
operator|=
name|daddr
expr_stmt|;
name|jext
operator|->
name|je_blocks
operator|=
name|blocks
expr_stmt|;
return|return;
block|}
comment|/* Extending the last extent. */
if|if
condition|(
name|jext
operator|->
name|je_daddr
operator|+
name|jext
operator|->
name|je_blocks
operator|==
name|daddr
condition|)
block|{
name|jext
operator|->
name|je_blocks
operator|+=
name|blocks
expr_stmt|;
return|return;
block|}
comment|/* Adding a new extent. */
if|if
condition|(
operator|++
name|jblocks
operator|->
name|jb_used
operator|==
name|jblocks
operator|->
name|jb_avail
condition|)
block|{
name|jblocks
operator|->
name|jb_avail
operator|*=
literal|2
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|jextent
argument_list|)
operator|*
name|jblocks
operator|->
name|jb_avail
expr_stmt|;
name|jext
operator|=
name|errmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|jext
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|jblocks
operator|->
name|jb_extent
argument_list|,
name|jext
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|jextent
argument_list|)
operator|*
name|jblocks
operator|->
name|jb_used
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|jblocks
operator|->
name|jb_extent
argument_list|)
expr_stmt|;
name|jblocks
operator|->
name|jb_extent
operator|=
name|jext
expr_stmt|;
block|}
name|jext
operator|=
operator|&
name|jblocks
operator|->
name|jb_extent
index|[
name|jblocks
operator|->
name|jb_used
index|]
expr_stmt|;
name|jext
operator|->
name|je_daddr
operator|=
name|daddr
expr_stmt|;
name|jext
operator|->
name|je_blocks
operator|=
name|blocks
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Add a file block from the journal to the extent map.  We can't read  * each file block individually because the kernel treats it as a circular  * buffer and segments may span mutliple contiguous blocks.  */
end_comment

begin_function
specifier|static
name|void
name|suj_add_block
parameter_list|(
name|ino_t
name|ino
parameter_list|,
name|ufs_lbn_t
name|lbn
parameter_list|,
name|ufs2_daddr_t
name|blk
parameter_list|,
name|int
name|frags
parameter_list|)
block|{
name|jblocks_add
argument_list|(
name|suj_jblocks
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|)
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|frags
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|suj_read
parameter_list|(
name|void
parameter_list|)
block|{
name|uint8_t
name|block
index|[
literal|1
operator|*
literal|1024
operator|*
literal|1024
index|]
decl_stmt|;
name|struct
name|suj_seg
modifier|*
name|seg
decl_stmt|;
name|struct
name|jsegrec
modifier|*
name|recn
decl_stmt|;
name|struct
name|jsegrec
modifier|*
name|rec
decl_stmt|;
name|ufs2_daddr_t
name|blk
decl_stmt|;
name|int
name|readsize
decl_stmt|;
name|int
name|blocks
decl_stmt|;
name|int
name|recsize
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Read records until we exhaust the journal space.  If we find 	 * an invalid record we start searching for a valid segment header 	 * at the next block.  This is because we don't have a head/tail 	 * pointer and must recover the information indirectly.  At the gap 	 * between the head and tail we won't necessarily have a valid 	 * segment. 	 */
name|restart
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|blk
operator|=
name|jblocks_next
argument_list|(
name|suj_jblocks
argument_list|,
name|size
argument_list|,
operator|&
name|readsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|==
literal|0
condition|)
return|return;
name|size
operator|=
name|readsize
expr_stmt|;
comment|/* 		 * Read 1MB at a time and scan for records within this block. 		 */
if|if
condition|(
name|bread
argument_list|(
name|disk
argument_list|,
name|blk
argument_list|,
operator|&
name|block
argument_list|,
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|err_suj
argument_list|(
literal|"Error reading journal block %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|blk
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|rec
operator|=
operator|(
name|void
operator|*
operator|)
name|block
init|;
name|size
condition|;
name|size
operator|-=
name|recsize
operator|,
name|rec
operator|=
operator|(
expr|struct
name|jsegrec
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|rec
operator|+
name|recsize
operator|)
control|)
block|{
name|recsize
operator|=
name|real_dev_bsize
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|jsr_time
operator|!=
name|fs
operator|->
name|fs_mtime
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Rec time %jd != fs mtime %jd\n"
argument_list|,
name|rec
operator|->
name|jsr_time
argument_list|,
name|fs
operator|->
name|fs_mtime
argument_list|)
expr_stmt|;
name|jblocks_advance
argument_list|(
name|suj_jblocks
argument_list|,
name|recsize
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rec
operator|->
name|jsr_cnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Found illegal count %d\n"
argument_list|,
name|rec
operator|->
name|jsr_cnt
argument_list|)
expr_stmt|;
name|jblocks_advance
argument_list|(
name|suj_jblocks
argument_list|,
name|recsize
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|blocks
operator|=
name|rec
operator|->
name|jsr_blocks
expr_stmt|;
name|recsize
operator|=
name|blocks
operator|*
name|real_dev_bsize
expr_stmt|;
if|if
condition|(
name|recsize
operator|>
name|size
condition|)
block|{
comment|/* 				 * We may just have run out of buffer, restart 				 * the loop to re-read from this spot. 				 */
if|if
condition|(
name|size
operator|<
name|fs
operator|->
name|fs_bsize
operator|&&
name|size
operator|!=
name|readsize
operator|&&
name|recsize
operator|<=
name|fs
operator|->
name|fs_bsize
condition|)
goto|goto
name|restart
goto|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Found invalid segsize %d> %d\n"
argument_list|,
name|recsize
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|recsize
operator|=
name|real_dev_bsize
expr_stmt|;
name|jblocks_advance
argument_list|(
name|suj_jblocks
argument_list|,
name|recsize
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Verify that all blocks in the segment are present. 			 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|blocks
condition|;
name|i
operator|++
control|)
block|{
name|recn
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|rec
operator|)
operator|+
name|i
operator|*
name|real_dev_bsize
expr_stmt|;
if|if
condition|(
name|recn
operator|->
name|jsr_seq
operator|==
name|rec
operator|->
name|jsr_seq
operator|&&
name|recn
operator|->
name|jsr_time
operator|==
name|rec
operator|->
name|jsr_time
condition|)
continue|continue;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Incomplete record %jd (%d)\n"
argument_list|,
name|rec
operator|->
name|jsr_seq
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|recsize
operator|=
name|i
operator|*
name|real_dev_bsize
expr_stmt|;
name|jblocks_advance
argument_list|(
name|suj_jblocks
argument_list|,
name|recsize
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|seg
operator|=
name|errmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|seg
argument_list|)
argument_list|)
expr_stmt|;
name|seg
operator|->
name|ss_blk
operator|=
name|errmalloc
argument_list|(
name|recsize
argument_list|)
expr_stmt|;
name|seg
operator|->
name|ss_rec
operator|=
operator|*
name|rec
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rec
argument_list|,
name|seg
operator|->
name|ss_blk
argument_list|,
name|recsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|jsr_oldest
operator|>
name|oldseq
condition|)
name|oldseq
operator|=
name|rec
operator|->
name|jsr_oldest
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|allsegs
argument_list|,
name|seg
argument_list|,
name|ss_next
argument_list|)
expr_stmt|;
name|jblocks_advance
argument_list|(
name|suj_jblocks
argument_list|,
name|recsize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Search a directory block for the SUJ_FILE.  */
end_comment

begin_function
specifier|static
name|void
name|suj_find
parameter_list|(
name|ino_t
name|ino
parameter_list|,
name|ufs_lbn_t
name|lbn
parameter_list|,
name|ufs2_daddr_t
name|blk
parameter_list|,
name|int
name|frags
parameter_list|)
block|{
name|char
name|block
index|[
name|MAXBSIZE
index|]
decl_stmt|;
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|int
name|off
decl_stmt|;
if|if
condition|(
name|sujino
condition|)
return|return;
name|bytes
operator|=
name|lfragtosize
argument_list|(
name|fs
argument_list|,
name|frags
argument_list|)
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
name|disk
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|)
argument_list|,
name|block
argument_list|,
name|bytes
argument_list|)
operator|<=
literal|0
condition|)
name|err_suj
argument_list|(
literal|"Failed to read ROOTINO directory block %jd\n"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|bytes
condition|;
name|off
operator|+=
name|dp
operator|->
name|d_reclen
control|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|&
name|block
index|[
name|off
index|]
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_reclen
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_namlen
operator|!=
name|strlen
argument_list|(
name|SUJ_FILE
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|bcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|SUJ_FILE
argument_list|,
name|dp
operator|->
name|d_namlen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|sujino
operator|=
name|dp
operator|->
name|d_ino
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Orchestrate the verification of a filesystem via the softupdates journal.  */
end_comment

begin_function
name|int
name|suj_check
parameter_list|(
specifier|const
name|char
modifier|*
name|filesys
parameter_list|)
block|{
name|union
name|dinode
modifier|*
name|jip
decl_stmt|;
name|union
name|dinode
modifier|*
name|ip
decl_stmt|;
name|uint64_t
name|blocks
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|struct
name|suj_seg
modifier|*
name|seg
decl_stmt|;
name|struct
name|suj_seg
modifier|*
name|segn
decl_stmt|;
name|opendisk
argument_list|(
name|filesys
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|allsegs
argument_list|)
expr_stmt|;
comment|/* 	 * Set an exit point when SUJ check failed 	 */
name|retval
operator|=
name|setjmp
argument_list|(
name|jmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|pwarn
argument_list|(
literal|"UNEXPECTED SU+J INCONSISTENCY\n"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|seg
argument_list|,
argument|&allsegs
argument_list|,
argument|ss_next
argument_list|,
argument|segn
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|allsegs
argument_list|,
name|seg
argument_list|,
name|ss_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|seg
operator|->
name|ss_blk
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|seg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reply
argument_list|(
literal|"FALLBACK TO FULL FSCK"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ckfini
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EEXIT
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Find the journal inode. 	 */
name|ip
operator|=
name|ino_read
argument_list|(
name|ROOTINO
argument_list|)
expr_stmt|;
name|sujino
operator|=
literal|0
expr_stmt|;
name|ino_visit
argument_list|(
name|ip
argument_list|,
name|ROOTINO
argument_list|,
name|suj_find
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sujino
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Journal inode removed.  Use tunefs to re-create.\n"
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_flags
operator|&=
operator|~
name|FS_SUJ
expr_stmt|;
name|sblock
operator|.
name|fs_sujfree
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Fetch the journal inode and verify it. 	 */
name|jip
operator|=
name|ino_read
argument_list|(
name|sujino
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"** SU+J Recovering %s\n"
argument_list|,
name|filesys
argument_list|)
expr_stmt|;
if|if
condition|(
name|suj_verifyino
argument_list|(
name|jip
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Build a list of journal blocks in jblocks before parsing the 	 * available journal blocks in with suj_read(). 	 */
name|printf
argument_list|(
literal|"** Reading %jd byte journal from inode %d.\n"
argument_list|,
name|DIP
argument_list|(
name|jip
argument_list|,
name|di_size
argument_list|)
argument_list|,
name|sujino
argument_list|)
expr_stmt|;
name|suj_jblocks
operator|=
name|jblocks_create
argument_list|()
expr_stmt|;
name|blocks
operator|=
name|ino_visit
argument_list|(
name|jip
argument_list|,
name|sujino
argument_list|,
name|suj_add_block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocks
operator|!=
name|numfrags
argument_list|(
name|fs
argument_list|,
name|DIP
argument_list|(
name|jip
argument_list|,
name|di_size
argument_list|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Sparse journal inode %d.\n"
argument_list|,
name|sujino
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|suj_read
argument_list|()
expr_stmt|;
name|jblocks_destroy
argument_list|(
name|suj_jblocks
argument_list|)
expr_stmt|;
name|suj_jblocks
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|preen
operator|||
name|reply
argument_list|(
literal|"RECOVER"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"** Building recovery table.\n"
argument_list|)
expr_stmt|;
name|suj_prune
argument_list|()
expr_stmt|;
name|suj_build
argument_list|()
expr_stmt|;
name|cg_apply
argument_list|(
name|cg_build
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"** Resolving unreferenced inode list.\n"
argument_list|)
expr_stmt|;
name|ino_unlinked
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"** Processing journal entries.\n"
argument_list|)
expr_stmt|;
name|cg_apply
argument_list|(
name|cg_trunc
argument_list|)
expr_stmt|;
name|cg_apply
argument_list|(
name|cg_check_blk
argument_list|)
expr_stmt|;
name|cg_apply
argument_list|(
name|cg_check_ino
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preen
operator|==
literal|0
operator|&&
operator|(
name|jrecs
operator|>
literal|0
operator|||
name|jbytes
operator|>
literal|0
operator|)
operator|&&
name|reply
argument_list|(
literal|"WRITE CHANGES"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * To remain idempotent with partial truncations the free bitmaps 	 * must be written followed by indirect blocks and lastly inode 	 * blocks.  This preserves access to the modified pointers until 	 * they are freed. 	 */
name|cg_apply
argument_list|(
name|cg_write
argument_list|)
expr_stmt|;
name|dblk_write
argument_list|()
expr_stmt|;
name|cg_apply
argument_list|(
name|cg_write_inos
argument_list|)
expr_stmt|;
comment|/* Write back superblock. */
name|closedisk
argument_list|(
name|filesys
argument_list|)
expr_stmt|;
if|if
condition|(
name|jrecs
operator|>
literal|0
operator|||
name|jbytes
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"** %jd journal records in %jd bytes for %.2f%% utilization\n"
argument_list|,
name|jrecs
argument_list|,
name|jbytes
argument_list|,
operator|(
operator|(
name|float
operator|)
name|jrecs
operator|/
call|(
name|float
call|)
argument_list|(
name|jbytes
operator|/
name|JREC_SIZE
argument_list|)
operator|)
operator|*
literal|100
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"** Freed %jd inodes (%jd dirs) %jd blocks, and %jd frags.\n"
argument_list|,
name|freeinos
argument_list|,
name|freedir
argument_list|,
name|freeblocks
argument_list|,
name|freefrags
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

