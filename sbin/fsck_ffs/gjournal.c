begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Pawel Jakub Dawidek<pjd@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Copyright (c) 1982, 1986, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<libufs.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"fsck.h"
end_include

begin_struct
struct|struct
name|cgchain
block|{
union|union
block|{
name|struct
name|cg
name|cgcu_cg
decl_stmt|;
name|char
name|cgcu_buf
index|[
name|MAXBSIZE
index|]
decl_stmt|;
block|}
name|cgc_union
union|;
name|int
name|cgc_busy
decl_stmt|;
name|int
name|cgc_dirty
decl_stmt|;
name|LIST_ENTRY
argument_list|(
argument|cgchain
argument_list|)
name|cgc_next
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|cgc_cg
value|cgc_union.cgcu_cg
end_define

begin_define
define|#
directive|define
name|MAX_CACHED_CGS
value|1024
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|ncgs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|cgchain
argument_list|)
name|cglist
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|cglist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|devnam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uufsd
modifier|*
name|disk
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fs
modifier|*
name|fs
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ufs2_dinode
name|ufs2_zino
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|putcgs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Return cylinder group from the cache or load it if it is not in the  * cache yet.  * Don't cache more than MAX_CACHED_CGS cylinder groups.  */
end_comment

begin_function
specifier|static
name|struct
name|cgchain
modifier|*
name|getcg
parameter_list|(
name|int
name|cg
parameter_list|)
block|{
name|struct
name|cgchain
modifier|*
name|cgc
decl_stmt|;
name|assert
argument_list|(
name|disk
operator|!=
name|NULL
operator|&&
name|fs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|cgc
argument_list|,
argument|&cglist
argument_list|,
argument|cgc_next
argument_list|)
block|{
if|if
condition|(
name|cgc
operator|->
name|cgc_cg
operator|.
name|cg_cgx
operator|==
name|cg
condition|)
block|{
comment|//printf("%s: Found cg=%d\n", __func__, cg);
return|return
operator|(
name|cgc
operator|)
return|;
block|}
block|}
comment|/* 	 * Our cache is full? Let's clean it up. 	 */
if|if
condition|(
name|ncgs
operator|>=
name|MAX_CACHED_CGS
condition|)
block|{
comment|//printf("%s: Flushing CGs.\n", __func__);
name|putcgs
argument_list|()
expr_stmt|;
block|}
name|cgc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cgc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgc
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Cannot allocate memory? 		 * Let's put all currently loaded and not busy cylinder groups 		 * on disk and try again. 		 */
comment|//printf("%s: No memory, flushing CGs.\n", __func__);
name|putcgs
argument_list|()
expr_stmt|;
name|cgc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cgc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgc
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc(%zu)"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cgc
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cgread1
argument_list|(
name|disk
argument_list|,
name|cg
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cgread1(%d)"
argument_list|,
name|cg
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|disk
operator|->
name|d_cg
argument_list|,
operator|&
name|cgc
operator|->
name|cgc_cg
argument_list|,
sizeof|sizeof
argument_list|(
name|cgc
operator|->
name|cgc_union
argument_list|)
argument_list|)
expr_stmt|;
name|cgc
operator|->
name|cgc_busy
operator|=
literal|0
expr_stmt|;
name|cgc
operator|->
name|cgc_dirty
operator|=
literal|0
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|cglist
argument_list|,
name|cgc
argument_list|,
name|cgc_next
argument_list|)
expr_stmt|;
name|ncgs
operator|++
expr_stmt|;
comment|//printf("%s: Read cg=%d\n", __func__, cg);
return|return
operator|(
name|cgc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark cylinder group as dirty - it will be written back on putcgs().  */
end_comment

begin_function
specifier|static
name|void
name|dirtycg
parameter_list|(
name|struct
name|cgchain
modifier|*
name|cgc
parameter_list|)
block|{
name|cgc
operator|->
name|cgc_dirty
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark cylinder group as busy - it will not be freed on putcgs().  */
end_comment

begin_function
specifier|static
name|void
name|busycg
parameter_list|(
name|struct
name|cgchain
modifier|*
name|cgc
parameter_list|)
block|{
name|cgc
operator|->
name|cgc_busy
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unmark the given cylinder group as busy.  */
end_comment

begin_function
specifier|static
name|void
name|unbusycg
parameter_list|(
name|struct
name|cgchain
modifier|*
name|cgc
parameter_list|)
block|{
name|cgc
operator|->
name|cgc_busy
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write back all dirty cylinder groups.  * Free all non-busy cylinder groups.  */
end_comment

begin_function
specifier|static
name|void
name|putcgs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgchain
modifier|*
name|cgc
decl_stmt|,
modifier|*
name|cgc2
decl_stmt|;
name|assert
argument_list|(
name|disk
operator|!=
name|NULL
operator|&&
name|fs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|cgc
argument_list|,
argument|&cglist
argument_list|,
argument|cgc_next
argument_list|,
argument|cgc2
argument_list|)
block|{
if|if
condition|(
name|cgc
operator|->
name|cgc_busy
condition|)
continue|continue;
name|LIST_REMOVE
argument_list|(
name|cgc
argument_list|,
name|cgc_next
argument_list|)
expr_stmt|;
name|ncgs
operator|--
expr_stmt|;
if|if
condition|(
name|cgc
operator|->
name|cgc_dirty
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|cgc
operator|->
name|cgc_cg
argument_list|,
operator|&
name|disk
operator|->
name|d_cg
argument_list|,
sizeof|sizeof
argument_list|(
name|cgc
operator|->
name|cgc_union
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgwrite1
argument_list|(
name|disk
argument_list|,
name|cgc
operator|->
name|cgc_cg
operator|.
name|cg_cgx
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cgwrite1(%d)"
argument_list|,
name|cgc
operator|->
name|cgc_cg
operator|.
name|cg_cgx
argument_list|)
expr_stmt|;
comment|//printf("%s: Wrote cg=%d\n", __func__,
comment|//    cgc->cgc_cg.cg_cgx);
block|}
name|free
argument_list|(
name|cgc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Free all non-busy cylinder groups without storing the dirty ones.  */
end_comment

begin_comment
unit|static void cancelcgs(void) { 	struct cgchain *cgc;  	assert(disk != NULL&& fs != NULL); 	while ((cgc = LIST_FIRST(&cglist)) != NULL) { 		if (cgc->cgc_busy) 			continue; 		LIST_REMOVE(cgc, cgc_next);
comment|//printf("%s: Canceled cg=%d\n", __func__, cgc->cgc_cg.cg_cgx);
end_comment

begin_endif
unit|free(cgc); 	} }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Open the given provider, load superblock.  */
end_comment

begin_function
specifier|static
name|void
name|opendisk
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|disk
operator|!=
name|NULL
condition|)
return|return;
name|disk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|disk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc(%zu)"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|disk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ufs_disk_fillout
argument_list|(
name|disk
argument_list|,
name|devnam
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"ufs_disk_fillout(%s) failed: %s"
argument_list|,
name|devnam
argument_list|,
name|disk
operator|->
name|d_error
argument_list|)
expr_stmt|;
block|}
name|fs
operator|=
operator|&
name|disk
operator|->
name|d_fs
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark file system as clean, write the super-block back, close the disk.  */
end_comment

begin_function
specifier|static
name|void
name|closedisk
parameter_list|(
name|void
parameter_list|)
block|{
name|fs
operator|->
name|fs_clean
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sbwrite
argument_list|(
name|disk
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"sbwrite(%s)"
argument_list|,
name|devnam
argument_list|)
expr_stmt|;
if|if
condition|(
name|ufs_disk_close
argument_list|(
name|disk
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ufs_disk_close(%s)"
argument_list|,
name|devnam
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|disk
operator|=
name|NULL
expr_stmt|;
name|fs
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|blkfree
parameter_list|(
name|ufs2_daddr_t
name|bno
parameter_list|,
name|long
name|size
parameter_list|)
block|{
name|struct
name|cgchain
modifier|*
name|cgc
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|ufs1_daddr_t
name|fragno
decl_stmt|,
name|cgbno
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cg
decl_stmt|,
name|blk
decl_stmt|,
name|frags
decl_stmt|,
name|bbase
decl_stmt|;
name|u_int8_t
modifier|*
name|blksfree
decl_stmt|;
name|cg
operator|=
name|dtog
argument_list|(
name|fs
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|cgc
operator|=
name|getcg
argument_list|(
name|cg
argument_list|)
expr_stmt|;
name|dirtycg
argument_list|(
name|cgc
argument_list|)
expr_stmt|;
name|cgp
operator|=
operator|&
name|cgc
operator|->
name|cgc_cg
expr_stmt|;
name|cgbno
operator|=
name|dtogd
argument_list|(
name|fs
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|blksfree
operator|=
name|cg_blksfree
argument_list|(
name|cgp
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|fs
operator|->
name|fs_bsize
condition|)
block|{
name|fragno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|cgbno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffs_isfreeblock
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
name|fragno
argument_list|)
condition|)
name|assert
argument_list|(
operator|!
literal|"blkfree: freeing free block"
argument_list|)
expr_stmt|;
name|ffs_setblock
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
name|fragno
argument_list|)
expr_stmt|;
name|ffs_clusteracct
argument_list|(
name|fs
argument_list|,
name|cgp
argument_list|,
name|fragno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|fs
operator|->
name|fs_cs
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
block|}
else|else
block|{
name|bbase
operator|=
name|cgbno
operator|-
name|fragnum
argument_list|(
name|fs
argument_list|,
name|cgbno
argument_list|)
expr_stmt|;
comment|/* 		 * decrement the counts associated with the old frags 		 */
name|blk
operator|=
name|blkmap
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
name|bbase
argument_list|)
expr_stmt|;
name|ffs_fragacct
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|,
name|cgp
operator|->
name|cg_frsum
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * deallocate the fragment 		 */
name|frags
operator|=
name|numfrags
argument_list|(
name|fs
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|frags
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isset
argument_list|(
name|blksfree
argument_list|,
name|cgbno
operator|+
name|i
argument_list|)
condition|)
name|assert
argument_list|(
operator|!
literal|"blkfree: freeing free frag"
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|blksfree
argument_list|,
name|cgbno
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nffree
operator|+=
name|i
expr_stmt|;
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nffree
operator|+=
name|i
expr_stmt|;
name|fs
operator|->
name|fs_cs
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
operator|.
name|cs_nffree
operator|+=
name|i
expr_stmt|;
comment|/* 		 * add back in counts associated with the new frags 		 */
name|blk
operator|=
name|blkmap
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
name|bbase
argument_list|)
expr_stmt|;
name|ffs_fragacct
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|,
name|cgp
operator|->
name|cg_frsum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * if a complete block has been reassembled, account for it 		 */
name|fragno
operator|=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|bbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffs_isblock
argument_list|(
name|fs
argument_list|,
name|blksfree
argument_list|,
name|fragno
argument_list|)
condition|)
block|{
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nffree
operator|-=
name|fs
operator|->
name|fs_frag
expr_stmt|;
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nffree
operator|-=
name|fs
operator|->
name|fs_frag
expr_stmt|;
name|fs
operator|->
name|fs_cs
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
operator|.
name|cs_nffree
operator|-=
name|fs
operator|->
name|fs_frag
expr_stmt|;
name|ffs_clusteracct
argument_list|(
name|fs
argument_list|,
name|cgp
argument_list|,
name|fragno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|fs
operator|->
name|fs_cs
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Recursively free all indirect blocks.  */
end_comment

begin_function
specifier|static
name|void
name|freeindir
parameter_list|(
name|ufs2_daddr_t
name|blk
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|char
name|sblks
index|[
name|MAXBSIZE
index|]
decl_stmt|;
name|ufs2_daddr_t
modifier|*
name|blks
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bread
argument_list|(
name|disk
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sblks
argument_list|,
operator|(
name|size_t
operator|)
name|fs
operator|->
name|fs_bsize
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"bread: %s"
argument_list|,
name|disk
operator|->
name|d_error
argument_list|)
expr_stmt|;
name|blks
operator|=
operator|(
name|ufs2_daddr_t
operator|*
operator|)
operator|&
name|sblks
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NINDIR
argument_list|(
name|fs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|blks
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|blkfree
argument_list|(
name|blks
index|[
name|i
index|]
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
else|else
name|freeindir
argument_list|(
name|blks
index|[
name|i
index|]
argument_list|,
name|level
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|blkfree
argument_list|(
name|blk
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|dblksize
parameter_list|(
name|fs
parameter_list|,
name|dino
parameter_list|,
name|lbn
parameter_list|)
define|\
value|((dino)->di_size>= smalllblktosize(fs, (lbn) + 1) \ 	    ? (fs)->fs_bsize \ 	    : fragroundup(fs, blkoff(fs, (dino)->di_size)))
end_define

begin_comment
comment|/*  * Free all blocks associated with the given inode.  */
end_comment

begin_function
specifier|static
name|void
name|clear_inode
parameter_list|(
name|struct
name|ufs2_dinode
modifier|*
name|dino
parameter_list|)
block|{
name|ufs2_daddr_t
name|bn
decl_stmt|;
name|int
name|extblocks
decl_stmt|,
name|i
decl_stmt|,
name|level
decl_stmt|;
name|off_t
name|osize
decl_stmt|;
name|long
name|bsize
decl_stmt|;
name|extblocks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_magic
operator|==
name|FS_UFS2_MAGIC
operator|&&
name|dino
operator|->
name|di_extsize
operator|>
literal|0
condition|)
name|extblocks
operator|=
name|btodb
argument_list|(
name|fragroundup
argument_list|(
name|fs
argument_list|,
name|dino
operator|->
name|di_extsize
argument_list|)
argument_list|)
expr_stmt|;
comment|/* deallocate external attributes blocks */
if|if
condition|(
name|extblocks
operator|>
literal|0
condition|)
block|{
name|osize
operator|=
name|dino
operator|->
name|di_extsize
expr_stmt|;
name|dino
operator|->
name|di_blocks
operator|-=
name|extblocks
expr_stmt|;
name|dino
operator|->
name|di_extsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NXADDR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dino
operator|->
name|di_extb
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|blkfree
argument_list|(
name|dino
operator|->
name|di_extb
index|[
name|i
index|]
argument_list|,
name|sblksize
argument_list|(
name|fs
argument_list|,
name|osize
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
define|#
directive|define
name|SINGLE
value|0
comment|/* index of single indirect block */
define|#
directive|define
name|DOUBLE
value|1
comment|/* index of double indirect block */
define|#
directive|define
name|TRIPLE
value|2
comment|/* index of triple indirect block */
comment|/* deallocate indirect blocks */
for|for
control|(
name|level
operator|=
name|SINGLE
init|;
name|level
operator|<=
name|TRIPLE
condition|;
name|level
operator|++
control|)
block|{
if|if
condition|(
name|dino
operator|->
name|di_ib
index|[
name|level
index|]
operator|==
literal|0
condition|)
break|break;
name|freeindir
argument_list|(
name|dino
operator|->
name|di_ib
index|[
name|level
index|]
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
comment|/* deallocate direct blocks and fragments */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDADDR
condition|;
name|i
operator|++
control|)
block|{
name|bn
operator|=
name|dino
operator|->
name|di_db
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bn
operator|==
literal|0
condition|)
continue|continue;
name|bsize
operator|=
name|dblksize
argument_list|(
name|fs
argument_list|,
name|dino
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|blkfree
argument_list|(
name|bn
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|gjournal_check
parameter_list|(
specifier|const
name|char
modifier|*
name|filesys
parameter_list|)
block|{
name|struct
name|ufs2_dinode
modifier|*
name|dino
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|struct
name|cgchain
modifier|*
name|cgc
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|uint8_t
modifier|*
name|inosused
decl_stmt|,
modifier|*
name|blksfree
decl_stmt|;
name|ino_t
name|cino
decl_stmt|,
name|ino
decl_stmt|;
name|int
name|cg
decl_stmt|,
name|mode
decl_stmt|;
name|devnam
operator|=
name|filesys
expr_stmt|;
name|opendisk
argument_list|()
expr_stmt|;
comment|/* Are there any unreferenced inodes in this file system? */
if|if
condition|(
name|fs
operator|->
name|fs_unrefs
operator|==
literal|0
condition|)
block|{
comment|//printf("No unreferenced inodes.\n");
name|closedisk
argument_list|()
expr_stmt|;
return|return;
block|}
for|for
control|(
name|cg
operator|=
literal|0
init|;
name|cg
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|cg
operator|++
control|)
block|{
comment|/* Show progress if requested. */
if|if
condition|(
name|got_siginfo
condition|)
block|{
name|printf
argument_list|(
literal|"%s: phase j: cyl group %d of %d (%d%%)\n"
argument_list|,
name|cdevname
argument_list|,
name|cg
argument_list|,
name|fs
operator|->
name|fs_ncg
argument_list|,
name|cg
operator|*
literal|100
operator|/
name|fs
operator|->
name|fs_ncg
argument_list|)
expr_stmt|;
name|got_siginfo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|got_sigalarm
condition|)
block|{
name|setproctitle
argument_list|(
literal|"%s pj %d%%"
argument_list|,
name|cdevname
argument_list|,
name|cg
operator|*
literal|100
operator|/
name|fs
operator|->
name|fs_ncg
argument_list|)
expr_stmt|;
name|got_sigalarm
operator|=
literal|0
expr_stmt|;
block|}
name|cgc
operator|=
name|getcg
argument_list|(
name|cg
argument_list|)
expr_stmt|;
name|cgp
operator|=
operator|&
name|cgc
operator|->
name|cgc_cg
expr_stmt|;
comment|/* Are there any unreferenced inodes in this cylinder group? */
if|if
condition|(
name|cgp
operator|->
name|cg_unrefs
operator|==
literal|0
condition|)
continue|continue;
comment|//printf("Analizing cylinder group %d (count=%d)\n", cg, cgp->cg_unrefs);
comment|/* 		 * We are going to modify this cylinder group, so we want it to 		 * be written back. 		 */
name|dirtycg
argument_list|(
name|cgc
argument_list|)
expr_stmt|;
comment|/* We don't want it to be freed in the meantime. */
name|busycg
argument_list|(
name|cgc
argument_list|)
expr_stmt|;
name|inosused
operator|=
name|cg_inosused
argument_list|(
name|cgp
argument_list|)
expr_stmt|;
name|blksfree
operator|=
name|cg_blksfree
argument_list|(
name|cgp
argument_list|)
expr_stmt|;
comment|/* 		 * Now go through the list of all inodes in this cylinder group 		 * to find unreferenced ones. 		 */
for|for
control|(
name|cino
operator|=
literal|0
init|;
name|cino
operator|<
name|fs
operator|->
name|fs_ipg
condition|;
name|cino
operator|++
control|)
block|{
name|ino
operator|=
name|fs
operator|->
name|fs_ipg
operator|*
name|cg
operator|+
name|cino
expr_stmt|;
comment|/* Unallocated? Skip it. */
if|if
condition|(
name|isclr
argument_list|(
name|inosused
argument_list|,
name|cino
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|getino
argument_list|(
name|disk
argument_list|,
operator|&
name|p
argument_list|,
name|ino
argument_list|,
operator|&
name|mode
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"getino(cg=%d ino=%d)"
argument_list|,
name|cg
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|dino
operator|=
name|p
expr_stmt|;
comment|/* Not a regular file nor directory? Skip it. */
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|dino
operator|->
name|di_mode
argument_list|)
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|dino
operator|->
name|di_mode
argument_list|)
condition|)
continue|continue;
comment|/* Has reference(s)? Skip it. */
if|if
condition|(
name|dino
operator|->
name|di_nlink
operator|>
literal|0
condition|)
continue|continue;
comment|//printf("Clearing inode=%d (size=%jd)\n", ino, (intmax_t)dino->di_size);
comment|/* Free inode's blocks. */
name|clear_inode
argument_list|(
name|dino
argument_list|)
expr_stmt|;
comment|/* Deallocate it. */
name|clrbit
argument_list|(
name|inosused
argument_list|,
name|cino
argument_list|)
expr_stmt|;
comment|/* Update position of last used inode. */
if|if
condition|(
name|ino
operator|<
name|cgp
operator|->
name|cg_irotor
condition|)
name|cgp
operator|->
name|cg_irotor
operator|=
name|ino
expr_stmt|;
comment|/* Update statistics. */
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nifree
operator|++
expr_stmt|;
name|fs
operator|->
name|fs_cs
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
operator|.
name|cs_nifree
operator|++
expr_stmt|;
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nifree
operator|++
expr_stmt|;
name|cgp
operator|->
name|cg_unrefs
operator|--
expr_stmt|;
name|fs
operator|->
name|fs_unrefs
operator|--
expr_stmt|;
comment|/* If this is directory, update related statistics. */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|dino
operator|->
name|di_mode
argument_list|)
condition|)
block|{
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_ndir
operator|--
expr_stmt|;
name|fs
operator|->
name|fs_cs
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
operator|.
name|cs_ndir
operator|--
expr_stmt|;
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_ndir
operator|--
expr_stmt|;
block|}
comment|/* Zero-fill the inode. */
operator|*
name|dino
operator|=
name|ufs2_zino
expr_stmt|;
comment|/* Write the inode back. */
if|if
condition|(
name|putino
argument_list|(
name|disk
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"putino(cg=%d ino=%d)"
argument_list|,
name|cg
argument_list|,
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgp
operator|->
name|cg_unrefs
operator|==
literal|0
condition|)
block|{
comment|//printf("No more unreferenced inodes in cg=%d.\n", cg);
break|break;
block|}
block|}
comment|/* 		 * We don't need this cylinder group anymore, so feel free to 		 * free it if needed. 		 */
name|unbusycg
argument_list|(
name|cgc
argument_list|)
expr_stmt|;
comment|/* 		 * If there are no more unreferenced inodes, there is no need to 		 * check other cylinder groups. 		 */
if|if
condition|(
name|fs
operator|->
name|fs_unrefs
operator|==
literal|0
condition|)
block|{
comment|//printf("No more unreferenced inodes (cg=%d/%d).\n", cg,
comment|//    fs->fs_ncg);
break|break;
block|}
block|}
comment|/* Write back modified cylinder groups. */
name|putcgs
argument_list|()
expr_stmt|;
comment|/* Write back updated statistics and super-block. */
name|closedisk
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

