begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998 Robert Nordier  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE  * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"mkfs_msdos.h"
end_include

begin_define
define|#
directive|define
name|argto1
parameter_list|(
name|arg
parameter_list|,
name|lo
parameter_list|,
name|msg
parameter_list|)
value|argtou(arg, lo, 0xff, msg)
end_define

begin_define
define|#
directive|define
name|argto2
parameter_list|(
name|arg
parameter_list|,
name|lo
parameter_list|,
name|msg
parameter_list|)
value|argtou(arg, lo, 0xffff, msg)
end_define

begin_define
define|#
directive|define
name|argto4
parameter_list|(
name|arg
parameter_list|,
name|lo
parameter_list|,
name|msg
parameter_list|)
value|argtou(arg, lo, 0xffffffff, msg)
end_define

begin_define
define|#
directive|define
name|argtox
parameter_list|(
name|arg
parameter_list|,
name|lo
parameter_list|,
name|msg
parameter_list|)
value|argtou(arg, lo, UINT_MAX, msg)
end_define

begin_function_decl
specifier|static
name|u_int
name|argtou
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|off_t
name|argtooff
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|time_t
name|get_tstamp
parameter_list|(
specifier|const
name|char
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|eb
decl_stmt|;
name|long
name|long
name|l
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|b
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|time_t
operator|)
name|st
operator|.
name|st_mtime
return|;
name|errno
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|strtoll
argument_list|(
name|b
argument_list|,
operator|&
name|eb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|eb
operator|||
operator|*
name|eb
operator|||
name|errno
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Can't parse timestamp '%s'"
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|time_t
operator|)
name|l
return|;
block|}
end_function

begin_comment
comment|/*  * Construct a FAT12, FAT16, or FAT32 file system.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|opts
index|[]
init|=
literal|"@:NB:C:F:I:L:O:S:a:b:c:e:f:h:i:k:m:n:o:r:s:T:u:"
decl_stmt|;
name|struct
name|msdos_options
name|o
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|,
modifier|*
name|dtype
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|memset
argument_list|(
operator|&
name|o
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|opts
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'@'
case|:
name|o
operator|.
name|offset
operator|=
name|argtooff
argument_list|(
name|optarg
argument_list|,
literal|"offset"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|o
operator|.
name|no_create
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|o
operator|.
name|bootstrap
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|o
operator|.
name|create_size
operator|=
name|argtooff
argument_list|(
name|optarg
argument_list|,
literal|"create size"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"12"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"16"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"32"
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: bad FAT type"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|o
operator|.
name|fat_type
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|o
operator|.
name|volume_id
operator|=
name|argto4
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|"volume ID"
argument_list|)
expr_stmt|;
name|o
operator|.
name|volume_id_set
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|o
operator|.
name|volume_label
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|o
operator|.
name|OEM_string
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|o
operator|.
name|bytes_per_sector
operator|=
name|argto2
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|,
literal|"bytes/sector"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|o
operator|.
name|sectors_per_fat
operator|=
name|argto4
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|,
literal|"sectors/FAT"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|o
operator|.
name|block_size
operator|=
name|argtox
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|,
literal|"block size"
argument_list|)
expr_stmt|;
name|o
operator|.
name|sectors_per_cluster
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|o
operator|.
name|sectors_per_cluster
operator|=
name|argto1
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|,
literal|"sectors/cluster"
argument_list|)
expr_stmt|;
name|o
operator|.
name|block_size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|o
operator|.
name|directory_entries
operator|=
name|argto2
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|,
literal|"directory entries"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|o
operator|.
name|floppy
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|o
operator|.
name|drive_heads
operator|=
name|argto2
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|,
literal|"drive heads"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|o
operator|.
name|info_sector
operator|=
name|argto2
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|,
literal|"info sector"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|o
operator|.
name|backup_sector
operator|=
name|argto2
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|,
literal|"backup sector"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|o
operator|.
name|media_descriptor
operator|=
name|argto1
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|"media descriptor"
argument_list|)
expr_stmt|;
name|o
operator|.
name|media_descriptor_set
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|o
operator|.
name|num_FAT
operator|=
name|argto1
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|,
literal|"number of FATs"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|o
operator|.
name|hidden_sectors
operator|=
name|argto4
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|"hidden sectors"
argument_list|)
expr_stmt|;
name|o
operator|.
name|hidden_sectors_set
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|o
operator|.
name|reserved_sectors
operator|=
name|argto2
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|,
literal|"reserved sectors"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|o
operator|.
name|size
operator|=
name|argto4
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|,
literal|"file system size"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|o
operator|.
name|timestamp_set
operator|=
literal|1
expr_stmt|;
name|o
operator|.
name|timestamp
operator|=
name|get_tstamp
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|o
operator|.
name|sectors_per_track
operator|=
name|argto2
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|,
literal|"sectors/track"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
operator|||
name|argc
operator|>
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
name|fname
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|.
name|create_size
operator|&&
operator|!
name|strchr
argument_list|(
name|fname
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fname
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|dtype
operator|=
operator|*
name|argv
expr_stmt|;
return|return
operator|!
operator|!
name|mkfs_msdos
argument_list|(
name|fname
argument_list|,
name|dtype
argument_list|,
operator|&
name|o
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert and check a numeric option argument.  */
end_comment

begin_function
specifier|static
name|u_int
name|argtou
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|u_int
name|lo
parameter_list|,
name|u_int
name|hi
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|u_long
name|x
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|strtoul
argument_list|(
name|arg
argument_list|,
operator|&
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|!
operator|*
name|arg
operator|||
operator|*
name|s
operator|||
name|x
operator|<
name|lo
operator|||
name|x
operator|>
name|hi
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: bad %s"
argument_list|,
name|arg
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/*  * Same for off_t, with optional skmgpP suffix  */
end_comment

begin_function
specifier|static
name|off_t
name|argtooff
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|off_t
name|x
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|strtoll
argument_list|(
name|arg
argument_list|,
operator|&
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* allow at most one extra char */
if|if
condition|(
name|errno
operator|||
name|x
operator|<
literal|0
operator|||
operator|(
name|s
index|[
literal|0
index|]
operator|&&
name|s
index|[
literal|1
index|]
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: bad %s"
argument_list|,
name|arg
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
comment|/* the extra char is the multiplier */
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: bad %s"
argument_list|,
name|arg
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* notreached */
case|case
literal|'s'
case|:
comment|/* sector */
case|case
literal|'S'
case|:
name|x
operator|<<=
literal|9
expr_stmt|;
comment|/* times 512 */
break|break;
case|case
literal|'k'
case|:
comment|/* kilobyte */
case|case
literal|'K'
case|:
name|x
operator|<<=
literal|10
expr_stmt|;
comment|/* times 1024 */
break|break;
case|case
literal|'m'
case|:
comment|/* megabyte */
case|case
literal|'M'
case|:
name|x
operator|<<=
literal|20
expr_stmt|;
comment|/* times 1024*1024 */
break|break;
case|case
literal|'g'
case|:
comment|/* gigabyte */
case|case
literal|'G'
case|:
name|x
operator|<<=
literal|30
expr_stmt|;
comment|/* times 1024*1024*1024 */
break|break;
case|case
literal|'p'
case|:
comment|/* partition start */
case|case
literal|'P'
case|:
case|case
literal|'l'
case|:
comment|/* partition length */
case|case
literal|'L'
case|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: not supported yet %s"
argument_list|,
name|arg
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* notreached */
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/*  * Print usage message.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [ -options ] special [disktype]\n"
argument_list|,
name|getprogname
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"where the options are:\n"
argument_list|)
expr_stmt|;
specifier|static
struct|struct
block|{
name|char
name|o
decl_stmt|;
specifier|const
name|char
modifier|*
name|h
decl_stmt|;
block|}
name|opts
index|[]
init|=
block|{
define|#
directive|define
name|AOPT
parameter_list|(
name|_opt
parameter_list|,
name|_type
parameter_list|,
name|_name
parameter_list|,
name|_min
parameter_list|,
name|_desc
parameter_list|)
value|{ _opt, _desc },
name|ALLOPTS
undef|#
directive|undef
name|AOPT
block|}
struct|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|opts
argument_list|)
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-%c %s\n"
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|o
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|h
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

