begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 1993, 1994 Steve Gerakines  *  *  This is freely redistributable software.  You may do anything you  *  wish with it, so long as the above notice stays intact.  *  *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS  *  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  *  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,  *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  *  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  *  POSSIBILITY OF SUCH DAMAGE.  *  *  ft.c - simple floppy tape filter  *  *  06/07/94 v1.0 ++sg  *  Added support for tape retension.  Added retries for ecc failures.  *  Moved to release.  *  *  01/28/94 v0.3b (Jim Babb)  *  Fixed bug when all sectors in a segment are marked bad.  *  *  10/30/93 v0.3  *  Minor revisions.  Seems pretty stable.  *  *  09/02/93 v0.2 pl01  *  Initial revision.  *  *  usage: ft [ -f tape ] [ description ]  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/ftape.h>
end_include

begin_define
define|#
directive|define
name|DEFQIC
value|"/dev/rft0"
end_define

begin_decl_stmt
name|char
name|buff
index|[
name|QCV_SEGSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scratch buffer */
end_comment

begin_decl_stmt
name|char
name|hbuff
index|[
name|QCV_SEGSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* header buffer */
end_comment

begin_decl_stmt
name|QIC_Header
modifier|*
name|hptr
init|=
operator|(
name|QIC_Header
operator|*
operator|)
name|hbuff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* header structure */
end_comment

begin_decl_stmt
name|int
name|hsn
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* segment number of header */
end_comment

begin_decl_stmt
name|int
name|dhsn
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* segment number of duplicate header */
end_comment

begin_decl_stmt
name|int
name|tfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tape file descriptor */
end_comment

begin_decl_stmt
name|QIC_Geom
name|geo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tape geometry */
end_comment

begin_decl_stmt
name|int
name|tvno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tape volume number */
end_comment

begin_decl_stmt
name|int
name|tvlast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if last volume in set */
end_comment

begin_decl_stmt
name|long
name|tvsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tape volume size in bytes */
end_comment

begin_decl_stmt
name|long
name|tvtime
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tape change time */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tvnote
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tape note */
end_comment

begin_decl_stmt
name|int
name|doretension
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if we should retension tape */
end_comment

begin_comment
comment|/* Lookup the badmap for a given track and segment. */
end_comment

begin_define
define|#
directive|define
name|BADMAP
parameter_list|(
name|t
parameter_list|,
name|s
parameter_list|)
value|hptr->qh_badmap[(t)*geo.g_segtrk+(s)]
end_define

begin_comment
comment|/* Retrieve values from a character array. */
end_comment

begin_define
define|#
directive|define
name|UL_VAL
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
value|(*((ULONG *)&(s)[p]))
end_define

begin_define
define|#
directive|define
name|US_VAL
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
value|(*((USHORT *)&(s)[p]))
end_define

begin_define
define|#
directive|define
name|equal
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(strcmp(s1, s2) == 0)
end_define

begin_comment
comment|/*  *  Print tape usage and then leave.  */
end_comment

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: ft [ -r ] [ -f device ] [ \"description\" ]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Check status of tape drive  */
end_comment

begin_function
name|int
name|check_stat
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|wr
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|s
decl_stmt|;
name|int
name|sawit
init|=
literal|0
decl_stmt|;
comment|/* get tape status */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|QIOSTATUS
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not get drive status\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* wait for the tape drive to become ready */
while|while
condition|(
operator|(
name|s
operator|&
name|QS_READY
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|sawit
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"waiting for drive to become ready...\n"
argument_list|)
expr_stmt|;
name|sawit
operator|=
literal|1
expr_stmt|;
block|}
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|QIOSTATUS
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not get drive status\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|s
operator|&
name|QS_FMTOK
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tape is not formatted\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|wr
operator|&&
operator|(
name|s
operator|&
name|QS_RDONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tape is write protected\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|3
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Convert time_t value to QIC time value.  */
end_comment

begin_function
name|ULONG
name|qtimeval
parameter_list|(
name|time_t
name|t
parameter_list|)
block|{
name|struct
name|tm
modifier|*
name|tp
decl_stmt|;
name|ULONG
name|r
decl_stmt|;
name|tp
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|r
operator|=
literal|2678400
operator|*
name|tp
operator|->
name|tm_mon
operator|+
literal|86400
operator|*
operator|(
name|tp
operator|->
name|tm_mday
operator|-
literal|1
operator|)
operator|+
literal|3600
operator|*
name|tp
operator|->
name|tm_hour
operator|+
literal|60
operator|*
name|tp
operator|->
name|tm_min
operator|+
name|tp
operator|->
name|tm_sec
expr_stmt|;
name|r
operator||=
operator|(
name|tp
operator|->
name|tm_year
operator|-
literal|70
operator|)
operator|<<
literal|25
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Return tm struct from QIC date format.  */
end_comment

begin_function
name|struct
name|tm
modifier|*
name|qtime
parameter_list|(
name|UCHAR
modifier|*
name|qt
parameter_list|)
block|{
name|ULONG
modifier|*
name|vp
init|=
operator|(
name|ULONG
operator|*
operator|)
name|qt
decl_stmt|;
name|struct
name|tm
name|t
decl_stmt|;
name|ULONG
name|v
decl_stmt|;
name|time_t
name|tv
decl_stmt|;
name|v
operator|=
operator|*
name|vp
expr_stmt|;
name|t
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|v
operator|>>
literal|25
operator|)
operator|&
literal|0x7f
operator|)
operator|+
literal|70
expr_stmt|;
name|v
operator|&=
literal|0x1ffffff
expr_stmt|;
name|t
operator|.
name|tm_mon
operator|=
name|v
operator|/
literal|2678400
expr_stmt|;
name|v
operator|%=
literal|2678400
expr_stmt|;
name|t
operator|.
name|tm_mday
operator|=
name|v
operator|/
literal|86400
operator|+
literal|1
expr_stmt|;
name|v
operator|%=
literal|86400
expr_stmt|;
name|t
operator|.
name|tm_hour
operator|=
name|v
operator|/
literal|3600
expr_stmt|;
name|v
operator|%=
literal|3600
expr_stmt|;
name|t
operator|.
name|tm_min
operator|=
name|v
operator|/
literal|60
expr_stmt|;
name|v
operator|%=
literal|60
expr_stmt|;
name|t
operator|.
name|tm_sec
operator|=
name|v
expr_stmt|;
name|t
operator|.
name|tm_wday
operator|=
literal|0
expr_stmt|;
comment|/* XXX - let mktime do the real work */
name|t
operator|.
name|tm_yday
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|tm_isdst
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|tm_gmtoff
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|tm_zone
operator|=
name|NULL
expr_stmt|;
name|tv
operator|=
name|mktime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|localtime
argument_list|(
operator|&
name|tv
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Return a string, zero terminated.  */
end_comment

begin_function
name|char
modifier|*
name|qstr
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
name|nchar
parameter_list|)
block|{
specifier|static
name|char
name|tstr
index|[
literal|256
index|]
decl_stmt|;
name|strncpy
argument_list|(
name|tstr
argument_list|,
name|str
argument_list|,
name|nchar
argument_list|)
expr_stmt|;
name|tstr
index|[
name|nchar
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|tstr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Read header from tape  */
end_comment

begin_function
name|int
name|get_header
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|sn
decl_stmt|,
name|bytes
decl_stmt|;
name|QIC_Segment
name|s
decl_stmt|;
name|int
name|gothdr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|QIOGEOM
argument_list|,
operator|&
name|geo
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"couldn't determine tape geometry\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Get the header and duplicate */
for|for
control|(
name|sn
operator|=
literal|0
init|;
name|sn
operator|<
literal|16
condition|;
name|sn
operator|++
control|)
block|{
name|s
operator|.
name|sg_trk
operator|=
literal|0
expr_stmt|;
name|s
operator|.
name|sg_seg
operator|=
name|sn
expr_stmt|;
name|s
operator|.
name|sg_badmap
operator|=
literal|0
expr_stmt|;
name|s
operator|.
name|sg_data
operator|=
operator|(
name|UCHAR
operator|*
operator|)
operator|&
name|buff
index|[
literal|0
index|]
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|QIOREAD
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|r
operator|=
name|check_parity
argument_list|(
name|s
operator|.
name|sg_data
argument_list|,
literal|0
argument_list|,
name|s
operator|.
name|sg_crcmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|sg_data
index|[
literal|0
index|]
operator|==
literal|0x55
operator|&&
name|s
operator|.
name|sg_data
index|[
literal|1
index|]
operator|==
literal|0xaa
operator|&&
name|s
operator|.
name|sg_data
index|[
literal|2
index|]
operator|==
literal|0x55
operator|&&
name|s
operator|.
name|sg_data
index|[
literal|3
index|]
operator|==
literal|0xaa
condition|)
block|{
if|if
condition|(
name|hsn
operator|>=
literal|0
condition|)
block|{
name|dhsn
operator|=
name|sn
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|&&
operator|!
name|gothdr
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"using secondary header\n"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|s
operator|.
name|sg_data
argument_list|,
name|hbuff
argument_list|,
name|QCV_SEGSIZE
argument_list|)
expr_stmt|;
name|gothdr
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
name|hsn
operator|=
name|sn
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|bcopy
argument_list|(
name|s
operator|.
name|sg_data
argument_list|,
name|hbuff
argument_list|,
name|QCV_SEGSIZE
argument_list|)
expr_stmt|;
name|gothdr
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many errors in primary header\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|gothdr
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"couldn't read header segment\n"
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|QIOREWIND
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Open /dev/tty and ask for next volume.  */
end_comment

begin_macro
name|ask_vol
argument_list|(
argument|int vn
argument_list|)
end_macro

begin_block
block|{
name|FILE
modifier|*
name|inp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"argh!! can't open /dev/tty\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Insert ftfilt volume %02d and press enter:"
argument_list|,
name|vn
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  Return the name of the tape only.  */
end_comment

begin_function
name|void
name|do_getname
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|check_stat
argument_list|(
name|tfd
argument_list|,
literal|0
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_header
argument_list|(
name|tfd
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\" - %s"
argument_list|,
name|qstr
argument_list|(
name|hptr
operator|->
name|qh_tname
argument_list|,
literal|44
argument_list|)
argument_list|,
name|asctime
argument_list|(
name|qtime
argument_list|(
name|hptr
operator|->
name|qh_chgdate
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Extract data from tape to stdout.  */
end_comment

begin_function
name|void
name|do_read
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|sno
decl_stmt|,
name|vno
decl_stmt|,
name|sbytes
decl_stmt|,
name|r
decl_stmt|,
name|eccfails
decl_stmt|;
name|long
name|curpos
decl_stmt|;
name|char
modifier|*
name|hname
decl_stmt|;
name|QIC_Segment
name|s
decl_stmt|;
comment|/* Process multiple volumes if necessary */
name|vno
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|check_stat
argument_list|(
name|tfd
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ask_vol
argument_list|(
name|vno
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|doretension
condition|)
block|{
name|ioctl
argument_list|(
name|tfd
argument_list|,
name|QIOBOT
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tfd
argument_list|,
name|QIOEOT
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tfd
argument_list|,
name|QIOBOT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|get_header
argument_list|(
name|tfd
argument_list|)
condition|)
block|{
name|ask_vol
argument_list|(
name|vno
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* extract volume and header info from label */
name|hname
operator|=
name|hptr
operator|->
name|qh_tname
expr_stmt|;
name|hname
index|[
literal|43
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tvno
operator|=
name|atoi
argument_list|(
operator|&
name|hname
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|tvlast
operator|=
operator|(
name|hname
index|[
literal|10
index|]
operator|==
literal|'*'
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|tvsize
operator|=
name|atoi
argument_list|(
operator|&
name|hname
index|[
literal|14
index|]
argument_list|)
expr_stmt|;
name|tvnote
operator|=
operator|&
name|hname
index|[
literal|25
index|]
expr_stmt|;
if|if
condition|(
name|vno
operator|!=
name|tvno
operator|||
name|strncmp
argument_list|(
name|hname
argument_list|,
literal|"ftfilt"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Incorrect volume inserted.  This tape is:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\" - %s\n"
argument_list|,
name|hname
argument_list|,
name|asctime
argument_list|(
name|qtime
argument_list|(
name|hptr
operator|->
name|qh_chgdate
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ask_vol
argument_list|(
name|vno
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Process this volume */
name|curpos
operator|=
literal|0
expr_stmt|;
name|eccfails
operator|=
literal|0
expr_stmt|;
name|sno
operator|=
name|hptr
operator|->
name|qh_first
expr_stmt|;
while|while
condition|(
name|tvsize
operator|>
literal|0
condition|)
block|{
name|s
operator|.
name|sg_trk
operator|=
name|sno
operator|/
name|geo
operator|.
name|g_segtrk
expr_stmt|;
name|s
operator|.
name|sg_seg
operator|=
name|sno
operator|%
name|geo
operator|.
name|g_segtrk
expr_stmt|;
name|s
operator|.
name|sg_badmap
operator|=
name|BADMAP
argument_list|(
name|s
operator|.
name|sg_trk
argument_list|,
name|s
operator|.
name|sg_seg
argument_list|)
expr_stmt|;
name|sbytes
operator|=
name|sect_bytes
argument_list|(
name|s
operator|.
name|sg_badmap
argument_list|)
operator|-
name|QCV_ECCSIZE
expr_stmt|;
name|s
operator|.
name|sg_data
operator|=
operator|(
name|UCHAR
operator|*
operator|)
operator|&
name|buff
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|sbytes
operator|<=
literal|0
condition|)
block|{
name|sno
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|tfd
argument_list|,
name|QIOREAD
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"QIOREAD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_parity
argument_list|(
name|s
operator|.
name|sg_data
argument_list|,
name|s
operator|.
name|sg_badmap
argument_list|,
name|s
operator|.
name|sg_crcmap
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|eccfails
operator|<=
literal|5
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ft: retry %d at segment %d byte %ld\n"
argument_list|,
name|eccfails
argument_list|,
name|sno
argument_list|,
name|curpos
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ft: *** ecc failure in segment %d at byte %ld\n"
argument_list|,
name|sno
argument_list|,
name|curpos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tvsize
operator|<
name|sbytes
condition|)
name|sbytes
operator|=
name|tvsize
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
name|s
operator|.
name|sg_data
argument_list|,
name|sbytes
argument_list|)
expr_stmt|;
name|tvsize
operator|-=
name|sbytes
expr_stmt|;
name|curpos
operator|+=
name|sbytes
expr_stmt|;
name|sno
operator|++
expr_stmt|;
name|eccfails
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tvlast
condition|)
break|break;
name|ioctl
argument_list|(
name|tfd
argument_list|,
name|QIOREWIND
argument_list|)
expr_stmt|;
name|ask_vol
argument_list|(
operator|++
name|vno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  Dump data from stdin to tape.  */
end_comment

begin_function
name|void
name|do_write
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|sno
decl_stmt|,
name|vno
decl_stmt|,
name|amt
decl_stmt|,
name|sbytes
decl_stmt|;
name|int
name|c
decl_stmt|,
name|maxseg
decl_stmt|,
name|r
decl_stmt|;
name|ULONG
name|qnow
decl_stmt|;
name|QIC_Segment
name|s
decl_stmt|;
name|char
name|tmpstr
index|[
literal|80
index|]
decl_stmt|;
name|qnow
operator|=
name|qtimeval
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|vno
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|check_stat
argument_list|(
name|tfd
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ask_vol
argument_list|(
name|vno
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|doretension
condition|)
block|{
name|ioctl
argument_list|(
name|tfd
argument_list|,
name|QIOBOT
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tfd
argument_list|,
name|QIOEOT
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tfd
argument_list|,
name|QIOBOT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|get_header
argument_list|(
name|tfd
argument_list|)
condition|)
block|{
name|ask_vol
argument_list|(
name|vno
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|maxseg
operator|=
name|geo
operator|.
name|g_segtrk
operator|*
name|geo
operator|.
name|g_trktape
operator|-
literal|1
expr_stmt|;
name|sno
operator|=
name|hptr
operator|->
name|qh_first
expr_stmt|;
name|tvno
operator|=
name|vno
expr_stmt|;
name|tvsize
operator|=
literal|0
expr_stmt|;
name|tvlast
operator|=
literal|0
expr_stmt|;
comment|/* Process until end of volume or end of data */
for|for
control|(
name|sno
operator|=
name|hptr
operator|->
name|qh_first
init|;
name|sno
operator|<
name|maxseg
operator|&&
name|tvlast
operator|==
literal|0
condition|;
operator|++
name|sno
control|)
block|{
comment|/* Prepare to load the next segment */
name|s
operator|.
name|sg_trk
operator|=
name|sno
operator|/
name|geo
operator|.
name|g_segtrk
expr_stmt|;
name|s
operator|.
name|sg_seg
operator|=
name|sno
operator|%
name|geo
operator|.
name|g_segtrk
expr_stmt|;
name|s
operator|.
name|sg_badmap
operator|=
name|BADMAP
argument_list|(
name|s
operator|.
name|sg_trk
argument_list|,
name|s
operator|.
name|sg_seg
argument_list|)
expr_stmt|;
name|sbytes
operator|=
name|sect_bytes
argument_list|(
name|s
operator|.
name|sg_badmap
argument_list|)
operator|-
name|QCV_ECCSIZE
expr_stmt|;
name|s
operator|.
name|sg_data
operator|=
operator|(
name|UCHAR
operator|*
operator|)
operator|&
name|buff
index|[
literal|0
index|]
expr_stmt|;
comment|/* Ugh.  Loop to get the full amt. */
for|for
control|(
name|amt
operator|=
literal|0
init|;
name|amt
operator|<
name|sbytes
condition|;
name|amt
operator|+=
name|r
control|)
block|{
name|r
operator|=
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|s
operator|.
name|sg_data
index|[
name|amt
index|]
argument_list|,
name|sbytes
operator|-
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
literal|0
condition|)
block|{
name|tvlast
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* skip the segment if *all* sectors are flagged as bad */
if|if
condition|(
name|amt
condition|)
block|{
if|if
condition|(
name|amt
operator|<
name|sbytes
condition|)
name|bzero
argument_list|(
operator|&
name|s
operator|.
name|sg_data
index|[
name|amt
index|]
argument_list|,
name|sbytes
operator|-
name|amt
argument_list|)
expr_stmt|;
name|r
operator|=
name|set_parity
argument_list|(
name|s
operator|.
name|sg_data
argument_list|,
name|s
operator|.
name|sg_badmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"** warning: ecc problem !!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|tfd
argument_list|,
name|QIOWRITE
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"QIOWRITE"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tvsize
operator|+=
name|amt
expr_stmt|;
block|}
block|}
comment|/* Build new header info */
comment|/* ftfilt vol*xx yyyyyyyyyy note56789012345678  */
comment|/* 01234567890123456789012345678901234567890123 */
name|sprintf
argument_list|(
name|tmpstr
argument_list|,
literal|"ftfilt vol%s%02d %010d %s"
argument_list|,
operator|(
name|tvlast
operator|)
condition|?
literal|"*"
else|:
literal|" "
argument_list|,
name|tvno
argument_list|,
name|tvsize
argument_list|,
name|tvnote
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|hptr
operator|->
name|qh_tname
argument_list|,
name|tmpstr
argument_list|,
literal|44
argument_list|)
expr_stmt|;
name|UL_VAL
argument_list|(
name|hptr
operator|->
name|qh_chgdate
argument_list|,
literal|0
argument_list|)
operator|=
name|qnow
expr_stmt|;
comment|/* Update the header for this volume */
if|if
condition|(
name|hsn
operator|>=
literal|0
condition|)
block|{
name|s
operator|.
name|sg_trk
operator|=
name|hsn
operator|/
name|geo
operator|.
name|g_segtrk
expr_stmt|;
name|s
operator|.
name|sg_seg
operator|=
name|hsn
operator|%
name|geo
operator|.
name|g_segtrk
expr_stmt|;
name|s
operator|.
name|sg_badmap
operator|=
literal|0
expr_stmt|;
name|s
operator|.
name|sg_data
operator|=
operator|(
name|UCHAR
operator|*
operator|)
name|hbuff
expr_stmt|;
name|r
operator|=
name|set_parity
argument_list|(
name|s
operator|.
name|sg_data
argument_list|,
name|s
operator|.
name|sg_badmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"** warning: header ecc problem !!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|tfd
argument_list|,
name|QIOWRITE
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"QIOWRITE"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dhsn
operator|>=
literal|0
condition|)
block|{
name|s
operator|.
name|sg_trk
operator|=
name|dhsn
operator|/
name|geo
operator|.
name|g_segtrk
expr_stmt|;
name|s
operator|.
name|sg_seg
operator|=
name|dhsn
operator|%
name|geo
operator|.
name|g_segtrk
expr_stmt|;
name|s
operator|.
name|sg_badmap
operator|=
literal|0
expr_stmt|;
name|s
operator|.
name|sg_data
operator|=
operator|(
name|UCHAR
operator|*
operator|)
name|hbuff
expr_stmt|;
name|r
operator|=
name|set_parity
argument_list|(
name|s
operator|.
name|sg_data
argument_list|,
name|s
operator|.
name|sg_badmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"** warning: duphdr ecc problem !!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|tfd
argument_list|,
name|QIOWRITE
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"QIOWRITE"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|ioctl
argument_list|(
name|tfd
argument_list|,
name|QIOREWIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvlast
condition|)
break|break;
name|ask_vol
argument_list|(
operator|++
name|vno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  Entry.  */
end_comment

begin_function
name|void
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|s
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|tape
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|;
comment|/* Get device from environment, command line will override. */
if|if
condition|(
operator|(
name|tape
operator|=
name|getenv
argument_list|(
literal|"TAPE"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tape
operator|=
name|DEFQIC
expr_stmt|;
comment|/* Process args. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
break|break;
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'t'
case|:
if|if
condition|(
name|i
operator|==
operator|(
name|argc
operator|-
literal|1
operator|)
condition|)
name|usage
argument_list|()
expr_stmt|;
name|tape
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|doretension
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
operator|(
name|argc
operator|-
literal|1
operator|)
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|argc
condition|)
block|{
name|tvnote
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|tvnote
argument_list|)
operator|>
literal|18
condition|)
name|argv
index|[
name|i
index|]
index|[
literal|18
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Open the tape device */
if|if
condition|(
operator|(
name|tfd
operator|=
name|open
argument_list|(
name|tape
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|tape
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|do_write
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|1
argument_list|)
condition|)
name|do_read
argument_list|()
expr_stmt|;
else|else
name|do_getname
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|tfd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

