begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996 Whistle Communications  * All Rights Reserved.  *  * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * Whistle Communications allows free use of this software in its "as is"  * condition.  Whistle Communications disclaims any liability of any kind for  * any damages whatsoever resulting from the use of this software.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_struct
struct|struct
name|mboot
block|{
name|unsigned
name|char
name|padding
index|[
literal|2
index|]
decl_stmt|;
comment|/* force the longs to be long aligned */
name|unsigned
name|char
name|bootinst
index|[
name|DOSPARTOFF
index|]
decl_stmt|;
name|struct
name|dos_partition
name|parts
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|short
name|int
name|signature
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|mboot
name|mboot
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NAMEBLOCK
value|1
end_define

begin_comment
comment|/* 2nd block */
end_comment

begin_define
define|#
directive|define
name|BLOCKSIZE
value|512
end_define

begin_define
define|#
directive|define
name|ENABLE_MAGIC
value|0xfadefeed
end_define

begin_define
define|#
directive|define
name|DISABLE_MAGIC
value|0xfadefade
end_define

begin_decl_stmt
specifier|static
name|int
name|bflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dflag
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BOOT_MAGIC
value|0xAA55
end_define

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n"
argument_list|,
literal|"usage: nextboot [-b] device bootstring [bootstring] ..."
argument_list|,
literal|"       nextboot {-e,-d} device"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|namebuf
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
name|cp
init|=
name|namebuf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|part
decl_stmt|;
name|bflag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"bde"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'b'
case|:
name|bflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|eflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
operator|(
name|dflag
operator|+
name|eflag
operator|+
name|bflag
operator|)
operator|>
literal|1
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dflag
operator|+
name|eflag
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"can't open %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/******************************************* 	 * Check that we have an MBR 	 */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"lseek"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|mboot
operator|.
name|bootinst
index|[
literal|0
index|]
argument_list|,
name|BLOCKSIZE
argument_list|)
operator|!=
name|BLOCKSIZE
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"read0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mboot
operator|.
name|signature
operator|!=
operator|(
name|unsigned
name|short
operator|)
name|BOOT_MAGIC
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"no fdisk part.. not touching block 1"
argument_list|)
expr_stmt|;
comment|/******************************************* 	 * And check that none of the partitions in it cover the name block; 	 */
for|for
control|(
name|part
operator|=
literal|0
init|;
name|part
operator|<
literal|4
condition|;
name|part
operator|++
control|)
block|{
if|if
condition|(
name|mboot
operator|.
name|parts
index|[
name|part
index|]
operator|.
name|dp_size
operator|&&
operator|(
name|mboot
operator|.
name|parts
index|[
name|part
index|]
operator|.
name|dp_start
operator|<=
name|NAMEBLOCK
operator|)
operator|&&
operator|(
name|mboot
operator|.
name|parts
index|[
name|part
index|]
operator|.
name|dp_start
operator|+
name|mboot
operator|.
name|parts
index|[
name|part
index|]
operator|.
name|dp_size
operator|>
name|NAMEBLOCK
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"name sector lies within a Bios partition: aborting write"
argument_list|)
expr_stmt|;
block|}
comment|/******************************************* 	 *  Now check the  name sector itself to see if it's been initialized. 	 */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|NAMEBLOCK
operator|*
name|BLOCKSIZE
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"lseek"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|namebuf
argument_list|,
name|BLOCKSIZE
argument_list|)
operator|!=
name|BLOCKSIZE
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"read1"
argument_list|)
expr_stmt|;
comment|/******************************************* 	 * check if we are just enabling or disabling 	 * Remember the flags are exclusive.. 	 */
if|if
condition|(
operator|!
name|bflag
condition|)
block|{
comment|/* don't care what's there if bflag is set */
switch|switch
condition|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|cp
condition|)
block|{
case|case
name|DISABLE_MAGIC
case|:
case|case
name|ENABLE_MAGIC
case|:
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"namesector not initialized, use the -b flag"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/******************************************* 	 *  If the z or r flag is set, damage or restore the magic number.. 	 * to disable/enable the feature 	 */
if|if
condition|(
name|dflag
condition|)
block|{
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|cp
operator|=
name|DISABLE_MAGIC
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|cp
operator|=
name|ENABLE_MAGIC
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|dflag
operator|)
operator|&&
operator|(
operator|!
name|eflag
operator|)
condition|)
block|{
comment|/******************************************* 	 	*  Create a new namesector in ram  	 	*/
name|cp
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'D'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'N'
expr_stmt|;
name|j
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|j
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|cp
operator|++
operator|=
literal|0xff
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|0xff
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|0xff
expr_stmt|;
name|namebuf
index|[
name|BLOCKSIZE
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* paranoid */
name|namebuf
index|[
name|BLOCKSIZE
index|]
operator|=
literal|0xff
expr_stmt|;
block|}
comment|/******************************************* 	 *  write it to disk. 	 */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|NAMEBLOCK
operator|*
name|BLOCKSIZE
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"lseek"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|namebuf
argument_list|,
name|BLOCKSIZE
argument_list|)
operator|!=
name|BLOCKSIZE
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/******************************************* 	 * just to be safe/paranoid.. read it back.. 	 * and print it.. 	 */
block|if (lseek(fd,NAMEBLOCK * BLOCKSIZE,0) == -1) 		err(1, "lseek (second)"); 	read (fd,namebuf,512); 	for (i = 0;i< 16;i++) { 		for ( j = 0; j< 16; j++) { 			printf("%02x ",(unsigned char )namebuf[(i*16) + j ]); 		} 		printf("\n"); 	}
endif|#
directive|endif
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

