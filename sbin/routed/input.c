begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
literal|"@(#)input.c	8.1 (Berkeley) 6/5/93"
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_empty
empty|#ident "$FreeBSD$"
end_empty

begin_function_decl
specifier|static
name|void
name|input
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
parameter_list|,
name|struct
name|interface
modifier|*
parameter_list|,
name|struct
name|interface
modifier|*
parameter_list|,
name|struct
name|rip
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|input_route
parameter_list|(
name|naddr
parameter_list|,
name|naddr
parameter_list|,
name|struct
name|rt_spare
modifier|*
parameter_list|,
name|struct
name|netinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ck_passwd
parameter_list|(
name|struct
name|interface
modifier|*
parameter_list|,
name|struct
name|rip
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|naddr
parameter_list|,
name|struct
name|msg_limit
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* process RIP input  */
end_comment

begin_function
name|void
name|read_rip
parameter_list|(
name|int
name|sock
parameter_list|,
name|struct
name|interface
modifier|*
name|sifp
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|struct
name|interface
modifier|*
name|aifp
decl_stmt|;
name|int
name|fromlen
decl_stmt|,
name|cc
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_PASSIFNAME
specifier|static
name|struct
name|msg_limit
name|bad_name
decl_stmt|;
struct|struct
block|{
name|char
name|ifname
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
name|union
name|pkt_buf
name|pbuf
decl_stmt|;
block|}
name|inbuf
struct|;
else|#
directive|else
struct|struct
block|{
name|union
name|pkt_buf
name|pbuf
decl_stmt|;
block|}
name|inbuf
struct|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|cc
operator|=
name|recvfrom
argument_list|(
name|sock
argument_list|,
operator|&
name|inbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|inbuf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|cc
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
name|LOGERR
argument_list|(
literal|"recvfrom(rip)"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fromlen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
name|logbad
argument_list|(
literal|1
argument_list|,
literal|"impossible recvfrom(rip) fromlen=%d"
argument_list|,
name|fromlen
argument_list|)
expr_stmt|;
comment|/* aifp is the "authenticated" interface via which the packet 		 *	arrived.  In fact, it is only the interface on which 		 *	the packet should have arrived based on is source 		 *	address. 		 * sifp is interface associated with the socket through which 		 *	the packet was received. 		 */
ifdef|#
directive|ifdef
name|USE_PASSIFNAME
if|if
condition|(
operator|(
name|cc
operator|-=
sizeof|sizeof
argument_list|(
name|inbuf
operator|.
name|ifname
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|logbad
argument_list|(
literal|0
argument_list|,
literal|"missing USE_PASSIFNAME; only %d bytes"
argument_list|,
name|cc
operator|+
sizeof|sizeof
argument_list|(
name|inbuf
operator|.
name|ifname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check the remote interfaces first */
for|for
control|(
name|aifp
operator|=
name|remote_if
init|;
name|aifp
condition|;
name|aifp
operator|=
name|aifp
operator|->
name|int_rlink
control|)
block|{
if|if
condition|(
name|aifp
operator|->
name|int_addr
operator|==
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
break|break;
block|}
if|if
condition|(
name|aifp
operator|==
literal|0
condition|)
block|{
name|aifp
operator|=
name|ifwithname
argument_list|(
name|inbuf
operator|.
name|ifname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|aifp
operator|==
literal|0
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_name
argument_list|,
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|"impossible interface name %.*s"
argument_list|,
name|IFNAMSIZ
argument_list|,
name|inbuf
operator|.
name|ifname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|aifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|&&
name|aifp
operator|->
name|int_dstaddr
operator|!=
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
operator|)
operator|||
operator|(
operator|!
operator|(
name|aifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|&&
operator|!
name|on_net
argument_list|(
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|aifp
operator|->
name|int_net
argument_list|,
name|aifp
operator|->
name|int_mask
argument_list|)
operator|)
condition|)
block|{
comment|/* If it came via the wrong interface, do not 				 * trust it. 				 */
name|aifp
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|#
directive|else
name|aifp
operator|=
name|iflookup
argument_list|(
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sifp
operator|==
literal|0
condition|)
name|sifp
operator|=
name|aifp
expr_stmt|;
name|input
argument_list|(
operator|&
name|from
argument_list|,
name|sifp
argument_list|,
name|aifp
argument_list|,
operator|&
name|inbuf
operator|.
name|pbuf
operator|.
name|rip
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process a RIP packet  */
end_comment

begin_function
specifier|static
name|void
name|input
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|from
parameter_list|,
comment|/* received from this IP address */
name|struct
name|interface
modifier|*
name|sifp
parameter_list|,
comment|/* interface of incoming socket */
name|struct
name|interface
modifier|*
name|aifp
parameter_list|,
comment|/* "authenticated" interface */
name|struct
name|rip
modifier|*
name|rip
parameter_list|,
name|int
name|cc
parameter_list|)
block|{
define|#
directive|define
name|FROM_NADDR
value|from->sin_addr.s_addr
specifier|static
name|struct
name|msg_limit
name|use_auth
decl_stmt|,
name|bad_len
decl_stmt|,
name|bad_mask
decl_stmt|;
specifier|static
name|struct
name|msg_limit
name|unk_router
decl_stmt|,
name|bad_router
decl_stmt|,
name|bad_nhop
decl_stmt|;
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
name|struct
name|rt_spare
name|new
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|n
decl_stmt|,
modifier|*
name|lim
decl_stmt|;
name|struct
name|interface
modifier|*
name|ifp1
decl_stmt|;
name|naddr
name|gate
decl_stmt|,
name|mask
decl_stmt|,
name|v1_mask
decl_stmt|,
name|dst
decl_stmt|,
name|ddst_h
init|=
literal|0
decl_stmt|;
name|struct
name|auth
modifier|*
name|ap
decl_stmt|;
name|struct
name|tgate
modifier|*
name|tg
init|=
literal|0
decl_stmt|;
name|struct
name|tgate_net
modifier|*
name|tn
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Notice when we hear from a remote gateway 	 */
if|if
condition|(
name|aifp
operator|!=
literal|0
operator|&&
operator|(
name|aifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
operator|)
condition|)
name|aifp
operator|->
name|int_act_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|trace_rip
argument_list|(
literal|"Recv"
argument_list|,
literal|"from"
argument_list|,
name|from
argument_list|,
name|sifp
argument_list|,
name|rip
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rip
operator|->
name|rip_vers
operator|==
literal|0
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_router
argument_list|,
name|FROM_NADDR
argument_list|,
literal|"RIP version 0, cmd %d, packet received from %s"
argument_list|,
name|rip
operator|->
name|rip_cmd
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|rip
operator|->
name|rip_vers
operator|>
name|RIPv2
condition|)
block|{
name|rip
operator|->
name|rip_vers
operator|=
name|RIPv2
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|>
operator|(
name|int
operator|)
name|OVER_MAXPACKETSIZE
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_router
argument_list|,
name|FROM_NADDR
argument_list|,
literal|"packet at least %d bytes too long received from %s"
argument_list|,
name|cc
operator|-
name|MAXPACKETSIZE
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|n
operator|=
name|rip
operator|->
name|rip_nets
expr_stmt|;
name|lim
operator|=
operator|(
expr|struct
name|netinfo
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rip
operator|+
name|cc
operator|)
expr_stmt|;
comment|/* Notice authentication. 	 * As required by section 4.2 in RFC 1723, discard authenticated 	 * RIPv2 messages, but only if configured for that silliness. 	 * 	 * RIPv2 authentication is lame.  Why authenticate queries? 	 * Why should a RIPv2 implementation with authentication disabled 	 * not be able to listen to RIPv2 packets with authentication, while 	 * RIPv1 systems will listen?  Crazy! 	 */
if|if
condition|(
operator|!
name|auth_ok
operator|&&
name|rip
operator|->
name|rip_vers
operator|==
name|RIPv2
operator|&&
name|n
operator|<
name|lim
operator|&&
name|n
operator|->
name|n_family
operator|==
name|RIP_AF_AUTH
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|use_auth
argument_list|,
name|FROM_NADDR
argument_list|,
literal|"RIPv2 message with authentication from %s discarded"
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|rip
operator|->
name|rip_cmd
condition|)
block|{
case|case
name|RIPCMD_REQUEST
case|:
comment|/* For mere requests, be a little sloppy about the source 		 */
if|if
condition|(
name|aifp
operator|==
literal|0
condition|)
name|aifp
operator|=
name|sifp
expr_stmt|;
comment|/* Are we talking to ourself or a remote gateway? 		 */
name|ifp1
operator|=
name|ifwithaddr
argument_list|(
name|FROM_NADDR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp1
condition|)
block|{
if|if
condition|(
name|ifp1
operator|->
name|int_state
operator|&
name|IS_REMOTE
condition|)
block|{
comment|/* remote gateway */
name|aifp
operator|=
name|ifp1
expr_stmt|;
if|if
condition|(
name|check_remote
argument_list|(
name|aifp
argument_list|)
condition|)
block|{
name|aifp
operator|->
name|int_act_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
operator|(
name|void
operator|)
name|if_ok
argument_list|(
name|aifp
argument_list|,
literal|"remote "
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|from
operator|->
name|sin_port
operator|==
name|htons
argument_list|(
name|RIP_PORT
argument_list|)
condition|)
block|{
name|trace_pkt
argument_list|(
literal|"    discard our own RIP request"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* did the request come from a router? 		 */
if|if
condition|(
name|from
operator|->
name|sin_port
operator|==
name|htons
argument_list|(
name|RIP_PORT
argument_list|)
condition|)
block|{
comment|/* yes, ignore the request if RIP is off so that 			 * the router does not depend on us. 			 */
if|if
condition|(
name|rip_sock
operator|<
literal|0
operator|||
operator|(
name|aifp
operator|!=
literal|0
operator|&&
name|IS_RIP_OUT_OFF
argument_list|(
name|aifp
operator|->
name|int_state
argument_list|)
operator|)
condition|)
block|{
name|trace_pkt
argument_list|(
literal|"    discard request while RIP off"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* According to RFC 1723, we should ignore unauthenticated 		 * queries.  That is too silly to bother with.  Sheesh! 		 * Are forwarding tables supposed to be secret, when 		 * a bad guy can infer them with test traffic?  When RIP 		 * is still the most common router-discovery protocol 		 * and so hosts need to send queries that will be answered? 		 * What about `rtquery`? 		 * Maybe on firewalls you'd care, but not enough to 		 * give up the diagnostic facilities of remote probing. 		 */
if|if
condition|(
name|n
operator|>=
name|lim
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_len
argument_list|,
name|FROM_NADDR
argument_list|,
literal|"empty request from %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cc
operator|%
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|rip
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_len
argument_list|,
name|FROM_NADDR
argument_list|,
literal|"request of bad length (%d) from %s"
argument_list|,
name|cc
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rip
operator|->
name|rip_vers
operator|==
name|RIPv2
operator|&&
operator|(
name|aifp
operator|==
literal|0
operator|||
operator|(
name|aifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV1_OUT
operator|)
operator|)
condition|)
block|{
name|v12buf
operator|.
name|buf
operator|->
name|rip_vers
operator|=
name|RIPv2
expr_stmt|;
comment|/* If we have a secret but it is a cleartext secret, 			 * do not disclose our secret unless the other guy 			 * already knows it. 			 */
name|ap
operator|=
name|find_auth
argument_list|(
name|aifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|!=
literal|0
operator|&&
name|ap
operator|->
name|type
operator|==
name|RIP_AUTH_PW
operator|&&
name|n
operator|->
name|n_family
operator|==
name|RIP_AF_AUTH
operator|&&
operator|!
name|ck_passwd
argument_list|(
name|aifp
argument_list|,
name|rip
argument_list|,
name|lim
argument_list|,
name|FROM_NADDR
argument_list|,
operator|&
name|use_auth
argument_list|)
condition|)
name|ap
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|v12buf
operator|.
name|buf
operator|->
name|rip_vers
operator|=
name|RIPv1
expr_stmt|;
name|ap
operator|=
literal|0
expr_stmt|;
block|}
name|clr_ws_buf
argument_list|(
operator|&
name|v12buf
argument_list|,
name|ap
argument_list|)
expr_stmt|;
do|do
block|{
name|NTOHL
argument_list|(
name|n
operator|->
name|n_metric
argument_list|)
expr_stmt|;
comment|/* A single entry with family RIP_AF_UNSPEC and 			 * metric HOPCNT_INFINITY means "all routes". 			 * We respond to routers only if we are acting 			 * as a supplier, or to anyone other than a router 			 * (i.e. a query). 			 */
if|if
condition|(
name|n
operator|->
name|n_family
operator|==
name|RIP_AF_UNSPEC
operator|&&
name|n
operator|->
name|n_metric
operator|==
name|HOPCNT_INFINITY
condition|)
block|{
comment|/* Answer a query from a utility program 				 * with all we know. 				 */
if|if
condition|(
name|from
operator|->
name|sin_port
operator|!=
name|htons
argument_list|(
name|RIP_PORT
argument_list|)
condition|)
block|{
name|supply
argument_list|(
name|from
argument_list|,
name|aifp
argument_list|,
name|OUT_QUERY
argument_list|,
literal|0
argument_list|,
name|rip
operator|->
name|rip_vers
argument_list|,
name|ap
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* A router trying to prime its tables. 				 * Filter the answer in the about same way 				 * broadcasts are filtered. 				 * 				 * Only answer a router if we are a supplier 				 * to keep an unwary host that is just starting 				 * from picking us as a router. 				 */
if|if
condition|(
name|aifp
operator|==
literal|0
condition|)
block|{
name|trace_pkt
argument_list|(
literal|"ignore distant router"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|supplier
operator|||
name|IS_RIP_OFF
argument_list|(
name|aifp
operator|->
name|int_state
argument_list|)
condition|)
block|{
name|trace_pkt
argument_list|(
literal|"ignore; not supplying"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do not answer a RIPv1 router if 				 * we are sending RIPv2.  But do offer 				 * poor man's router discovery. 				 */
if|if
condition|(
operator|(
name|aifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV1_OUT
operator|)
operator|&&
name|rip
operator|->
name|rip_vers
operator|==
name|RIPv1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|aifp
operator|->
name|int_state
operator|&
name|IS_PM_RDISC
operator|)
condition|)
block|{
name|trace_pkt
argument_list|(
literal|"ignore; sending RIPv2"
argument_list|)
expr_stmt|;
return|return;
block|}
name|v12buf
operator|.
name|n
operator|->
name|n_family
operator|=
name|RIP_AF_INET
expr_stmt|;
name|v12buf
operator|.
name|n
operator|->
name|n_dst
operator|=
name|RIP_DEFAULT
expr_stmt|;
name|i
operator|=
name|aifp
operator|->
name|int_d_metric
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|rt
operator|=
name|rtget
argument_list|(
name|RIP_DEFAULT
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|i
operator|=
name|MIN
argument_list|(
name|i
argument_list|,
operator|(
name|rt
operator|->
name|rt_metric
operator|+
name|aifp
operator|->
name|int_metric
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|v12buf
operator|.
name|n
operator|->
name|n_metric
operator|=
name|htonl
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|v12buf
operator|.
name|n
operator|++
expr_stmt|;
break|break;
block|}
comment|/* Respond with RIPv1 instead of RIPv2 if 				 * that is what we are broadcasting on the 				 * interface to keep the remote router from 				 * getting the wrong initial idea of the 				 * routes we send. 				 */
name|supply
argument_list|(
name|from
argument_list|,
name|aifp
argument_list|,
name|OUT_UNICAST
argument_list|,
literal|0
argument_list|,
operator|(
name|aifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV1_OUT
operator|)
condition|?
name|RIPv2
else|:
name|RIPv1
argument_list|,
name|ap
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Ignore authentication */
if|if
condition|(
name|n
operator|->
name|n_family
operator|==
name|RIP_AF_AUTH
condition|)
continue|continue;
if|if
condition|(
name|n
operator|->
name|n_family
operator|!=
name|RIP_AF_INET
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_router
argument_list|,
name|FROM_NADDR
argument_list|,
literal|"request from %s for unsupported"
literal|" (af %d) %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|n
operator|->
name|n_family
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|n
operator|->
name|n_dst
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We are being asked about a specific destination. 			 */
name|dst
operator|=
name|n
operator|->
name|n_dst
expr_stmt|;
if|if
condition|(
operator|!
name|check_dst
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_router
argument_list|,
name|FROM_NADDR
argument_list|,
literal|"bad queried destination %s from %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|dst
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* decide what mask was intended */
if|if
condition|(
name|rip
operator|->
name|rip_vers
operator|==
name|RIPv1
operator|||
literal|0
operator|==
operator|(
name|mask
operator|=
name|ntohl
argument_list|(
name|n
operator|->
name|n_mask
argument_list|)
operator|)
operator|||
literal|0
operator|!=
operator|(
name|ntohl
argument_list|(
name|dst
argument_list|)
operator|&
operator|~
name|mask
operator|)
condition|)
name|mask
operator|=
name|ripv1_mask_host
argument_list|(
name|dst
argument_list|,
name|aifp
argument_list|)
expr_stmt|;
comment|/* try to find the answer */
name|rt
operator|=
name|rtget
argument_list|(
name|dst
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rt
operator|&&
name|dst
operator|!=
name|RIP_DEFAULT
condition|)
name|rt
operator|=
name|rtfind
argument_list|(
name|n
operator|->
name|n_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|v12buf
operator|.
name|buf
operator|->
name|rip_vers
operator|!=
name|RIPv1
condition|)
name|v12buf
operator|.
name|n
operator|->
name|n_mask
operator|=
name|mask
expr_stmt|;
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
block|{
comment|/* we do not have the answer */
name|v12buf
operator|.
name|n
operator|->
name|n_metric
operator|=
name|HOPCNT_INFINITY
expr_stmt|;
block|}
else|else
block|{
comment|/* we have the answer, so compute the 				 * right metric and next hop. 				 */
name|v12buf
operator|.
name|n
operator|->
name|n_family
operator|=
name|RIP_AF_INET
expr_stmt|;
name|v12buf
operator|.
name|n
operator|->
name|n_dst
operator|=
name|dst
expr_stmt|;
name|v12buf
operator|.
name|n
operator|->
name|n_metric
operator|=
operator|(
name|rt
operator|->
name|rt_metric
operator|+
literal|1
operator|+
operator|(
operator|(
name|aifp
operator|!=
literal|0
operator|)
condition|?
name|aifp
operator|->
name|int_metric
else|:
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|v12buf
operator|.
name|n
operator|->
name|n_metric
operator|>
name|HOPCNT_INFINITY
condition|)
name|v12buf
operator|.
name|n
operator|->
name|n_metric
operator|=
name|HOPCNT_INFINITY
expr_stmt|;
if|if
condition|(
name|v12buf
operator|.
name|buf
operator|->
name|rip_vers
operator|!=
name|RIPv1
condition|)
block|{
name|v12buf
operator|.
name|n
operator|->
name|n_tag
operator|=
name|rt
operator|->
name|rt_tag
expr_stmt|;
name|v12buf
operator|.
name|n
operator|->
name|n_mask
operator|=
name|mask
expr_stmt|;
if|if
condition|(
name|aifp
operator|!=
literal|0
operator|&&
name|on_net
argument_list|(
name|rt
operator|->
name|rt_gate
argument_list|,
name|aifp
operator|->
name|int_net
argument_list|,
name|aifp
operator|->
name|int_mask
argument_list|)
operator|&&
name|rt
operator|->
name|rt_gate
operator|!=
name|aifp
operator|->
name|int_addr
condition|)
name|v12buf
operator|.
name|n
operator|->
name|n_nhop
operator|=
name|rt
operator|->
name|rt_gate
expr_stmt|;
block|}
block|}
name|HTONL
argument_list|(
name|v12buf
operator|.
name|n
operator|->
name|n_metric
argument_list|)
expr_stmt|;
comment|/* Stop paying attention if we fill the output buffer. 			 */
if|if
condition|(
operator|++
name|v12buf
operator|.
name|n
operator|>=
name|v12buf
operator|.
name|lim
condition|)
break|break;
block|}
do|while
condition|(
operator|++
name|n
operator|<
name|lim
condition|)
do|;
comment|/* Send the answer about specific routes. 		 */
if|if
condition|(
name|ap
operator|!=
literal|0
operator|&&
name|ap
operator|->
name|type
operator|==
name|RIP_AUTH_MD5
condition|)
name|end_md5_auth
argument_list|(
operator|&
name|v12buf
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|->
name|sin_port
operator|!=
name|htons
argument_list|(
name|RIP_PORT
argument_list|)
condition|)
block|{
comment|/* query */
operator|(
name|void
operator|)
name|output
argument_list|(
name|OUT_QUERY
argument_list|,
name|from
argument_list|,
name|aifp
argument_list|,
name|v12buf
operator|.
name|buf
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|v12buf
operator|.
name|n
operator|-
operator|(
name|char
operator|*
operator|)
name|v12buf
operator|.
name|buf
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|supplier
condition|)
block|{
operator|(
name|void
operator|)
name|output
argument_list|(
name|OUT_UNICAST
argument_list|,
name|from
argument_list|,
name|aifp
argument_list|,
name|v12buf
operator|.
name|buf
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|v12buf
operator|.
name|n
operator|-
operator|(
name|char
operator|*
operator|)
name|v12buf
operator|.
name|buf
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Only answer a router if we are a supplier 			 * to keep an unwary host that is just starting 			 * from picking us an a router. 			 */
empty_stmt|;
block|}
return|return;
case|case
name|RIPCMD_TRACEON
case|:
case|case
name|RIPCMD_TRACEOFF
case|:
comment|/* Notice that trace messages are turned off for all possible 		 * abuse if _PATH_TRACE is undefined in pathnames.h. 		 * Notice also that because of the way the trace file is 		 * handled in trace.c, no abuse is plausible even if 		 * _PATH_TRACE_ is defined. 		 * 		 * First verify message came from a privileged port. */
if|if
condition|(
name|ntohs
argument_list|(
name|from
operator|->
name|sin_port
argument_list|)
operator|>
name|IPPORT_RESERVED
condition|)
block|{
name|msglog
argument_list|(
literal|"trace command from untrusted port on %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|aifp
operator|==
literal|0
condition|)
block|{
name|msglog
argument_list|(
literal|"trace command from unknown router %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rip
operator|->
name|rip_cmd
operator|==
name|RIPCMD_TRACEON
condition|)
block|{
name|rip
operator|->
name|rip_tracefile
index|[
name|cc
operator|-
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|set_tracefile
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rip
operator|->
name|rip_tracefile
argument_list|,
literal|"trace command: %s\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trace_off
argument_list|(
literal|"tracing turned off by %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|RIPCMD_RESPONSE
case|:
if|if
condition|(
name|cc
operator|%
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|rip
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_len
argument_list|,
name|FROM_NADDR
argument_list|,
literal|"response of bad length (%d) from %s"
argument_list|,
name|cc
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* verify message came from a router */
if|if
condition|(
name|from
operator|->
name|sin_port
operator|!=
name|ntohs
argument_list|(
name|RIP_PORT
argument_list|)
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_router
argument_list|,
name|FROM_NADDR
argument_list|,
literal|"    discard RIP response from unknown port"
literal|" %d on host %s"
argument_list|,
name|ntohs
argument_list|(
name|from
operator|->
name|sin_port
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rip_sock
operator|<
literal|0
condition|)
block|{
name|trace_pkt
argument_list|(
literal|"    discard response while RIP off"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Are we talking to ourself or a remote gateway? 		 */
name|ifp1
operator|=
name|ifwithaddr
argument_list|(
name|FROM_NADDR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp1
condition|)
block|{
if|if
condition|(
name|ifp1
operator|->
name|int_state
operator|&
name|IS_REMOTE
condition|)
block|{
comment|/* remote gateway */
name|aifp
operator|=
name|ifp1
expr_stmt|;
if|if
condition|(
name|check_remote
argument_list|(
name|aifp
argument_list|)
condition|)
block|{
name|aifp
operator|->
name|int_act_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
operator|(
name|void
operator|)
name|if_ok
argument_list|(
name|aifp
argument_list|,
literal|"remote "
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|trace_pkt
argument_list|(
literal|"    discard our own RIP response"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Accept routing packets from routers directly connected 		 * via broadcast or point-to-point networks, and from 		 * those listed in /etc/gateways. 		 */
if|if
condition|(
name|aifp
operator|==
literal|0
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|unk_router
argument_list|,
name|FROM_NADDR
argument_list|,
literal|"   discard response from %s"
literal|" via unexpected interface"
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|IS_RIP_IN_OFF
argument_list|(
name|aifp
operator|->
name|int_state
argument_list|)
condition|)
block|{
name|trace_pkt
argument_list|(
literal|"    discard RIPv%d response"
literal|" via disabled interface %s"
argument_list|,
name|rip
operator|->
name|rip_vers
argument_list|,
name|aifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|n
operator|>=
name|lim
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_len
argument_list|,
name|FROM_NADDR
argument_list|,
literal|"empty response from %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|aifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV1_IN
operator|)
operator|&&
name|rip
operator|->
name|rip_vers
operator|==
name|RIPv1
operator|)
operator|||
operator|(
operator|(
name|aifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV2_IN
operator|)
operator|&&
name|rip
operator|->
name|rip_vers
operator|!=
name|RIPv1
operator|)
condition|)
block|{
name|trace_pkt
argument_list|(
literal|"    discard RIPv%d response"
argument_list|,
name|rip
operator|->
name|rip_vers
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Ignore routes via dead interface. 		 */
if|if
condition|(
name|aifp
operator|->
name|int_state
operator|&
name|IS_BROKE
condition|)
block|{
name|trace_pkt
argument_list|(
literal|"discard response via broken interface %s"
argument_list|,
name|aifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the interface cares, ignore bad routers. 		 * Trace but do not log this problem, because where it 		 * happens, it happens frequently. 		 */
if|if
condition|(
name|aifp
operator|->
name|int_state
operator|&
name|IS_DISTRUST
condition|)
block|{
name|tg
operator|=
name|tgates
expr_stmt|;
while|while
condition|(
name|tg
operator|->
name|tgate_addr
operator|!=
name|FROM_NADDR
condition|)
block|{
name|tg
operator|=
name|tg
operator|->
name|tgate_next
expr_stmt|;
if|if
condition|(
name|tg
operator|==
literal|0
condition|)
block|{
name|trace_pkt
argument_list|(
literal|"    discard RIP response"
literal|" from untrusted router %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* Authenticate the packet if we have a secret. 		 * If we do not have any secrets, ignore the error in 		 * RFC 1723 and accept it regardless. 		 */
if|if
condition|(
name|aifp
operator|->
name|int_auth
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|RIP_AUTH_NONE
operator|&&
name|rip
operator|->
name|rip_vers
operator|!=
name|RIPv1
operator|&&
operator|!
name|ck_passwd
argument_list|(
name|aifp
argument_list|,
name|rip
argument_list|,
name|lim
argument_list|,
name|FROM_NADDR
argument_list|,
operator|&
name|use_auth
argument_list|)
condition|)
return|return;
do|do
block|{
if|if
condition|(
name|n
operator|->
name|n_family
operator|==
name|RIP_AF_AUTH
condition|)
continue|continue;
name|NTOHL
argument_list|(
name|n
operator|->
name|n_metric
argument_list|)
expr_stmt|;
name|dst
operator|=
name|n
operator|->
name|n_dst
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|n_family
operator|!=
name|RIP_AF_INET
operator|&&
operator|(
name|n
operator|->
name|n_family
operator|!=
name|RIP_AF_UNSPEC
operator|||
name|dst
operator|!=
name|RIP_DEFAULT
operator|)
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_router
argument_list|,
name|FROM_NADDR
argument_list|,
literal|"route from %s to unsupported"
literal|" address family=%d destination=%s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|,
name|n
operator|->
name|n_family
argument_list|,
name|naddr_ntoa
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|check_dst
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_router
argument_list|,
name|FROM_NADDR
argument_list|,
literal|"bad destination %s from %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|dst
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|n
operator|->
name|n_metric
operator|==
literal|0
operator|||
name|n
operator|->
name|n_metric
operator|>
name|HOPCNT_INFINITY
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_router
argument_list|,
name|FROM_NADDR
argument_list|,
literal|"bad metric %d from %s"
literal|" for destination %s"
argument_list|,
name|n
operator|->
name|n_metric
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Notice the next-hop. 			 */
name|gate
operator|=
name|FROM_NADDR
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|n_nhop
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rip
operator|->
name|rip_vers
operator|==
name|RIPv1
condition|)
block|{
name|n
operator|->
name|n_nhop
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Use it only if it is valid. */
if|if
condition|(
name|on_net
argument_list|(
name|n
operator|->
name|n_nhop
argument_list|,
name|aifp
operator|->
name|int_net
argument_list|,
name|aifp
operator|->
name|int_mask
argument_list|)
operator|&&
name|check_dst
argument_list|(
name|n
operator|->
name|n_nhop
argument_list|)
condition|)
block|{
name|gate
operator|=
name|n
operator|->
name|n_nhop
expr_stmt|;
block|}
else|else
block|{
name|msglim
argument_list|(
operator|&
name|bad_nhop
argument_list|,
name|FROM_NADDR
argument_list|,
literal|"router %s to %s"
literal|" has bad next hop %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|dst
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|n
operator|->
name|n_nhop
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_nhop
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rip
operator|->
name|rip_vers
operator|==
name|RIPv1
operator|||
literal|0
operator|==
operator|(
name|mask
operator|=
name|ntohl
argument_list|(
name|n
operator|->
name|n_mask
argument_list|)
operator|)
condition|)
block|{
name|mask
operator|=
name|ripv1_mask_host
argument_list|(
name|dst
argument_list|,
name|aifp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|dst
argument_list|)
operator|&
operator|~
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_mask
argument_list|,
name|FROM_NADDR
argument_list|,
literal|"router %s sent bad netmask"
literal|" %#lx with %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|mask
argument_list|,
name|naddr_ntoa
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rip
operator|->
name|rip_vers
operator|==
name|RIPv1
condition|)
name|n
operator|->
name|n_tag
operator|=
literal|0
expr_stmt|;
comment|/* Adjust metric according to incoming interface.. 			 */
name|n
operator|->
name|n_metric
operator|+=
name|aifp
operator|->
name|int_metric
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|n_metric
operator|>
name|HOPCNT_INFINITY
condition|)
name|n
operator|->
name|n_metric
operator|=
name|HOPCNT_INFINITY
expr_stmt|;
comment|/* Should we trust this route from this router? */
if|if
condition|(
name|tg
operator|&&
operator|(
name|tn
operator|=
name|tg
operator|->
name|tgate_nets
operator|)
operator|->
name|mask
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TGATE_NETS
condition|;
name|i
operator|++
operator|,
name|tn
operator|++
control|)
block|{
if|if
condition|(
name|on_net
argument_list|(
name|dst
argument_list|,
name|tn
operator|->
name|net
argument_list|,
name|tn
operator|->
name|mask
argument_list|)
operator|&&
name|tn
operator|->
name|mask
operator|<=
name|mask
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|MAX_TGATE_NETS
operator|||
name|tn
operator|->
name|mask
operator|==
literal|0
condition|)
block|{
name|trace_pkt
argument_list|(
literal|"   ignored unauthorized %s"
argument_list|,
name|addrname
argument_list|(
name|dst
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Recognize and ignore a default route we faked 			 * which is being sent back to us by a machine with 			 * broken split-horizon. 			 * Be a little more paranoid than that, and reject 			 * default routes with the same metric we advertised. 			 */
if|if
condition|(
name|aifp
operator|->
name|int_d_metric
operator|!=
literal|0
operator|&&
name|dst
operator|==
name|RIP_DEFAULT
operator|&&
operator|(
name|int
operator|)
name|n
operator|->
name|n_metric
operator|>=
name|aifp
operator|->
name|int_d_metric
condition|)
continue|continue;
comment|/* We can receive aggregated RIPv2 routes that must 			 * be broken down before they are transmitted by 			 * RIPv1 via an interface on a subnet. 			 * We might also receive the same routes aggregated 			 * via other RIPv2 interfaces. 			 * This could cause duplicate routes to be sent on 			 * the RIPv1 interfaces.  "Longest matching variable 			 * length netmasks" lets RIPv2 listeners understand, 			 * but breaking down the aggregated routes for RIPv1 			 * listeners can produce duplicate routes. 			 * 			 * Breaking down aggregated routes here bloats 			 * the daemon table, but does not hurt the kernel 			 * table, since routes are always aggregated for 			 * the kernel. 			 * 			 * Notice that this does not break down network 			 * routes corresponding to subnets.  This is part 			 * of the defense against RS_NET_SYN. 			 */
if|if
condition|(
name|have_ripv1_out
operator|&&
operator|(
operator|(
operator|(
name|rt
operator|=
name|rtget
argument_list|(
name|dst
argument_list|,
name|mask
argument_list|)
operator|)
operator|==
literal|0
operator|||
operator|!
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_NET_SYN
operator|)
operator|)
operator|)
operator|&&
operator|(
name|v1_mask
operator|=
name|ripv1_mask_net
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
name|mask
condition|)
block|{
name|ddst_h
operator|=
name|v1_mask
operator|&
operator|-
name|v1_mask
expr_stmt|;
name|i
operator|=
operator|(
name|v1_mask
operator|&
operator|~
name|mask
operator|)
operator|/
name|ddst_h
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|511
condition|)
block|{
comment|/* Punt if we would have to generate 					 * an unreasonable number of routes. 					 */
if|if
condition|(
name|TRACECONTENTS
condition|)
name|trace_misc
argument_list|(
literal|"accept %s-->%s as 1"
literal|" instead of %d routes"
argument_list|,
name|addrname
argument_list|(
name|dst
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|FROM_NADDR
argument_list|)
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
name|v1_mask
expr_stmt|;
block|}
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|new
operator|.
name|rts_gate
operator|=
name|gate
expr_stmt|;
name|new
operator|.
name|rts_router
operator|=
name|FROM_NADDR
expr_stmt|;
name|new
operator|.
name|rts_metric
operator|=
name|n
operator|->
name|n_metric
expr_stmt|;
name|new
operator|.
name|rts_tag
operator|=
name|n
operator|->
name|n_tag
expr_stmt|;
name|new
operator|.
name|rts_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|new
operator|.
name|rts_ifp
operator|=
name|aifp
expr_stmt|;
name|new
operator|.
name|rts_de_ag
operator|=
name|i
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|input_route
argument_list|(
name|dst
argument_list|,
name|mask
argument_list|,
operator|&
name|new
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|j
operator|>
name|i
condition|)
break|break;
name|dst
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|dst
argument_list|)
operator|+
name|ddst_h
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|++
name|n
operator|<
name|lim
condition|)
do|;
break|break;
block|}
undef|#
directive|undef
name|FROM_NADDR
block|}
end_function

begin_comment
comment|/* Process a single input route.  */
end_comment

begin_function
specifier|static
name|void
name|input_route
parameter_list|(
name|naddr
name|dst
parameter_list|,
comment|/* network order */
name|naddr
name|mask
parameter_list|,
name|struct
name|rt_spare
modifier|*
name|new
parameter_list|,
name|struct
name|netinfo
modifier|*
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
name|struct
name|rt_spare
modifier|*
name|rts
decl_stmt|,
modifier|*
name|rts0
decl_stmt|;
name|struct
name|interface
modifier|*
name|ifp1
decl_stmt|;
comment|/* See if the other guy is telling us to send our packets to him. 	 * Sometimes network routes arrive over a point-to-point link for 	 * the network containing the address(es) of the link. 	 * 	 * If our interface is broken, switch to using the other guy. 	 */
name|ifp1
operator|=
name|ifwithaddr
argument_list|(
name|dst
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp1
operator|!=
literal|0
operator|&&
operator|(
operator|!
operator|(
name|ifp1
operator|->
name|int_state
operator|&
name|IS_BROKE
operator|)
operator|||
operator|(
name|ifp1
operator|->
name|int_state
operator|&
name|IS_PASSIVE
operator|)
operator|)
condition|)
return|return;
comment|/* Look for the route in our table. 	 */
name|rt
operator|=
name|rtget
argument_list|(
name|dst
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* Consider adding the route if we do not already have it. 	 */
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
block|{
comment|/* Ignore unknown routes being poisoned. 		 */
if|if
condition|(
name|new
operator|->
name|rts_metric
operator|==
name|HOPCNT_INFINITY
condition|)
return|return;
comment|/* Ignore the route if it points to us */
if|if
condition|(
name|n
operator|->
name|n_nhop
operator|!=
literal|0
operator|&&
literal|0
operator|!=
name|ifwithaddr
argument_list|(
name|n
operator|->
name|n_nhop
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
comment|/* If something has not gone crazy and tried to fill 		 * our memory, accept the new route. 		 */
if|if
condition|(
name|total_routes
operator|<
name|MAX_ROUTES
condition|)
name|rtadd
argument_list|(
name|dst
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We already know about the route.  Consider this update. 	 * 	 * If (rt->rt_state& RS_NET_SYN), then this route 	 * is the same as a network route we have inferred 	 * for subnets we know, in order to tell RIPv1 routers 	 * about the subnets. 	 * 	 * It is impossible to tell if the route is coming 	 * from a distant RIPv2 router with the standard 	 * netmask because that router knows about the entire 	 * network, or if it is a round-about echo of a 	 * synthetic, RIPv1 network route of our own. 	 * The worst is that both kinds of routes might be 	 * received, and the bad one might have the smaller 	 * metric.  Partly solve this problem by never 	 * aggregating into such a route.  Also keep it 	 * around as long as the interface exists. 	 */
name|rts0
operator|=
name|rt
operator|->
name|rt_spares
expr_stmt|;
for|for
control|(
name|rts
operator|=
name|rts0
operator|,
name|i
operator|=
name|NUM_SPARES
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
operator|,
name|rts
operator|++
control|)
block|{
if|if
condition|(
name|rts
operator|->
name|rts_router
operator|==
name|new
operator|->
name|rts_router
condition|)
break|break;
comment|/* Note the worst slot to reuse, 		 * other than the current slot. 		 */
if|if
condition|(
name|rts0
operator|==
name|rt
operator|->
name|rt_spares
operator|||
name|BETTER_LINK
argument_list|(
name|rt
argument_list|,
name|rts0
argument_list|,
name|rts
argument_list|)
condition|)
name|rts0
operator|=
name|rts
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* Found a route from the router already in the table. 		 */
comment|/* If the new route is a route broken down from an 		 * aggregated route, and if the previous route is either 		 * not a broken down route or was broken down from a finer 		 * netmask, and if the previous route is current, 		 * then forget this one. 		 */
if|if
condition|(
name|new
operator|->
name|rts_de_ag
operator|>
name|rts
operator|->
name|rts_de_ag
operator|&&
name|now_stale
operator|<=
name|rts
operator|->
name|rts_time
condition|)
return|return;
comment|/* Keep poisoned routes around only long enough to pass 		 * the poison on.  Use a new timestamp for good routes. 		 */
if|if
condition|(
name|rts
operator|->
name|rts_metric
operator|==
name|HOPCNT_INFINITY
operator|&&
name|new
operator|->
name|rts_metric
operator|==
name|HOPCNT_INFINITY
condition|)
name|new
operator|->
name|rts_time
operator|=
name|rts
operator|->
name|rts_time
expr_stmt|;
comment|/* If this is an update for the router we currently prefer, 		 * then note it. 		 */
if|if
condition|(
name|i
operator|==
name|NUM_SPARES
condition|)
block|{
name|rtchange
argument_list|(
name|rt
argument_list|,
name|rt
operator|->
name|rt_state
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the route got worse, check for something better. 			 */
if|if
condition|(
name|new
operator|->
name|rts_metric
operator|>
name|rts
operator|->
name|rts_metric
condition|)
name|rtswitch
argument_list|(
name|rt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This is an update for a spare route. 		 * Finished if the route is unchanged. 		 */
if|if
condition|(
name|rts
operator|->
name|rts_gate
operator|==
name|new
operator|->
name|rts_gate
operator|&&
name|rts
operator|->
name|rts_metric
operator|==
name|new
operator|->
name|rts_metric
operator|&&
name|rts
operator|->
name|rts_tag
operator|==
name|new
operator|->
name|rts_tag
condition|)
block|{
name|trace_upslot
argument_list|(
name|rt
argument_list|,
name|rts
argument_list|,
name|new
argument_list|)
expr_stmt|;
operator|*
name|rts
operator|=
operator|*
name|new
expr_stmt|;
return|return;
block|}
comment|/* Forget it if it has gone bad. 		 */
if|if
condition|(
name|new
operator|->
name|rts_metric
operator|==
name|HOPCNT_INFINITY
condition|)
block|{
name|rts_delete
argument_list|(
name|rt
argument_list|,
name|rts
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* The update is for a route we know about, 		 * but not from a familiar router. 		 * 		 * Ignore the route if it points to us. 		 */
if|if
condition|(
name|n
operator|->
name|n_nhop
operator|!=
literal|0
operator|&&
literal|0
operator|!=
name|ifwithaddr
argument_list|(
name|n
operator|->
name|n_nhop
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
comment|/* the loop above set rts0=worst spare */
name|rts
operator|=
name|rts0
expr_stmt|;
comment|/* Save the route as a spare only if it has 		 * a better metric than our worst spare. 		 * This also ignores poisoned routes (those 		 * received with metric HOPCNT_INFINITY). 		 */
if|if
condition|(
name|new
operator|->
name|rts_metric
operator|>=
name|rts
operator|->
name|rts_metric
condition|)
return|return;
block|}
name|trace_upslot
argument_list|(
name|rt
argument_list|,
name|rts
argument_list|,
name|new
argument_list|)
expr_stmt|;
operator|*
name|rts
operator|=
operator|*
name|new
expr_stmt|;
comment|/* try to switch to a better route */
name|rtswitch
argument_list|(
name|rt
argument_list|,
name|rts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
comment|/* 0 if bad */
name|ck_passwd
parameter_list|(
name|struct
name|interface
modifier|*
name|aifp
parameter_list|,
name|struct
name|rip
modifier|*
name|rip
parameter_list|,
name|void
modifier|*
name|lim
parameter_list|,
name|naddr
name|from
parameter_list|,
name|struct
name|msg_limit
modifier|*
name|use_authp
parameter_list|)
block|{
define|#
directive|define
name|NA
value|(rip->rip_auths)
name|struct
name|netauth
modifier|*
name|na2
decl_stmt|;
name|struct
name|auth
modifier|*
name|ap
decl_stmt|;
name|MD5_CTX
name|md5_ctx
decl_stmt|;
name|u_char
name|hash
index|[
name|RIP_AUTH_PW_LEN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|NA
operator|>=
name|lim
operator|||
name|NA
operator|->
name|a_family
operator|!=
name|RIP_AF_AUTH
condition|)
block|{
name|msglim
argument_list|(
name|use_authp
argument_list|,
name|from
argument_list|,
literal|"missing password from %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* accept any current (+/- 24 hours) password 	 */
for|for
control|(
name|ap
operator|=
name|aifp
operator|->
name|int_auth
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_AUTH_KEYS
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|type
operator|!=
name|NA
operator|->
name|a_type
operator|||
operator|(
name|u_long
operator|)
name|ap
operator|->
name|start
operator|>
operator|(
name|u_long
operator|)
name|clk
operator|.
name|tv_sec
operator|+
name|DAY
operator|||
operator|(
name|u_long
operator|)
name|ap
operator|->
name|end
operator|+
name|DAY
operator|<
operator|(
name|u_long
operator|)
name|clk
operator|.
name|tv_sec
condition|)
continue|continue;
if|if
condition|(
name|NA
operator|->
name|a_type
operator|==
name|RIP_AUTH_PW
condition|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|NA
operator|->
name|au
operator|.
name|au_pw
argument_list|,
name|ap
operator|->
name|key
argument_list|,
name|RIP_AUTH_PW_LEN
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* accept MD5 secret with the right key ID 			 */
if|if
condition|(
name|NA
operator|->
name|au
operator|.
name|a_md5
operator|.
name|md5_keyid
operator|!=
name|ap
operator|->
name|keyid
condition|)
continue|continue;
name|len
operator|=
name|ntohs
argument_list|(
name|NA
operator|->
name|au
operator|.
name|a_md5
operator|.
name|md5_pkt_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|rip
argument_list|)
operator|)
operator|%
sizeof|sizeof
argument_list|(
operator|*
name|NA
argument_list|)
operator|!=
literal|0
operator|||
name|len
operator|!=
operator|(
name|char
operator|*
operator|)
name|lim
operator|-
operator|(
name|char
operator|*
operator|)
name|rip
operator|-
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|NA
argument_list|)
condition|)
block|{
name|msglim
argument_list|(
name|use_authp
argument_list|,
name|from
argument_list|,
literal|"wrong MD5 RIPv2 packet length of %d"
literal|" instead of %d from %s"
argument_list|,
name|len
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lim
operator|-
operator|(
name|char
operator|*
operator|)
name|rip
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|NA
argument_list|)
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|na2
operator|=
operator|(
expr|struct
name|netauth
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rip
operator|+
name|len
operator|)
expr_stmt|;
comment|/* Given a good hash value, these are not security 			 * problems so be generous and accept the routes, 			 * after complaining. 			 */
if|if
condition|(
name|TRACEPACKETS
condition|)
block|{
if|if
condition|(
name|NA
operator|->
name|au
operator|.
name|a_md5
operator|.
name|md5_auth_len
operator|!=
name|RIP_AUTH_MD5_LEN
condition|)
name|msglim
argument_list|(
name|use_authp
argument_list|,
name|from
argument_list|,
literal|"unknown MD5 RIPv2 auth len %#x"
literal|" instead of %#x from %s"
argument_list|,
name|NA
operator|->
name|au
operator|.
name|a_md5
operator|.
name|md5_auth_len
argument_list|,
name|RIP_AUTH_MD5_LEN
argument_list|,
name|naddr_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|na2
operator|->
name|a_family
operator|!=
name|RIP_AF_AUTH
condition|)
name|msglim
argument_list|(
name|use_authp
argument_list|,
name|from
argument_list|,
literal|"unknown MD5 RIPv2 family %#x"
literal|" instead of %#x from %s"
argument_list|,
name|na2
operator|->
name|a_family
argument_list|,
name|RIP_AF_AUTH
argument_list|,
name|naddr_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|na2
operator|->
name|a_type
operator|!=
name|ntohs
argument_list|(
literal|1
argument_list|)
condition|)
name|msglim
argument_list|(
name|use_authp
argument_list|,
name|from
argument_list|,
literal|"MD5 RIPv2 hash has %#x"
literal|" instead of %#x from %s"
argument_list|,
name|na2
operator|->
name|a_type
argument_list|,
name|ntohs
argument_list|(
literal|1
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MD5Init
argument_list|(
operator|&
name|md5_ctx
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5_ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|rip
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5_ctx
argument_list|,
name|ap
operator|->
name|key
argument_list|,
name|RIP_AUTH_MD5_LEN
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|hash
argument_list|,
operator|&
name|md5_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|hash
argument_list|,
name|na2
operator|->
name|au
operator|.
name|au_pw
argument_list|,
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
name|msglim
argument_list|(
name|use_authp
argument_list|,
name|from
argument_list|,
literal|"bad password from %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|NA
block|}
end_function

end_unit

