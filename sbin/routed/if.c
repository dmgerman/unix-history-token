begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$Revision: 2.27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_empty
empty|#ident "$Revision: 2.27 $"
end_empty

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|ifhead
name|ifnet
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|ifnet
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* all interfaces */
end_comment

begin_decl_stmt
name|struct
name|ifhead
name|remote_if
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|remote_if
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* remote interfaces */
end_comment

begin_comment
comment|/* hash table for all interfaces, big enough to tolerate ridiculous  * numbers of IP aliases.  Crazy numbers of aliases such as 7000  * still will not do well, but not just in looking up interfaces  * by name or address.  */
end_comment

begin_define
define|#
directive|define
name|AHASH_LEN
value|211
end_define

begin_comment
comment|/* must be prime */
end_comment

begin_define
define|#
directive|define
name|AHASH
parameter_list|(
name|a
parameter_list|)
value|&ahash_tbl[(a)%AHASH_LEN]
end_define

begin_decl_stmt
specifier|static
name|struct
name|interface
modifier|*
name|ahash_tbl
index|[
name|AHASH_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BHASH_LEN
value|211
end_define

begin_comment
comment|/* must be prime */
end_comment

begin_define
define|#
directive|define
name|BHASH
parameter_list|(
name|a
parameter_list|)
value|&bhash_tbl[(a)%BHASH_LEN]
end_define

begin_decl_stmt
specifier|static
name|struct
name|interface
modifier|*
name|bhash_tbl
index|[
name|BHASH_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash for physical interface names.  * Assume there are never more 100 or 200 real interfaces, and that  * aliases are put on the end of the hash chains.  */
end_comment

begin_define
define|#
directive|define
name|NHASH_LEN
value|97
end_define

begin_decl_stmt
specifier|static
name|struct
name|interface
modifier|*
name|nhash_tbl
index|[
name|NHASH_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tot_interfaces
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of remote and local interfaces */
end_comment

begin_decl_stmt
name|int
name|rip_interfaces
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of interfaces doing RIP */
end_comment

begin_decl_stmt
specifier|static
name|int
name|foundloopback
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* valid flag for loopaddr */
end_comment

begin_decl_stmt
name|naddr
name|loopaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our address on loopback */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rt_spare
name|loop_rts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|ifinit_timer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|last_ifinit
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IF_RESCAN_DELAY
parameter_list|()
value|(last_ifinit.tv_sec == now.tv_sec		\&& last_ifinit.tv_usec == now.tv_usec	\&& timercmp(&ifinit_timer,&now,>))
end_define

begin_decl_stmt
name|int
name|have_ripv1_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* have a RIPv1 interface */
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_ripv1_in
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|if_bad
parameter_list|(
name|struct
name|interface
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|addrouteforif
parameter_list|(
name|struct
name|interface
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|struct
name|interface
modifier|*
modifier|*
name|nhash
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
name|i
operator|=
operator|(
operator|(
name|i
operator|<<
literal|1
operator|)
operator|&
literal|0x7fffffff
operator|)
operator||
operator|(
operator|(
name|i
operator|>>
literal|31
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|i
operator|^=
operator|*
name|p
expr_stmt|;
block|}
return|return
operator|&
name|nhash_tbl
index|[
name|i
operator|%
name|NHASH_LEN
index|]
return|;
block|}
end_function

begin_comment
comment|/* Link a new interface into the lists and hash tables.  */
end_comment

begin_function
name|void
name|if_link
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|interface
modifier|*
modifier|*
name|hifp
decl_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ifnet
argument_list|,
name|ifp
argument_list|,
name|int_list
argument_list|)
expr_stmt|;
name|hifp
operator|=
name|AHASH
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_ahash_prev
operator|=
name|hifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_ahash
operator|=
operator|*
name|hifp
operator|)
operator|!=
literal|0
condition|)
operator|(
operator|*
name|hifp
operator|)
operator|->
name|int_ahash_prev
operator|=
operator|&
name|ifp
operator|->
name|int_ahash
expr_stmt|;
operator|*
name|hifp
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_BROADCAST
condition|)
block|{
name|hifp
operator|=
name|BHASH
argument_list|(
name|ifp
operator|->
name|int_brdaddr
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_bhash_prev
operator|=
name|hifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_bhash
operator|=
operator|*
name|hifp
operator|)
operator|!=
literal|0
condition|)
operator|(
operator|*
name|hifp
operator|)
operator|->
name|int_bhash_prev
operator|=
operator|&
name|ifp
operator|->
name|int_bhash
expr_stmt|;
operator|*
name|hifp
operator|=
name|ifp
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|remote_if
argument_list|,
name|ifp
argument_list|,
name|remote_list
argument_list|)
expr_stmt|;
name|hifp
operator|=
name|nhash
argument_list|(
name|ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALIAS
condition|)
block|{
comment|/* put aliases on the end of the hash chain */
while|while
condition|(
operator|*
name|hifp
operator|!=
literal|0
condition|)
name|hifp
operator|=
operator|&
operator|(
operator|*
name|hifp
operator|)
operator|->
name|int_nhash
expr_stmt|;
block|}
name|ifp
operator|->
name|int_nhash_prev
operator|=
name|hifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_nhash
operator|=
operator|*
name|hifp
operator|)
operator|!=
literal|0
condition|)
operator|(
operator|*
name|hifp
operator|)
operator|->
name|int_nhash_prev
operator|=
operator|&
name|ifp
operator|->
name|int_nhash
expr_stmt|;
operator|*
name|hifp
operator|=
name|ifp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the interface with an address  */
end_comment

begin_function
name|struct
name|interface
modifier|*
name|ifwithaddr
parameter_list|(
name|naddr
name|addr
parameter_list|,
name|int
name|bcast
parameter_list|,
comment|/* notice IFF_BROADCAST address */
name|int
name|remote
parameter_list|)
comment|/* include IS_REMOTE interfaces */
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|,
modifier|*
name|possible
init|=
literal|0
decl_stmt|;
name|remote
operator|=
operator|(
name|remote
operator|==
literal|0
operator|)
condition|?
name|IS_REMOTE
else|:
literal|0
expr_stmt|;
for|for
control|(
name|ifp
operator|=
operator|*
name|AHASH
argument_list|(
name|addr
argument_list|)
init|;
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_ahash
control|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_addr
operator|!=
name|addr
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|remote
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_state
operator|&
operator|(
name|IS_BROKE
operator||
name|IS_PASSIVE
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|ifp
return|;
name|possible
operator|=
name|ifp
expr_stmt|;
block|}
if|if
condition|(
name|possible
operator|||
operator|!
name|bcast
condition|)
return|return
name|possible
return|;
for|for
control|(
name|ifp
operator|=
operator|*
name|BHASH
argument_list|(
name|addr
argument_list|)
init|;
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_bhash
control|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_brdaddr
operator|!=
name|addr
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|remote
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_state
operator|&
operator|(
name|IS_BROKE
operator||
name|IS_PASSIVE
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|ifp
return|;
name|possible
operator|=
name|ifp
expr_stmt|;
block|}
return|return
name|possible
return|;
block|}
end_function

begin_comment
comment|/* find the interface with a name  */
end_comment

begin_function
specifier|static
name|struct
name|interface
modifier|*
name|ifwithname
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
comment|/* "ec0" or whatever */
name|naddr
name|addr
parameter_list|)
comment|/* 0 or network address */
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
name|ifp
operator|=
operator|*
name|nhash
argument_list|(
name|name
argument_list|)
init|;
name|ifp
operator|!=
literal|0
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_nhash
control|)
block|{
comment|/* If the network address is not specified, 			 * ignore any alias interfaces.  Otherwise, look 			 * for the interface with the target name and address. 			 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ifp
operator|->
name|int_name
argument_list|,
name|name
argument_list|)
operator|&&
operator|(
operator|(
name|addr
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALIAS
operator|)
operator|)
operator|||
operator|(
name|ifp
operator|->
name|int_addr
operator|==
name|addr
operator|)
operator|)
condition|)
return|return
name|ifp
return|;
block|}
comment|/* If there is no known interface, maybe there is a 		 * new interface.  So just once look for new interfaces. 		 */
if|if
condition|(
name|IF_RESCAN_DELAY
argument_list|()
condition|)
return|return
literal|0
return|;
name|ifinit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|interface
modifier|*
name|ifwithindex
parameter_list|(
name|u_short
name|ifindex
parameter_list|,
name|int
name|rescan_ok
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|ifp
argument_list|,
argument|&ifnet
argument_list|,
argument|int_list
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_index
operator|==
name|ifindex
condition|)
return|return
name|ifp
return|;
block|}
comment|/* If there is no known interface, maybe there is a 		 * new interface.  So just once look for new interfaces. 		 */
if|if
condition|(
operator|!
name|rescan_ok
operator|||
name|IF_RESCAN_DELAY
argument_list|()
condition|)
return|return
literal|0
return|;
name|ifinit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find an interface from which the specified address  * should have come from.  Used for figuring out which  * interface a packet came in on.  */
end_comment

begin_function
name|struct
name|interface
modifier|*
name|iflookup
parameter_list|(
name|naddr
name|addr
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|,
modifier|*
name|maybe
decl_stmt|;
name|int
name|once
init|=
literal|0
decl_stmt|;
name|maybe
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|ifp
argument_list|,
argument|&ifnet
argument_list|,
argument|int_list
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
comment|/* finished with a match */
if|if
condition|(
name|ifp
operator|->
name|int_dstaddr
operator|==
name|addr
condition|)
return|return
name|ifp
return|;
block|}
else|else
block|{
comment|/* finished with an exact match */
if|if
condition|(
name|ifp
operator|->
name|int_addr
operator|==
name|addr
condition|)
return|return
name|ifp
return|;
comment|/* Look for the longest approximate match. 				 */
if|if
condition|(
name|on_net
argument_list|(
name|addr
argument_list|,
name|ifp
operator|->
name|int_net
argument_list|,
name|ifp
operator|->
name|int_mask
argument_list|)
operator|&&
operator|(
name|maybe
operator|==
literal|0
operator|||
name|ifp
operator|->
name|int_mask
operator|>
name|maybe
operator|->
name|int_mask
operator|)
condition|)
name|maybe
operator|=
name|ifp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|maybe
operator|!=
literal|0
operator|||
name|once
operator|||
name|IF_RESCAN_DELAY
argument_list|()
condition|)
return|return
name|maybe
return|;
name|once
operator|=
literal|1
expr_stmt|;
comment|/* If there is no known interface, maybe there is a 		 * new interface.  So just once look for new interfaces. 		 */
name|ifinit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the classical netmask for an IP address.  */
end_comment

begin_function
name|naddr
comment|/* host byte order */
name|std_mask
parameter_list|(
name|naddr
name|addr
parameter_list|)
comment|/* network byte order */
block|{
name|addr
operator|=
name|ntohl
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* was a host, not a network */
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
comment|/* default route has mask 0 */
return|return
literal|0
return|;
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|IN_CLASSA_NET
return|;
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|IN_CLASSB_NET
return|;
return|return
name|IN_CLASSC_NET
return|;
block|}
end_function

begin_comment
comment|/* Find the netmask that would be inferred by RIPv1 listeners  *	on the given interface for a given network.  *	If no interface is specified, look for the best fitting	interface.  */
end_comment

begin_function
name|naddr
name|ripv1_mask_net
parameter_list|(
name|naddr
name|addr
parameter_list|,
comment|/* in network byte order */
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
comment|/* as seen on this interface */
block|{
name|struct
name|r1net
modifier|*
name|r1p
decl_stmt|;
name|naddr
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
comment|/* default always has 0 mask */
return|return
name|mask
return|;
if|if
condition|(
name|ifp
operator|!=
literal|0
operator|&&
name|ifp
operator|->
name|int_ripv1_mask
operator|!=
name|HOST_MASK
condition|)
block|{
comment|/* If the target network is that of the associated interface 		 * on which it arrived, then use the netmask of the interface. 		 */
if|if
condition|(
name|on_net
argument_list|(
name|addr
argument_list|,
name|ifp
operator|->
name|int_net
argument_list|,
name|ifp
operator|->
name|int_std_mask
argument_list|)
condition|)
name|mask
operator|=
name|ifp
operator|->
name|int_ripv1_mask
expr_stmt|;
block|}
else|else
block|{
comment|/* Examine all interfaces, and if it the target seems 		 * to have the same network number of an interface, use the 		 * netmask of that interface.  If there is more than one 		 * such interface, prefer the interface with the longest 		 * match. 		 */
name|LIST_FOREACH
argument_list|(
argument|ifp
argument_list|,
argument|&ifnet
argument_list|,
argument|int_list
argument_list|)
block|{
if|if
condition|(
name|on_net
argument_list|(
name|addr
argument_list|,
name|ifp
operator|->
name|int_std_net
argument_list|,
name|ifp
operator|->
name|int_std_mask
argument_list|)
operator|&&
name|ifp
operator|->
name|int_ripv1_mask
operator|>
name|mask
operator|&&
name|ifp
operator|->
name|int_ripv1_mask
operator|!=
name|HOST_MASK
condition|)
name|mask
operator|=
name|ifp
operator|->
name|int_ripv1_mask
expr_stmt|;
block|}
block|}
comment|/* check special definitions */
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|r1p
operator|=
name|r1nets
init|;
name|r1p
operator|!=
literal|0
condition|;
name|r1p
operator|=
name|r1p
operator|->
name|r1net_next
control|)
block|{
if|if
condition|(
name|on_net
argument_list|(
name|addr
argument_list|,
name|r1p
operator|->
name|r1net_net
argument_list|,
name|r1p
operator|->
name|r1net_match
argument_list|)
operator|&&
name|r1p
operator|->
name|r1net_mask
operator|>
name|mask
condition|)
name|mask
operator|=
name|r1p
operator|->
name|r1net_mask
expr_stmt|;
block|}
comment|/* Otherwise, make the classic A/B/C guess. 		 */
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
name|mask
operator|=
name|std_mask
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
name|mask
return|;
block|}
end_function

begin_function
name|naddr
name|ripv1_mask_host
parameter_list|(
name|naddr
name|addr
parameter_list|,
comment|/* in network byte order */
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
comment|/* as seen on this interface */
block|{
name|naddr
name|mask
init|=
name|ripv1_mask_net
argument_list|(
name|addr
argument_list|,
name|ifp
argument_list|)
decl_stmt|;
comment|/* If the computed netmask does not mask the address, 	 * then assume it is a host address 	 */
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|addr
argument_list|)
operator|&
operator|~
name|mask
operator|)
operator|!=
literal|0
condition|)
name|mask
operator|=
name|HOST_MASK
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function

begin_comment
comment|/* See if an IP address looks reasonable as a destination.  */
end_comment

begin_function
name|int
comment|/* 0=bad */
name|check_dst
parameter_list|(
name|naddr
name|addr
parameter_list|)
block|{
name|addr
operator|=
name|ntohl
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* default */
name|addr
operator|>>=
name|IN_CLASSA_NSHIFT
expr_stmt|;
return|return
operator|(
name|addr
operator|!=
literal|0
operator|&&
name|addr
operator|!=
name|IN_LOOPBACKNET
operator|)
return|;
block|}
return|return
operator|(
name|IN_CLASSB
argument_list|(
name|addr
argument_list|)
operator|||
name|IN_CLASSC
argument_list|(
name|addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* See a new interface duplicates an existing interface.  */
end_comment

begin_function
name|struct
name|interface
modifier|*
name|check_dup
parameter_list|(
name|naddr
name|addr
parameter_list|,
comment|/* IP address, so network byte order */
name|naddr
name|dstaddr
parameter_list|,
comment|/* ditto */
name|naddr
name|mask
parameter_list|,
comment|/* mask, so host byte order */
name|int
name|if_flags
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ifp
argument_list|,
argument|&ifnet
argument_list|,
argument|int_list
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_mask
operator|!=
name|mask
condition|)
continue|continue;
if|if
condition|(
operator|!
name|iff_up
argument_list|(
name|ifp
operator|->
name|int_if_flags
argument_list|)
condition|)
continue|continue;
comment|/* The local address can only be shared with a point-to-point 		 * link. 		 */
if|if
condition|(
operator|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
operator|)
operator|||
operator|!
operator|(
name|if_flags
operator|&
name|IS_REMOTE
operator|)
operator|)
operator|&&
name|ifp
operator|->
name|int_addr
operator|==
name|addr
operator|&&
operator|(
operator|(
operator|(
name|if_flags
operator||
name|ifp
operator|->
name|int_if_flags
operator|)
operator|&
name|IFF_POINTOPOINT
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|ifp
return|;
if|if
condition|(
name|on_net
argument_list|(
name|ifp
operator|->
name|int_dstaddr
argument_list|,
name|ntohl
argument_list|(
name|dstaddr
argument_list|)
argument_list|,
name|mask
argument_list|)
condition|)
return|return
name|ifp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* See that a remote gateway is reachable.  *	Note that the answer can change as real interfaces come and go.  */
end_comment

begin_function
name|int
comment|/* 0=bad */
name|check_remote
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
comment|/* do not worry about other kinds */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
operator|)
condition|)
return|return
literal|1
return|;
name|rt
operator|=
name|rtfind
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
operator|&&
name|rt
operator|->
name|rt_ifp
operator|!=
literal|0
operator|&&
name|on_net
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|,
name|rt
operator|->
name|rt_ifp
operator|->
name|int_net
argument_list|,
name|rt
operator|->
name|rt_ifp
operator|->
name|int_mask
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* the gateway cannot be reached directly from one of our 	 * interfaces 	 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
operator|)
condition|)
block|{
name|msglog
argument_list|(
literal|"unreachable gateway %s in "
name|_PATH_GATEWAYS
argument_list|,
name|naddr_ntoa
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|)
argument_list|)
expr_stmt|;
name|if_bad
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Delete an interface.  */
end_comment

begin_function
specifier|static
name|void
name|ifdel
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp1
decl_stmt|;
name|trace_if
argument_list|(
literal|"Del"
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_state
operator||=
name|IS_BROKE
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ifp
argument_list|,
name|int_list
argument_list|)
expr_stmt|;
operator|*
name|ifp
operator|->
name|int_ahash_prev
operator|=
name|ifp
operator|->
name|int_ahash
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_ahash
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|int_ahash
operator|->
name|int_ahash_prev
operator|=
name|ifp
operator|->
name|int_ahash_prev
expr_stmt|;
operator|*
name|ifp
operator|->
name|int_nhash_prev
operator|=
name|ifp
operator|->
name|int_nhash
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_nhash
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|int_nhash
operator|->
name|int_nhash_prev
operator|=
name|ifp
operator|->
name|int_nhash_prev
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_BROADCAST
condition|)
block|{
operator|*
name|ifp
operator|->
name|int_bhash_prev
operator|=
name|ifp
operator|->
name|int_bhash
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_bhash
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|int_bhash
operator|->
name|int_bhash_prev
operator|=
name|ifp
operator|->
name|int_bhash_prev
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
condition|)
name|LIST_REMOVE
argument_list|(
name|ifp
argument_list|,
name|remote_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALIAS
operator|)
condition|)
block|{
comment|/* delete aliases when the main interface dies 		 */
name|LIST_FOREACH
argument_list|(
argument|ifp1
argument_list|,
argument|&ifnet
argument_list|,
argument|int_list
argument_list|)
block|{
if|if
condition|(
name|ifp1
operator|!=
name|ifp
operator|&&
operator|!
name|strcmp
argument_list|(
name|ifp
operator|->
name|int_name
argument_list|,
name|ifp1
operator|->
name|int_name
argument_list|)
condition|)
name|ifdel
argument_list|(
name|ifp1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|&&
name|rip_sock
operator|>=
literal|0
condition|)
block|{
name|struct
name|group_req
name|gr
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|memset
argument_list|(
operator|&
name|gr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gr
argument_list|)
argument_list|)
expr_stmt|;
name|gr
operator|.
name|gr_interface
operator|=
name|ifp
operator|->
name|int_index
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|gr
operator|.
name|gr_group
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
ifdef|#
directive|ifdef
name|_HAVE_SIN_LEN
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_RIP_GROUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|rip_sock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|MCAST_LEAVE_GROUP
argument_list|,
operator|&
name|gr
argument_list|,
sizeof|sizeof
argument_list|(
name|gr
argument_list|)
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EADDRNOTAVAIL
operator|&&
operator|!
name|TRACEACTIONS
condition|)
name|LOGERR
argument_list|(
literal|"setsockopt(MCAST_LEAVE_GROUP RIP)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rip_sock_mcast
operator|==
name|ifp
condition|)
name|rip_sock_mcast
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|int_rip_sock
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|ifp
operator|->
name|int_rip_sock
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_rip_sock
operator|=
operator|-
literal|1
expr_stmt|;
name|fix_select
argument_list|()
expr_stmt|;
block|}
name|tot_interfaces
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|IS_RIP_OFF
argument_list|(
name|ifp
operator|->
name|int_state
argument_list|)
condition|)
name|rip_interfaces
operator|--
expr_stmt|;
comment|/* Zap all routes associated with this interface. 		 * Assume routes just using gateways beyond this interface 		 * will timeout naturally, and have probably already died. 		 */
operator|(
name|void
operator|)
name|rn_walktree
argument_list|(
name|rhead
argument_list|,
name|walk_bad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_rdisc_mg
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_bad_rdisc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark an interface ill.  */
end_comment

begin_function
name|void
name|if_sick
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|==
operator|(
name|ifp
operator|->
name|int_state
operator|&
operator|(
name|IS_SICK
operator||
name|IS_BROKE
operator|)
operator|)
condition|)
block|{
name|ifp
operator|->
name|int_state
operator||=
name|IS_SICK
expr_stmt|;
name|ifp
operator|->
name|int_act_time
operator|=
name|NEVER
expr_stmt|;
name|trace_if
argument_list|(
literal|"Chg"
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|LIM_SEC
argument_list|(
name|ifinit_timer
argument_list|,
name|now
operator|.
name|tv_sec
operator|+
name|CHECK_BAD_INTERVAL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark an interface dead.  */
end_comment

begin_function
specifier|static
name|void
name|if_bad
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp1
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
condition|)
return|return;
name|LIM_SEC
argument_list|(
name|ifinit_timer
argument_list|,
name|now
operator|.
name|tv_sec
operator|+
name|CHECK_BAD_INTERVAL
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_state
operator||=
operator|(
name|IS_BROKE
operator||
name|IS_SICK
operator|)
expr_stmt|;
name|ifp
operator|->
name|int_act_time
operator|=
name|NEVER
expr_stmt|;
name|ifp
operator|->
name|int_query_time
operator|=
name|NEVER
expr_stmt|;
name|ifp
operator|->
name|int_data
operator|.
name|ts
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|trace_if
argument_list|(
literal|"Chg"
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALIAS
operator|)
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|ifp1
argument_list|,
argument|&ifnet
argument_list|,
argument|int_list
argument_list|)
block|{
if|if
condition|(
name|ifp1
operator|!=
name|ifp
operator|&&
operator|!
name|strcmp
argument_list|(
name|ifp
operator|->
name|int_name
argument_list|,
name|ifp1
operator|->
name|int_name
argument_list|)
condition|)
name|if_bad
argument_list|(
name|ifp1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|rn_walktree
argument_list|(
name|rhead
argument_list|,
name|walk_bad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_bad_rdisc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark an interface alive  */
end_comment

begin_function
name|int
comment|/* 1=it was dead */
name|if_ok
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
operator|)
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_SICK
condition|)
block|{
name|trace_act
argument_list|(
literal|"%sinterface %s to %s working better"
argument_list|,
name|type
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|naddr_ntoa
argument_list|(
name|ifp
operator|->
name|int_dstaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_state
operator|&=
operator|~
name|IS_SICK
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|msglog
argument_list|(
literal|"%sinterface %s to %s restored"
argument_list|,
name|type
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|naddr_ntoa
argument_list|(
name|ifp
operator|->
name|int_dstaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_state
operator|&=
operator|~
operator|(
name|IS_BROKE
operator||
name|IS_SICK
operator|)
expr_stmt|;
name|ifp
operator|->
name|int_data
operator|.
name|ts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALIAS
operator|)
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|ifp1
argument_list|,
argument|&ifnet
argument_list|,
argument|int_list
argument_list|)
block|{
if|if
condition|(
name|ifp1
operator|!=
name|ifp
operator|&&
operator|!
name|strcmp
argument_list|(
name|ifp
operator|->
name|int_name
argument_list|,
name|ifp1
operator|->
name|int_name
argument_list|)
condition|)
name|if_ok
argument_list|(
name|ifp1
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|if_ok_rdisc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
condition|)
block|{
if|if
condition|(
operator|!
name|addrouteforif
argument_list|(
name|ifp
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* disassemble routing message  */
end_comment

begin_function
name|void
name|rt_xaddrs
parameter_list|(
name|struct
name|rt_addrinfo
modifier|*
name|info
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|lim
parameter_list|,
name|int
name|addrs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|_HAVE_SA_LEN
specifier|static
name|struct
name|sockaddr
name|sa_zero
decl_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|rti_addrs
operator|=
name|addrs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RTAX_MAX
operator|&&
name|sa
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|addrs
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|info
operator|->
name|rti_info
index|[
name|i
index|]
operator|=
operator|(
name|sa
operator|->
name|sa_len
operator|!=
literal|0
operator|)
condition|?
name|sa
else|:
operator|&
name|sa_zero
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|sa
operator|)
operator|+
name|SA_SIZE
argument_list|(
name|sa
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the network interfaces which have configured themselves.  *	This must be done regularly, if only for extra addresses  *	that come and go on interfaces.  */
end_comment

begin_function
name|void
name|ifinit
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|ifa_msghdr
modifier|*
name|sysctl_buf
decl_stmt|;
specifier|static
name|size_t
name|sysctl_buf_size
init|=
literal|0
decl_stmt|;
name|uint
name|complaints
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|prev_complaints
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|COMP_NOT_INET
value|0x001
define|#
directive|define
name|COMP_NOADDR
value|0x002
define|#
directive|define
name|COMP_BADADDR
value|0x004
define|#
directive|define
name|COMP_NODST
value|0x008
define|#
directive|define
name|COMP_NOBADR
value|0x010
define|#
directive|define
name|COMP_NOMASK
value|0x020
define|#
directive|define
name|COMP_DUP
value|0x040
define|#
directive|define
name|COMP_BAD_METRIC
value|0x080
define|#
directive|define
name|COMP_NETMASK
value|0x100
name|struct
name|interface
name|ifs
decl_stmt|,
name|ifs0
decl_stmt|,
modifier|*
name|ifp
decl_stmt|,
modifier|*
name|ifp1
decl_stmt|;
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
name|size_t
name|needed
decl_stmt|;
name|int
name|mib
index|[
literal|6
index|]
decl_stmt|;
name|struct
name|if_msghdr
modifier|*
name|ifm
decl_stmt|;
name|void
modifier|*
name|ifam_lim
decl_stmt|;
name|struct
name|ifa_msghdr
modifier|*
name|ifam
decl_stmt|,
modifier|*
name|ifam2
decl_stmt|;
name|int
name|in
decl_stmt|,
name|ierr
decl_stmt|,
name|out
decl_stmt|,
name|oerr
decl_stmt|;
name|struct
name|intnet
modifier|*
name|intnetp
decl_stmt|;
name|struct
name|rt_addrinfo
name|info
decl_stmt|;
ifdef|#
directive|ifdef
name|SIOCGIFMETRIC
name|struct
name|ifreq
name|ifr
decl_stmt|;
endif|#
directive|endif
name|last_ifinit
operator|=
name|now
expr_stmt|;
name|ifinit_timer
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
operator|+
operator|(
name|supplier
condition|?
name|CHECK_ACT_INTERVAL
else|:
name|CHECK_QUIET_INTERVAL
operator|)
expr_stmt|;
comment|/* mark all interfaces so we can get rid of those that disappear */
name|LIST_FOREACH
argument_list|(
argument|ifp
argument_list|,
argument|&ifnet
argument_list|,
argument|int_list
argument_list|)
name|ifp
operator|->
name|int_state
operator|&=
operator|~
operator|(
name|IS_CHECKED
operator||
name|IS_DUP
operator|)
expr_stmt|;
comment|/* Fetch the interface list, without too many system calls 	 * since we do it repeatedly. 	 */
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_NET
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|PF_ROUTE
expr_stmt|;
name|mib
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mib
index|[
literal|3
index|]
operator|=
name|AF_INET
expr_stmt|;
name|mib
index|[
literal|4
index|]
operator|=
name|NET_RT_IFLIST
expr_stmt|;
name|mib
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|needed
operator|=
name|sysctl_buf_size
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
name|sysctl_buf
argument_list|,
operator|&
name|needed
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
break|break;
comment|/* retry if the table grew */
if|if
condition|(
name|errno
operator|!=
name|ENOMEM
operator|&&
name|errno
operator|!=
name|EFAULT
condition|)
name|BADERR
argument_list|(
literal|1
argument_list|,
literal|"ifinit: sysctl(RT_IFLIST)"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sysctl_buf
argument_list|)
expr_stmt|;
name|needed
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|,
operator|&
name|needed
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|BADERR
argument_list|(
literal|1
argument_list|,
literal|"ifinit: sysctl(RT_IFLIST) estimate"
argument_list|)
expr_stmt|;
name|sysctl_buf
operator|=
name|rtmalloc
argument_list|(
name|sysctl_buf_size
operator|=
name|needed
argument_list|,
literal|"ifinit sysctl"
argument_list|)
expr_stmt|;
block|}
comment|/* XXX: thanks to malloc(3), alignment can be presumed OK */
name|ifam_lim
operator|=
operator|(
name|char
operator|*
operator|)
name|sysctl_buf
operator|+
name|needed
expr_stmt|;
for|for
control|(
name|ifam
operator|=
name|sysctl_buf
init|;
operator|(
name|void
operator|*
operator|)
name|ifam
operator|<
name|ifam_lim
condition|;
name|ifam
operator|=
name|ifam2
control|)
block|{
name|ifam2
operator|=
operator|(
expr|struct
name|ifa_msghdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ifam
operator|+
name|ifam
operator|->
name|ifam_msglen
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RTM_OIFINFO
if|if
condition|(
name|ifam
operator|->
name|ifam_type
operator|==
name|RTM_OIFINFO
condition|)
continue|continue;
comment|/* just ignore compat message */
endif|#
directive|endif
if|if
condition|(
name|ifam
operator|->
name|ifam_type
operator|==
name|RTM_IFINFO
condition|)
block|{
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|ifm
operator|=
operator|(
expr|struct
name|if_msghdr
operator|*
operator|)
name|ifam
expr_stmt|;
comment|/* make prototype structure for the IP aliases 			 */
name|memset
argument_list|(
operator|&
name|ifs0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifs0
argument_list|)
argument_list|)
expr_stmt|;
name|ifs0
operator|.
name|int_rip_sock
operator|=
operator|-
literal|1
expr_stmt|;
name|ifs0
operator|.
name|int_index
operator|=
name|ifm
operator|->
name|ifm_index
expr_stmt|;
name|ifs0
operator|.
name|int_if_flags
operator|=
name|ifm
operator|->
name|ifm_flags
expr_stmt|;
name|ifs0
operator|.
name|int_state
operator|=
name|IS_CHECKED
expr_stmt|;
name|ifs0
operator|.
name|int_query_time
operator|=
name|NEVER
expr_stmt|;
name|ifs0
operator|.
name|int_act_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|ifs0
operator|.
name|int_data
operator|.
name|ts
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|ifs0
operator|.
name|int_data
operator|.
name|ipackets
operator|=
name|ifm
operator|->
name|ifm_data
operator|.
name|ifi_ipackets
expr_stmt|;
name|ifs0
operator|.
name|int_data
operator|.
name|ierrors
operator|=
name|ifm
operator|->
name|ifm_data
operator|.
name|ifi_ierrors
expr_stmt|;
name|ifs0
operator|.
name|int_data
operator|.
name|opackets
operator|=
name|ifm
operator|->
name|ifm_data
operator|.
name|ifi_opackets
expr_stmt|;
name|ifs0
operator|.
name|int_data
operator|.
name|oerrors
operator|=
name|ifm
operator|->
name|ifm_data
operator|.
name|ifi_oerrors
expr_stmt|;
ifdef|#
directive|ifdef
name|sgi
name|ifs0
operator|.
name|int_data
operator|.
name|odrops
operator|=
name|ifm
operator|->
name|ifm_data
operator|.
name|ifi_odrops
expr_stmt|;
endif|#
directive|endif
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|(
name|ifm
operator|+
literal|1
operator|)
expr_stmt|;
name|sdl
operator|->
name|sdl_data
index|[
name|sdl
operator|->
name|sdl_nlen
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|ifs0
operator|.
name|int_name
argument_list|,
name|sdl
operator|->
name|sdl_data
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|ifs0
operator|.
name|int_name
argument_list|)
argument_list|,
name|sdl
operator|->
name|sdl_nlen
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ifam
operator|->
name|ifam_type
operator|!=
name|RTM_NEWADDR
condition|)
block|{
name|logbad
argument_list|(
literal|1
argument_list|,
literal|"ifinit: out of sync"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rt_xaddrs
argument_list|(
operator|&
name|info
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|ifam
operator|+
literal|1
operator|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|ifam2
argument_list|,
name|ifam
operator|->
name|ifam_addrs
argument_list|)
expr_stmt|;
comment|/* Prepare for the next address of this interface, which 		 * will be an alias. 		 * Do not output RIP or Router-Discovery packets via aliases. 		 */
name|memcpy
argument_list|(
operator|&
name|ifs
argument_list|,
operator|&
name|ifs0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifs
argument_list|)
argument_list|)
expr_stmt|;
name|ifs0
operator|.
name|int_state
operator||=
operator|(
name|IS_ALIAS
operator||
name|IS_NO_RIP_OUT
operator||
name|IS_NO_RDISC
operator|)
expr_stmt|;
if|if
condition|(
name|INFO_IFA
argument_list|(
operator|&
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|iff_up
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_NOADDR
operator|)
condition|)
name|msglog
argument_list|(
literal|"%s has no address"
argument_list|,
name|ifs
operator|.
name|int_name
argument_list|)
expr_stmt|;
name|complaints
operator||=
name|COMP_NOADDR
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|INFO_IFA
argument_list|(
operator|&
name|info
argument_list|)
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
if|if
condition|(
name|iff_up
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_NOT_INET
operator|)
condition|)
name|trace_act
argument_list|(
literal|"%s: not AF_INET"
argument_list|,
name|ifs
operator|.
name|int_name
argument_list|)
expr_stmt|;
name|complaints
operator||=
name|COMP_NOT_INET
expr_stmt|;
block|}
continue|continue;
block|}
name|ifs
operator|.
name|int_addr
operator|=
name|S_ADDR
argument_list|(
name|INFO_IFA
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|ifs
operator|.
name|int_addr
argument_list|)
operator|>>
literal|24
operator|==
literal|0
operator|||
name|ntohl
argument_list|(
name|ifs
operator|.
name|int_addr
argument_list|)
operator|>>
literal|24
operator|==
literal|0xff
condition|)
block|{
if|if
condition|(
name|iff_up
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_BADADDR
operator|)
condition|)
name|msglog
argument_list|(
literal|"%s has a bad address"
argument_list|,
name|ifs
operator|.
name|int_name
argument_list|)
expr_stmt|;
name|complaints
operator||=
name|COMP_BADADDR
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|ifs
operator|.
name|int_if_flags
operator|&
name|IFF_LOOPBACK
condition|)
block|{
name|ifs
operator|.
name|int_state
operator||=
name|IS_NO_RIP
operator||
name|IS_NO_RDISC
expr_stmt|;
if|if
condition|(
name|ifs
operator|.
name|int_addr
operator|==
name|htonl
argument_list|(
name|INADDR_LOOPBACK
argument_list|)
condition|)
name|ifs
operator|.
name|int_state
operator||=
name|IS_PASSIVE
expr_stmt|;
name|ifs
operator|.
name|int_dstaddr
operator|=
name|ifs
operator|.
name|int_addr
expr_stmt|;
name|ifs
operator|.
name|int_mask
operator|=
name|HOST_MASK
expr_stmt|;
name|ifs
operator|.
name|int_ripv1_mask
operator|=
name|HOST_MASK
expr_stmt|;
name|ifs
operator|.
name|int_std_mask
operator|=
name|std_mask
argument_list|(
name|ifs
operator|.
name|int_dstaddr
argument_list|)
expr_stmt|;
name|ifs
operator|.
name|int_net
operator|=
name|ntohl
argument_list|(
name|ifs
operator|.
name|int_dstaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foundloopback
condition|)
block|{
name|foundloopback
operator|=
literal|1
expr_stmt|;
name|loopaddr
operator|=
name|ifs
operator|.
name|int_addr
expr_stmt|;
name|loop_rts
operator|.
name|rts_gate
operator|=
name|loopaddr
expr_stmt|;
name|loop_rts
operator|.
name|rts_router
operator|=
name|loopaddr
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ifs
operator|.
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
if|if
condition|(
name|INFO_BRD
argument_list|(
operator|&
name|info
argument_list|)
operator|==
literal|0
operator|||
name|INFO_BRD
argument_list|(
operator|&
name|info
argument_list|)
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
if|if
condition|(
name|iff_up
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_NODST
operator|)
condition|)
name|msglog
argument_list|(
literal|"%s has a bad"
literal|" destination address"
argument_list|,
name|ifs
operator|.
name|int_name
argument_list|)
expr_stmt|;
name|complaints
operator||=
name|COMP_NODST
expr_stmt|;
block|}
continue|continue;
block|}
name|ifs
operator|.
name|int_dstaddr
operator|=
name|S_ADDR
argument_list|(
name|INFO_BRD
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|ifs
operator|.
name|int_dstaddr
argument_list|)
operator|>>
literal|24
operator|==
literal|0
operator|||
name|ntohl
argument_list|(
name|ifs
operator|.
name|int_dstaddr
argument_list|)
operator|>>
literal|24
operator|==
literal|0xff
condition|)
block|{
if|if
condition|(
name|iff_up
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_NODST
operator|)
condition|)
name|msglog
argument_list|(
literal|"%s has a bad"
literal|" destination address"
argument_list|,
name|ifs
operator|.
name|int_name
argument_list|)
expr_stmt|;
name|complaints
operator||=
name|COMP_NODST
expr_stmt|;
block|}
continue|continue;
block|}
name|ifs
operator|.
name|int_mask
operator|=
name|HOST_MASK
expr_stmt|;
name|ifs
operator|.
name|int_ripv1_mask
operator|=
name|ntohl
argument_list|(
name|S_ADDR
argument_list|(
name|INFO_MASK
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ifs
operator|.
name|int_std_mask
operator|=
name|std_mask
argument_list|(
name|ifs
operator|.
name|int_dstaddr
argument_list|)
expr_stmt|;
name|ifs
operator|.
name|int_net
operator|=
name|ntohl
argument_list|(
name|ifs
operator|.
name|int_dstaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|INFO_MASK
argument_list|(
operator|&
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|iff_up
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_NOMASK
operator|)
condition|)
name|msglog
argument_list|(
literal|"%s has no netmask"
argument_list|,
name|ifs
operator|.
name|int_name
argument_list|)
expr_stmt|;
name|complaints
operator||=
name|COMP_NOMASK
expr_stmt|;
block|}
continue|continue;
block|}
name|ifs
operator|.
name|int_dstaddr
operator|=
name|ifs
operator|.
name|int_addr
expr_stmt|;
name|ifs
operator|.
name|int_mask
operator|=
name|ntohl
argument_list|(
name|S_ADDR
argument_list|(
name|INFO_MASK
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ifs
operator|.
name|int_ripv1_mask
operator|=
name|ifs
operator|.
name|int_mask
expr_stmt|;
name|ifs
operator|.
name|int_std_mask
operator|=
name|std_mask
argument_list|(
name|ifs
operator|.
name|int_addr
argument_list|)
expr_stmt|;
name|ifs
operator|.
name|int_net
operator|=
name|ntohl
argument_list|(
name|ifs
operator|.
name|int_addr
argument_list|)
operator|&
name|ifs
operator|.
name|int_mask
expr_stmt|;
if|if
condition|(
name|ifs
operator|.
name|int_mask
operator|!=
name|ifs
operator|.
name|int_std_mask
condition|)
name|ifs
operator|.
name|int_state
operator||=
name|IS_SUBNET
expr_stmt|;
if|if
condition|(
name|ifs
operator|.
name|int_if_flags
operator|&
name|IFF_BROADCAST
condition|)
block|{
if|if
condition|(
name|INFO_BRD
argument_list|(
operator|&
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|iff_up
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_NOBADR
operator|)
condition|)
name|msglog
argument_list|(
literal|"%s has"
literal|"no broadcast address"
argument_list|,
name|ifs
operator|.
name|int_name
argument_list|)
expr_stmt|;
name|complaints
operator||=
name|COMP_NOBADR
expr_stmt|;
block|}
continue|continue;
block|}
name|ifs
operator|.
name|int_brdaddr
operator|=
name|S_ADDR
argument_list|(
name|INFO_BRD
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ifs
operator|.
name|int_std_net
operator|=
name|ifs
operator|.
name|int_net
operator|&
name|ifs
operator|.
name|int_std_mask
expr_stmt|;
name|ifs
operator|.
name|int_std_addr
operator|=
name|htonl
argument_list|(
name|ifs
operator|.
name|int_std_net
argument_list|)
expr_stmt|;
comment|/* Use a minimum metric of one.  Treat the interface metric 		 * (default 0) as an increment to the hop count of one. 		 * 		 * The metric obtained from the routing socket dump of 		 * interface addresses is wrong.  It is not set by the 		 * SIOCSIFMETRIC ioctl. 		 */
ifdef|#
directive|ifdef
name|SIOCGIFMETRIC
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|ifs
operator|.
name|int_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|rt_sock
argument_list|,
name|SIOCGIFMETRIC
argument_list|,
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DBGERR
argument_list|(
literal|1
argument_list|,
literal|"ioctl(SIOCGIFMETRIC)"
argument_list|)
expr_stmt|;
name|ifs
operator|.
name|int_metric
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ifs
operator|.
name|int_metric
operator|=
name|ifr
operator|.
name|ifr_metric
expr_stmt|;
block|}
else|#
directive|else
name|ifs
operator|.
name|int_metric
operator|=
name|ifam
operator|->
name|ifam_metric
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ifs
operator|.
name|int_metric
operator|>
name|HOPCNT_INFINITY
condition|)
block|{
name|ifs
operator|.
name|int_metric
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_BAD_METRIC
operator|)
operator|&&
name|iff_up
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
block|{
name|complaints
operator||=
name|COMP_BAD_METRIC
expr_stmt|;
name|msglog
argument_list|(
literal|"%s has a metric of %d"
argument_list|,
name|ifs
operator|.
name|int_name
argument_list|,
name|ifs
operator|.
name|int_metric
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* See if this is a familiar interface. 		 * If so, stop worrying about it if it is the same. 		 * Start it over if it now is to somewhere else, as happens 		 * frequently with PPP and SLIP. 		 */
name|ifp
operator|=
name|ifwithname
argument_list|(
name|ifs
operator|.
name|int_name
argument_list|,
operator|(
operator|(
name|ifs
operator|.
name|int_state
operator|&
name|IS_ALIAS
operator|)
condition|?
name|ifs
operator|.
name|int_addr
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|int_state
operator||=
name|IS_CHECKED
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
operator|(
name|ifp
operator|->
name|int_if_flags
operator|^
name|ifs
operator|.
name|int_if_flags
operator|)
operator|&
operator|(
name|IFF_BROADCAST
operator||
name|IFF_LOOPBACK
operator||
name|IFF_POINTOPOINT
operator||
name|IFF_MULTICAST
operator|)
operator|)
operator|||
literal|0
operator|!=
operator|(
operator|(
name|ifp
operator|->
name|int_state
operator|^
name|ifs
operator|.
name|int_state
operator|)
operator|&
name|IS_ALIAS
operator|)
operator|||
name|ifp
operator|->
name|int_addr
operator|!=
name|ifs
operator|.
name|int_addr
operator|||
name|ifp
operator|->
name|int_brdaddr
operator|!=
name|ifs
operator|.
name|int_brdaddr
operator|||
name|ifp
operator|->
name|int_dstaddr
operator|!=
name|ifs
operator|.
name|int_dstaddr
operator|||
name|ifp
operator|->
name|int_mask
operator|!=
name|ifs
operator|.
name|int_mask
operator|||
name|ifp
operator|->
name|int_metric
operator|!=
name|ifs
operator|.
name|int_metric
condition|)
block|{
comment|/* Forget old information about 				 * a changed interface. 				 */
name|trace_act
argument_list|(
literal|"interface %s has changed"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
name|ifdel
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ifp
operator|!=
literal|0
condition|)
block|{
comment|/* The primary representative of an alias worries 			 * about how things are working. 			 */
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALIAS
condition|)
continue|continue;
comment|/* note interfaces that have been turned off 			 */
if|if
condition|(
operator|!
name|iff_up
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|iff_up
argument_list|(
name|ifp
operator|->
name|int_if_flags
argument_list|)
condition|)
block|{
name|msglog
argument_list|(
literal|"interface %s to %s turned off"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|naddr_ntoa
argument_list|(
name|ifp
operator|->
name|int_dstaddr
argument_list|)
argument_list|)
expr_stmt|;
name|if_bad
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|now
operator|.
name|tv_sec
operator|>
operator|(
name|ifp
operator|->
name|int_data
operator|.
name|ts
operator|+
name|CHECK_BAD_INTERVAL
operator|)
condition|)
block|{
name|trace_act
argument_list|(
literal|"interface %s has been off"
literal|" %jd seconds; forget it"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
operator|(
name|intmax_t
operator|)
name|now
operator|.
name|tv_sec
operator|-
name|ifp
operator|->
name|int_data
operator|.
name|ts
argument_list|)
expr_stmt|;
name|ifdel
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* or that were off and are now ok */
if|if
condition|(
operator|!
name|iff_up
argument_list|(
name|ifp
operator|->
name|int_if_flags
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|int_if_flags
operator||=
name|IFF_UP
expr_stmt|;
operator|(
name|void
operator|)
name|if_ok
argument_list|(
name|ifp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* If it has been long enough, 			 * see if the interface is broken. 			 */
if|if
condition|(
name|now
operator|.
name|tv_sec
operator|<
name|ifp
operator|->
name|int_data
operator|.
name|ts
operator|+
name|CHECK_BAD_INTERVAL
condition|)
continue|continue;
name|in
operator|=
name|ifs
operator|.
name|int_data
operator|.
name|ipackets
operator|-
name|ifp
operator|->
name|int_data
operator|.
name|ipackets
expr_stmt|;
name|ierr
operator|=
name|ifs
operator|.
name|int_data
operator|.
name|ierrors
operator|-
name|ifp
operator|->
name|int_data
operator|.
name|ierrors
expr_stmt|;
name|out
operator|=
name|ifs
operator|.
name|int_data
operator|.
name|opackets
operator|-
name|ifp
operator|->
name|int_data
operator|.
name|opackets
expr_stmt|;
name|oerr
operator|=
name|ifs
operator|.
name|int_data
operator|.
name|oerrors
operator|-
name|ifp
operator|->
name|int_data
operator|.
name|oerrors
expr_stmt|;
ifdef|#
directive|ifdef
name|sgi
comment|/* Through at least IRIX 6.2, PPP and SLIP 			 * count packets dropped by the filters. 			 * But FDDI rings stuck non-operational count 			 * dropped packets as they wait for improvement. 			 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
condition|)
name|oerr
operator|+=
operator|(
name|ifs
operator|.
name|int_data
operator|.
name|odrops
operator|-
name|ifp
operator|->
name|int_data
operator|.
name|odrops
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the interface just awoke, restart the counters. 			 */
if|if
condition|(
name|ifp
operator|->
name|int_data
operator|.
name|ts
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|int_data
operator|=
name|ifs
operator|.
name|int_data
expr_stmt|;
continue|continue;
block|}
name|ifp
operator|->
name|int_data
operator|=
name|ifs
operator|.
name|int_data
expr_stmt|;
comment|/* Withhold judgment when the short error 			 * counters wrap or the interface is reset. 			 */
if|if
condition|(
name|ierr
operator|<
literal|0
operator|||
name|in
operator|<
literal|0
operator|||
name|oerr
operator|<
literal|0
operator|||
name|out
operator|<
literal|0
condition|)
block|{
name|LIM_SEC
argument_list|(
name|ifinit_timer
argument_list|,
name|now
operator|.
name|tv_sec
operator|+
name|CHECK_BAD_INTERVAL
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Withhold judgement when there is no traffic 			 */
if|if
condition|(
name|in
operator|==
literal|0
operator|&&
name|out
operator|==
literal|0
operator|&&
name|ierr
operator|==
literal|0
operator|&&
name|oerr
operator|==
literal|0
condition|)
continue|continue;
comment|/* It is bad if input or output is not working. 			 * Require presistent problems before marking it dead. 			 */
if|if
condition|(
operator|(
name|in
operator|<=
name|ierr
operator|&&
name|ierr
operator|>
literal|0
operator|)
operator|||
operator|(
name|out
operator|<=
name|oerr
operator|&&
name|oerr
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_SICK
operator|)
condition|)
block|{
name|trace_act
argument_list|(
literal|"interface %s to %s"
literal|" sick: in=%d ierr=%d"
literal|" out=%d oerr=%d"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|naddr_ntoa
argument_list|(
name|ifp
operator|->
name|int_dstaddr
argument_list|)
argument_list|,
name|in
argument_list|,
name|ierr
argument_list|,
name|out
argument_list|,
name|oerr
argument_list|)
expr_stmt|;
name|if_sick
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
operator|)
condition|)
block|{
name|msglog
argument_list|(
literal|"interface %s to %s broken:"
literal|" in=%d ierr=%d out=%d oerr=%d"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|naddr_ntoa
argument_list|(
name|ifp
operator|->
name|int_dstaddr
argument_list|)
argument_list|,
name|in
argument_list|,
name|ierr
argument_list|,
name|out
argument_list|,
name|oerr
argument_list|)
expr_stmt|;
name|if_bad
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* otherwise, it is active and healthy 			 */
name|ifp
operator|->
name|int_act_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
operator|(
name|void
operator|)
name|if_ok
argument_list|(
name|ifp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* This is a new interface. 		 * If it is dead, forget it. 		 */
if|if
condition|(
operator|!
name|iff_up
argument_list|(
name|ifs
operator|.
name|int_if_flags
argument_list|)
condition|)
continue|continue;
comment|/* If it duplicates an existing interface, 		 * complain about it, mark the other one 		 * duplicated, and forget this one. 		 */
name|ifp
operator|=
name|check_dup
argument_list|(
name|ifs
operator|.
name|int_addr
argument_list|,
name|ifs
operator|.
name|int_dstaddr
argument_list|,
name|ifs
operator|.
name|int_mask
argument_list|,
name|ifs
operator|.
name|int_if_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
literal|0
condition|)
block|{
comment|/* Ignore duplicates of itself, caused by having 			 * IP aliases on the same network. 			 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ifp
operator|->
name|int_name
argument_list|,
name|ifs
operator|.
name|int_name
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_DUP
operator|)
condition|)
block|{
name|complaints
operator||=
name|COMP_DUP
expr_stmt|;
name|msglog
argument_list|(
literal|"%s (%s%s%s) is duplicated by"
literal|" %s (%s%s%s)"
argument_list|,
name|ifs
operator|.
name|int_name
argument_list|,
name|addrname
argument_list|(
name|ifs
operator|.
name|int_addr
argument_list|,
name|ifs
operator|.
name|int_mask
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|(
operator|(
name|ifs
operator|.
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
condition|?
literal|"-->"
else|:
literal|""
operator|)
argument_list|,
operator|(
operator|(
name|ifs
operator|.
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
condition|?
name|naddr_ntoa
argument_list|(
name|ifs
operator|.
name|int_dstaddr
argument_list|)
else|:
literal|""
operator|)
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|addrname
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|,
name|ifp
operator|->
name|int_mask
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|(
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
condition|?
literal|"-->"
else|:
literal|""
operator|)
argument_list|,
operator|(
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
condition|?
name|naddr_ntoa
argument_list|(
name|ifp
operator|->
name|int_dstaddr
argument_list|)
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|int_state
operator||=
name|IS_DUP
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
literal|0
operator|==
operator|(
name|ifs
operator|.
name|int_if_flags
operator|&
operator|(
name|IFF_POINTOPOINT
operator||
name|IFF_BROADCAST
operator||
name|IFF_LOOPBACK
operator|)
operator|)
condition|)
block|{
name|trace_act
argument_list|(
literal|"%s is neither broadcast, point-to-point,"
literal|" nor loopback"
argument_list|,
name|ifs
operator|.
name|int_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifs
operator|.
name|int_state
operator|&
name|IFF_MULTICAST
operator|)
condition|)
name|ifs
operator|.
name|int_state
operator||=
name|IS_NO_RDISC
expr_stmt|;
block|}
comment|/* It is new and ok.   Add it to the list of interfaces 		 */
name|ifp
operator|=
operator|(
expr|struct
name|interface
operator|*
operator|)
name|rtmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ifp
argument_list|)
argument_list|,
literal|"ifinit ifp"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ifp
argument_list|,
operator|&
name|ifs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|get_parms
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_link
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|trace_if
argument_list|(
literal|"Add"
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
comment|/* Notice likely bad netmask. 		 */
if|if
condition|(
operator|!
operator|(
name|prev_complaints
operator|&
name|COMP_NETMASK
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|&&
name|ifp
operator|->
name|int_addr
operator|!=
name|RIP_DEFAULT
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|ifp1
argument_list|,
argument|&ifnet
argument_list|,
argument|int_list
argument_list|)
block|{
if|if
condition|(
name|ifp1
operator|->
name|int_mask
operator|==
name|ifp
operator|->
name|int_mask
condition|)
continue|continue;
if|if
condition|(
name|ifp1
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
continue|continue;
if|if
condition|(
name|ifp1
operator|->
name|int_dstaddr
operator|==
name|RIP_DEFAULT
condition|)
continue|continue;
comment|/* ignore aliases on the right network */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ifp
operator|->
name|int_name
argument_list|,
name|ifp1
operator|->
name|int_name
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|on_net
argument_list|(
name|ifp
operator|->
name|int_dstaddr
argument_list|,
name|ifp1
operator|->
name|int_net
argument_list|,
name|ifp1
operator|->
name|int_mask
argument_list|)
operator|||
name|on_net
argument_list|(
name|ifp1
operator|->
name|int_dstaddr
argument_list|,
name|ifp
operator|->
name|int_net
argument_list|,
name|ifp
operator|->
name|int_mask
argument_list|)
condition|)
block|{
name|msglog
argument_list|(
literal|"possible netmask problem"
literal|" between %s:%s and %s:%s"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|addrname
argument_list|(
name|htonl
argument_list|(
name|ifp
operator|->
name|int_net
argument_list|)
argument_list|,
name|ifp
operator|->
name|int_mask
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ifp1
operator|->
name|int_name
argument_list|,
name|addrname
argument_list|(
name|htonl
argument_list|(
name|ifp1
operator|->
name|int_net
argument_list|)
argument_list|,
name|ifp1
operator|->
name|int_mask
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|complaints
operator||=
name|COMP_NETMASK
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALIAS
operator|)
condition|)
block|{
comment|/* Count the # of directly connected networks. 			 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_LOOPBACK
operator|)
condition|)
name|tot_interfaces
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|IS_RIP_OFF
argument_list|(
name|ifp
operator|->
name|int_state
argument_list|)
condition|)
name|rip_interfaces
operator|++
expr_stmt|;
comment|/* turn on router discovery and RIP If needed */
name|if_ok_rdisc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|rip_on
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are multi-homed and have at least two interfaces 	 * listening to RIP, then output by default. 	 */
if|if
condition|(
operator|!
name|supplier_set
operator|&&
name|rip_interfaces
operator|>
literal|1
condition|)
name|set_supplier
argument_list|()
expr_stmt|;
comment|/* If we are multi-homed, optionally advertise a route to 	 * our main address. 	 */
if|if
condition|(
name|advertise_mhome
operator|||
operator|(
name|tot_interfaces
operator|>
literal|1
operator|&&
name|mhome
operator|&&
operator|(
name|ifp
operator|=
name|ifwithaddr
argument_list|(
name|myaddr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|foundloopback
operator|)
condition|)
block|{
name|advertise_mhome
operator|=
literal|1
expr_stmt|;
name|rt
operator|=
name|rtget
argument_list|(
name|myaddr
argument_list|,
name|HOST_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_ifp
operator|!=
name|ifp
operator|||
name|rt
operator|->
name|rt_router
operator|!=
name|loopaddr
condition|)
block|{
name|rtdelete
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|loop_rts
operator|.
name|rts_ifp
operator|=
name|ifp
expr_stmt|;
name|loop_rts
operator|.
name|rts_metric
operator|=
literal|0
expr_stmt|;
name|loop_rts
operator|.
name|rts_time
operator|=
name|rt
operator|->
name|rt_time
expr_stmt|;
name|rtchange
argument_list|(
name|rt
argument_list|,
name|rt
operator|->
name|rt_state
operator||
name|RS_MHOME
argument_list|,
operator|&
name|loop_rts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
block|{
name|loop_rts
operator|.
name|rts_ifp
operator|=
name|ifp
expr_stmt|;
name|loop_rts
operator|.
name|rts_metric
operator|=
literal|0
expr_stmt|;
name|rtadd
argument_list|(
name|myaddr
argument_list|,
name|HOST_MASK
argument_list|,
name|RS_MHOME
argument_list|,
operator|&
name|loop_rts
argument_list|)
expr_stmt|;
block|}
block|}
name|LIST_FOREACH_SAFE
argument_list|(
argument|ifp
argument_list|,
argument|&ifnet
argument_list|,
argument|int_list
argument_list|,
argument|ifp1
argument_list|)
block|{
comment|/* Forget any interfaces that have disappeared. 		 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
operator|(
name|IS_CHECKED
operator||
name|IS_REMOTE
operator|)
operator|)
condition|)
block|{
name|trace_act
argument_list|(
literal|"interface %s has disappeared"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
name|ifdel
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_PASSIVE
operator|)
condition|)
name|LIM_SEC
argument_list|(
name|ifinit_timer
argument_list|,
name|now
operator|.
name|tv_sec
operator|+
name|CHECK_BAD_INTERVAL
argument_list|)
expr_stmt|;
comment|/* If we ever have a RIPv1 interface, assume we always will. 		 * It might come back if it ever goes away. 		 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV1_OUT
operator|)
operator|&&
name|supplier
condition|)
name|have_ripv1_out
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV1_IN
operator|)
condition|)
name|have_ripv1_in
operator|=
literal|1
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|ifp
argument_list|,
argument|&ifnet
argument_list|,
argument|int_list
argument_list|)
block|{
comment|/* Ensure there is always a network route for interfaces, 		 * after any dead interfaces have been deleted, which 		 * might affect routes for point-to-point links. 		 */
if|if
condition|(
operator|!
name|addrouteforif
argument_list|(
name|ifp
argument_list|)
condition|)
continue|continue;
comment|/* Add routes to the local end of point-to-point interfaces 		 * using loopback. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
operator|)
operator|&&
name|foundloopback
condition|)
block|{
comment|/* Delete any routes to the network address through 			 * foreign routers. Remove even static routes. 			 */
name|del_static
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|,
name|HOST_MASK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rt
operator|=
name|rtget
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|,
name|HOST_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
operator|&&
name|rt
operator|->
name|rt_router
operator|!=
name|loopaddr
condition|)
block|{
name|rtdelete
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_LOCAL
operator|)
operator|||
name|rt
operator|->
name|rt_metric
operator|>
name|ifp
operator|->
name|int_metric
condition|)
block|{
name|ifp1
operator|=
name|ifp
expr_stmt|;
block|}
else|else
block|{
name|ifp1
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
block|}
name|loop_rts
operator|.
name|rts_ifp
operator|=
name|ifp1
expr_stmt|;
name|loop_rts
operator|.
name|rts_metric
operator|=
literal|0
expr_stmt|;
name|loop_rts
operator|.
name|rts_time
operator|=
name|rt
operator|->
name|rt_time
expr_stmt|;
name|rtchange
argument_list|(
name|rt
argument_list|,
operator|(
operator|(
name|rt
operator|->
name|rt_state
operator|&
operator|~
name|RS_NET_SYN
operator|)
operator||
operator|(
name|RS_IF
operator||
name|RS_LOCAL
operator|)
operator|)
argument_list|,
operator|&
name|loop_rts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|loop_rts
operator|.
name|rts_ifp
operator|=
name|ifp
expr_stmt|;
name|loop_rts
operator|.
name|rts_metric
operator|=
literal|0
expr_stmt|;
name|rtadd
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|,
name|HOST_MASK
argument_list|,
operator|(
name|RS_IF
operator||
name|RS_LOCAL
operator|)
argument_list|,
operator|&
name|loop_rts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* add the authority routes */
for|for
control|(
name|intnetp
operator|=
name|intnets
init|;
name|intnetp
operator|!=
literal|0
condition|;
name|intnetp
operator|=
name|intnetp
operator|->
name|intnet_next
control|)
block|{
name|rt
operator|=
name|rtget
argument_list|(
name|intnetp
operator|->
name|intnet_addr
argument_list|,
name|intnetp
operator|->
name|intnet_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_NO_NET_SYN
operator|)
operator|&&
operator|!
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_NET_INT
operator|)
condition|)
block|{
name|rtdelete
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
block|{
name|loop_rts
operator|.
name|rts_ifp
operator|=
literal|0
expr_stmt|;
name|loop_rts
operator|.
name|rts_metric
operator|=
name|intnetp
operator|->
name|intnet_metric
operator|-
literal|1
expr_stmt|;
name|rtadd
argument_list|(
name|intnetp
operator|->
name|intnet_addr
argument_list|,
name|intnetp
operator|->
name|intnet_mask
argument_list|,
name|RS_NET_SYN
operator||
name|RS_NET_INT
argument_list|,
operator|&
name|loop_rts
argument_list|)
expr_stmt|;
block|}
block|}
name|prev_complaints
operator|=
name|complaints
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_net_syn
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
specifier|static
name|struct
name|rt_spare
name|new
decl_stmt|;
comment|/* Turn on the need to automatically synthesize a network route 	 * for this interface only if we are running RIPv1 on some other 	 * interface that is on a different class-A,B,or C network. 	 */
if|if
condition|(
name|have_ripv1_out
operator|||
name|have_ripv1_in
condition|)
block|{
name|ifp
operator|->
name|int_state
operator||=
name|IS_NEED_NET_SYN
expr_stmt|;
name|rt
operator|=
name|rtget
argument_list|(
name|ifp
operator|->
name|int_std_addr
argument_list|,
name|ifp
operator|->
name|int_std_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
operator|&&
literal|0
operator|==
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_NO_NET_SYN
operator|)
operator|&&
operator|(
operator|!
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_NET_SYN
operator|)
operator|||
name|rt
operator|->
name|rt_metric
operator|>
name|ifp
operator|->
name|int_metric
operator|)
condition|)
block|{
name|rtdelete
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
block|{
name|new
operator|.
name|rts_ifp
operator|=
name|ifp
expr_stmt|;
name|new
operator|.
name|rts_gate
operator|=
name|ifp
operator|->
name|int_addr
expr_stmt|;
name|new
operator|.
name|rts_router
operator|=
name|ifp
operator|->
name|int_addr
expr_stmt|;
name|new
operator|.
name|rts_metric
operator|=
name|ifp
operator|->
name|int_metric
expr_stmt|;
name|rtadd
argument_list|(
name|ifp
operator|->
name|int_std_addr
argument_list|,
name|ifp
operator|->
name|int_std_mask
argument_list|,
name|RS_NET_SYN
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ifp
operator|->
name|int_state
operator|&=
operator|~
name|IS_NEED_NET_SYN
expr_stmt|;
name|rt
operator|=
name|rtget
argument_list|(
name|ifp
operator|->
name|int_std_addr
argument_list|,
name|ifp
operator|->
name|int_std_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
operator|&&
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_NET_SYN
operator|)
operator|&&
name|rt
operator|->
name|rt_ifp
operator|==
name|ifp
condition|)
name|rtbad_sub
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add route for interface if not currently installed.  * Create route to other end if a point-to-point link,  * otherwise a route to this (sub)network.  */
end_comment

begin_function
specifier|static
name|int
comment|/* 0=bad interface */
name|addrouteforif
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
specifier|static
name|struct
name|rt_spare
name|new
decl_stmt|;
name|naddr
name|dst
decl_stmt|;
comment|/* skip sick interfaces 	 */
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
condition|)
return|return
literal|0
return|;
comment|/* If the interface on a subnet, then install a RIPv1 route to 	 * the network as well (unless it is sick). 	 */
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_SUBNET
condition|)
name|check_net_syn
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|(
literal|0
operator|!=
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
operator|(
name|IFF_POINTOPOINT
operator||
name|IFF_LOOPBACK
operator|)
operator|)
condition|?
name|ifp
operator|->
name|int_dstaddr
else|:
name|htonl
argument_list|(
name|ifp
operator|->
name|int_net
argument_list|)
operator|)
expr_stmt|;
name|new
operator|.
name|rts_ifp
operator|=
name|ifp
expr_stmt|;
name|new
operator|.
name|rts_router
operator|=
name|ifp
operator|->
name|int_addr
expr_stmt|;
name|new
operator|.
name|rts_gate
operator|=
name|ifp
operator|->
name|int_addr
expr_stmt|;
name|new
operator|.
name|rts_metric
operator|=
name|ifp
operator|->
name|int_metric
expr_stmt|;
name|new
operator|.
name|rts_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
comment|/* If we are going to send packets to the gateway, 	 * it must be reachable using our physical interfaces 	 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_EXTERNAL
operator|)
operator|&&
operator|!
name|check_remote
argument_list|(
name|ifp
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We are finished if the correct main interface route exists. 	 * The right route must be for the right interface, not synthesized 	 * from a subnet, be a "gateway" or not as appropriate, and so forth. 	 */
name|del_static
argument_list|(
name|dst
argument_list|,
name|ifp
operator|->
name|int_mask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rt
operator|=
name|rtget
argument_list|(
name|dst
argument_list|,
name|ifp
operator|->
name|int_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_ifp
operator|!=
name|ifp
operator|||
name|rt
operator|->
name|rt_router
operator|!=
name|ifp
operator|->
name|int_addr
operator|)
operator|&&
operator|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_DUP
operator|)
operator|||
name|rt
operator|->
name|rt_ifp
operator|==
literal|0
operator|||
operator|(
name|rt
operator|->
name|rt_ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
operator|)
operator|)
condition|)
block|{
name|rtdelete
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rtchange
argument_list|(
name|rt
argument_list|,
operator|(
operator|(
name|rt
operator|->
name|rt_state
operator||
name|RS_IF
operator|)
operator|&
operator|~
operator|(
name|RS_NET_SYN
operator||
name|RS_LOCAL
operator|)
operator|)
argument_list|,
operator|&
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_transitions
operator|++
operator|>
literal|0
condition|)
name|trace_act
argument_list|(
literal|"re-install interface %s"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
name|rtadd
argument_list|(
name|dst
argument_list|,
name|ifp
operator|->
name|int_mask
argument_list|,
name|RS_IF
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

