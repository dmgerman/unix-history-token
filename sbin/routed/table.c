begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$Revision: 2.27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_empty
empty|#ident "$Revision: 2.27 $"
end_empty

begin_endif
endif|#
directive|endif
end_endif

begin_empty
empty|#ident "$FreeBSD$"
end_empty

begin_function_decl
specifier|static
name|struct
name|rt_spare
modifier|*
name|rts_better
parameter_list|(
name|struct
name|rt_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|rt_spare
name|rts_empty
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|HOPCNT_INFINITY
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|set_need_flash
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|_HAVE_SIN_LEN
end_ifdef

begin_function_decl
specifier|static
name|void
name|masktrim
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|masktrim
parameter_list|(
name|struct
name|sockaddr_in_new
modifier|*
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|radix_node_head
modifier|*
name|rhead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* root of the radix tree */
end_comment

begin_decl_stmt
name|int
name|need_flash
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flash update needed 					 * start =1 to suppress the 1st 					 */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|age_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next check of old routes */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|need_kern
init|=
block|{
comment|/* need to update kernel table */
name|EPOCH
operator|+
name|MIN_WAITTIME
operator|-
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stopint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|total_routes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zap any old routes through this gateway */
end_comment

begin_decl_stmt
name|naddr
name|age_bad_gate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* It is desirable to "aggregate" routes, to combine differing routes of  * the same metric and next hop into a common route with a smaller netmask  * or to suppress redundant routes, routes that add no information to  * routes with smaller netmasks.  *  * A route is redundant if and only if any and all routes with smaller  * but matching netmasks and nets are the same.  Since routes are  * kept sorted in the radix tree, redundant routes always come second.  *  * There are two kinds of aggregations.  First, two routes of the same bit  * mask and differing only in the least significant bit of the network  * number can be combined into a single route with a coarser mask.  *  * Second, a route can be suppressed in favor of another route with a more  * coarse mask provided no incompatible routes with intermediate masks  * are present.  The second kind of aggregation involves suppressing routes.  * A route must not be suppressed if an incompatible route exists with  * an intermediate mask, since the suppressed route would be covered  * by the intermediate.  *  * This code relies on the radix tree walk encountering routes  * sorted first by address, with the smallest address first.  */
end_comment

begin_decl_stmt
name|struct
name|ag_info
name|ag_slots
index|[
name|NUM_AG_SLOTS
index|]
decl_stmt|,
modifier|*
name|ag_avail
decl_stmt|,
modifier|*
name|ag_corsest
decl_stmt|,
modifier|*
name|ag_finest
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #define DEBUG_AG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_AG
end_ifdef

begin_define
define|#
directive|define
name|CHECK_AG
parameter_list|()
value|{int acnt = 0; struct ag_info *cag;		\ 	for (cag = ag_avail; cag != 0; cag = cag->ag_fine)	\ 		acnt++;						\ 	for (cag = ag_corsest; cag != 0; cag = cag->ag_fine)	\ 		acnt++;						\ 	if (acnt != NUM_AG_SLOTS) {				\ 		(void)fflush(stderr);				\ 		abort();					\ 	}							\ }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHECK_AG
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Output the contents of an aggregation table slot.  *	This function must always be immediately followed with the deletion  *	of the target slot.  */
end_comment

begin_function
specifier|static
name|void
name|ag_out
parameter_list|(
name|struct
name|ag_info
modifier|*
name|ag
parameter_list|,
name|void
function_decl|(
modifier|*
name|out
function_decl|)
parameter_list|(
name|struct
name|ag_info
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|ag_info
modifier|*
name|ag_cors
decl_stmt|;
name|naddr
name|bit
decl_stmt|;
comment|/* Forget it if this route should not be output for split-horizon. */
if|if
condition|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_SPLIT_HZ
condition|)
return|return;
comment|/* If we output both the even and odd twins, then the immediate parent, 	 * if it is present, is redundant, unless the parent manages to 	 * aggregate into something coarser. 	 * On successive calls, this code detects the even and odd twins, 	 * and marks the parent. 	 * 	 * Note that the order in which the radix tree code emits routes 	 * ensures that the twins are seen before the parent is emitted. 	 */
name|ag_cors
operator|=
name|ag
operator|->
name|ag_cors
expr_stmt|;
if|if
condition|(
name|ag_cors
operator|!=
literal|0
operator|&&
name|ag_cors
operator|->
name|ag_mask
operator|==
name|ag
operator|->
name|ag_mask
operator|<<
literal|1
operator|&&
name|ag_cors
operator|->
name|ag_dst_h
operator|==
operator|(
name|ag
operator|->
name|ag_dst_h
operator|&
name|ag_cors
operator|->
name|ag_mask
operator|)
condition|)
block|{
name|ag_cors
operator|->
name|ag_state
operator||=
operator|(
operator|(
name|ag_cors
operator|->
name|ag_dst_h
operator|==
name|ag
operator|->
name|ag_dst_h
operator|)
condition|?
name|AGS_REDUN0
else|:
name|AGS_REDUN1
operator|)
expr_stmt|;
block|}
comment|/* Skip it if this route is itself redundant. 	 * 	 * It is ok to change the contents of the slot here, since it is 	 * always deleted next. 	 */
if|if
condition|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_REDUN0
condition|)
block|{
if|if
condition|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_REDUN1
condition|)
return|return;
comment|/* quit if fully redundant */
comment|/* make it finer if it is half-redundant */
name|bit
operator|=
operator|(
operator|-
name|ag
operator|->
name|ag_mask
operator|)
operator|>>
literal|1
expr_stmt|;
name|ag
operator|->
name|ag_dst_h
operator||=
name|bit
expr_stmt|;
name|ag
operator|->
name|ag_mask
operator||=
name|bit
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_REDUN1
condition|)
block|{
comment|/* make it finer if it is half-redundant */
name|bit
operator|=
operator|(
operator|-
name|ag
operator|->
name|ag_mask
operator|)
operator|>>
literal|1
expr_stmt|;
name|ag
operator|->
name|ag_mask
operator||=
name|bit
expr_stmt|;
block|}
name|out
argument_list|(
name|ag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ag_del
parameter_list|(
name|struct
name|ag_info
modifier|*
name|ag
parameter_list|)
block|{
name|CHECK_AG
argument_list|()
expr_stmt|;
if|if
condition|(
name|ag
operator|->
name|ag_cors
operator|==
literal|0
condition|)
name|ag_corsest
operator|=
name|ag
operator|->
name|ag_fine
expr_stmt|;
else|else
name|ag
operator|->
name|ag_cors
operator|->
name|ag_fine
operator|=
name|ag
operator|->
name|ag_fine
expr_stmt|;
if|if
condition|(
name|ag
operator|->
name|ag_fine
operator|==
literal|0
condition|)
name|ag_finest
operator|=
name|ag
operator|->
name|ag_cors
expr_stmt|;
else|else
name|ag
operator|->
name|ag_fine
operator|->
name|ag_cors
operator|=
name|ag
operator|->
name|ag_cors
expr_stmt|;
name|ag
operator|->
name|ag_fine
operator|=
name|ag_avail
expr_stmt|;
name|ag_avail
operator|=
name|ag
expr_stmt|;
name|CHECK_AG
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush routes waiting for aggregation.  *	This must not suppress a route unless it is known that among all  *	routes with coarser masks that match it, the one with the longest  *	mask is appropriate.  This is ensured by scanning the routes  *	in lexical order, and with the most restrictive mask first  *	among routes to the same destination.  */
end_comment

begin_function
name|void
name|ag_flush
parameter_list|(
name|naddr
name|lim_dst_h
parameter_list|,
comment|/* flush routes to here */
name|naddr
name|lim_mask
parameter_list|,
comment|/* matching this mask */
name|void
function_decl|(
modifier|*
name|out
function_decl|)
parameter_list|(
name|struct
name|ag_info
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|ag_info
modifier|*
name|ag
decl_stmt|,
modifier|*
name|ag_cors
decl_stmt|;
name|naddr
name|dst_h
decl_stmt|;
for|for
control|(
name|ag
operator|=
name|ag_finest
init|;
name|ag
operator|!=
literal|0
operator|&&
name|ag
operator|->
name|ag_mask
operator|>=
name|lim_mask
condition|;
name|ag
operator|=
name|ag_cors
control|)
block|{
name|ag_cors
operator|=
name|ag
operator|->
name|ag_cors
expr_stmt|;
comment|/* work on only the specified routes */
name|dst_h
operator|=
name|ag
operator|->
name|ag_dst_h
expr_stmt|;
if|if
condition|(
operator|(
name|dst_h
operator|&
name|lim_mask
operator|)
operator|!=
name|lim_dst_h
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_SUPPRESS
operator|)
condition|)
name|ag_out
argument_list|(
name|ag
argument_list|,
name|out
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
condition|;
name|ag_cors
operator|=
name|ag_cors
operator|->
name|ag_cors
control|)
block|{
comment|/* Look for a route that can suppress the 			 * current route */
if|if
condition|(
name|ag_cors
operator|==
literal|0
condition|)
block|{
comment|/* failed, so output it and look for 				 * another route to work on 				 */
name|ag_out
argument_list|(
name|ag
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|dst_h
operator|&
name|ag_cors
operator|->
name|ag_mask
operator|)
operator|==
name|ag_cors
operator|->
name|ag_dst_h
condition|)
block|{
comment|/* We found a route with a coarser mask that 				 * aggregates the current target. 				 * 				 * If it has a different next hop, it 				 * cannot replace the target, so output 				 * the target. 				 */
if|if
condition|(
name|ag
operator|->
name|ag_gate
operator|!=
name|ag_cors
operator|->
name|ag_gate
operator|&&
operator|!
operator|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_FINE_GATE
operator|)
operator|&&
operator|!
operator|(
name|ag_cors
operator|->
name|ag_state
operator|&
name|AGS_CORS_GATE
operator|)
condition|)
block|{
name|ag_out
argument_list|(
name|ag
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If the coarse route has a good enough 				 * metric, it suppresses the target. 				 * If the suppressed target was redundant, 				 * then mark the suppressor redundant. 				 */
if|if
condition|(
name|ag_cors
operator|->
name|ag_pref
operator|<=
name|ag
operator|->
name|ag_pref
condition|)
block|{
if|if
condition|(
name|AG_IS_REDUN
argument_list|(
name|ag
operator|->
name|ag_state
argument_list|)
operator|&&
name|ag_cors
operator|->
name|ag_mask
operator|==
name|ag
operator|->
name|ag_mask
operator|<<
literal|1
condition|)
block|{
if|if
condition|(
name|ag_cors
operator|->
name|ag_dst_h
operator|==
name|dst_h
condition|)
name|ag_cors
operator|->
name|ag_state
operator||=
name|AGS_REDUN0
expr_stmt|;
else|else
name|ag_cors
operator|->
name|ag_state
operator||=
name|AGS_REDUN1
expr_stmt|;
block|}
if|if
condition|(
name|ag
operator|->
name|ag_tag
operator|!=
name|ag_cors
operator|->
name|ag_tag
condition|)
name|ag_cors
operator|->
name|ag_tag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ag
operator|->
name|ag_nhop
operator|!=
name|ag_cors
operator|->
name|ag_nhop
condition|)
name|ag_cors
operator|->
name|ag_nhop
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* That route has either been output or suppressed */
name|ag_cors
operator|=
name|ag
operator|->
name|ag_cors
expr_stmt|;
name|ag_del
argument_list|(
name|ag
argument_list|)
expr_stmt|;
block|}
name|CHECK_AG
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to aggregate a route with previous routes.  */
end_comment

begin_function
name|void
name|ag_check
parameter_list|(
name|naddr
name|dst
parameter_list|,
name|naddr
name|mask
parameter_list|,
name|naddr
name|gate
parameter_list|,
name|naddr
name|nhop
parameter_list|,
name|char
name|metric
parameter_list|,
name|char
name|pref
parameter_list|,
name|u_int
name|new_seqno
parameter_list|,
name|u_short
name|tag
parameter_list|,
name|u_short
name|state
parameter_list|,
name|void
function_decl|(
modifier|*
name|out
function_decl|)
parameter_list|(
name|struct
name|ag_info
modifier|*
parameter_list|)
parameter_list|)
comment|/* output using this */
block|{
name|struct
name|ag_info
modifier|*
name|ag
decl_stmt|,
modifier|*
name|nag
decl_stmt|,
modifier|*
name|ag_cors
decl_stmt|;
name|naddr
name|xaddr
decl_stmt|;
name|int
name|x
decl_stmt|;
name|dst
operator|=
name|ntohl
argument_list|(
name|dst
argument_list|)
expr_stmt|;
comment|/* Punt non-contiguous subnet masks. 	 * 	 * (X& -X) contains a single bit if and only if X is a power of 2. 	 * (X + (X& -X)) == 0 if and only if X is a power of 2. 	 */
if|if
condition|(
operator|(
name|mask
operator|&
operator|-
name|mask
operator|)
operator|+
name|mask
operator|!=
literal|0
condition|)
block|{
name|struct
name|ag_info
name|nc_ag
decl_stmt|;
name|nc_ag
operator|.
name|ag_dst_h
operator|=
name|dst
expr_stmt|;
name|nc_ag
operator|.
name|ag_mask
operator|=
name|mask
expr_stmt|;
name|nc_ag
operator|.
name|ag_gate
operator|=
name|gate
expr_stmt|;
name|nc_ag
operator|.
name|ag_nhop
operator|=
name|nhop
expr_stmt|;
name|nc_ag
operator|.
name|ag_metric
operator|=
name|metric
expr_stmt|;
name|nc_ag
operator|.
name|ag_pref
operator|=
name|pref
expr_stmt|;
name|nc_ag
operator|.
name|ag_tag
operator|=
name|tag
expr_stmt|;
name|nc_ag
operator|.
name|ag_state
operator|=
name|state
expr_stmt|;
name|nc_ag
operator|.
name|ag_seqno
operator|=
name|new_seqno
expr_stmt|;
name|out
argument_list|(
operator|&
name|nc_ag
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Search for the right slot in the aggregation table. 	 */
name|ag_cors
operator|=
literal|0
expr_stmt|;
name|ag
operator|=
name|ag_corsest
expr_stmt|;
while|while
condition|(
name|ag
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ag
operator|->
name|ag_mask
operator|>=
name|mask
condition|)
break|break;
comment|/* Suppress old routes (i.e. combine with compatible routes 		 * with coarser masks) as we look for the right slot in the 		 * aggregation table for the new route. 		 * A route to an address less than the current destination 		 * will not be affected by the current route or any route 		 * seen hereafter.  That means it is safe to suppress it. 		 * This check keeps poor routes (e.g. with large hop counts) 		 * from preventing suppression of finer routes. 		 */
if|if
condition|(
name|ag_cors
operator|!=
literal|0
operator|&&
name|ag
operator|->
name|ag_dst_h
operator|<
name|dst
operator|&&
operator|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_SUPPRESS
operator|)
operator|&&
name|ag_cors
operator|->
name|ag_pref
operator|<=
name|ag
operator|->
name|ag_pref
operator|&&
operator|(
name|ag
operator|->
name|ag_dst_h
operator|&
name|ag_cors
operator|->
name|ag_mask
operator|)
operator|==
name|ag_cors
operator|->
name|ag_dst_h
operator|&&
operator|(
name|ag_cors
operator|->
name|ag_gate
operator|==
name|ag
operator|->
name|ag_gate
operator|||
operator|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_FINE_GATE
operator|)
operator|||
operator|(
name|ag_cors
operator|->
name|ag_state
operator|&
name|AGS_CORS_GATE
operator|)
operator|)
condition|)
block|{
comment|/*  If the suppressed target was redundant, 			 * then mark the suppressor redundant. 			 */
if|if
condition|(
name|AG_IS_REDUN
argument_list|(
name|ag
operator|->
name|ag_state
argument_list|)
operator|&&
name|ag_cors
operator|->
name|ag_mask
operator|==
name|ag
operator|->
name|ag_mask
operator|<<
literal|1
condition|)
block|{
if|if
condition|(
name|ag_cors
operator|->
name|ag_dst_h
operator|==
name|dst
condition|)
name|ag_cors
operator|->
name|ag_state
operator||=
name|AGS_REDUN0
expr_stmt|;
else|else
name|ag_cors
operator|->
name|ag_state
operator||=
name|AGS_REDUN1
expr_stmt|;
block|}
if|if
condition|(
name|ag
operator|->
name|ag_tag
operator|!=
name|ag_cors
operator|->
name|ag_tag
condition|)
name|ag_cors
operator|->
name|ag_tag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ag
operator|->
name|ag_nhop
operator|!=
name|ag_cors
operator|->
name|ag_nhop
condition|)
name|ag_cors
operator|->
name|ag_nhop
operator|=
literal|0
expr_stmt|;
name|ag_del
argument_list|(
name|ag
argument_list|)
expr_stmt|;
name|CHECK_AG
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ag_cors
operator|=
name|ag
expr_stmt|;
block|}
name|ag
operator|=
name|ag_cors
operator|->
name|ag_fine
expr_stmt|;
block|}
comment|/* If we find the even/odd twin of the new route, and if the 	 * masks and so forth are equal, we can aggregate them. 	 * We can probably promote one of the pair. 	 * 	 * Since the routes are encountered in lexical order, 	 * the new route must be odd.  However, the second or later 	 * times around this loop, it could be the even twin promoted 	 * from the even/odd pair of twins of the finer route. 	 */
while|while
condition|(
name|ag
operator|!=
literal|0
operator|&&
name|ag
operator|->
name|ag_mask
operator|==
name|mask
operator|&&
operator|(
operator|(
name|ag
operator|->
name|ag_dst_h
operator|^
name|dst
operator|)
operator|&
operator|(
name|mask
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Here we know the target route and the route in the current 		 * slot have the same netmasks and differ by at most the 		 * last bit.  They are either for the same destination, or 		 * for an even/odd pair of destinations. 		 */
if|if
condition|(
name|ag
operator|->
name|ag_dst_h
operator|==
name|dst
condition|)
block|{
comment|/* We have two routes to the same destination. 			 * Routes are encountered in lexical order, so a 			 * route is never promoted until the parent route is 			 * already present.  So we know that the new route is 			 * a promoted (or aggregated) pair and the route 			 * already in the slot is the explicit route. 			 * 			 * Prefer the best route if their metrics differ, 			 * or the aggregated one if not, following a sort 			 * of longest-match rule. 			 */
if|if
condition|(
name|pref
operator|<=
name|ag
operator|->
name|ag_pref
condition|)
block|{
name|ag
operator|->
name|ag_gate
operator|=
name|gate
expr_stmt|;
name|ag
operator|->
name|ag_nhop
operator|=
name|nhop
expr_stmt|;
name|ag
operator|->
name|ag_tag
operator|=
name|tag
expr_stmt|;
name|ag
operator|->
name|ag_metric
operator|=
name|metric
expr_stmt|;
name|ag
operator|->
name|ag_pref
operator|=
name|pref
expr_stmt|;
if|if
condition|(
name|ag
operator|->
name|ag_seqno
operator|<
name|new_seqno
condition|)
name|ag
operator|->
name|ag_seqno
operator|=
name|new_seqno
expr_stmt|;
name|x
operator|=
name|ag
operator|->
name|ag_state
expr_stmt|;
name|ag
operator|->
name|ag_state
operator|=
name|state
expr_stmt|;
name|state
operator|=
name|x
expr_stmt|;
block|}
comment|/* Some bits are set if they are set on either route, 			 * except when the route is for an interface. 			 */
if|if
condition|(
operator|!
operator|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_IF
operator|)
condition|)
name|ag
operator|->
name|ag_state
operator||=
operator|(
name|state
operator|&
operator|(
name|AGS_AGGREGATE_EITHER
operator||
name|AGS_REDUN0
operator||
name|AGS_REDUN1
operator|)
operator|)
expr_stmt|;
return|return;
block|}
comment|/* If one of the routes can be promoted and the other can 		 * be suppressed, it may be possible to combine them or 		 * worthwhile to promote one. 		 * 		 * Any route that can be promoted is always 		 * marked to be eligible to be suppressed. 		 */
if|if
condition|(
operator|!
operator|(
operator|(
name|state
operator|&
name|AGS_AGGREGATE
operator|)
operator|&&
operator|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_SUPPRESS
operator|)
operator|)
operator|&&
operator|!
operator|(
operator|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_AGGREGATE
operator|)
operator|&&
operator|(
name|state
operator|&
name|AGS_SUPPRESS
operator|)
operator|)
condition|)
break|break;
comment|/* A pair of even/odd twin routes can be combined 		 * if either is redundant, or if they are via the 		 * same gateway and have the same metric. 		 */
if|if
condition|(
name|AG_IS_REDUN
argument_list|(
name|ag
operator|->
name|ag_state
argument_list|)
operator|||
name|AG_IS_REDUN
argument_list|(
name|state
argument_list|)
operator|||
operator|(
name|ag
operator|->
name|ag_gate
operator|==
name|gate
operator|&&
name|ag
operator|->
name|ag_pref
operator|==
name|pref
operator|&&
operator|(
name|state
operator|&
name|ag
operator|->
name|ag_state
operator|&
name|AGS_AGGREGATE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* We have both the even and odd pairs. 			 * Since the routes are encountered in order, 			 * the route in the slot must be the even twin. 			 * 			 * Combine and promote (aggregate) the pair of routes. 			 */
if|if
condition|(
name|new_seqno
operator|<
name|ag
operator|->
name|ag_seqno
condition|)
name|new_seqno
operator|=
name|ag
operator|->
name|ag_seqno
expr_stmt|;
if|if
condition|(
operator|!
name|AG_IS_REDUN
argument_list|(
name|state
argument_list|)
condition|)
name|state
operator|&=
operator|~
name|AGS_REDUN1
expr_stmt|;
if|if
condition|(
name|AG_IS_REDUN
argument_list|(
name|ag
operator|->
name|ag_state
argument_list|)
condition|)
name|state
operator||=
name|AGS_REDUN0
expr_stmt|;
else|else
name|state
operator|&=
operator|~
name|AGS_REDUN0
expr_stmt|;
name|state
operator||=
operator|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_AGGREGATE_EITHER
operator|)
expr_stmt|;
if|if
condition|(
name|ag
operator|->
name|ag_tag
operator|!=
name|tag
condition|)
name|tag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ag
operator|->
name|ag_nhop
operator|!=
name|nhop
condition|)
name|nhop
operator|=
literal|0
expr_stmt|;
comment|/* Get rid of the even twin that was already 			 * in the slot. 			 */
name|ag_del
argument_list|(
name|ag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ag
operator|->
name|ag_pref
operator|>=
name|pref
operator|&&
operator|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_AGGREGATE
operator|)
condition|)
block|{
comment|/* If we cannot combine the pair, maybe the route 			 * with the worse metric can be promoted. 			 * 			 * Promote the old, even twin, by giving its slot 			 * in the table to the new, odd twin. 			 */
name|ag
operator|->
name|ag_dst_h
operator|=
name|dst
expr_stmt|;
name|xaddr
operator|=
name|ag
operator|->
name|ag_gate
expr_stmt|;
name|ag
operator|->
name|ag_gate
operator|=
name|gate
expr_stmt|;
name|gate
operator|=
name|xaddr
expr_stmt|;
name|xaddr
operator|=
name|ag
operator|->
name|ag_nhop
expr_stmt|;
name|ag
operator|->
name|ag_nhop
operator|=
name|nhop
expr_stmt|;
name|nhop
operator|=
name|xaddr
expr_stmt|;
name|x
operator|=
name|ag
operator|->
name|ag_tag
expr_stmt|;
name|ag
operator|->
name|ag_tag
operator|=
name|tag
expr_stmt|;
name|tag
operator|=
name|x
expr_stmt|;
comment|/* The promoted route is even-redundant only if the 			 * even twin was fully redundant.  It is not 			 * odd-redundant because the odd-twin will still be 			 * in the table. 			 */
name|x
operator|=
name|ag
operator|->
name|ag_state
expr_stmt|;
if|if
condition|(
operator|!
name|AG_IS_REDUN
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|&=
operator|~
name|AGS_REDUN0
expr_stmt|;
name|x
operator|&=
operator|~
name|AGS_REDUN1
expr_stmt|;
name|ag
operator|->
name|ag_state
operator|=
name|state
expr_stmt|;
name|state
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|ag
operator|->
name|ag_metric
expr_stmt|;
name|ag
operator|->
name|ag_metric
operator|=
name|metric
expr_stmt|;
name|metric
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|ag
operator|->
name|ag_pref
expr_stmt|;
name|ag
operator|->
name|ag_pref
operator|=
name|pref
expr_stmt|;
name|pref
operator|=
name|x
expr_stmt|;
comment|/* take the newest sequence number */
if|if
condition|(
name|new_seqno
operator|<=
name|ag
operator|->
name|ag_seqno
condition|)
name|new_seqno
operator|=
name|ag
operator|->
name|ag_seqno
expr_stmt|;
else|else
name|ag
operator|->
name|ag_seqno
operator|=
name|new_seqno
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|state
operator|&
name|AGS_AGGREGATE
operator|)
condition|)
break|break;
comment|/* cannot promote either twin */
comment|/* Promote the new, odd twin by shaving its 			 * mask and address. 			 * The promoted route is odd-redundant only if the 			 * odd twin was fully redundant.  It is not 			 * even-redundant because the even twin is still in 			 * the table. 			 */
if|if
condition|(
operator|!
name|AG_IS_REDUN
argument_list|(
name|state
argument_list|)
condition|)
name|state
operator|&=
operator|~
name|AGS_REDUN1
expr_stmt|;
name|state
operator|&=
operator|~
name|AGS_REDUN0
expr_stmt|;
if|if
condition|(
name|new_seqno
operator|<
name|ag
operator|->
name|ag_seqno
condition|)
name|new_seqno
operator|=
name|ag
operator|->
name|ag_seqno
expr_stmt|;
else|else
name|ag
operator|->
name|ag_seqno
operator|=
name|new_seqno
expr_stmt|;
block|}
name|mask
operator|<<=
literal|1
expr_stmt|;
name|dst
operator|&=
name|mask
expr_stmt|;
if|if
condition|(
name|ag_cors
operator|==
literal|0
condition|)
block|{
name|ag
operator|=
name|ag_corsest
expr_stmt|;
break|break;
block|}
name|ag
operator|=
name|ag_cors
expr_stmt|;
name|ag_cors
operator|=
name|ag
operator|->
name|ag_cors
expr_stmt|;
block|}
comment|/* When we can no longer promote and combine routes, 	 * flush the old route in the target slot.  Also flush 	 * any finer routes that we know will never be aggregated by 	 * the new route. 	 * 	 * In case we moved toward coarser masks, 	 * get back where we belong 	 */
if|if
condition|(
name|ag
operator|!=
literal|0
operator|&&
name|ag
operator|->
name|ag_mask
operator|<
name|mask
condition|)
block|{
name|ag_cors
operator|=
name|ag
expr_stmt|;
name|ag
operator|=
name|ag
operator|->
name|ag_fine
expr_stmt|;
block|}
comment|/* Empty the target slot 	 */
if|if
condition|(
name|ag
operator|!=
literal|0
operator|&&
name|ag
operator|->
name|ag_mask
operator|==
name|mask
condition|)
block|{
name|ag_flush
argument_list|(
name|ag
operator|->
name|ag_dst_h
argument_list|,
name|ag
operator|->
name|ag_mask
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|ag
operator|=
operator|(
name|ag_cors
operator|==
literal|0
operator|)
condition|?
name|ag_corsest
else|:
name|ag_cors
operator|->
name|ag_fine
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_AG
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ag
operator|==
literal|0
operator|&&
name|ag_cors
operator|!=
name|ag_finest
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ag_cors
operator|==
literal|0
operator|&&
name|ag
operator|!=
name|ag_corsest
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ag
operator|!=
literal|0
operator|&&
name|ag
operator|->
name|ag_cors
operator|!=
name|ag_cors
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ag_cors
operator|!=
literal|0
operator|&&
name|ag_cors
operator|->
name|ag_fine
operator|!=
name|ag
condition|)
name|abort
argument_list|()
expr_stmt|;
name|CHECK_AG
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Save the new route on the end of the table. 	 */
name|nag
operator|=
name|ag_avail
expr_stmt|;
name|ag_avail
operator|=
name|nag
operator|->
name|ag_fine
expr_stmt|;
name|nag
operator|->
name|ag_dst_h
operator|=
name|dst
expr_stmt|;
name|nag
operator|->
name|ag_mask
operator|=
name|mask
expr_stmt|;
name|nag
operator|->
name|ag_gate
operator|=
name|gate
expr_stmt|;
name|nag
operator|->
name|ag_nhop
operator|=
name|nhop
expr_stmt|;
name|nag
operator|->
name|ag_metric
operator|=
name|metric
expr_stmt|;
name|nag
operator|->
name|ag_pref
operator|=
name|pref
expr_stmt|;
name|nag
operator|->
name|ag_tag
operator|=
name|tag
expr_stmt|;
name|nag
operator|->
name|ag_state
operator|=
name|state
expr_stmt|;
name|nag
operator|->
name|ag_seqno
operator|=
name|new_seqno
expr_stmt|;
name|nag
operator|->
name|ag_fine
operator|=
name|ag
expr_stmt|;
if|if
condition|(
name|ag
operator|!=
literal|0
condition|)
name|ag
operator|->
name|ag_cors
operator|=
name|nag
expr_stmt|;
else|else
name|ag_finest
operator|=
name|nag
expr_stmt|;
name|nag
operator|->
name|ag_cors
operator|=
name|ag_cors
expr_stmt|;
if|if
condition|(
name|ag_cors
operator|==
literal|0
condition|)
name|ag_corsest
operator|=
name|nag
expr_stmt|;
else|else
name|ag_cors
operator|->
name|ag_fine
operator|=
name|nag
expr_stmt|;
name|CHECK_AG
argument_list|()
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NAME0_LEN
value|14
end_define

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rtm_type_name
parameter_list|(
name|u_char
name|type
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|rtm_types
index|[]
init|=
block|{
literal|"RTM_ADD"
block|,
literal|"RTM_DELETE"
block|,
literal|"RTM_CHANGE"
block|,
literal|"RTM_GET"
block|,
literal|"RTM_LOSING"
block|,
literal|"RTM_REDIRECT"
block|,
literal|"RTM_MISS"
block|,
literal|"RTM_LOCK"
block|,
literal|"RTM_OLDADD"
block|,
literal|"RTM_OLDDEL"
block|,
literal|"RTM_RESOLVE"
block|,
literal|"RTM_NEWADDR"
block|,
literal|"RTM_DELADDR"
block|,
ifdef|#
directive|ifdef
name|RTM_OIFINFO
literal|"RTM_OIFINFO"
block|,
endif|#
directive|endif
literal|"RTM_IFINFO"
block|,
literal|"RTM_NEWMADDR"
block|,
literal|"RTM_DELMADDR"
block|}
decl_stmt|;
define|#
directive|define
name|NEW_RTM_PAT
value|"RTM type %#x"
specifier|static
name|char
name|name0
index|[
sizeof|sizeof
argument_list|(
name|NEW_RTM_PAT
argument_list|)
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|type
operator|>
sizeof|sizeof
argument_list|(
name|rtm_types
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rtm_types
index|[
literal|0
index|]
argument_list|)
operator|||
name|type
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|name0
argument_list|,
sizeof|sizeof
argument_list|(
name|name0
argument_list|)
argument_list|,
name|NEW_RTM_PAT
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|name0
return|;
block|}
else|else
block|{
return|return
name|rtm_types
index|[
name|type
operator|-
literal|1
index|]
return|;
block|}
undef|#
directive|undef
name|NEW_RTM_PAT
block|}
end_function

begin_comment
comment|/* Trim a mask in a sockaddr  *	Produce a length of 0 for an address of 0.  *	Otherwise produce the index of the first zero byte.  */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|_HAVE_SIN_LEN
name|masktrim
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|ap
parameter_list|)
else|#
directive|else
function|masktrim
parameter_list|(
name|struct
name|sockaddr_in_new
modifier|*
name|ap
parameter_list|)
endif|#
directive|endif
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
name|ap
operator|->
name|sin_len
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|ap
operator|->
name|sin_addr
operator|.
name|s_addr
operator|+
literal|1
operator|)
expr_stmt|;
while|while
condition|(
operator|*
operator|--
name|cp
operator|==
literal|0
condition|)
continue|continue;
name|ap
operator|->
name|sin_len
operator|=
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|ap
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell the kernel to add, delete or change a route  */
end_comment

begin_function
specifier|static
name|void
name|rtioctl
parameter_list|(
name|int
name|action
parameter_list|,
comment|/* RTM_DELETE, etc */
name|naddr
name|dst
parameter_list|,
name|naddr
name|gate
parameter_list|,
name|naddr
name|mask
parameter_list|,
name|int
name|metric
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
struct|struct
block|{
name|struct
name|rt_msghdr
name|w_rtm
decl_stmt|;
name|struct
name|sockaddr_in
name|w_dst
decl_stmt|;
name|struct
name|sockaddr_in
name|w_gate
decl_stmt|;
ifdef|#
directive|ifdef
name|_HAVE_SA_LEN
name|struct
name|sockaddr_in
name|w_mask
decl_stmt|;
else|#
directive|else
name|struct
name|sockaddr_in_new
name|w_mask
decl_stmt|;
endif|#
directive|endif
block|}
name|w
struct|;
name|long
name|cc
decl_stmt|;
define|#
directive|define
name|PAT
value|" %-10s %s metric=%d flags=%#x"
define|#
directive|define
name|ARGS
value|rtm_type_name(action), rtname(dst,mask,gate), metric, flags
name|again
label|:
name|memset
argument_list|(
operator|&
name|w
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|w_rtm
operator|.
name|rtm_msglen
operator|=
sizeof|sizeof
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|.
name|w_rtm
operator|.
name|rtm_version
operator|=
name|RTM_VERSION
expr_stmt|;
name|w
operator|.
name|w_rtm
operator|.
name|rtm_type
operator|=
name|action
expr_stmt|;
name|w
operator|.
name|w_rtm
operator|.
name|rtm_flags
operator|=
name|flags
expr_stmt|;
name|w
operator|.
name|w_rtm
operator|.
name|rtm_seq
operator|=
operator|++
name|rt_sock_seqno
expr_stmt|;
name|w
operator|.
name|w_rtm
operator|.
name|rtm_addrs
operator|=
name|RTA_DST
operator||
name|RTA_GATEWAY
expr_stmt|;
if|if
condition|(
name|metric
operator|!=
literal|0
operator|||
name|action
operator|==
name|RTM_CHANGE
condition|)
block|{
name|w
operator|.
name|w_rtm
operator|.
name|rtm_rmx
operator|.
name|rmx_hopcount
operator|=
name|metric
expr_stmt|;
name|w
operator|.
name|w_rtm
operator|.
name|rtm_inits
operator||=
name|RTV_HOPCOUNT
expr_stmt|;
block|}
name|w
operator|.
name|w_dst
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|w
operator|.
name|w_dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|dst
expr_stmt|;
name|w
operator|.
name|w_gate
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|w
operator|.
name|w_gate
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|gate
expr_stmt|;
ifdef|#
directive|ifdef
name|_HAVE_SA_LEN
name|w
operator|.
name|w_dst
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|w
operator|.
name|w_dst
argument_list|)
expr_stmt|;
name|w
operator|.
name|w_gate
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|w
operator|.
name|w_gate
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mask
operator|==
name|HOST_MASK
condition|)
block|{
name|w
operator|.
name|w_rtm
operator|.
name|rtm_flags
operator||=
name|RTF_HOST
expr_stmt|;
name|w
operator|.
name|w_rtm
operator|.
name|rtm_msglen
operator|-=
sizeof|sizeof
argument_list|(
name|w
operator|.
name|w_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|w
operator|.
name|w_rtm
operator|.
name|rtm_addrs
operator||=
name|RTA_NETMASK
expr_stmt|;
name|w
operator|.
name|w_mask
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|mask
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_HAVE_SA_LEN
name|masktrim
argument_list|(
operator|&
name|w
operator|.
name|w_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|w_mask
operator|.
name|sin_len
operator|==
literal|0
condition|)
name|w
operator|.
name|w_mask
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|w
operator|.
name|w_rtm
operator|.
name|rtm_msglen
operator|-=
operator|(
sizeof|sizeof
argument_list|(
name|w
operator|.
name|w_mask
argument_list|)
operator|-
name|w
operator|.
name|w_mask
operator|.
name|sin_len
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|NO_INSTALL
name|cc
operator|=
name|write
argument_list|(
name|rt_sock
argument_list|,
operator|&
name|w
argument_list|,
name|w
operator|.
name|w_rtm
operator|.
name|rtm_msglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ESRCH
operator|&&
operator|(
name|action
operator|==
name|RTM_CHANGE
operator|||
name|action
operator|==
name|RTM_DELETE
operator|)
condition|)
block|{
name|trace_act
argument_list|(
literal|"route disappeared before"
name|PAT
argument_list|,
name|ARGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|RTM_CHANGE
condition|)
block|{
name|action
operator|=
name|RTM_ADD
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return;
block|}
name|msglog
argument_list|(
literal|"write(rt_sock)"
name|PAT
literal|": %s"
argument_list|,
name|ARGS
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cc
operator|!=
name|w
operator|.
name|w_rtm
operator|.
name|rtm_msglen
condition|)
block|{
name|msglog
argument_list|(
literal|"write(rt_sock) wrote %ld instead of %d for"
name|PAT
argument_list|,
name|cc
argument_list|,
name|w
operator|.
name|w_rtm
operator|.
name|rtm_msglen
argument_list|,
name|ARGS
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|TRACEKERNEL
condition|)
name|trace_misc
argument_list|(
literal|"write kernel"
name|PAT
argument_list|,
name|ARGS
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PAT
undef|#
directive|undef
name|ARGS
block|}
end_function

begin_define
define|#
directive|define
name|KHASH_SIZE
value|71
end_define

begin_comment
comment|/* should be prime */
end_comment

begin_define
define|#
directive|define
name|KHASH
parameter_list|(
name|a
parameter_list|,
name|m
parameter_list|)
value|khash_bins[((a) ^ (m)) % KHASH_SIZE]
end_define

begin_struct
specifier|static
struct|struct
name|khash
block|{
name|struct
name|khash
modifier|*
name|k_next
decl_stmt|;
name|naddr
name|k_dst
decl_stmt|;
name|naddr
name|k_mask
decl_stmt|;
name|naddr
name|k_gate
decl_stmt|;
name|short
name|k_metric
decl_stmt|;
name|u_short
name|k_state
decl_stmt|;
define|#
directive|define
name|KS_NEW
value|0x001
define|#
directive|define
name|KS_DELETE
value|0x002
comment|/* need to delete the route */
define|#
directive|define
name|KS_ADD
value|0x004
comment|/* add to the kernel */
define|#
directive|define
name|KS_CHANGE
value|0x008
comment|/* tell kernel to change the route */
define|#
directive|define
name|KS_DEL_ADD
value|0x010
comment|/* delete& add to change the kernel */
define|#
directive|define
name|KS_STATIC
value|0x020
comment|/* Static flag in kernel */
define|#
directive|define
name|KS_GATEWAY
value|0x040
comment|/* G flag in kernel */
define|#
directive|define
name|KS_DYNAMIC
value|0x080
comment|/* result of redirect */
define|#
directive|define
name|KS_DELETED
value|0x100
comment|/* already deleted from kernel */
define|#
directive|define
name|KS_CHECK
value|0x200
name|time_t
name|k_keep
decl_stmt|;
define|#
directive|define
name|K_KEEP_LIM
value|30
name|time_t
name|k_redirect_time
decl_stmt|;
comment|/* when redirected route 1st seen */
block|}
modifier|*
name|khash_bins
index|[
name|KHASH_SIZE
index|]
struct|;
end_struct

begin_function
specifier|static
name|struct
name|khash
modifier|*
name|kern_find
parameter_list|(
name|naddr
name|dst
parameter_list|,
name|naddr
name|mask
parameter_list|,
name|struct
name|khash
modifier|*
modifier|*
modifier|*
name|ppk
parameter_list|)
block|{
name|struct
name|khash
modifier|*
name|k
decl_stmt|,
modifier|*
modifier|*
name|pk
decl_stmt|;
for|for
control|(
name|pk
operator|=
operator|&
name|KHASH
argument_list|(
name|dst
argument_list|,
name|mask
argument_list|)
init|;
operator|(
name|k
operator|=
operator|*
name|pk
operator|)
operator|!=
literal|0
condition|;
name|pk
operator|=
operator|&
name|k
operator|->
name|k_next
control|)
block|{
if|if
condition|(
name|k
operator|->
name|k_dst
operator|==
name|dst
operator|&&
name|k
operator|->
name|k_mask
operator|==
name|mask
condition|)
break|break;
block|}
if|if
condition|(
name|ppk
operator|!=
literal|0
condition|)
operator|*
name|ppk
operator|=
name|pk
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|khash
modifier|*
name|kern_add
parameter_list|(
name|naddr
name|dst
parameter_list|,
name|naddr
name|mask
parameter_list|)
block|{
name|struct
name|khash
modifier|*
name|k
decl_stmt|,
modifier|*
modifier|*
name|pk
decl_stmt|;
name|k
operator|=
name|kern_find
argument_list|(
name|dst
argument_list|,
name|mask
argument_list|,
operator|&
name|pk
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
literal|0
condition|)
return|return
name|k
return|;
name|k
operator|=
operator|(
expr|struct
name|khash
operator|*
operator|)
name|rtmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|k
argument_list|)
argument_list|,
literal|"kern_add"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|k
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|->
name|k_dst
operator|=
name|dst
expr_stmt|;
name|k
operator|->
name|k_mask
operator|=
name|mask
expr_stmt|;
name|k
operator|->
name|k_state
operator|=
name|KS_NEW
expr_stmt|;
name|k
operator|->
name|k_keep
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
operator|*
name|pk
operator|=
name|k
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_comment
comment|/* If a kernel route has a non-zero metric, check that it is still in the  *	daemon table, and not deleted by interfaces coming and going.  */
end_comment

begin_function
specifier|static
name|void
name|kern_check_static
parameter_list|(
name|struct
name|khash
modifier|*
name|k
parameter_list|,
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
name|struct
name|rt_spare
name|new
decl_stmt|;
if|if
condition|(
name|k
operator|->
name|k_metric
operator|==
literal|0
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|.
name|rts_ifp
operator|=
name|ifp
expr_stmt|;
name|new
operator|.
name|rts_gate
operator|=
name|k
operator|->
name|k_gate
expr_stmt|;
name|new
operator|.
name|rts_router
operator|=
operator|(
name|ifp
operator|!=
literal|0
operator|)
condition|?
name|ifp
operator|->
name|int_addr
else|:
name|loopaddr
expr_stmt|;
name|new
operator|.
name|rts_metric
operator|=
name|k
operator|->
name|k_metric
expr_stmt|;
name|new
operator|.
name|rts_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|rt
operator|=
name|rtget
argument_list|(
name|k
operator|->
name|k_dst
argument_list|,
name|k
operator|->
name|k_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_STATIC
operator|)
condition|)
name|rtchange
argument_list|(
name|rt
argument_list|,
name|rt
operator|->
name|rt_state
operator||
name|RS_STATIC
argument_list|,
operator|&
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtadd
argument_list|(
name|k
operator|->
name|k_dst
argument_list|,
name|k
operator|->
name|k_mask
argument_list|,
name|RS_STATIC
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* operate on a kernel entry  */
end_comment

begin_function
specifier|static
name|void
name|kern_ioctl
parameter_list|(
name|struct
name|khash
modifier|*
name|k
parameter_list|,
name|int
name|action
parameter_list|,
comment|/* RTM_DELETE, etc */
name|int
name|flags
parameter_list|)
block|{
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|RTM_DELETE
case|:
name|k
operator|->
name|k_state
operator|&=
operator|~
name|KS_DYNAMIC
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|k_state
operator|&
name|KS_DELETED
condition|)
return|return;
name|k
operator|->
name|k_state
operator||=
name|KS_DELETED
expr_stmt|;
break|break;
case|case
name|RTM_ADD
case|:
name|k
operator|->
name|k_state
operator|&=
operator|~
name|KS_DELETED
expr_stmt|;
break|break;
case|case
name|RTM_CHANGE
case|:
if|if
condition|(
name|k
operator|->
name|k_state
operator|&
name|KS_DELETED
condition|)
block|{
name|action
operator|=
name|RTM_ADD
expr_stmt|;
name|k
operator|->
name|k_state
operator|&=
operator|~
name|KS_DELETED
expr_stmt|;
block|}
break|break;
block|}
name|rtioctl
argument_list|(
name|action
argument_list|,
name|k
operator|->
name|k_dst
argument_list|,
name|k
operator|->
name|k_gate
argument_list|,
name|k
operator|->
name|k_mask
argument_list|,
name|k
operator|->
name|k_metric
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add a route the kernel told us  */
end_comment

begin_function
specifier|static
name|void
name|rtm_add
parameter_list|(
name|struct
name|rt_msghdr
modifier|*
name|rtm
parameter_list|,
name|struct
name|rt_addrinfo
modifier|*
name|info
parameter_list|,
name|time_t
name|keep
parameter_list|)
block|{
name|struct
name|khash
modifier|*
name|k
decl_stmt|;
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|naddr
name|mask
decl_stmt|;
if|if
condition|(
name|rtm
operator|->
name|rtm_flags
operator|&
name|RTF_HOST
condition|)
block|{
name|mask
operator|=
name|HOST_MASK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INFO_MASK
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mask
operator|=
name|ntohl
argument_list|(
name|S_ADDR
argument_list|(
name|INFO_MASK
argument_list|(
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msglog
argument_list|(
literal|"ignore %s without mask"
argument_list|,
name|rtm_type_name
argument_list|(
name|rtm
operator|->
name|rtm_type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|k
operator|=
name|kern_add
argument_list|(
name|S_ADDR
argument_list|(
name|INFO_DST
argument_list|(
name|info
argument_list|)
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|k_state
operator|&
name|KS_NEW
condition|)
name|k
operator|->
name|k_keep
operator|=
name|now
operator|.
name|tv_sec
operator|+
name|keep
expr_stmt|;
if|if
condition|(
name|INFO_GATE
argument_list|(
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
name|trace_act
argument_list|(
literal|"note %s without gateway"
argument_list|,
name|rtm_type_name
argument_list|(
name|rtm
operator|->
name|rtm_type
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|->
name|k_metric
operator|=
name|HOPCNT_INFINITY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INFO_GATE
argument_list|(
name|info
argument_list|)
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
name|trace_act
argument_list|(
literal|"note %s with gateway AF=%d"
argument_list|,
name|rtm_type_name
argument_list|(
name|rtm
operator|->
name|rtm_type
argument_list|)
argument_list|,
name|INFO_GATE
argument_list|(
name|info
argument_list|)
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|k
operator|->
name|k_metric
operator|=
name|HOPCNT_INFINITY
expr_stmt|;
block|}
else|else
block|{
name|k
operator|->
name|k_gate
operator|=
name|S_ADDR
argument_list|(
name|INFO_GATE
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|->
name|k_metric
operator|=
name|rtm
operator|->
name|rtm_rmx
operator|.
name|rmx_hopcount
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|k_metric
operator|<
literal|0
condition|)
name|k
operator|->
name|k_metric
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|->
name|k_metric
operator|>
name|HOPCNT_INFINITY
operator|-
literal|1
condition|)
name|k
operator|->
name|k_metric
operator|=
name|HOPCNT_INFINITY
operator|-
literal|1
expr_stmt|;
block|}
name|k
operator|->
name|k_state
operator|&=
operator|~
operator|(
name|KS_DELETE
operator||
name|KS_ADD
operator||
name|KS_CHANGE
operator||
name|KS_DEL_ADD
operator||
name|KS_DELETED
operator||
name|KS_GATEWAY
operator||
name|KS_STATIC
operator||
name|KS_NEW
operator||
name|KS_CHECK
operator|)
expr_stmt|;
if|if
condition|(
name|rtm
operator|->
name|rtm_flags
operator|&
name|RTF_GATEWAY
condition|)
name|k
operator|->
name|k_state
operator||=
name|KS_GATEWAY
expr_stmt|;
if|if
condition|(
name|rtm
operator|->
name|rtm_flags
operator|&
name|RTF_STATIC
condition|)
name|k
operator|->
name|k_state
operator||=
name|KS_STATIC
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|rtm
operator|->
name|rtm_flags
operator|&
operator|(
name|RTF_DYNAMIC
operator||
name|RTF_MODIFIED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|INFO_AUTHOR
argument_list|(
name|info
argument_list|)
operator|!=
literal|0
operator|&&
name|INFO_AUTHOR
argument_list|(
name|info
argument_list|)
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|ifp
operator|=
name|iflookup
argument_list|(
name|S_ADDR
argument_list|(
name|INFO_AUTHOR
argument_list|(
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ifp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|supplier
operator|&&
operator|(
name|ifp
operator|==
literal|0
operator|||
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_REDIRECT_OK
operator|)
operator|)
condition|)
block|{
comment|/* Routers are not supposed to listen to redirects, 			 * so delete it if it came via an unknown interface 			 * or the interface does not have special permission. 			 */
name|k
operator|->
name|k_state
operator|&=
operator|~
name|KS_DYNAMIC
expr_stmt|;
name|k
operator|->
name|k_state
operator||=
name|KS_DELETE
expr_stmt|;
name|LIM_SEC
argument_list|(
name|need_kern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|trace_act
argument_list|(
literal|"mark for deletion redirected %s --> %s"
literal|" via %s"
argument_list|,
name|addrname
argument_list|(
name|k
operator|->
name|k_dst
argument_list|,
name|k
operator|->
name|k_mask
argument_list|,
literal|0
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|k
operator|->
name|k_gate
argument_list|)
argument_list|,
name|ifp
condition|?
name|ifp
operator|->
name|int_name
else|:
literal|"unknown interface"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|k
operator|->
name|k_state
operator||=
name|KS_DYNAMIC
expr_stmt|;
name|k
operator|->
name|k_redirect_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|trace_act
argument_list|(
literal|"accept redirected %s --> %s via %s"
argument_list|,
name|addrname
argument_list|(
name|k
operator|->
name|k_dst
argument_list|,
name|k
operator|->
name|k_mask
argument_list|,
literal|0
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|k
operator|->
name|k_gate
argument_list|)
argument_list|,
name|ifp
condition|?
name|ifp
operator|->
name|int_name
else|:
literal|"unknown interface"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* If it is not a static route, quit until the next comparison 	 * between the kernel and daemon tables, when it will be deleted. 	 */
if|if
condition|(
operator|!
operator|(
name|k
operator|->
name|k_state
operator|&
name|KS_STATIC
operator|)
condition|)
block|{
name|k
operator|->
name|k_state
operator||=
name|KS_DELETE
expr_stmt|;
name|LIM_SEC
argument_list|(
name|need_kern
argument_list|,
name|k
operator|->
name|k_keep
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Put static routes with real metrics into the daemon table so 	 * they can be advertised. 	 * 	 * Find the interface toward the gateway. 	 */
name|ifp
operator|=
name|iflookup
argument_list|(
name|k
operator|->
name|k_gate
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
literal|0
condition|)
name|msglog
argument_list|(
literal|"static route %s --> %s impossibly lacks ifp"
argument_list|,
name|addrname
argument_list|(
name|S_ADDR
argument_list|(
name|INFO_DST
argument_list|(
name|info
argument_list|)
argument_list|)
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|k
operator|->
name|k_gate
argument_list|)
argument_list|)
expr_stmt|;
name|kern_check_static
argument_list|(
name|k
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* deal with packet loss  */
end_comment

begin_function
specifier|static
name|void
name|rtm_lose
parameter_list|(
name|struct
name|rt_msghdr
modifier|*
name|rtm
parameter_list|,
name|struct
name|rt_addrinfo
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|INFO_GATE
argument_list|(
name|info
argument_list|)
operator|==
literal|0
operator|||
name|INFO_GATE
argument_list|(
name|info
argument_list|)
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
name|trace_act
argument_list|(
literal|"ignore %s without gateway"
argument_list|,
name|rtm_type_name
argument_list|(
name|rtm
operator|->
name|rtm_type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rdisc_ok
condition|)
name|rdisc_age
argument_list|(
name|S_ADDR
argument_list|(
name|INFO_GATE
argument_list|(
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|age
argument_list|(
name|S_ADDR
argument_list|(
name|INFO_GATE
argument_list|(
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the gateway slot of an info structure point to something  * useful.  If it is not already useful, but it specifies an interface,  * then fill in the sockaddr_in provided and point it there.  */
end_comment

begin_function
specifier|static
name|int
name|get_info_gate
parameter_list|(
name|struct
name|sockaddr
modifier|*
modifier|*
name|sap
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|rsin
parameter_list|)
block|{
name|struct
name|sockaddr_dl
modifier|*
name|sdl
init|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|*
name|sap
decl_stmt|;
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
name|sdl
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|sdl
operator|)
operator|->
name|sdl_family
operator|==
name|AF_INET
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|sdl
operator|)
operator|->
name|sdl_family
operator|!=
name|AF_LINK
condition|)
return|return
literal|0
return|;
name|ifp
operator|=
name|ifwithindex
argument_list|(
name|sdl
operator|->
name|sdl_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|rsin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifp
operator|->
name|int_addr
expr_stmt|;
ifdef|#
directive|ifdef
name|_HAVE_SA_LEN
name|rsin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rsin
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rsin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
operator|*
name|sap
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|rsin
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Clean the kernel table by copying it to the daemon image.  * Eventually the daemon will delete any extra routes.  */
end_comment

begin_function
name|void
name|flush_kern
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|sysctl_buf
decl_stmt|;
specifier|static
name|size_t
name|sysctl_buf_size
init|=
literal|0
decl_stmt|;
name|size_t
name|needed
decl_stmt|;
name|int
name|mib
index|[
literal|6
index|]
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|,
modifier|*
name|lim
decl_stmt|;
name|struct
name|rt_msghdr
modifier|*
name|rtm
decl_stmt|;
name|struct
name|sockaddr_in
name|gate_sin
decl_stmt|;
name|struct
name|rt_addrinfo
name|info
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|khash
modifier|*
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KHASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
name|khash_bins
index|[
name|i
index|]
init|;
name|k
operator|!=
literal|0
condition|;
name|k
operator|=
name|k
operator|->
name|k_next
control|)
block|{
name|k
operator|->
name|k_state
operator||=
name|KS_CHECK
expr_stmt|;
block|}
block|}
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_NET
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|PF_ROUTE
expr_stmt|;
name|mib
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* protocol */
name|mib
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* wildcard address family */
name|mib
index|[
literal|4
index|]
operator|=
name|NET_RT_DUMP
expr_stmt|;
name|mib
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* no flags */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|needed
operator|=
name|sysctl_buf_size
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
name|sysctl_buf
argument_list|,
operator|&
name|needed
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
name|errno
operator|!=
name|ENOMEM
operator|&&
name|errno
operator|!=
name|EFAULT
condition|)
name|BADERR
argument_list|(
literal|1
argument_list|,
literal|"flush_kern: sysctl(RT_DUMP)"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sysctl_buf
argument_list|)
expr_stmt|;
name|needed
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|,
operator|&
name|needed
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|BADERR
argument_list|(
literal|1
argument_list|,
literal|"flush_kern: sysctl(RT_DUMP) estimate"
argument_list|)
expr_stmt|;
comment|/* Kludge around the habit of some systems, such as 		 * BSD/OS 3.1, to not admit how many routes are in the 		 * kernel, or at least to be quite wrong. 		 */
name|needed
operator|+=
literal|50
operator|*
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|rtm
argument_list|)
operator|+
literal|5
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
operator|)
expr_stmt|;
name|sysctl_buf
operator|=
name|rtmalloc
argument_list|(
name|sysctl_buf_size
operator|=
name|needed
argument_list|,
literal|"flush_kern sysctl(RT_DUMP)"
argument_list|)
expr_stmt|;
block|}
name|lim
operator|=
name|sysctl_buf
operator|+
name|needed
expr_stmt|;
for|for
control|(
name|next
operator|=
name|sysctl_buf
init|;
name|next
operator|<
name|lim
condition|;
name|next
operator|+=
name|rtm
operator|->
name|rtm_msglen
control|)
block|{
name|rtm
operator|=
operator|(
expr|struct
name|rt_msghdr
operator|*
operator|)
name|next
expr_stmt|;
if|if
condition|(
name|rtm
operator|->
name|rtm_msglen
operator|==
literal|0
condition|)
block|{
name|msglog
argument_list|(
literal|"zero length kernel route at "
literal|" %#lx in buffer %#lx before %#lx"
argument_list|,
operator|(
name|u_long
operator|)
name|rtm
argument_list|,
operator|(
name|u_long
operator|)
name|sysctl_buf
argument_list|,
operator|(
name|u_long
operator|)
name|lim
argument_list|)
expr_stmt|;
break|break;
block|}
name|rt_xaddrs
argument_list|(
operator|&
name|info
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|rtm
operator|+
literal|1
operator|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|next
operator|+
name|rtm
operator|->
name|rtm_msglen
operator|)
argument_list|,
name|rtm
operator|->
name|rtm_addrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|INFO_DST
argument_list|(
operator|&
name|info
argument_list|)
operator|==
literal|0
operator|||
name|INFO_DST
argument_list|(
operator|&
name|info
argument_list|)
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
continue|continue;
comment|/* ignore ARP table entries on systems with a merged route 		 * and ARP table. 		 */
if|if
condition|(
name|rtm
operator|->
name|rtm_flags
operator|&
name|RTF_LLINFO
condition|)
continue|continue;
if|#
directive|if
name|defined
argument_list|(
name|RTF_CLONED
argument_list|)
operator|&&
name|defined
argument_list|(
name|__bsdi__
argument_list|)
comment|/* ignore cloned routes 		 */
if|if
condition|(
name|rtm
operator|->
name|rtm_flags
operator|&
name|RTF_CLONED
condition|)
continue|continue;
endif|#
directive|endif
comment|/* ignore multicast addresses 		 */
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|S_ADDR
argument_list|(
name|INFO_DST
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|get_info_gate
argument_list|(
operator|&
name|INFO_GATE
argument_list|(
operator|&
name|info
argument_list|)
argument_list|,
operator|&
name|gate_sin
argument_list|)
condition|)
continue|continue;
comment|/* Note static routes and interface routes, and also 		 * preload the image of the kernel table so that 		 * we can later clean it, as well as avoid making 		 * unneeded changes.  Keep the old kernel routes for a 		 * few seconds to allow a RIP or router-discovery 		 * response to be heard. 		 */
name|rtm_add
argument_list|(
name|rtm
argument_list|,
operator|&
name|info
argument_list|,
name|MIN_WAITTIME
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KHASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
name|khash_bins
index|[
name|i
index|]
init|;
name|k
operator|!=
literal|0
condition|;
name|k
operator|=
name|k
operator|->
name|k_next
control|)
block|{
if|if
condition|(
name|k
operator|->
name|k_state
operator|&
name|KS_CHECK
condition|)
block|{
name|msglog
argument_list|(
literal|"%s --> %s disappeared from kernel"
argument_list|,
name|addrname
argument_list|(
name|k
operator|->
name|k_dst
argument_list|,
name|k
operator|->
name|k_mask
argument_list|,
literal|0
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|k
operator|->
name|k_gate
argument_list|)
argument_list|)
expr_stmt|;
name|del_static
argument_list|(
name|k
operator|->
name|k_dst
argument_list|,
name|k
operator|->
name|k_mask
argument_list|,
name|k
operator|->
name|k_gate
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Listen to announcements from the kernel  */
end_comment

begin_function
name|void
name|read_rt
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|cc
decl_stmt|;
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|struct
name|sockaddr_in
name|gate_sin
decl_stmt|;
name|naddr
name|mask
decl_stmt|,
name|gate
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|struct
name|rt_msghdr
name|rtm
decl_stmt|;
name|struct
name|sockaddr
name|addrs
index|[
name|RTAX_MAX
index|]
decl_stmt|;
block|}
name|r
struct|;
name|struct
name|if_msghdr
name|ifm
decl_stmt|;
block|}
name|m
union|;
name|char
name|str
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|strp
decl_stmt|;
name|struct
name|rt_addrinfo
name|info
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cc
operator|=
name|read
argument_list|(
name|rt_sock
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|cc
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
name|LOGERR
argument_list|(
literal|"read(rt_sock)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_version
operator|!=
name|RTM_VERSION
condition|)
block|{
name|msglog
argument_list|(
literal|"bogus routing message version %d"
argument_list|,
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_version
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Ignore our own results. 		 */
if|if
condition|(
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_type
operator|<=
name|RTM_CHANGE
operator|&&
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_pid
operator|==
name|mypid
condition|)
block|{
specifier|static
name|int
name|complained
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|complained
condition|)
block|{
name|msglog
argument_list|(
literal|"receiving our own change messages"
argument_list|)
expr_stmt|;
name|complained
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_type
operator|==
name|RTM_IFINFO
operator|||
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_type
operator|==
name|RTM_NEWADDR
operator|||
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_type
operator|==
name|RTM_DELADDR
condition|)
block|{
name|ifp
operator|=
name|ifwithindex
argument_list|(
name|m
operator|.
name|ifm
operator|.
name|ifm_index
argument_list|,
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_type
operator|!=
name|RTM_DELADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
literal|0
condition|)
name|trace_act
argument_list|(
literal|"note %s with flags %#x"
literal|" for unknown interface index #%d"
argument_list|,
name|rtm_type_name
argument_list|(
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_type
argument_list|)
argument_list|,
name|m
operator|.
name|ifm
operator|.
name|ifm_flags
argument_list|,
name|m
operator|.
name|ifm
operator|.
name|ifm_index
argument_list|)
expr_stmt|;
else|else
name|trace_act
argument_list|(
literal|"note %s with flags %#x for %s"
argument_list|,
name|rtm_type_name
argument_list|(
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_type
argument_list|)
argument_list|,
name|m
operator|.
name|ifm
operator|.
name|ifm_flags
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
comment|/* After being informed of a change to an interface, 			 * check them all now if the check would otherwise 			 * be a long time from now, if the interface is 			 * not known, or if the interface has been turned 			 * off or on. 			 */
if|if
condition|(
name|ifinit_timer
operator|.
name|tv_sec
operator|-
name|now
operator|.
name|tv_sec
operator|>=
name|CHECK_BAD_INTERVAL
operator|||
name|ifp
operator|==
literal|0
operator|||
operator|(
operator|(
name|ifp
operator|->
name|int_if_flags
operator|^
name|m
operator|.
name|ifm
operator|.
name|ifm_flags
operator|)
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
name|ifinit_timer
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|RTM_OIFINFO
if|if
condition|(
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_type
operator|==
name|RTM_OIFINFO
condition|)
continue|continue;
comment|/* ignore compat message */
endif|#
directive|endif
name|strcpy
argument_list|(
name|str
argument_list|,
name|rtm_type_name
argument_list|(
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_type
argument_list|)
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|&
name|str
index|[
name|strlen
argument_list|(
name|str
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_type
operator|<=
name|RTM_CHANGE
condition|)
name|strp
operator|+=
name|sprintf
argument_list|(
name|strp
argument_list|,
literal|" from pid %d"
argument_list|,
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_pid
argument_list|)
expr_stmt|;
name|rt_xaddrs
argument_list|(
operator|&
name|info
argument_list|,
name|m
operator|.
name|r
operator|.
name|addrs
argument_list|,
operator|&
name|m
operator|.
name|r
operator|.
name|addrs
index|[
name|RTAX_MAX
index|]
argument_list|,
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_addrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|INFO_DST
argument_list|(
operator|&
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
name|trace_act
argument_list|(
literal|"ignore %s without dst"
argument_list|,
name|str
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|INFO_DST
argument_list|(
operator|&
name|info
argument_list|)
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
name|trace_act
argument_list|(
literal|"ignore %s for AF %d"
argument_list|,
name|str
argument_list|,
name|INFO_DST
argument_list|(
operator|&
name|info
argument_list|)
operator|->
name|sa_family
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mask
operator|=
operator|(
operator|(
name|INFO_MASK
argument_list|(
operator|&
name|info
argument_list|)
operator|!=
literal|0
operator|)
condition|?
name|ntohl
argument_list|(
name|S_ADDR
argument_list|(
name|INFO_MASK
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
argument_list|)
else|:
operator|(
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_flags
operator|&
name|RTF_HOST
operator|)
condition|?
name|HOST_MASK
else|:
name|std_mask
argument_list|(
name|S_ADDR
argument_list|(
name|INFO_DST
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|strp
operator|+=
name|sprintf
argument_list|(
name|strp
argument_list|,
literal|": %s"
argument_list|,
name|addrname
argument_list|(
name|S_ADDR
argument_list|(
name|INFO_DST
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|S_ADDR
argument_list|(
name|INFO_DST
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|trace_act
argument_list|(
literal|"ignore multicast %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_flags
operator|&
name|RTF_LLINFO
condition|)
block|{
name|trace_act
argument_list|(
literal|"ignore ARP %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|defined
argument_list|(
name|RTF_CLONED
argument_list|)
operator|&&
name|defined
argument_list|(
name|__bsdi__
argument_list|)
if|if
condition|(
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_flags
operator|&
name|RTF_CLONED
condition|)
block|{
name|trace_act
argument_list|(
literal|"ignore cloned %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|get_info_gate
argument_list|(
operator|&
name|INFO_GATE
argument_list|(
operator|&
name|info
argument_list|)
argument_list|,
operator|&
name|gate_sin
argument_list|)
condition|)
block|{
name|gate
operator|=
name|S_ADDR
argument_list|(
name|INFO_GATE
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|strp
operator|+=
name|sprintf
argument_list|(
name|strp
argument_list|,
literal|" --> %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|gate
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gate
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|INFO_AUTHOR
argument_list|(
operator|&
name|info
argument_list|)
operator|!=
literal|0
condition|)
name|strp
operator|+=
name|sprintf
argument_list|(
name|strp
argument_list|,
literal|" by authority of %s"
argument_list|,
name|saddr_ntoa
argument_list|(
name|INFO_AUTHOR
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_type
condition|)
block|{
case|case
name|RTM_ADD
case|:
case|case
name|RTM_CHANGE
case|:
case|case
name|RTM_REDIRECT
case|:
if|if
condition|(
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_errno
operator|!=
literal|0
condition|)
block|{
name|trace_act
argument_list|(
literal|"ignore %s with \"%s\" error"
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trace_act
argument_list|(
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|rtm_add
argument_list|(
operator|&
name|m
operator|.
name|r
operator|.
name|rtm
argument_list|,
operator|&
name|info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RTM_DELETE
case|:
if|if
condition|(
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_errno
operator|!=
literal|0
operator|&&
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_errno
operator|!=
name|ESRCH
condition|)
block|{
name|trace_act
argument_list|(
literal|"ignore %s with \"%s\" error"
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|m
operator|.
name|r
operator|.
name|rtm
operator|.
name|rtm_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trace_act
argument_list|(
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|del_static
argument_list|(
name|S_ADDR
argument_list|(
name|INFO_DST
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
argument_list|,
name|mask
argument_list|,
name|gate
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RTM_LOSING
case|:
name|trace_act
argument_list|(
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|rtm_lose
argument_list|(
operator|&
name|m
operator|.
name|r
operator|.
name|rtm
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
break|break;
default|default:
name|trace_act
argument_list|(
literal|"ignore %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* after aggregating, note routes that belong in the kernel  */
end_comment

begin_function
specifier|static
name|void
name|kern_out
parameter_list|(
name|struct
name|ag_info
modifier|*
name|ag
parameter_list|)
block|{
name|struct
name|khash
modifier|*
name|k
decl_stmt|;
comment|/* Do not install bad routes if they are not already present. 	 * This includes routes that had RS_NET_SYN for interfaces that 	 * recently died. 	 */
if|if
condition|(
name|ag
operator|->
name|ag_metric
operator|==
name|HOPCNT_INFINITY
condition|)
block|{
name|k
operator|=
name|kern_find
argument_list|(
name|htonl
argument_list|(
name|ag
operator|->
name|ag_dst_h
argument_list|)
argument_list|,
name|ag
operator|->
name|ag_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return;
block|}
else|else
block|{
name|k
operator|=
name|kern_add
argument_list|(
name|htonl
argument_list|(
name|ag
operator|->
name|ag_dst_h
argument_list|)
argument_list|,
name|ag
operator|->
name|ag_mask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|->
name|k_state
operator|&
name|KS_NEW
condition|)
block|{
comment|/* will need to add new entry to the kernel table */
name|k
operator|->
name|k_state
operator|=
name|KS_ADD
expr_stmt|;
if|if
condition|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_GATEWAY
condition|)
name|k
operator|->
name|k_state
operator||=
name|KS_GATEWAY
expr_stmt|;
name|k
operator|->
name|k_gate
operator|=
name|ag
operator|->
name|ag_gate
expr_stmt|;
name|k
operator|->
name|k_metric
operator|=
name|ag
operator|->
name|ag_metric
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|k
operator|->
name|k_state
operator|&
name|KS_STATIC
condition|)
return|return;
comment|/* modify existing kernel entry if necessary */
if|if
condition|(
name|k
operator|->
name|k_gate
operator|!=
name|ag
operator|->
name|ag_gate
operator|||
name|k
operator|->
name|k_metric
operator|!=
name|ag
operator|->
name|ag_metric
condition|)
block|{
comment|/* Must delete bad interface routes etc. to change them. */
if|if
condition|(
name|k
operator|->
name|k_metric
operator|==
name|HOPCNT_INFINITY
condition|)
name|k
operator|->
name|k_state
operator||=
name|KS_DEL_ADD
expr_stmt|;
name|k
operator|->
name|k_gate
operator|=
name|ag
operator|->
name|ag_gate
expr_stmt|;
name|k
operator|->
name|k_metric
operator|=
name|ag
operator|->
name|ag_metric
expr_stmt|;
name|k
operator|->
name|k_state
operator||=
name|KS_CHANGE
expr_stmt|;
block|}
comment|/* If the daemon thinks the route should exist, forget 	 * about any redirections. 	 * If the daemon thinks the route should exist, eventually 	 * override manual intervention by the operator. 	 */
if|if
condition|(
operator|(
name|k
operator|->
name|k_state
operator|&
operator|(
name|KS_DYNAMIC
operator||
name|KS_DELETED
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|k
operator|->
name|k_state
operator|&=
operator|~
name|KS_DYNAMIC
expr_stmt|;
name|k
operator|->
name|k_state
operator||=
operator|(
name|KS_ADD
operator||
name|KS_DEL_ADD
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|k
operator|->
name|k_state
operator|&
name|KS_GATEWAY
operator|)
operator|&&
operator|!
operator|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_GATEWAY
operator|)
condition|)
block|{
name|k
operator|->
name|k_state
operator|&=
operator|~
name|KS_GATEWAY
expr_stmt|;
name|k
operator|->
name|k_state
operator||=
operator|(
name|KS_ADD
operator||
name|KS_DEL_ADD
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|k
operator|->
name|k_state
operator|&
name|KS_GATEWAY
operator|)
operator|&&
operator|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_GATEWAY
operator|)
condition|)
block|{
name|k
operator|->
name|k_state
operator||=
name|KS_GATEWAY
expr_stmt|;
name|k
operator|->
name|k_state
operator||=
operator|(
name|KS_ADD
operator||
name|KS_DEL_ADD
operator|)
expr_stmt|;
block|}
comment|/* Deleting-and-adding is necessary to change aspects of a route. 	 * Just delete instead of deleting and then adding a bad route. 	 * Otherwise, we want to keep the route in the kernel. 	 */
if|if
condition|(
name|k
operator|->
name|k_metric
operator|==
name|HOPCNT_INFINITY
operator|&&
operator|(
name|k
operator|->
name|k_state
operator|&
name|KS_DEL_ADD
operator|)
condition|)
name|k
operator|->
name|k_state
operator||=
name|KS_DELETE
expr_stmt|;
else|else
name|k
operator|->
name|k_state
operator|&=
operator|~
name|KS_DELETE
expr_stmt|;
undef|#
directive|undef
name|RT
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|walk_kern
parameter_list|(
name|struct
name|radix_node
modifier|*
name|rn
parameter_list|,
name|struct
name|walkarg
modifier|*
name|argp
name|UNUSED
parameter_list|)
block|{
define|#
directive|define
name|RT
value|((struct rt_entry *)rn)
name|char
name|metric
decl_stmt|,
name|pref
decl_stmt|;
name|u_int
name|ags
init|=
literal|0
decl_stmt|;
comment|/* Do not install synthetic routes */
if|if
condition|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_NET_SYN
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_IF
operator|)
condition|)
block|{
comment|/* This is an ordinary route, not for an interface. 		 */
comment|/* aggregate, ordinary good routes without regard to 		 * their metric 		 */
name|pref
operator|=
literal|1
expr_stmt|;
name|ags
operator||=
operator|(
name|AGS_GATEWAY
operator||
name|AGS_SUPPRESS
operator||
name|AGS_AGGREGATE
operator|)
expr_stmt|;
comment|/* Do not install host routes directly to hosts, to avoid 		 * interfering with ARP entries in the kernel table. 		 */
if|if
condition|(
name|RT_ISHOST
argument_list|(
name|RT
argument_list|)
operator|&&
name|ntohl
argument_list|(
name|RT
operator|->
name|rt_dst
argument_list|)
operator|==
name|RT
operator|->
name|rt_gate
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* This is an interface route. 		 * Do not install routes for "external" remote interfaces. 		 */
if|if
condition|(
name|RT
operator|->
name|rt_ifp
operator|!=
literal|0
operator|&&
operator|(
name|RT
operator|->
name|rt_ifp
operator|->
name|int_state
operator|&
name|IS_EXTERNAL
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Interfaces should override received routes. 		 */
name|pref
operator|=
literal|0
expr_stmt|;
name|ags
operator||=
operator|(
name|AGS_IF
operator||
name|AGS_CORS_GATE
operator|)
expr_stmt|;
comment|/* If it is not an interface, or an alias for an interface, 		 * it must be a "gateway." 		 * 		 * If it is a "remote" interface, it is also a "gateway" to 		 * the kernel if is not an alias. 		 */
if|if
condition|(
name|RT
operator|->
name|rt_ifp
operator|==
literal|0
operator|||
operator|(
name|RT
operator|->
name|rt_ifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
operator|)
condition|)
name|ags
operator||=
operator|(
name|AGS_GATEWAY
operator||
name|AGS_SUPPRESS
operator||
name|AGS_AGGREGATE
operator|)
expr_stmt|;
block|}
comment|/* If RIP is off and IRDP is on, let the route to the discovered 	 * route suppress any RIP routes.  Eventually the RIP routes 	 * will time-out and be deleted.  This reaches the steady-state 	 * quicker. 	 */
if|if
condition|(
operator|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_RDISC
operator|)
operator|&&
name|rip_sock
operator|<
literal|0
condition|)
name|ags
operator||=
name|AGS_CORS_GATE
expr_stmt|;
name|metric
operator|=
name|RT
operator|->
name|rt_metric
expr_stmt|;
if|if
condition|(
name|metric
operator|==
name|HOPCNT_INFINITY
condition|)
block|{
comment|/* if the route is dead, so try hard to aggregate. */
name|pref
operator|=
name|HOPCNT_INFINITY
expr_stmt|;
name|ags
operator||=
operator|(
name|AGS_FINE_GATE
operator||
name|AGS_SUPPRESS
operator|)
expr_stmt|;
name|ags
operator|&=
operator|~
operator|(
name|AGS_IF
operator||
name|AGS_CORS_GATE
operator|)
expr_stmt|;
block|}
name|ag_check
argument_list|(
name|RT
operator|->
name|rt_dst
argument_list|,
name|RT
operator|->
name|rt_mask
argument_list|,
name|RT
operator|->
name|rt_gate
argument_list|,
literal|0
argument_list|,
name|metric
argument_list|,
name|pref
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ags
argument_list|,
name|kern_out
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|RT
block|}
end_function

begin_comment
comment|/* Update the kernel table to match the daemon table.  */
end_comment

begin_function
specifier|static
name|void
name|fix_kern
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|khash
modifier|*
name|k
decl_stmt|,
modifier|*
modifier|*
name|pk
decl_stmt|;
name|need_kern
operator|=
name|age_timer
expr_stmt|;
comment|/* Walk daemon table, updating the copy of the kernel table. 	 */
operator|(
name|void
operator|)
name|rn_walktree
argument_list|(
name|rhead
argument_list|,
name|walk_kern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ag_flush
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|kern_out
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KHASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|pk
operator|=
operator|&
name|khash_bins
index|[
name|i
index|]
init|;
operator|(
name|k
operator|=
operator|*
name|pk
operator|)
operator|!=
literal|0
condition|;
control|)
block|{
comment|/* Do not touch static routes */
if|if
condition|(
name|k
operator|->
name|k_state
operator|&
name|KS_STATIC
condition|)
block|{
name|kern_check_static
argument_list|(
name|k
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pk
operator|=
operator|&
name|k
operator|->
name|k_next
expr_stmt|;
continue|continue;
block|}
comment|/* check hold on routes deleted by the operator */
if|if
condition|(
name|k
operator|->
name|k_keep
operator|>
name|now
operator|.
name|tv_sec
condition|)
block|{
comment|/* ensure we check when the hold is over */
name|LIM_SEC
argument_list|(
name|need_kern
argument_list|,
name|k
operator|->
name|k_keep
argument_list|)
expr_stmt|;
comment|/* mark for the next cycle */
name|k
operator|->
name|k_state
operator||=
name|KS_DELETE
expr_stmt|;
name|pk
operator|=
operator|&
name|k
operator|->
name|k_next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|k
operator|->
name|k_state
operator|&
name|KS_DELETE
operator|)
operator|&&
operator|!
operator|(
name|k
operator|->
name|k_state
operator|&
name|KS_DYNAMIC
operator|)
condition|)
block|{
name|kern_ioctl
argument_list|(
name|k
argument_list|,
name|RTM_DELETE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|pk
operator|=
name|k
operator|->
name|k_next
expr_stmt|;
name|free
argument_list|(
name|k
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|k
operator|->
name|k_state
operator|&
name|KS_DEL_ADD
condition|)
name|kern_ioctl
argument_list|(
name|k
argument_list|,
name|RTM_DELETE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|k_state
operator|&
name|KS_ADD
condition|)
block|{
name|kern_ioctl
argument_list|(
name|k
argument_list|,
name|RTM_ADD
argument_list|,
operator|(
operator|(
literal|0
operator|!=
operator|(
name|k
operator|->
name|k_state
operator|&
operator|(
name|KS_GATEWAY
operator||
name|KS_DYNAMIC
operator|)
operator|)
operator|)
condition|?
name|RTF_GATEWAY
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|->
name|k_state
operator|&
name|KS_CHANGE
condition|)
block|{
name|kern_ioctl
argument_list|(
name|k
argument_list|,
name|RTM_CHANGE
argument_list|,
operator|(
operator|(
literal|0
operator|!=
operator|(
name|k
operator|->
name|k_state
operator|&
operator|(
name|KS_GATEWAY
operator||
name|KS_DYNAMIC
operator|)
operator|)
operator|)
condition|?
name|RTF_GATEWAY
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
name|k
operator|->
name|k_state
operator|&=
operator|~
operator|(
name|KS_ADD
operator||
name|KS_CHANGE
operator||
name|KS_DEL_ADD
operator|)
expr_stmt|;
comment|/* Mark this route to be deleted in the next cycle. 			 * This deletes routes that disappear from the 			 * daemon table, since the normal aging code 			 * will clear the bit for routes that have not 			 * disappeared from the daemon table. 			 */
name|k
operator|->
name|k_state
operator||=
name|KS_DELETE
expr_stmt|;
name|pk
operator|=
operator|&
name|k
operator|->
name|k_next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Delete a static route in the image of the kernel table.  */
end_comment

begin_function
name|void
name|del_static
parameter_list|(
name|naddr
name|dst
parameter_list|,
name|naddr
name|mask
parameter_list|,
name|naddr
name|gate
parameter_list|,
name|int
name|gone
parameter_list|)
block|{
name|struct
name|khash
modifier|*
name|k
decl_stmt|;
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
comment|/* Just mark it in the table to be deleted next time the kernel 	 * table is updated. 	 * If it has already been deleted, mark it as such, and set its 	 * keep-timer so that it will not be deleted again for a while. 	 * This lets the operator delete a route added by the daemon 	 * and add a replacement. 	 */
name|k
operator|=
name|kern_find
argument_list|(
name|dst
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
literal|0
operator|&&
operator|(
name|gate
operator|==
literal|0
operator|||
name|k
operator|->
name|k_gate
operator|==
name|gate
operator|)
condition|)
block|{
name|k
operator|->
name|k_state
operator|&=
operator|~
operator|(
name|KS_STATIC
operator||
name|KS_DYNAMIC
operator||
name|KS_CHECK
operator|)
expr_stmt|;
name|k
operator|->
name|k_state
operator||=
name|KS_DELETE
expr_stmt|;
if|if
condition|(
name|gone
condition|)
block|{
name|k
operator|->
name|k_state
operator||=
name|KS_DELETED
expr_stmt|;
name|k
operator|->
name|k_keep
operator|=
name|now
operator|.
name|tv_sec
operator|+
name|K_KEEP_LIM
expr_stmt|;
block|}
block|}
name|rt
operator|=
name|rtget
argument_list|(
name|dst
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
operator|&&
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_STATIC
operator|)
condition|)
name|rtbad
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete all routes generated from ICMP Redirects that use a given gateway,  * as well as old redirected routes.  */
end_comment

begin_function
name|void
name|del_redirects
parameter_list|(
name|naddr
name|bad_gate
parameter_list|,
name|time_t
name|old
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|khash
modifier|*
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KHASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
name|khash_bins
index|[
name|i
index|]
init|;
name|k
operator|!=
literal|0
condition|;
name|k
operator|=
name|k
operator|->
name|k_next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|k
operator|->
name|k_state
operator|&
name|KS_DYNAMIC
operator|)
operator|||
operator|(
name|k
operator|->
name|k_state
operator|&
name|KS_STATIC
operator|)
condition|)
continue|continue;
if|if
condition|(
name|k
operator|->
name|k_gate
operator|!=
name|bad_gate
operator|&&
name|k
operator|->
name|k_redirect_time
operator|>
name|old
operator|&&
operator|!
name|supplier
condition|)
continue|continue;
name|k
operator|->
name|k_state
operator||=
name|KS_DELETE
expr_stmt|;
name|k
operator|->
name|k_state
operator|&=
operator|~
name|KS_DYNAMIC
expr_stmt|;
name|need_kern
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|trace_act
argument_list|(
literal|"mark redirected %s --> %s for deletion"
argument_list|,
name|addrname
argument_list|(
name|k
operator|->
name|k_dst
argument_list|,
name|k
operator|->
name|k_mask
argument_list|,
literal|0
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|k
operator|->
name|k_gate
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Start the daemon tables.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|max_keylen
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|rtinit
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ag_info
modifier|*
name|ag
decl_stmt|;
comment|/* Initialize the radix trees */
name|max_keylen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|rn_init
argument_list|()
expr_stmt|;
name|rn_inithead
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|rhead
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* mark all of the slots in the table free */
name|ag_avail
operator|=
name|ag_slots
expr_stmt|;
for|for
control|(
name|ag
operator|=
name|ag_slots
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NUM_AG_SLOTS
condition|;
name|i
operator|++
control|)
block|{
name|ag
operator|->
name|ag_fine
operator|=
name|ag
operator|+
literal|1
expr_stmt|;
name|ag
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_HAVE_SIN_LEN
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
name|dst_sock
init|=
block|{
sizeof|sizeof
argument_list|(
name|dst_sock
argument_list|)
block|,
name|AF_INET
block|,
literal|0
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
name|mask_sock
init|=
block|{
sizeof|sizeof
argument_list|(
name|mask_sock
argument_list|)
block|,
name|AF_INET
block|,
literal|0
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in_new
name|dst_sock
init|=
block|{
name|_SIN_ADDR_SIZE
block|,
name|AF_INET
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in_new
name|mask_sock
init|=
block|{
name|_SIN_ADDR_SIZE
block|,
name|AF_INET
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|set_need_flash
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|need_flash
condition|)
block|{
name|need_flash
operator|=
literal|1
expr_stmt|;
comment|/* Do not send the flash update immediately.  Wait a little 		 * while to hear from other routers. 		 */
name|no_flash
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
operator|+
name|MIN_WAITTIME
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get a particular routing table entry  */
end_comment

begin_function
name|struct
name|rt_entry
modifier|*
name|rtget
parameter_list|(
name|naddr
name|dst
parameter_list|,
name|naddr
name|mask
parameter_list|)
block|{
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
name|dst_sock
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|dst
expr_stmt|;
name|mask_sock
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|masktrim
argument_list|(
operator|&
name|mask_sock
argument_list|)
expr_stmt|;
name|rt
operator|=
operator|(
expr|struct
name|rt_entry
operator|*
operator|)
name|rhead
operator|->
name|rnh_lookup
argument_list|(
operator|&
name|dst_sock
argument_list|,
operator|&
name|mask_sock
argument_list|,
name|rhead
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rt
operator|||
name|rt
operator|->
name|rt_dst
operator|!=
name|dst
operator|||
name|rt
operator|->
name|rt_mask
operator|!=
name|mask
condition|)
return|return
literal|0
return|;
return|return
name|rt
return|;
block|}
end_function

begin_comment
comment|/* Find a route to dst as the kernel would.  */
end_comment

begin_function
name|struct
name|rt_entry
modifier|*
name|rtfind
parameter_list|(
name|naddr
name|dst
parameter_list|)
block|{
name|dst_sock
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|dst
expr_stmt|;
return|return
operator|(
expr|struct
name|rt_entry
operator|*
operator|)
name|rhead
operator|->
name|rnh_matchaddr
argument_list|(
operator|&
name|dst_sock
argument_list|,
name|rhead
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* add a route to the table  */
end_comment

begin_function
name|void
name|rtadd
parameter_list|(
name|naddr
name|dst
parameter_list|,
name|naddr
name|mask
parameter_list|,
name|u_int
name|state
parameter_list|,
comment|/* rt_state for the entry */
name|struct
name|rt_spare
modifier|*
name|new
parameter_list|)
block|{
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
name|naddr
name|smask
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|rt_spare
modifier|*
name|rts
decl_stmt|;
name|rt
operator|=
operator|(
expr|struct
name|rt_entry
operator|*
operator|)
name|rtmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rt
argument_list|)
argument_list|,
literal|"rtadd"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rt
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|rts
operator|=
name|rt
operator|->
name|rt_spares
operator|,
name|i
operator|=
name|NUM_SPARES
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
operator|,
name|rts
operator|++
control|)
name|rts
operator|->
name|rts_metric
operator|=
name|HOPCNT_INFINITY
expr_stmt|;
name|rt
operator|->
name|rt_nodes
operator|->
name|rn_key
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|rt
operator|->
name|rt_dst_sock
expr_stmt|;
name|rt
operator|->
name|rt_dst
operator|=
name|dst
expr_stmt|;
name|rt
operator|->
name|rt_dst_sock
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
ifdef|#
directive|ifdef
name|_HAVE_SIN_LEN
name|rt
operator|->
name|rt_dst_sock
operator|.
name|sin_len
operator|=
name|dst_sock
operator|.
name|sin_len
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mask
operator|!=
name|HOST_MASK
condition|)
block|{
name|smask
operator|=
name|std_mask
argument_list|(
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|smask
operator|&
operator|~
name|mask
operator|)
operator|==
literal|0
operator|&&
name|mask
operator|>
name|smask
condition|)
name|state
operator||=
name|RS_SUBNET
expr_stmt|;
block|}
name|mask_sock
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|masktrim
argument_list|(
operator|&
name|mask_sock
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_mask
operator|=
name|mask
expr_stmt|;
name|rt
operator|->
name|rt_state
operator|=
name|state
expr_stmt|;
name|rt
operator|->
name|rt_spares
index|[
literal|0
index|]
operator|=
operator|*
name|new
expr_stmt|;
name|rt
operator|->
name|rt_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|rt
operator|->
name|rt_poison_metric
operator|=
name|HOPCNT_INFINITY
expr_stmt|;
name|rt
operator|->
name|rt_seqno
operator|=
name|update_seqno
expr_stmt|;
if|if
condition|(
operator|++
name|total_routes
operator|==
name|MAX_ROUTES
condition|)
name|msglog
argument_list|(
literal|"have maximum (%d) routes"
argument_list|,
name|total_routes
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRACEACTIONS
condition|)
name|trace_add_del
argument_list|(
literal|"Add"
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|need_kern
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|set_need_flash
argument_list|()
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|rhead
operator|->
name|rnh_addaddr
argument_list|(
operator|&
name|rt
operator|->
name|rt_dst_sock
argument_list|,
operator|&
name|mask_sock
argument_list|,
name|rhead
argument_list|,
name|rt
operator|->
name|rt_nodes
argument_list|)
condition|)
block|{
name|msglog
argument_list|(
literal|"rnh_addaddr() failed for %s mask=%#lx"
argument_list|,
name|naddr_ntoa
argument_list|(
name|dst
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|mask
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* notice a changed route  */
end_comment

begin_function
name|void
name|rtchange
parameter_list|(
name|struct
name|rt_entry
modifier|*
name|rt
parameter_list|,
name|u_int
name|state
parameter_list|,
comment|/* new state bits */
name|struct
name|rt_spare
modifier|*
name|new
parameter_list|,
name|char
modifier|*
name|label
parameter_list|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_metric
operator|!=
name|new
operator|->
name|rts_metric
condition|)
block|{
comment|/* Fix the kernel immediately if it seems the route 		 * has gone bad, since there may be a working route that 		 * aggregates this route. 		 */
if|if
condition|(
name|new
operator|->
name|rts_metric
operator|==
name|HOPCNT_INFINITY
condition|)
block|{
name|need_kern
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|rts_time
operator|>=
name|now
operator|.
name|tv_sec
operator|-
name|EXPIRE_TIME
condition|)
name|new
operator|->
name|rts_time
operator|=
name|now
operator|.
name|tv_sec
operator|-
name|EXPIRE_TIME
expr_stmt|;
block|}
name|rt
operator|->
name|rt_seqno
operator|=
name|update_seqno
expr_stmt|;
name|set_need_flash
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|->
name|rt_gate
operator|!=
name|new
operator|->
name|rts_gate
condition|)
block|{
name|need_kern
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|rt
operator|->
name|rt_seqno
operator|=
name|update_seqno
expr_stmt|;
name|set_need_flash
argument_list|()
expr_stmt|;
block|}
name|state
operator||=
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_SUBNET
operator|)
expr_stmt|;
comment|/* Keep various things from deciding ageless routes are stale. 	 */
if|if
condition|(
operator|!
name|AGE_RT
argument_list|(
name|state
argument_list|,
name|new
operator|->
name|rts_ifp
argument_list|)
condition|)
name|new
operator|->
name|rts_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|TRACEACTIONS
condition|)
name|trace_change
argument_list|(
name|rt
argument_list|,
name|state
argument_list|,
name|new
argument_list|,
name|label
condition|?
name|label
else|:
literal|"Chg   "
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_state
operator|=
name|state
expr_stmt|;
name|rt
operator|->
name|rt_spares
index|[
literal|0
index|]
operator|=
operator|*
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* check for a better route among the spares  */
end_comment

begin_function
specifier|static
name|struct
name|rt_spare
modifier|*
name|rts_better
parameter_list|(
name|struct
name|rt_entry
modifier|*
name|rt
parameter_list|)
block|{
name|struct
name|rt_spare
modifier|*
name|rts
decl_stmt|,
modifier|*
name|rts1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* find the best alternative among the spares */
name|rts
operator|=
name|rt
operator|->
name|rt_spares
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_SPARES
operator|,
name|rts1
operator|=
name|rts
operator|+
literal|1
init|;
name|i
operator|>
literal|2
condition|;
name|i
operator|--
operator|,
name|rts1
operator|++
control|)
block|{
if|if
condition|(
name|BETTER_LINK
argument_list|(
name|rt
argument_list|,
name|rts1
argument_list|,
name|rts
argument_list|)
condition|)
name|rts
operator|=
name|rts1
expr_stmt|;
block|}
return|return
name|rts
return|;
block|}
end_function

begin_comment
comment|/* switch to a backup route  */
end_comment

begin_function
name|void
name|rtswitch
parameter_list|(
name|struct
name|rt_entry
modifier|*
name|rt
parameter_list|,
name|struct
name|rt_spare
modifier|*
name|rts
parameter_list|)
block|{
name|struct
name|rt_spare
name|swap
decl_stmt|;
name|char
name|label
index|[
literal|10
index|]
decl_stmt|;
comment|/* Do not change permanent routes */
if|if
condition|(
literal|0
operator|!=
operator|(
name|rt
operator|->
name|rt_state
operator|&
operator|(
name|RS_MHOME
operator||
name|RS_STATIC
operator||
name|RS_RDISC
operator||
name|RS_NET_SYN
operator||
name|RS_IF
operator|)
operator|)
condition|)
return|return;
comment|/* find the best alternative among the spares */
if|if
condition|(
name|rts
operator|==
literal|0
condition|)
name|rts
operator|=
name|rts_better
argument_list|(
name|rt
argument_list|)
expr_stmt|;
comment|/* Do not bother if it is not worthwhile. 	 */
if|if
condition|(
operator|!
name|BETTER_LINK
argument_list|(
name|rt
argument_list|,
name|rts
argument_list|,
name|rt
operator|->
name|rt_spares
argument_list|)
condition|)
return|return;
name|swap
operator|=
name|rt
operator|->
name|rt_spares
index|[
literal|0
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|label
argument_list|,
literal|"Use #%d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|rts
operator|-
name|rt
operator|->
name|rt_spares
argument_list|)
argument_list|)
expr_stmt|;
name|rtchange
argument_list|(
name|rt
argument_list|,
name|rt
operator|->
name|rt_state
operator|&
operator|~
operator|(
name|RS_NET_SYN
operator||
name|RS_RDISC
operator|)
argument_list|,
name|rts
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap
operator|.
name|rts_metric
operator|==
name|HOPCNT_INFINITY
condition|)
block|{
operator|*
name|rts
operator|=
name|rts_empty
expr_stmt|;
block|}
else|else
block|{
operator|*
name|rts
operator|=
name|swap
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|rtdelete
parameter_list|(
name|struct
name|rt_entry
modifier|*
name|rt
parameter_list|)
block|{
name|struct
name|khash
modifier|*
name|k
decl_stmt|;
if|if
condition|(
name|TRACEACTIONS
condition|)
name|trace_add_del
argument_list|(
literal|"Del"
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|k
operator|=
name|kern_find
argument_list|(
name|rt
operator|->
name|rt_dst
argument_list|,
name|rt
operator|->
name|rt_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
literal|0
condition|)
block|{
name|k
operator|->
name|k_state
operator||=
name|KS_DELETE
expr_stmt|;
name|need_kern
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
block|}
name|dst_sock
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|rt
operator|->
name|rt_dst
expr_stmt|;
name|mask_sock
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|rt
operator|->
name|rt_mask
argument_list|)
expr_stmt|;
name|masktrim
argument_list|(
operator|&
name|mask_sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
operator|(
expr|struct
name|rt_entry
operator|*
operator|)
name|rhead
operator|->
name|rnh_deladdr
argument_list|(
operator|&
name|dst_sock
argument_list|,
operator|&
name|mask_sock
argument_list|,
name|rhead
argument_list|)
condition|)
block|{
name|msglog
argument_list|(
literal|"rnh_deladdr() failed"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|total_routes
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|rts_delete
parameter_list|(
name|struct
name|rt_entry
modifier|*
name|rt
parameter_list|,
name|struct
name|rt_spare
modifier|*
name|rts
parameter_list|)
block|{
name|trace_upslot
argument_list|(
name|rt
argument_list|,
name|rts
argument_list|,
operator|&
name|rts_empty
argument_list|)
expr_stmt|;
operator|*
name|rts
operator|=
name|rts_empty
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get rid of a bad route, and try to switch to a replacement.  */
end_comment

begin_function
name|void
name|rtbad
parameter_list|(
name|struct
name|rt_entry
modifier|*
name|rt
parameter_list|)
block|{
name|struct
name|rt_spare
name|new
decl_stmt|;
comment|/* Poison the route */
name|new
operator|=
name|rt
operator|->
name|rt_spares
index|[
literal|0
index|]
expr_stmt|;
name|new
operator|.
name|rts_metric
operator|=
name|HOPCNT_INFINITY
expr_stmt|;
name|rtchange
argument_list|(
name|rt
argument_list|,
name|rt
operator|->
name|rt_state
operator|&
operator|~
operator|(
name|RS_IF
operator||
name|RS_LOCAL
operator||
name|RS_STATIC
operator|)
argument_list|,
operator|&
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rtswitch
argument_list|(
name|rt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Junk a RS_NET_SYN or RS_LOCAL route,  *	unless it is needed by another interface.  */
end_comment

begin_function
name|void
name|rtbad_sub
parameter_list|(
name|struct
name|rt_entry
modifier|*
name|rt
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|,
modifier|*
name|ifp1
decl_stmt|;
name|struct
name|intnet
modifier|*
name|intnetp
decl_stmt|;
name|u_int
name|state
decl_stmt|;
name|ifp1
operator|=
literal|0
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_LOCAL
condition|)
block|{
comment|/* Is this the route through loopback for the interface? 		 * If so, see if it is used by any other interfaces, such 		 * as a point-to-point interface with the same local address. 		 */
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
operator|!=
literal|0
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
comment|/* Retain it if another interface needs it. 			 */
if|if
condition|(
name|ifp
operator|->
name|int_addr
operator|==
name|rt
operator|->
name|rt_ifp
operator|->
name|int_addr
condition|)
block|{
name|state
operator||=
name|RS_LOCAL
expr_stmt|;
name|ifp1
operator|=
name|ifp
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|state
operator|&
name|RS_LOCAL
operator|)
condition|)
block|{
comment|/* Retain RIPv1 logical network route if there is another 		 * interface that justifies it. 		 */
if|if
condition|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_NET_SYN
condition|)
block|{
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
operator|!=
literal|0
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NEED_NET_SYN
operator|)
operator|&&
name|rt
operator|->
name|rt_mask
operator|==
name|ifp
operator|->
name|int_std_mask
operator|&&
name|rt
operator|->
name|rt_dst
operator|==
name|ifp
operator|->
name|int_std_addr
condition|)
block|{
name|state
operator||=
name|RS_NET_SYN
expr_stmt|;
name|ifp1
operator|=
name|ifp
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* or if there is an authority route that needs it. */
for|for
control|(
name|intnetp
operator|=
name|intnets
init|;
name|intnetp
operator|!=
literal|0
condition|;
name|intnetp
operator|=
name|intnetp
operator|->
name|intnet_next
control|)
block|{
if|if
condition|(
name|intnetp
operator|->
name|intnet_addr
operator|==
name|rt
operator|->
name|rt_dst
operator|&&
name|intnetp
operator|->
name|intnet_mask
operator|==
name|rt
operator|->
name|rt_mask
condition|)
block|{
name|state
operator||=
operator|(
name|RS_NET_SYN
operator||
name|RS_NET_INT
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|ifp1
operator|!=
literal|0
operator|||
operator|(
name|state
operator|&
name|RS_NET_SYN
operator|)
condition|)
block|{
name|struct
name|rt_spare
name|new
init|=
name|rt
operator|->
name|rt_spares
index|[
literal|0
index|]
decl_stmt|;
name|new
operator|.
name|rts_ifp
operator|=
name|ifp1
expr_stmt|;
name|rtchange
argument_list|(
name|rt
argument_list|,
operator|(
operator|(
name|rt
operator|->
name|rt_state
operator|&
operator|~
operator|(
name|RS_NET_SYN
operator||
name|RS_LOCAL
operator|)
operator|)
operator||
name|state
operator|)
argument_list|,
operator|&
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtbad
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called while walking the table looking for sick interfaces  * or after a time change.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|walk_bad
parameter_list|(
name|struct
name|radix_node
modifier|*
name|rn
parameter_list|,
name|struct
name|walkarg
modifier|*
name|argp
name|UNUSED
parameter_list|)
block|{
define|#
directive|define
name|RT
value|((struct rt_entry *)rn)
name|struct
name|rt_spare
modifier|*
name|rts
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* fix any spare routes through the interface 	 */
name|rts
operator|=
name|RT
operator|->
name|rt_spares
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_SPARES
init|;
name|i
operator|!=
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|rts
operator|++
expr_stmt|;
if|if
condition|(
name|rts
operator|->
name|rts_metric
operator|<
name|HOPCNT_INFINITY
operator|&&
operator|(
name|rts
operator|->
name|rts_ifp
operator|==
literal|0
operator|||
operator|(
name|rts
operator|->
name|rts_ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
operator|)
operator|)
condition|)
name|rts_delete
argument_list|(
name|RT
argument_list|,
name|rts
argument_list|)
expr_stmt|;
block|}
comment|/* Deal with the main route 	 */
comment|/* finished if it has been handled before or if its interface is ok 	 */
if|if
condition|(
name|RT
operator|->
name|rt_ifp
operator|==
literal|0
operator|||
operator|!
operator|(
name|RT
operator|->
name|rt_ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Bad routes for other than interfaces are easy. 	 */
if|if
condition|(
literal|0
operator|==
operator|(
name|RT
operator|->
name|rt_state
operator|&
operator|(
name|RS_IF
operator||
name|RS_NET_SYN
operator||
name|RS_LOCAL
operator|)
operator|)
condition|)
block|{
name|rtbad
argument_list|(
name|RT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rtbad_sub
argument_list|(
name|RT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|RT
block|}
end_function

begin_comment
comment|/* Check the age of an individual route.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|walk_age
parameter_list|(
name|struct
name|radix_node
modifier|*
name|rn
parameter_list|,
name|struct
name|walkarg
modifier|*
name|argp
name|UNUSED
parameter_list|)
block|{
define|#
directive|define
name|RT
value|((struct rt_entry *)rn)
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|struct
name|rt_spare
modifier|*
name|rts
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* age all of the spare routes, including the primary route 	 * currently in use 	 */
name|rts
operator|=
name|RT
operator|->
name|rt_spares
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_SPARES
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
operator|,
name|rts
operator|++
control|)
block|{
name|ifp
operator|=
name|rts
operator|->
name|rts_ifp
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NUM_SPARES
condition|)
block|{
if|if
condition|(
operator|!
name|AGE_RT
argument_list|(
name|RT
operator|->
name|rt_state
argument_list|,
name|ifp
argument_list|)
condition|)
block|{
comment|/* Keep various things from deciding ageless 				 * routes are stale 				 */
name|rts
operator|->
name|rts_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
continue|continue;
block|}
comment|/* forget RIP routes after RIP has been turned off. 			 */
if|if
condition|(
name|rip_sock
operator|<
literal|0
condition|)
block|{
name|rtdelete
argument_list|(
name|RT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* age failing routes 		 */
if|if
condition|(
name|age_bad_gate
operator|==
name|rts
operator|->
name|rts_gate
operator|&&
name|rts
operator|->
name|rts_time
operator|>=
name|now_stale
condition|)
block|{
name|rts
operator|->
name|rts_time
operator|-=
name|SUPPLY_INTERVAL
expr_stmt|;
block|}
comment|/* trash the spare routes when they go bad */
if|if
condition|(
name|rts
operator|->
name|rts_metric
operator|<
name|HOPCNT_INFINITY
operator|&&
name|now_garbage
operator|>
name|rts
operator|->
name|rts_time
operator|&&
name|i
operator|!=
name|NUM_SPARES
condition|)
name|rts_delete
argument_list|(
name|RT
argument_list|,
name|rts
argument_list|)
expr_stmt|;
block|}
comment|/* finished if the active route is still fresh */
if|if
condition|(
name|now_stale
operator|<=
name|RT
operator|->
name|rt_time
condition|)
return|return
literal|0
return|;
comment|/* try to switch to an alternative */
name|rtswitch
argument_list|(
name|RT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Delete a dead route after it has been publically mourned. */
if|if
condition|(
name|now_garbage
operator|>
name|RT
operator|->
name|rt_time
condition|)
block|{
name|rtdelete
argument_list|(
name|RT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Start poisoning a bad route before deleting it. */
if|if
condition|(
name|now
operator|.
name|tv_sec
operator|-
name|RT
operator|->
name|rt_time
operator|>
name|EXPIRE_TIME
condition|)
block|{
name|struct
name|rt_spare
name|new
init|=
name|RT
operator|->
name|rt_spares
index|[
literal|0
index|]
decl_stmt|;
name|new
operator|.
name|rts_metric
operator|=
name|HOPCNT_INFINITY
expr_stmt|;
name|rtchange
argument_list|(
name|RT
argument_list|,
name|RT
operator|->
name|rt_state
argument_list|,
operator|&
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Watch for dead routes and interfaces.  */
end_comment

begin_function
name|void
name|age
parameter_list|(
name|naddr
name|bad_gate
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|int
name|need_query
init|=
literal|0
decl_stmt|;
comment|/* If not listening to RIP, there is no need to age the routes in 	 * the table. 	 */
name|age_timer
operator|.
name|tv_sec
operator|=
operator|(
name|now
operator|.
name|tv_sec
operator|+
operator|(
operator|(
name|rip_sock
operator|<
literal|0
operator|)
condition|?
name|NEVER
else|:
name|SUPPLY_INTERVAL
operator|)
operator|)
expr_stmt|;
comment|/* Check for dead IS_REMOTE interfaces by timing their 	 * transmissions. 	 */
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
operator|)
condition|)
continue|continue;
comment|/* ignore unreachable remote interfaces */
if|if
condition|(
operator|!
name|check_remote
argument_list|(
name|ifp
argument_list|)
condition|)
continue|continue;
comment|/* Restore remote interface that has become reachable 		 */
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
condition|)
name|if_ok
argument_list|(
name|ifp
argument_list|,
literal|"remote "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_act_time
operator|!=
name|NEVER
operator|&&
name|now
operator|.
name|tv_sec
operator|-
name|ifp
operator|->
name|int_act_time
operator|>
name|EXPIRE_TIME
condition|)
block|{
name|msglog
argument_list|(
literal|"remote interface %s to %s timed out after"
literal|" %ld:%ld"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|naddr_ntoa
argument_list|(
name|ifp
operator|->
name|int_dstaddr
argument_list|)
argument_list|,
operator|(
name|now
operator|.
name|tv_sec
operator|-
name|ifp
operator|->
name|int_act_time
operator|)
operator|/
literal|60
argument_list|,
operator|(
name|now
operator|.
name|tv_sec
operator|-
name|ifp
operator|->
name|int_act_time
operator|)
operator|%
literal|60
argument_list|)
expr_stmt|;
name|if_sick
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* If we have not heard from the other router 		 * recently, ask it. 		 */
if|if
condition|(
name|now
operator|.
name|tv_sec
operator|>=
name|ifp
operator|->
name|int_query_time
condition|)
block|{
name|ifp
operator|->
name|int_query_time
operator|=
name|NEVER
expr_stmt|;
name|need_query
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Age routes. */
name|age_bad_gate
operator|=
name|bad_gate
expr_stmt|;
operator|(
name|void
operator|)
name|rn_walktree
argument_list|(
name|rhead
argument_list|,
name|walk_age
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* delete old redirected routes to keep the kernel table small 	 * and prevent blackholes 	 */
name|del_redirects
argument_list|(
name|bad_gate
argument_list|,
name|now
operator|.
name|tv_sec
operator|-
name|STALE_TIME
argument_list|)
expr_stmt|;
comment|/* Update the kernel routing table. */
name|fix_kern
argument_list|()
expr_stmt|;
comment|/* poke reticent remote gateways */
if|if
condition|(
name|need_query
condition|)
name|rip_query
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

