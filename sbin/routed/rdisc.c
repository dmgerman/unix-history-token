begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
literal|"@(#)rdisc.c	8.1 (Berkeley) x/y/95"
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_elif

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_empty
empty|#ident "$FreeBSD$"
end_empty

begin_comment
comment|/* router advertisement ICMP packet */
end_comment

begin_struct
struct|struct
name|icmp_ad
block|{
name|u_int8_t
name|icmp_type
decl_stmt|;
comment|/* type of message */
name|u_int8_t
name|icmp_code
decl_stmt|;
comment|/* type sub code */
name|u_int16_t
name|icmp_cksum
decl_stmt|;
comment|/* ones complement cksum of struct */
name|u_int8_t
name|icmp_ad_num
decl_stmt|;
comment|/* # of following router addresses */
name|u_int8_t
name|icmp_ad_asize
decl_stmt|;
comment|/* 2--words in each advertisement */
name|u_int16_t
name|icmp_ad_life
decl_stmt|;
comment|/* seconds of validity */
struct|struct
name|icmp_ad_info
block|{
name|n_long
name|icmp_ad_addr
decl_stmt|;
name|n_long
name|icmp_ad_pref
decl_stmt|;
block|}
name|icmp_ad_info
index|[
literal|1
index|]
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/* router solicitation ICMP packet */
end_comment

begin_struct
struct|struct
name|icmp_so
block|{
name|u_int8_t
name|icmp_type
decl_stmt|;
comment|/* type of message */
name|u_int8_t
name|icmp_code
decl_stmt|;
comment|/* type sub code */
name|u_int16_t
name|icmp_cksum
decl_stmt|;
comment|/* ones complement cksum of struct */
name|n_long
name|icmp_so_rsvd
decl_stmt|;
block|}
struct|;
end_struct

begin_union
union|union
name|ad_u
block|{
name|struct
name|icmp
name|icmp
decl_stmt|;
name|struct
name|icmp_ad
name|ad
decl_stmt|;
name|struct
name|icmp_so
name|so
decl_stmt|;
block|}
union|;
end_union

begin_decl_stmt
name|int
name|rdisc_sock
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* router-discovery raw socket */
end_comment

begin_decl_stmt
name|struct
name|interface
modifier|*
name|rdisc_sock_mcast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current multicast interface */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|rdisc_timer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rdisc_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* using solicited route */
end_comment

begin_define
define|#
directive|define
name|MAX_ADS
value|16
end_define

begin_comment
comment|/* at least one per interface */
end_comment

begin_struct
struct|struct
name|dr
block|{
comment|/* accumulated advertisements */
name|struct
name|interface
modifier|*
name|dr_ifp
decl_stmt|;
name|naddr
name|dr_gate
decl_stmt|;
comment|/* gateway */
name|time_t
name|dr_ts
decl_stmt|;
comment|/* when received */
name|time_t
name|dr_life
decl_stmt|;
comment|/* lifetime in host byte order */
name|n_long
name|dr_recv_pref
decl_stmt|;
comment|/* received but biased preference */
name|n_long
name|dr_pref
decl_stmt|;
comment|/* preference adjusted by metric */
block|}
modifier|*
name|cur_drp
struct|,
name|drs
index|[
name|MAX_ADS
index|]
struct|;
end_struct

begin_comment
comment|/* convert between signed, balanced around zero,  * and unsigned zero-based preferences */
end_comment

begin_define
define|#
directive|define
name|SIGN_PREF
parameter_list|(
name|p
parameter_list|)
value|((p) ^ MIN_PreferenceLevel)
end_define

begin_define
define|#
directive|define
name|UNSIGN_PREF
parameter_list|(
name|p
parameter_list|)
value|SIGN_PREF(p)
end_define

begin_comment
comment|/* adjust unsigned preference by interface metric,  * without driving it to infinity */
end_comment

begin_define
define|#
directive|define
name|PREF
parameter_list|(
name|p
parameter_list|,
name|ifp
parameter_list|)
value|((int)(p)<= (ifp)->int_metric ? ((p) != 0 ? 1 : 0) \ 		      : (p) - ((ifp)->int_metric))
end_define

begin_function_decl
specifier|static
name|void
name|rdisc_sort
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* dump an ICMP Router Discovery Advertisement Message  */
end_comment

begin_function
specifier|static
name|void
name|trace_rdisc
parameter_list|(
specifier|const
name|char
modifier|*
name|act
parameter_list|,
name|naddr
name|from
parameter_list|,
name|naddr
name|to
parameter_list|,
name|struct
name|interface
modifier|*
name|ifp
parameter_list|,
name|union
name|ad_u
modifier|*
name|p
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|n_long
modifier|*
name|wp
decl_stmt|,
modifier|*
name|lim
decl_stmt|;
if|if
condition|(
operator|!
name|TRACEPACKETS
operator|||
name|ftrace
operator|==
literal|0
condition|)
return|return;
name|lastlog
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|icmp
operator|.
name|icmp_type
operator|==
name|ICMP_ROUTERADVERT
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ftrace
argument_list|,
literal|"%s Router Ad"
literal|" from %s to %s via %s life=%d\n"
argument_list|,
name|act
argument_list|,
name|naddr_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|to
argument_list|)
argument_list|,
name|ifp
condition|?
name|ifp
operator|->
name|int_name
else|:
literal|"?"
argument_list|,
name|ntohs
argument_list|(
name|p
operator|->
name|ad
operator|.
name|icmp_ad_life
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TRACECONTENTS
condition|)
return|return;
name|wp
operator|=
operator|&
name|p
operator|->
name|ad
operator|.
name|icmp_ad_info
index|[
literal|0
index|]
operator|.
name|icmp_ad_addr
expr_stmt|;
name|lim
operator|=
operator|&
name|wp
index|[
operator|(
name|len
operator|-
sizeof|sizeof
argument_list|(
name|p
operator|->
name|ad
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|wp
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|ad
operator|.
name|icmp_ad_num
operator|&&
name|wp
operator|<=
name|lim
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ftrace
argument_list|,
literal|"\t%s preference=%d"
argument_list|,
name|naddr_ntoa
argument_list|(
name|wp
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|ntohl
argument_list|(
name|wp
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|wp
operator|+=
name|p
operator|->
name|ad
operator|.
name|icmp_ad_asize
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|ftrace
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trace_act
argument_list|(
literal|"%s Router Solic. from %s to %s via %s value=%#x"
argument_list|,
name|act
argument_list|,
name|naddr_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|to
argument_list|)
argument_list|,
name|ifp
condition|?
name|ifp
operator|->
name|int_name
else|:
literal|"?"
argument_list|,
operator|(
name|int
operator|)
name|ntohl
argument_list|(
name|p
operator|->
name|so
operator|.
name|icmp_so_rsvd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* prepare Router Discovery socket.  */
end_comment

begin_function
specifier|static
name|void
name|get_rdisc_sock
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|rdisc_sock
operator|<
literal|0
condition|)
block|{
name|rdisc_sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_ICMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdisc_sock
operator|<
literal|0
condition|)
name|BADERR
argument_list|(
literal|1
argument_list|,
literal|"rdisc_sock = socket()"
argument_list|)
expr_stmt|;
name|fix_sock
argument_list|(
name|rdisc_sock
argument_list|,
literal|"rdisc_sock"
argument_list|)
expr_stmt|;
name|fix_select
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Pick multicast group for router-discovery socket  */
end_comment

begin_function
name|void
name|set_rdisc_mg
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|,
name|int
name|on
parameter_list|)
comment|/* 0=turn it off */
block|{
name|struct
name|ip_mreq
name|m
decl_stmt|;
if|if
condition|(
name|rdisc_sock
operator|<
literal|0
condition|)
block|{
comment|/* Create the raw socket so that we can hear at least 		 * broadcast router discovery packets. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RDISC
operator|)
operator|==
name|IS_NO_RDISC
operator|||
operator|!
name|on
condition|)
return|return;
name|get_rdisc_sock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_MULTICAST
operator|)
condition|)
block|{
name|ifp
operator|->
name|int_state
operator|&=
operator|~
operator|(
name|IS_ALL_HOSTS
operator||
name|IS_ALL_ROUTERS
operator|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|MCAST_PPP_BUG
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
return|return;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|.
name|imr_interface
operator|.
name|s_addr
operator|=
operator|(
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
condition|?
name|ifp
operator|->
name|int_dstaddr
else|:
name|ifp
operator|->
name|int_addr
operator|)
expr_stmt|;
if|if
condition|(
name|supplier
operator|||
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_ADV_IN
operator|)
operator|||
operator|!
name|on
condition|)
block|{
comment|/* stop listening to advertisements 		 */
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALL_HOSTS
condition|)
block|{
name|m
operator|.
name|imr_multiaddr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ALLHOSTS_GROUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|rdisc_sock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_DROP_MEMBERSHIP
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|LOGERR
argument_list|(
literal|"IP_DROP_MEMBERSHIP ALLHOSTS"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_state
operator|&=
operator|~
name|IS_ALL_HOSTS
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALL_HOSTS
operator|)
condition|)
block|{
comment|/* start listening to advertisements 		 */
name|m
operator|.
name|imr_multiaddr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ALLHOSTS_GROUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|rdisc_sock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_ADD_MEMBERSHIP
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|LOGERR
argument_list|(
literal|"IP_ADD_MEMBERSHIP ALLHOSTS"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|int_state
operator||=
name|IS_ALL_HOSTS
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|supplier
operator|||
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_ADV_OUT
operator|)
operator|||
operator|!
name|on
condition|)
block|{
comment|/* stop listening to solicitations 		 */
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALL_ROUTERS
condition|)
block|{
name|m
operator|.
name|imr_multiaddr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ALLROUTERS_GROUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|rdisc_sock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_DROP_MEMBERSHIP
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|LOGERR
argument_list|(
literal|"IP_DROP_MEMBERSHIP ALLROUTERS"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_state
operator|&=
operator|~
name|IS_ALL_ROUTERS
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALL_ROUTERS
operator|)
condition|)
block|{
comment|/* start hearing solicitations 		 */
name|m
operator|.
name|imr_multiaddr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ALLROUTERS_GROUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|rdisc_sock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_ADD_MEMBERSHIP
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|LOGERR
argument_list|(
literal|"IP_ADD_MEMBERSHIP ALLROUTERS"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|int_state
operator||=
name|IS_ALL_ROUTERS
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* start supplying routes  */
end_comment

begin_function
name|void
name|set_supplier
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|struct
name|dr
modifier|*
name|drp
decl_stmt|;
if|if
condition|(
name|supplier_set
condition|)
return|return;
name|trace_act
argument_list|(
literal|"start supplying routes"
argument_list|)
expr_stmt|;
comment|/* Forget discovered routes. 	 */
for|for
control|(
name|drp
operator|=
name|drs
init|;
name|drp
operator|<
operator|&
name|drs
index|[
name|MAX_ADS
index|]
condition|;
name|drp
operator|++
control|)
block|{
name|drp
operator|->
name|dr_recv_pref
operator|=
literal|0
expr_stmt|;
name|drp
operator|->
name|dr_life
operator|=
literal|0
expr_stmt|;
block|}
name|rdisc_age
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|supplier_set
operator|=
literal|1
expr_stmt|;
name|supplier
operator|=
literal|1
expr_stmt|;
comment|/* Do not start advertising until we have heard some RIP routes */
name|LIM_SEC
argument_list|(
name|rdisc_timer
argument_list|,
name|now
operator|.
name|tv_sec
operator|+
name|MIN_WAITTIME
argument_list|)
expr_stmt|;
comment|/* Switch router discovery multicast groups from soliciting 	 * to advertising. 	 */
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
condition|)
continue|continue;
name|ifp
operator|->
name|int_rdisc_cnt
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|int_rdisc_timer
operator|.
name|tv_usec
operator|=
name|rdisc_timer
operator|.
name|tv_usec
expr_stmt|;
name|ifp
operator|->
name|int_rdisc_timer
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
operator|+
name|MIN_WAITTIME
expr_stmt|;
name|set_rdisc_mg
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* get rid of any redirects */
name|del_redirects
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* age discovered routes and find the best one  */
end_comment

begin_function
name|void
name|rdisc_age
parameter_list|(
name|naddr
name|bad_gate
parameter_list|)
block|{
name|time_t
name|sec
decl_stmt|;
name|struct
name|dr
modifier|*
name|drp
decl_stmt|;
comment|/* If only advertising, then do only that. */
if|if
condition|(
name|supplier
condition|)
block|{
comment|/* If switching from client to server, get rid of old 		 * default routes. 		 */
if|if
condition|(
name|cur_drp
operator|!=
literal|0
condition|)
name|rdisc_sort
argument_list|()
expr_stmt|;
name|rdisc_adv
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* If we are being told about a bad router, 	 * then age the discovered default route, and if there is 	 * no alternative, solicit a replacement. 	 */
if|if
condition|(
name|bad_gate
operator|!=
literal|0
condition|)
block|{
comment|/* Look for the bad discovered default route. 		 * Age it and note its interface. 		 */
for|for
control|(
name|drp
operator|=
name|drs
init|;
name|drp
operator|<
operator|&
name|drs
index|[
name|MAX_ADS
index|]
condition|;
name|drp
operator|++
control|)
block|{
if|if
condition|(
name|drp
operator|->
name|dr_ts
operator|==
literal|0
condition|)
continue|continue;
comment|/* When we find the bad router, then age the route 			 * to at most SUPPLY_INTERVAL. 			 * This is contrary to RFC 1256, but defends against 			 * black holes. 			 */
if|if
condition|(
name|drp
operator|->
name|dr_gate
operator|==
name|bad_gate
condition|)
block|{
name|sec
operator|=
operator|(
name|now
operator|.
name|tv_sec
operator|-
name|drp
operator|->
name|dr_life
operator|+
name|SUPPLY_INTERVAL
operator|)
expr_stmt|;
if|if
condition|(
name|drp
operator|->
name|dr_ts
operator|>
name|sec
condition|)
block|{
name|trace_act
argument_list|(
literal|"age 0.0.0.0 --> %s via %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|drp
operator|->
name|dr_gate
argument_list|)
argument_list|,
name|drp
operator|->
name|dr_ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
name|drp
operator|->
name|dr_ts
operator|=
name|sec
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
name|rdisc_sol
argument_list|()
expr_stmt|;
name|rdisc_sort
argument_list|()
expr_stmt|;
comment|/* Delete old redirected routes to keep the kernel table small, 	 * and to prevent black holes.  Check that the kernel table 	 * matches the daemon table (i.e. has the default route). 	 * But only if RIP is not running and we are not dealing with 	 * a bad gateway, since otherwise age() will be called. 	 */
if|if
condition|(
name|rip_sock
operator|<
literal|0
operator|&&
name|bad_gate
operator|==
literal|0
condition|)
name|age
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Zap all routes discovered via an interface that has gone bad  *	This should only be called when !(ifp->int_state& IS_ALIAS)  */
end_comment

begin_function
name|void
name|if_bad_rdisc
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|dr
modifier|*
name|drp
decl_stmt|;
for|for
control|(
name|drp
operator|=
name|drs
init|;
name|drp
operator|<
operator|&
name|drs
index|[
name|MAX_ADS
index|]
condition|;
name|drp
operator|++
control|)
block|{
if|if
condition|(
name|drp
operator|->
name|dr_ifp
operator|!=
name|ifp
condition|)
continue|continue;
name|drp
operator|->
name|dr_recv_pref
operator|=
literal|0
expr_stmt|;
name|drp
operator|->
name|dr_ts
operator|=
literal|0
expr_stmt|;
name|drp
operator|->
name|dr_life
operator|=
literal|0
expr_stmt|;
block|}
comment|/* make a note to re-solicit, turn RIP on or off, etc. */
name|rdisc_timer
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* mark an interface ok for router discovering.  */
end_comment

begin_function
name|void
name|if_ok_rdisc
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|set_rdisc_mg
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_rdisc_cnt
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|int_rdisc_timer
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
operator|+
operator|(
name|supplier
condition|?
name|MIN_WAITTIME
else|:
name|MAX_SOLICITATION_DELAY
operator|)
expr_stmt|;
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|rdisc_timer
argument_list|,
operator|&
name|ifp
operator|->
name|int_rdisc_timer
argument_list|,
operator|>
argument_list|)
condition|)
name|rdisc_timer
operator|=
name|ifp
operator|->
name|int_rdisc_timer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get rid of a dead discovered router  */
end_comment

begin_function
specifier|static
name|void
name|del_rdisc
parameter_list|(
name|struct
name|dr
modifier|*
name|drp
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|naddr
name|gate
decl_stmt|;
name|int
name|i
decl_stmt|;
name|del_redirects
argument_list|(
name|gate
operator|=
name|drp
operator|->
name|dr_gate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drp
operator|->
name|dr_ts
operator|=
literal|0
expr_stmt|;
name|drp
operator|->
name|dr_life
operator|=
literal|0
expr_stmt|;
comment|/* Count the other discovered routes on the interface. 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|ifp
operator|=
name|drp
operator|->
name|dr_ifp
expr_stmt|;
for|for
control|(
name|drp
operator|=
name|drs
init|;
name|drp
operator|<
operator|&
name|drs
index|[
name|MAX_ADS
index|]
condition|;
name|drp
operator|++
control|)
block|{
if|if
condition|(
name|drp
operator|->
name|dr_ts
operator|!=
literal|0
operator|&&
name|drp
operator|->
name|dr_ifp
operator|==
name|ifp
condition|)
name|i
operator|++
expr_stmt|;
block|}
comment|/* If that was the last good discovered router on the interface, 	 * then solicit a new one. 	 * This is contrary to RFC 1256, but defends against black holes. 	 */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|trace_act
argument_list|(
literal|"discovered router %s via %s"
literal|" is bad--have %d remaining"
argument_list|,
name|naddr_ntoa
argument_list|(
name|gate
argument_list|)
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|int_rdisc_cnt
operator|>=
name|MAX_SOLICITATIONS
condition|)
block|{
name|trace_act
argument_list|(
literal|"last discovered router %s via %s"
literal|" is bad--re-solicit"
argument_list|,
name|naddr_ntoa
argument_list|(
name|gate
argument_list|)
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_rdisc_cnt
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|int_rdisc_timer
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|rdisc_sol
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|trace_act
argument_list|(
literal|"last discovered router %s via %s"
literal|" is bad--wait to solicit"
argument_list|,
name|naddr_ntoa
argument_list|(
name|gate
argument_list|)
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the best discovered route,  * and discard stale routers.  */
end_comment

begin_function
specifier|static
name|void
name|rdisc_sort
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dr
modifier|*
name|drp
decl_stmt|,
modifier|*
name|new_drp
decl_stmt|;
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
name|struct
name|rt_spare
name|new
decl_stmt|;
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|u_int
name|new_st
init|=
literal|0
decl_stmt|;
name|n_long
name|new_pref
init|=
literal|0
decl_stmt|;
comment|/* Find the best discovered route. 	 */
name|new_drp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|drp
operator|=
name|drs
init|;
name|drp
operator|<
operator|&
name|drs
index|[
name|MAX_ADS
index|]
condition|;
name|drp
operator|++
control|)
block|{
if|if
condition|(
name|drp
operator|->
name|dr_ts
operator|==
literal|0
condition|)
continue|continue;
name|ifp
operator|=
name|drp
operator|->
name|dr_ifp
expr_stmt|;
comment|/* Get rid of expired discovered routers. 		 */
if|if
condition|(
name|drp
operator|->
name|dr_ts
operator|+
name|drp
operator|->
name|dr_life
operator|<=
name|now
operator|.
name|tv_sec
condition|)
block|{
name|del_rdisc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LIM_SEC
argument_list|(
name|rdisc_timer
argument_list|,
name|drp
operator|->
name|dr_ts
operator|+
name|drp
operator|->
name|dr_life
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Update preference with possibly changed interface 		 * metric. 		 */
name|drp
operator|->
name|dr_pref
operator|=
name|PREF
argument_list|(
name|drp
operator|->
name|dr_recv_pref
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
comment|/* Prefer the current route to prevent thrashing. 		 * Prefer shorter lifetimes to speed the detection of 		 * bad routers. 		 * Avoid sick interfaces. 		 */
if|if
condition|(
name|new_drp
operator|==
literal|0
operator|||
operator|(
operator|!
operator|(
operator|(
name|new_st
operator|^
name|drp
operator|->
name|dr_ifp
operator|->
name|int_state
operator|)
operator|&
name|IS_SICK
operator|)
operator|&&
operator|(
name|new_pref
operator|<
name|drp
operator|->
name|dr_pref
operator|||
operator|(
name|new_pref
operator|==
name|drp
operator|->
name|dr_pref
operator|&&
operator|(
name|drp
operator|==
name|cur_drp
operator|||
operator|(
name|new_drp
operator|!=
name|cur_drp
operator|&&
name|new_drp
operator|->
name|dr_life
operator|>
name|drp
operator|->
name|dr_life
operator|)
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|new_st
operator|&
name|IS_SICK
operator|)
operator|&&
operator|!
operator|(
name|drp
operator|->
name|dr_ifp
operator|->
name|int_state
operator|&
name|IS_SICK
operator|)
operator|)
condition|)
block|{
name|new_drp
operator|=
name|drp
expr_stmt|;
name|new_st
operator|=
name|drp
operator|->
name|dr_ifp
operator|->
name|int_state
expr_stmt|;
name|new_pref
operator|=
name|drp
operator|->
name|dr_pref
expr_stmt|;
block|}
block|}
comment|/* switch to a better default route 	 */
if|if
condition|(
name|new_drp
operator|!=
name|cur_drp
condition|)
block|{
name|rt
operator|=
name|rtget
argument_list|(
name|RIP_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop using discovered routes if they are all bad 		 */
if|if
condition|(
name|new_drp
operator|==
literal|0
condition|)
block|{
name|trace_act
argument_list|(
literal|"turn off Router Discovery client"
argument_list|)
expr_stmt|;
name|rdisc_ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
operator|&&
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RS_RDISC
operator|)
condition|)
block|{
name|new
operator|=
name|rt
operator|->
name|rt_spares
index|[
literal|0
index|]
expr_stmt|;
name|new
operator|.
name|rts_metric
operator|=
name|HOPCNT_INFINITY
expr_stmt|;
name|new
operator|.
name|rts_time
operator|=
name|now
operator|.
name|tv_sec
operator|-
name|GARBAGE_TIME
expr_stmt|;
name|rtchange
argument_list|(
name|rt
argument_list|,
name|rt
operator|->
name|rt_state
operator|&
operator|~
name|RS_RDISC
argument_list|,
operator|&
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rtswitch
argument_list|(
name|rt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cur_drp
operator|==
literal|0
condition|)
block|{
name|trace_act
argument_list|(
literal|"turn on Router Discovery client"
literal|" using %s via %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|new_drp
operator|->
name|dr_gate
argument_list|)
argument_list|,
name|new_drp
operator|->
name|dr_ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
name|rdisc_ok
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|trace_act
argument_list|(
literal|"switch Router Discovery from"
literal|" %s via %s to %s via %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|cur_drp
operator|->
name|dr_gate
argument_list|)
argument_list|,
name|cur_drp
operator|->
name|dr_ifp
operator|->
name|int_name
argument_list|,
name|naddr_ntoa
argument_list|(
name|new_drp
operator|->
name|dr_gate
argument_list|)
argument_list|,
name|new_drp
operator|->
name|dr_ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|.
name|rts_ifp
operator|=
name|new_drp
operator|->
name|dr_ifp
expr_stmt|;
name|new
operator|.
name|rts_gate
operator|=
name|new_drp
operator|->
name|dr_gate
expr_stmt|;
name|new
operator|.
name|rts_router
operator|=
name|new_drp
operator|->
name|dr_gate
expr_stmt|;
name|new
operator|.
name|rts_metric
operator|=
name|HOPCNT_INFINITY
operator|-
literal|1
expr_stmt|;
name|new
operator|.
name|rts_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
literal|0
condition|)
block|{
name|rtchange
argument_list|(
name|rt
argument_list|,
name|rt
operator|->
name|rt_state
operator||
name|RS_RDISC
argument_list|,
operator|&
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtadd
argument_list|(
name|RIP_DEFAULT
argument_list|,
literal|0
argument_list|,
name|RS_RDISC
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
block|}
block|}
name|cur_drp
operator|=
name|new_drp
expr_stmt|;
block|}
comment|/* turn RIP on or off */
if|if
condition|(
operator|!
name|rdisc_ok
operator|||
name|rip_interfaces
operator|>
literal|1
condition|)
block|{
name|rip_on
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rip_off
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* handle a single address in an advertisement  */
end_comment

begin_function
specifier|static
name|void
name|parse_ad
parameter_list|(
name|naddr
name|from
parameter_list|,
name|naddr
name|gate
parameter_list|,
name|n_long
name|pref
parameter_list|,
comment|/* signed and in network order */
name|u_short
name|life
parameter_list|,
comment|/* in host byte order */
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
specifier|static
name|struct
name|msg_limit
name|bad_gate
decl_stmt|;
name|struct
name|dr
modifier|*
name|drp
decl_stmt|,
modifier|*
name|new_drp
decl_stmt|;
if|if
condition|(
name|gate
operator|==
name|RIP_DEFAULT
operator|||
operator|!
name|check_dst
argument_list|(
name|gate
argument_list|)
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_gate
argument_list|,
name|from
argument_list|,
literal|"router %s advertising bad gateway %s"
argument_list|,
name|naddr_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|gate
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ignore pointers to ourself and routes via unreachable networks 	 */
if|if
condition|(
name|ifwithaddr
argument_list|(
name|gate
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|trace_pkt
argument_list|(
literal|"    discard Router Discovery Ad pointing at us"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|on_net
argument_list|(
name|gate
argument_list|,
name|ifp
operator|->
name|int_net
argument_list|,
name|ifp
operator|->
name|int_mask
argument_list|)
condition|)
block|{
name|trace_pkt
argument_list|(
literal|"    discard Router Discovery Ad"
literal|" toward unreachable net"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Convert preference to an unsigned value 	 * and later bias it by the metric of the interface. 	 */
name|pref
operator|=
name|UNSIGN_PREF
argument_list|(
name|ntohl
argument_list|(
name|pref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pref
operator|==
literal|0
operator|||
name|life
operator|<
name|MinMaxAdvertiseInterval
condition|)
block|{
name|pref
operator|=
literal|0
expr_stmt|;
name|life
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|new_drp
operator|=
literal|0
operator|,
name|drp
operator|=
name|drs
init|;
name|drp
operator|<
operator|&
name|drs
index|[
name|MAX_ADS
index|]
condition|;
name|drp
operator|++
control|)
block|{
comment|/* accept new info for a familiar entry 		 */
if|if
condition|(
name|drp
operator|->
name|dr_gate
operator|==
name|gate
condition|)
block|{
name|new_drp
operator|=
name|drp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|life
operator|==
literal|0
condition|)
continue|continue;
comment|/* do not worry about dead ads */
if|if
condition|(
name|drp
operator|->
name|dr_ts
operator|==
literal|0
condition|)
block|{
name|new_drp
operator|=
name|drp
expr_stmt|;
comment|/* use unused entry */
block|}
elseif|else
if|if
condition|(
name|new_drp
operator|==
literal|0
condition|)
block|{
comment|/* look for an entry worse than the new one to 			 * reuse. 			 */
if|if
condition|(
operator|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_SICK
operator|)
operator|&&
operator|(
name|drp
operator|->
name|dr_ifp
operator|->
name|int_state
operator|&
name|IS_SICK
operator|)
operator|)
operator|||
operator|(
name|pref
operator|>
name|drp
operator|->
name|dr_pref
operator|&&
operator|!
operator|(
operator|(
name|ifp
operator|->
name|int_state
operator|^
name|drp
operator|->
name|dr_ifp
operator|->
name|int_state
operator|)
operator|&
name|IS_SICK
operator|)
operator|)
condition|)
name|new_drp
operator|=
name|drp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_drp
operator|->
name|dr_ts
operator|!=
literal|0
condition|)
block|{
comment|/* look for the least valuable entry to reuse 			 */
if|if
condition|(
operator|(
operator|!
operator|(
name|new_drp
operator|->
name|dr_ifp
operator|->
name|int_state
operator|&
name|IS_SICK
operator|)
operator|&&
operator|(
name|drp
operator|->
name|dr_ifp
operator|->
name|int_state
operator|&
name|IS_SICK
operator|)
operator|)
operator|||
operator|(
name|new_drp
operator|->
name|dr_pref
operator|>
name|drp
operator|->
name|dr_pref
operator|&&
operator|!
operator|(
operator|(
name|new_drp
operator|->
name|dr_ifp
operator|->
name|int_state
operator|^
name|drp
operator|->
name|dr_ifp
operator|->
name|int_state
operator|)
operator|&
name|IS_SICK
operator|)
operator|)
condition|)
name|new_drp
operator|=
name|drp
expr_stmt|;
block|}
block|}
comment|/* forget it if all of the current entries are better */
if|if
condition|(
name|new_drp
operator|==
literal|0
condition|)
return|return;
name|new_drp
operator|->
name|dr_ifp
operator|=
name|ifp
expr_stmt|;
name|new_drp
operator|->
name|dr_gate
operator|=
name|gate
expr_stmt|;
name|new_drp
operator|->
name|dr_ts
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|new_drp
operator|->
name|dr_life
operator|=
name|life
expr_stmt|;
name|new_drp
operator|->
name|dr_recv_pref
operator|=
name|pref
expr_stmt|;
comment|/* bias functional preference by metric of the interface */
name|new_drp
operator|->
name|dr_pref
operator|=
name|PREF
argument_list|(
name|pref
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
comment|/* after hearing a good advertisement, stop asking 	 */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_SICK
operator|)
condition|)
name|ifp
operator|->
name|int_rdisc_cnt
operator|=
name|MAX_SOLICITATIONS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the IP checksum  *	This assumes the packet is less than 32K long.  */
end_comment

begin_function
specifier|static
name|u_short
name|in_cksum
parameter_list|(
name|u_short
modifier|*
name|p
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|u_int
name|sum
init|=
literal|0
decl_stmt|;
name|int
name|nwords
init|=
name|len
operator|>>
literal|1
decl_stmt|;
while|while
condition|(
name|nwords
operator|--
operator|!=
literal|0
condition|)
name|sum
operator|+=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|sum
operator|+=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|p
expr_stmt|;
comment|/* end-around-carry */
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|+
operator|(
name|sum
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|sum
operator|>>
literal|16
operator|)
expr_stmt|;
return|return
operator|(
operator|~
name|sum
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Send a router discovery advertisement or solicitation ICMP packet.  */
end_comment

begin_function
specifier|static
name|void
name|send_rdisc
parameter_list|(
name|union
name|ad_u
modifier|*
name|p
parameter_list|,
name|int
name|p_size
parameter_list|,
name|struct
name|interface
modifier|*
name|ifp
parameter_list|,
name|naddr
name|dst
parameter_list|,
comment|/* 0 or unicast destination */
name|int
name|type
parameter_list|)
comment|/* 0=unicast, 1=bcast, 2=mcast */
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|naddr
name|tgt_mcast
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|dst
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
ifdef|#
directive|ifdef
name|_HAVE_SIN_LEN
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flags
operator|=
name|MSG_DONTROUTE
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0
case|:
comment|/* unicast */
default|default:
name|msg
operator|=
literal|"Send"
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* broadcast */
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
name|msg
operator|=
literal|"Send pt-to-pt"
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifp
operator|->
name|int_dstaddr
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
literal|"Send broadcast"
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifp
operator|->
name|int_brdaddr
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* multicast */
name|msg
operator|=
literal|"Send multicast"
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_DUP
condition|)
block|{
name|trace_act
argument_list|(
literal|"abort multicast output via %s"
literal|" with duplicate address"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rdisc_sock_mcast
operator|!=
name|ifp
condition|)
block|{
comment|/* select the right interface. */
ifdef|#
directive|ifdef
name|MCAST_PPP_BUG
comment|/* Do not specify the primary interface explicitly 			 * if we have the multicast point-to-point kernel 			 * bug, since the kernel will do the wrong thing 			 * if the local address of a point-to-point link 			 * is the same as the address of an ordinary 			 * interface. 			 */
if|if
condition|(
name|ifp
operator|->
name|int_addr
operator|==
name|myaddr
condition|)
block|{
name|tgt_mcast
operator|=
literal|0
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|tgt_mcast
operator|=
name|ifp
operator|->
name|int_addr
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|setsockopt
argument_list|(
name|rdisc_sock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_IF
argument_list|,
operator|&
name|tgt_mcast
argument_list|,
sizeof|sizeof
argument_list|(
name|tgt_mcast
argument_list|)
argument_list|)
condition|)
block|{
name|LOGERR
argument_list|(
literal|"setsockopt(rdisc_sock,"
literal|"IP_MULTICAST_IF)"
argument_list|)
expr_stmt|;
name|rdisc_sock_mcast
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|rdisc_sock_mcast
operator|=
name|ifp
expr_stmt|;
block|}
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rdisc_sock
operator|<
literal|0
condition|)
name|get_rdisc_sock
argument_list|()
expr_stmt|;
name|trace_rdisc
argument_list|(
name|msg
argument_list|,
name|ifp
operator|->
name|int_addr
argument_list|,
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|ifp
argument_list|,
name|p
argument_list|,
name|p_size
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|sendto
argument_list|(
name|rdisc_sock
argument_list|,
name|p
argument_list|,
name|p_size
argument_list|,
name|flags
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|ifp
operator|==
literal|0
operator|||
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
operator|)
condition|)
name|msglog
argument_list|(
literal|"sendto(%s%s%s): %s"
argument_list|,
name|ifp
operator|!=
literal|0
condition|?
name|ifp
operator|->
name|int_name
else|:
literal|""
argument_list|,
name|ifp
operator|!=
literal|0
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
literal|0
condition|)
name|if_sick
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Send an advertisement  */
end_comment

begin_function
specifier|static
name|void
name|send_adv
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|,
name|naddr
name|dst
parameter_list|,
comment|/* 0 or unicast destination */
name|int
name|type
parameter_list|)
comment|/* 0=unicast, 1=bcast, 2=mcast */
block|{
name|union
name|ad_u
name|u
decl_stmt|;
name|n_long
name|pref
decl_stmt|;
name|memset
argument_list|(
operator|&
name|u
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|u
operator|.
name|ad
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|.
name|ad
operator|.
name|icmp_type
operator|=
name|ICMP_ROUTERADVERT
expr_stmt|;
name|u
operator|.
name|ad
operator|.
name|icmp_ad_num
operator|=
literal|1
expr_stmt|;
name|u
operator|.
name|ad
operator|.
name|icmp_ad_asize
operator|=
sizeof|sizeof
argument_list|(
name|u
operator|.
name|ad
operator|.
name|icmp_ad_info
index|[
literal|0
index|]
argument_list|)
operator|/
literal|4
expr_stmt|;
name|u
operator|.
name|ad
operator|.
name|icmp_ad_life
operator|=
name|stopint
condition|?
literal|0
else|:
name|htons
argument_list|(
name|ifp
operator|->
name|int_rdisc_int
operator|*
literal|3
argument_list|)
expr_stmt|;
comment|/* Convert the configured preference to an unsigned value, 	 * bias it by the interface metric, and then send it as a 	 * signed, network byte order value. 	 */
name|pref
operator|=
name|UNSIGN_PREF
argument_list|(
name|ifp
operator|->
name|int_rdisc_pref
argument_list|)
expr_stmt|;
name|u
operator|.
name|ad
operator|.
name|icmp_ad_info
index|[
literal|0
index|]
operator|.
name|icmp_ad_pref
operator|=
name|htonl
argument_list|(
name|SIGN_PREF
argument_list|(
name|PREF
argument_list|(
name|pref
argument_list|,
name|ifp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|.
name|ad
operator|.
name|icmp_ad_info
index|[
literal|0
index|]
operator|.
name|icmp_ad_addr
operator|=
name|ifp
operator|->
name|int_addr
expr_stmt|;
name|u
operator|.
name|ad
operator|.
name|icmp_cksum
operator|=
name|in_cksum
argument_list|(
operator|(
name|u_short
operator|*
operator|)
operator|&
name|u
operator|.
name|ad
argument_list|,
sizeof|sizeof
argument_list|(
name|u
operator|.
name|ad
argument_list|)
argument_list|)
expr_stmt|;
name|send_rdisc
argument_list|(
operator|&
name|u
argument_list|,
sizeof|sizeof
argument_list|(
name|u
operator|.
name|ad
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|dst
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Advertise for Router Discovery  */
end_comment

begin_function
name|void
name|rdisc_adv
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
operator|!
name|supplier
condition|)
return|return;
name|rdisc_timer
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
operator|+
name|NEVER
expr_stmt|;
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
if|if
condition|(
literal|0
operator|!=
operator|(
name|ifp
operator|->
name|int_state
operator|&
operator|(
name|IS_NO_ADV_OUT
operator||
name|IS_BROKE
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|timercmp
argument_list|(
operator|&
name|ifp
operator|->
name|int_rdisc_timer
argument_list|,
operator|&
name|now
argument_list|,
operator|>
argument_list|)
operator|||
name|stopint
condition|)
block|{
name|send_adv
argument_list|(
name|ifp
argument_list|,
name|htonl
argument_list|(
name|INADDR_ALLHOSTS_GROUP
argument_list|)
argument_list|,
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BCAST_RDISC
operator|)
condition|?
literal|1
else|:
literal|2
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_rdisc_cnt
operator|++
expr_stmt|;
name|intvl_random
argument_list|(
operator|&
name|ifp
operator|->
name|int_rdisc_timer
argument_list|,
operator|(
name|ifp
operator|->
name|int_rdisc_int
operator|*
literal|3
operator|)
operator|/
literal|4
argument_list|,
name|ifp
operator|->
name|int_rdisc_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_rdisc_cnt
operator|<
name|MAX_INITIAL_ADVERTS
operator|&&
operator|(
name|ifp
operator|->
name|int_rdisc_timer
operator|.
name|tv_sec
operator|>
name|MAX_INITIAL_ADVERT_INTERVAL
operator|)
condition|)
block|{
name|ifp
operator|->
name|int_rdisc_timer
operator|.
name|tv_sec
operator|=
name|MAX_INITIAL_ADVERT_INTERVAL
expr_stmt|;
block|}
name|timevaladd
argument_list|(
operator|&
name|ifp
operator|->
name|int_rdisc_timer
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|rdisc_timer
argument_list|,
operator|&
name|ifp
operator|->
name|int_rdisc_timer
argument_list|,
operator|>
argument_list|)
condition|)
name|rdisc_timer
operator|=
name|ifp
operator|->
name|int_rdisc_timer
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Solicit for Router Discovery  */
end_comment

begin_function
name|void
name|rdisc_sol
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|union
name|ad_u
name|u
decl_stmt|;
if|if
condition|(
name|supplier
condition|)
return|return;
name|rdisc_timer
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
operator|+
name|NEVER
expr_stmt|;
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
if|if
condition|(
literal|0
operator|!=
operator|(
name|ifp
operator|->
name|int_state
operator|&
operator|(
name|IS_NO_SOL_OUT
operator||
name|IS_BROKE
operator|)
operator|)
operator|||
name|ifp
operator|->
name|int_rdisc_cnt
operator|>=
name|MAX_SOLICITATIONS
condition|)
continue|continue;
if|if
condition|(
operator|!
name|timercmp
argument_list|(
operator|&
name|ifp
operator|->
name|int_rdisc_timer
argument_list|,
operator|&
name|now
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|memset
argument_list|(
operator|&
name|u
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|u
operator|.
name|so
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|.
name|so
operator|.
name|icmp_type
operator|=
name|ICMP_ROUTERSOLICIT
expr_stmt|;
name|u
operator|.
name|so
operator|.
name|icmp_cksum
operator|=
name|in_cksum
argument_list|(
operator|(
name|u_short
operator|*
operator|)
operator|&
name|u
operator|.
name|so
argument_list|,
sizeof|sizeof
argument_list|(
name|u
operator|.
name|so
argument_list|)
argument_list|)
expr_stmt|;
name|send_rdisc
argument_list|(
operator|&
name|u
argument_list|,
sizeof|sizeof
argument_list|(
name|u
operator|.
name|so
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|htonl
argument_list|(
name|INADDR_ALLROUTERS_GROUP
argument_list|)
argument_list|,
operator|(
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BCAST_RDISC
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|ifp
operator|->
name|int_rdisc_cnt
operator|>=
name|MAX_SOLICITATIONS
condition|)
continue|continue;
name|ifp
operator|->
name|int_rdisc_timer
operator|.
name|tv_sec
operator|=
name|SOLICITATION_INTERVAL
expr_stmt|;
name|ifp
operator|->
name|int_rdisc_timer
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|ifp
operator|->
name|int_rdisc_timer
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|rdisc_timer
argument_list|,
operator|&
name|ifp
operator|->
name|int_rdisc_timer
argument_list|,
operator|>
argument_list|)
condition|)
name|rdisc_timer
operator|=
name|ifp
operator|->
name|int_rdisc_timer
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* check the IP header of a possible Router Discovery ICMP packet */
end_comment

begin_function
specifier|static
name|struct
name|interface
modifier|*
comment|/* 0 if bad */
name|ck_icmp
parameter_list|(
specifier|const
name|char
modifier|*
name|act
parameter_list|,
name|naddr
name|from
parameter_list|,
name|struct
name|interface
modifier|*
name|ifp
parameter_list|,
name|naddr
name|to
parameter_list|,
name|union
name|ad_u
modifier|*
name|p
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|icmp
operator|.
name|icmp_type
operator|==
name|ICMP_ROUTERADVERT
condition|)
block|{
name|type
operator|=
literal|"advertisement"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|icmp
operator|.
name|icmp_type
operator|==
name|ICMP_ROUTERSOLICIT
condition|)
block|{
name|type
operator|=
literal|"solicitation"
expr_stmt|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|p
operator|->
name|icmp
operator|.
name|icmp_code
operator|!=
literal|0
condition|)
block|{
name|trace_pkt
argument_list|(
literal|"unrecognized ICMP Router %s code=%d from %s to %s"
argument_list|,
name|type
argument_list|,
name|p
operator|->
name|icmp
operator|.
name|icmp_code
argument_list|,
name|naddr_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|trace_rdisc
argument_list|(
name|act
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|ifp
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
literal|0
condition|)
name|trace_pkt
argument_list|(
literal|"unknown interface for router-discovery %s"
literal|" from %s to %s"
argument_list|,
name|type
argument_list|,
name|naddr_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ifp
return|;
block|}
end_function

begin_comment
comment|/* read packets from the router discovery socket  */
end_comment

begin_function
name|void
name|read_d
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|msg_limit
name|bad_asize
decl_stmt|,
name|bad_len
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_PASSIFNAME
specifier|static
name|struct
name|msg_limit
name|bad_name
decl_stmt|;
endif|#
directive|endif
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|int
name|n
decl_stmt|,
name|fromlen
decl_stmt|,
name|cc
decl_stmt|,
name|hlen
decl_stmt|;
struct|struct
block|{
ifdef|#
directive|ifdef
name|USE_PASSIFNAME
name|char
name|ifname
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
endif|#
directive|endif
union|union
block|{
name|struct
name|ip
name|ip
decl_stmt|;
name|u_short
name|s
index|[
literal|512
operator|/
literal|2
index|]
decl_stmt|;
name|u_char
name|b
index|[
literal|512
index|]
decl_stmt|;
block|}
name|pkt
union|;
block|}
name|buf
struct|;
name|union
name|ad_u
modifier|*
name|p
decl_stmt|;
name|n_long
modifier|*
name|wp
decl_stmt|;
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|cc
operator|=
name|recvfrom
argument_list|(
name|rdisc_sock
argument_list|,
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|cc
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
name|LOGERR
argument_list|(
literal|"recvfrom(rdisc_sock)"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fromlen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
name|logbad
argument_list|(
literal|1
argument_list|,
literal|"impossible recvfrom(rdisc_sock) fromlen=%d"
argument_list|,
name|fromlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_PASSIFNAME
if|if
condition|(
operator|(
name|cc
operator|-=
sizeof|sizeof
argument_list|(
name|buf
operator|.
name|ifname
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|logbad
argument_list|(
literal|0
argument_list|,
literal|"missing USE_PASSIFNAME; only %d bytes"
argument_list|,
name|cc
operator|+
sizeof|sizeof
argument_list|(
name|buf
operator|.
name|ifname
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hlen
operator|=
name|buf
operator|.
name|pkt
operator|.
name|ip
operator|.
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|cc
operator|<
name|hlen
operator|+
name|ICMP_MINLEN
condition|)
continue|continue;
name|p
operator|=
operator|(
expr|union
name|ad_u
operator|*
operator|)
operator|&
name|buf
operator|.
name|pkt
operator|.
name|b
index|[
name|hlen
index|]
expr_stmt|;
name|cc
operator|-=
name|hlen
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_PASSIFNAME
name|ifp
operator|=
name|ifwithname
argument_list|(
name|buf
operator|.
name|ifname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
literal|0
condition|)
name|msglim
argument_list|(
operator|&
name|bad_name
argument_list|,
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|"impossible rdisc if_ name %.*s"
argument_list|,
name|IFNAMSIZ
argument_list|,
name|buf
operator|.
name|ifname
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* If we could tell the interface on which a packet from 		 * address 0 arrived, we could deal with such solicitations. 		 */
name|ifp
operator|=
operator|(
operator|(
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|iflookup
argument_list|(
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|=
name|ck_icmp
argument_list|(
literal|"Recv"
argument_list|,
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|ifp
argument_list|,
name|buf
operator|.
name|pkt
operator|.
name|ip
operator|.
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|p
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ifwithaddr
argument_list|(
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|trace_pkt
argument_list|(
literal|"    "
literal|"discard our own Router Discovery message"
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|p
operator|->
name|icmp
operator|.
name|icmp_type
condition|)
block|{
case|case
name|ICMP_ROUTERADVERT
case|:
if|if
condition|(
name|p
operator|->
name|ad
operator|.
name|icmp_ad_asize
operator|*
literal|4
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|p
operator|->
name|ad
operator|.
name|icmp_ad_info
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_asize
argument_list|,
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|"intolerable rdisc address size=%d"
argument_list|,
name|p
operator|->
name|ad
operator|.
name|icmp_ad_asize
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
operator|->
name|ad
operator|.
name|icmp_ad_num
operator|==
literal|0
condition|)
block|{
name|trace_pkt
argument_list|(
literal|"    empty?"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cc
operator|!=
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|p
operator|->
name|ad
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|p
operator|->
name|ad
operator|.
name|icmp_ad_info
argument_list|)
operator|+
operator|(
name|p
operator|->
name|ad
operator|.
name|icmp_ad_num
operator|*
sizeof|sizeof
argument_list|(
name|p
operator|->
name|ad
operator|.
name|icmp_ad_info
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|)
condition|)
block|{
name|msglim
argument_list|(
operator|&
name|bad_len
argument_list|,
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|"rdisc length %d does not match ad_num"
literal|" %d"
argument_list|,
name|cc
argument_list|,
name|p
operator|->
name|ad
operator|.
name|icmp_ad_num
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|supplier
condition|)
continue|continue;
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_ADV_IN
condition|)
continue|continue;
name|wp
operator|=
operator|&
name|p
operator|->
name|ad
operator|.
name|icmp_ad_info
index|[
literal|0
index|]
operator|.
name|icmp_ad_addr
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|p
operator|->
name|ad
operator|.
name|icmp_ad_num
condition|;
name|n
operator|++
control|)
block|{
name|parse_ad
argument_list|(
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|wp
index|[
literal|0
index|]
argument_list|,
name|wp
index|[
literal|1
index|]
argument_list|,
name|ntohs
argument_list|(
name|p
operator|->
name|ad
operator|.
name|icmp_ad_life
argument_list|)
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|wp
operator|+=
name|p
operator|->
name|ad
operator|.
name|icmp_ad_asize
expr_stmt|;
block|}
break|break;
case|case
name|ICMP_ROUTERSOLICIT
case|:
if|if
condition|(
operator|!
name|supplier
condition|)
continue|continue;
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_ADV_OUT
condition|)
continue|continue;
if|if
condition|(
name|stopint
condition|)
continue|continue;
comment|/* XXX 			 * We should handle messages from address 0. 			 */
comment|/* Respond with a point-to-point advertisement */
name|send_adv
argument_list|(
name|ifp
argument_list|,
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|rdisc_sort
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

