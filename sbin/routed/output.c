begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
literal|"@(#)output.c	8.1 (Berkeley) 6/5/93"
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_elif

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_empty
empty|#ident "$FreeBSD$"
end_empty

begin_decl_stmt
name|u_int
name|update_seqno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* walk the tree of routes with this for output  */
end_comment

begin_struct
struct|struct
block|{
name|struct
name|sockaddr_in
name|to
decl_stmt|;
name|naddr
name|to_mask
decl_stmt|;
name|naddr
name|to_net
decl_stmt|;
name|naddr
name|to_std_mask
decl_stmt|;
name|naddr
name|to_std_net
decl_stmt|;
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
comment|/* usually output interface */
name|struct
name|auth
modifier|*
name|a
decl_stmt|;
name|char
name|metric
decl_stmt|;
comment|/* adjust metrics by interface */
name|int
name|npackets
decl_stmt|;
name|int
name|gen_limit
decl_stmt|;
name|u_int
name|state
decl_stmt|;
define|#
directive|define
name|WS_ST_FLASH
value|0x001
comment|/* send only changed routes */
define|#
directive|define
name|WS_ST_RIP2_ALL
value|0x002
comment|/* send full featured RIPv2 */
define|#
directive|define
name|WS_ST_AG
value|0x004
comment|/* ok to aggregate subnets */
define|#
directive|define
name|WS_ST_SUPER_AG
value|0x008
comment|/* ok to aggregate networks */
define|#
directive|define
name|WS_ST_QUERY
value|0x010
comment|/* responding to a query */
define|#
directive|define
name|WS_ST_TO_ON_NET
value|0x020
comment|/* sending onto one of our nets */
define|#
directive|define
name|WS_ST_DEFAULT
value|0x040
comment|/* faking a default */
block|}
name|ws
struct|;
end_struct

begin_comment
comment|/* A buffer for what can be heard by both RIPv1 and RIPv2 listeners */
end_comment

begin_decl_stmt
name|struct
name|ws_buf
name|v12buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|union
name|pkt_buf
name|ripv12_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Another for only RIPv2 listeners */
end_comment

begin_decl_stmt
name|struct
name|ws_buf
name|v2buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|union
name|pkt_buf
name|rip_v2_buf
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|bufinit
parameter_list|(
name|void
parameter_list|)
block|{
name|ripv12_buf
operator|.
name|rip
operator|.
name|rip_cmd
operator|=
name|RIPCMD_RESPONSE
expr_stmt|;
name|v12buf
operator|.
name|buf
operator|=
operator|&
name|ripv12_buf
operator|.
name|rip
expr_stmt|;
name|v12buf
operator|.
name|base
operator|=
operator|&
name|v12buf
operator|.
name|buf
operator|->
name|rip_nets
index|[
literal|0
index|]
expr_stmt|;
name|rip_v2_buf
operator|.
name|rip
operator|.
name|rip_cmd
operator|=
name|RIPCMD_RESPONSE
expr_stmt|;
name|rip_v2_buf
operator|.
name|rip
operator|.
name|rip_vers
operator|=
name|RIPv2
expr_stmt|;
name|v2buf
operator|.
name|buf
operator|=
operator|&
name|rip_v2_buf
operator|.
name|rip
expr_stmt|;
name|v2buf
operator|.
name|base
operator|=
operator|&
name|v2buf
operator|.
name|buf
operator|->
name|rip_nets
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send the contents of the global buffer via the non-multicast socket  */
end_comment

begin_function
name|int
comment|/*<0 on failure */
name|output
parameter_list|(
name|enum
name|output_type
name|type
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|dst
parameter_list|,
comment|/* send to here */
name|struct
name|interface
modifier|*
name|ifp
parameter_list|,
name|struct
name|rip
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
comment|/* this many bytes */
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|res
decl_stmt|;
name|naddr
name|tgt_mcast
decl_stmt|;
name|int
name|soc
decl_stmt|;
name|int
name|serrno
decl_stmt|;
name|sin
operator|=
operator|*
name|dst
expr_stmt|;
if|if
condition|(
name|sin
operator|.
name|sin_port
operator|==
literal|0
condition|)
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|RIP_PORT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_HAVE_SIN_LEN
if|if
condition|(
name|sin
operator|.
name|sin_len
operator|==
literal|0
condition|)
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|soc
operator|=
name|rip_sock
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OUT_QUERY
case|:
name|msg
operator|=
literal|"Answer Query"
expr_stmt|;
if|if
condition|(
name|soc
operator|<
literal|0
condition|)
name|soc
operator|=
name|ifp
operator|->
name|int_rip_sock
expr_stmt|;
break|break;
case|case
name|OUT_UNICAST
case|:
name|msg
operator|=
literal|"Send"
expr_stmt|;
if|if
condition|(
name|soc
operator|<
literal|0
condition|)
name|soc
operator|=
name|ifp
operator|->
name|int_rip_sock
expr_stmt|;
name|flags
operator|=
name|MSG_DONTROUTE
expr_stmt|;
break|break;
case|case
name|OUT_BROADCAST
case|:
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
name|msg
operator|=
literal|"Send"
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|=
literal|"Send bcast"
expr_stmt|;
block|}
name|flags
operator|=
name|MSG_DONTROUTE
expr_stmt|;
break|break;
case|case
name|OUT_MULTICAST
case|:
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
name|msg
operator|=
literal|"Send pt-to-pt"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_DUP
condition|)
block|{
name|trace_act
argument_list|(
literal|"abort multicast output via %s"
literal|" with duplicate address"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|msg
operator|=
literal|"Send mcast"
expr_stmt|;
if|if
condition|(
name|rip_sock_mcast
operator|!=
name|ifp
condition|)
block|{
ifdef|#
directive|ifdef
name|MCAST_PPP_BUG
comment|/* Do not specify the primary interface 				 * explicitly if we have the multicast 				 * point-to-point kernel bug, since the 				 * kernel will do the wrong thing if the 				 * local address of a point-to-point link 				 * is the same as the address of an ordinary 				 * interface. 				 */
if|if
condition|(
name|ifp
operator|->
name|int_addr
operator|==
name|myaddr
condition|)
block|{
name|tgt_mcast
operator|=
literal|0
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|tgt_mcast
operator|=
name|ifp
operator|->
name|int_addr
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|setsockopt
argument_list|(
name|rip_sock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_IF
argument_list|,
operator|&
name|tgt_mcast
argument_list|,
sizeof|sizeof
argument_list|(
name|tgt_mcast
argument_list|)
argument_list|)
condition|)
block|{
name|serrno
operator|=
name|errno
expr_stmt|;
name|LOGERR
argument_list|(
literal|"setsockopt(rip_sock,"
literal|"IP_MULTICAST_IF)"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|serrno
expr_stmt|;
name|ifp
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rip_sock_mcast
operator|=
name|ifp
expr_stmt|;
block|}
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_RIP_GROUP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NO_OUT_MULTICAST
case|:
case|case
name|NO_OUT_RIPV2
case|:
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
name|trace_rip
argument_list|(
name|msg
argument_list|,
literal|"to"
argument_list|,
operator|&
name|sin
argument_list|,
name|ifp
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|res
operator|=
name|sendto
argument_list|(
name|soc
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
operator|&&
operator|(
name|ifp
operator|==
literal|0
operator|||
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_BROKE
operator|)
operator|)
condition|)
block|{
name|serrno
operator|=
name|errno
expr_stmt|;
name|msglog
argument_list|(
literal|"%s sendto(%s%s%s.%d): %s"
argument_list|,
name|msg
argument_list|,
name|ifp
operator|!=
literal|0
condition|?
name|ifp
operator|->
name|int_name
else|:
literal|""
argument_list|,
name|ifp
operator|!=
literal|0
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sin
operator|.
name|sin_port
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
name|serrno
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Find the first key for a packet to send.  * Try for a key that is eligible and has not expired, but settle for  * the last key if they have all expired.  * If no key is ready yet, give up.  */
end_comment

begin_function
name|struct
name|auth
modifier|*
name|find_auth
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|auth
modifier|*
name|ap
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ifp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|res
operator|=
literal|0
expr_stmt|;
name|ap
operator|=
name|ifp
operator|->
name|int_auth
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_AUTH_KEYS
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
block|{
comment|/* stop looking after the last key */
if|if
condition|(
name|ap
operator|->
name|type
operator|==
name|RIP_AUTH_NONE
condition|)
break|break;
comment|/* ignore keys that are not ready yet */
if|if
condition|(
operator|(
name|u_long
operator|)
name|ap
operator|->
name|start
operator|>
operator|(
name|u_long
operator|)
name|clk
operator|.
name|tv_sec
condition|)
continue|continue;
if|if
condition|(
operator|(
name|u_long
operator|)
name|ap
operator|->
name|end
operator|<
operator|(
name|u_long
operator|)
name|clk
operator|.
name|tv_sec
condition|)
block|{
comment|/* note best expired password as a fall-back */
if|if
condition|(
name|res
operator|==
literal|0
operator|||
operator|(
name|u_long
operator|)
name|ap
operator|->
name|end
operator|>
operator|(
name|u_long
operator|)
name|res
operator|->
name|end
condition|)
name|res
operator|=
name|ap
expr_stmt|;
continue|continue;
block|}
comment|/* note key with the best future */
if|if
condition|(
name|res
operator|==
literal|0
operator|||
operator|(
name|u_long
operator|)
name|res
operator|->
name|end
operator|<
operator|(
name|u_long
operator|)
name|ap
operator|->
name|end
condition|)
name|res
operator|=
name|ap
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
name|void
name|clr_ws_buf
parameter_list|(
name|struct
name|ws_buf
modifier|*
name|wb
parameter_list|,
name|struct
name|auth
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|netauth
modifier|*
name|na
decl_stmt|;
name|wb
operator|->
name|lim
operator|=
name|wb
operator|->
name|base
operator|+
name|NETS_LEN
expr_stmt|;
name|wb
operator|->
name|n
operator|=
name|wb
operator|->
name|base
expr_stmt|;
name|memset
argument_list|(
name|wb
operator|->
name|n
argument_list|,
literal|0
argument_list|,
name|NETS_LEN
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|wb
operator|->
name|n
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (start to) install authentication if appropriate 	 */
if|if
condition|(
name|ap
operator|==
literal|0
condition|)
return|return;
name|na
operator|=
operator|(
expr|struct
name|netauth
operator|*
operator|)
name|wb
operator|->
name|n
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|type
operator|==
name|RIP_AUTH_PW
condition|)
block|{
name|na
operator|->
name|a_family
operator|=
name|RIP_AF_AUTH
expr_stmt|;
name|na
operator|->
name|a_type
operator|=
name|RIP_AUTH_PW
expr_stmt|;
name|memcpy
argument_list|(
name|na
operator|->
name|au
operator|.
name|au_pw
argument_list|,
name|ap
operator|->
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|na
operator|->
name|au
operator|.
name|au_pw
argument_list|)
argument_list|)
expr_stmt|;
name|wb
operator|->
name|n
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|type
operator|==
name|RIP_AUTH_MD5
condition|)
block|{
name|na
operator|->
name|a_family
operator|=
name|RIP_AF_AUTH
expr_stmt|;
name|na
operator|->
name|a_type
operator|=
name|RIP_AUTH_MD5
expr_stmt|;
name|na
operator|->
name|au
operator|.
name|a_md5
operator|.
name|md5_keyid
operator|=
name|ap
operator|->
name|keyid
expr_stmt|;
name|na
operator|->
name|au
operator|.
name|a_md5
operator|.
name|md5_auth_len
operator|=
name|RIP_AUTH_MD5_LEN
expr_stmt|;
name|na
operator|->
name|au
operator|.
name|a_md5
operator|.
name|md5_seqno
operator|=
name|htonl
argument_list|(
name|clk
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|wb
operator|->
name|n
operator|++
expr_stmt|;
name|wb
operator|->
name|lim
operator|--
expr_stmt|;
comment|/* make room for trailer */
block|}
block|}
end_function

begin_function
name|void
name|end_md5_auth
parameter_list|(
name|struct
name|ws_buf
modifier|*
name|wb
parameter_list|,
name|struct
name|auth
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|netauth
modifier|*
name|na
decl_stmt|,
modifier|*
name|na2
decl_stmt|;
name|MD5_CTX
name|md5_ctx
decl_stmt|;
name|int
name|len
decl_stmt|;
name|na
operator|=
operator|(
expr|struct
name|netauth
operator|*
operator|)
name|wb
operator|->
name|base
expr_stmt|;
name|na2
operator|=
operator|(
expr|struct
name|netauth
operator|*
operator|)
name|wb
operator|->
name|n
expr_stmt|;
name|len
operator|=
operator|(
name|char
operator|*
operator|)
name|na2
operator|-
operator|(
name|char
operator|*
operator|)
name|wb
operator|->
name|buf
expr_stmt|;
name|na2
operator|->
name|a_family
operator|=
name|RIP_AF_AUTH
expr_stmt|;
name|na2
operator|->
name|a_type
operator|=
name|htons
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|na
operator|->
name|au
operator|.
name|a_md5
operator|.
name|md5_pkt_len
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|MD5Init
argument_list|(
operator|&
name|md5_ctx
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5_ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|wb
operator|->
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5_ctx
argument_list|,
name|ap
operator|->
name|key
argument_list|,
name|RIP_AUTH_MD5_LEN
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|na2
operator|->
name|au
operator|.
name|au_pw
argument_list|,
operator|&
name|md5_ctx
argument_list|)
expr_stmt|;
name|wb
operator|->
name|n
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send the buffer  */
end_comment

begin_function
specifier|static
name|void
name|supply_write
parameter_list|(
name|struct
name|ws_buf
modifier|*
name|wb
parameter_list|)
block|{
comment|/* Output multicast only if legal. 	 * If we would multicast and it would be illegal, then discard the 	 * packet. 	 */
switch|switch
condition|(
name|wb
operator|->
name|type
condition|)
block|{
case|case
name|NO_OUT_MULTICAST
case|:
name|trace_pkt
argument_list|(
literal|"skip multicast to %s because impossible"
argument_list|,
name|naddr_ntoa
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_OUT_RIPV2
case|:
break|break;
default|default:
if|if
condition|(
name|ws
operator|.
name|a
operator|!=
literal|0
operator|&&
name|ws
operator|.
name|a
operator|->
name|type
operator|==
name|RIP_AUTH_MD5
condition|)
name|end_md5_auth
argument_list|(
name|wb
argument_list|,
name|ws
operator|.
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
argument_list|(
name|wb
operator|->
name|type
argument_list|,
operator|&
name|ws
operator|.
name|to
argument_list|,
name|ws
operator|.
name|ifp
argument_list|,
name|wb
operator|->
name|buf
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|wb
operator|->
name|n
operator|-
operator|(
name|char
operator|*
operator|)
name|wb
operator|->
name|buf
operator|)
argument_list|)
operator|<
literal|0
operator|&&
name|ws
operator|.
name|ifp
operator|!=
literal|0
condition|)
name|if_sick
argument_list|(
name|ws
operator|.
name|ifp
argument_list|)
expr_stmt|;
name|ws
operator|.
name|npackets
operator|++
expr_stmt|;
break|break;
block|}
name|clr_ws_buf
argument_list|(
name|wb
argument_list|,
name|ws
operator|.
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* put an entry into the packet  */
end_comment

begin_function
specifier|static
name|void
name|supply_out
parameter_list|(
name|struct
name|ag_info
modifier|*
name|ag
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|naddr
name|mask
decl_stmt|,
name|v1_mask
decl_stmt|,
name|dst_h
decl_stmt|,
name|ddst_h
init|=
literal|0
decl_stmt|;
name|struct
name|ws_buf
modifier|*
name|wb
decl_stmt|;
comment|/* Skip this route if doing a flash update and it and the routes 	 * it aggregates have not changed recently. 	 */
if|if
condition|(
name|ag
operator|->
name|ag_seqno
operator|<
name|update_seqno
operator|&&
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_FLASH
operator|)
condition|)
return|return;
name|dst_h
operator|=
name|ag
operator|->
name|ag_dst_h
expr_stmt|;
name|mask
operator|=
name|ag
operator|->
name|ag_mask
expr_stmt|;
name|v1_mask
operator|=
name|ripv1_mask_host
argument_list|(
name|htonl
argument_list|(
name|dst_h
argument_list|)
argument_list|,
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_TO_ON_NET
operator|)
condition|?
name|ws
operator|.
name|ifp
else|:
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* If we are sending RIPv2 packets that cannot (or must not) be 	 * heard by RIPv1 listeners, do not worry about sub- or supernets. 	 * Subnets (from other networks) can only be sent via multicast. 	 * A pair of subnet routes might have been promoted so that they 	 * are legal to send by RIPv1. 	 * If RIPv1 is off, use the multicast buffer. 	 */
if|if
condition|(
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_RIP2_ALL
operator|)
operator|||
operator|(
operator|(
name|ag
operator|->
name|ag_state
operator|&
name|AGS_RIPV2
operator|)
operator|&&
name|v1_mask
operator|!=
name|mask
operator|)
condition|)
block|{
comment|/* use the RIPv2-only buffer */
name|wb
operator|=
operator|&
name|v2buf
expr_stmt|;
block|}
else|else
block|{
comment|/* use the RIPv1-or-RIPv2 buffer */
name|wb
operator|=
operator|&
name|v12buf
expr_stmt|;
comment|/* Convert supernet route into corresponding set of network 		 * routes for RIPv1, but leave non-contiguous netmasks 		 * to ag_check(). 		 */
if|if
condition|(
name|v1_mask
operator|>
name|mask
operator|&&
name|mask
operator|+
operator|(
name|mask
operator|&
operator|-
name|mask
operator|)
operator|==
literal|0
condition|)
block|{
name|ddst_h
operator|=
name|v1_mask
operator|&
operator|-
name|v1_mask
expr_stmt|;
name|i
operator|=
operator|(
name|v1_mask
operator|&
operator|~
name|mask
operator|)
operator|/
name|ddst_h
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|ws
operator|.
name|gen_limit
condition|)
block|{
comment|/* Punt if we would have to generate an 				 * unreasonable number of routes. 				 */
if|if
condition|(
name|TRACECONTENTS
condition|)
name|trace_misc
argument_list|(
literal|"sending %s-->%s as 1"
literal|" instead of %d routes"
argument_list|,
name|addrname
argument_list|(
name|htonl
argument_list|(
name|dst_h
argument_list|)
argument_list|,
name|mask
argument_list|,
literal|1
argument_list|)
argument_list|,
name|naddr_ntoa
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
name|v1_mask
expr_stmt|;
name|ws
operator|.
name|gen_limit
operator|-=
name|i
expr_stmt|;
block|}
block|}
block|}
do|do
block|{
name|wb
operator|->
name|n
operator|->
name|n_family
operator|=
name|RIP_AF_INET
expr_stmt|;
name|wb
operator|->
name|n
operator|->
name|n_dst
operator|=
name|htonl
argument_list|(
name|dst_h
argument_list|)
expr_stmt|;
comment|/* If the route is from router-discovery or we are 		 * shutting down, admit only a bad metric. 		 */
name|wb
operator|->
name|n
operator|->
name|n_metric
operator|=
operator|(
operator|(
name|stopint
operator|||
name|ag
operator|->
name|ag_metric
operator|<
literal|1
operator|)
condition|?
name|HOPCNT_INFINITY
else|:
name|ag
operator|->
name|ag_metric
operator|)
expr_stmt|;
name|wb
operator|->
name|n
operator|->
name|n_metric
operator|=
name|htonl
argument_list|(
name|wb
operator|->
name|n
operator|->
name|n_metric
argument_list|)
expr_stmt|;
comment|/* Any non-zero bits in the supposedly unused RIPv1 fields 		 * cause the old `routed` to ignore the route. 		 * That means the mask and so forth cannot be sent 		 * in the hybrid RIPv1/RIPv2 mode. 		 */
if|if
condition|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_RIP2_ALL
condition|)
block|{
if|if
condition|(
name|ag
operator|->
name|ag_nhop
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_QUERY
operator|)
operator|||
operator|(
name|ag
operator|->
name|ag_nhop
operator|!=
name|ws
operator|.
name|ifp
operator|->
name|int_addr
operator|&&
name|on_net
argument_list|(
name|ag
operator|->
name|ag_nhop
argument_list|,
name|ws
operator|.
name|ifp
operator|->
name|int_net
argument_list|,
name|ws
operator|.
name|ifp
operator|->
name|int_mask
argument_list|)
operator|)
operator|)
condition|)
name|wb
operator|->
name|n
operator|->
name|n_nhop
operator|=
name|ag
operator|->
name|ag_nhop
expr_stmt|;
name|wb
operator|->
name|n
operator|->
name|n_mask
operator|=
name|htonl
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|wb
operator|->
name|n
operator|->
name|n_tag
operator|=
name|ag
operator|->
name|ag_tag
expr_stmt|;
block|}
name|dst_h
operator|+=
name|ddst_h
expr_stmt|;
if|if
condition|(
operator|++
name|wb
operator|->
name|n
operator|>=
name|wb
operator|->
name|lim
condition|)
name|supply_write
argument_list|(
name|wb
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|--
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/* supply one route from the table  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|walk_supply
parameter_list|(
name|struct
name|radix_node
modifier|*
name|rn
parameter_list|,
name|struct
name|walkarg
modifier|*
name|argp
name|UNUSED
parameter_list|)
block|{
define|#
directive|define
name|RT
value|((struct rt_entry *)rn)
name|u_short
name|ags
decl_stmt|;
name|char
name|metric
decl_stmt|,
name|pref
decl_stmt|;
name|naddr
name|dst
decl_stmt|,
name|nhop
decl_stmt|;
name|struct
name|rt_spare
modifier|*
name|rts
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Do not advertise external remote interfaces or passive interfaces. 	 */
if|if
condition|(
operator|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_IF
operator|)
operator|&&
name|RT
operator|->
name|rt_ifp
operator|!=
literal|0
operator|&&
operator|(
name|RT
operator|->
name|rt_ifp
operator|->
name|int_state
operator|&
name|IS_PASSIVE
operator|)
operator|&&
operator|!
operator|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_MHOME
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If being quiet about our ability to forward, then 	 * do not say anything unless responding to a query, 	 * except about our main interface. 	 */
if|if
condition|(
operator|!
name|supplier
operator|&&
operator|!
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_QUERY
operator|)
operator|&&
operator|!
operator|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_MHOME
operator|)
condition|)
return|return
literal|0
return|;
name|dst
operator|=
name|RT
operator|->
name|rt_dst
expr_stmt|;
comment|/* do not collide with the fake default route */
if|if
condition|(
name|dst
operator|==
name|RIP_DEFAULT
operator|&&
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_DEFAULT
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_NET_SYN
condition|)
block|{
if|if
condition|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_NET_INT
condition|)
block|{
comment|/* Do not send manual synthetic network routes 			 * into the subnet. 			 */
if|if
condition|(
name|on_net
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|,
name|RT
operator|->
name|rt_mask
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Do not send automatic synthetic network routes 			 * if they are not needed because no RIPv1 listeners 			 * can hear them. 			 */
if|if
condition|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_RIP2_ALL
condition|)
return|return
literal|0
return|;
comment|/* Do not send automatic synthetic network routes to 			 * the real subnet. 			 */
if|if
condition|(
name|on_net
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|ntohl
argument_list|(
name|dst
argument_list|)
argument_list|,
name|RT
operator|->
name|rt_mask
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|nhop
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Advertise the next hop if this is not a route for one 		 * of our interfaces and the next hop is on the same 		 * network as the target. 		 * The final determination is made by supply_out(). 		 */
if|if
condition|(
operator|!
operator|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_IF
operator|)
operator|&&
name|RT
operator|->
name|rt_gate
operator|!=
name|myaddr
operator|&&
name|RT
operator|->
name|rt_gate
operator|!=
name|loopaddr
condition|)
name|nhop
operator|=
name|RT
operator|->
name|rt_gate
expr_stmt|;
else|else
name|nhop
operator|=
literal|0
expr_stmt|;
block|}
name|metric
operator|=
name|RT
operator|->
name|rt_metric
expr_stmt|;
name|ags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_MHOME
condition|)
block|{
comment|/* retain host route of multi-homed servers */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|RT_ISHOST
argument_list|(
name|RT
argument_list|)
condition|)
block|{
comment|/* We should always suppress (into existing network routes) 		 * the host routes for the local end of our point-to-point 		 * links. 		 * If we are suppressing host routes in general, then do so. 		 * Avoid advertising host routes onto their own network, 		 * where they should be handled by proxy-ARP. 		 */
if|if
condition|(
operator|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_LOCAL
operator|)
operator|||
name|ridhosts
operator|||
name|on_net
argument_list|(
name|dst
argument_list|,
name|ws
operator|.
name|to_net
argument_list|,
name|ws
operator|.
name|to_mask
argument_list|)
condition|)
name|ags
operator||=
name|AGS_SUPPRESS
expr_stmt|;
comment|/* Aggregate stray host routes into network routes if allowed. 		 * We cannot aggregate host routes into small network routes 		 * without confusing RIPv1 listeners into thinking the 		 * network routes are host routes. 		 */
if|if
condition|(
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_AG
operator|)
operator|&&
operator|!
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_RIP2_ALL
operator|)
condition|)
name|ags
operator||=
name|AGS_AGGREGATE
expr_stmt|;
block|}
else|else
block|{
comment|/* Always suppress network routes into other, existing 		 * network routes 		 */
name|ags
operator||=
name|AGS_SUPPRESS
expr_stmt|;
comment|/* Generate supernets if allowed. 		 * If we can be heard by RIPv1 systems, we will 		 * later convert back to ordinary nets. 		 * This unifies dealing with received supernets. 		 */
if|if
condition|(
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_AG
operator|)
operator|&&
operator|(
operator|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_SUBNET
operator|)
operator|||
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_SUPER_AG
operator|)
operator|)
condition|)
name|ags
operator||=
name|AGS_AGGREGATE
expr_stmt|;
block|}
comment|/* Do not send RIPv1 advertisements of subnets to other 	 * networks. If possible, multicast them by RIPv2. 	 */
if|if
condition|(
operator|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_SUBNET
operator|)
operator|&&
operator|!
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_RIP2_ALL
operator|)
operator|&&
operator|!
name|on_net
argument_list|(
name|dst
argument_list|,
name|ws
operator|.
name|to_std_net
argument_list|,
name|ws
operator|.
name|to_std_mask
argument_list|)
condition|)
name|ags
operator||=
name|AGS_RIPV2
operator||
name|AGS_AGGREGATE
expr_stmt|;
comment|/* Do not send a route back to where it came from, except in 	 * response to a query.  This is "split-horizon".  That means not 	 * advertising back to the same network	and so via the same interface. 	 * 	 * We want to suppress routes that might have been fragmented 	 * from this route by a RIPv1 router and sent back to us, and so we 	 * cannot forget this route here.  Let the split-horizon route 	 * suppress the fragmented routes and then itself be forgotten. 	 * 	 * Include the routes for both ends of point-to-point interfaces 	 * among those suppressed by split-horizon, since the other side 	 * should knows them as well as we do. 	 * 	 * Notice spare routes with the same metric that we are about to 	 * advertise, to split the horizon on redundant, inactive paths. 	 */
if|if
condition|(
name|ws
operator|.
name|ifp
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_QUERY
operator|)
operator|&&
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_TO_ON_NET
operator|)
operator|&&
operator|(
operator|!
operator|(
name|RT
operator|->
name|rt_state
operator|&
name|RS_IF
operator|)
operator|||
name|ws
operator|.
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
condition|)
block|{
for|for
control|(
name|rts
operator|=
name|RT
operator|->
name|rt_spares
operator|,
name|i
operator|=
name|NUM_SPARES
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
operator|,
name|rts
operator|++
control|)
block|{
if|if
condition|(
name|rts
operator|->
name|rts_metric
operator|>
name|metric
operator|||
name|rts
operator|->
name|rts_ifp
operator|!=
name|ws
operator|.
name|ifp
condition|)
continue|continue;
comment|/* If we do not mark the route with AGS_SPLIT_HZ here, 			 * it will be poisoned-reverse, or advertised back 			 * toward its source with an infinite metric. 			 * If we have recently advertised the route with a 			 * better metric than we now have, then we should 			 * poison-reverse the route before suppressing it for 			 * split-horizon. 			 * 			 * In almost all cases, if there is no spare for the 			 * route then it is either old and dead or a brand 			 * new route. If it is brand new, there is no need 			 * for poison-reverse. If it is old and dead, it 			 * is already poisoned. 			 */
if|if
condition|(
name|RT
operator|->
name|rt_poison_time
operator|<
name|now_expire
operator|||
name|RT
operator|->
name|rt_poison_metric
operator|>=
name|metric
operator|||
name|RT
operator|->
name|rt_spares
index|[
literal|1
index|]
operator|.
name|rts_gate
operator|==
literal|0
condition|)
block|{
name|ags
operator||=
name|AGS_SPLIT_HZ
expr_stmt|;
name|ags
operator|&=
operator|~
name|AGS_SUPPRESS
expr_stmt|;
block|}
name|metric
operator|=
name|HOPCNT_INFINITY
expr_stmt|;
break|break;
block|}
block|}
comment|/* Keep track of the best metric with which the 	 * route has been advertised recently. 	 */
if|if
condition|(
name|RT
operator|->
name|rt_poison_metric
operator|>=
name|metric
operator|||
name|RT
operator|->
name|rt_poison_time
operator|<
name|now_expire
condition|)
block|{
name|RT
operator|->
name|rt_poison_time
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|RT
operator|->
name|rt_poison_metric
operator|=
name|metric
expr_stmt|;
block|}
comment|/* Adjust the outgoing metric by the cost of the link. 	 * Avoid aggregation when a route is counting to infinity. 	 */
name|pref
operator|=
name|RT
operator|->
name|rt_poison_metric
operator|+
name|ws
operator|.
name|metric
expr_stmt|;
name|metric
operator|+=
name|ws
operator|.
name|metric
expr_stmt|;
comment|/* Do not advertise stable routes that will be ignored, 	 * unless we are answering a query. 	 * If the route recently was advertised with a metric that 	 * would have been less than infinity through this interface, 	 * we need to continue to advertise it in order to poison it. 	 */
if|if
condition|(
name|metric
operator|>=
name|HOPCNT_INFINITY
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_QUERY
operator|)
operator|&&
operator|(
name|pref
operator|>=
name|HOPCNT_INFINITY
operator|||
name|RT
operator|->
name|rt_poison_time
operator|<
name|now_garbage
operator|)
condition|)
return|return
literal|0
return|;
name|metric
operator|=
name|HOPCNT_INFINITY
expr_stmt|;
block|}
name|ag_check
argument_list|(
name|dst
argument_list|,
name|RT
operator|->
name|rt_mask
argument_list|,
literal|0
argument_list|,
name|nhop
argument_list|,
name|metric
argument_list|,
name|pref
argument_list|,
name|RT
operator|->
name|rt_seqno
argument_list|,
name|RT
operator|->
name|rt_tag
argument_list|,
name|ags
argument_list|,
name|supply_out
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|RT
block|}
end_function

begin_comment
comment|/* Supply dst with the contents of the routing tables.  * If this won't fit in one packet, chop it up into several.  */
end_comment

begin_function
name|void
name|supply
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|dst
parameter_list|,
name|struct
name|interface
modifier|*
name|ifp
parameter_list|,
comment|/* output interface */
name|enum
name|output_type
name|type
parameter_list|,
name|int
name|flash
parameter_list|,
comment|/* 1=flash update */
name|int
name|vers
parameter_list|,
comment|/* RIP version */
name|int
name|passwd_ok
parameter_list|)
comment|/* OK to include cleartext password */
block|{
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
name|int
name|def_metric
decl_stmt|;
name|ws
operator|.
name|state
operator|=
literal|0
expr_stmt|;
name|ws
operator|.
name|gen_limit
operator|=
literal|1024
expr_stmt|;
name|ws
operator|.
name|to
operator|=
operator|*
name|dst
expr_stmt|;
name|ws
operator|.
name|to_std_mask
operator|=
name|std_mask
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|ws
operator|.
name|to_std_net
operator|=
name|ntohl
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|&
name|ws
operator|.
name|to_std_mask
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
literal|0
condition|)
block|{
name|ws
operator|.
name|to_mask
operator|=
name|ifp
operator|->
name|int_mask
expr_stmt|;
name|ws
operator|.
name|to_net
operator|=
name|ifp
operator|->
name|int_net
expr_stmt|;
if|if
condition|(
name|on_net
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|ws
operator|.
name|to_net
argument_list|,
name|ws
operator|.
name|to_mask
argument_list|)
condition|)
name|ws
operator|.
name|state
operator||=
name|WS_ST_TO_ON_NET
expr_stmt|;
block|}
else|else
block|{
name|ws
operator|.
name|to_mask
operator|=
name|ripv1_mask_net
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ws
operator|.
name|to_net
operator|=
name|ntohl
argument_list|(
name|ws
operator|.
name|to
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|&
name|ws
operator|.
name|to_mask
expr_stmt|;
name|rt
operator|=
name|rtfind
argument_list|(
name|dst
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
condition|)
name|ifp
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
block|}
name|ws
operator|.
name|npackets
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flash
condition|)
name|ws
operator|.
name|state
operator||=
name|WS_ST_FLASH
expr_stmt|;
if|if
condition|(
operator|(
name|ws
operator|.
name|ifp
operator|=
name|ifp
operator|)
operator|==
literal|0
condition|)
block|{
name|ws
operator|.
name|metric
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Adjust the advertised metric by the outgoing interface 		 * metric. 		 */
name|ws
operator|.
name|metric
operator|=
name|ifp
operator|->
name|int_metric
operator|+
literal|1
expr_stmt|;
block|}
name|ripv12_buf
operator|.
name|rip
operator|.
name|rip_vers
operator|=
name|vers
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OUT_MULTICAST
case|:
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_MULTICAST
condition|)
name|v2buf
operator|.
name|type
operator|=
name|OUT_MULTICAST
expr_stmt|;
else|else
name|v2buf
operator|.
name|type
operator|=
name|NO_OUT_MULTICAST
expr_stmt|;
name|v12buf
operator|.
name|type
operator|=
name|OUT_BROADCAST
expr_stmt|;
break|break;
case|case
name|OUT_QUERY
case|:
name|ws
operator|.
name|state
operator||=
name|WS_ST_QUERY
expr_stmt|;
comment|/* fall through */
case|case
name|OUT_BROADCAST
case|:
case|case
name|OUT_UNICAST
case|:
name|v2buf
operator|.
name|type
operator|=
operator|(
name|vers
operator|==
name|RIPv2
operator|)
condition|?
name|type
else|:
name|NO_OUT_RIPV2
expr_stmt|;
name|v12buf
operator|.
name|type
operator|=
name|type
expr_stmt|;
break|break;
case|case
name|NO_OUT_MULTICAST
case|:
case|case
name|NO_OUT_RIPV2
case|:
break|break;
comment|/* no output */
block|}
if|if
condition|(
name|vers
operator|==
name|RIPv2
condition|)
block|{
comment|/* full RIPv2 only if cannot be heard by RIPv1 listeners */
if|if
condition|(
name|type
operator|!=
name|OUT_BROADCAST
condition|)
name|ws
operator|.
name|state
operator||=
name|WS_ST_RIP2_ALL
expr_stmt|;
if|if
condition|(
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_QUERY
operator|)
operator|||
operator|!
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_TO_ON_NET
operator|)
condition|)
block|{
name|ws
operator|.
name|state
operator||=
operator|(
name|WS_ST_AG
operator||
name|WS_ST_SUPER_AG
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|==
literal|0
operator|||
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_AG
operator|)
condition|)
block|{
name|ws
operator|.
name|state
operator||=
name|WS_ST_AG
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|OUT_BROADCAST
operator|&&
operator|(
name|ifp
operator|==
literal|0
operator|||
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_SUPER_AG
operator|)
operator|)
condition|)
name|ws
operator|.
name|state
operator||=
name|WS_ST_SUPER_AG
expr_stmt|;
block|}
block|}
name|ws
operator|.
name|a
operator|=
operator|(
name|vers
operator|==
name|RIPv2
operator|)
condition|?
name|find_auth
argument_list|(
name|ifp
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|passwd_ok
operator|&&
name|ws
operator|.
name|a
operator|!=
literal|0
operator|&&
name|ws
operator|.
name|a
operator|->
name|type
operator|==
name|RIP_AUTH_PW
condition|)
name|ws
operator|.
name|a
operator|=
literal|0
expr_stmt|;
name|clr_ws_buf
argument_list|(
operator|&
name|v12buf
argument_list|,
name|ws
operator|.
name|a
argument_list|)
expr_stmt|;
name|clr_ws_buf
argument_list|(
operator|&
name|v2buf
argument_list|,
name|ws
operator|.
name|a
argument_list|)
expr_stmt|;
comment|/*  Fake a default route if asked and if there is not already 	 * a better, real default route. 	 */
if|if
condition|(
name|supplier
operator|&&
operator|(
name|def_metric
operator|=
name|ifp
operator|->
name|int_d_metric
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
literal|0
operator|==
operator|(
name|rt
operator|=
name|rtget
argument_list|(
name|RIP_DEFAULT
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
name|rt
operator|->
name|rt_metric
operator|+
name|ws
operator|.
name|metric
operator|>=
name|def_metric
condition|)
block|{
name|ws
operator|.
name|state
operator||=
name|WS_ST_DEFAULT
expr_stmt|;
name|ag_check
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|def_metric
argument_list|,
name|def_metric
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|supply_out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|def_metric
operator|=
name|rt
operator|->
name|rt_metric
operator|+
name|ws
operator|.
name|metric
expr_stmt|;
block|}
comment|/* If both RIPv2 and the poor-man's router discovery 		 * kludge are on, arrange to advertise an extra 		 * default route via RIPv1. 		 */
if|if
condition|(
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_RIP2_ALL
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_PM_RDISC
operator|)
condition|)
block|{
name|ripv12_buf
operator|.
name|rip
operator|.
name|rip_vers
operator|=
name|RIPv1
expr_stmt|;
name|v12buf
operator|.
name|n
operator|->
name|n_family
operator|=
name|RIP_AF_INET
expr_stmt|;
name|v12buf
operator|.
name|n
operator|->
name|n_dst
operator|=
name|htonl
argument_list|(
name|RIP_DEFAULT
argument_list|)
expr_stmt|;
name|v12buf
operator|.
name|n
operator|->
name|n_metric
operator|=
name|htonl
argument_list|(
name|def_metric
argument_list|)
expr_stmt|;
name|v12buf
operator|.
name|n
operator|++
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|rn_walktree
argument_list|(
name|rhead
argument_list|,
name|walk_supply
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ag_flush
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|supply_out
argument_list|)
expr_stmt|;
comment|/* Flush the packet buffers, provided they are not empty and 	 * do not contain only the password. 	 */
if|if
condition|(
name|v12buf
operator|.
name|n
operator|!=
name|v12buf
operator|.
name|base
operator|&&
operator|(
name|v12buf
operator|.
name|n
operator|>
name|v12buf
operator|.
name|base
operator|+
literal|1
operator|||
name|v12buf
operator|.
name|base
operator|->
name|n_family
operator|!=
name|RIP_AF_AUTH
operator|)
condition|)
name|supply_write
argument_list|(
operator|&
name|v12buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|v2buf
operator|.
name|n
operator|!=
name|v2buf
operator|.
name|base
operator|&&
operator|(
name|v2buf
operator|.
name|n
operator|>
name|v2buf
operator|.
name|base
operator|+
literal|1
operator|||
name|v2buf
operator|.
name|base
operator|->
name|n_family
operator|!=
name|RIP_AF_AUTH
operator|)
condition|)
name|supply_write
argument_list|(
operator|&
name|v2buf
argument_list|)
expr_stmt|;
comment|/* If we sent nothing and this is an answer to a query, send 	 * an empty buffer. 	 */
if|if
condition|(
name|ws
operator|.
name|npackets
operator|==
literal|0
operator|&&
operator|(
name|ws
operator|.
name|state
operator|&
name|WS_ST_QUERY
operator|)
condition|)
name|supply_write
argument_list|(
operator|&
name|v12buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* send all of the routing table or just do a flash update  */
end_comment

begin_function
name|void
name|rip_bcast
parameter_list|(
name|int
name|flash
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_HAVE_SIN_LEN
specifier|static
name|struct
name|sockaddr_in
name|dst
init|=
block|{
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
block|,
name|AF_INET
block|,
literal|0
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
else|#
directive|else
specifier|static
name|struct
name|sockaddr_in
name|dst
init|=
block|{
name|AF_INET
block|}
decl_stmt|;
endif|#
directive|endif
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|enum
name|output_type
name|type
decl_stmt|;
name|int
name|vers
decl_stmt|;
name|struct
name|timeval
name|rtime
decl_stmt|;
name|need_flash
operator|=
literal|0
expr_stmt|;
name|intvl_random
argument_list|(
operator|&
name|rtime
argument_list|,
name|MIN_WAITTIME
argument_list|,
name|MAX_WAITTIME
argument_list|)
expr_stmt|;
name|no_flash
operator|=
name|rtime
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|no_flash
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|rip_sock
operator|<
literal|0
condition|)
return|return;
name|trace_act
argument_list|(
literal|"send %s and inhibit dynamic updates for %.3f sec"
argument_list|,
name|flash
condition|?
literal|"dynamic update"
else|:
literal|"all routes"
argument_list|,
name|rtime
operator|.
name|tv_sec
operator|+
operator|(
operator|(
name|float
operator|)
name|rtime
operator|.
name|tv_usec
operator|)
operator|/
literal|1000000.0
argument_list|)
expr_stmt|;
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
operator|!=
literal|0
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
comment|/* Skip interfaces not doing RIP. 		 * Do try broken interfaces to see if they have healed. 		 */
if|if
condition|(
name|IS_RIP_OUT_OFF
argument_list|(
name|ifp
operator|->
name|int_state
argument_list|)
condition|)
continue|continue;
comment|/* skip turned off interfaces */
if|if
condition|(
operator|!
name|iff_up
argument_list|(
name|ifp
operator|->
name|int_if_flags
argument_list|)
condition|)
continue|continue;
name|vers
operator|=
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV1_OUT
operator|)
condition|?
name|RIPv2
else|:
name|RIPv1
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_BROADCAST
condition|)
block|{
comment|/* ordinary, hardware interface */
name|dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifp
operator|->
name|int_brdaddr
expr_stmt|;
if|if
condition|(
name|vers
operator|==
name|RIPv2
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RIP_MCAST
operator|)
condition|)
block|{
name|type
operator|=
name|OUT_MULTICAST
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|OUT_BROADCAST
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
comment|/* point-to-point hardware interface */
name|dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifp
operator|->
name|int_dstaddr
expr_stmt|;
name|type
operator|=
name|OUT_UNICAST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
condition|)
block|{
comment|/* remote interface */
name|dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifp
operator|->
name|int_addr
expr_stmt|;
name|type
operator|=
name|OUT_UNICAST
expr_stmt|;
block|}
else|else
block|{
comment|/* ATM, HIPPI, etc. */
continue|continue;
block|}
name|supply
argument_list|(
operator|&
name|dst
argument_list|,
name|ifp
argument_list|,
name|type
argument_list|,
name|flash
argument_list|,
name|vers
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|update_seqno
operator|++
expr_stmt|;
comment|/* all routes are up to date */
block|}
end_function

begin_comment
comment|/* Ask for routes  * Do it only once to an interface, and not even after the interface  * was broken and recovered.  */
end_comment

begin_function
name|void
name|rip_query
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_HAVE_SIN_LEN
specifier|static
name|struct
name|sockaddr_in
name|dst
init|=
block|{
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
block|,
name|AF_INET
block|,
literal|0
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
else|#
directive|else
specifier|static
name|struct
name|sockaddr_in
name|dst
init|=
block|{
name|AF_INET
block|}
decl_stmt|;
endif|#
directive|endif
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|struct
name|rip
name|buf
decl_stmt|;
name|enum
name|output_type
name|type
decl_stmt|;
if|if
condition|(
name|rip_sock
operator|<
literal|0
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
comment|/* Skip interfaces those already queried. 		 * Do not ask via interfaces through which we don't 		 * accept input.  Do not ask via interfaces that cannot 		 * send RIP packets. 		 * Do try broken interfaces to see if they have healed. 		 */
if|if
condition|(
name|IS_RIP_IN_OFF
argument_list|(
name|ifp
operator|->
name|int_state
argument_list|)
operator|||
name|ifp
operator|->
name|int_query_time
operator|!=
name|NEVER
condition|)
continue|continue;
comment|/* skip turned off interfaces */
if|if
condition|(
operator|!
name|iff_up
argument_list|(
name|ifp
operator|->
name|int_if_flags
argument_list|)
condition|)
continue|continue;
name|buf
operator|.
name|rip_vers
operator|=
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV1_OUT
operator|)
condition|?
name|RIPv2
else|:
name|RIPv1
expr_stmt|;
name|buf
operator|.
name|rip_cmd
operator|=
name|RIPCMD_REQUEST
expr_stmt|;
name|buf
operator|.
name|rip_nets
index|[
literal|0
index|]
operator|.
name|n_family
operator|=
name|RIP_AF_UNSPEC
expr_stmt|;
name|buf
operator|.
name|rip_nets
index|[
literal|0
index|]
operator|.
name|n_metric
operator|=
name|htonl
argument_list|(
name|HOPCNT_INFINITY
argument_list|)
expr_stmt|;
comment|/* Send a RIPv1 query only if allowed and if we will 		 * listen to RIPv1 routers. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV1_OUT
operator|)
operator|||
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RIPV1_IN
operator|)
condition|)
block|{
name|buf
operator|.
name|rip_vers
operator|=
name|RIPv2
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|rip_vers
operator|=
name|RIPv1
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_BROADCAST
condition|)
block|{
comment|/* ordinary, hardware interface */
name|dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifp
operator|->
name|int_brdaddr
expr_stmt|;
comment|/* Broadcast RIPv1 queries and RIPv2 queries 			 * when the hardware cannot multicast. 			 */
if|if
condition|(
name|buf
operator|.
name|rip_vers
operator|==
name|RIPv2
operator|&&
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_NO_RIP_MCAST
operator|)
condition|)
block|{
name|type
operator|=
name|OUT_MULTICAST
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|OUT_BROADCAST
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
block|{
comment|/* point-to-point hardware interface */
name|dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifp
operator|->
name|int_dstaddr
expr_stmt|;
name|type
operator|=
name|OUT_UNICAST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
condition|)
block|{
comment|/* remote interface */
name|dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ifp
operator|->
name|int_addr
expr_stmt|;
name|type
operator|=
name|OUT_UNICAST
expr_stmt|;
block|}
else|else
block|{
comment|/* ATM, HIPPI, etc. */
continue|continue;
block|}
name|ifp
operator|->
name|int_query_time
operator|=
name|now
operator|.
name|tv_sec
operator|+
name|SUPPLY_INTERVAL
expr_stmt|;
if|if
condition|(
name|output
argument_list|(
name|type
argument_list|,
operator|&
name|dst
argument_list|,
name|ifp
argument_list|,
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|if_sick
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

