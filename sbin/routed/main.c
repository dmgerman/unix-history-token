begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sgi
end_ifdef

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1983, 1988, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
literal|"@(#)main.c	8.1 (Berkeley) 6/5/93"
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_elif

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__COPYRIGHT
argument_list|(
literal|"@(#) Copyright (c) 1983, 1988, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_empty
empty|#ident "$FreeBSD$"
end_empty

begin_decl_stmt
name|pid_t
name|mypid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|naddr
name|myaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system address */
end_comment

begin_decl_stmt
name|char
name|myname
index|[
name|MAXHOSTNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|supplier
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* supply or broadcast updates */
end_comment

begin_decl_stmt
name|int
name|supplier_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipforwarding
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* kernel forwarding on */
end_comment

begin_decl_stmt
name|int
name|default_gateway
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1=advertise default */
end_comment

begin_decl_stmt
name|int
name|background
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ridhosts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1=reduce host routes */
end_comment

begin_decl_stmt
name|int
name|mhome
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1=want multi-homed host route */
end_comment

begin_decl_stmt
name|int
name|advertise_mhome
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1=must continue advertising it */
end_comment

begin_decl_stmt
name|int
name|auth_ok
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1=ignore auth if we do not care */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|epoch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* when started */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|clk
decl_stmt|,
name|prev_clk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usec_fudge
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|now
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current idea of time */
end_comment

begin_decl_stmt
name|time_t
name|now_stale
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|now_expire
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|now_garbage
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|next_bcast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next general broadcast */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|no_flash
init|=
block|{
comment|/* inhibit flash update */
name|EPOCH
operator|+
name|SUPPLY_INTERVAL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|flush_kern_timer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|fd_set
name|fdbits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sock_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rip_sock
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RIP socket */
end_comment

begin_decl_stmt
name|struct
name|interface
modifier|*
name|rip_sock_mcast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current multicast interface */
end_comment

begin_decl_stmt
name|int
name|rt_sock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* routing socket */
end_comment

begin_decl_stmt
name|int
name|rt_sock_seqno
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|get_rip_sock
parameter_list|(
name|naddr
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|timevalsub
parameter_list|(
name|struct
name|timeval
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|mib
index|[
literal|4
index|]
decl_stmt|,
name|off
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|timeval
name|wtime
decl_stmt|,
name|t2
decl_stmt|;
name|time_t
name|dt
decl_stmt|;
name|fd_set
name|ibits
decl_stmt|;
name|naddr
name|p_net
decl_stmt|,
name|p_mask
decl_stmt|;
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|struct
name|parm
name|parm
decl_stmt|;
name|char
modifier|*
name|tracename
init|=
literal|0
decl_stmt|;
comment|/* Some shells are badly broken and send SIGHUP to backgrounded 	 * processes. 	 */
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|openlog
argument_list|(
literal|"routed"
argument_list|,
name|LOG_PID
operator||
name|LOG_ODELAY
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
name|ftrace
operator|=
name|stdout
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|clk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prev_clk
operator|=
name|clk
expr_stmt|;
name|epoch
operator|=
name|clk
expr_stmt|;
name|epoch
operator|.
name|tv_sec
operator|-=
name|EPOCH
expr_stmt|;
name|now
operator|.
name|tv_sec
operator|=
name|EPOCH
expr_stmt|;
name|now_stale
operator|=
name|EPOCH
operator|-
name|STALE_TIME
expr_stmt|;
name|now_expire
operator|=
name|EPOCH
operator|-
name|EXPIRE_TIME
expr_stmt|;
name|now_garbage
operator|=
name|EPOCH
operator|-
name|GARBAGE_TIME
expr_stmt|;
name|wtime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|gethostname
argument_list|(
name|myname
argument_list|,
sizeof|sizeof
argument_list|(
name|myname
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gethost
argument_list|(
name|myname
argument_list|,
operator|&
name|myaddr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"sqdghmpAtvT:F:P:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|'s'
case|:
name|supplier
operator|=
literal|1
expr_stmt|;
name|supplier_set
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|supplier
operator|=
literal|0
expr_stmt|;
name|supplier_set
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|background
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|memset
argument_list|(
operator|&
name|parm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|parm
operator|.
name|parm_d_metric
operator|=
literal|1
expr_stmt|;
name|cp
operator|=
name|check_parms
argument_list|(
operator|&
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
literal|0
condition|)
name|msglog
argument_list|(
literal|"bad -g: %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|default_gateway
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* suppress extra host routes */
name|ridhosts
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* advertise host route */
name|mhome
operator|=
literal|1
expr_stmt|;
comment|/* on multi-homed hosts */
break|break;
case|case
literal|'A'
case|:
comment|/* Ignore authentication if we do not care. 			 * Crazy as it is, that is what RFC 1723 requires. 			 */
name|auth_ok
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|new_tracelevel
operator|++
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|tracename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* minimal routes for SLIP */
name|n
operator|=
name|FAKE_METRIC
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|n
operator|=
operator|(
name|int
operator|)
name|strtoul
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
operator|&&
name|n
operator|<=
name|HOPCNT_INFINITY
operator|-
literal|1
operator|&&
name|n
operator|>=
literal|1
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getnet
argument_list|(
name|optarg
argument_list|,
operator|&
name|p_net
argument_list|,
operator|&
name|p_mask
argument_list|)
condition|)
block|{
name|msglog
argument_list|(
literal|"bad network; \"-F %s\""
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
name|memset
argument_list|(
operator|&
name|parm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|parm
operator|.
name|parm_net
operator|=
name|p_net
expr_stmt|;
name|parm
operator|.
name|parm_mask
operator|=
name|p_mask
expr_stmt|;
name|parm
operator|.
name|parm_d_metric
operator|=
name|n
expr_stmt|;
name|cp
operator|=
name|check_parms
argument_list|(
operator|&
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
literal|0
condition|)
name|msglog
argument_list|(
literal|"bad -F: %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* handle arbitrary parameters. 			 */
name|q
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|cp
operator|=
name|parse_parms
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
literal|0
condition|)
name|msglog
argument_list|(
literal|"%s in \"-P %s\""
argument_list|,
name|cp
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* display version */
name|verbose
operator|++
expr_stmt|;
name|msglog
argument_list|(
literal|"version 2.22"
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|usage
goto|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|tracename
operator|==
literal|0
operator|&&
name|argc
operator|>=
literal|1
condition|)
block|{
name|tracename
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|tracename
operator|!=
literal|0
operator|&&
name|tracename
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
goto|goto
name|usage
goto|;
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
name|usage
label|:
name|logbad
argument_list|(
literal|0
argument_list|,
literal|"usage: routed [-sqdghmpAtv] [-T tracefile]"
literal|" [-F net[,metric]] [-P parms]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|logbad
argument_list|(
literal|0
argument_list|,
literal|"requires UID 0"
argument_list|)
expr_stmt|;
block|}
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_NET
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|PF_INET
expr_stmt|;
name|mib
index|[
literal|2
index|]
operator|=
name|IPPROTO_IP
expr_stmt|;
name|mib
index|[
literal|3
index|]
operator|=
name|IPCTL_FORWARDING
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ipforwarding
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|4
argument_list|,
operator|&
name|ipforwarding
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|LOGERR
argument_list|(
literal|"sysctl(IPCTL_FORWARDING)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ipforwarding
condition|)
block|{
if|if
condition|(
name|supplier
condition|)
name|msglog
argument_list|(
literal|"-s incompatible with ipforwarding=0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_gateway
condition|)
block|{
name|msglog
argument_list|(
literal|"-g incompatible with ipforwarding=0"
argument_list|)
expr_stmt|;
name|default_gateway
operator|=
literal|0
expr_stmt|;
block|}
name|supplier
operator|=
literal|0
expr_stmt|;
name|supplier_set
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|default_gateway
condition|)
block|{
if|if
condition|(
name|supplier_set
operator|&&
operator|!
name|supplier
condition|)
block|{
name|msglog
argument_list|(
literal|"-g and -q incompatible"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|supplier
operator|=
literal|1
expr_stmt|;
name|supplier_set
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|sigalrm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|background
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|sigterm
argument_list|)
expr_stmt|;
comment|/* SIGHUP fatal during debugging */
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sigterm
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigterm
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|sigtrace_on
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|sigtrace_off
argument_list|)
expr_stmt|;
comment|/* get into the background */
ifdef|#
directive|ifdef
name|sgi
if|if
condition|(
literal|0
operator|>
name|_daemonize
argument_list|(
name|background
condition|?
literal|0
else|:
operator|(
name|_DF_NOCHDIR
operator||
name|_DF_NOFORK
operator|)
argument_list|,
name|STDIN_FILENO
argument_list|,
name|STDOUT_FILENO
argument_list|,
name|STDERR_FILENO
argument_list|)
condition|)
name|BADERR
argument_list|(
literal|0
argument_list|,
literal|"_daemonize()"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|background
operator|&&
name|daemon
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|BADERR
argument_list|(
literal|0
argument_list|,
literal|"daemon()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mypid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|srandom
argument_list|(
call|(
name|int
call|)
argument_list|(
name|clk
operator|.
name|tv_sec
operator|^
name|clk
operator|.
name|tv_usec
operator|^
name|mypid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* prepare socket connected to the kernel. 	 */
name|rt_sock
operator|=
name|socket
argument_list|(
name|AF_ROUTE
argument_list|,
name|SOCK_RAW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt_sock
operator|<
literal|0
condition|)
name|BADERR
argument_list|(
literal|1
argument_list|,
literal|"rt_sock = socket()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|rt_sock
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|logbad
argument_list|(
literal|1
argument_list|,
literal|"fcntl(rt_sock) O_NONBLOCK: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|rt_sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_USELOOPBACK
argument_list|,
operator|&
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|LOGERR
argument_list|(
literal|"setsockopt(SO_USELOOPBACK,0)"
argument_list|)
expr_stmt|;
name|fix_select
argument_list|()
expr_stmt|;
if|if
condition|(
name|tracename
operator|!=
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|inittracename
argument_list|,
name|tracename
argument_list|,
sizeof|sizeof
argument_list|(
name|inittracename
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|set_tracefile
argument_list|(
name|inittracename
argument_list|,
literal|"%s"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tracelevel_msg
argument_list|(
literal|"%s"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* turn on tracing to stdio */
block|}
name|bufinit
argument_list|()
expr_stmt|;
comment|/* initialize radix tree */
name|rtinit
argument_list|()
expr_stmt|;
comment|/* Pick a random part of the second for our output to minimize 	 * collisions. 	 * 	 * Start broadcasting after hearing from other routers, and 	 * at a random time so a bunch of systems do not get synchronized 	 * after a power failure. 	 */
name|intvl_random
argument_list|(
operator|&
name|next_bcast
argument_list|,
name|EPOCH
operator|+
name|MIN_WAITTIME
argument_list|,
name|EPOCH
operator|+
name|SUPPLY_INTERVAL
argument_list|)
expr_stmt|;
name|age_timer
operator|.
name|tv_usec
operator|=
name|next_bcast
operator|.
name|tv_usec
expr_stmt|;
name|age_timer
operator|.
name|tv_sec
operator|=
name|EPOCH
operator|+
name|MIN_WAITTIME
expr_stmt|;
name|rdisc_timer
operator|=
name|next_bcast
expr_stmt|;
name|ifinit_timer
operator|.
name|tv_usec
operator|=
name|next_bcast
operator|.
name|tv_usec
expr_stmt|;
comment|/* Collect an initial view of the world by checking the interface 	 * configuration and the kludge file. 	 */
name|gwkludge
argument_list|()
expr_stmt|;
name|ifinit
argument_list|()
expr_stmt|;
comment|/* Ask for routes */
name|rip_query
argument_list|()
expr_stmt|;
name|rdisc_sol
argument_list|()
expr_stmt|;
comment|/* Now turn off stdio if not tracing */
if|if
condition|(
name|new_tracelevel
operator|==
literal|0
condition|)
name|trace_close
argument_list|(
name|background
argument_list|)
expr_stmt|;
comment|/* Loop forever, listening and broadcasting. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|prev_clk
operator|=
name|clk
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|clk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_clk
operator|.
name|tv_sec
operator|==
name|clk
operator|.
name|tv_sec
operator|&&
name|prev_clk
operator|.
name|tv_usec
operator|==
name|clk
operator|.
name|tv_usec
operator|+
name|usec_fudge
condition|)
block|{
comment|/* Much of `routed` depends on time always advancing. 			 * On systems that do not guarantee that gettimeofday() 			 * produces unique timestamps even if called within 			 * a single tick, use trickery like that in classic 			 * BSD kernels. 			 */
name|clk
operator|.
name|tv_usec
operator|+=
operator|++
name|usec_fudge
expr_stmt|;
block|}
else|else
block|{
name|usec_fudge
operator|=
literal|0
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|clk
argument_list|,
operator|&
name|prev_clk
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|t2
operator|.
name|tv_sec
operator|>
name|wtime
operator|.
name|tv_sec
operator|+
literal|5
condition|)
block|{
comment|/* Deal with time changes before other 				 * housekeeping to keep everything straight. 				 */
name|dt
operator|=
name|t2
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|dt
operator|>
literal|0
condition|)
name|dt
operator|-=
name|wtime
operator|.
name|tv_sec
expr_stmt|;
name|trace_act
argument_list|(
literal|"time changed by %d sec"
argument_list|,
operator|(
name|int
operator|)
name|dt
argument_list|)
expr_stmt|;
name|epoch
operator|.
name|tv_sec
operator|+=
name|dt
expr_stmt|;
block|}
block|}
name|timevalsub
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|clk
argument_list|,
operator|&
name|epoch
argument_list|)
expr_stmt|;
name|now_stale
operator|=
name|now
operator|.
name|tv_sec
operator|-
name|STALE_TIME
expr_stmt|;
name|now_expire
operator|=
name|now
operator|.
name|tv_sec
operator|-
name|EXPIRE_TIME
expr_stmt|;
name|now_garbage
operator|=
name|now
operator|.
name|tv_sec
operator|-
name|GARBAGE_TIME
expr_stmt|;
comment|/* deal with signals that should affect tracing */
name|set_tracelevel
argument_list|()
expr_stmt|;
if|if
condition|(
name|stopint
operator|!=
literal|0
condition|)
block|{
name|rip_bcast
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rdisc_adv
argument_list|()
expr_stmt|;
name|trace_off
argument_list|(
literal|"exiting with signal %d"
argument_list|,
name|stopint
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|stopint
operator||
literal|128
argument_list|)
expr_stmt|;
block|}
comment|/* look for new or dead interfaces */
name|timevalsub
argument_list|(
operator|&
name|wtime
argument_list|,
operator|&
name|ifinit_timer
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|wtime
operator|.
name|tv_sec
operator|<=
literal|0
condition|)
block|{
name|wtime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|ifinit
argument_list|()
expr_stmt|;
name|rip_query
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* Check the kernel table occassionally for mysteriously 		 * evaporated routes 		 */
name|timevalsub
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|flush_kern_timer
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|.
name|tv_sec
operator|<=
literal|0
condition|)
block|{
name|flush_kern
argument_list|()
expr_stmt|;
name|flush_kern_timer
operator|.
name|tv_sec
operator|=
operator|(
name|now
operator|.
name|tv_sec
operator|+
name|CHECK_QUIET_INTERVAL
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|wtime
argument_list|,
operator|<
argument_list|)
condition|)
name|wtime
operator|=
name|t2
expr_stmt|;
comment|/* If it is time, then broadcast our routes. 		 */
if|if
condition|(
name|supplier
operator|||
name|advertise_mhome
condition|)
block|{
name|timevalsub
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|next_bcast
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|.
name|tv_sec
operator|<=
literal|0
condition|)
block|{
comment|/* Synchronize the aging and broadcast 				 * timers to minimize awakenings 				 */
name|age
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rip_bcast
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* It is desirable to send routing updates 				 * regularly.  So schedule the next update 				 * 30 seconds after the previous one was 				 * scheduled, instead of 30 seconds after 				 * the previous update was finished. 				 * Even if we just started after discovering 				 * a 2nd interface or were otherwise delayed, 				 * pick a 30-second aniversary of the 				 * original broadcast time. 				 */
name|n
operator|=
literal|1
operator|+
operator|(
literal|0
operator|-
name|t2
operator|.
name|tv_sec
operator|)
operator|/
name|SUPPLY_INTERVAL
expr_stmt|;
name|next_bcast
operator|.
name|tv_sec
operator|+=
name|n
operator|*
name|SUPPLY_INTERVAL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|wtime
argument_list|,
operator|<
argument_list|)
condition|)
name|wtime
operator|=
name|t2
expr_stmt|;
block|}
comment|/* If we need a flash update, either do it now or 		 * set the delay to end when it is time. 		 * 		 * If we are within MIN_WAITTIME seconds of a full update, 		 * do not bother. 		 */
if|if
condition|(
name|need_flash
operator|&&
name|supplier
operator|&&
name|no_flash
operator|.
name|tv_sec
operator|+
name|MIN_WAITTIME
operator|<
name|next_bcast
operator|.
name|tv_sec
condition|)
block|{
comment|/* accurate to the millisecond */
if|if
condition|(
operator|!
name|timercmp
argument_list|(
operator|&
name|no_flash
argument_list|,
operator|&
name|now
argument_list|,
operator|>
argument_list|)
condition|)
name|rip_bcast
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|no_flash
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|wtime
argument_list|,
operator|<
argument_list|)
condition|)
name|wtime
operator|=
name|t2
expr_stmt|;
block|}
comment|/* trigger the main aging timer. 		 */
name|timevalsub
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|age_timer
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|.
name|tv_sec
operator|<=
literal|0
condition|)
block|{
name|age
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|wtime
argument_list|,
operator|<
argument_list|)
condition|)
name|wtime
operator|=
name|t2
expr_stmt|;
comment|/* update the kernel routing table 		 */
name|timevalsub
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|need_kern
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|.
name|tv_sec
operator|<=
literal|0
condition|)
block|{
name|age
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|wtime
argument_list|,
operator|<
argument_list|)
condition|)
name|wtime
operator|=
name|t2
expr_stmt|;
comment|/* take care of router discovery, 		 * but do it in the correct the millisecond 		 */
if|if
condition|(
operator|!
name|timercmp
argument_list|(
operator|&
name|rdisc_timer
argument_list|,
operator|&
name|now
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|rdisc_age
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|timevalsub
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|rdisc_timer
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|wtime
argument_list|,
operator|<
argument_list|)
condition|)
name|wtime
operator|=
name|t2
expr_stmt|;
comment|/* wait for input or a timer to expire. 		 */
name|trace_flush
argument_list|()
expr_stmt|;
name|ibits
operator|=
name|fdbits
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|sock_max
argument_list|,
operator|&
name|ibits
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|wtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
operator|&&
name|errno
operator|!=
name|EAGAIN
condition|)
name|BADERR
argument_list|(
literal|1
argument_list|,
literal|"select"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|rt_sock
argument_list|,
operator|&
name|ibits
argument_list|)
condition|)
block|{
name|read_rt
argument_list|()
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|rdisc_sock
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|rdisc_sock
argument_list|,
operator|&
name|ibits
argument_list|)
condition|)
block|{
name|read_d
argument_list|()
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|rip_sock
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|rip_sock
argument_list|,
operator|&
name|ibits
argument_list|)
condition|)
block|{
name|read_rip
argument_list|(
name|rip_sock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|n
operator|>
literal|0
operator|&&
literal|0
operator|!=
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_rip_sock
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|ifp
operator|->
name|int_rip_sock
argument_list|,
operator|&
name|ibits
argument_list|)
condition|)
block|{
name|read_rip
argument_list|(
name|ifp
operator|->
name|int_rip_sock
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|sigalrm
parameter_list|(
name|int
name|s
name|UNUSED
parameter_list|)
block|{
comment|/* Historically, SIGALRM would cause the daemon to check for 	 * new and broken interfaces. 	 */
name|ifinit_timer
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|trace_act
argument_list|(
literal|"SIGALRM"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* watch for fatal signals */
end_comment

begin_function
name|void
name|sigterm
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|stopint
operator|=
name|sig
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* catch it only once */
block|}
end_function

begin_function
name|void
name|fix_select
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdbits
argument_list|)
expr_stmt|;
name|sock_max
operator|=
literal|0
expr_stmt|;
name|FD_SET
argument_list|(
name|rt_sock
argument_list|,
operator|&
name|fdbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_max
operator|<=
name|rt_sock
condition|)
name|sock_max
operator|=
name|rt_sock
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|rip_sock
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|rip_sock
argument_list|,
operator|&
name|fdbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_max
operator|<=
name|rip_sock
condition|)
name|sock_max
operator|=
name|rip_sock
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
literal|0
operator|!=
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_rip_sock
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|ifp
operator|->
name|int_rip_sock
argument_list|,
operator|&
name|fdbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_max
operator|<=
name|ifp
operator|->
name|int_rip_sock
condition|)
name|sock_max
operator|=
name|ifp
operator|->
name|int_rip_sock
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rdisc_sock
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|rdisc_sock
argument_list|,
operator|&
name|fdbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_max
operator|<=
name|rdisc_sock
condition|)
name|sock_max
operator|=
name|rdisc_sock
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|fix_sock
parameter_list|(
name|int
name|sock
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|on
decl_stmt|;
define|#
directive|define
name|MIN_SOCKBUF
value|(4*1024)
specifier|static
name|int
name|rbuf
decl_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|sock
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|logbad
argument_list|(
literal|1
argument_list|,
literal|"fcntl(%s) O_NONBLOCK: %s"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|on
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|msglog
argument_list|(
literal|"setsockopt(%s,SO_BROADCAST): %s"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_PASSIFNAME
name|on
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_PASSIFNAME
argument_list|,
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|msglog
argument_list|(
literal|"setsockopt(%s,SO_PASSIFNAME): %s"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rbuf
operator|>=
name|MIN_SOCKBUF
condition|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|&
name|rbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|msglog
argument_list|(
literal|"setsockopt(%s,SO_RCVBUF=%d): %s"
argument_list|,
name|name
argument_list|,
name|rbuf
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|rbuf
operator|=
literal|60
operator|*
literal|1024
init|;
condition|;
name|rbuf
operator|-=
literal|4096
control|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|&
name|rbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|trace_act
argument_list|(
literal|"RCVBUF=%d"
argument_list|,
name|rbuf
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rbuf
operator|<
name|MIN_SOCKBUF
condition|)
block|{
name|msglog
argument_list|(
literal|"setsockopt(%s,SO_RCVBUF = %d): %s"
argument_list|,
name|name
argument_list|,
name|rbuf
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* get a rip socket  */
end_comment

begin_function
specifier|static
name|int
comment|/*<0 or file descriptor */
name|get_rip_sock
parameter_list|(
name|naddr
name|addr
parameter_list|,
name|int
name|serious
parameter_list|)
comment|/* 1=failure to bind is serious */
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|unsigned
name|char
name|ttl
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|BADERR
argument_list|(
literal|1
argument_list|,
literal|"rip_sock = socket()"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_HAVE_SIN_LEN
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|RIP_PORT
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|serious
condition|)
name|BADERR
argument_list|(
name|errno
operator|!=
name|EADDRINUSE
argument_list|,
literal|"bind(rip_sock)"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fix_sock
argument_list|(
name|s
argument_list|,
literal|"rip_sock"
argument_list|)
expr_stmt|;
name|ttl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_TTL
argument_list|,
operator|&
name|ttl
argument_list|,
sizeof|sizeof
argument_list|(
name|ttl
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|DBGERR
argument_list|(
literal|1
argument_list|,
literal|"rip_sock setsockopt(IP_MULTICAST_TTL)"
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* turn off main RIP socket */
end_comment

begin_function
name|void
name|rip_off
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|naddr
name|addr
decl_stmt|;
if|if
condition|(
name|rip_sock
operator|>=
literal|0
operator|&&
operator|!
name|mhome
condition|)
block|{
name|trace_act
argument_list|(
literal|"turn off RIP"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rip_sock
argument_list|)
expr_stmt|;
name|rip_sock
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* get non-broadcast sockets to listen to queries. 		 */
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
operator|!=
literal|0
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
condition|)
continue|continue;
if|if
condition|(
name|ifp
operator|->
name|int_rip_sock
operator|<
literal|0
condition|)
block|{
name|addr
operator|=
operator|(
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
condition|?
name|ifp
operator|->
name|int_dstaddr
else|:
name|ifp
operator|->
name|int_addr
operator|)
expr_stmt|;
name|ifp
operator|->
name|int_rip_sock
operator|=
name|get_rip_sock
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|fix_select
argument_list|()
expr_stmt|;
name|age
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* turn on RIP multicast input via an interface  */
end_comment

begin_function
specifier|static
name|void
name|rip_mcast_on
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ip_mreq
name|m
decl_stmt|;
if|if
condition|(
operator|!
name|IS_RIP_IN_OFF
argument_list|(
name|ifp
operator|->
name|int_state
argument_list|)
operator|&&
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_MULTICAST
operator|)
ifdef|#
directive|ifdef
name|MCAST_PPP_BUG
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
endif|#
directive|endif
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_ALIAS
operator|)
condition|)
block|{
name|m
operator|.
name|imr_multiaddr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_RIP_GROUP
argument_list|)
expr_stmt|;
name|m
operator|.
name|imr_interface
operator|.
name|s_addr
operator|=
operator|(
operator|(
name|ifp
operator|->
name|int_if_flags
operator|&
name|IFF_POINTOPOINT
operator|)
condition|?
name|ifp
operator|->
name|int_dstaddr
else|:
name|ifp
operator|->
name|int_addr
operator|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|rip_sock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_ADD_MEMBERSHIP
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|LOGERR
argument_list|(
literal|"setsockopt(IP_ADD_MEMBERSHIP RIP)"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prepare socket used for RIP.  */
end_comment

begin_function
name|void
name|rip_on
parameter_list|(
name|struct
name|interface
modifier|*
name|ifp
parameter_list|)
block|{
comment|/* If the main RIP socket is already alive, only start receiving 	 * multicasts for this interface. 	 */
if|if
condition|(
name|rip_sock
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ifp
operator|!=
literal|0
condition|)
name|rip_mcast_on
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the main RIP socket is off and it makes sense to turn it on, 	 * then turn it on for all of the interfaces. 	 * It makes sense if either router discovery is off, or if 	 * router discover is on and at most one interface is doing RIP. 	 */
if|if
condition|(
name|rip_interfaces
operator|>
literal|0
operator|&&
operator|(
operator|!
name|rdisc_ok
operator|||
name|rip_interfaces
operator|>
literal|1
operator|)
condition|)
block|{
name|trace_act
argument_list|(
literal|"turn on RIP"
argument_list|)
expr_stmt|;
comment|/* Close all of the query sockets so that we can open 		 * the main socket.  SO_REUSEPORT is not a solution, 		 * since that would let two daemons bind to the broadcast 		 * socket. 		 */
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
operator|!=
literal|0
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
if|if
condition|(
name|ifp
operator|->
name|int_rip_sock
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|ifp
operator|->
name|int_rip_sock
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_rip_sock
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|rip_sock
operator|=
name|get_rip_sock
argument_list|(
name|INADDR_ANY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rip_sock_mcast
operator|=
literal|0
expr_stmt|;
comment|/* Do not advertise anything until we have heard something 		 */
if|if
condition|(
name|next_bcast
operator|.
name|tv_sec
operator|<
name|now
operator|.
name|tv_sec
operator|+
name|MIN_WAITTIME
condition|)
name|next_bcast
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
operator|+
name|MIN_WAITTIME
expr_stmt|;
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
operator|!=
literal|0
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
name|ifp
operator|->
name|int_query_time
operator|=
name|NEVER
expr_stmt|;
name|rip_mcast_on
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|ifinit_timer
operator|.
name|tv_sec
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|int_state
operator|&
name|IS_REMOTE
operator|)
operator|&&
name|ifp
operator|->
name|int_rip_sock
operator|<
literal|0
condition|)
block|{
comment|/* RIP is off, so ensure there are sockets on which 		 * to listen for queries. 		 */
name|ifp
operator|->
name|int_rip_sock
operator|=
name|get_rip_sock
argument_list|(
name|ifp
operator|->
name|int_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fix_select
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* die if malloc(3) fails  */
end_comment

begin_function
name|void
modifier|*
name|rtmalloc
parameter_list|(
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|logbad
argument_list|(
literal|1
argument_list|,
literal|"malloc(%lu) failed in %s"
argument_list|,
operator|(
name|u_long
operator|)
name|size
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* get a random instant in an interval  */
end_comment

begin_function
name|void
name|intvl_random
parameter_list|(
name|struct
name|timeval
modifier|*
name|tp
parameter_list|,
comment|/* put value here */
name|u_long
name|lo
parameter_list|,
comment|/* value is after this second */
name|u_long
name|hi
parameter_list|)
comment|/* and before this */
block|{
name|tp
operator|->
name|tv_sec
operator|=
call|(
name|time_t
call|)
argument_list|(
name|hi
operator|==
name|lo
condition|?
name|lo
else|:
operator|(
name|lo
operator|+
name|random
argument_list|()
operator|%
operator|(
operator|(
name|hi
operator|-
name|lo
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tv_usec
operator|=
name|random
argument_list|()
operator|%
literal|1000000
expr_stmt|;
block|}
end_function

begin_function
name|void
name|timevaladd
parameter_list|(
name|struct
name|timeval
modifier|*
name|t1
parameter_list|,
name|struct
name|timeval
modifier|*
name|t2
parameter_list|)
block|{
name|t1
operator|->
name|tv_sec
operator|+=
name|t2
operator|->
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|(
name|t1
operator|->
name|tv_usec
operator|+=
name|t2
operator|->
name|tv_usec
operator|)
operator|>=
literal|1000000
condition|)
block|{
name|t1
operator|->
name|tv_sec
operator|++
expr_stmt|;
name|t1
operator|->
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* t1 = t2 - t3  */
end_comment

begin_function
specifier|static
name|void
name|timevalsub
parameter_list|(
name|struct
name|timeval
modifier|*
name|t1
parameter_list|,
name|struct
name|timeval
modifier|*
name|t2
parameter_list|,
name|struct
name|timeval
modifier|*
name|t3
parameter_list|)
block|{
name|t1
operator|->
name|tv_sec
operator|=
name|t2
operator|->
name|tv_sec
operator|-
name|t3
operator|->
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|(
name|t1
operator|->
name|tv_usec
operator|=
name|t2
operator|->
name|tv_usec
operator|-
name|t3
operator|->
name|tv_usec
operator|)
operator|<
literal|0
condition|)
block|{
name|t1
operator|->
name|tv_sec
operator|--
expr_stmt|;
name|t1
operator|->
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* put a message into the system log  */
end_comment

begin_function
name|void
name|msglog
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|trace_flush
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|vsyslog
argument_list|(
name|LOG_ERR
argument_list|,
name|p
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftrace
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ftrace
operator|==
name|stdout
condition|)
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"routed: "
argument_list|,
name|ftrace
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|ftrace
argument_list|,
name|p
argument_list|,
name|args
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|ftrace
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Put a message about a bad system into the system log if  * we have not complained about it recently.  *  * It is desirable to complain about all bad systems, but not too often.  * In the worst case, it is not practical to keep track of all bad systems.  * For example, there can be many systems with the wrong password.  */
end_comment

begin_function
name|void
name|msglim
parameter_list|(
name|struct
name|msg_limit
modifier|*
name|lim
parameter_list|,
name|naddr
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|msg_sub
modifier|*
name|ms1
decl_stmt|,
modifier|*
name|ms
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* look for the oldest slot in the table 	 * or the slot for the bad router. 	 */
name|ms
operator|=
name|ms1
operator|=
name|lim
operator|->
name|subs
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MSG_SUBJECT_N
init|;
condition|;
name|i
operator|--
operator|,
name|ms1
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* Reuse a slot at most once every 10 minutes. 			 */
if|if
condition|(
name|lim
operator|->
name|reuse
operator|>
name|now
operator|.
name|tv_sec
condition|)
block|{
name|ms
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ms
operator|=
name|ms1
expr_stmt|;
name|lim
operator|->
name|reuse
operator|=
name|now
operator|.
name|tv_sec
operator|+
literal|10
operator|*
literal|60
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|ms
operator|->
name|addr
operator|==
name|addr
condition|)
block|{
comment|/* Repeat a complaint about a given system at 			 * most once an hour. 			 */
if|if
condition|(
name|ms
operator|->
name|until
operator|>
name|now
operator|.
name|tv_sec
condition|)
name|ms
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ms
operator|->
name|until
operator|<
name|ms1
operator|->
name|until
condition|)
name|ms
operator|=
name|ms1
expr_stmt|;
block|}
if|if
condition|(
name|ms
operator|!=
literal|0
condition|)
block|{
name|ms
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|ms
operator|->
name|until
operator|=
name|now
operator|.
name|tv_sec
operator|+
literal|60
operator|*
literal|60
expr_stmt|;
comment|/* 60 minutes */
name|trace_flush
argument_list|()
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|p
init|;
operator|*
name|p1
operator|==
literal|' '
condition|;
name|p1
operator|++
control|)
continue|continue;
name|vsyslog
argument_list|(
name|LOG_ERR
argument_list|,
name|p1
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* always display the message if tracing */
if|if
condition|(
name|ftrace
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|ftrace
argument_list|,
name|p
argument_list|,
name|args
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|ftrace
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|logbad
parameter_list|(
name|int
name|dump
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|trace_flush
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|vsyslog
argument_list|(
name|LOG_ERR
argument_list|,
name|p
argument_list|,
name|args
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"routed: "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|p
argument_list|,
name|args
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"; giving up\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump
condition|)
name|abort
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

