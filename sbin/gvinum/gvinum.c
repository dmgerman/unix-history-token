begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 2004 Lukas Ertl  *  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<geom/vinum/geom_vinum_var.h>
end_include

begin_include
include|#
directive|include
file|<geom/vinum/geom_vinum_share.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<libgeom.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<readline/readline.h>
end_include

begin_include
include|#
directive|include
file|<readline/history.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"gvinum.h"
end_include

begin_function_decl
name|void
name|gvinum_cancelinit
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gvinum_create
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gvinum_help
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gvinum_init
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gvinum_list
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gvinum_parityop
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gvinum_printconfig
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gvinum_rm
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gvinum_saveconfig
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gvinum_start
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gvinum_stop
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|parseline
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|printconfig
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|line
decl_stmt|,
name|tokens
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|inputline
decl_stmt|,
modifier|*
name|token
index|[
name|GV_MAXARGS
index|]
decl_stmt|;
comment|/* Load the module if necessary. */
if|if
condition|(
name|kldfind
argument_list|(
name|GVINUMMOD
argument_list|)
operator|<
literal|0
operator|&&
name|kldload
argument_list|(
name|GVINUMMOD
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|GVINUMMOD
literal|": Kernel module not available"
argument_list|)
expr_stmt|;
comment|/* Arguments given on the command line. */
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|parseline
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* Interactive mode. */
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|inputline
operator|=
name|readline
argument_list|(
literal|"gvinum -> "
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputline
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't read input"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|inputline
condition|)
block|{
name|add_history
argument_list|(
name|inputline
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|inputline
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inputline
argument_list|)
expr_stmt|;
name|line
operator|++
expr_stmt|;
comment|/* count the lines */
name|tokens
operator|=
name|gv_tokenize
argument_list|(
name|buffer
argument_list|,
name|token
argument_list|,
name|GV_MAXARGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokens
condition|)
name|parseline
argument_list|(
name|tokens
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gvinum_cancelinit
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
return|return;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"cancelinit"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"argc"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"argv%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't init: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|gvinum_list
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gvinum_create
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|struct
name|gv_drive
modifier|*
name|d
decl_stmt|;
name|struct
name|gv_plex
modifier|*
name|p
decl_stmt|;
name|struct
name|gv_sd
modifier|*
name|s
decl_stmt|;
name|struct
name|gv_volume
modifier|*
name|v
decl_stmt|;
name|FILE
modifier|*
name|tmp
decl_stmt|;
name|int
name|drives
decl_stmt|,
name|errors
decl_stmt|,
name|fd
decl_stmt|,
name|line
decl_stmt|,
name|plexes
decl_stmt|,
name|plex_in_volume
decl_stmt|;
name|int
name|sd_in_plex
decl_stmt|,
name|status
decl_stmt|,
name|subdisks
decl_stmt|,
name|tokens
decl_stmt|,
name|volumes
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|commandline
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|ed
decl_stmt|;
name|char
name|original
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|tmpfile
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|token
index|[
name|GV_MAXARGS
index|]
decl_stmt|;
name|char
name|plex
index|[
name|GV_MAXPLEXNAME
index|]
decl_stmt|,
name|volume
index|[
name|GV_MAXVOLNAME
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|tmp
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"can't open '%s' for reading"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|snprintf
argument_list|(
name|tmpfile
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpfile
argument_list|)
argument_list|,
literal|"/tmp/gvinum.XXXXXX"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|tmpfile
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"temporary file not accessible"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|tmp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"can't open '%s' for writing"
argument_list|,
name|tmpfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|printconfig
argument_list|(
name|tmp
argument_list|,
literal|"# "
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|ed
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|==
name|NULL
condition|)
name|ed
operator|=
name|_PATH_VI
expr_stmt|;
name|snprintf
argument_list|(
name|commandline
argument_list|,
sizeof|sizeof
argument_list|(
name|commandline
argument_list|)
argument_list|,
literal|"%s %s"
argument_list|,
name|ed
argument_list|,
name|tmpfile
argument_list|)
expr_stmt|;
name|status
operator|=
name|system
argument_list|(
name|commandline
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"couldn't exec %s; status: %d"
argument_list|,
name|ed
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|tmp
operator|=
name|fopen
argument_list|(
name|tmpfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"can't open '%s' for reading"
argument_list|,
name|tmpfile
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"create"
argument_list|)
expr_stmt|;
name|drives
operator|=
name|volumes
operator|=
name|plexes
operator|=
name|subdisks
operator|=
literal|0
expr_stmt|;
name|plex_in_volume
operator|=
name|sd_in_plex
operator|=
literal|0
expr_stmt|;
name|errors
operator|=
literal|0
expr_stmt|;
name|line
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|tmp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Skip empty lines and comments. */
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\0'
operator|||
operator|*
name|buf
operator|==
literal|'#'
condition|)
block|{
name|line
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Kill off the newline. */
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Copy the original input line in case we need it for error 		 * output. 		 */
name|strncpy
argument_list|(
name|original
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|tokens
operator|=
name|gv_tokenize
argument_list|(
name|buf
argument_list|,
name|token
argument_list|,
name|GV_MAXARGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokens
operator|>
literal|0
condition|)
block|{
comment|/* Volume definition. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
literal|0
index|]
argument_list|,
literal|"volume"
argument_list|)
condition|)
block|{
name|v
operator|=
name|gv_new_volume
argument_list|(
name|tokens
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"line %d: invalid volume "
literal|"definition"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"line %d: '%s'"
argument_list|,
name|line
argument_list|,
name|original
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Reset plex count for this volume. */
name|plex_in_volume
operator|=
literal|0
expr_stmt|;
comment|/* 					 * Set default volume name for 					 * following plex definitions. 					 */
name|strncpy
argument_list|(
name|volume
argument_list|,
name|v
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|volume
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
literal|"volume%d"
argument_list|,
name|volumes
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|v
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|volumes
operator|++
expr_stmt|;
block|}
comment|/* Plex definition. */
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
literal|0
index|]
argument_list|,
literal|"plex"
argument_list|)
condition|)
block|{
name|p
operator|=
name|gv_new_plex
argument_list|(
name|tokens
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"line %d: invalid plex "
literal|"definition"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"line %d: '%s'"
argument_list|,
name|line
argument_list|,
name|original
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Reset subdisk count for this plex. */
name|sd_in_plex
operator|=
literal|0
expr_stmt|;
comment|/* Default name. */
if|if
condition|(
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|GV_MAXPLEXNAME
argument_list|,
literal|"%s.p%d"
argument_list|,
name|volume
argument_list|,
name|plex_in_volume
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/* Default volume. */
if|if
condition|(
name|strlen
argument_list|(
name|p
operator|->
name|volume
argument_list|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|volume
argument_list|,
name|GV_MAXVOLNAME
argument_list|,
literal|"%s"
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
comment|/* 					 * Set default plex name for following 					 * subdisk definitions. 					 */
name|strncpy
argument_list|(
name|plex
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|GV_MAXPLEXNAME
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
literal|"plex%d"
argument_list|,
name|plexes
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|plexes
operator|++
expr_stmt|;
block|}
comment|/* Subdisk definition. */
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
literal|0
index|]
argument_list|,
literal|"sd"
argument_list|)
condition|)
block|{
name|s
operator|=
name|gv_new_sd
argument_list|(
name|tokens
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"line %d: invalid subdisk "
literal|"definition:"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"line %d: '%s'"
argument_list|,
name|line
argument_list|,
name|original
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Default name. */
if|if
condition|(
name|strlen
argument_list|(
name|s
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|GV_MAXSDNAME
argument_list|,
literal|"%s.s%d"
argument_list|,
name|plex
argument_list|,
name|sd_in_plex
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/* Default plex. */
if|if
condition|(
name|strlen
argument_list|(
name|s
operator|->
name|plex
argument_list|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|s
operator|->
name|plex
argument_list|,
name|GV_MAXPLEXNAME
argument_list|,
literal|"%s"
argument_list|,
name|plex
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
literal|"sd%d"
argument_list|,
name|subdisks
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|subdisks
operator|++
expr_stmt|;
block|}
comment|/* Subdisk definition. */
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
literal|0
index|]
argument_list|,
literal|"drive"
argument_list|)
condition|)
block|{
name|d
operator|=
name|gv_new_drive
argument_list|(
name|tokens
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"line %d: invalid drive "
literal|"definition:"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"line %d: '%s'"
argument_list|,
name|line
argument_list|,
name|original
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
literal|"drive%d"
argument_list|,
name|drives
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|drives
operator|++
expr_stmt|;
block|}
comment|/* Everything else is bogus. */
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"line %d: invalid definition:"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"line %d: '%s'"
argument_list|,
name|line
argument_list|,
name|original
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
block|}
name|line
operator|++
expr_stmt|;
block|}
name|fclose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errors
operator|&&
operator|(
name|volumes
operator|||
name|plexes
operator|||
name|subdisks
operator|||
name|drives
operator|)
condition|)
block|{
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"volumes"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|volumes
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"plexes"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|plexes
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"subdisks"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|subdisks
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"drives"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|drives
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
name|warnx
argument_list|(
literal|"create failed: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
block|}
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|gvinum_list
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gvinum_help
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"COMMANDS\n"
literal|"attach plex volume [rename]\n"
literal|"attach subdisk plex [offset] [rename]\n"
literal|"        Attach a plex to a volume, or a subdisk to a plex.\n"
literal|"checkparity plex [-f] [-v]\n"
literal|"        Check the parity blocks of a RAID-4 or RAID-5 plex.\n"
literal|"concat [-f] [-n name] [-v] drives\n"
literal|"        Create a concatenated volume from the specified drives.\n"
literal|"create [-f] description-file\n"
literal|"        Create a volume as described in description-file.\n"
literal|"detach [-f] [plex | subdisk]\n"
literal|"        Detach a plex or subdisk from the volume or plex to"
literal|"which it is\n"
literal|"        attached.\n"
literal|"dumpconfig [drive ...]\n"
literal|"        List the configuration information stored on the"
literal|" specified\n"
literal|"        drives, or all drives in the system if no drive names"
literal|" are speci-\n"
literal|"        fied.\n"
literal|"info [-v] [-V]\n"
literal|"        List information about volume manager state.\n"
literal|"init [-S size] [-w] plex | subdisk\n"
literal|"        Initialize the contents of a subdisk or all the subdisks"
literal|" of a\n"
literal|"        plex to all zeros.\n"
literal|"label volume\n"
literal|"        Create a volume label.\n"
literal|"l | list [-r] [-s] [-v] [-V] [volume | plex | subdisk]\n"
literal|"        List information about specified objects.\n"
literal|"ld [-r] [-s] [-v] [-V] [volume]\n"
literal|"        List information about drives.\n"
literal|"ls [-r] [-s] [-v] [-V] [subdisk]\n"
literal|"        List information about subdisks.\n"
literal|"lp [-r] [-s] [-v] [-V] [plex]\n"
literal|"        List information about plexes.\n"
literal|"lv [-r] [-s] [-v] [-V] [volume]\n"
literal|"        List information about volumes.\n"
literal|"mirror [-f] [-n name] [-s] [-v] drives\n"
literal|"        Create a mirrored volume from the specified drives.\n"
literal|"move | mv -f drive object ...\n"
literal|"        Move the object(s) to the specified drive.\n"
literal|"printconfig [file]\n"
literal|"        Write a copy of the current configuration to file.\n"
literal|"quit    Exit the vinum program when running in interactive mode."
literal|"  Nor-\n"
literal|"        mally this would be done by entering the EOF character.\n"
literal|"rename [-r] [drive | subdisk | plex | volume] newname\n"
literal|"        Change the name of the specified object.\n"
literal|"rebuildparity plex [-f] [-v] [-V]\n"
literal|"        Rebuild the parity blocks of a RAID-4 or RAID-5 plex.\n"
literal|"resetconfig\n"
literal|"        Reset the complete vinum configuration.\n"
literal|"rm [-f] [-r] volume | plex | subdisk\n"
literal|"        Remove an object.\n"
literal|"saveconfig\n"
literal|"        Save vinum configuration to disk after configuration"
literal|" failures.\n"
literal|"setstate state [volume | plex | subdisk | drive]\n"
literal|"        Set state without influencing other objects, for"
literal|" diagnostic pur-\n"
literal|"        poses only.\n"
literal|"start [-i interval] [-S size] [-w] volume | plex | subdisk\n"
literal|"        Allow the system to access the objects.\n"
literal|"stop [-f] [volume | plex | subdisk]\n"
literal|"        Terminate access to the objects, or stop vinum if no"
literal|" parameters\n"
literal|"        are specified.\n"
literal|"stripe [-f] [-n name] [-v] drives\n"
literal|"        Create a striped volume from the specified drives.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|gvinum_init
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|int
name|i
decl_stmt|,
name|initsize
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|initsize
operator|=
literal|0
expr_stmt|;
name|optreset
operator|=
literal|1
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"S"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'S'
case|:
name|initsize
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
return|return;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
operator|!
name|initsize
condition|)
name|initsize
operator|=
literal|512
expr_stmt|;
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"init"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"argc"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"initsize"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|initsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"argv%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't init: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|gvinum_list
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gvinum_list
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|cmd
decl_stmt|,
name|config
index|[
name|GV_CFG_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|=
literal|"list"
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
name|optreset
operator|=
literal|1
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
name|cmd
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"rsvV"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'r'
case|:
name|flags
operator||=
name|GV_FLAG_R
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|flags
operator||=
name|GV_FLAG_S
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|flags
operator||=
name|GV_FLAG_V
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|flags
operator||=
name|GV_FLAG_V
expr_stmt|;
name|flags
operator||=
name|GV_FLAG_VV
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
return|return;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
block|}
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"list"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"cmd"
argument_list|,
operator|-
literal|1
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"argc"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"flags"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|gctl_rw_param
argument_list|(
name|req
argument_list|,
literal|"config"
argument_list|,
sizeof|sizeof
argument_list|(
name|config
argument_list|)
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"argv%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't get configuration: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|gvinum_printconfig
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|printconfig
argument_list|(
name|stdout
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gvinum_parityop
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|rebuild
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|,
name|rv
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
modifier|*
name|op
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|rebuild
condition|)
block|{
name|op
operator|=
literal|"rebuildparity"
expr_stmt|;
name|msg
operator|=
literal|"Rebuilding"
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
literal|"checkparity"
expr_stmt|;
name|msg
operator|=
literal|"Checking"
expr_stmt|;
block|}
name|optreset
operator|=
literal|1
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"fv"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'f'
case|:
name|flags
operator||=
name|GV_FLAG_F
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|flags
operator||=
name|GV_FLAG_V
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|warnx
argument_list|(
literal|"invalid flag '%c'"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"usage: %s [-f] [-v]<plex>"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|rv
operator|=
literal|0
expr_stmt|;
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"parityop"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"flags"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"rebuild"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|rebuild
argument_list|)
expr_stmt|;
name|gctl_rw_param
argument_list|(
name|req
argument_list|,
literal|"rv"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|rv
argument_list|)
expr_stmt|;
name|gctl_rw_param
argument_list|(
name|req
argument_list|,
literal|"offset"
argument_list|,
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"plex"
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
condition|)
block|{
name|warnx
argument_list|(
literal|"%s\n"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
break|break;
block|}
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|GV_FLAG_V
condition|)
block|{
name|printf
argument_list|(
literal|"\r%s at %s ... "
argument_list|,
name|msg
argument_list|,
name|gv_roughlength
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Parity incorrect at offset 0x%jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rebuild
condition|)
break|break;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Clear the -f flag. */
name|flags
operator|&=
operator|~
name|GV_FLAG_F
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|>=
literal|0
condition|)
do|;
if|if
condition|(
operator|(
name|rv
operator|==
literal|2
operator|)
operator|&&
operator|(
name|flags
operator|&
name|GV_FLAG_V
operator|)
condition|)
block|{
if|if
condition|(
name|rebuild
condition|)
name|printf
argument_list|(
literal|"Rebuilt parity on %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s has correct parity\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|gvinum_rm
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|cmd
decl_stmt|;
name|cmd
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|optreset
operator|=
literal|1
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'r'
case|:
name|flags
operator||=
name|GV_FLAG_R
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
return|return;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"remove"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"argc"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"flags"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"argv%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't remove: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|gvinum_list
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gvinum_saveconfig
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"saveconfig"
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
name|warnx
argument_list|(
literal|"can't save configuration: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gvinum_start
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|int
name|i
decl_stmt|,
name|initsize
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
comment|/* 'start' with no arguments is a no-op. */
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
return|return;
name|initsize
operator|=
literal|0
expr_stmt|;
name|optreset
operator|=
literal|1
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"S"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'S'
case|:
name|initsize
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
return|return;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
operator|!
name|initsize
condition|)
name|initsize
operator|=
literal|512
expr_stmt|;
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"start"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"argc"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"initsize"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|initsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"argv%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't start: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|gvinum_list
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gvinum_stop
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|fileid
decl_stmt|;
name|fileid
operator|=
name|kldfind
argument_list|(
name|GVINUMMOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileid
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"cannot find "
name|GVINUMMOD
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|kldunload
argument_list|(
name|fileid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"cannot unload "
name|GVINUMMOD
argument_list|)
expr_stmt|;
return|return;
block|}
name|warnx
argument_list|(
name|GVINUMMOD
literal|" unloaded"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|parseline
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"cancelinit"
argument_list|)
condition|)
name|gvinum_cancelinit
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"create"
argument_list|)
condition|)
name|gvinum_create
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"exit"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"quit"
argument_list|)
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"help"
argument_list|)
condition|)
name|gvinum_help
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"init"
argument_list|)
condition|)
name|gvinum_init
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"list"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"l"
argument_list|)
condition|)
name|gvinum_list
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"ld"
argument_list|)
condition|)
name|gvinum_list
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"lp"
argument_list|)
condition|)
name|gvinum_list
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"ls"
argument_list|)
condition|)
name|gvinum_list
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"lv"
argument_list|)
condition|)
name|gvinum_list
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"printconfig"
argument_list|)
condition|)
name|gvinum_printconfig
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"rm"
argument_list|)
condition|)
name|gvinum_rm
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"saveconfig"
argument_list|)
condition|)
name|gvinum_saveconfig
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"start"
argument_list|)
condition|)
name|gvinum_start
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"stop"
argument_list|)
condition|)
name|gvinum_stop
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"checkparity"
argument_list|)
condition|)
name|gvinum_parityop
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"rebuildparity"
argument_list|)
condition|)
name|gvinum_parityop
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"unknown command '%s'\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * The guts of printconfig.  This is called from gvinum_printconfig and from  * gvinum_create when called without an argument, in order to give the user  * something to edit.  */
end_comment

begin_function
name|void
name|printconfig
parameter_list|(
name|FILE
modifier|*
name|of
parameter_list|,
name|char
modifier|*
name|comment
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|struct
name|utsname
name|uname_s
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
name|buf
index|[
name|GV_CFG_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|uname
argument_list|(
operator|&
name|uname_s
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"getconfig"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"comment"
argument_list|,
operator|-
literal|1
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|gctl_rw_param
argument_list|(
name|req
argument_list|,
literal|"config"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't get configuration: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
return|return;
block|}
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"# Vinum configuration of %s, saved at %s"
argument_list|,
name|uname_s
operator|.
name|nodename
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|comment
operator|!=
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"# Current configuration:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|of
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

