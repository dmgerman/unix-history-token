begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 2004 Lukas Ertl  *  Copyright (c) 2005 Chris Jones  *  Copyright (c) 2007 Ulf Lilleengen  *  All rights reserved.  *  * Portions of this software were developed for the FreeBSD Project  * by Chris Jones thanks to the support of Google's Summer of Code  * program and mentoring by Lukas Ertl.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<geom/vinum/geom_vinum_var.h>
end_include

begin_include
include|#
directive|include
file|<geom/vinum/geom_vinum_share.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libgeom.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<readline/readline.h>
end_include

begin_include
include|#
directive|include
file|<readline/history.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"gvinum.h"
end_include

begin_function_decl
specifier|static
name|void
name|gvinum_attach
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_concat
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_create
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_detach
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_grow
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_help
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_list
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_move
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_mirror
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_parityop
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_printconfig
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_raid5
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_rename
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_resetconfig
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_rm
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_saveconfig
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_setstate
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_start
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_stop
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gvinum_stripe
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parseline
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printconfig
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|create_drive
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_volume
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|find_name
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|find_pattern
parameter_list|(
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_device
parameter_list|(
name|struct
name|gv_drive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|find_drive
parameter_list|()
define|\
value|find_name("gvinumdrive", GV_TYPE_DRIVE, GV_MAXDRIVENAME)
end_define

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|line
decl_stmt|,
name|tokens
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|inputline
decl_stmt|,
modifier|*
name|token
index|[
name|GV_MAXARGS
index|]
decl_stmt|;
comment|/* Load the module if necessary. */
if|if
condition|(
name|modfind
argument_list|(
name|GVINUMMOD
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|kldload
argument_list|(
name|GVINUMKLD
argument_list|)
operator|<
literal|0
operator|&&
name|modfind
argument_list|(
name|GVINUMMOD
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|GVINUMKLD
literal|": Kernel module not available"
argument_list|)
expr_stmt|;
block|}
comment|/* Arguments given on the command line. */
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|parseline
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* Interactive mode. */
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|inputline
operator|=
name|readline
argument_list|(
literal|"gvinum -> "
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputline
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't read input"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|inputline
condition|)
block|{
name|add_history
argument_list|(
name|inputline
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|inputline
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inputline
argument_list|)
expr_stmt|;
name|line
operator|++
expr_stmt|;
comment|/* count the lines */
name|tokens
operator|=
name|gv_tokenize
argument_list|(
name|buffer
argument_list|,
name|token
argument_list|,
name|GV_MAXARGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokens
condition|)
name|parseline
argument_list|(
name|tokens
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attach a plex to a volume or a subdisk to a plex. */
end_comment

begin_function
specifier|static
name|void
name|gvinum_attach
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|int
name|rename
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|rename
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|warnx
argument_list|(
literal|"usage:\tattach<subdisk><plex> [rename] "
literal|"[<plexoffset>]\n"
literal|"\tattach<plex><volume> [rename]"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"rename"
argument_list|)
condition|)
block|{
name|rename
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|5
condition|)
name|offset
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"attach"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"child"
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"parent"
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"offset"
argument_list|,
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"rename"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|rename
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
name|warnx
argument_list|(
literal|"attach failed: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gvinum_create
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|struct
name|gv_drive
modifier|*
name|d
decl_stmt|;
name|struct
name|gv_plex
modifier|*
name|p
decl_stmt|;
name|struct
name|gv_sd
modifier|*
name|s
decl_stmt|;
name|struct
name|gv_volume
modifier|*
name|v
decl_stmt|;
name|FILE
modifier|*
name|tmp
decl_stmt|;
name|int
name|drives
decl_stmt|,
name|errors
decl_stmt|,
name|fd
decl_stmt|,
name|flags
decl_stmt|,
name|i
decl_stmt|,
name|line
decl_stmt|,
name|plexes
decl_stmt|,
name|plex_in_volume
decl_stmt|;
name|int
name|sd_in_plex
decl_stmt|,
name|status
decl_stmt|,
name|subdisks
decl_stmt|,
name|tokens
decl_stmt|,
name|undeffd
decl_stmt|,
name|volumes
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|commandline
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|ed
decl_stmt|,
modifier|*
name|sdname
decl_stmt|;
name|char
name|original
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|tmpfile
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|token
index|[
name|GV_MAXARGS
index|]
decl_stmt|;
name|char
name|plex
index|[
name|GV_MAXPLEXNAME
index|]
decl_stmt|,
name|volume
index|[
name|GV_MAXVOLNAME
index|]
decl_stmt|;
name|tmp
operator|=
name|NULL
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* Force flag used to ignore already created drives. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-f"
argument_list|)
condition|)
block|{
name|flags
operator||=
name|GV_FLAG_F
expr_stmt|;
comment|/* Else it must be a file. */
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tmp
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"can't open '%s' for reading"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* We didn't get a file. */
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|tmpfile
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpfile
argument_list|)
argument_list|,
literal|"/tmp/gvinum.XXXXXX"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|tmpfile
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"temporary file not accessible"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|tmp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"can't open '%s' for writing"
argument_list|,
name|tmpfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|printconfig
argument_list|(
name|tmp
argument_list|,
literal|"# "
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|ed
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|==
name|NULL
condition|)
name|ed
operator|=
name|_PATH_VI
expr_stmt|;
name|snprintf
argument_list|(
name|commandline
argument_list|,
sizeof|sizeof
argument_list|(
name|commandline
argument_list|)
argument_list|,
literal|"%s %s"
argument_list|,
name|ed
argument_list|,
name|tmpfile
argument_list|)
expr_stmt|;
name|status
operator|=
name|system
argument_list|(
name|commandline
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"couldn't exec %s; status: %d"
argument_list|,
name|ed
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|tmp
operator|=
name|fopen
argument_list|(
name|tmpfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"can't open '%s' for reading"
argument_list|,
name|tmpfile
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"create"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"flags"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|drives
operator|=
name|volumes
operator|=
name|plexes
operator|=
name|subdisks
operator|=
literal|0
expr_stmt|;
name|plex_in_volume
operator|=
name|sd_in_plex
operator|=
name|undeffd
operator|=
literal|0
expr_stmt|;
name|plex
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|errors
operator|=
literal|0
expr_stmt|;
name|line
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|tmp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Skip empty lines and comments. */
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\0'
operator|||
operator|*
name|buf
operator|==
literal|'#'
condition|)
block|{
name|line
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Kill off the newline. */
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Copy the original input line in case we need it for error 		 * output. 		 */
name|strlcpy
argument_list|(
name|original
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|original
argument_list|)
argument_list|)
expr_stmt|;
name|tokens
operator|=
name|gv_tokenize
argument_list|(
name|buf
argument_list|,
name|token
argument_list|,
name|GV_MAXARGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokens
operator|<=
literal|0
condition|)
block|{
name|line
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Volume definition. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
literal|0
index|]
argument_list|,
literal|"volume"
argument_list|)
condition|)
block|{
name|v
operator|=
name|gv_new_volume
argument_list|(
name|tokens
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"line %d: invalid volume definition"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"line %d: '%s'"
argument_list|,
name|line
argument_list|,
name|original
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
name|line
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Reset plex count for this volume. */
name|plex_in_volume
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Set default volume name for following plex 			 * definitions. 			 */
name|strlcpy
argument_list|(
name|volume
argument_list|,
name|v
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|volume
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
literal|"volume%d"
argument_list|,
name|volumes
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|v
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|volumes
operator|++
expr_stmt|;
comment|/* Plex definition. */
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
literal|0
index|]
argument_list|,
literal|"plex"
argument_list|)
condition|)
block|{
name|p
operator|=
name|gv_new_plex
argument_list|(
name|tokens
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"line %d: invalid plex definition"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"line %d: '%s'"
argument_list|,
name|line
argument_list|,
name|original
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
name|line
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Reset subdisk count for this plex. */
name|sd_in_plex
operator|=
literal|0
expr_stmt|;
comment|/* Default name. */
if|if
condition|(
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|name
argument_list|)
argument_list|,
literal|"%s.p%d"
argument_list|,
name|volume
argument_list|,
name|plex_in_volume
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/* Default volume. */
if|if
condition|(
name|strlen
argument_list|(
name|p
operator|->
name|volume
argument_list|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|volume
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|volume
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Set default plex name for following subdisk 			 * definitions. 			 */
name|strlcpy
argument_list|(
name|plex
argument_list|,
name|p
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|plex
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
literal|"plex%d"
argument_list|,
name|plexes
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|plexes
operator|++
expr_stmt|;
comment|/* Subdisk definition. */
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
literal|0
index|]
argument_list|,
literal|"sd"
argument_list|)
condition|)
block|{
name|s
operator|=
name|gv_new_sd
argument_list|(
name|tokens
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"line %d: invalid subdisk "
literal|"definition:"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"line %d: '%s'"
argument_list|,
name|line
argument_list|,
name|original
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
name|line
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Default name. */
if|if
condition|(
name|strlen
argument_list|(
name|s
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|plex
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sdname
operator|=
name|find_name
argument_list|(
literal|"gvinumsubdisk.p"
argument_list|,
name|GV_TYPE_SD
argument_list|,
name|GV_MAXSDNAME
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|s
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|,
literal|"%s.s%d"
argument_list|,
name|sdname
argument_list|,
name|undeffd
operator|++
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sdname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|s
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|,
literal|"%s.s%d"
argument_list|,
name|plex
argument_list|,
name|sd_in_plex
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Default plex. */
if|if
condition|(
name|strlen
argument_list|(
name|s
operator|->
name|plex
argument_list|)
operator|==
literal|0
condition|)
name|snprintf
argument_list|(
name|s
operator|->
name|plex
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|plex
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|plex
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
literal|"sd%d"
argument_list|,
name|subdisks
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|subdisks
operator|++
expr_stmt|;
comment|/* Subdisk definition. */
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
literal|0
index|]
argument_list|,
literal|"drive"
argument_list|)
condition|)
block|{
name|d
operator|=
name|gv_new_drive
argument_list|(
name|tokens
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"line %d: invalid drive definition:"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"line %d: '%s'"
argument_list|,
name|line
argument_list|,
name|original
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
name|line
operator|++
expr_stmt|;
continue|continue;
block|}
name|snprintf
argument_list|(
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
literal|"drive%d"
argument_list|,
name|drives
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|drives
operator|++
expr_stmt|;
comment|/* Everything else is bogus. */
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"line %d: invalid definition:"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"line %d: '%s'"
argument_list|,
name|line
argument_list|,
name|original
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
name|line
operator|++
expr_stmt|;
block|}
name|fclose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errors
operator|&&
operator|(
name|volumes
operator|||
name|plexes
operator|||
name|subdisks
operator|||
name|drives
operator|)
condition|)
block|{
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"volumes"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|volumes
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"plexes"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|plexes
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"subdisks"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|subdisks
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"drives"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|drives
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
name|warnx
argument_list|(
literal|"create failed: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
block|}
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a concatenated volume. */
end_comment

begin_function
specifier|static
name|void
name|gvinum_concat
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"usage:\tconcat [-fv] [-n name] drives\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|create_volume
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"concat"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a drive quick and dirty. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|create_drive
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|)
block|{
name|struct
name|gv_drive
modifier|*
name|d
decl_stmt|;
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
modifier|*
name|drivename
decl_stmt|,
modifier|*
name|dname
decl_stmt|;
name|int
name|drives
decl_stmt|,
name|i
decl_stmt|,
name|flags
decl_stmt|,
name|volumes
decl_stmt|,
name|subdisks
decl_stmt|,
name|plexes
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|flags
operator|=
name|plexes
operator|=
name|subdisks
operator|=
name|volumes
operator|=
literal|0
expr_stmt|;
name|drives
operator|=
literal|1
expr_stmt|;
name|dname
operator|=
name|NULL
expr_stmt|;
name|drivename
operator|=
name|find_drive
argument_list|()
expr_stmt|;
if|if
condition|(
name|drivename
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"create"
argument_list|)
expr_stmt|;
name|d
operator|=
name|gv_alloc_drive
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"unable to allocate for gv_drive object"
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|drivename
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|copy_device
argument_list|(
name|d
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"drive0"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"flags"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"drives"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|drives
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"volumes"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|volumes
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"plexes"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|plexes
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"subdisks"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|subdisks
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"error creating drive: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|drivename
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX: This is needed because we have to make sure the drives 		 * are created before we return. */
comment|/* Loop until it's in the config. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100000
condition|;
name|i
operator|++
control|)
block|{
name|dname
operator|=
name|find_name
argument_list|(
literal|"gvinumdrive"
argument_list|,
name|GV_TYPE_DRIVE
argument_list|,
name|GV_MAXDRIVENAME
argument_list|)
expr_stmt|;
comment|/* If we got a different name, quit. */
if|if
condition|(
name|dname
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|dname
argument_list|,
name|drivename
argument_list|)
condition|)
name|found
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|dname
argument_list|)
expr_stmt|;
name|dname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|found
condition|)
break|break;
name|usleep
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
comment|/* Sleep for 0.1s */
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"error creating drive"
argument_list|)
expr_stmt|;
name|drivename
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|drivename
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * General routine for creating a volume. Mainly for use by concat, mirror,  * raid5 and stripe commands.  */
end_comment

begin_function
specifier|static
name|void
name|create_volume
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|verb
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|drivename
decl_stmt|,
modifier|*
name|volname
decl_stmt|;
name|int
name|drives
decl_stmt|,
name|flags
decl_stmt|,
name|i
decl_stmt|;
name|off_t
name|stripesize
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|drives
operator|=
literal|0
expr_stmt|;
name|volname
operator|=
name|NULL
expr_stmt|;
name|stripesize
operator|=
literal|262144
expr_stmt|;
comment|/* XXX: Should we check for argument length? */
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-f"
argument_list|)
condition|)
block|{
name|flags
operator||=
name|GV_FLAG_F
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-n"
argument_list|)
condition|)
block|{
name|volname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-v"
argument_list|)
condition|)
block|{
name|flags
operator||=
name|GV_FLAG_V
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-s"
argument_list|)
condition|)
block|{
name|flags
operator||=
name|GV_FLAG_S
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"raid5"
argument_list|)
condition|)
name|stripesize
operator|=
name|gv_sizespec
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Assume it's a drive. */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"drive%d"
argument_list|,
name|drives
operator|++
argument_list|)
expr_stmt|;
comment|/* First we create the drive. */
name|drivename
operator|=
name|create_drive
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|drivename
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* Then we add it to the request. */
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|drivename
argument_list|)
expr_stmt|;
block|}
block|}
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"stripesize"
argument_list|,
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|,
operator|&
name|stripesize
argument_list|)
expr_stmt|;
comment|/* Find a free volume name. */
if|if
condition|(
name|volname
operator|==
name|NULL
condition|)
name|volname
operator|=
name|find_name
argument_list|(
literal|"gvinumvolume"
argument_list|,
name|GV_TYPE_VOL
argument_list|,
name|GV_MAXVOLNAME
argument_list|)
expr_stmt|;
comment|/* Then we send a request to actually create the volumes. */
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
name|verb
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"flags"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"drives"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|drives
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"name"
argument_list|,
operator|-
literal|1
argument_list|,
name|volname
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
name|warnx
argument_list|(
literal|"creating %s volume failed: %s"
argument_list|,
name|verb
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|bad
label|:
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a line of the config, return the word after<pattern>. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|find_pattern
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|strsep
argument_list|(
operator|&
name|line
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ptr
argument_list|,
name|pattern
argument_list|)
condition|)
block|{
comment|/* Return the next. */
name|ptr
operator|=
name|strsep
argument_list|(
operator|&
name|line
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
name|ptr
operator|=
name|strsep
argument_list|(
operator|&
name|line
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find a free name for an object given a prefix. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_name
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|namelen
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|char
name|comment
index|[
literal|1
index|]
decl_stmt|,
name|buf
index|[
name|GV_CFG_LEN
operator|-
literal|1
index|]
decl_stmt|,
modifier|*
name|sname
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|begin
decl_stmt|,
name|len
decl_stmt|,
name|conflict
decl_stmt|;
name|char
name|line
index|[
literal|1024
index|]
decl_stmt|;
name|comment
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find a name. Fetch out configuration first. */
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"getconfig"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"comment"
argument_list|,
operator|-
literal|1
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|gctl_rw_param
argument_list|(
name|req
argument_list|,
literal|"config"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't get configuration: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|begin
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|sname
operator|=
name|malloc
argument_list|(
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX: Max object setting? */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|10000
condition|;
name|n
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|sname
argument_list|,
name|namelen
argument_list|,
literal|"%s%d"
argument_list|,
name|prefix
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|conflict
operator|=
literal|0
expr_stmt|;
name|begin
operator|=
literal|0
expr_stmt|;
comment|/* Loop through the configuration line by line. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\n'
operator|||
name|buf
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ptr
operator|=
name|buf
operator|+
name|begin
expr_stmt|;
name|strlcpy
argument_list|(
name|line
argument_list|,
name|ptr
argument_list|,
operator|(
name|i
operator|-
name|begin
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|begin
operator|=
name|i
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GV_TYPE_DRIVE
case|:
name|name
operator|=
name|find_pattern
argument_list|(
name|line
argument_list|,
literal|"drive"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GV_TYPE_VOL
case|:
name|name
operator|=
name|find_pattern
argument_list|(
name|line
argument_list|,
literal|"volume"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GV_TYPE_PLEX
case|:
case|case
name|GV_TYPE_SD
case|:
name|name
operator|=
name|find_pattern
argument_list|(
name|line
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Invalid type given\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sname
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|conflict
operator|=
literal|1
expr_stmt|;
comment|/* XXX: Could quit the loop earlier. */
block|}
block|}
block|}
if|if
condition|(
operator|!
name|conflict
condition|)
return|return
operator|(
name|sname
operator|)
return|;
block|}
name|free
argument_list|(
name|sname
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_device
parameter_list|(
name|struct
name|gv_drive
modifier|*
name|d
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|device
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|strlcpy
argument_list|(
name|d
operator|->
name|device
argument_list|,
operator|(
name|device
operator|+
literal|5
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|device
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|d
operator|->
name|device
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|device
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Detach a plex or subdisk from its parent. */
end_comment

begin_function
specifier|static
name|void
name|gvinum_detach
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|optreset
operator|=
literal|1
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'f'
case|:
name|flags
operator||=
name|GV_FLAG_F
expr_stmt|;
break|break;
default|default:
name|warn
argument_list|(
literal|"invalid flag: %c"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"usage: detach [-f]<subdisk> |<plex>"
argument_list|)
expr_stmt|;
return|return;
block|}
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"detach"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"object"
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"flags"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
name|warnx
argument_list|(
literal|"detach failed: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gvinum_help
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"COMMANDS\n"
literal|"checkparity [-f] plex\n"
literal|"        Check the parity blocks of a RAID-5 plex.\n"
literal|"create [-f] description-file\n"
literal|"        Create as per description-file or open editor.\n"
literal|"attach plex volume [rename]\n"
literal|"attach subdisk plex [offset] [rename]\n"
literal|"        Attach a plex to a volume, or a subdisk to a plex\n"
literal|"concat [-fv] [-n name] drives\n"
literal|"        Create a concatenated volume from the specified drives.\n"
literal|"detach [-f] [plex | subdisk]\n"
literal|"        Detach a plex or a subdisk from the volume or plex to\n"
literal|"        which it is attached.\n"
literal|"grow plex drive\n"
literal|"        Grow plex by creating a properly sized subdisk on drive\n"
literal|"l | list [-r] [-v] [-V] [volume | plex | subdisk]\n"
literal|"        List information about specified objects.\n"
literal|"ld [-r] [-v] [-V] [volume]\n"
literal|"        List information about drives.\n"
literal|"ls [-r] [-v] [-V] [subdisk]\n"
literal|"        List information about subdisks.\n"
literal|"lp [-r] [-v] [-V] [plex]\n"
literal|"        List information about plexes.\n"
literal|"lv [-r] [-v] [-V] [volume]\n"
literal|"        List information about volumes.\n"
literal|"mirror [-fsv] [-n name] drives\n"
literal|"        Create a mirrored volume from the specified drives.\n"
literal|"move | mv -f drive object ...\n"
literal|"        Move the object(s) to the specified drive.\n"
literal|"quit    Exit the vinum program when running in interactive mode."
literal|"  Nor-\n"
literal|"        mally this would be done by entering the EOF character.\n"
literal|"raid5 [-fv] [-s stripesize] [-n name] drives\n"
literal|"        Create a RAID-5 volume from the specified drives.\n"
literal|"rename [-r] [drive | subdisk | plex | volume] newname\n"
literal|"        Change the name of the specified object.\n"
literal|"rebuildparity plex [-f]\n"
literal|"        Rebuild the parity blocks of a RAID-5 plex.\n"
literal|"resetconfig [-f]\n"
literal|"        Reset the complete gvinum configuration\n"
literal|"rm [-r] [-f] volume | plex | subdisk | drive\n"
literal|"        Remove an object.\n"
literal|"saveconfig\n"
literal|"        Save vinum configuration to disk after configuration"
literal|" failures.\n"
literal|"setstate [-f] state [volume | plex | subdisk | drive]\n"
literal|"        Set state without influencing other objects, for"
literal|" diagnostic pur-\n"
literal|"        poses only.\n"
literal|"start [-S size] volume | plex | subdisk\n"
literal|"        Allow the system to access the objects.\n"
literal|"stripe [-fv] [-n name] drives\n"
literal|"        Create a striped volume from the specified drives.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gvinum_setstate
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|optreset
operator|=
literal|1
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'f'
case|:
name|flags
operator||=
name|GV_FLAG_F
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|warn
argument_list|(
literal|"invalid flag: %c"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"usage: setstate [-f]<state><obj>"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * XXX: This hack is needed to avoid tripping over (now) invalid 	 * 'classic' vinum states and will go away later. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"up"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"down"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"stale"
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid state '%s'"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"setstate"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"state"
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"object"
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"flags"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
name|warnx
argument_list|(
literal|"%s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gvinum_list
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|cmd
decl_stmt|,
name|config
index|[
name|GV_CFG_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|=
literal|"list"
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
name|optreset
operator|=
literal|1
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
name|cmd
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"rsvV"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'r'
case|:
name|flags
operator||=
name|GV_FLAG_R
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|flags
operator||=
name|GV_FLAG_S
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|flags
operator||=
name|GV_FLAG_V
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|flags
operator||=
name|GV_FLAG_V
expr_stmt|;
name|flags
operator||=
name|GV_FLAG_VV
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
return|return;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
block|}
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"list"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"cmd"
argument_list|,
operator|-
literal|1
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"argc"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"flags"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|gctl_rw_param
argument_list|(
name|req
argument_list|,
literal|"config"
argument_list|,
sizeof|sizeof
argument_list|(
name|config
argument_list|)
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"argv%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't get configuration: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a mirrored volume. */
end_comment

begin_function
specifier|static
name|void
name|gvinum_mirror
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"usage\tmirror [-fsv] [-n name] drives\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|create_volume
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"mirror"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note that move is currently of form '[-r] target object [...]' */
end_comment

begin_function
specifier|static
name|void
name|gvinum_move
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
name|optreset
operator|=
literal|1
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'f'
case|:
name|flags
operator||=
name|GV_FLAG_F
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
return|return;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
block|}
switch|switch
condition|(
name|argc
condition|)
block|{
case|case
literal|0
case|:
name|warnx
argument_list|(
literal|"no destination or object(s) to move specified"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
name|warnx
argument_list|(
literal|"no object(s) to move specified"
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"move"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"argc"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"flags"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"destination"
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"argv%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
name|warnx
argument_list|(
literal|"can't move object(s):  %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gvinum_printconfig
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|printconfig
argument_list|(
name|stdout
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gvinum_parityop
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|int
name|rebuild
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
modifier|*
name|op
decl_stmt|;
if|if
condition|(
name|rebuild
condition|)
block|{
name|op
operator|=
literal|"rebuildparity"
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
literal|"checkparity"
expr_stmt|;
block|}
name|optreset
operator|=
literal|1
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"fv"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'f'
case|:
name|flags
operator||=
name|GV_FLAG_F
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|flags
operator||=
name|GV_FLAG_V
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"invalid flag '%c'"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"usage: %s [-f] [-v]<plex>"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"rebuild"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|rebuild
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"flags"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"plex"
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
condition|)
name|warnx
argument_list|(
literal|"%s\n"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a RAID-5 volume. */
end_comment

begin_function
specifier|static
name|void
name|gvinum_raid5
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"usage:\traid5 [-fv] [-s stripesize] [-n name] drives\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|create_volume
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"raid5"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gvinum_rename
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|j
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
name|optreset
operator|=
literal|1
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'r'
case|:
name|flags
operator||=
name|GV_FLAG_R
expr_stmt|;
break|break;
default|default:
return|return;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
block|}
switch|switch
condition|(
name|argc
condition|)
block|{
case|case
literal|0
case|:
name|warnx
argument_list|(
literal|"no object to rename specified"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
name|warnx
argument_list|(
literal|"no new name specified"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
break|break;
default|default:
name|warnx
argument_list|(
literal|"more than one new name specified"
argument_list|)
expr_stmt|;
return|return;
block|}
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"rename"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"flags"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"object"
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"newname"
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
name|warnx
argument_list|(
literal|"can't rename object:  %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gvinum_rm
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|optreset
operator|=
literal|1
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"rf"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'f'
case|:
name|flags
operator||=
name|GV_FLAG_F
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|flags
operator||=
name|GV_FLAG_R
expr_stmt|;
break|break;
default|default:
return|return;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"remove"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"argc"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"flags"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"argv%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't remove: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gvinum_resetconfig
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
name|reply
index|[
literal|32
index|]
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'f'
case|:
name|flags
operator||=
name|GV_FLAG_F
expr_stmt|;
break|break;
default|default:
name|warn
argument_list|(
literal|"invalid flag: %c"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|GV_FLAG_F
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"Please enter this command from a tty device\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|" WARNING!  This command will completely wipe out"
literal|" your gvinum configuration.\n"
literal|" All data will be lost.  If you really want to do this,"
literal|" enter the text\n\n"
literal|" NO FUTURE\n"
literal|" Enter text -> "
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|reply
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|reply
argument_list|,
literal|"NO FUTURE\n"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n No change\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"resetconfig"
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't reset config: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gvinum configuration obliterated\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gvinum_saveconfig
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"saveconfig"
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
name|warnx
argument_list|(
literal|"can't save configuration: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gvinum_start
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|int
name|i
decl_stmt|,
name|initsize
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
comment|/* 'start' with no arguments is a no-op. */
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
return|return;
name|initsize
operator|=
literal|0
expr_stmt|;
name|optreset
operator|=
literal|1
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"S"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'S'
case|:
name|initsize
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
operator|!
name|initsize
condition|)
name|initsize
operator|=
literal|512
expr_stmt|;
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"start"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"argc"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"initsize"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|initsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"argv%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't start: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gvinum_stop
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|fileid
decl_stmt|;
name|fileid
operator|=
name|kldfind
argument_list|(
name|GVINUMKLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileid
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|modfind
argument_list|(
name|GVINUMMOD
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"cannot find "
name|GVINUMKLD
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * This little hack prevents that we end up in an infinite loop in 	 * g_unload_class().  gv_unload() will return EAGAIN so that the GEOM 	 * event thread will be free for the g_wither_geom() call from 	 * gv_unload().  It's silly, but it works. 	 */
name|printf
argument_list|(
literal|"unloading "
name|GVINUMKLD
literal|" kernel module... "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|kldunload
argument_list|(
name|fileid
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|)
condition|)
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|kldunload
argument_list|(
name|fileid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" failed!\n"
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"cannot unload "
name|GVINUMKLD
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a striped volume. */
end_comment

begin_function
specifier|static
name|void
name|gvinum_stripe
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"usage:\tstripe [-fv] [-n name] drives\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|create_volume
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"stripe"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Grow a subdisk by adding disk backed by provider. */
end_comment

begin_function
specifier|static
name|void
name|gvinum_grow
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|char
modifier|*
name|drive
decl_stmt|,
modifier|*
name|sdname
decl_stmt|;
name|char
name|sdprefix
index|[
name|GV_MAXSDNAME
index|]
decl_stmt|;
name|struct
name|gv_drive
modifier|*
name|d
decl_stmt|;
name|struct
name|gv_sd
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|int
name|drives
decl_stmt|,
name|volumes
decl_stmt|,
name|plexes
decl_stmt|,
name|subdisks
decl_stmt|,
name|flags
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|drives
operator|=
name|volumes
operator|=
name|plexes
operator|=
name|subdisks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|warnx
argument_list|(
literal|"usage:\tgrow plex drive\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|gv_alloc_sd
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"unable to create subdisk"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|=
name|gv_alloc_drive
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"unable to create drive"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Lookup device and set an appropriate drive name. */
name|drive
operator|=
name|find_drive
argument_list|()
expr_stmt|;
if|if
condition|(
name|drive
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"unable to find an appropriate drive name"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return;
block|}
name|strlcpy
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|drive
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|copy_device
argument_list|(
name|d
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|drives
operator|=
literal|1
expr_stmt|;
comment|/* We try to use the plex name as basis for the subdisk name. */
name|snprintf
argument_list|(
name|sdprefix
argument_list|,
sizeof|sizeof
argument_list|(
name|sdprefix
argument_list|)
argument_list|,
literal|"%s.s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sdname
operator|=
name|find_name
argument_list|(
name|sdprefix
argument_list|,
name|GV_TYPE_SD
argument_list|,
name|GV_MAXSDNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdname
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"unable to find an appropriate subdisk name"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|drive
argument_list|)
expr_stmt|;
return|return;
block|}
name|strlcpy
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|sdname
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sdname
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|s
operator|->
name|plex
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|plex
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|s
operator|->
name|drive
argument_list|,
name|d
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|drive
argument_list|)
argument_list|)
expr_stmt|;
name|subdisks
operator|=
literal|1
expr_stmt|;
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"create"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"flags"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"volumes"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|volumes
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"plexes"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|plexes
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"subdisks"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|subdisks
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"drives"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|&
name|drives
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"drive0"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"sd0"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"unable to grow plex: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return;
block|}
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parseline
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"create"
argument_list|)
condition|)
name|gvinum_create
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"exit"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"quit"
argument_list|)
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"attach"
argument_list|)
condition|)
name|gvinum_attach
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"detach"
argument_list|)
condition|)
name|gvinum_detach
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"concat"
argument_list|)
condition|)
name|gvinum_concat
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"grow"
argument_list|)
condition|)
name|gvinum_grow
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"help"
argument_list|)
condition|)
name|gvinum_help
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"list"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"l"
argument_list|)
condition|)
name|gvinum_list
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"ld"
argument_list|)
condition|)
name|gvinum_list
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"lp"
argument_list|)
condition|)
name|gvinum_list
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"ls"
argument_list|)
condition|)
name|gvinum_list
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"lv"
argument_list|)
condition|)
name|gvinum_list
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"mirror"
argument_list|)
condition|)
name|gvinum_mirror
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"move"
argument_list|)
condition|)
name|gvinum_move
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"mv"
argument_list|)
condition|)
name|gvinum_move
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"printconfig"
argument_list|)
condition|)
name|gvinum_printconfig
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"raid5"
argument_list|)
condition|)
name|gvinum_raid5
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"rename"
argument_list|)
condition|)
name|gvinum_rename
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"resetconfig"
argument_list|)
condition|)
name|gvinum_resetconfig
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"rm"
argument_list|)
condition|)
name|gvinum_rm
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"saveconfig"
argument_list|)
condition|)
name|gvinum_saveconfig
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"setstate"
argument_list|)
condition|)
name|gvinum_setstate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"start"
argument_list|)
condition|)
name|gvinum_start
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"stop"
argument_list|)
condition|)
name|gvinum_stop
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"stripe"
argument_list|)
condition|)
name|gvinum_stripe
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"checkparity"
argument_list|)
condition|)
name|gvinum_parityop
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"rebuildparity"
argument_list|)
condition|)
name|gvinum_parityop
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"unknown command '%s'\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The guts of printconfig.  This is called from gvinum_printconfig and from  * gvinum_create when called without an argument, in order to give the user  * something to edit.  */
end_comment

begin_function
specifier|static
name|void
name|printconfig
parameter_list|(
name|FILE
modifier|*
name|of
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|req
decl_stmt|;
name|struct
name|utsname
name|uname_s
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
name|buf
index|[
name|GV_CFG_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|uname
argument_list|(
operator|&
name|uname_s
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|req
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"VINUM"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"getconfig"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|req
argument_list|,
literal|"comment"
argument_list|,
operator|-
literal|1
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|gctl_rw_param
argument_list|(
name|req
argument_list|,
literal|"config"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't get configuration: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
return|return;
block|}
name|gctl_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"# Vinum configuration of %s, saved at %s"
argument_list|,
name|uname_s
operator|.
name|nodename
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|comment
operator|!=
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"# Current configuration:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

