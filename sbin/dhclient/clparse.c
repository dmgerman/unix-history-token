begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: clparse.c,v 1.18 2004/09/15 18:15:18 henning Exp $	*/
end_comment

begin_comment
comment|/* Parser for dhclient config and lease files... */
end_comment

begin_comment
comment|/*  * Copyright (c) 1997 The Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon<mellon@fugue.com> in cooperation with Vixie  * Enterprises.  To learn more about the Internet Software Consortium,  * see ``http://www.vix.com/isc''.  To learn more about Vixie  * Enterprises, see ``http://www.vix.com''.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_include
include|#
directive|include
file|"dhctoken.h"
end_include

begin_decl_stmt
name|struct
name|client_config
name|top_level_config
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|interface_info
modifier|*
name|dummy_interfaces
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|interface_info
modifier|*
name|ifi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|client_script_name
index|[]
init|=
literal|"/sbin/dhclient-script"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * client-conf-file :== client-declarations EOF  * client-declarations :==<nil>  *			 | client-declaration  *			 | client-declarations client-declaration  */
end_comment

begin_function
name|int
name|read_client_conf
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
name|struct
name|client_config
modifier|*
name|config
decl_stmt|;
name|new_parse
argument_list|(
name|path_dhclient_conf
argument_list|)
expr_stmt|;
comment|/* Set up the initial dhcp option universe. */
name|initialize_universes
argument_list|()
expr_stmt|;
comment|/* Initialize the top level client configuration. */
name|memset
argument_list|(
operator|&
name|top_level_config
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|top_level_config
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set some defaults... */
name|top_level_config
operator|.
name|timeout
operator|=
literal|60
expr_stmt|;
name|top_level_config
operator|.
name|select_interval
operator|=
literal|0
expr_stmt|;
name|top_level_config
operator|.
name|reboot_timeout
operator|=
literal|10
expr_stmt|;
name|top_level_config
operator|.
name|retry_interval
operator|=
literal|300
expr_stmt|;
name|top_level_config
operator|.
name|backoff_cutoff
operator|=
literal|15
expr_stmt|;
name|top_level_config
operator|.
name|initial_interval
operator|=
literal|3
expr_stmt|;
name|top_level_config
operator|.
name|bootp_policy
operator|=
name|ACCEPT
expr_stmt|;
name|top_level_config
operator|.
name|script_name
operator|=
name|client_script_name
expr_stmt|;
name|top_level_config
operator|.
name|requested_options
index|[
name|top_level_config
operator|.
name|requested_option_count
operator|++
index|]
operator|=
name|DHO_SUBNET_MASK
expr_stmt|;
name|top_level_config
operator|.
name|requested_options
index|[
name|top_level_config
operator|.
name|requested_option_count
operator|++
index|]
operator|=
name|DHO_BROADCAST_ADDRESS
expr_stmt|;
name|top_level_config
operator|.
name|requested_options
index|[
name|top_level_config
operator|.
name|requested_option_count
operator|++
index|]
operator|=
name|DHO_TIME_OFFSET
expr_stmt|;
name|top_level_config
operator|.
name|requested_options
index|[
name|top_level_config
operator|.
name|requested_option_count
operator|++
index|]
operator|=
name|DHO_CLASSLESS_ROUTES
expr_stmt|;
name|top_level_config
operator|.
name|requested_options
index|[
name|top_level_config
operator|.
name|requested_option_count
operator|++
index|]
operator|=
name|DHO_ROUTERS
expr_stmt|;
name|top_level_config
operator|.
name|requested_options
index|[
name|top_level_config
operator|.
name|requested_option_count
operator|++
index|]
operator|=
name|DHO_DOMAIN_NAME
expr_stmt|;
name|top_level_config
operator|.
name|requested_options
index|[
name|top_level_config
operator|.
name|requested_option_count
operator|++
index|]
operator|=
name|DHO_DOMAIN_NAME_SERVERS
expr_stmt|;
name|top_level_config
operator|.
name|requested_options
index|[
name|top_level_config
operator|.
name|requested_option_count
operator|++
index|]
operator|=
name|DHO_HOST_NAME
expr_stmt|;
if|if
condition|(
operator|(
name|cfile
operator|=
name|fopen
argument_list|(
name|path_dhclient_conf
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
do|do
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|EOF
condition|)
break|break;
name|parse_client_statement
argument_list|(
name|cfile
argument_list|,
name|NULL
argument_list|,
operator|&
name|top_level_config
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* Clear the peek buffer */
name|fclose
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set up state and config structures for clients that don't 	 * have per-interface configuration declarations. 	 */
name|config
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ifi
operator|->
name|client
condition|)
block|{
name|ifi
operator|->
name|client
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|client_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifi
operator|->
name|client
condition|)
name|error
argument_list|(
literal|"no memory for client state."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ifi
operator|->
name|client
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|ifi
operator|->
name|client
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ifi
operator|->
name|client
operator|->
name|config
condition|)
block|{
if|if
condition|(
operator|!
name|config
condition|)
block|{
name|config
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|client_config
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
condition|)
name|error
argument_list|(
literal|"no memory for client config."
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|config
argument_list|,
operator|&
name|top_level_config
argument_list|,
sizeof|sizeof
argument_list|(
name|top_level_config
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ifi
operator|->
name|client
operator|->
name|config
operator|=
name|config
expr_stmt|;
block|}
return|return
operator|(
operator|!
name|warnings_occurred
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lease-file :== client-lease-statements EOF  * client-lease-statements :==<nil>  *		     | client-lease-statements LEASE client-lease-statement  */
end_comment

begin_function
name|void
name|read_client_leases
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
name|new_parse
argument_list|(
name|path_dhclient_db
argument_list|)
expr_stmt|;
comment|/* Open the lease file.   If we can't open it, just return - 	   we can safely trust the server to remember our state. */
if|if
condition|(
operator|(
name|cfile
operator|=
name|fopen
argument_list|(
name|path_dhclient_db
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|token
operator|!=
name|LEASE
condition|)
block|{
name|warning
argument_list|(
literal|"Corrupt lease file - possible data loss!"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|parse_client_lease_statement
argument_list|(
name|cfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|fclose
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * client-declaration :==  *	SEND option-decl |  *	DEFAULT option-decl |  *	SUPERSEDE option-decl |  *	PREPEND option-decl |  *	APPEND option-decl |  *	hardware-declaration |  *	REQUEST option-list |  *	REQUIRE option-list |  *	TIMEOUT number |  *	RETRY number |  *	REBOOT number |  *	SELECT_TIMEOUT number |  *	SCRIPT string |  *	interface-declaration |  *	LEASE client-lease-statement |  *	ALIAS client-lease-statement  */
end_comment

begin_function
name|void
name|parse_client_statement
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|,
name|struct
name|interface_info
modifier|*
name|ip
parameter_list|,
name|struct
name|client_config
modifier|*
name|config
parameter_list|)
block|{
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|option
modifier|*
name|option
decl_stmt|;
switch|switch
condition|(
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
condition|)
block|{
case|case
name|SEND
case|:
name|parse_option_decl
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|send_options
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|DEFAULT
case|:
name|option
operator|=
name|parse_option_decl
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|defaults
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
condition|)
name|config
operator|->
name|default_actions
index|[
name|option
operator|->
name|code
index|]
operator|=
name|ACTION_DEFAULT
expr_stmt|;
return|return;
case|case
name|SUPERSEDE
case|:
name|option
operator|=
name|parse_option_decl
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|defaults
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
condition|)
name|config
operator|->
name|default_actions
index|[
name|option
operator|->
name|code
index|]
operator|=
name|ACTION_SUPERSEDE
expr_stmt|;
return|return;
case|case
name|APPEND
case|:
name|option
operator|=
name|parse_option_decl
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|defaults
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
condition|)
name|config
operator|->
name|default_actions
index|[
name|option
operator|->
name|code
index|]
operator|=
name|ACTION_APPEND
expr_stmt|;
return|return;
case|case
name|PREPEND
case|:
name|option
operator|=
name|parse_option_decl
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|defaults
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
condition|)
name|config
operator|->
name|default_actions
index|[
name|option
operator|->
name|code
index|]
operator|=
name|ACTION_PREPEND
expr_stmt|;
return|return;
case|case
name|MEDIA
case|:
name|parse_string_list
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|media
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|HARDWARE
case|:
if|if
condition|(
name|ip
condition|)
name|parse_hardware_param
argument_list|(
name|cfile
argument_list|,
operator|&
name|ip
operator|->
name|hw_address
argument_list|)
expr_stmt|;
else|else
block|{
name|parse_warn
argument_list|(
literal|"hardware address parameter %s"
argument_list|,
literal|"not allowed here."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|REQUEST
case|:
name|config
operator|->
name|requested_option_count
operator|=
name|parse_option_list
argument_list|(
name|cfile
argument_list|,
name|config
operator|->
name|requested_options
argument_list|)
expr_stmt|;
return|return;
case|case
name|REQUIRE
case|:
name|memset
argument_list|(
name|config
operator|->
name|required_options
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|config
operator|->
name|required_options
argument_list|)
argument_list|)
expr_stmt|;
name|parse_option_list
argument_list|(
name|cfile
argument_list|,
name|config
operator|->
name|required_options
argument_list|)
expr_stmt|;
return|return;
case|case
name|TIMEOUT
case|:
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|timeout
argument_list|)
expr_stmt|;
return|return;
case|case
name|RETRY
case|:
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|retry_interval
argument_list|)
expr_stmt|;
return|return;
case|case
name|SELECT_TIMEOUT
case|:
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|select_interval
argument_list|)
expr_stmt|;
return|return;
case|case
name|REBOOT
case|:
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|reboot_timeout
argument_list|)
expr_stmt|;
return|return;
case|case
name|BACKOFF_CUTOFF
case|:
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|backoff_cutoff
argument_list|)
expr_stmt|;
return|return;
case|case
name|INITIAL_INTERVAL
case|:
name|parse_lease_time
argument_list|(
name|cfile
argument_list|,
operator|&
name|config
operator|->
name|initial_interval
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCRIPT
case|:
name|config
operator|->
name|script_name
operator|=
name|parse_string
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|INTERFACE
case|:
if|if
condition|(
name|ip
condition|)
name|parse_warn
argument_list|(
literal|"nested interface declaration."
argument_list|)
expr_stmt|;
name|parse_interface_declaration
argument_list|(
name|cfile
argument_list|,
name|config
argument_list|)
expr_stmt|;
return|return;
case|case
name|LEASE
case|:
name|parse_client_lease_statement
argument_list|(
name|cfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|ALIAS
case|:
name|parse_client_lease_statement
argument_list|(
name|cfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
case|case
name|REJECT
case|:
name|parse_reject_statement
argument_list|(
name|cfile
argument_list|,
name|config
argument_list|)
expr_stmt|;
return|return;
default|default:
name|parse_warn
argument_list|(
literal|"expecting a statement."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"semicolon expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|parse_X
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|,
name|u_int8_t
modifier|*
name|buf
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|len
decl_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|NUMBER_OR_NAME
operator|||
name|token
operator|==
name|NUMBER
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
operator|&&
name|token
operator|!=
name|NUMBER_OR_NAME
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting hexadecimal constant."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|convert_num
argument_list|(
operator|&
name|buf
index|[
name|len
index|]
argument_list|,
name|val
argument_list|,
literal|16
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|++
operator|>
name|max
condition|)
block|{
name|parse_warn
argument_list|(
literal|"hexadecimal constant too long."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|COLON
condition|)
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|COLON
condition|)
do|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|STRING
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|>
name|max
condition|)
block|{
name|parse_warn
argument_list|(
literal|"string constant too long."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse_warn
argument_list|(
literal|"expecting string or hexadecimal data"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * option-list :== option_name |  *		   option_list COMMA option_name  */
end_comment

begin_function
name|int
name|parse_option_list
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|,
name|u_int8_t
modifier|*
name|list
parameter_list|)
block|{
name|int
name|ix
decl_stmt|,
name|i
decl_stmt|;
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expected option name."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|dhcp_options
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|val
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|256
condition|)
block|{
name|parse_warn
argument_list|(
literal|"%s: unexpected option name."
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|list
index|[
name|ix
operator|++
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ix
operator|==
literal|256
condition|)
block|{
name|parse_warn
argument_list|(
literal|"%s: too many options."
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting semicolon."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ix
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * interface-declaration :==  *	INTERFACE string LBRACE client-declarations RBRACE  */
end_comment

begin_function
name|void
name|parse_interface_declaration
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|,
name|struct
name|client_config
modifier|*
name|outer_config
parameter_list|)
block|{
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting interface name (in quotes)."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|=
name|interface_or_dummy
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|client
condition|)
name|make_client_state
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|config
condition|)
name|make_client_config
argument_list|(
name|ip
argument_list|,
name|outer_config
argument_list|)
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LBRACE
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting left brace."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|EOF
condition|)
block|{
name|parse_warn
argument_list|(
literal|"unterminated interface declaration."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|token
operator|==
name|RBRACE
condition|)
break|break;
name|parse_client_statement
argument_list|(
name|cfile
argument_list|,
name|ip
argument_list|,
name|ip
operator|->
name|client
operator|->
name|config
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|interface_info
modifier|*
name|interface_or_dummy
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
comment|/* Find the interface (if any) that matches the name. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ifi
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|ifi
operator|)
return|;
comment|/* If it's not a real interface, see if it's on the dummy list. */
for|for
control|(
name|ip
operator|=
name|dummy_interfaces
init|;
name|ip
condition|;
name|ip
operator|=
name|ip
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ip
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|ip
operator|)
return|;
comment|/* 	 * If we didn't find an interface, make a dummy interface as a 	 * placeholder. 	 */
name|ip
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
condition|)
name|error
argument_list|(
literal|"Insufficient memory to record interface %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ip
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|ip
operator|->
name|next
operator|=
name|dummy_interfaces
expr_stmt|;
name|dummy_interfaces
operator|=
name|ip
expr_stmt|;
return|return
operator|(
name|ip
operator|)
return|;
block|}
end_function

begin_function
name|void
name|make_client_state
parameter_list|(
name|struct
name|interface_info
modifier|*
name|ip
parameter_list|)
block|{
name|ip
operator|->
name|client
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|ip
operator|->
name|client
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|client
condition|)
name|error
argument_list|(
literal|"no memory for state on %s"
argument_list|,
name|ip
operator|->
name|name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ip
operator|->
name|client
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|ip
operator|->
name|client
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|make_client_config
parameter_list|(
name|struct
name|interface_info
modifier|*
name|ip
parameter_list|,
name|struct
name|client_config
modifier|*
name|config
parameter_list|)
block|{
name|ip
operator|->
name|client
operator|->
name|config
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|client_config
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|->
name|client
operator|->
name|config
condition|)
name|error
argument_list|(
literal|"no memory for config for %s"
argument_list|,
name|ip
operator|->
name|name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ip
operator|->
name|client
operator|->
name|config
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|ip
operator|->
name|client
operator|->
name|config
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ip
operator|->
name|client
operator|->
name|config
argument_list|,
name|config
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|config
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * client-lease-statement :==  *	RBRACE client-lease-declarations LBRACE  *  *	client-lease-declarations :==  *<nil> |  *		client-lease-declaration |  *		client-lease-declarations client-lease-declaration  */
end_comment

begin_function
name|void
name|parse_client_lease_statement
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|,
name|int
name|is_static
parameter_list|)
block|{
name|struct
name|client_lease
modifier|*
name|lease
decl_stmt|,
modifier|*
name|lp
decl_stmt|,
modifier|*
name|pl
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|LBRACE
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting left brace."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|lease
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|client_lease
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lease
condition|)
name|error
argument_list|(
literal|"no memory for lease."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|lease
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lease
argument_list|)
argument_list|)
expr_stmt|;
name|lease
operator|->
name|is_static
operator|=
name|is_static
expr_stmt|;
name|ip
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|EOF
condition|)
block|{
name|parse_warn
argument_list|(
literal|"unterminated lease declaration."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|token
operator|==
name|RBRACE
condition|)
break|break;
name|parse_client_lease_declaration
argument_list|(
name|cfile
argument_list|,
name|lease
argument_list|,
operator|&
name|ip
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* If the lease declaration didn't include an interface 	 * declaration that we recognized, it's of no use to us. 	 */
if|if
condition|(
operator|!
name|ip
condition|)
block|{
name|free_client_lease
argument_list|(
name|lease
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make sure there's a client state structure... */
if|if
condition|(
operator|!
name|ip
operator|->
name|client
condition|)
name|make_client_state
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* If this is an alias lease, it doesn't need to be sorted in. */
if|if
condition|(
name|is_static
operator|==
literal|2
condition|)
block|{
name|ip
operator|->
name|client
operator|->
name|alias
operator|=
name|lease
expr_stmt|;
return|return;
block|}
comment|/* 	 * The new lease may supersede a lease that's not the active 	 * lease but is still on the lease list, so scan the lease list 	 * looking for a lease with the same address, and if we find it, 	 * toss it. 	 */
name|pl
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|ip
operator|->
name|client
operator|->
name|leases
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|address
operator|.
name|len
operator|==
name|lease
operator|->
name|address
operator|.
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|lp
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|address
operator|.
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|pl
condition|)
name|pl
operator|->
name|next
operator|=
name|lp
operator|->
name|next
expr_stmt|;
else|else
name|ip
operator|->
name|client
operator|->
name|leases
operator|=
name|lp
operator|->
name|next
expr_stmt|;
name|free_client_lease
argument_list|(
name|lp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * If this is a preloaded lease, just put it on the list of 	 * recorded leases - don't make it the active lease. 	 */
if|if
condition|(
name|is_static
condition|)
block|{
name|lease
operator|->
name|next
operator|=
name|ip
operator|->
name|client
operator|->
name|leases
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|leases
operator|=
name|lease
expr_stmt|;
return|return;
block|}
comment|/* 	 * The last lease in the lease file on a particular interface is 	 * the active lease for that interface.    Of course, we don't 	 * know what the last lease in the file is until we've parsed 	 * the whole file, so at this point, we assume that the lease we 	 * just parsed is the active lease for its interface.   If 	 * there's already an active lease for the interface, and this 	 * lease is for the same ip address, then we just toss the old 	 * active lease and replace it with this one.   If this lease is 	 * for a different address, then if the old active lease has 	 * expired, we dump it; if not, we put it on the list of leases 	 * for this interface which are still valid but no longer 	 * active. 	 */
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|expiry
operator|<
name|cur_time
condition|)
name|free_client_lease
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|address
operator|.
name|len
operator|==
name|lease
operator|->
name|address
operator|.
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|address
operator|.
name|iabuf
argument_list|,
name|lease
operator|->
name|address
operator|.
name|len
argument_list|)
condition|)
name|free_client_lease
argument_list|(
name|ip
operator|->
name|client
operator|->
name|active
argument_list|)
expr_stmt|;
else|else
block|{
name|ip
operator|->
name|client
operator|->
name|active
operator|->
name|next
operator|=
name|ip
operator|->
name|client
operator|->
name|leases
expr_stmt|;
name|ip
operator|->
name|client
operator|->
name|leases
operator|=
name|ip
operator|->
name|client
operator|->
name|active
expr_stmt|;
block|}
block|}
name|ip
operator|->
name|client
operator|->
name|active
operator|=
name|lease
expr_stmt|;
comment|/* Phew. */
block|}
end_function

begin_comment
comment|/*  * client-lease-declaration :==  *	BOOTP |  *	INTERFACE string |  *	FIXED_ADDR ip_address |  *	FILENAME string |  *	SERVER_NAME string |  *	OPTION option-decl |  *	RENEW time-decl |  *	REBIND time-decl |  *	EXPIRE time-decl  */
end_comment

begin_function
name|void
name|parse_client_lease_declaration
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|,
name|struct
name|client_lease
modifier|*
name|lease
parameter_list|,
name|struct
name|interface_info
modifier|*
modifier|*
name|ipp
parameter_list|)
block|{
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|interface_info
modifier|*
name|ip
decl_stmt|;
switch|switch
condition|(
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
condition|)
block|{
case|case
name|BOOTP
case|:
name|lease
operator|->
name|is_bootp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|INTERFACE
case|:
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting interface name (in quotes)."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|ip
operator|=
name|interface_or_dummy
argument_list|(
name|val
argument_list|)
expr_stmt|;
operator|*
name|ipp
operator|=
name|ip
expr_stmt|;
break|break;
case|case
name|FIXED_ADDR
case|:
if|if
condition|(
operator|!
name|parse_ip_addr
argument_list|(
name|cfile
argument_list|,
operator|&
name|lease
operator|->
name|address
argument_list|)
condition|)
return|return;
break|break;
case|case
name|MEDIUM
case|:
name|parse_string_list
argument_list|(
name|cfile
argument_list|,
operator|&
name|lease
operator|->
name|medium
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|FILENAME
case|:
name|lease
operator|->
name|filename
operator|=
name|parse_string
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|SERVER_NAME
case|:
name|lease
operator|->
name|server_name
operator|=
name|parse_string
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|RENEW
case|:
name|lease
operator|->
name|renewal
operator|=
name|parse_date
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|REBIND
case|:
name|lease
operator|->
name|rebind
operator|=
name|parse_date
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|EXPIRE
case|:
name|lease
operator|->
name|expiry
operator|=
name|parse_date
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
case|case
name|OPTION
case|:
name|parse_option_decl
argument_list|(
name|cfile
argument_list|,
name|lease
operator|->
name|options
argument_list|)
expr_stmt|;
return|return;
default|default:
name|parse_warn
argument_list|(
literal|"expecting lease declaration."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting semicolon."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|option
modifier|*
name|parse_option_decl
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|,
name|struct
name|option_data
modifier|*
name|options
parameter_list|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
name|u_int8_t
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|u_int8_t
name|hunkbuf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|hunkix
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|vendor
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|struct
name|universe
modifier|*
name|universe
decl_stmt|;
name|struct
name|option
modifier|*
name|option
decl_stmt|;
name|struct
name|iaddr
name|ip_addr
decl_stmt|;
name|u_int8_t
modifier|*
name|dp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|nul_term
init|=
literal|0
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting identifier after option keyword."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|vendor
operator|=
name|strdup
argument_list|(
name|val
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"no memory for vendor information."
argument_list|)
expr_stmt|;
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|DOT
condition|)
block|{
comment|/* Go ahead and take the DOT token... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
comment|/* The next token should be an identifier... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting identifier after '.'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Look up the option name hash table for the specified 		   vendor. */
name|universe
operator|=
operator|(
operator|(
expr|struct
name|universe
operator|*
operator|)
name|hash_lookup
argument_list|(
operator|&
name|universe_hash
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|vendor
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
comment|/* If it's not there, we can't parse the rest of the 		   declaration. */
if|if
condition|(
operator|!
name|universe
condition|)
block|{
name|parse_warn
argument_list|(
literal|"no vendor named %s."
argument_list|,
name|vendor
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Use the default hash table, which contains all the 		   standard dhcp option names. */
name|val
operator|=
name|vendor
expr_stmt|;
name|universe
operator|=
operator|&
name|dhcp_universe
expr_stmt|;
block|}
comment|/* Look up the actual option info... */
name|option
operator|=
operator|(
expr|struct
name|option
operator|*
operator|)
name|hash_lookup
argument_list|(
name|universe
operator|->
name|hash
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we didn't get an option structure, it's an undefined option. */
if|if
condition|(
operator|!
name|option
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|vendor
condition|)
name|parse_warn
argument_list|(
literal|"no option named %s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|parse_warn
argument_list|(
literal|"no option named %s for vendor %s"
argument_list|,
name|val
argument_list|,
name|vendor
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Free the initial identifier token. */
name|free
argument_list|(
name|vendor
argument_list|)
expr_stmt|;
comment|/* Parse the option data... */
do|do
block|{
for|for
control|(
name|fmt
operator|=
name|option
operator|->
name|format
init|;
operator|*
name|fmt
condition|;
name|fmt
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'A'
condition|)
break|break;
switch|switch
condition|(
operator|*
name|fmt
condition|)
block|{
case|case
literal|'X'
case|:
name|len
operator|=
name|parse_X
argument_list|(
name|cfile
argument_list|,
operator|&
name|hunkbuf
index|[
name|hunkix
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|hunkbuf
argument_list|)
operator|-
name|hunkix
argument_list|)
expr_stmt|;
name|hunkix
operator|+=
name|len
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Text string... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting string."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|hunkix
operator|+
name|len
operator|+
literal|1
operator|>
sizeof|sizeof
argument_list|(
name|hunkbuf
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
literal|"option data buffer %s"
argument_list|,
literal|"overflow"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|hunkbuf
index|[
name|hunkix
index|]
argument_list|,
name|val
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nul_term
operator|=
literal|1
expr_stmt|;
name|hunkix
operator|+=
name|len
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* IP address. */
if|if
condition|(
operator|!
name|parse_ip_addr
argument_list|(
name|cfile
argument_list|,
operator|&
name|ip_addr
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|len
operator|=
name|ip_addr
operator|.
name|len
expr_stmt|;
name|dp
operator|=
name|ip_addr
operator|.
name|iabuf
expr_stmt|;
name|alloc
label|:
if|if
condition|(
name|hunkix
operator|+
name|len
operator|>
sizeof|sizeof
argument_list|(
name|hunkbuf
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
literal|"option data buffer "
literal|"overflow"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|hunkbuf
index|[
name|hunkix
index|]
argument_list|,
name|dp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|hunkix
operator|+=
name|len
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Unsigned 32-bit integer... */
case|case
literal|'l'
case|:
comment|/* Signed 32-bit integer... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|need_number
label|:
name|parse_warn
argument_list|(
literal|"expecting number."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|convert_num
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
name|dp
operator|=
name|buf
expr_stmt|;
goto|goto
name|alloc
goto|;
case|case
literal|'s'
case|:
comment|/* Signed 16-bit integer. */
case|case
literal|'S'
case|:
comment|/* Unsigned 16-bit integer. */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
goto|goto
name|need_number
goto|;
name|convert_num
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
name|dp
operator|=
name|buf
expr_stmt|;
goto|goto
name|alloc
goto|;
case|case
literal|'b'
case|:
comment|/* Signed 8-bit integer. */
case|case
literal|'B'
case|:
comment|/* Unsigned 8-bit integer. */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
goto|goto
name|need_number
goto|;
name|convert_num
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
name|dp
operator|=
name|buf
expr_stmt|;
goto|goto
name|alloc
goto|;
case|case
literal|'f'
case|:
comment|/* Boolean flag. */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_identifier
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting identifier."
argument_list|)
expr_stmt|;
name|bad_flag
label|:
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"true"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"on"
argument_list|)
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"false"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|val
argument_list|,
literal|"off"
argument_list|)
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|parse_warn
argument_list|(
literal|"expecting boolean."
argument_list|)
expr_stmt|;
goto|goto
name|bad_flag
goto|;
block|}
name|len
operator|=
literal|1
expr_stmt|;
name|dp
operator|=
name|buf
expr_stmt|;
goto|goto
name|alloc
goto|;
default|default:
name|warning
argument_list|(
literal|"Bad format %c in parse_option_param."
argument_list|,
operator|*
name|fmt
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|fmt
operator|==
literal|'A'
operator|&&
name|token
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"semicolon expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|options
index|[
name|option
operator|->
name|code
index|]
operator|.
name|data
operator|=
name|malloc
argument_list|(
name|hunkix
operator|+
name|nul_term
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|options
index|[
name|option
operator|->
name|code
index|]
operator|.
name|data
condition|)
name|error
argument_list|(
literal|"out of memory allocating option data."
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|options
index|[
name|option
operator|->
name|code
index|]
operator|.
name|data
argument_list|,
name|hunkbuf
argument_list|,
name|hunkix
operator|+
name|nul_term
argument_list|)
expr_stmt|;
name|options
index|[
name|option
operator|->
name|code
index|]
operator|.
name|len
operator|=
name|hunkix
expr_stmt|;
return|return
operator|(
name|option
operator|)
return|;
block|}
end_function

begin_function
name|void
name|parse_string_list
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|,
name|struct
name|string_list
modifier|*
modifier|*
name|lp
parameter_list|,
name|int
name|multiple
parameter_list|)
block|{
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|string_list
modifier|*
name|cur
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
comment|/* Find the last medium in the media list. */
if|if
condition|(
operator|*
name|lp
condition|)
for|for
control|(
name|cur
operator|=
operator|*
name|lp
init|;
name|cur
operator|->
name|next
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
empty_stmt|;
comment|/* nothing */
else|else
name|cur
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
literal|"Expecting media options."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmp
operator|=
name|new_string_list
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"no memory for string list entry."
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|tmp
operator|->
name|string
argument_list|,
name|val
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Store this medium at the end of the media list. */
if|if
condition|(
name|cur
condition|)
name|cur
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
else|else
operator|*
name|lp
operator|=
name|tmp
expr_stmt|;
name|cur
operator|=
name|tmp
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|multiple
operator|&&
name|token
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting semicolon."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|parse_reject_statement
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|,
name|struct
name|client_config
modifier|*
name|config
parameter_list|)
block|{
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|iaddr
name|addr
decl_stmt|;
name|struct
name|iaddrlist
modifier|*
name|list
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|parse_ip_addr
argument_list|(
name|cfile
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting IP address."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|list
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iaddrlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
name|error
argument_list|(
literal|"no memory for reject list!"
argument_list|)
expr_stmt|;
name|list
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|list
operator|->
name|next
operator|=
name|config
operator|->
name|reject_list
expr_stmt|;
name|config
operator|->
name|reject_list
operator|=
name|list
expr_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting semicolon."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

