begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: parse.c,v 1.11 2004/05/05 23:07:47 deraadt Exp $	*/
end_comment

begin_comment
comment|/* Common parser code for dhcpd and dhclient. */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995, 1996, 1997, 1998 The Internet Software Consortium.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of The Internet Software Consortium nor the names  *    of its contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND  * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This software has been written for the Internet Software Consortium  * by Ted Lemon<mellon@fugue.com> in cooperation with Vixie  * Enterprises.  To learn more about the Internet Software Consortium,  * see ``http://www.vix.com/isc''.  To learn more about Vixie  * Enterprises, see ``http://www.vix.com''.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"dhcpd.h"
end_include

begin_include
include|#
directive|include
file|"dhctoken.h"
end_include

begin_comment
comment|/* Skip to the semicolon ending the current statement.   If we encounter  * braces, the matching closing brace terminates the statement.   If we  * encounter a right brace but haven't encountered a left brace, return  * leaving the brace in the token buffer for the caller.   If we see a  * semicolon and haven't seen a left brace, return.   This lets us skip  * over:  *  *	statement;  *	statement foo bar { }  *	statement foo bar { statement { } }  *	statement}  *  *	...et cetera.  */
end_comment

begin_function
name|void
name|skip_to_semi
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|)
block|{
name|int
name|brace_count
init|=
literal|0
decl_stmt|,
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
do|do
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|RBRACE
condition|)
block|{
if|if
condition|(
name|brace_count
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|brace_count
condition|)
return|return;
block|}
else|else
return|return;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|LBRACE
condition|)
block|{
name|brace_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|SEMI
operator|&&
operator|!
name|brace_count
condition|)
block|{
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
literal|'\n'
condition|)
block|{
comment|/* 			 * EOL only happens when parsing 			 * /etc/resolv.conf, and we treat it like a 			 * semicolon because the resolv.conf file is 			 * line-oriented. 			 */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|!=
name|EOF
condition|)
do|;
block|}
end_function

begin_function
name|int
name|parse_semi
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|)
block|{
name|int
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"semicolon expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * string-parameter :== STRING SEMI  */
end_comment

begin_function
name|char
modifier|*
name|parse_string
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|)
block|{
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|size_t
name|valsize
decl_stmt|;
name|int
name|token
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
condition|)
block|{
name|parse_warn
argument_list|(
literal|"filename must be a string"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|valsize
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|malloc
argument_list|(
name|valsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|error
argument_list|(
literal|"no memory for string %s."
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|val
argument_list|,
name|valsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_semi
argument_list|(
name|cfile
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
name|int
name|parse_ip_addr
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|,
name|struct
name|iaddr
modifier|*
name|addr
parameter_list|)
block|{
name|addr
operator|->
name|len
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|parse_numeric_aggregate
argument_list|(
name|cfile
argument_list|,
name|addr
operator|->
name|iabuf
argument_list|,
operator|&
name|addr
operator|->
name|len
argument_list|,
name|DOT
argument_list|,
literal|10
argument_list|,
literal|8
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * hardware-parameter :== HARDWARE ETHERNET csns SEMI  * csns :== NUMBER | csns COLON NUMBER  */
end_comment

begin_function
name|void
name|parse_hardware_param
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|,
name|struct
name|hardware
modifier|*
name|hardware
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|token
decl_stmt|,
name|hlen
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|ETHERNET
case|:
name|hardware
operator|->
name|htype
operator|=
name|HTYPE_ETHER
expr_stmt|;
break|break;
case|case
name|TOKEN_RING
case|:
name|hardware
operator|->
name|htype
operator|=
name|HTYPE_IEEE802
expr_stmt|;
break|break;
case|case
name|FDDI
case|:
name|hardware
operator|->
name|htype
operator|=
name|HTYPE_FDDI
expr_stmt|;
break|break;
default|default:
name|parse_warn
argument_list|(
literal|"expecting a network hardware type"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Parse the hardware address information.   Technically, it 	 * would make a lot of sense to restrict the length of the data 	 * we'll accept here to the length of a particular hardware 	 * address type.   Unfortunately, there are some broken clients 	 * out there that put bogus data in the chaddr buffer, and we 	 * accept that data in the lease file rather than simply failing 	 * on such clients.   Yuck. 	 */
name|hlen
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|parse_numeric_aggregate
argument_list|(
name|cfile
argument_list|,
name|NULL
argument_list|,
operator|&
name|hlen
argument_list|,
name|COLON
argument_list|,
literal|16
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return;
if|if
condition|(
name|hlen
operator|>
sizeof|sizeof
argument_list|(
name|hardware
operator|->
name|haddr
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|parse_warn
argument_list|(
literal|"hardware address too long"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hardware
operator|->
name|hlen
operator|=
name|hlen
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|hardware
operator|->
name|haddr
index|[
literal|0
index|]
argument_list|,
name|t
argument_list|,
name|hardware
operator|->
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
name|hardware
operator|->
name|haddr
argument_list|)
condition|)
name|memset
argument_list|(
operator|&
name|hardware
operator|->
name|haddr
index|[
name|hlen
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hardware
operator|->
name|haddr
argument_list|)
operator|-
name|hlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting semicolon."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * lease-time :== NUMBER SEMI  */
end_comment

begin_function
name|void
name|parse_lease_time
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|,
name|time_t
modifier|*
name|timep
parameter_list|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|token
decl_stmt|;
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"Expecting numeric lease time"
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|convert_num
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|timep
argument_list|,
name|val
argument_list|,
literal|10
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* Unswap the number - convert_num returns stuff in NBO. */
operator|*
name|timep
operator|=
name|ntohl
argument_list|(
operator|*
name|timep
argument_list|)
expr_stmt|;
comment|/* XXX */
name|parse_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * No BNF for numeric aggregates - that's defined by the caller.  What  * this function does is to parse a sequence of numbers separated by the  * token specified in separator.  If max is zero, any number of numbers  * will be parsed; otherwise, exactly max numbers are expected.  Base  * and size tell us how to internalize the numbers once they've been  * tokenized.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|parse_numeric_aggregate
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|max
parameter_list|,
name|int
name|separator
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|bufp
init|=
name|buf
decl_stmt|,
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|int
name|token
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|size_t
name|valsize
decl_stmt|;
name|pair
name|c
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|lbufp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|bufp
operator|&&
operator|*
name|max
condition|)
block|{
name|lbufp
operator|=
name|bufp
operator|=
name|malloc
argument_list|(
operator|*
name|max
operator|*
name|size
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
name|error
argument_list|(
literal|"can't allocate space for numeric aggregate"
argument_list|)
expr_stmt|;
block|}
else|else
name|s
operator|=
name|bufp
expr_stmt|;
do|do
block|{
if|if
condition|(
name|count
condition|)
block|{
name|token
operator|=
name|peek_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|separator
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|max
condition|)
break|break;
if|if
condition|(
name|token
operator|!=
name|RBRACE
operator|&&
name|token
operator|!=
name|LBRACE
condition|)
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
name|parse_warn
argument_list|(
literal|"too few numbers."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lbufp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|EOF
condition|)
block|{
name|parse_warn
argument_list|(
literal|"unexpected end of file"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Allow NUMBER_OR_NAME if base is 16. */
if|if
condition|(
name|token
operator|!=
name|NUMBER
operator|&&
operator|(
name|base
operator|!=
literal|16
operator|||
name|token
operator|!=
name|NUMBER_OR_NAME
operator|)
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expecting numeric value."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lbufp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 		 * If we can, convert the number now; otherwise, build a 		 * linked list of all the numbers. 		 */
if|if
condition|(
name|s
condition|)
block|{
name|convert_num
argument_list|(
name|s
argument_list|,
name|val
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|s
operator|+=
name|size
operator|/
literal|8
expr_stmt|;
block|}
else|else
block|{
name|valsize
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
expr_stmt|;
name|t
operator|=
name|malloc
argument_list|(
name|valsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|error
argument_list|(
literal|"no temp space for number."
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|t
argument_list|,
name|val
argument_list|,
name|valsize
argument_list|)
expr_stmt|;
name|c
operator|=
name|cons
argument_list|(
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|++
name|count
operator|!=
operator|*
name|max
condition|)
do|;
comment|/* If we had to cons up a list, convert it now. */
if|if
condition|(
name|c
condition|)
block|{
name|free
argument_list|(
name|lbufp
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|malloc
argument_list|(
name|count
operator|*
name|size
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
name|error
argument_list|(
literal|"can't allocate space for numeric aggregate."
argument_list|)
expr_stmt|;
name|s
operator|=
name|bufp
operator|+
name|count
operator|-
name|size
operator|/
literal|8
expr_stmt|;
operator|*
name|max
operator|=
name|count
expr_stmt|;
block|}
while|while
condition|(
name|c
condition|)
block|{
name|pair
name|cdr
init|=
name|c
operator|->
name|cdr
decl_stmt|;
name|convert_num
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|c
operator|->
name|car
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|s
operator|-=
name|size
operator|/
literal|8
expr_stmt|;
comment|/* Free up temp space. */
name|free
argument_list|(
name|c
operator|->
name|car
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|cdr
expr_stmt|;
block|}
return|return
operator|(
name|bufp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|convert_num
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|negative
init|=
literal|0
decl_stmt|,
name|tval
decl_stmt|,
name|max
decl_stmt|;
name|u_int32_t
name|val
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|str
decl_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'-'
condition|)
block|{
name|negative
operator|=
literal|1
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
comment|/* If base wasn't specified, figure it out from the data. */
if|if
condition|(
operator|!
name|base
condition|)
block|{
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isascii
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
name|ptr
operator|+=
literal|1
expr_stmt|;
block|}
else|else
name|base
operator|=
literal|10
expr_stmt|;
block|}
else|else
name|base
operator|=
literal|10
expr_stmt|;
block|}
do|do
block|{
name|tval
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
comment|/* XXX assumes ASCII... */
if|if
condition|(
name|tval
operator|>=
literal|'a'
condition|)
name|tval
operator|=
name|tval
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|tval
operator|>=
literal|'A'
condition|)
name|tval
operator|=
name|tval
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|tval
operator|>=
literal|'0'
condition|)
name|tval
operator|-=
literal|'0'
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"Bogus number: %s."
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tval
operator|>=
name|base
condition|)
block|{
name|warning
argument_list|(
literal|"Bogus number: %s: digit %d not in base %d"
argument_list|,
name|str
argument_list|,
name|tval
argument_list|,
name|base
argument_list|)
expr_stmt|;
break|break;
block|}
name|val
operator|=
name|val
operator|*
name|base
operator|+
name|tval
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|ptr
condition|)
do|;
if|if
condition|(
name|negative
condition|)
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|max
operator|=
operator|(
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|+
operator|(
operator|(
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|max
condition|)
block|{
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|8
case|:
name|warning
argument_list|(
literal|"value %s%o exceeds max (%d) for precision."
argument_list|,
name|negative
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|val
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|warning
argument_list|(
literal|"value %s%x exceeds max (%d) for precision."
argument_list|,
name|negative
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|val
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warning
argument_list|(
literal|"value %s%u exceeds max (%d) for precision."
argument_list|,
name|negative
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|val
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|negative
condition|)
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
operator|*
name|buf
operator|=
operator|-
operator|(
name|unsigned
name|long
operator|)
name|val
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|putShort
argument_list|(
name|buf
argument_list|,
operator|-
operator|(
name|unsigned
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|putLong
argument_list|(
name|buf
argument_list|,
operator|-
operator|(
name|unsigned
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warning
argument_list|(
literal|"Unexpected integer size: %d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
operator|*
name|buf
operator|=
operator|(
name|u_int8_t
operator|)
name|val
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|putUShort
argument_list|(
name|buf
argument_list|,
operator|(
name|u_int16_t
operator|)
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|putULong
argument_list|(
name|buf
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warning
argument_list|(
literal|"Unexpected integer size: %d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * date :== NUMBER NUMBER SLASH NUMBER SLASH NUMBER  *		NUMBER COLON NUMBER COLON NUMBER SEMI  *  * Dates are always in GMT; first number is day of week; next is  * year/month/day; next is hours:minutes:seconds on a 24-hour  * clock.  */
end_comment

begin_function
name|time_t
name|parse_date
parameter_list|(
name|FILE
modifier|*
name|cfile
parameter_list|)
block|{
specifier|static
name|int
name|months
index|[
literal|11
index|]
init|=
block|{
literal|31
block|,
literal|59
block|,
literal|90
block|,
literal|120
block|,
literal|151
block|,
literal|181
block|,
literal|212
block|,
literal|243
block|,
literal|273
block|,
literal|304
block|,
literal|334
block|}
decl_stmt|;
name|int
name|guess
decl_stmt|,
name|token
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
comment|/* Day of week... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"numeric day of week expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tm
operator|.
name|tm_wday
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Year... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"numeric year expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tm
operator|.
name|tm_year
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|.
name|tm_year
operator|>
literal|1900
condition|)
name|tm
operator|.
name|tm_year
operator|-=
literal|1900
expr_stmt|;
comment|/* Slash separating year from month... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SLASH
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expected slash separating year from month."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Month... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"numeric month expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tm
operator|.
name|tm_mon
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Slash separating month from day... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SLASH
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expected slash separating month from day."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Month... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"numeric day of month expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tm
operator|.
name|tm_mday
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Hour... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"numeric hour expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tm
operator|.
name|tm_hour
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Colon separating hour from minute... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COLON
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expected colon separating hour from minute."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Minute... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"numeric minute expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tm
operator|.
name|tm_min
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Colon separating minute from second... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|COLON
condition|)
block|{
name|parse_warn
argument_list|(
literal|"expected colon separating hour from minute."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Minute... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NUMBER
condition|)
block|{
name|parse_warn
argument_list|(
literal|"numeric minute expected."
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tm
operator|.
name|tm_sec
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_isdst
operator|=
literal|0
expr_stmt|;
comment|/* XXX: We assume that mktime does not use tm_yday. */
name|tm
operator|.
name|tm_yday
operator|=
literal|0
expr_stmt|;
comment|/* Make sure the date ends in a semicolon... */
name|token
operator|=
name|next_token
argument_list|(
operator|&
name|val
argument_list|,
name|cfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|SEMI
condition|)
block|{
name|parse_warn
argument_list|(
literal|"semicolon expected."
argument_list|)
expr_stmt|;
name|skip_to_semi
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Guess the time value... */
name|guess
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
operator|(
literal|365
operator|*
operator|(
name|tm
operator|.
name|tm_year
operator|-
literal|70
operator|)
operator|+
comment|/* Days in years since '70 */
operator|(
name|tm
operator|.
name|tm_year
operator|-
literal|69
operator|)
operator|/
literal|4
operator|+
comment|/* Leap days since '70 */
operator|(
name|tm
operator|.
name|tm_mon
comment|/* Days in months this year */
condition|?
name|months
index|[
name|tm
operator|.
name|tm_mon
operator|-
literal|1
index|]
else|:
literal|0
operator|)
operator|+
operator|(
name|tm
operator|.
name|tm_mon
operator|>
literal|1
operator|&&
comment|/* Leap day this year */
operator|!
operator|(
operator|(
name|tm
operator|.
name|tm_year
operator|-
literal|72
operator|)
operator|&
literal|3
operator|)
operator|)
operator|+
name|tm
operator|.
name|tm_mday
operator|-
literal|1
operator|)
operator|*
literal|24
operator|)
operator|+
comment|/* Day of month */
name|tm
operator|.
name|tm_hour
operator|)
operator|*
literal|60
operator|)
operator|+
name|tm
operator|.
name|tm_min
operator|)
operator|*
literal|60
operator|)
operator|+
name|tm
operator|.
name|tm_sec
expr_stmt|;
comment|/* 	 * This guess could be wrong because of leap seconds or other 	 * weirdness we don't know about that the system does.   For 	 * now, we're just going to accept the guess, but at some point 	 * it might be nice to do a successive approximation here to get 	 * an exact value.   Even if the error is small, if the server 	 * is restarted frequently (and thus the lease database is 	 * reread), the error could accumulate into something 	 * significant. 	 */
return|return
operator|(
name|guess
operator|)
return|;
block|}
end_function

end_unit

