begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 Christoph M. Robitschko  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Christoph M. Robitschko  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * ttytab.c  * Everything that has to do with the getty table.  * This includes starting child precesses.  */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<ttyent.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"init.h"
end_include

begin_include
include|#
directive|include
file|"prototypes.h"
end_include

begin_include
include|#
directive|include
file|"libutil.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__gcc__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|checkstatus
init|=
name|DEF_CHECKSTATUS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|checktime
init|=
name|DEF_CHECKTIME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|def_waittimes
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|30
block|,
literal|60
block|,
literal|300
block|,
literal|1800
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|waittimes
init|=
name|def_waittimes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nwaittimes
init|=
literal|7
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * FREE_TTY  * remove a ttytab entry from the list  */
end_comment

begin_function
name|ttytab_t
modifier|*
name|free_tty
parameter_list|(
name|tab
parameter_list|,
name|tt
parameter_list|)
name|ttytab_t
modifier|*
name|tab
decl_stmt|,
decl|*
name|tt
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
comment|/* Delete the entry from utmp, make log to wtmp */
if|if
condition|(
name|logout
argument_list|(
name|tt
operator|->
name|name
argument_list|)
condition|)
name|logwtmp
argument_list|(
name|tt
operator|->
name|name
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* unlink it from the list first, in case of unexpected signal */
if|if
condition|(
name|tt
operator|->
name|next
condition|)
name|tt
operator|->
name|next
operator|->
name|prev
operator|=
name|tt
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|tt
operator|->
name|prev
condition|)
name|tt
operator|->
name|prev
operator|->
name|next
operator|=
name|tt
operator|->
name|next
expr_stmt|;
else|else
name|tab
operator|=
name|tt
operator|->
name|next
expr_stmt|;
comment|/* free the associated memory */
if|if
condition|(
name|tt
operator|->
name|name
condition|)
name|free
argument_list|(
name|tt
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt
operator|->
name|type
condition|)
name|free
argument_list|(
name|tt
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt
operator|->
name|argv
condition|)
block|{
for|for
control|(
name|s
operator|=
name|tt
operator|->
name|argv
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
name|free
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tt
operator|->
name|argv
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tt
argument_list|)
expr_stmt|;
return|return
operator|(
name|tab
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * ENT_TO_TAB  * create or change a ttytab entry based on the information in a ttyent struct  */
end_comment

begin_function
name|ttytab_t
modifier|*
name|ent_to_tab
parameter_list|(
name|ent
parameter_list|,
name|tt
parameter_list|,
name|tab
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|struct
name|ttyent
modifier|*
name|ent
decl_stmt|;
name|ttytab_t
modifier|*
name|tab
decl_stmt|,
decl|*
name|tt
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|argstr
decl_stmt|;
comment|/* Do we really need this entry ? */
if|if
condition|(
name|ent
operator|->
name|ty_status
operator|&
name|TTY_ON
operator|==
literal|0
condition|)
return|return
operator|(
name|tab
operator|)
return|;
name|Debug
argument_list|(
literal|4
argument_list|,
literal|"Processing tty entry %s"
argument_list|,
name|ent
operator|->
name|ty_name
argument_list|)
expr_stmt|;
comment|/* Allocate a ttytab entry, if not already there */
if|if
condition|(
operator|!
name|tt
condition|)
block|{
name|tt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tt
condition|)
goto|goto
name|kaaplotz
goto|;
name|tt
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|tt
operator|->
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
name|tt
operator|->
name|type
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|tt
operator|->
name|intflags
operator|=
name|INIT_NEW
expr_stmt|;
name|tt
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|tt
operator|->
name|failcount
operator|=
literal|0
expr_stmt|;
name|tt
operator|->
name|starttime
operator|=
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
name|tt
operator|->
name|next
operator|=
name|tab
expr_stmt|;
name|tt
operator|->
name|prev
operator|=
operator|(
name|ttytab_t
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|tab
condition|)
name|tab
operator|->
name|prev
operator|=
name|tt
expr_stmt|;
name|tab
operator|=
name|tt
expr_stmt|;
name|Debug
argument_list|(
literal|5
argument_list|,
literal|"Creating new ttytab entry"
argument_list|)
expr_stmt|;
block|}
else|else
name|Debug
argument_list|(
literal|5
argument_list|,
literal|"Reusing existing ttytab entry"
argument_list|)
expr_stmt|;
name|tt
operator|->
name|intflags
operator||=
operator|(
name|flags
operator||
name|INIT_SEEN
operator|)
expr_stmt|;
comment|/* fill each field in from the ttyent, if it has changed */
if|if
condition|(
name|strcmp
argument_list|(
name|ent
operator|->
name|ty_name
argument_list|,
name|tt
operator|->
name|name
argument_list|)
condition|)
block|{
name|Debug
argument_list|(
literal|5
argument_list|,
literal|"name differs: old=\"%s\" new=\"%s\""
argument_list|,
name|tt
operator|->
name|name
argument_list|,
name|ent
operator|->
name|ty_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt
operator|->
name|name
condition|)
name|free
argument_list|(
name|tt
operator|->
name|name
argument_list|)
expr_stmt|;
name|tt
operator|->
name|name
operator|=
name|newstring
argument_list|(
name|ent
operator|->
name|ty_name
argument_list|)
expr_stmt|;
name|tt
operator|->
name|intflags
operator||=
name|INIT_CHANGED
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|INIT_NODEV
condition|)
name|argstr
operator|=
name|ent
operator|->
name|ty_getty
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|argstr
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|ent
operator|->
name|ty_getty
argument_list|)
operator|+
name|strlen
argument_list|(
name|tt
operator|->
name|name
argument_list|)
operator|+
literal|2
argument_list|)
operator|)
condition|)
goto|goto
name|kaaplotz
goto|;
comment|/* 		sprintf(argstr, "%s %s", ent->ty_getty, tt->name); */
name|strcpy
argument_list|(
name|argstr
argument_list|,
name|ent
operator|->
name|ty_getty
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|argstr
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|argstr
argument_list|,
name|tt
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argv_changed
argument_list|(
name|argstr
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|tt
operator|->
name|argv
argument_list|)
condition|)
block|{
if|if
condition|(
name|tt
operator|->
name|argv
condition|)
block|{
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|tt
operator|->
name|argv
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
name|free
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tt
operator|->
name|argv
argument_list|)
expr_stmt|;
block|}
name|tt
operator|->
name|argv
operator|=
name|string_to_argv
argument_list|(
name|argstr
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tt
operator|->
name|intflags
operator||=
name|INIT_CHANGED
expr_stmt|;
name|Debug
argument_list|(
literal|5
argument_list|,
literal|"argv differs."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|ent
operator|->
name|ty_type
argument_list|,
name|tt
operator|->
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|tt
operator|->
name|type
condition|)
name|free
argument_list|(
name|tt
operator|->
name|type
argument_list|)
expr_stmt|;
name|tt
operator|->
name|type
operator|=
name|newstring
argument_list|(
name|ent
operator|->
name|ty_type
argument_list|)
expr_stmt|;
name|tt
operator|->
name|intflags
operator||=
name|INIT_CHANGED
expr_stmt|;
name|Debug
argument_list|(
literal|5
argument_list|,
literal|"type differs."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|tt
operator|->
name|intflags
operator|&
name|INIT_CHANGED
operator|)
condition|)
block|{
name|Debug
argument_list|(
literal|5
argument_list|,
literal|"entry unchanged."
argument_list|)
expr_stmt|;
block|}
else|else
name|Debug
argument_list|(
literal|5
argument_list|,
literal|"entry has been changed."
argument_list|)
expr_stmt|;
return|return
operator|(
name|tab
operator|)
return|;
name|kaaplotz
label|:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Out of memory in ent_to_tab"
argument_list|)
expr_stmt|;
name|callout
argument_list|(
name|retrytime
argument_list|,
name|CO_ENT2TAB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|tab
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * ARGV_CHANGED  * compares a string and an argv  */
end_comment

begin_function
name|int
name|argv_changed
parameter_list|(
name|string
parameter_list|,
name|argv
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|ss
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|sa
decl_stmt|;
if|if
condition|(
operator|!
name|argv
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|ss
operator|=
name|string
operator|,
name|sa
operator|=
name|argv
init|;
operator|*
name|sa
condition|;
name|sa
operator|++
control|)
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
operator|*
name|sa
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|sa
argument_list|,
name|ss
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ss
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ss
operator|!=
literal|' '
operator|)
operator|&&
operator|(
operator|*
name|ss
operator|!=
literal|'\t'
operator|)
operator|&&
operator|(
operator|*
name|ss
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|(
operator|*
name|ss
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|ss
operator|==
literal|'\t'
operator|)
condition|)
name|ss
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ss
condition|)
comment|/* String longer than argv ? */
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * STRING_TO_ARGV  * breaks up a string into words. Speration characters are SPACE and TAB,  * unless prepended by a backslash \ or within double quotes ".  * Quotes and backslash can be escaped by an additional \.  * If errtext is non-NULL, it is set to point to an error message.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|string_to_argv
parameter_list|(
name|string
parameter_list|,
name|rargc
parameter_list|,
name|errtext
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|rargc
decl_stmt|;
name|char
modifier|*
modifier|*
name|errtext
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|backslash
decl_stmt|,
name|inquote
decl_stmt|;
name|int
name|argc
decl_stmt|,
name|alloc_argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|ra
decl_stmt|;
name|Debug
argument_list|(
literal|4
argument_list|,
literal|"string_to_argv(\"%s\")"
argument_list|,
name|string
argument_list|)
expr_stmt|;
comment|/* 	 * argv is allocated in chunks of ALLOC_ARGV pointers; if it runs 	 * out of space, it is realloc'ed with ALLOC_ARGV more pointers. 	 */
name|argc
operator|=
literal|0
expr_stmt|;
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|ALLOC_ARGV
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argv
condition|)
return|return
operator|(
name|argv
operator|)
return|;
name|alloc_argc
operator|=
name|ALLOC_ARGV
expr_stmt|;
if|if
condition|(
name|errtext
condition|)
operator|*
name|errtext
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|string
init|;
operator|*
name|s
condition|;
control|)
block|{
name|backslash
operator|=
name|inquote
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|(
operator|*
name|s
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'\t'
operator|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
comment|/* Skip blanks */
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|malloc_fail
goto|;
for|for
control|(
name|t
operator|=
name|buf
init|;
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|backslash
condition|)
block|{
name|backslash
operator|=
literal|0
expr_stmt|;
operator|*
name|t
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
else|else
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\\'
case|:
name|backslash
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|inquote
operator|^=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
if|if
condition|(
name|inquote
operator|&&
name|errtext
condition|)
operator|*
name|errtext
operator|=
literal|"Unmatched \"."
expr_stmt|;
goto|goto
name|end_of_word
goto|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
if|if
condition|(
operator|!
name|inquote
condition|)
goto|goto
name|end_of_word
goto|;
comment|/* no break */
default|default:
operator|*
name|t
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
block|}
name|end_of_word
label|:
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|argv
index|[
name|argc
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|malloc_fail
goto|;
if|if
condition|(
operator|++
name|argc
operator|>=
name|alloc_argc
condition|)
block|{
name|alloc_argc
operator|+=
name|ALLOC_ARGV
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ra
operator|=
name|realloc
argument_list|(
name|argv
argument_list|,
name|alloc_argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|malloc_fail
goto|;
name|argv
operator|=
name|ra
expr_stmt|;
block|}
block|}
comment|/* Terminate argv with a NULL pointer and return */
name|argv
index|[
name|argc
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|rargc
condition|)
operator|*
name|rargc
operator|=
name|argc
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|5
condition|)
block|{
for|for
control|(
name|ra
operator|=
name|argv
init|;
operator|*
name|ra
condition|;
name|ra
operator|++
control|)
name|Debug
argument_list|(
literal|5
argument_list|,
literal|"	\"%s\""
argument_list|,
operator|*
name|ra
argument_list|)
expr_stmt|;
name|Debug
argument_list|(
literal|5
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|argv
operator|)
return|;
name|malloc_fail
label|:
comment|/* free all so-far allocated memory and return a NULL pointer */
for|for
control|(
init|;
operator|*
name|argv
condition|;
name|argv
operator|++
control|)
name|free
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * DO_GETTY  * start a getty process for a ttytab entry  */
end_comment

begin_function
name|int
name|do_getty
parameter_list|(
name|tt
parameter_list|,
name|status
parameter_list|)
name|ttytab_t
modifier|*
name|tt
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
if|if
condition|(
operator|!
name|tt
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|Debug
argument_list|(
literal|2
argument_list|,
literal|"do_getty for %s"
argument_list|,
name|tt
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt
operator|->
name|intflags
operator|&
name|INIT_FAILSLEEP
condition|)
name|tt
operator|->
name|intflags
operator|&=
operator|~
name|INIT_FAILSLEEP
expr_stmt|;
else|else
block|{
comment|/* Delete old entry from utmp, make log to wtmp */
if|if
condition|(
name|logout
argument_list|(
name|tt
operator|->
name|name
argument_list|)
condition|)
name|logwtmp
argument_list|(
name|tt
operator|->
name|name
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|checkstatus
operator|&&
name|status
operator|)
operator|||
operator|(
name|checktime
operator|&&
operator|(
name|time
argument_list|(
literal|0
argument_list|)
operator|-
name|tt
operator|->
name|starttime
operator|<=
name|checktime
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|tt
operator|->
name|intflags
operator|&
name|INIT_FAILED
condition|)
block|{
if|if
condition|(
operator|++
name|tt
operator|->
name|failcount
operator|>=
name|nwaittimes
condition|)
name|tt
operator|->
name|failcount
operator|=
name|nwaittimes
expr_stmt|;
block|}
else|else
block|{
name|tt
operator|->
name|intflags
operator||=
name|INIT_FAILED
expr_stmt|;
name|tt
operator|->
name|failcount
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|waittimes
index|[
name|tt
operator|->
name|failcount
index|]
condition|)
block|{
name|tt
operator|->
name|intflags
operator||=
name|INIT_FAILSLEEP
expr_stmt|;
name|tt
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"getty \"%s\" for %s failed, sleeping"
argument_list|,
name|tt
operator|->
name|argv
index|[
literal|0
index|]
argument_list|,
name|tt
operator|->
name|name
argument_list|)
expr_stmt|;
name|callout
argument_list|(
name|waittimes
index|[
name|tt
operator|->
name|failcount
index|]
argument_list|,
name|CO_GETTY
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
name|tt
operator|->
name|intflags
operator|&=
operator|~
name|INIT_FAILED
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TESTRUN
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* TESTRUN */
name|tt
operator|->
name|starttime
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|blocksig
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fork failed for %s: %m"
argument_list|,
name|tt
operator|->
name|name
argument_list|)
expr_stmt|;
name|unblocksig
argument_list|()
expr_stmt|;
name|callout
argument_list|(
name|retrytime
argument_list|,
name|CO_FORK
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tt
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|0
case|:
name|signalsforchile
argument_list|()
expr_stmt|;
name|iputenv
argument_list|(
literal|"TERM"
argument_list|,
name|tt
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt
operator|->
name|intflags
operator|&
name|INIT_OPEN
condition|)
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|device
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|tt
operator|->
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"/dev/"
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 			sprintf(device, "/dev/%s", tt->name); */
name|strcpy
argument_list|(
name|device
argument_list|,
literal|"/dev/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|device
argument_list|,
name|tt
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|revoke
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|closelog
argument_list|()
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"open %s failed: %m"
argument_list|,
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|login_tty
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"login_tty for %s failed: %m"
argument_list|,
name|device
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CONFIGURE
name|setconf
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|closelog
argument_list|()
expr_stmt|;
comment|/* Necessary, because dup2 fails otherwise (?) */
if|if
condition|(
name|tt
operator|->
name|intflags
operator|&
name|INIT_ARG0
condition|)
name|execve
argument_list|(
name|tt
operator|->
name|argv
index|[
literal|0
index|]
argument_list|,
name|tt
operator|->
name|argv
operator|+
literal|1
argument_list|,
name|ienviron
argument_list|)
expr_stmt|;
else|else
name|execve
argument_list|(
name|tt
operator|->
name|argv
index|[
literal|0
index|]
argument_list|,
name|tt
operator|->
name|argv
argument_list|,
name|ienviron
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Exec \"%s\" failed for %s: %m"
argument_list|,
name|tt
operator|->
name|argv
index|[
literal|0
index|]
argument_list|,
name|tt
operator|->
name|name
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
default|default:
name|tt
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
name|unblocksig
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

end_unit

