begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 Christoph M. Robitschko  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Christoph M. Robitschko  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * init.c  * Main program for init.  * Also contains definitions for global variables etc.  */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<ttyent.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"init.h"
end_include

begin_include
include|#
directive|include
file|"prototypes.h"
end_include

begin_include
include|#
directive|include
file|"libutil.h"
end_include

begin_comment
comment|/* global variables, preset to their defaults */
end_comment

begin_decl_stmt
name|int
name|timeout_m2s_TERM
init|=
name|INIT_M2S_TERMTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|timeout_m2s_KILL
init|=
name|INIT_M2S_KILLTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|retrytime
init|=
name|RETRYTIME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|startup_single
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|checkonly
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|force_single
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|force_debug
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
init|=
name|DEBUG_LEVEL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIGURE
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|config_file
init|=
name|INIT_CONFIG
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|ttytab_t
modifier|*
name|ttytab
init|=
operator|(
name|ttytab_t
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|callout_t
modifier|*
name|callout_tab
init|=
operator|(
name|callout_t
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|callout_t
modifier|*
name|callout_free
init|=
operator|(
name|callout_t
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|callout_nfree
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sigset_t
name|block_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|boing_singleuser
decl_stmt|,
name|boing_single2multi
decl_stmt|,
name|boing_multiuser
decl_stmt|,
name|boing_multi2single
decl_stmt|,
name|boing_waitforboot
decl_stmt|,
modifier|*
name|boing_m2stimeout
decl_stmt|;
end_decl_stmt

begin_enum
specifier|static
enum|enum
block|{
name|SINGLEUSER
block|,
name|MULTIUSER
block|,
name|SINGLE2MULTI
block|,
name|MULTI2SINGLE
block|}
name|State
enum|;
end_enum

begin_decl_stmt
name|struct
name|ttyent
name|RCent_auto
init|=
block|{
literal|"console"
block|,
literal|"/bin/sh sh /etc/rc autoboot"
block|,
literal|"dumb"
block|,
name|TTY_ON
operator||
name|TTY_SECURE
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ttyent
name|RCent_fast
init|=
block|{
literal|"console"
block|,
literal|"/bin/sh sh /etc/rc"
block|,
literal|"dumb"
block|,
name|TTY_ON
operator||
name|TTY_SECURE
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ttyent
name|Single_ent
init|=
block|{
literal|"console"
block|,
literal|"/bin/sh -"
block|,
literal|"pc3"
block|,
name|TTY_ON
operator||
name|TTY_SECURE
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ttyent
modifier|*
name|RCent
init|=
operator|&
name|RCent_auto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ttyent
modifier|*
name|Singlesh
init|=
operator|&
name|Single_ent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**********************************************************  *                           Main                         *  **********************************************************/
end_comment

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
comment|/* make it a session leader */
operator|(
name|void
operator|)
name|setsid
argument_list|()
expr_stmt|;
comment|/* initialize syslog */
name|openlog
argument_list|(
literal|"init"
argument_list|,
name|LOG_CONS
operator||
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
comment|/* parse command line */
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-s"
argument_list|)
condition|)
comment|/* Singleuser */
name|force_single
operator|=
name|startup_single
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-f"
argument_list|)
condition|)
comment|/* Fastboot */
name|RCent
operator|=
operator|&
name|RCent_fast
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-d"
argument_list|)
condition|)
comment|/* Debug level */
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|force_debug
operator|=
name|str2u
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|debug
operator|=
name|force_debug
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"option -d needs positive integer argument"
argument_list|)
expr_stmt|;
block|}
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"option -d needs an argument"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIGURE
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-C"
argument_list|)
condition|)
comment|/* Configuration file */
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|config_file
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"option -C needs an argument"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-S"
argument_list|)
condition|)
comment|/* Syntaxcheck only */
name|checkonly
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-"
argument_list|)
condition|)
comment|/* ignore this */
empty_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unknown option \"%s\""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|TESTRUN
comment|/* did some idiot try to run init ? */
if|if
condition|(
operator|(
name|getpid
argument_list|()
operator|!=
literal|1
operator|)
operator|&&
operator|!
name|checkonly
condition|)
block|{
specifier|const
name|char
name|errmsg
index|[]
init|=
literal|"init: system daemon, not runnable by user\r\n"
decl_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|errmsg
argument_list|,
name|strlen
argument_list|(
name|errmsg
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ! TESTRUN */
ifdef|#
directive|ifdef
name|CONFIGURE
comment|/* read the default configuration (limits etc) */
name|getconf
argument_list|()
expr_stmt|;
comment|/* read configuration file */
name|configure
argument_list|(
name|config_file
argument_list|)
expr_stmt|;
comment|/* set global configuration parameters */
name|checkconf
argument_list|()
expr_stmt|;
if|if
condition|(
name|checkonly
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* values configured by command-line arguments take precedence	*/
comment|/* over values in the config file				*/
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|force_debug
operator|>=
literal|0
condition|)
name|debug
operator|=
name|force_debug
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|force_single
operator|>=
literal|0
condition|)
name|startup_single
operator|=
name|force_single
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * initialize callout table 	 */
name|allocate_callout
argument_list|()
expr_stmt|;
comment|/* 	 * initialize the longjmp buffers; 	 * after a longjmp(), the appropriate function is called and 	 * does not return. 	 */
if|if
condition|(
name|setjmp
argument_list|(
name|boing_singleuser
argument_list|)
condition|)
name|singleuser
argument_list|()
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|boing_single2multi
argument_list|)
condition|)
name|single2multi
argument_list|()
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|boing_multiuser
argument_list|)
condition|)
name|multiuser
argument_list|()
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|boing_multi2single
argument_list|)
condition|)
name|multi2single
argument_list|()
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|boing_waitforboot
argument_list|)
condition|)
name|waitforboot
argument_list|()
expr_stmt|;
comment|/* install signal handlers for catched signals */
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|sig_tstp
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sig_term
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|sig_hup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|sig_alrm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|sig_usr1
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|sig_usr2
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIGURE
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|sig_ttin
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|UNTRUSTED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TESTRUN
argument_list|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sig_int
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* define Set of signals to be blocked for critical parts */
operator|(
name|void
operator|)
name|sigemptyset
argument_list|(
operator|&
name|block_set
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|block_set
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|block_set
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|block_set
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|block_set
argument_list|,
name|SIGUSR1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|block_set
argument_list|,
name|SIGUSR2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|block_set
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
comment|/* Action ! */
if|if
condition|(
name|startup_single
condition|)
name|longjmp
argument_list|(
name|boing_singleuser
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|longjmp
argument_list|(
name|boing_single2multi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/**********************************************************  *                      Signal Handlers                   *  **********************************************************/
end_comment

begin_comment
comment|/* TSTP -- wait for children, but don't spawn new ones */
end_comment

begin_function
name|void
name|sig_tstp
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|Debug
argument_list|(
literal|3
argument_list|,
literal|"TSTP Signal received"
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|boing_waitforboot
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TERM -- Go to singleuser mode */
end_comment

begin_function
name|void
name|sig_term
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|Debug
argument_list|(
literal|3
argument_list|,
literal|"Terminate Signal received"
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|boing_multi2single
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* HUP -- Reread /etc/ttys file */
end_comment

begin_function
name|void
name|sig_hup
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|Debug
argument_list|(
literal|3
argument_list|,
literal|"Hangup Signal received"
argument_list|)
expr_stmt|;
if|if
condition|(
name|State
operator|==
name|MULTIUSER
condition|)
name|longjmp
argument_list|(
name|boing_multiuser
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ALRM -- Timeout Signal */
end_comment

begin_function
name|void
name|sig_alrm
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|Debug
argument_list|(
literal|3
argument_list|,
literal|"Alarm Signal received"
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_tab
condition|)
name|do_callout
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* USR1 -- Increment debugging level */
end_comment

begin_function
name|void
name|sig_usr1
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|debug
operator|++
expr_stmt|;
if|if
condition|(
name|debug
operator|==
literal|1
condition|)
name|Debug
argument_list|(
literal|0
argument_list|,
literal|"I will chat like a gossip"
argument_list|)
expr_stmt|;
else|else
name|Debug
argument_list|(
literal|0
argument_list|,
literal|"I will chat like %d gossips"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* USR2 -- switch off debugging */
end_comment

begin_function
name|void
name|sig_usr2
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|Debug
argument_list|(
literal|0
argument_list|,
literal|"OK, I will shut up now."
argument_list|)
expr_stmt|;
name|debug
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UNTRUSTED
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TESTRUN
argument_list|)
end_if

begin_comment
comment|/* INT -- execute original init (Signal can be generated from the kernel 	debugger with 'call pfind(1)' and then 'call psignal(XXXXX, 2)' 	where XXXXX is the return value of the pfind call). 	This isn't very pretty, but it saved me from booting from floppy 	disk many times.  */
end_comment

begin_function
name|void
name|sig_int
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|Debug
argument_list|(
literal|0
argument_list|,
literal|"Interrupt signal received; trying to execute /sbin/init.ori"
argument_list|)
expr_stmt|;
name|Debug
argument_list|(
literal|0
argument_list|,
literal|"(Are you not satisfied with me ?)"
argument_list|)
expr_stmt|;
name|kill
argument_list|(
operator|-
literal|1
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/sbin/init.ori"
argument_list|,
literal|"init"
argument_list|,
literal|"-s"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Debug
argument_list|(
literal|0
argument_list|,
literal|"Could not execute /sbin/init.ori (%m)"
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|boing_multi2single
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNTRUSTED */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIGURE
end_ifdef

begin_comment
comment|/* TTIN -- reread configuration file; only valid when in singleuser mode */
end_comment

begin_function
name|void
name|sig_ttin
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
if|if
condition|(
name|State
operator|==
name|SINGLEUSER
condition|)
block|{
name|blocksig
argument_list|()
expr_stmt|;
name|Debug
argument_list|(
literal|0
argument_list|,
literal|"TTIN signal received, re-reading configuration file"
argument_list|)
expr_stmt|;
name|setconf
argument_list|()
expr_stmt|;
name|configure
argument_list|(
name|config_file
argument_list|)
expr_stmt|;
name|checkconf
argument_list|()
expr_stmt|;
name|unblocksig
argument_list|()
expr_stmt|;
block|}
else|else
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"TTIN signal received, but not in singleuser mode"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**********************************************************  *                      SingleUserMode                    *  **********************************************************/
end_comment

begin_function
name|void
name|singleuser
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|State
operator|=
name|SINGLEUSER
expr_stmt|;
name|clear_callout
argument_list|()
expr_stmt|;
name|Debug
argument_list|(
literal|1
argument_list|,
literal|"Entered State singleuser"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttytab
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"internal error: multiple users in singleusermode"
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|boing_multi2single
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|RCent
operator|=
operator|&
name|RCent_fast
expr_stmt|;
name|blocksig
argument_list|()
expr_stmt|;
name|ttytab
operator|=
name|ent_to_tab
argument_list|(
name|Singlesh
argument_list|,
operator|(
name|ttytab_t
operator|*
operator|)
literal|0
argument_list|,
name|ttytab
argument_list|,
name|INIT_NODEV
operator||
name|INIT_OPEN
operator||
name|INIT_ARG0
argument_list|)
expr_stmt|;
name|unblocksig
argument_list|()
expr_stmt|;
if|if
condition|(
name|do_getty
argument_list|(
name|ttytab
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_EMERG
argument_list|,
literal|"Unable to start singleuser shell"
argument_list|)
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* What else should we do about this ? */
block|}
ifndef|#
directive|ifndef
name|TESTRUN
while|while
condition|(
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|!=
name|ttytab
operator|->
name|pid
condition|)
empty_stmt|;
else|#
directive|else
name|scanf
argument_list|(
literal|"%d\n"
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
name|Debug
argument_list|(
literal|1
argument_list|,
literal|"Singleusershell exited with status %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|blocksig
argument_list|()
expr_stmt|;
name|ttytab
operator|=
name|free_tty
argument_list|(
name|ttytab
argument_list|,
name|ttytab
argument_list|)
expr_stmt|;
name|unblocksig
argument_list|()
expr_stmt|;
name|longjmp
argument_list|(
name|boing_single2multi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/**********************************************************  *                      Single 2 Multi                    *  **********************************************************/
end_comment

begin_function
name|void
name|single2multi
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|State
operator|=
name|SINGLE2MULTI
expr_stmt|;
name|clear_callout
argument_list|()
expr_stmt|;
name|Debug
argument_list|(
literal|1
argument_list|,
literal|"Entered State single2multi"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttytab
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"internal error: users in single2multi"
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|boing_multi2single
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|blocksig
argument_list|()
expr_stmt|;
name|ttytab
operator|=
name|ent_to_tab
argument_list|(
name|RCent
argument_list|,
operator|(
name|ttytab_t
operator|*
operator|)
literal|0
argument_list|,
name|ttytab
argument_list|,
name|INIT_NODEV
operator||
name|INIT_OPEN
operator||
name|INIT_ARG0
argument_list|)
expr_stmt|;
name|unblocksig
argument_list|()
expr_stmt|;
if|if
condition|(
name|do_getty
argument_list|(
name|ttytab
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to execute /etc/rc"
argument_list|)
expr_stmt|;
name|ttytab
operator|=
name|free_tty
argument_list|(
name|ttytab
argument_list|,
name|ttytab
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|boing_singleuser
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|TESTRUN
while|while
condition|(
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|!=
name|ttytab
operator|->
name|pid
condition|)
empty_stmt|;
else|#
directive|else
name|scanf
argument_list|(
literal|"%d\n"
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Debug
argument_list|(
literal|1
argument_list|,
literal|"/etc/rc exited with status %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|blocksig
argument_list|()
expr_stmt|;
name|ttytab
operator|=
name|free_tty
argument_list|(
name|ttytab
argument_list|,
name|ttytab
argument_list|)
expr_stmt|;
name|unblocksig
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|longjmp
argument_list|(
name|boing_singleuser
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|logwtmp
argument_list|(
literal|"~"
argument_list|,
literal|"reboot"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|boing_multiuser
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/**********************************************************  *                       WaitForBoot                      *  **********************************************************/
end_comment

begin_function
name|void
name|waitforboot
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|ttytab_t
modifier|*
name|tt
decl_stmt|;
comment|/* Note that the State variable is not set here */
name|clear_callout
argument_list|()
expr_stmt|;
name|Debug
argument_list|(
literal|1
argument_list|,
literal|"Entered State waitforboot"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|pause
argument_list|()
expr_stmt|;
else|else
block|{
name|Debug
argument_list|(
literal|4
argument_list|,
literal|"Process %d exited with status %d"
argument_list|,
name|pid
argument_list|,
name|status
argument_list|)
expr_stmt|;
for|for
control|(
name|tt
operator|=
name|ttytab
init|;
name|tt
condition|;
name|tt
operator|=
name|tt
operator|->
name|next
control|)
if|if
condition|(
name|tt
operator|->
name|pid
operator|==
name|pid
condition|)
block|{
name|blocksig
argument_list|()
expr_stmt|;
name|ttytab
operator|=
name|free_tty
argument_list|(
name|ttytab
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|unblocksig
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/**********************************************************  *                        MultiUser                       *  **********************************************************/
end_comment

begin_function
name|void
name|multiuser
parameter_list|(
name|void
parameter_list|)
block|{
name|ttytab_t
modifier|*
name|tt
decl_stmt|;
name|struct
name|ttyent
modifier|*
name|tent
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|State
operator|=
name|MULTIUSER
expr_stmt|;
name|clear_callout
argument_list|()
expr_stmt|;
name|Debug
argument_list|(
literal|1
argument_list|,
literal|"Entered State multiuser"
argument_list|)
expr_stmt|;
comment|/* First, (re)build ttytab based on what is in /etc/ttys */
name|blocksig
argument_list|()
expr_stmt|;
name|setttyent
argument_list|()
expr_stmt|;
for|for
control|(
name|tt
operator|=
name|ttytab
init|;
name|tt
condition|;
name|tt
operator|=
name|tt
operator|->
name|next
control|)
name|tt
operator|->
name|intflags
operator|&=
operator|~
operator|(
name|INIT_SEEN
operator||
name|INIT_CHANGED
operator||
name|INIT_NEW
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|tent
operator|=
name|getttyent
argument_list|()
operator|)
condition|)
if|if
condition|(
name|tent
operator|->
name|ty_status
operator|&
name|TTY_ON
condition|)
block|{
for|for
control|(
name|tt
operator|=
name|ttytab
init|;
name|tt
condition|;
name|tt
operator|=
name|tt
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tent
operator|->
name|ty_name
argument_list|,
name|tt
operator|->
name|name
argument_list|)
condition|)
break|break;
name|ttytab
operator|=
name|ent_to_tab
argument_list|(
name|tent
argument_list|,
name|tt
argument_list|,
name|ttytab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|unblocksig
argument_list|()
expr_stmt|;
comment|/* Kill the processes whose entries are deleted or changed */
comment|/* Also start the getty process on the lines that were just added */
for|for
control|(
name|tt
operator|=
name|ttytab
init|;
name|tt
condition|;
name|tt
operator|=
name|tt
operator|->
name|next
control|)
if|if
condition|(
operator|!
operator|(
name|tt
operator|->
name|intflags
operator|&
name|INIT_SEEN
operator|)
condition|)
block|{
name|Debug
argument_list|(
literal|5
argument_list|,
literal|"killing %s (PID %d): Not seen"
argument_list|,
name|tt
operator|->
name|name
argument_list|,
name|tt
operator|->
name|pid
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|tt
operator|->
name|pid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|tt
operator|->
name|intflags
operator||=
name|INIT_DONTSPAWN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tt
operator|->
name|intflags
operator|&
name|INIT_NEW
condition|)
operator|(
name|void
operator|)
name|do_getty
argument_list|(
name|tt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tt
operator|->
name|intflags
operator|&
name|INIT_CHANGED
condition|)
block|{
name|Debug
argument_list|(
literal|5
argument_list|,
literal|"killing %s (PID %d): Changed"
argument_list|,
name|tt
operator|->
name|name
argument_list|,
name|tt
operator|->
name|pid
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|tt
operator|->
name|pid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tt
operator|->
name|intflags
operator|&
name|INIT_FAILSLEEP
condition|)
block|{
name|Debug
argument_list|(
literal|5
argument_list|,
literal|"continuing %s (PID %d)"
argument_list|,
name|tt
operator|->
name|name
argument_list|,
name|tt
operator|->
name|pid
argument_list|)
expr_stmt|;
define|#
directive|define
name|UNSLEEP
parameter_list|(
name|a
parameter_list|)
name|UNSLEEP
argument_list|(
name|tt
operator|->
name|pid
argument_list|)
expr_stmt|;
name|tt
operator|->
name|intflags
operator|&=
operator|~
name|INIT_FAILED
operator||
name|INIT_FAILSLEEP
expr_stmt|;
name|do_getty
argument_list|(
name|tt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Now handle terminating children and respawn gettys for lines */
while|while
condition|(
literal|1
condition|)
block|{
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINTR
case|:
break|break;
case|case
name|ECHILD
case|:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"wait() found no child processes -- going singleuser."
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|boing_multi2single
argument_list|,
literal|2
argument_list|)
expr_stmt|;
default|default:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"wait() failed: %m"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Debug
argument_list|(
literal|4
argument_list|,
literal|"Process %d terminated with status %d"
argument_list|,
name|pid
argument_list|,
name|status
argument_list|)
expr_stmt|;
for|for
control|(
name|tt
operator|=
name|ttytab
init|;
name|tt
condition|;
name|tt
operator|=
name|tt
operator|->
name|next
control|)
if|if
condition|(
name|pid
operator|==
name|tt
operator|->
name|pid
condition|)
if|if
condition|(
name|tt
operator|->
name|intflags
operator|&
name|INIT_DONTSPAWN
condition|)
block|{
name|blocksig
argument_list|()
expr_stmt|;
name|ttytab
operator|=
name|free_tty
argument_list|(
name|ttytab
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|unblocksig
argument_list|()
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|do_getty
argument_list|(
name|tt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/**********************************************************  *                       Multi2Single                     *  **********************************************************/
end_comment

begin_function
name|void
name|multi2single
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|jmp_buf
name|boing_timeout
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
specifier|volatile
name|int
name|round
decl_stmt|;
name|State
operator|=
name|MULTI2SINGLE
expr_stmt|;
name|clear_callout
argument_list|()
expr_stmt|;
name|Debug
argument_list|(
literal|1
argument_list|,
literal|"Entering State multi2single"
argument_list|)
expr_stmt|;
comment|/* forget about the gettys */
name|blocksig
argument_list|()
expr_stmt|;
while|while
condition|(
name|ttytab
condition|)
name|ttytab
operator|=
name|free_tty
argument_list|(
name|ttytab
argument_list|,
name|ttytab
argument_list|)
expr_stmt|;
name|unblocksig
argument_list|()
expr_stmt|;
comment|/* 	 * round = 1: TERMinate children, then wait for them (default 10 seconds) 	 * round = 2: KILL children, then wait for them (default 30 seconds) 	 * round = 3: timeout expired; go to singleuser mode 	 */
name|round
operator|=
literal|0
expr_stmt|;
name|setjmp
argument_list|(
name|boing_timeout
argument_list|)
expr_stmt|;
name|boing_m2stimeout
operator|=
operator|&
name|boing_timeout
expr_stmt|;
name|round
operator|++
expr_stmt|;
if|if
condition|(
name|round
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|round
operator|==
literal|1
condition|)
block|{
name|Debug
argument_list|(
literal|3
argument_list|,
literal|"TERMinating processes"
argument_list|)
expr_stmt|;
name|kill
argument_list|(
operator|-
literal|1
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|kill
argument_list|(
operator|-
literal|1
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
name|callout
argument_list|(
name|timeout_m2s_TERM
argument_list|,
name|CO_MUL2SIN
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Debug
argument_list|(
literal|3
argument_list|,
literal|"KILLing processes"
argument_list|)
expr_stmt|;
name|kill
argument_list|(
operator|-
literal|1
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
operator|-
literal|1
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
name|callout
argument_list|(
name|timeout_m2s_KILL
argument_list|,
name|CO_MUL2SIN
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|Debug
argument_list|(
literal|4
argument_list|,
literal|"Process %d exited with status %d"
argument_list|,
name|pid
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|Debug
argument_list|(
literal|2
argument_list|,
literal|"Wait returned error: %m"
argument_list|)
expr_stmt|;
block|}
else|else
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"There are still some (hung) processes."
argument_list|)
expr_stmt|;
comment|/* We don't need no steenkin timeout any more... */
name|boing_m2stimeout
operator|=
operator|(
name|jmp_buf
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Jump ! (Rein ins Vergnuegen) */
name|longjmp
argument_list|(
name|boing_singleuser
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/**********************************************************  *                         Callout                        *  * Schedule a retry operation for a later time            *  **********************************************************/
end_comment

begin_function
name|void
name|callout
parameter_list|(
name|when
parameter_list|,
name|type
parameter_list|,
name|arg
parameter_list|)
name|unsigned
name|int
name|when
decl_stmt|;
name|retr_t
name|type
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|callout_t
modifier|*
name|ntp
decl_stmt|,
modifier|*
name|ctp
decl_stmt|,
modifier|*
name|octp
decl_stmt|;
name|Debug
argument_list|(
literal|3
argument_list|,
literal|"Scheduling callout in %d seconds."
argument_list|,
name|when
argument_list|)
expr_stmt|;
name|blocksig
argument_list|()
expr_stmt|;
comment|/* find a free callout entry */
if|if
condition|(
name|callout_nfree
operator|<=
name|CALLOUT_MINFREE
condition|)
name|allocate_callout
argument_list|()
expr_stmt|;
name|ntp
operator|=
name|callout_free
expr_stmt|;
if|if
condition|(
operator|!
name|ntp
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Callout table is full !"
argument_list|)
expr_stmt|;
return|return;
block|}
name|callout_free
operator|=
name|ntp
operator|->
name|next
expr_stmt|;
name|callout_nfree
operator|--
expr_stmt|;
comment|/* look at which point we put it in the callout list */
name|when
operator|+=
operator|(
name|unsigned
name|int
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|octp
operator|=
name|NULL
operator|,
name|ctp
operator|=
name|callout_tab
init|;
name|ctp
condition|;
name|octp
operator|=
name|ctp
operator|,
name|ctp
operator|=
name|ctp
operator|->
name|next
control|)
if|if
condition|(
name|when
operator|<
name|ctp
operator|->
name|sleept
condition|)
break|break;
else|else
name|when
operator|-=
name|ctp
operator|->
name|sleept
expr_stmt|;
if|if
condition|(
name|octp
condition|)
name|octp
operator|->
name|next
operator|=
name|ntp
expr_stmt|;
else|else
name|callout_tab
operator|=
name|ntp
expr_stmt|;
name|ntp
operator|->
name|next
operator|=
name|ctp
expr_stmt|;
name|ntp
operator|->
name|sleept
operator|=
name|when
expr_stmt|;
if|if
condition|(
name|ctp
condition|)
name|ctp
operator|->
name|sleept
operator|-=
name|when
expr_stmt|;
name|ntp
operator|->
name|what
operator|=
name|type
expr_stmt|;
name|ntp
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
comment|/* schedule alarm */
name|when
operator|=
name|callout_tab
operator|->
name|sleept
operator|-
operator|(
name|unsigned
name|int
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|when
operator|<=
literal|0
condition|)
block|{
name|Debug
argument_list|(
literal|4
argument_list|,
literal|"Next callout: NOW !"
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
block|}
else|else
name|Debug
argument_list|(
literal|4
argument_list|,
literal|"Next callout in %d seconds."
argument_list|,
name|when
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|when
argument_list|)
expr_stmt|;
name|unblocksig
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************  *                      Allocate_Callout                  *  * allocate (further) elements to the callout table       *  *********************************************************/
end_comment

begin_function
name|void
name|allocate_callout
parameter_list|(
name|void
parameter_list|)
block|{
name|callout_t
modifier|*
name|ntp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ntp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|callout_t
argument_list|)
operator|*
name|CALLOUT_CHUNK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntp
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|CALLOUT_CHUNK
condition|;
name|i
operator|++
control|)
name|ntp
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|&
name|ntp
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|ntp
operator|->
name|next
operator|=
name|callout_free
expr_stmt|;
name|callout_free
operator|=
operator|&
name|ntp
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|callout_nfree
operator|+=
name|CALLOUT_CHUNK
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************  *                      Clear_Callout                     *  * Removes all callout entries                            *  *********************************************************/
end_comment

begin_function
name|void
name|clear_callout
parameter_list|(
name|void
parameter_list|)
block|{
name|callout_t
modifier|*
name|ctp
decl_stmt|,
modifier|*
name|nctp
decl_stmt|;
if|if
condition|(
name|callout_tab
condition|)
name|Debug
argument_list|(
literal|4
argument_list|,
literal|"All callouts for today cancelled."
argument_list|)
expr_stmt|;
name|blocksig
argument_list|()
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ctp
operator|=
name|callout_tab
init|;
name|ctp
condition|;
name|ctp
operator|=
name|nctp
control|)
block|{
name|nctp
operator|=
name|ctp
operator|->
name|next
expr_stmt|;
name|ctp
operator|->
name|next
operator|=
name|callout_free
expr_stmt|;
name|callout_free
operator|=
name|ctp
expr_stmt|;
name|callout_nfree
operator|++
expr_stmt|;
block|}
name|unblocksig
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************  *                         Do_Callout                     *  * calls the callback routines when the time has expired  *  *********************************************************/
end_comment

begin_function
name|void
name|do_callout
parameter_list|(
name|void
parameter_list|)
block|{
name|callout_t
modifier|*
name|ctp
decl_stmt|;
name|unsigned
name|int
name|now
decl_stmt|;
name|now
operator|=
operator|(
name|unsigned
name|int
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|ctp
operator|=
name|callout_tab
init|;
name|ctp
condition|;
control|)
block|{
if|if
condition|(
name|ctp
operator|->
name|sleept
operator|>
name|now
condition|)
break|break;
name|ctp
operator|=
name|ctp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ctp
condition|)
name|ctp
operator|->
name|sleept
operator|+=
name|callout_tab
operator|->
name|sleept
expr_stmt|;
name|callout_tab
operator|->
name|next
operator|=
name|callout_free
expr_stmt|;
name|callout_free
operator|=
name|callout_tab
expr_stmt|;
name|callout_tab
operator|=
name|ctp
expr_stmt|;
name|callout_nfree
operator|++
expr_stmt|;
switch|switch
condition|(
name|callout_free
operator|->
name|what
condition|)
block|{
case|case
name|CO_ENT2TAB
case|:
name|Debug
argument_list|(
literal|3
argument_list|,
literal|"Callout -> Multiuser"
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|boing_multiuser
argument_list|,
literal|2
argument_list|)
expr_stmt|;
case|case
name|CO_FORK
case|:
case|case
name|CO_GETTY
case|:
name|Debug
argument_list|(
literal|3
argument_list|,
literal|"Callout -> do_getty()"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|do_getty
argument_list|(
operator|(
name|ttytab_t
operator|*
operator|)
name|callout_free
operator|->
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CO_MUL2SIN
case|:
name|Debug
argument_list|(
literal|3
argument_list|,
literal|"Callout -> M2S timeout"
argument_list|)
expr_stmt|;
if|if
condition|(
name|boing_m2stimeout
condition|)
name|longjmp
argument_list|(
operator|*
name|boing_m2stimeout
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* schedule next alarm */
if|if
condition|(
name|callout_tab
condition|)
block|{
name|Debug
argument_list|(
literal|4
argument_list|,
literal|"Next callout in %d seconds."
argument_list|,
name|callout_tab
operator|->
name|sleept
operator|-
name|now
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|callout_tab
operator|->
name|sleept
operator|-
name|now
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************  *                      SignalsForChile                   *  * Set up signals for the child processes                 *  *********************************************************/
end_comment

begin_function
name|void
name|signalsforchile
parameter_list|(
name|void
parameter_list|)
block|{
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|unblocksig
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

