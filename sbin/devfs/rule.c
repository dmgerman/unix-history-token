begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Dima Dorfman.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Rule subsystem manipulation.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_function_decl
specifier|static
name|void
name|rulespec_infp
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|unsigned
name|long
name|reqest
parameter_list|,
name|devfs_rsnum
name|rsnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rulespec_instr
parameter_list|(
name|struct
name|devfs_rule
modifier|*
name|dr
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|devfs_rsnum
name|rsnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rulespec_intok
parameter_list|(
name|struct
name|devfs_rule
modifier|*
name|dr
parameter_list|,
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|,
name|devfs_rsnum
name|rsnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rulespec_outfp
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|devfs_rule
modifier|*
name|dr
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|command_t
name|rule_add
decl_stmt|,
name|rule_apply
decl_stmt|,
name|rule_applyset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|command_t
name|rule_del
decl_stmt|,
name|rule_delset
decl_stmt|,
name|rule_show
decl_stmt|,
name|rule_showsets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ctbl_t
name|ctbl_rule
init|=
block|{
block|{
literal|"add"
block|,
name|rule_add
block|}
block|,
block|{
literal|"apply"
block|,
name|rule_apply
block|}
block|,
block|{
literal|"applyset"
block|,
name|rule_applyset
block|}
block|,
block|{
literal|"del"
block|,
name|rule_del
block|}
block|,
block|{
literal|"delset"
block|,
name|rule_delset
block|}
block|,
block|{
literal|"show"
block|,
name|rule_show
block|}
block|,
block|{
literal|"showsets"
block|,
name|rule_showsets
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|intstr
name|ist_type
index|[]
init|=
block|{
block|{
literal|"disk"
block|,
name|D_DISK
block|}
block|,
block|{
literal|"mem"
block|,
name|D_MEM
block|}
block|,
block|{
literal|"tape"
block|,
name|D_TAPE
block|}
block|,
block|{
literal|"tty"
block|,
name|D_TTY
block|}
block|,
block|{
name|NULL
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devfs_rsnum
name|in_rsnum
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|rule_main
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|struct
name|cmd
modifier|*
name|c
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|setprogname
argument_list|(
literal|"devfs rule"
argument_list|)
expr_stmt|;
name|optreset
operator|=
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"s:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'s'
case|:
name|in_rsnum
operator|=
name|eatonum
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|ac
operator|-=
name|optind
expr_stmt|;
name|av
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|ac
operator|<
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
for|for
control|(
name|c
operator|=
name|ctbl_rule
init|;
name|c
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|c
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|c
operator|->
name|name
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
name|exit
argument_list|(
call|(
modifier|*
name|c
operator|->
name|handler
call|)
argument_list|(
name|ac
argument_list|,
name|av
argument_list|)
argument_list|)
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown command: %s"
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rule_add
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|struct
name|devfs_rule
name|dr
decl_stmt|;
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|ac
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|rulespec_infp
argument_list|(
name|stdin
argument_list|,
name|DEVFSIO_RADD
argument_list|,
name|in_rsnum
argument_list|)
expr_stmt|;
else|else
block|{
name|rulespec_intok
argument_list|(
operator|&
name|dr
argument_list|,
name|ac
operator|-
literal|1
argument_list|,
name|av
operator|+
literal|1
argument_list|,
name|in_rsnum
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ioctl
argument_list|(
name|mpfd
argument_list|,
name|DEVFSIO_RADD
argument_list|,
operator|&
name|dr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl DEVFSIO_RADD"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rule_apply
parameter_list|(
name|int
name|ac
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|av
name|__unused
parameter_list|)
block|{
name|struct
name|devfs_rule
name|dr
decl_stmt|;
name|devfs_rnum
name|rnum
decl_stmt|;
name|devfs_rid
name|rid
decl_stmt|;
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|ac
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|atonum
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
operator|&
name|rnum
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|rulespec_infp
argument_list|(
name|stdin
argument_list|,
name|DEVFSIO_RAPPLY
argument_list|,
name|in_rsnum
argument_list|)
expr_stmt|;
else|else
block|{
name|rulespec_intok
argument_list|(
operator|&
name|dr
argument_list|,
name|ac
operator|-
literal|1
argument_list|,
name|av
operator|+
literal|1
argument_list|,
name|in_rsnum
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ioctl
argument_list|(
name|mpfd
argument_list|,
name|DEVFSIO_RAPPLY
argument_list|,
operator|&
name|dr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl DEVFSIO_RAPPLY"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rid
operator|=
name|mkrid
argument_list|(
name|in_rsnum
argument_list|,
name|rnum
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ioctl
argument_list|(
name|mpfd
argument_list|,
name|DEVFSIO_RAPPLYID
argument_list|,
operator|&
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl DEVFSIO_RAPPLYID"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rule_applyset
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
name|__unused
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|ac
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|rv
operator|=
name|ioctl
argument_list|(
name|mpfd
argument_list|,
name|DEVFSIO_SAPPLY
argument_list|,
operator|&
name|in_rsnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl DEVFSIO_SAPPLY"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rule_del
parameter_list|(
name|int
name|ac
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|devfs_rid
name|rid
decl_stmt|;
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|av
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
name|usage
argument_list|()
expr_stmt|;
name|rid
operator|=
name|mkrid
argument_list|(
name|in_rsnum
argument_list|,
name|eatoi
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ioctl
argument_list|(
name|mpfd
argument_list|,
name|DEVFSIO_RDEL
argument_list|,
operator|&
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl DEVFSIO_RDEL"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rule_delset
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
name|__unused
parameter_list|)
block|{
name|struct
name|devfs_rule
name|dr
decl_stmt|;
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|ac
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|dr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|dr
argument_list|)
argument_list|)
expr_stmt|;
name|dr
operator|.
name|dr_magic
operator|=
name|DEVFS_MAGIC
expr_stmt|;
name|dr
operator|.
name|dr_id
operator|=
name|mkrid
argument_list|(
name|in_rsnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|ioctl
argument_list|(
name|mpfd
argument_list|,
name|DEVFSIO_RGETNEXT
argument_list|,
operator|&
name|dr
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|rv
operator|=
name|ioctl
argument_list|(
name|mpfd
argument_list|,
name|DEVFSIO_RDEL
argument_list|,
operator|&
name|dr
operator|.
name|dr_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl DEVFSIO_RDEL"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl DEVFSIO_RGETNEXT"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rule_show
parameter_list|(
name|int
name|ac
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|struct
name|devfs_rule
name|dr
decl_stmt|;
name|devfs_rnum
name|rnum
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|memset
argument_list|(
operator|&
name|dr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|dr
argument_list|)
argument_list|)
expr_stmt|;
name|dr
operator|.
name|dr_magic
operator|=
name|DEVFS_MAGIC
expr_stmt|;
if|if
condition|(
name|av
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|rnum
operator|=
name|eatoi
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dr
operator|.
name|dr_id
operator|=
name|mkrid
argument_list|(
name|in_rsnum
argument_list|,
name|rnum
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ioctl
argument_list|(
name|mpfd
argument_list|,
name|DEVFSIO_RGETNEXT
argument_list|,
operator|&
name|dr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl DEVFSIO_RGETNEXT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rid2rn
argument_list|(
name|dr
operator|.
name|dr_id
argument_list|)
operator|==
name|rnum
condition|)
name|rulespec_outfp
argument_list|(
name|stdout
argument_list|,
operator|&
name|dr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dr
operator|.
name|dr_id
operator|=
name|mkrid
argument_list|(
name|in_rsnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|ioctl
argument_list|(
name|mpfd
argument_list|,
name|DEVFSIO_RGETNEXT
argument_list|,
operator|&
name|dr
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|rulespec_outfp
argument_list|(
name|stdout
argument_list|,
operator|&
name|dr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl DEVFSIO_RGETNEXT"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rule_showsets
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
name|__unused
parameter_list|)
block|{
name|devfs_rsnum
name|rsnum
decl_stmt|;
if|if
condition|(
name|ac
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|rsnum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ioctl
argument_list|(
name|mpfd
argument_list|,
name|DEVFSIO_SGETNEXT
argument_list|,
operator|&
name|rsnum
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|rsnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl DEVFSIO_SGETNEXT"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ruleset_main
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|devfs_rsnum
name|rsnum
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|setprogname
argument_list|(
literal|"devfs ruleset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
name|rsnum
operator|=
name|eatonum
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ioctl
argument_list|(
name|mpfd
argument_list|,
name|DEVFSIO_SUSE
argument_list|,
operator|&
name|rsnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl DEVFSIO_SUSE"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Input rules from a file (probably the standard input).  This  * differs from the other rulespec_in*() routines in that it also  * calls ioctl() for the rules, since it is impractical (and not very  * useful) to return a list (or array) of rules, just so the caller  * can call call ioctl() for each of them.  */
end_comment

begin_function
specifier|static
name|void
name|rulespec_infp
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|unsigned
name|long
name|request
parameter_list|,
name|devfs_rsnum
name|rsnum
parameter_list|)
block|{
name|struct
name|devfs_rule
name|dr
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|assert
argument_list|(
name|fp
operator|==
name|stdin
argument_list|)
expr_stmt|;
comment|/* XXX: De-hardcode "stdin" from error msg. */
while|while
condition|(
name|efgetln
argument_list|(
name|fp
argument_list|,
operator|&
name|line
argument_list|)
condition|)
block|{
name|rulespec_instr
argument_list|(
operator|&
name|dr
argument_list|,
name|line
argument_list|,
name|rsnum
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ioctl
argument_list|(
name|mpfd
argument_list|,
name|request
argument_list|,
operator|&
name|dr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* efgetln() always malloc()s. */
block|}
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"stdin"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Construct a /struct devfs_rule/ from a string.  */
end_comment

begin_function
specifier|static
name|void
name|rulespec_instr
parameter_list|(
name|struct
name|devfs_rule
modifier|*
name|dr
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|devfs_rsnum
name|rsnum
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|tokenize
argument_list|(
name|str
argument_list|,
operator|&
name|ac
argument_list|,
operator|&
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unexpected end of rulespec"
argument_list|)
expr_stmt|;
name|rulespec_intok
argument_list|(
name|dr
argument_list|,
name|ac
argument_list|,
name|av
argument_list|,
name|rsnum
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Construct a /struct devfs_rule/ from ac and av.  */
end_comment

begin_function
specifier|static
name|void
name|rulespec_intok
parameter_list|(
name|struct
name|devfs_rule
modifier|*
name|dr
parameter_list|,
name|int
name|ac
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|,
name|devfs_rsnum
name|rsnum
parameter_list|)
block|{
name|struct
name|intstr
modifier|*
name|is
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
name|devfs_rnum
name|rnum
decl_stmt|;
name|void
modifier|*
name|set
decl_stmt|;
name|memset
argument_list|(
name|dr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We don't maintain ac hereinafter. 	 */
if|if
condition|(
name|av
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unexpected end of rulespec"
argument_list|)
expr_stmt|;
comment|/* If the first argument is an integer, treat it as a rule number. */
if|if
condition|(
operator|!
name|atonum
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|&
name|rnum
argument_list|)
condition|)
name|rnum
operator|=
literal|0
expr_stmt|;
comment|/* auto-number */
else|else
operator|++
name|av
expr_stmt|;
comment|/* 	 * These aren't table-driven since that would result in more 	 * tiny functions than I care to deal with. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|av
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
break|break;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"type"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|av
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"expecting argument for type"
argument_list|)
expr_stmt|;
for|for
control|(
name|is
operator|=
name|ist_type
init|;
name|is
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|is
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
name|is
operator|->
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dr
operator|->
name|dr_dswflags
operator||=
name|is
operator|->
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is
operator|->
name|s
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown type: %s"
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dr
operator|->
name|dr_icond
operator||=
name|DRC_DSWFLAGS
expr_stmt|;
name|av
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"path"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|av
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"expecting argument for path"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|dr
operator|->
name|dr_pathptrn
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|DEVFS_MAXPTRNLEN
argument_list|)
operator|>=
name|DEVFS_MAXPTRNLEN
condition|)
name|warnx
argument_list|(
literal|"pattern specified too long; truncated"
argument_list|)
expr_stmt|;
name|dr
operator|->
name|dr_icond
operator||=
name|DRC_PATHPTRN
expr_stmt|;
name|av
operator|+=
literal|2
expr_stmt|;
block|}
else|else
break|break;
block|}
while|while
condition|(
name|av
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"hide"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dr
operator|->
name|dr_iacts
operator||=
name|DRA_BACTS
expr_stmt|;
name|dr
operator|->
name|dr_bacts
operator||=
name|DRB_HIDE
expr_stmt|;
operator|++
name|av
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"unhide"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dr
operator|->
name|dr_iacts
operator||=
name|DRA_BACTS
expr_stmt|;
name|dr
operator|->
name|dr_bacts
operator||=
name|DRB_UNHIDE
expr_stmt|;
operator|++
name|av
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"user"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|av
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"expecting argument for user"
argument_list|)
expr_stmt|;
name|dr
operator|->
name|dr_iacts
operator||=
name|DRA_UID
expr_stmt|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
name|dr
operator|->
name|dr_uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
else|else
name|dr
operator|->
name|dr_uid
operator|=
name|eatoi
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* XXX overflow */
name|av
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"group"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|av
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"expecting argument for group"
argument_list|)
expr_stmt|;
name|dr
operator|->
name|dr_iacts
operator||=
name|DRA_GID
expr_stmt|;
name|gr
operator|=
name|getgrnam
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|!=
name|NULL
condition|)
name|dr
operator|->
name|dr_gid
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
else|else
name|dr
operator|->
name|dr_gid
operator|=
name|eatoi
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* XXX overflow */
name|av
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"mode"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|av
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"expecting argument for mode"
argument_list|)
expr_stmt|;
name|dr
operator|->
name|dr_iacts
operator||=
name|DRA_MODE
expr_stmt|;
name|set
operator|=
name|setmode
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid mode: %s"
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dr
operator|->
name|dr_mode
operator|=
name|getmode
argument_list|(
name|set
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|av
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"include"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|av
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"expecting argument for include"
argument_list|)
expr_stmt|;
name|dr
operator|->
name|dr_iacts
operator||=
name|DRA_INCSET
expr_stmt|;
name|dr
operator|->
name|dr_incset
operator|=
name|eatonum
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|av
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown argument: %s"
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|dr
operator|->
name|dr_id
operator|=
name|mkrid
argument_list|(
name|rsnum
argument_list|,
name|rnum
argument_list|)
expr_stmt|;
name|dr
operator|->
name|dr_magic
operator|=
name|DEVFS_MAGIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a human-readable (and machine-parsable, by rulespec_in*())  * representation of dr to bufp.  *bufp should be free(3)'d when the  * caller is finished with it.  */
end_comment

begin_function
specifier|static
name|void
name|rulespec_outfp
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|devfs_rule
modifier|*
name|dr
parameter_list|)
block|{
name|struct
name|intstr
modifier|*
name|is
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
name|rid2rn
argument_list|(
name|dr
operator|->
name|dr_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_icond
operator|&
name|DRC_DSWFLAGS
condition|)
for|for
control|(
name|is
operator|=
name|ist_type
init|;
name|is
operator|->
name|s
operator|!=
name|NULL
condition|;
operator|++
name|is
control|)
if|if
condition|(
name|dr
operator|->
name|dr_dswflags
operator|&
name|is
operator|->
name|i
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" type %s"
argument_list|,
name|is
operator|->
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_icond
operator|&
name|DRC_PATHPTRN
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" path %s"
argument_list|,
name|dr
operator|->
name|dr_pathptrn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_iacts
operator|&
name|DRA_BACTS
condition|)
block|{
if|if
condition|(
name|dr
operator|->
name|dr_bacts
operator|&
name|DRB_HIDE
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" hide"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_bacts
operator|&
name|DRB_UNHIDE
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" unhide"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dr
operator|->
name|dr_iacts
operator|&
name|DRA_UID
condition|)
block|{
name|pw
operator|=
name|getpwuid
argument_list|(
name|dr
operator|->
name|dr_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" user %d"
argument_list|,
name|dr
operator|->
name|dr_uid
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" user %s"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dr
operator|->
name|dr_iacts
operator|&
name|DRA_GID
condition|)
block|{
name|gr
operator|=
name|getgrgid
argument_list|(
name|dr
operator|->
name|dr_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" group %d"
argument_list|,
name|dr
operator|->
name|dr_gid
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" group %s"
argument_list|,
name|gr
operator|->
name|gr_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dr
operator|->
name|dr_iacts
operator|&
name|DRA_MODE
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" mode %o"
argument_list|,
name|dr
operator|->
name|dr_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_iacts
operator|&
name|DRA_INCSET
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" include %d"
argument_list|,
name|dr
operator|->
name|dr_incset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

