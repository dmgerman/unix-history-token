begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: fsdb.c,v 1.2 1995/10/08 23:18:10 thorpej Exp $	*/
end_comment

begin_comment
comment|/*  *  Copyright (c) 1995 John T. Kohl  *  All rights reserved.  *   *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  3. The name of the author may not be used to endorse or promote products  *     derived from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  *		$Id$  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: fsdb.c,v 1.8 1997/04/15 09:02:45 joerg Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<histedit.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dir.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|"fsdb.h"
end_include

begin_include
include|#
directive|include
file|"fsck.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|usage
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmdloop
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: fsdb [-d] [-f] [-r] fsname\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|returntosingle
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|nflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We suck in lots of fsck code, and just pick& choose the stuff we want.  *  * fsreadfd is set up to read from the file system, fswritefd to write to  * the file system.  */
end_comment

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|,
name|rval
decl_stmt|;
name|char
modifier|*
name|fsys
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|-
literal|1
operator|!=
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"fdr"
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* The -f option is left for historical 			 * reasons and has no meaning. 			 */
break|break;
case|case
literal|'d'
case|:
name|debug
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|nflag
operator|++
expr_stmt|;
comment|/* "no" in fsck, readonly for us */
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
else|else
name|fsys
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|setup
argument_list|(
name|fsys
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"cannot set up file system `%s'"
argument_list|,
name|fsys
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s file system `%s'\nLast Mounted on %s\n"
argument_list|,
name|nflag
condition|?
literal|"Examining"
else|:
literal|"Editing"
argument_list|,
name|fsys
argument_list|,
name|sblock
operator|.
name|fs_fsmnt
argument_list|)
expr_stmt|;
name|rval
operator|=
name|cmdloop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|nflag
condition|)
block|{
name|sblock
operator|.
name|fs_clean
operator|=
literal|0
expr_stmt|;
comment|/* mark it dirty */
name|sbdirty
argument_list|()
expr_stmt|;
name|ckfini
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*** FILE SYSTEM MARKED DIRTY\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*** BE SURE TO RUN FSCK TO CLEAN UP ANY DAMAGE\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*** IF IT WAS MOUNTED, RE-MOUNT WITH -u -o reload\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|CMDFUNC
parameter_list|(
name|func
parameter_list|)
value|int func __P((int argc, char *argv[]))
end_define

begin_define
define|#
directive|define
name|CMDFUNCSTART
parameter_list|(
name|func
parameter_list|)
value|int func(argc, argv)		\ 				int argc;		\ 				char *argv[];
end_define

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|helpfn
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|focus
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* focus on inode */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|active
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* print active inode */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|focusname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* focus by name */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|zapi
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* clear inode */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|uplink
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* incr link */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|downlink
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* decr link */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|linkcount
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* set link count */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|quit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* quit */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|ls
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* list directory */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|rm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* remove name */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|ln
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* add name */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|newtype
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* change type */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chmode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* change mode */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chlen
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* change length */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chaflags
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* change flags */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chgen
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* change generation */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chowner
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* change owner */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chgroup
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Change group */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|back
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* pop back to last ino */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chmtime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Change mtime */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chctime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Change ctime */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chatime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Change atime */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chinum
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Change inode # of dirent */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Change dirname of dirent */
end_comment

begin_decl_stmt
name|struct
name|cmdtable
name|cmds
index|[]
init|=
block|{
block|{
literal|"help"
block|,
literal|"Print out help"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|helpfn
block|}
block|,
block|{
literal|"?"
block|,
literal|"Print out help"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|helpfn
block|}
block|,
block|{
literal|"inode"
block|,
literal|"Set active inode to INUM"
block|,
literal|2
block|,
literal|2
block|,
name|FL_RO
block|,
name|focus
block|}
block|,
block|{
literal|"clri"
block|,
literal|"Clear inode INUM"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|zapi
block|}
block|,
block|{
literal|"lookup"
block|,
literal|"Set active inode by looking up NAME"
block|,
literal|2
block|,
literal|2
block|,
name|FL_RO
block|,
name|focusname
block|}
block|,
block|{
literal|"cd"
block|,
literal|"Set active inode by looking up NAME"
block|,
literal|2
block|,
literal|2
block|,
name|FL_RO
block|,
name|focusname
block|}
block|,
block|{
literal|"back"
block|,
literal|"Go to previous active inode"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|back
block|}
block|,
block|{
literal|"active"
block|,
literal|"Print active inode"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|active
block|}
block|,
block|{
literal|"print"
block|,
literal|"Print active inode"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|active
block|}
block|,
block|{
literal|"uplink"
block|,
literal|"Increment link count"
block|,
literal|1
block|,
literal|1
block|,
name|FL_WR
block|,
name|uplink
block|}
block|,
block|{
literal|"downlink"
block|,
literal|"Decrement link count"
block|,
literal|1
block|,
literal|1
block|,
name|FL_WR
block|,
name|downlink
block|}
block|,
block|{
literal|"linkcount"
block|,
literal|"Set link count to COUNT"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|linkcount
block|}
block|,
block|{
literal|"ls"
block|,
literal|"List current inode as directory"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|ls
block|}
block|,
block|{
literal|"rm"
block|,
literal|"Remove NAME from current inode directory"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|rm
block|}
block|,
block|{
literal|"del"
block|,
literal|"Remove NAME from current inode directory"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|rm
block|}
block|,
block|{
literal|"ln"
block|,
literal|"Hardlink INO into current inode directory as NAME"
block|,
literal|3
block|,
literal|3
block|,
name|FL_WR
block|,
name|ln
block|}
block|,
block|{
literal|"chinum"
block|,
literal|"Change dir entry number INDEX to INUM"
block|,
literal|3
block|,
literal|3
block|,
name|FL_WR
block|,
name|chinum
block|}
block|,
block|{
literal|"chname"
block|,
literal|"Change dir entry number INDEX to NAME"
block|,
literal|3
block|,
literal|3
block|,
name|FL_WR
block|,
name|chname
block|}
block|,
block|{
literal|"chtype"
block|,
literal|"Change type of current inode to TYPE"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|newtype
block|}
block|,
block|{
literal|"chmod"
block|,
literal|"Change mode of current inode to MODE"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chmode
block|}
block|,
block|{
literal|"chlen"
block|,
literal|"Change length of current inode to LENGTH"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chlen
block|}
block|,
block|{
literal|"chown"
block|,
literal|"Change owner of current inode to OWNER"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chowner
block|}
block|,
block|{
literal|"chgrp"
block|,
literal|"Change group of current inode to GROUP"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chgroup
block|}
block|,
block|{
literal|"chflags"
block|,
literal|"Change flags of current inode to FLAGS"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chaflags
block|}
block|,
block|{
literal|"chgen"
block|,
literal|"Change generation number of current inode to GEN"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chgen
block|}
block|,
block|{
literal|"mtime"
block|,
literal|"Change mtime of current inode to MTIME"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chmtime
block|}
block|,
block|{
literal|"ctime"
block|,
literal|"Change ctime of current inode to CTIME"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chctime
block|}
block|,
block|{
literal|"atime"
block|,
literal|"Change atime of current inode to ATIME"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chatime
block|}
block|,
block|{
literal|"quit"
block|,
literal|"Exit"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|quit
block|}
block|,
block|{
literal|"q"
block|,
literal|"Exit"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|quit
block|}
block|,
block|{
literal|"exit"
block|,
literal|"Exit"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|quit
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|helpfn
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|struct
name|cmdtable
modifier|*
name|cmdtp
decl_stmt|;
name|printf
argument_list|(
literal|"Commands are:\n%-10s %5s %5s   %s\n"
argument_list|,
literal|"command"
argument_list|,
literal|"min argc"
argument_list|,
literal|"max argc"
argument_list|,
literal|"what"
argument_list|)
expr_stmt|;
for|for
control|(
name|cmdtp
operator|=
name|cmds
init|;
name|cmdtp
operator|->
name|cmd
condition|;
name|cmdtp
operator|++
control|)
name|printf
argument_list|(
literal|"%-10s %5u %5u   %s\n"
argument_list|,
name|cmdtp
operator|->
name|cmd
argument_list|,
name|cmdtp
operator|->
name|minargc
argument_list|,
name|cmdtp
operator|->
name|maxargc
argument_list|,
name|cmdtp
operator|->
name|helptxt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|prompt
parameter_list|(
name|el
parameter_list|)
name|EditLine
modifier|*
name|el
decl_stmt|;
block|{
specifier|static
name|char
name|pstring
index|[
literal|64
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|pstring
argument_list|,
sizeof|sizeof
argument_list|(
name|pstring
argument_list|)
argument_list|,
literal|"fsdb (inum: %d)> "
argument_list|,
name|curinum
argument_list|)
expr_stmt|;
return|return
name|pstring
return|;
block|}
end_function

begin_function
name|int
name|cmdloop
parameter_list|()
block|{
name|char
modifier|*
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|elline
decl_stmt|;
name|int
name|cmd_argc
decl_stmt|,
name|rval
init|=
literal|0
decl_stmt|,
name|known
decl_stmt|;
define|#
directive|define
name|scratch
value|known
name|char
modifier|*
modifier|*
name|cmd_argv
decl_stmt|;
name|struct
name|cmdtable
modifier|*
name|cmdp
decl_stmt|;
name|History
modifier|*
name|hist
decl_stmt|;
name|EditLine
modifier|*
name|elptr
decl_stmt|;
name|curinode
operator|=
name|ginode
argument_list|(
name|ROOTINO
argument_list|)
expr_stmt|;
name|curinum
operator|=
name|ROOTINO
expr_stmt|;
name|printactive
argument_list|()
expr_stmt|;
name|hist
operator|=
name|history_init
argument_list|()
expr_stmt|;
name|history
argument_list|(
name|hist
argument_list|,
name|H_EVENT
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|/* 100 elt history buffer */
name|elptr
operator|=
name|el_init
argument_list|(
literal|"fsdb"
argument_list|,
name|stdin
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|elptr
argument_list|,
name|EL_EDITOR
argument_list|,
literal|"emacs"
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|elptr
argument_list|,
name|EL_PROMPT
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|elptr
argument_list|,
name|EL_HIST
argument_list|,
name|history
argument_list|,
name|hist
argument_list|)
expr_stmt|;
name|el_source
argument_list|(
name|elptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|elline
operator|=
name|el_gets
argument_list|(
name|elptr
argument_list|,
operator|&
name|scratch
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|scratch
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"command `%s'\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|history
argument_list|(
name|hist
argument_list|,
name|H_ENTER
argument_list|,
name|elline
argument_list|)
expr_stmt|;
name|line
operator|=
name|strdup
argument_list|(
name|elline
argument_list|)
expr_stmt|;
name|cmd_argv
operator|=
name|crack
argument_list|(
name|line
argument_list|,
operator|&
name|cmd_argc
argument_list|)
expr_stmt|;
comment|/* 	 * el_parse returns -1 to signal that it's not been handled 	 * internally. 	 */
if|if
condition|(
name|el_parse
argument_list|(
name|elptr
argument_list|,
name|cmd_argc
argument_list|,
name|cmd_argv
argument_list|)
operator|!=
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|cmd_argc
condition|)
block|{
name|known
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cmdp
operator|=
name|cmds
init|;
name|cmdp
operator|->
name|cmd
condition|;
name|cmdp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmdp
operator|->
name|cmd
argument_list|,
name|cmd_argv
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|cmdp
operator|->
name|flags
operator|&
name|FL_WR
operator|)
operator|==
name|FL_WR
operator|&&
name|nflag
condition|)
name|warnx
argument_list|(
literal|"`%s' requires write access"
argument_list|,
name|cmd_argv
index|[
literal|0
index|]
argument_list|)
operator|,
name|rval
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd_argc
operator|>=
name|cmdp
operator|->
name|minargc
operator|&&
name|cmd_argc
operator|<=
name|cmdp
operator|->
name|maxargc
condition|)
name|rval
operator|=
call|(
modifier|*
name|cmdp
operator|->
name|handler
call|)
argument_list|(
name|cmd_argc
argument_list|,
name|cmd_argv
argument_list|)
expr_stmt|;
else|else
name|rval
operator|=
name|argcount
argument_list|(
name|cmdp
argument_list|,
name|cmd_argc
argument_list|,
name|cmd_argv
argument_list|)
expr_stmt|;
name|known
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|known
condition|)
name|warnx
argument_list|(
literal|"unknown command `%s'"
argument_list|,
name|cmd_argv
index|[
literal|0
index|]
argument_list|)
operator|,
name|rval
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|rval
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|<
literal|0
condition|)
return|return
name|rval
return|;
if|if
condition|(
name|rval
condition|)
name|warnx
argument_list|(
literal|"rval was %d"
argument_list|,
name|rval
argument_list|)
expr_stmt|;
block|}
name|el_end
argument_list|(
name|elptr
argument_list|)
expr_stmt|;
name|history_end
argument_list|(
name|hist
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|dinode
modifier|*
name|curinode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|curinum
decl_stmt|,
name|ocurrent
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GETINUM
parameter_list|(
name|ac
parameter_list|,
name|inum
parameter_list|)
value|inum = strtoul(argv[ac],&cp, 0); \     if (inum< ROOTINO || inum> maxino || cp == argv[ac] || *cp != '\0' ) { \ 	printf("inode %d out of range; range is [%d,%d]\n", \ 	       inum, ROOTINO, maxino); \ 	return 1; \     }
end_define

begin_comment
comment|/*  * Focus on given inode number  */
end_comment

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|focus
argument_list|)
end_macro

begin_block
block|{
name|ino_t
name|inum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|GETINUM
argument_list|(
literal|1
argument_list|,
name|inum
argument_list|)
expr_stmt|;
name|curinode
operator|=
name|ginode
argument_list|(
name|inum
argument_list|)
expr_stmt|;
name|ocurrent
operator|=
name|curinum
expr_stmt|;
name|curinum
operator|=
name|inum
expr_stmt|;
name|printactive
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|back
argument_list|)
end_macro

begin_block
block|{
name|curinum
operator|=
name|ocurrent
expr_stmt|;
name|curinode
operator|=
name|ginode
argument_list|(
name|curinum
argument_list|)
expr_stmt|;
name|printactive
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|zapi
argument_list|)
end_macro

begin_block
block|{
name|ino_t
name|inum
decl_stmt|;
name|struct
name|dinode
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|GETINUM
argument_list|(
literal|1
argument_list|,
name|inum
argument_list|)
expr_stmt|;
name|dp
operator|=
name|ginode
argument_list|(
name|inum
argument_list|)
expr_stmt|;
name|clearinode
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
if|if
condition|(
name|curinode
condition|)
comment|/* re-set after potential change */
name|curinode
operator|=
name|ginode
argument_list|(
name|curinum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|active
argument_list|)
end_macro

begin_block
block|{
name|printactive
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|quit
argument_list|)
end_macro

begin_block
block|{
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|uplink
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|printf
argument_list|(
literal|"inode %d link count now %d\n"
argument_list|,
name|curinum
argument_list|,
operator|++
name|curinode
operator|->
name|di_nlink
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|downlink
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|printf
argument_list|(
literal|"inode %d link count now %d\n"
argument_list|,
name|curinum
argument_list|,
operator|--
name|curinode
operator|->
name|di_nlink
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_decl_stmt
specifier|const
name|char
modifier|*
name|typename
index|[]
init|=
block|{
literal|"unknown"
block|,
literal|"fifo"
block|,
literal|"char special"
block|,
literal|"unregistered #3"
block|,
literal|"directory"
block|,
literal|"unregistered #5"
block|,
literal|"blk special"
block|,
literal|"unregistered #7"
block|,
literal|"regular"
block|,
literal|"unregistered #9"
block|,
literal|"symlink"
block|,
literal|"unregistered #11"
block|,
literal|"socket"
block|,
literal|"unregistered #13"
block|,
literal|"whiteout"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|slot
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|scannames
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|inodesc
modifier|*
name|idesc
decl_stmt|;
block|{
specifier|register
name|struct
name|direct
modifier|*
name|dirp
init|=
name|idesc
operator|->
name|id_dirp
decl_stmt|;
name|printf
argument_list|(
literal|"slot %d ino %d reclen %d: %s, `%.*s'\n"
argument_list|,
name|slot
operator|++
argument_list|,
name|dirp
operator|->
name|d_ino
argument_list|,
name|dirp
operator|->
name|d_reclen
argument_list|,
name|typename
index|[
name|dirp
operator|->
name|d_type
index|]
argument_list|,
name|dirp
operator|->
name|d_namlen
argument_list|,
name|dirp
operator|->
name|d_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_function

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|ls
argument_list|)
end_macro

begin_block
block|{
name|struct
name|inodesc
name|idesc
decl_stmt|;
name|checkactivedir
argument_list|()
expr_stmt|;
comment|/* let it go on anyway */
name|slot
operator|=
literal|0
expr_stmt|;
name|idesc
operator|.
name|id_number
operator|=
name|curinum
expr_stmt|;
name|idesc
operator|.
name|id_func
operator|=
name|scannames
expr_stmt|;
name|idesc
operator|.
name|id_type
operator|=
name|DATA
expr_stmt|;
name|idesc
operator|.
name|id_fix
operator|=
name|IGNORE
expr_stmt|;
name|ckinode
argument_list|(
name|curinode
argument_list|,
operator|&
name|idesc
argument_list|)
expr_stmt|;
name|curinode
operator|=
name|ginode
argument_list|(
name|curinum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_decl_stmt
name|int
name|findino
name|__P
argument_list|(
operator|(
expr|struct
name|inodesc
operator|*
name|idesc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from fsck */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dolookup
name|__P
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|dolookup
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|inodesc
name|idesc
decl_stmt|;
if|if
condition|(
operator|!
name|checkactivedir
argument_list|()
condition|)
return|return
literal|0
return|;
name|idesc
operator|.
name|id_number
operator|=
name|curinum
expr_stmt|;
name|idesc
operator|.
name|id_func
operator|=
name|findino
expr_stmt|;
name|idesc
operator|.
name|id_name
operator|=
name|name
expr_stmt|;
name|idesc
operator|.
name|id_type
operator|=
name|DATA
expr_stmt|;
name|idesc
operator|.
name|id_fix
operator|=
name|IGNORE
expr_stmt|;
if|if
condition|(
name|ckinode
argument_list|(
name|curinode
argument_list|,
operator|&
name|idesc
argument_list|)
operator|&
name|FOUND
condition|)
block|{
name|curinum
operator|=
name|idesc
operator|.
name|id_parent
expr_stmt|;
name|curinode
operator|=
name|ginode
argument_list|(
name|curinum
argument_list|)
expr_stmt|;
name|printactive
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"name `%s' not found in current inode directory"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|focusname
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|ocurrent
operator|=
name|curinum
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|curinum
operator|=
name|ROOTINO
expr_stmt|;
name|curinode
operator|=
name|ginode
argument_list|(
name|ROOTINO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|checkactivedir
argument_list|()
condition|)
return|return
literal|1
return|;
block|}
for|for
control|(
name|p
operator|=
name|argv
index|[
literal|1
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|val
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|"/"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|val
operator|==
literal|'\0'
condition|)
empty_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|printf
argument_list|(
literal|"component `%s': "
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dolookup
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|curinode
operator|=
name|ginode
argument_list|(
name|curinum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|ln
argument_list|)
end_macro

begin_block
block|{
name|ino_t
name|inum
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|GETINUM
argument_list|(
literal|1
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkactivedir
argument_list|()
condition|)
return|return
literal|1
return|;
name|rval
operator|=
name|makeentry
argument_list|(
name|curinum
argument_list|,
name|inum
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
name|printf
argument_list|(
literal|"Ino %d entered as `%s'\n"
argument_list|,
name|inum
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"could not enter name? weird.\n"
argument_list|)
expr_stmt|;
name|curinode
operator|=
name|ginode
argument_list|(
name|curinum
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|rm
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
decl_stmt|;
if|if
condition|(
operator|!
name|checkactivedir
argument_list|()
condition|)
return|return
literal|1
return|;
name|rval
operator|=
name|changeino
argument_list|(
name|curinum
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|&
name|ALTERED
condition|)
block|{
name|printf
argument_list|(
literal|"Name `%s' removed\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"could not remove name? weird.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_block

begin_decl_stmt
name|long
name|slotcount
decl_stmt|,
name|desired
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|chinumfunc
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|inodesc
modifier|*
name|idesc
decl_stmt|;
block|{
specifier|register
name|struct
name|direct
modifier|*
name|dirp
init|=
name|idesc
operator|->
name|id_dirp
decl_stmt|;
if|if
condition|(
name|slotcount
operator|++
operator|==
name|desired
condition|)
block|{
name|dirp
operator|->
name|d_ino
operator|=
name|idesc
operator|->
name|id_parent
expr_stmt|;
return|return
name|STOP
operator||
name|ALTERED
operator||
name|FOUND
return|;
block|}
return|return
name|KEEPON
return|;
block|}
end_function

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chinum
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
name|struct
name|inodesc
name|idesc
decl_stmt|;
name|slotcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|checkactivedir
argument_list|()
condition|)
return|return
literal|1
return|;
name|GETINUM
argument_list|(
literal|2
argument_list|,
name|inum
argument_list|)
expr_stmt|;
name|desired
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
operator|||
name|desired
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"invalid slot number `%s'\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|idesc
operator|.
name|id_number
operator|=
name|curinum
expr_stmt|;
name|idesc
operator|.
name|id_func
operator|=
name|chinumfunc
expr_stmt|;
name|idesc
operator|.
name|id_fix
operator|=
name|IGNORE
expr_stmt|;
name|idesc
operator|.
name|id_type
operator|=
name|DATA
expr_stmt|;
name|idesc
operator|.
name|id_parent
operator|=
name|inum
expr_stmt|;
comment|/* XXX convenient hiding place */
if|if
condition|(
name|ckinode
argument_list|(
name|curinode
argument_list|,
operator|&
name|idesc
argument_list|)
operator|&
name|FOUND
condition|)
return|return
literal|0
return|;
else|else
block|{
name|warnx
argument_list|(
literal|"no %sth slot in current directory"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_block

begin_function
name|int
name|chnamefunc
parameter_list|(
name|idesc
parameter_list|)
name|struct
name|inodesc
modifier|*
name|idesc
decl_stmt|;
block|{
specifier|register
name|struct
name|direct
modifier|*
name|dirp
init|=
name|idesc
operator|->
name|id_dirp
decl_stmt|;
name|struct
name|direct
name|testdir
decl_stmt|;
if|if
condition|(
name|slotcount
operator|++
operator|==
name|desired
condition|)
block|{
comment|/* will name fit? */
name|testdir
operator|.
name|d_namlen
operator|=
name|strlen
argument_list|(
name|idesc
operator|->
name|id_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|DIRSIZ
argument_list|(
name|NEWDIRFMT
argument_list|,
operator|&
name|testdir
argument_list|)
operator|<=
name|dirp
operator|->
name|d_reclen
condition|)
block|{
name|dirp
operator|->
name|d_namlen
operator|=
name|testdir
operator|.
name|d_namlen
expr_stmt|;
name|strcpy
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|,
name|idesc
operator|->
name|id_name
argument_list|)
expr_stmt|;
return|return
name|STOP
operator||
name|ALTERED
operator||
name|FOUND
return|;
block|}
else|else
return|return
name|STOP
operator||
name|FOUND
return|;
comment|/* won't fit, so give up */
block|}
return|return
name|KEEPON
return|;
block|}
end_function

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chname
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|inodesc
name|idesc
decl_stmt|;
name|slotcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|checkactivedir
argument_list|()
condition|)
return|return
literal|1
return|;
name|desired
operator|=
name|strtoul
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"invalid slot number `%s'\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|idesc
operator|.
name|id_number
operator|=
name|curinum
expr_stmt|;
name|idesc
operator|.
name|id_func
operator|=
name|chnamefunc
expr_stmt|;
name|idesc
operator|.
name|id_fix
operator|=
name|IGNORE
expr_stmt|;
name|idesc
operator|.
name|id_type
operator|=
name|DATA
expr_stmt|;
name|idesc
operator|.
name|id_name
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|rval
operator|=
name|ckinode
argument_list|(
name|curinode
argument_list|,
operator|&
name|idesc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|&
operator|(
name|FOUND
operator||
name|ALTERED
operator|)
operator|)
operator|==
operator|(
name|FOUND
operator||
name|ALTERED
operator|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|rval
operator|&
name|FOUND
condition|)
block|{
name|warnx
argument_list|(
literal|"new name `%s' does not fit in slot %s\n"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"no %sth slot in current directory"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_block

begin_struct
struct|struct
name|typemap
block|{
specifier|const
name|char
modifier|*
name|typename
decl_stmt|;
name|int
name|typebits
decl_stmt|;
block|}
name|typenamemap
index|[]
init|=
block|{
block|{
literal|"file"
block|,
name|IFREG
block|}
block|,
block|{
literal|"dir"
block|,
name|IFDIR
block|}
block|,
block|{
literal|"socket"
block|,
name|IFSOCK
block|}
block|,
block|{
literal|"fifo"
block|,
name|IFIFO
block|}
block|, }
struct|;
end_struct

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|newtype
argument_list|)
end_macro

begin_block
block|{
name|int
name|type
decl_stmt|;
name|struct
name|typemap
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|type
operator|=
name|curinode
operator|->
name|di_mode
operator|&
name|IFMT
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|typenamemap
init|;
name|tp
operator|<
operator|&
name|typenamemap
index|[
sizeof|sizeof
argument_list|(
name|typemap
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|typemap
argument_list|)
index|]
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|tp
operator|->
name|typename
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"setting type to %s\n"
argument_list|,
name|tp
operator|->
name|typename
argument_list|)
expr_stmt|;
name|type
operator|=
name|tp
operator|->
name|typebits
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tp
operator|==
operator|&
name|typenamemap
index|[
sizeof|sizeof
argument_list|(
name|typemap
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|typemap
argument_list|)
index|]
condition|)
block|{
name|warnx
argument_list|(
literal|"type `%s' not known"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"try one of `file', `dir', `socket', `fifo'"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|curinode
operator|->
name|di_mode
operator|&=
operator|~
name|IFMT
expr_stmt|;
name|curinode
operator|->
name|di_mode
operator||=
name|type
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chlen
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
init|=
literal|1
decl_stmt|;
name|long
name|len
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|len
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
operator|||
name|len
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"bad length `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|curinode
operator|->
name|di_size
operator|=
name|len
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|()
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chmode
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
init|=
literal|1
decl_stmt|;
name|long
name|modebits
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|modebits
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"bad modebits `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|curinode
operator|->
name|di_mode
operator|&=
operator|~
literal|07777
expr_stmt|;
name|curinode
operator|->
name|di_mode
operator||=
name|modebits
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|()
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chaflags
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
init|=
literal|1
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|flags
operator|=
name|strtoul
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"bad flags `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|flags
operator|>
name|UINT_MAX
condition|)
block|{
name|warnx
argument_list|(
literal|"flags set beyond 32-bit range of field (%lx)\n"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|curinode
operator|->
name|di_flags
operator|=
name|flags
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|()
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chgen
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
init|=
literal|1
decl_stmt|;
name|long
name|gen
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|gen
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"bad gen `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gen
operator|>
name|INT_MAX
operator|||
name|gen
operator|<
name|INT_MIN
condition|)
block|{
name|warnx
argument_list|(
literal|"gen set beyond 32-bit range of field (%lx)\n"
argument_list|,
name|gen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|curinode
operator|->
name|di_gen
operator|=
name|gen
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|()
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|linkcount
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
init|=
literal|1
decl_stmt|;
name|int
name|lcnt
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|lcnt
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"bad link count `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|lcnt
operator|>
name|USHRT_MAX
operator|||
name|lcnt
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"max link count is %d\n"
argument_list|,
name|USHRT_MAX
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|curinode
operator|->
name|di_nlink
operator|=
name|lcnt
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|()
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chowner
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
init|=
literal|1
decl_stmt|;
name|unsigned
name|long
name|uid
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|uid
operator|=
name|strtoul
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
comment|/* try looking up name */
if|if
condition|(
name|pwd
operator|=
name|getpwnam
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|uid
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"bad uid `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|curinode
operator|->
name|di_uid
operator|=
name|uid
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|()
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chgroup
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
init|=
literal|1
decl_stmt|;
name|unsigned
name|long
name|gid
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|gid
operator|=
name|strtoul
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"bad gid `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|curinode
operator|->
name|di_gid
operator|=
name|gid
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|()
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_function
name|int
name|dotime
parameter_list|(
name|name
parameter_list|,
name|rts
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|timespec
modifier|*
name|rts
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|val
decl_stmt|;
name|struct
name|tm
name|t
decl_stmt|;
name|int32_t
name|sec
decl_stmt|;
name|int32_t
name|nsec
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|nsec
operator|=
name|strtoul
argument_list|(
operator|++
name|p
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|p
operator|||
operator|*
name|val
operator|!=
literal|'\0'
operator|||
name|nsec
operator|>=
literal|1000000000
operator|||
name|nsec
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid nanoseconds"
argument_list|)
expr_stmt|;
goto|goto
name|badformat
goto|;
block|}
block|}
else|else
name|nsec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|!=
literal|14
condition|)
block|{
name|badformat
label|:
name|warnx
argument_list|(
literal|"date format: YYYYMMDDHHMMSS[.nsec]"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
condition|)
goto|goto
name|badformat
goto|;
name|p
operator|=
name|name
expr_stmt|;
define|#
directive|define
name|VAL
parameter_list|()
value|((*p++) - '0')
name|t
operator|.
name|tm_year
operator|=
name|VAL
argument_list|()
expr_stmt|;
name|t
operator|.
name|tm_year
operator|=
name|VAL
argument_list|()
operator|+
name|t
operator|.
name|tm_year
operator|*
literal|10
expr_stmt|;
name|t
operator|.
name|tm_year
operator|=
name|VAL
argument_list|()
operator|+
name|t
operator|.
name|tm_year
operator|*
literal|10
expr_stmt|;
name|t
operator|.
name|tm_year
operator|=
name|VAL
argument_list|()
operator|+
name|t
operator|.
name|tm_year
operator|*
literal|10
operator|-
literal|1900
expr_stmt|;
name|t
operator|.
name|tm_mon
operator|=
name|VAL
argument_list|()
expr_stmt|;
name|t
operator|.
name|tm_mon
operator|=
name|VAL
argument_list|()
operator|+
name|t
operator|.
name|tm_mon
operator|*
literal|10
operator|-
literal|1
expr_stmt|;
name|t
operator|.
name|tm_mday
operator|=
name|VAL
argument_list|()
expr_stmt|;
name|t
operator|.
name|tm_mday
operator|=
name|VAL
argument_list|()
operator|+
name|t
operator|.
name|tm_mday
operator|*
literal|10
expr_stmt|;
name|t
operator|.
name|tm_hour
operator|=
name|VAL
argument_list|()
expr_stmt|;
name|t
operator|.
name|tm_hour
operator|=
name|VAL
argument_list|()
operator|+
name|t
operator|.
name|tm_hour
operator|*
literal|10
expr_stmt|;
name|t
operator|.
name|tm_min
operator|=
name|VAL
argument_list|()
expr_stmt|;
name|t
operator|.
name|tm_min
operator|=
name|VAL
argument_list|()
operator|+
name|t
operator|.
name|tm_min
operator|*
literal|10
expr_stmt|;
name|t
operator|.
name|tm_sec
operator|=
name|VAL
argument_list|()
expr_stmt|;
name|t
operator|.
name|tm_sec
operator|=
name|VAL
argument_list|()
operator|+
name|t
operator|.
name|tm_sec
operator|*
literal|10
expr_stmt|;
name|t
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
name|sec
operator|=
name|mktime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"date/time out of range"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|rts
operator|->
name|tv_sec
operator|=
name|sec
expr_stmt|;
name|rts
operator|->
name|tv_nsec
operator|=
name|nsec
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chmtime
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|dotime
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|curinode
operator|->
name|di_ctime
argument_list|)
condition|)
return|return
literal|1
return|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chatime
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|dotime
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|curinode
operator|->
name|di_ctime
argument_list|)
condition|)
return|return
literal|1
return|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chctime
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|dotime
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|curinode
operator|->
name|di_ctime
argument_list|)
condition|)
return|return
literal|1
return|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

end_unit

