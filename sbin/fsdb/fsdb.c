begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: fsdb.c,v 1.2 1995/10/08 23:18:10 thorpej Exp $	*/
end_comment

begin_comment
comment|/*  *  Copyright (c) 1995 John T. Kohl  *  All rights reserved.  *   *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  3. The name of the author may not be used to endorse or promote products  *     derived from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<histedit.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<timeconv.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dir.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|"fsdb.h"
end_include

begin_include
include|#
directive|include
file|"fsck.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|usage
argument_list|(
name|void
argument_list|)
name|__dead2
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|cmdloop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_blk32
parameter_list|(
name|uint32_t
modifier|*
name|wantedblk
parameter_list|,
name|uint32_t
name|curblk
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_blk64
parameter_list|(
name|uint64_t
modifier|*
name|wantedblk
parameter_list|,
name|uint64_t
name|curblk
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|founddatablk
parameter_list|(
name|uint64_t
name|blk
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_blks32
parameter_list|(
name|uint32_t
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|uint32_t
modifier|*
name|blknum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_blks64
parameter_list|(
name|uint64_t
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|uint64_t
modifier|*
name|blknum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_indirblks32
parameter_list|(
name|uint32_t
name|blk
parameter_list|,
name|int
name|ind_level
parameter_list|,
name|uint32_t
modifier|*
name|blknum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_indirblks64
parameter_list|(
name|uint64_t
name|blk
parameter_list|,
name|int
name|ind_level
parameter_list|,
name|uint64_t
modifier|*
name|blknum
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: fsdb [-d] [-f] [-r] fsname\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|returntosingle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We suck in lots of fsck code, and just pick& choose the stuff we want.  *  * fsreadfd is set up to read from the file system, fswritefd to write to  * the file system.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|ch
decl_stmt|,
name|rval
decl_stmt|;
name|char
modifier|*
name|fsys
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|-
literal|1
operator|!=
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"fdr"
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* The -f option is left for historical 			 * reasons and has no meaning. 			 */
break|break;
case|case
literal|'d'
case|:
name|debug
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|nflag
operator|++
expr_stmt|;
comment|/* "no" in fsck, readonly for us */
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
else|else
name|fsys
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|sblock_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|setup
argument_list|(
name|fsys
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"cannot set up file system `%s'"
argument_list|,
name|fsys
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s file system `%s'\nLast Mounted on %s\n"
argument_list|,
name|nflag
condition|?
literal|"Examining"
else|:
literal|"Editing"
argument_list|,
name|fsys
argument_list|,
name|sblock
operator|.
name|fs_fsmnt
argument_list|)
expr_stmt|;
name|rval
operator|=
name|cmdloop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|nflag
condition|)
block|{
name|sblock
operator|.
name|fs_clean
operator|=
literal|0
expr_stmt|;
comment|/* mark it dirty */
name|sbdirty
argument_list|()
expr_stmt|;
name|ckfini
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*** FILE SYSTEM MARKED DIRTY\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*** BE SURE TO RUN FSCK TO CLEAN UP ANY DAMAGE\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*** IF IT WAS MOUNTED, RE-MOUNT WITH -u -o reload\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|CMDFUNC
parameter_list|(
name|func
parameter_list|)
value|int func(int argc, char *argv[])
end_define

begin_define
define|#
directive|define
name|CMDFUNCSTART
parameter_list|(
name|func
parameter_list|)
value|int func(int argc, char *argv[])
end_define

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|helpfn
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|focus
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* focus on inode */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|active
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* print active inode */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* print blocks for active inode */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|focusname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* focus by name */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|zapi
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* clear inode */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|uplink
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* incr link */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|downlink
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* decr link */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|linkcount
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* set link count */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|quit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* quit */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|findblk
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* find block */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|ls
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* list directory */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|rm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* remove name */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|ln
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* add name */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|newtype
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* change type */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chmode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* change mode */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chlen
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* change length */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chaflags
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* change flags */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chgen
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* change generation */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chowner
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* change owner */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chgroup
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Change group */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|back
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* pop back to last ino */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chmtime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Change mtime */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chctime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Change ctime */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chatime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Change atime */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chinum
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Change inode # of dirent */
end_comment

begin_expr_stmt
name|CMDFUNC
argument_list|(
name|chname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Change dirname of dirent */
end_comment

begin_decl_stmt
name|struct
name|cmdtable
name|cmds
index|[]
init|=
block|{
block|{
literal|"help"
block|,
literal|"Print out help"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|helpfn
block|}
block|,
block|{
literal|"?"
block|,
literal|"Print out help"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|helpfn
block|}
block|,
block|{
literal|"inode"
block|,
literal|"Set active inode to INUM"
block|,
literal|2
block|,
literal|2
block|,
name|FL_RO
block|,
name|focus
block|}
block|,
block|{
literal|"clri"
block|,
literal|"Clear inode INUM"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|zapi
block|}
block|,
block|{
literal|"lookup"
block|,
literal|"Set active inode by looking up NAME"
block|,
literal|2
block|,
literal|2
block|,
name|FL_RO
operator||
name|FL_ST
block|,
name|focusname
block|}
block|,
block|{
literal|"cd"
block|,
literal|"Set active inode by looking up NAME"
block|,
literal|2
block|,
literal|2
block|,
name|FL_RO
operator||
name|FL_ST
block|,
name|focusname
block|}
block|,
block|{
literal|"back"
block|,
literal|"Go to previous active inode"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|back
block|}
block|,
block|{
literal|"active"
block|,
literal|"Print active inode"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|active
block|}
block|,
block|{
literal|"print"
block|,
literal|"Print active inode"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|active
block|}
block|,
block|{
literal|"blocks"
block|,
literal|"Print block numbers of active inode"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|blocks
block|}
block|,
block|{
literal|"uplink"
block|,
literal|"Increment link count"
block|,
literal|1
block|,
literal|1
block|,
name|FL_WR
block|,
name|uplink
block|}
block|,
block|{
literal|"downlink"
block|,
literal|"Decrement link count"
block|,
literal|1
block|,
literal|1
block|,
name|FL_WR
block|,
name|downlink
block|}
block|,
block|{
literal|"linkcount"
block|,
literal|"Set link count to COUNT"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|linkcount
block|}
block|,
block|{
literal|"findblk"
block|,
literal|"Find inode owning disk block(s)"
block|,
literal|2
block|,
literal|33
block|,
name|FL_RO
block|,
name|findblk
block|}
block|,
block|{
literal|"ls"
block|,
literal|"List current inode as directory"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|ls
block|}
block|,
block|{
literal|"rm"
block|,
literal|"Remove NAME from current inode directory"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
operator||
name|FL_ST
block|,
name|rm
block|}
block|,
block|{
literal|"del"
block|,
literal|"Remove NAME from current inode directory"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
operator||
name|FL_ST
block|,
name|rm
block|}
block|,
block|{
literal|"ln"
block|,
literal|"Hardlink INO into current inode directory as NAME"
block|,
literal|3
block|,
literal|3
block|,
name|FL_WR
operator||
name|FL_ST
block|,
name|ln
block|}
block|,
block|{
literal|"chinum"
block|,
literal|"Change dir entry number INDEX to INUM"
block|,
literal|3
block|,
literal|3
block|,
name|FL_WR
block|,
name|chinum
block|}
block|,
block|{
literal|"chname"
block|,
literal|"Change dir entry number INDEX to NAME"
block|,
literal|3
block|,
literal|3
block|,
name|FL_WR
operator||
name|FL_ST
block|,
name|chname
block|}
block|,
block|{
literal|"chtype"
block|,
literal|"Change type of current inode to TYPE"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|newtype
block|}
block|,
block|{
literal|"chmod"
block|,
literal|"Change mode of current inode to MODE"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chmode
block|}
block|,
block|{
literal|"chlen"
block|,
literal|"Change length of current inode to LENGTH"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chlen
block|}
block|,
block|{
literal|"chown"
block|,
literal|"Change owner of current inode to OWNER"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chowner
block|}
block|,
block|{
literal|"chgrp"
block|,
literal|"Change group of current inode to GROUP"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chgroup
block|}
block|,
block|{
literal|"chflags"
block|,
literal|"Change flags of current inode to FLAGS"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chaflags
block|}
block|,
block|{
literal|"chgen"
block|,
literal|"Change generation number of current inode to GEN"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chgen
block|}
block|,
block|{
literal|"mtime"
block|,
literal|"Change mtime of current inode to MTIME"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chmtime
block|}
block|,
block|{
literal|"ctime"
block|,
literal|"Change ctime of current inode to CTIME"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chctime
block|}
block|,
block|{
literal|"atime"
block|,
literal|"Change atime of current inode to ATIME"
block|,
literal|2
block|,
literal|2
block|,
name|FL_WR
block|,
name|chatime
block|}
block|,
block|{
literal|"quit"
block|,
literal|"Exit"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|quit
block|}
block|,
block|{
literal|"q"
block|,
literal|"Exit"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|quit
block|}
block|,
block|{
literal|"exit"
block|,
literal|"Exit"
block|,
literal|1
block|,
literal|1
block|,
name|FL_RO
block|,
name|quit
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|helpfn
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|cmdtable
modifier|*
name|cmdtp
decl_stmt|;
name|printf
argument_list|(
literal|"Commands are:\n%-10s %5s %5s   %s\n"
argument_list|,
literal|"command"
argument_list|,
literal|"min args"
argument_list|,
literal|"max args"
argument_list|,
literal|"what"
argument_list|)
expr_stmt|;
for|for
control|(
name|cmdtp
operator|=
name|cmds
init|;
name|cmdtp
operator|->
name|cmd
condition|;
name|cmdtp
operator|++
control|)
name|printf
argument_list|(
literal|"%-10s %5u %5u   %s\n"
argument_list|,
name|cmdtp
operator|->
name|cmd
argument_list|,
name|cmdtp
operator|->
name|minargc
operator|-
literal|1
argument_list|,
name|cmdtp
operator|->
name|maxargc
operator|-
literal|1
argument_list|,
name|cmdtp
operator|->
name|helptxt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|prompt
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
specifier|static
name|char
name|pstring
index|[
literal|64
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|pstring
argument_list|,
sizeof|sizeof
argument_list|(
name|pstring
argument_list|)
argument_list|,
literal|"fsdb (inum: %d)> "
argument_list|,
name|curinum
argument_list|)
expr_stmt|;
return|return
name|pstring
return|;
block|}
end_function

begin_function
name|int
name|cmdloop
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|elline
decl_stmt|;
name|int
name|cmd_argc
decl_stmt|,
name|rval
init|=
literal|0
decl_stmt|,
name|known
decl_stmt|;
define|#
directive|define
name|scratch
value|known
name|char
modifier|*
modifier|*
name|cmd_argv
decl_stmt|;
name|struct
name|cmdtable
modifier|*
name|cmdp
decl_stmt|;
name|History
modifier|*
name|hist
decl_stmt|;
name|EditLine
modifier|*
name|elptr
decl_stmt|;
name|HistEvent
name|he
decl_stmt|;
name|curinode
operator|=
name|ginode
argument_list|(
name|ROOTINO
argument_list|)
expr_stmt|;
name|curinum
operator|=
name|ROOTINO
expr_stmt|;
name|printactive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hist
operator|=
name|history_init
argument_list|()
expr_stmt|;
name|history
argument_list|(
name|hist
argument_list|,
operator|&
name|he
argument_list|,
name|H_SETSIZE
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|/* 100 elt history buffer */
name|elptr
operator|=
name|el_init
argument_list|(
literal|"fsdb"
argument_list|,
name|stdin
argument_list|,
name|stdout
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|elptr
argument_list|,
name|EL_EDITOR
argument_list|,
literal|"emacs"
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|elptr
argument_list|,
name|EL_PROMPT
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|elptr
argument_list|,
name|EL_HIST
argument_list|,
name|history
argument_list|,
name|hist
argument_list|)
expr_stmt|;
name|el_source
argument_list|(
name|elptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|elline
operator|=
name|el_gets
argument_list|(
name|elptr
argument_list|,
operator|&
name|scratch
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|scratch
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"command `%s'\n"
argument_list|,
name|elline
argument_list|)
expr_stmt|;
name|history
argument_list|(
name|hist
argument_list|,
operator|&
name|he
argument_list|,
name|H_ENTER
argument_list|,
name|elline
argument_list|)
expr_stmt|;
name|line
operator|=
name|strdup
argument_list|(
name|elline
argument_list|)
expr_stmt|;
name|cmd_argv
operator|=
name|crack
argument_list|(
name|line
argument_list|,
operator|&
name|cmd_argc
argument_list|)
expr_stmt|;
comment|/* 	 * el_parse returns -1 to signal that it's not been handled 	 * internally. 	 */
if|if
condition|(
name|el_parse
argument_list|(
name|elptr
argument_list|,
name|cmd_argc
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|cmd_argv
argument_list|)
operator|!=
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|cmd_argc
condition|)
block|{
name|known
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cmdp
operator|=
name|cmds
init|;
name|cmdp
operator|->
name|cmd
condition|;
name|cmdp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmdp
operator|->
name|cmd
argument_list|,
name|cmd_argv
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|cmdp
operator|->
name|flags
operator|&
name|FL_WR
operator|)
operator|==
name|FL_WR
operator|&&
name|nflag
condition|)
name|warnx
argument_list|(
literal|"`%s' requires write access"
argument_list|,
name|cmd_argv
index|[
literal|0
index|]
argument_list|)
operator|,
name|rval
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd_argc
operator|>=
name|cmdp
operator|->
name|minargc
operator|&&
name|cmd_argc
operator|<=
name|cmdp
operator|->
name|maxargc
condition|)
name|rval
operator|=
call|(
modifier|*
name|cmdp
operator|->
name|handler
call|)
argument_list|(
name|cmd_argc
argument_list|,
name|cmd_argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd_argc
operator|>=
name|cmdp
operator|->
name|minargc
operator|&&
operator|(
name|cmdp
operator|->
name|flags
operator|&
name|FL_ST
operator|)
operator|==
name|FL_ST
condition|)
block|{
name|strcpy
argument_list|(
name|line
argument_list|,
name|elline
argument_list|)
expr_stmt|;
name|cmd_argv
operator|=
name|recrack
argument_list|(
name|line
argument_list|,
operator|&
name|cmd_argc
argument_list|,
name|cmdp
operator|->
name|maxargc
argument_list|)
expr_stmt|;
name|rval
operator|=
call|(
modifier|*
name|cmdp
operator|->
name|handler
call|)
argument_list|(
name|cmd_argc
argument_list|,
name|cmd_argv
argument_list|)
expr_stmt|;
block|}
else|else
name|rval
operator|=
name|argcount
argument_list|(
name|cmdp
argument_list|,
name|cmd_argc
argument_list|,
name|cmd_argv
argument_list|)
expr_stmt|;
name|known
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|known
condition|)
name|warnx
argument_list|(
literal|"unknown command `%s'"
argument_list|,
name|cmd_argv
index|[
literal|0
index|]
argument_list|)
operator|,
name|rval
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|rval
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|<
literal|0
condition|)
comment|/* user typed "quit" */
return|return
literal|0
return|;
if|if
condition|(
name|rval
condition|)
name|warnx
argument_list|(
literal|"rval was %d"
argument_list|,
name|rval
argument_list|)
expr_stmt|;
block|}
name|el_end
argument_list|(
name|elptr
argument_list|)
expr_stmt|;
name|history_end
argument_list|(
name|hist
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_decl_stmt
name|union
name|dinode
modifier|*
name|curinode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|curinum
decl_stmt|,
name|ocurrent
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GETINUM
parameter_list|(
name|ac
parameter_list|,
name|inum
parameter_list|)
value|inum = strtoul(argv[ac],&cp, 0); \     if (inum< ROOTINO || inum> maxino || cp == argv[ac] || *cp != '\0' ) { \ 	printf("inode %d out of range; range is [%d,%d]\n", \ 	       inum, ROOTINO, maxino); \ 	return 1; \     }
end_define

begin_comment
comment|/*  * Focus on given inode number  */
end_comment

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|focus
argument_list|)
end_macro

begin_block
block|{
name|ino_t
name|inum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|GETINUM
argument_list|(
literal|1
argument_list|,
name|inum
argument_list|)
expr_stmt|;
name|curinode
operator|=
name|ginode
argument_list|(
name|inum
argument_list|)
expr_stmt|;
name|ocurrent
operator|=
name|curinum
expr_stmt|;
name|curinum
operator|=
name|inum
expr_stmt|;
name|printactive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|back
argument_list|)
end_macro

begin_block
block|{
name|curinum
operator|=
name|ocurrent
expr_stmt|;
name|curinode
operator|=
name|ginode
argument_list|(
name|curinum
argument_list|)
expr_stmt|;
name|printactive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|zapi
argument_list|)
end_macro

begin_block
block|{
name|ino_t
name|inum
decl_stmt|;
name|union
name|dinode
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|GETINUM
argument_list|(
literal|1
argument_list|,
name|inum
argument_list|)
expr_stmt|;
name|dp
operator|=
name|ginode
argument_list|(
name|inum
argument_list|)
expr_stmt|;
name|clearinode
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
if|if
condition|(
name|curinode
condition|)
comment|/* re-set after potential change */
name|curinode
operator|=
name|ginode
argument_list|(
name|curinum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|active
argument_list|)
end_macro

begin_block
block|{
name|printactive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|blocks
argument_list|)
end_macro

begin_block
block|{
name|printactive
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|quit
argument_list|)
end_macro

begin_block
block|{
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|uplink
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|DIP_SET
argument_list|(
name|curinode
argument_list|,
name|di_nlink
argument_list|,
name|DIP
argument_list|(
name|curinode
argument_list|,
name|di_nlink
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"inode %d link count now %d\n"
argument_list|,
name|curinum
argument_list|,
name|DIP
argument_list|(
name|curinode
argument_list|,
name|di_nlink
argument_list|)
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|downlink
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|DIP_SET
argument_list|(
name|curinode
argument_list|,
name|di_nlink
argument_list|,
name|DIP
argument_list|(
name|curinode
argument_list|,
name|di_nlink
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"inode %d link count now %d\n"
argument_list|,
name|curinum
argument_list|,
name|DIP
argument_list|(
name|curinode
argument_list|,
name|di_nlink
argument_list|)
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_decl_stmt
specifier|const
name|char
modifier|*
name|typename
index|[]
init|=
block|{
literal|"unknown"
block|,
literal|"fifo"
block|,
literal|"char special"
block|,
literal|"unregistered #3"
block|,
literal|"directory"
block|,
literal|"unregistered #5"
block|,
literal|"blk special"
block|,
literal|"unregistered #7"
block|,
literal|"regular"
block|,
literal|"unregistered #9"
block|,
literal|"symlink"
block|,
literal|"unregistered #11"
block|,
literal|"socket"
block|,
literal|"unregistered #13"
block|,
literal|"whiteout"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|slot
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|scannames
parameter_list|(
name|struct
name|inodesc
modifier|*
name|idesc
parameter_list|)
block|{
name|struct
name|direct
modifier|*
name|dirp
init|=
name|idesc
operator|->
name|id_dirp
decl_stmt|;
name|printf
argument_list|(
literal|"slot %d ino %d reclen %d: %s, `%.*s'\n"
argument_list|,
name|slot
operator|++
argument_list|,
name|dirp
operator|->
name|d_ino
argument_list|,
name|dirp
operator|->
name|d_reclen
argument_list|,
name|typename
index|[
name|dirp
operator|->
name|d_type
index|]
argument_list|,
name|dirp
operator|->
name|d_namlen
argument_list|,
name|dirp
operator|->
name|d_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_function

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|ls
argument_list|)
end_macro

begin_block
block|{
name|struct
name|inodesc
name|idesc
decl_stmt|;
name|checkactivedir
argument_list|()
expr_stmt|;
comment|/* let it go on anyway */
name|slot
operator|=
literal|0
expr_stmt|;
name|idesc
operator|.
name|id_number
operator|=
name|curinum
expr_stmt|;
name|idesc
operator|.
name|id_func
operator|=
name|scannames
expr_stmt|;
name|idesc
operator|.
name|id_type
operator|=
name|DATA
expr_stmt|;
name|idesc
operator|.
name|id_fix
operator|=
name|IGNORE
expr_stmt|;
name|ckinode
argument_list|(
name|curinode
argument_list|,
operator|&
name|idesc
argument_list|)
expr_stmt|;
name|curinode
operator|=
name|ginode
argument_list|(
name|curinum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|findblk_numtofind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wantedblksize
decl_stmt|;
end_decl_stmt

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|findblk
argument_list|)
end_macro

begin_block
block|{
name|ino_t
name|inum
decl_stmt|,
name|inosused
decl_stmt|;
name|uint32_t
modifier|*
name|wantedblk32
decl_stmt|;
name|uint64_t
modifier|*
name|wantedblk64
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
init|=
operator|&
name|cgrp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|is_ufs2
decl_stmt|;
name|wantedblksize
operator|=
operator|(
name|argc
operator|-
literal|1
operator|)
expr_stmt|;
name|is_ufs2
operator|=
name|sblock
operator|.
name|fs_magic
operator|==
name|FS_UFS2_MAGIC
expr_stmt|;
name|ocurrent
operator|=
name|curinum
expr_stmt|;
if|if
condition|(
name|is_ufs2
condition|)
block|{
name|wantedblk64
operator|=
name|calloc
argument_list|(
name|wantedblksize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wantedblk64
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|wantedblk64
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|dbtofsb
argument_list|(
operator|&
name|sblock
argument_list|,
name|strtoull
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wantedblk32
operator|=
name|calloc
argument_list|(
name|wantedblksize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wantedblk32
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|wantedblk32
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|dbtofsb
argument_list|(
operator|&
name|sblock
argument_list|,
name|strtoull
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|findblk_numtofind
operator|=
name|wantedblksize
expr_stmt|;
comment|/*      * sblock.fs_ncg holds a number of cylinder groups.      * Iterate over all cylinder groups.      */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|c
operator|++
control|)
block|{
comment|/* 	 * sblock.fs_ipg holds a number of inodes per cylinder group. 	 * Calculate a highest inode number for a given cylinder group. 	 */
name|inum
operator|=
name|c
operator|*
name|sblock
operator|.
name|fs_ipg
expr_stmt|;
comment|/* Read cylinder group. */
name|getblk
argument_list|(
operator|&
name|cgblk
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_cgsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cgp
argument_list|,
name|cgblk
operator|.
name|b_un
operator|.
name|b_cg
argument_list|,
name|sblock
operator|.
name|fs_cgsize
argument_list|)
expr_stmt|;
comment|/* 	 * Get a highest used inode number for a given cylinder group. 	 * For UFS1 all inodes initialized at the newfs stage. 	 */
if|if
condition|(
name|is_ufs2
condition|)
name|inosused
operator|=
name|cgp
operator|->
name|cg_initediblk
expr_stmt|;
else|else
name|inosused
operator|=
name|sblock
operator|.
name|fs_ipg
expr_stmt|;
for|for
control|(
init|;
name|inosused
operator|>
literal|0
condition|;
name|inum
operator|++
operator|,
name|inosused
operator|--
control|)
block|{
comment|/* Skip magic inodes: 0, WINO, ROOTINO. */
if|if
condition|(
name|inum
operator|<
name|ROOTINO
condition|)
continue|continue;
comment|/* 	     * Check if the block we are looking for is just an inode block. 	     * 	     * ino_to_fsba() - get block containing inode from its number. 	     * INOPB() - get a number of inodes in one disk block. 	     */
if|if
condition|(
name|is_ufs2
condition|?
name|compare_blk64
argument_list|(
name|wantedblk64
argument_list|,
name|ino_to_fsba
argument_list|(
operator|&
name|sblock
argument_list|,
name|inum
argument_list|)
argument_list|)
else|:
name|compare_blk32
argument_list|(
name|wantedblk32
argument_list|,
name|ino_to_fsba
argument_list|(
operator|&
name|sblock
argument_list|,
name|inum
argument_list|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"block %llu: inode block (%d-%d)\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|ino_to_fsba
argument_list|(
operator|&
name|sblock
argument_list|,
name|inum
argument_list|)
argument_list|)
argument_list|,
operator|(
name|inum
operator|/
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
operator|)
operator|*
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|,
operator|(
name|inum
operator|/
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
operator|+
literal|1
operator|)
operator|*
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|)
expr_stmt|;
name|findblk_numtofind
operator|--
expr_stmt|;
if|if
condition|(
name|findblk_numtofind
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
block|}
comment|/* Get on-disk inode aka dinode. */
name|curinum
operator|=
name|inum
expr_stmt|;
name|curinode
operator|=
name|ginode
argument_list|(
name|inum
argument_list|)
expr_stmt|;
comment|/* Find IFLNK dinode with allocated data blocks. */
switch|switch
condition|(
name|DIP
argument_list|(
name|curinode
argument_list|,
name|di_mode
argument_list|)
operator|&
name|IFMT
condition|)
block|{
case|case
name|IFDIR
case|:
case|case
name|IFREG
case|:
if|if
condition|(
name|DIP
argument_list|(
name|curinode
argument_list|,
name|di_blocks
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
break|break;
case|case
name|IFLNK
case|:
block|{
name|uint64_t
name|size
init|=
name|DIP
argument_list|(
name|curinode
argument_list|,
name|di_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<
name|sblock
operator|.
name|fs_maxsymlinklen
operator|&&
name|DIP
argument_list|(
name|curinode
argument_list|,
name|di_blocks
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
else|else
break|break;
block|}
default|default:
continue|continue;
block|}
comment|/* Look through direct data blocks. */
if|if
condition|(
name|is_ufs2
condition|?
name|find_blks64
argument_list|(
name|curinode
operator|->
name|dp2
operator|.
name|di_db
argument_list|,
name|NDADDR
argument_list|,
name|wantedblk64
argument_list|)
else|:
name|find_blks32
argument_list|(
name|curinode
operator|->
name|dp1
operator|.
name|di_db
argument_list|,
name|NDADDR
argument_list|,
name|wantedblk32
argument_list|)
condition|)
goto|goto
name|end
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIADDR
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Does the block we are looking for belongs to the 		 * indirect blocks? 		 */
if|if
condition|(
name|is_ufs2
condition|?
name|compare_blk64
argument_list|(
name|wantedblk64
argument_list|,
name|curinode
operator|->
name|dp2
operator|.
name|di_ib
index|[
name|i
index|]
argument_list|)
else|:
name|compare_blk32
argument_list|(
name|wantedblk32
argument_list|,
name|curinode
operator|->
name|dp1
operator|.
name|di_ib
index|[
name|i
index|]
argument_list|)
condition|)
if|if
condition|(
name|founddatablk
argument_list|(
name|is_ufs2
condition|?
name|curinode
operator|->
name|dp2
operator|.
name|di_ib
index|[
name|i
index|]
else|:
name|curinode
operator|->
name|dp1
operator|.
name|di_ib
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* 		 * Search through indirect, double and triple indirect 		 * data blocks. 		 */
if|if
condition|(
name|is_ufs2
condition|?
operator|(
name|curinode
operator|->
name|dp2
operator|.
name|di_ib
index|[
name|i
index|]
operator|!=
literal|0
operator|)
else|:
operator|(
name|curinode
operator|->
name|dp1
operator|.
name|di_ib
index|[
name|i
index|]
operator|!=
literal|0
operator|)
condition|)
if|if
condition|(
name|is_ufs2
condition|?
name|find_indirblks64
argument_list|(
name|curinode
operator|->
name|dp2
operator|.
name|di_ib
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|wantedblk64
argument_list|)
else|:
name|find_indirblks32
argument_list|(
name|curinode
operator|->
name|dp1
operator|.
name|di_ib
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|wantedblk32
argument_list|)
condition|)
goto|goto
name|end
goto|;
block|}
block|}
block|}
name|end
label|:
name|curinum
operator|=
name|ocurrent
expr_stmt|;
name|curinode
operator|=
name|ginode
argument_list|(
name|curinum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|compare_blk32
parameter_list|(
name|uint32_t
modifier|*
name|wantedblk
parameter_list|,
name|uint32_t
name|curblk
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wantedblksize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wantedblk
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|wantedblk
index|[
name|i
index|]
operator|==
name|curblk
condition|)
block|{
name|wantedblk
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compare_blk64
parameter_list|(
name|uint64_t
modifier|*
name|wantedblk
parameter_list|,
name|uint64_t
name|curblk
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wantedblksize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wantedblk
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|wantedblk
index|[
name|i
index|]
operator|==
name|curblk
condition|)
block|{
name|wantedblk
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|founddatablk
parameter_list|(
name|uint64_t
name|blk
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%llu: data block of inode %d\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|blk
argument_list|)
argument_list|,
name|curinum
argument_list|)
expr_stmt|;
name|findblk_numtofind
operator|--
expr_stmt|;
if|if
condition|(
name|findblk_numtofind
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_blks32
parameter_list|(
name|uint32_t
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|uint32_t
modifier|*
name|wantedblk
parameter_list|)
block|{
name|int
name|blk
decl_stmt|;
for|for
control|(
name|blk
operator|=
literal|0
init|;
name|blk
operator|<
name|size
condition|;
name|blk
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|blk
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|compare_blk32
argument_list|(
name|wantedblk
argument_list|,
name|buf
index|[
name|blk
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|founddatablk
argument_list|(
name|buf
index|[
name|blk
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_indirblks32
parameter_list|(
name|uint32_t
name|blk
parameter_list|,
name|int
name|ind_level
parameter_list|,
name|uint32_t
modifier|*
name|wantedblk
parameter_list|)
block|{
define|#
directive|define
name|MAXNINDIR
value|(MAXBSIZE / sizeof(uint32_t))
name|uint32_t
name|idblk
index|[
name|MAXNINDIR
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bread
argument_list|(
name|fsreadfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|idblk
argument_list|,
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|blk
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind_level
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|find_blks32
argument_list|(
name|idblk
argument_list|,
name|sblock
operator|.
name|fs_bsize
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|wantedblk
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
name|ind_level
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_bsize
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|compare_blk32
argument_list|(
name|wantedblk
argument_list|,
name|idblk
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|founddatablk
argument_list|(
name|idblk
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|idblk
index|[
name|i
index|]
operator|!=
literal|0
condition|)
if|if
condition|(
name|find_indirblks32
argument_list|(
name|idblk
index|[
name|i
index|]
argument_list|,
name|ind_level
argument_list|,
name|wantedblk
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
undef|#
directive|undef
name|MAXNINDIR
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_blks64
parameter_list|(
name|uint64_t
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|uint64_t
modifier|*
name|wantedblk
parameter_list|)
block|{
name|int
name|blk
decl_stmt|;
for|for
control|(
name|blk
operator|=
literal|0
init|;
name|blk
operator|<
name|size
condition|;
name|blk
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|blk
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|compare_blk64
argument_list|(
name|wantedblk
argument_list|,
name|buf
index|[
name|blk
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|founddatablk
argument_list|(
name|buf
index|[
name|blk
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_indirblks64
parameter_list|(
name|uint64_t
name|blk
parameter_list|,
name|int
name|ind_level
parameter_list|,
name|uint64_t
modifier|*
name|wantedblk
parameter_list|)
block|{
define|#
directive|define
name|MAXNINDIR
value|(MAXBSIZE / sizeof(uint64_t))
name|uint64_t
name|idblk
index|[
name|MAXNINDIR
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bread
argument_list|(
name|fsreadfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|idblk
argument_list|,
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|blk
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind_level
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|find_blks64
argument_list|(
name|idblk
argument_list|,
name|sblock
operator|.
name|fs_bsize
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|wantedblk
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
name|ind_level
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_bsize
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|compare_blk64
argument_list|(
name|wantedblk
argument_list|,
name|idblk
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|founddatablk
argument_list|(
name|idblk
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|idblk
index|[
name|i
index|]
operator|!=
literal|0
condition|)
if|if
condition|(
name|find_indirblks64
argument_list|(
name|idblk
index|[
name|i
index|]
argument_list|,
name|ind_level
argument_list|,
name|wantedblk
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
undef|#
directive|undef
name|MAXNINDIR
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
name|int
name|findino
parameter_list|(
name|struct
name|inodesc
modifier|*
name|idesc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* from fsck */
end_comment

begin_function_decl
specifier|static
name|int
name|dolookup
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|dolookup
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|inodesc
name|idesc
decl_stmt|;
if|if
condition|(
operator|!
name|checkactivedir
argument_list|()
condition|)
return|return
literal|0
return|;
name|idesc
operator|.
name|id_number
operator|=
name|curinum
expr_stmt|;
name|idesc
operator|.
name|id_func
operator|=
name|findino
expr_stmt|;
name|idesc
operator|.
name|id_name
operator|=
name|name
expr_stmt|;
name|idesc
operator|.
name|id_type
operator|=
name|DATA
expr_stmt|;
name|idesc
operator|.
name|id_fix
operator|=
name|IGNORE
expr_stmt|;
if|if
condition|(
name|ckinode
argument_list|(
name|curinode
argument_list|,
operator|&
name|idesc
argument_list|)
operator|&
name|FOUND
condition|)
block|{
name|curinum
operator|=
name|idesc
operator|.
name|id_parent
expr_stmt|;
name|curinode
operator|=
name|ginode
argument_list|(
name|curinum
argument_list|)
expr_stmt|;
name|printactive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"name `%s' not found in current inode directory"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|focusname
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|ocurrent
operator|=
name|curinum
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|curinum
operator|=
name|ROOTINO
expr_stmt|;
name|curinode
operator|=
name|ginode
argument_list|(
name|ROOTINO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|checkactivedir
argument_list|()
condition|)
return|return
literal|1
return|;
block|}
for|for
control|(
name|p
operator|=
name|argv
index|[
literal|1
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|val
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|"/"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|val
operator|==
literal|'\0'
condition|)
empty_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|printf
argument_list|(
literal|"component `%s': "
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dolookup
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|curinode
operator|=
name|ginode
argument_list|(
name|curinum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|ln
argument_list|)
end_macro

begin_block
block|{
name|ino_t
name|inum
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|GETINUM
argument_list|(
literal|1
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkactivedir
argument_list|()
condition|)
return|return
literal|1
return|;
name|rval
operator|=
name|makeentry
argument_list|(
name|curinum
argument_list|,
name|inum
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
name|printf
argument_list|(
literal|"Ino %d entered as `%s'\n"
argument_list|,
name|inum
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"could not enter name? weird.\n"
argument_list|)
expr_stmt|;
name|curinode
operator|=
name|ginode
argument_list|(
name|curinum
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|rm
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
decl_stmt|;
if|if
condition|(
operator|!
name|checkactivedir
argument_list|()
condition|)
return|return
literal|1
return|;
name|rval
operator|=
name|changeino
argument_list|(
name|curinum
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|&
name|ALTERED
condition|)
block|{
name|printf
argument_list|(
literal|"Name `%s' removed\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"could not remove name ('%s')? weird.\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_block

begin_decl_stmt
name|long
name|slotcount
decl_stmt|,
name|desired
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|chinumfunc
parameter_list|(
name|struct
name|inodesc
modifier|*
name|idesc
parameter_list|)
block|{
name|struct
name|direct
modifier|*
name|dirp
init|=
name|idesc
operator|->
name|id_dirp
decl_stmt|;
if|if
condition|(
name|slotcount
operator|++
operator|==
name|desired
condition|)
block|{
name|dirp
operator|->
name|d_ino
operator|=
name|idesc
operator|->
name|id_parent
expr_stmt|;
return|return
name|STOP
operator||
name|ALTERED
operator||
name|FOUND
return|;
block|}
return|return
name|KEEPON
return|;
block|}
end_function

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chinum
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
name|struct
name|inodesc
name|idesc
decl_stmt|;
name|slotcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|checkactivedir
argument_list|()
condition|)
return|return
literal|1
return|;
name|GETINUM
argument_list|(
literal|2
argument_list|,
name|inum
argument_list|)
expr_stmt|;
name|desired
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
operator|||
name|desired
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"invalid slot number `%s'\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|idesc
operator|.
name|id_number
operator|=
name|curinum
expr_stmt|;
name|idesc
operator|.
name|id_func
operator|=
name|chinumfunc
expr_stmt|;
name|idesc
operator|.
name|id_fix
operator|=
name|IGNORE
expr_stmt|;
name|idesc
operator|.
name|id_type
operator|=
name|DATA
expr_stmt|;
name|idesc
operator|.
name|id_parent
operator|=
name|inum
expr_stmt|;
comment|/* XXX convenient hiding place */
if|if
condition|(
name|ckinode
argument_list|(
name|curinode
argument_list|,
operator|&
name|idesc
argument_list|)
operator|&
name|FOUND
condition|)
return|return
literal|0
return|;
else|else
block|{
name|warnx
argument_list|(
literal|"no %sth slot in current directory"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_block

begin_function
name|int
name|chnamefunc
parameter_list|(
name|struct
name|inodesc
modifier|*
name|idesc
parameter_list|)
block|{
name|struct
name|direct
modifier|*
name|dirp
init|=
name|idesc
operator|->
name|id_dirp
decl_stmt|;
name|struct
name|direct
name|testdir
decl_stmt|;
if|if
condition|(
name|slotcount
operator|++
operator|==
name|desired
condition|)
block|{
comment|/* will name fit? */
name|testdir
operator|.
name|d_namlen
operator|=
name|strlen
argument_list|(
name|idesc
operator|->
name|id_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|DIRSIZ
argument_list|(
name|NEWDIRFMT
argument_list|,
operator|&
name|testdir
argument_list|)
operator|<=
name|dirp
operator|->
name|d_reclen
condition|)
block|{
name|dirp
operator|->
name|d_namlen
operator|=
name|testdir
operator|.
name|d_namlen
expr_stmt|;
name|strcpy
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|,
name|idesc
operator|->
name|id_name
argument_list|)
expr_stmt|;
return|return
name|STOP
operator||
name|ALTERED
operator||
name|FOUND
return|;
block|}
else|else
return|return
name|STOP
operator||
name|FOUND
return|;
comment|/* won't fit, so give up */
block|}
return|return
name|KEEPON
return|;
block|}
end_function

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chname
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|inodesc
name|idesc
decl_stmt|;
name|slotcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|checkactivedir
argument_list|()
condition|)
return|return
literal|1
return|;
name|desired
operator|=
name|strtoul
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"invalid slot number `%s'\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|idesc
operator|.
name|id_number
operator|=
name|curinum
expr_stmt|;
name|idesc
operator|.
name|id_func
operator|=
name|chnamefunc
expr_stmt|;
name|idesc
operator|.
name|id_fix
operator|=
name|IGNORE
expr_stmt|;
name|idesc
operator|.
name|id_type
operator|=
name|DATA
expr_stmt|;
name|idesc
operator|.
name|id_name
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|rval
operator|=
name|ckinode
argument_list|(
name|curinode
argument_list|,
operator|&
name|idesc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|&
operator|(
name|FOUND
operator||
name|ALTERED
operator|)
operator|)
operator|==
operator|(
name|FOUND
operator||
name|ALTERED
operator|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|rval
operator|&
name|FOUND
condition|)
block|{
name|warnx
argument_list|(
literal|"new name `%s' does not fit in slot %s\n"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"no %sth slot in current directory"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_block

begin_struct
struct|struct
name|typemap
block|{
specifier|const
name|char
modifier|*
name|typename
decl_stmt|;
name|int
name|typebits
decl_stmt|;
block|}
name|typenamemap
index|[]
init|=
block|{
block|{
literal|"file"
block|,
name|IFREG
block|}
block|,
block|{
literal|"dir"
block|,
name|IFDIR
block|}
block|,
block|{
literal|"socket"
block|,
name|IFSOCK
block|}
block|,
block|{
literal|"fifo"
block|,
name|IFIFO
block|}
block|, }
struct|;
end_struct

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|newtype
argument_list|)
end_macro

begin_block
block|{
name|int
name|type
decl_stmt|;
name|struct
name|typemap
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|type
operator|=
name|DIP
argument_list|(
name|curinode
argument_list|,
name|di_mode
argument_list|)
operator|&
name|IFMT
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|typenamemap
init|;
name|tp
operator|<
operator|&
name|typenamemap
index|[
sizeof|sizeof
argument_list|(
name|typenamemap
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|typenamemap
argument_list|)
index|]
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|tp
operator|->
name|typename
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"setting type to %s\n"
argument_list|,
name|tp
operator|->
name|typename
argument_list|)
expr_stmt|;
name|type
operator|=
name|tp
operator|->
name|typebits
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tp
operator|==
operator|&
name|typenamemap
index|[
sizeof|sizeof
argument_list|(
name|typenamemap
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|typenamemap
argument_list|)
index|]
condition|)
block|{
name|warnx
argument_list|(
literal|"type `%s' not known"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"try one of `file', `dir', `socket', `fifo'"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|DIP_SET
argument_list|(
name|curinode
argument_list|,
name|di_mode
argument_list|,
name|DIP
argument_list|(
name|curinode
argument_list|,
name|di_mode
argument_list|)
operator|&
operator|~
name|IFMT
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|curinode
argument_list|,
name|di_mode
argument_list|,
name|DIP
argument_list|(
name|curinode
argument_list|,
name|di_mode
argument_list|)
operator||
name|type
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chlen
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
init|=
literal|1
decl_stmt|;
name|long
name|len
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|len
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
operator|||
name|len
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"bad length `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|DIP_SET
argument_list|(
name|curinode
argument_list|,
name|di_size
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chmode
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
init|=
literal|1
decl_stmt|;
name|long
name|modebits
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|modebits
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
operator|||
operator|(
name|modebits
operator|&
operator|~
literal|07777
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"bad modebits `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|DIP_SET
argument_list|(
name|curinode
argument_list|,
name|di_mode
argument_list|,
name|DIP
argument_list|(
name|curinode
argument_list|,
name|di_mode
argument_list|)
operator|&
operator|~
literal|07777
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|curinode
argument_list|,
name|di_mode
argument_list|,
name|DIP
argument_list|(
name|curinode
argument_list|,
name|di_mode
argument_list|)
operator||
name|modebits
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chaflags
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
init|=
literal|1
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|flags
operator|=
name|strtoul
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"bad flags `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|flags
operator|>
name|UINT_MAX
condition|)
block|{
name|warnx
argument_list|(
literal|"flags set beyond 32-bit range of field (%lx)\n"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|DIP_SET
argument_list|(
name|curinode
argument_list|,
name|di_flags
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chgen
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
init|=
literal|1
decl_stmt|;
name|long
name|gen
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|gen
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"bad gen `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gen
operator|>
name|INT_MAX
operator|||
name|gen
operator|<
name|INT_MIN
condition|)
block|{
name|warnx
argument_list|(
literal|"gen set beyond 32-bit range of field (%lx)\n"
argument_list|,
name|gen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|DIP_SET
argument_list|(
name|curinode
argument_list|,
name|di_gen
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|linkcount
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
init|=
literal|1
decl_stmt|;
name|int
name|lcnt
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|lcnt
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"bad link count `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|lcnt
operator|>
name|USHRT_MAX
operator|||
name|lcnt
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"max link count is %d\n"
argument_list|,
name|USHRT_MAX
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|DIP_SET
argument_list|(
name|curinode
argument_list|,
name|di_nlink
argument_list|,
name|lcnt
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chowner
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
init|=
literal|1
decl_stmt|;
name|unsigned
name|long
name|uid
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|uid
operator|=
name|strtoul
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
comment|/* try looking up name */
if|if
condition|(
operator|(
name|pwd
operator|=
name|getpwnam
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|uid
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"bad uid `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|DIP_SET
argument_list|(
name|curinode
argument_list|,
name|di_uid
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chgroup
argument_list|)
end_macro

begin_block
block|{
name|int
name|rval
init|=
literal|1
decl_stmt|;
name|unsigned
name|long
name|gid
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
if|if
condition|(
operator|!
name|checkactive
argument_list|()
condition|)
return|return
literal|1
return|;
name|gid
operator|=
name|strtoul
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|argv
index|[
literal|1
index|]
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"bad gid `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|DIP_SET
argument_list|(
name|curinode
argument_list|,
name|di_gid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_block

begin_function
name|int
name|dotime
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|time_t
modifier|*
name|secp
parameter_list|,
name|int32_t
modifier|*
name|nsecp
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|val
decl_stmt|;
name|struct
name|tm
name|t
decl_stmt|;
name|int32_t
name|nsec
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|nsec
operator|=
name|strtoul
argument_list|(
operator|++
name|p
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|p
operator|||
operator|*
name|val
operator|!=
literal|'\0'
operator|||
name|nsec
operator|>=
literal|1000000000
operator|||
name|nsec
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid nanoseconds"
argument_list|)
expr_stmt|;
goto|goto
name|badformat
goto|;
block|}
block|}
else|else
name|nsec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|!=
literal|14
condition|)
block|{
name|badformat
label|:
name|warnx
argument_list|(
literal|"date format: YYYYMMDDHHMMSS[.nsec]"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|nsecp
operator|=
name|nsec
expr_stmt|;
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
condition|)
goto|goto
name|badformat
goto|;
name|p
operator|=
name|name
expr_stmt|;
define|#
directive|define
name|VAL
parameter_list|()
value|((*p++) - '0')
name|t
operator|.
name|tm_year
operator|=
name|VAL
argument_list|()
expr_stmt|;
name|t
operator|.
name|tm_year
operator|=
name|VAL
argument_list|()
operator|+
name|t
operator|.
name|tm_year
operator|*
literal|10
expr_stmt|;
name|t
operator|.
name|tm_year
operator|=
name|VAL
argument_list|()
operator|+
name|t
operator|.
name|tm_year
operator|*
literal|10
expr_stmt|;
name|t
operator|.
name|tm_year
operator|=
name|VAL
argument_list|()
operator|+
name|t
operator|.
name|tm_year
operator|*
literal|10
operator|-
literal|1900
expr_stmt|;
name|t
operator|.
name|tm_mon
operator|=
name|VAL
argument_list|()
expr_stmt|;
name|t
operator|.
name|tm_mon
operator|=
name|VAL
argument_list|()
operator|+
name|t
operator|.
name|tm_mon
operator|*
literal|10
operator|-
literal|1
expr_stmt|;
name|t
operator|.
name|tm_mday
operator|=
name|VAL
argument_list|()
expr_stmt|;
name|t
operator|.
name|tm_mday
operator|=
name|VAL
argument_list|()
operator|+
name|t
operator|.
name|tm_mday
operator|*
literal|10
expr_stmt|;
name|t
operator|.
name|tm_hour
operator|=
name|VAL
argument_list|()
expr_stmt|;
name|t
operator|.
name|tm_hour
operator|=
name|VAL
argument_list|()
operator|+
name|t
operator|.
name|tm_hour
operator|*
literal|10
expr_stmt|;
name|t
operator|.
name|tm_min
operator|=
name|VAL
argument_list|()
expr_stmt|;
name|t
operator|.
name|tm_min
operator|=
name|VAL
argument_list|()
operator|+
name|t
operator|.
name|tm_min
operator|*
literal|10
expr_stmt|;
name|t
operator|.
name|tm_sec
operator|=
name|VAL
argument_list|()
expr_stmt|;
name|t
operator|.
name|tm_sec
operator|=
name|VAL
argument_list|()
operator|+
name|t
operator|.
name|tm_sec
operator|*
literal|10
expr_stmt|;
name|t
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|secp
operator|=
name|mktime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|secp
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"date/time out of range"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chmtime
argument_list|)
end_macro

begin_block
block|{
name|time_t
name|secs
decl_stmt|;
name|int32_t
name|nsecs
decl_stmt|;
if|if
condition|(
name|dotime
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|secs
argument_list|,
operator|&
name|nsecs
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|sblock
operator|.
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|curinode
operator|->
name|dp1
operator|.
name|di_mtime
operator|=
name|_time_to_time32
argument_list|(
name|secs
argument_list|)
expr_stmt|;
else|else
name|curinode
operator|->
name|dp2
operator|.
name|di_mtime
operator|=
name|_time_to_time64
argument_list|(
name|secs
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|curinode
argument_list|,
name|di_mtimensec
argument_list|,
name|nsecs
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chatime
argument_list|)
end_macro

begin_block
block|{
name|time_t
name|secs
decl_stmt|;
name|int32_t
name|nsecs
decl_stmt|;
if|if
condition|(
name|dotime
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|secs
argument_list|,
operator|&
name|nsecs
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|sblock
operator|.
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|curinode
operator|->
name|dp1
operator|.
name|di_atime
operator|=
name|_time_to_time32
argument_list|(
name|secs
argument_list|)
expr_stmt|;
else|else
name|curinode
operator|->
name|dp2
operator|.
name|di_atime
operator|=
name|_time_to_time64
argument_list|(
name|secs
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|curinode
argument_list|,
name|di_atimensec
argument_list|,
name|nsecs
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|CMDFUNCSTART
argument_list|(
argument|chctime
argument_list|)
end_macro

begin_block
block|{
name|time_t
name|secs
decl_stmt|;
name|int32_t
name|nsecs
decl_stmt|;
if|if
condition|(
name|dotime
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|secs
argument_list|,
operator|&
name|nsecs
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|sblock
operator|.
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|curinode
operator|->
name|dp1
operator|.
name|di_ctime
operator|=
name|_time_to_time32
argument_list|(
name|secs
argument_list|)
expr_stmt|;
else|else
name|curinode
operator|->
name|dp2
operator|.
name|di_ctime
operator|=
name|_time_to_time64
argument_list|(
name|secs
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|curinode
argument_list|,
name|di_ctimensec
argument_list|,
name|nsecs
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|printactive
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

end_unit

