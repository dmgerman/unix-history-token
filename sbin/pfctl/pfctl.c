begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: pfctl.c,v 1.278 2008/08/31 20:18:17 jmc Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2001 Daniel Hartmeier  * Copyright (c) 2002,2003 Henning Brauer  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *    - Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *    - Redistributions in binary form must reproduce the above  *      copyright notice, this list of conditions and the following  *      disclaimer in the documentation and/or other materials provided  *      with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/pfvar.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<altq/altq.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pfctl_parser.h"
end_include

begin_include
include|#
directive|include
file|"pfctl.h"
end_include

begin_function_decl
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_enable
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_disable
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_clear_stats
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_clear_interface_flags
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_clear_rules
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_clear_nat
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_clear_altq
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_clear_src_nodes
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_clear_states
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pfctl_addrprefix
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|pf_addr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_kill_src_nodes
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_net_kill_states
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_label_kill_states
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_id_kill_states
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pfctl_init_options
parameter_list|(
name|struct
name|pfctl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_load_options
parameter_list|(
name|struct
name|pfctl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_load_limit
parameter_list|(
name|struct
name|pfctl
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_load_timeout
parameter_list|(
name|struct
name|pfctl
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_load_debug
parameter_list|(
name|struct
name|pfctl
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_load_logif
parameter_list|(
name|struct
name|pfctl
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_load_hostid
parameter_list|(
name|struct
name|pfctl
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_get_pool
parameter_list|(
name|int
parameter_list|,
name|struct
name|pf_pool
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pfctl_print_rule_counters
parameter_list|(
name|struct
name|pf_rule
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_show_rules
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|enum
name|pfctl_show
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_show_nat
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_show_src_nodes
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_show_states
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_show_status
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_show_timeouts
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_show_limits
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pfctl_debug
parameter_list|(
name|int
parameter_list|,
name|u_int32_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_test_altqsupport
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_show_anchors
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_ruleset_trans
parameter_list|(
name|struct
name|pfctl
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|pf_anchor
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_load_ruleset
parameter_list|(
name|struct
name|pfctl
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|pf_ruleset
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_load_rule
parameter_list|(
name|struct
name|pfctl
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|pf_rule
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|char
modifier|*
name|pfctl_lookup_option
parameter_list|(
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|pf_anchor_global
name|pf_anchors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pf_anchor
name|pf_main_anchor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|clearopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rulesopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|showopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|debugopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|anchoropt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|optiopt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pf_device
init|=
literal|"/dev/pf"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ifaceopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tableopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|tblcmdopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|src_node_killers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|src_node_kill
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|state_killers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|state_kill
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|loadopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|altqsupport
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dev
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|first_title
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|labels
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INDENT
parameter_list|(
name|d
parameter_list|,
name|o
parameter_list|)
value|do {						\ 				if (o) {				\ 					int i;				\ 					for (i=0; i< d; i++)		\ 						printf("  ");		\ 				}					\ 			} while (0);					\   static const struct {
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|index
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|} pf_limits
index|[]
operator|=
block|{
block|{
literal|"states"
block|,
name|PF_LIMIT_STATES
block|}
block|,
block|{
literal|"src-nodes"
block|,
name|PF_LIMIT_SRC_NODES
block|}
block|,
block|{
literal|"frags"
block|,
name|PF_LIMIT_FRAGS
block|}
block|,
block|{
literal|"table-entries"
block|,
name|PF_LIMIT_TABLE_ENTRIES
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|pf_hint
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pf_hint
name|pf_hint_normal
index|[]
init|=
block|{
block|{
literal|"tcp.first"
block|,
literal|2
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.opening"
block|,
literal|30
block|}
block|,
block|{
literal|"tcp.established"
block|,
literal|24
operator|*
literal|60
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.closing"
block|,
literal|15
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.finwait"
block|,
literal|45
block|}
block|,
block|{
literal|"tcp.closed"
block|,
literal|90
block|}
block|,
block|{
literal|"tcp.tsdiff"
block|,
literal|30
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pf_hint
name|pf_hint_satellite
index|[]
init|=
block|{
block|{
literal|"tcp.first"
block|,
literal|3
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.opening"
block|,
literal|30
operator|+
literal|5
block|}
block|,
block|{
literal|"tcp.established"
block|,
literal|24
operator|*
literal|60
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.closing"
block|,
literal|15
operator|*
literal|60
operator|+
literal|5
block|}
block|,
block|{
literal|"tcp.finwait"
block|,
literal|45
operator|+
literal|5
block|}
block|,
block|{
literal|"tcp.closed"
block|,
literal|90
operator|+
literal|5
block|}
block|,
block|{
literal|"tcp.tsdiff"
block|,
literal|60
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pf_hint
name|pf_hint_conservative
index|[]
init|=
block|{
block|{
literal|"tcp.first"
block|,
literal|60
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.opening"
block|,
literal|15
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.established"
block|,
literal|5
operator|*
literal|24
operator|*
literal|60
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.closing"
block|,
literal|60
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.finwait"
block|,
literal|10
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.closed"
block|,
literal|3
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.tsdiff"
block|,
literal|60
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pf_hint
name|pf_hint_aggressive
index|[]
init|=
block|{
block|{
literal|"tcp.first"
block|,
literal|30
block|}
block|,
block|{
literal|"tcp.opening"
block|,
literal|5
block|}
block|,
block|{
literal|"tcp.established"
block|,
literal|5
operator|*
literal|60
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.closing"
block|,
literal|60
block|}
block|,
block|{
literal|"tcp.finwait"
block|,
literal|30
block|}
block|,
block|{
literal|"tcp.closed"
block|,
literal|30
block|}
block|,
block|{
literal|"tcp.tsdiff"
block|,
literal|10
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|pf_hint
modifier|*
name|hint
decl_stmt|;
block|}
name|pf_hints
index|[]
init|=
block|{
block|{
literal|"normal"
block|,
name|pf_hint_normal
block|}
block|,
block|{
literal|"satellite"
block|,
name|pf_hint_satellite
block|}
block|,
block|{
literal|"high-latency"
block|,
name|pf_hint_satellite
block|}
block|,
block|{
literal|"conservative"
block|,
name|pf_hint_conservative
block|}
block|,
block|{
literal|"aggressive"
block|,
name|pf_hint_aggressive
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|clearopt_list
index|[]
init|=
block|{
literal|"nat"
block|,
literal|"queue"
block|,
literal|"rules"
block|,
literal|"Sources"
block|,
literal|"states"
block|,
literal|"info"
block|,
literal|"Tables"
block|,
literal|"osfp"
block|,
literal|"all"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|showopt_list
index|[]
init|=
block|{
literal|"nat"
block|,
literal|"queue"
block|,
literal|"rules"
block|,
literal|"Anchors"
block|,
literal|"Sources"
block|,
literal|"states"
block|,
literal|"info"
block|,
literal|"Interfaces"
block|,
literal|"labels"
block|,
literal|"timeouts"
block|,
literal|"memory"
block|,
literal|"Tables"
block|,
literal|"osfp"
block|,
literal|"all"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|tblcmdopt_list
index|[]
init|=
block|{
literal|"kill"
block|,
literal|"flush"
block|,
literal|"add"
block|,
literal|"delete"
block|,
literal|"load"
block|,
literal|"replace"
block|,
literal|"show"
block|,
literal|"test"
block|,
literal|"zero"
block|,
literal|"expire"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|debugopt_list
index|[]
init|=
block|{
literal|"none"
block|,
literal|"urgent"
block|,
literal|"misc"
block|,
literal|"loud"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|optiopt_list
index|[]
init|=
block|{
literal|"none"
block|,
literal|"basic"
block|,
literal|"profile"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|__progname
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-AdeghmNnOPqRrvz] [-a anchor] [-D macro=value] [-F modifier]\n"
literal|"\t[-f file] [-i interface] [-K host | network]\n"
literal|"\t[-k host | network | label | id] [-o level] [-p device]\n"
literal|"\t[-s modifier] [-t table -T command [address ...]] [-x level]\n"
argument_list|,
name|__progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pfctl_enable
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCSTART
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"pf already enabled"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|ESRCH
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"pfil registeration failed"
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCSTART"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pf enabled\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|altqsupport
operator|&&
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCSTARTALTQ
argument_list|)
condition|)
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCSTARTALTQ"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_disable
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCSTOP
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"pf not enabled"
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCSTOP"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pf disabled\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|altqsupport
operator|&&
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCSTOPALTQ
argument_list|)
condition|)
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCSTOPALTQ"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_clear_stats
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCLRSTATUS
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCCLRSTATUS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pf: statistics cleared\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_clear_interface_flags
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pfioc_iface
name|pi
decl_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|pi
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|.
name|pfiio_flags
operator|=
name|PFI_IFLAG_SKIP
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCLRIFFLAG
argument_list|,
operator|&
name|pi
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCCLRIFFLAG"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pf: interface flags reset\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_clear_rules
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|,
name|char
modifier|*
name|anchorname
parameter_list|)
block|{
name|struct
name|pfr_buffer
name|t
decl_stmt|;
name|memset
argument_list|(
operator|&
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|pfrb_type
operator|=
name|PFRB_TRANS
expr_stmt|;
if|if
condition|(
name|pfctl_add_trans
argument_list|(
operator|&
name|t
argument_list|,
name|PF_RULESET_SCRUB
argument_list|,
name|anchorname
argument_list|)
operator|||
name|pfctl_add_trans
argument_list|(
operator|&
name|t
argument_list|,
name|PF_RULESET_FILTER
argument_list|,
name|anchorname
argument_list|)
operator|||
name|pfctl_trans
argument_list|(
name|dev
argument_list|,
operator|&
name|t
argument_list|,
name|DIOCXBEGIN
argument_list|,
literal|0
argument_list|)
operator|||
name|pfctl_trans
argument_list|(
name|dev
argument_list|,
operator|&
name|t
argument_list|,
name|DIOCXCOMMIT
argument_list|,
literal|0
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"pfctl_clear_rules"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rules cleared\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_clear_nat
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|,
name|char
modifier|*
name|anchorname
parameter_list|)
block|{
name|struct
name|pfr_buffer
name|t
decl_stmt|;
name|memset
argument_list|(
operator|&
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|pfrb_type
operator|=
name|PFRB_TRANS
expr_stmt|;
if|if
condition|(
name|pfctl_add_trans
argument_list|(
operator|&
name|t
argument_list|,
name|PF_RULESET_NAT
argument_list|,
name|anchorname
argument_list|)
operator|||
name|pfctl_add_trans
argument_list|(
operator|&
name|t
argument_list|,
name|PF_RULESET_BINAT
argument_list|,
name|anchorname
argument_list|)
operator|||
name|pfctl_add_trans
argument_list|(
operator|&
name|t
argument_list|,
name|PF_RULESET_RDR
argument_list|,
name|anchorname
argument_list|)
operator|||
name|pfctl_trans
argument_list|(
name|dev
argument_list|,
operator|&
name|t
argument_list|,
name|DIOCXBEGIN
argument_list|,
literal|0
argument_list|)
operator|||
name|pfctl_trans
argument_list|(
name|dev
argument_list|,
operator|&
name|t
argument_list|,
name|DIOCXCOMMIT
argument_list|,
literal|0
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"pfctl_clear_nat"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nat cleared\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_clear_altq
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pfr_buffer
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|altqsupport
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memset
argument_list|(
operator|&
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|pfrb_type
operator|=
name|PFRB_TRANS
expr_stmt|;
if|if
condition|(
name|pfctl_add_trans
argument_list|(
operator|&
name|t
argument_list|,
name|PF_RULESET_ALTQ
argument_list|,
literal|""
argument_list|)
operator|||
name|pfctl_trans
argument_list|(
name|dev
argument_list|,
operator|&
name|t
argument_list|,
name|DIOCXBEGIN
argument_list|,
literal|0
argument_list|)
operator|||
name|pfctl_trans
argument_list|(
name|dev
argument_list|,
operator|&
name|t
argument_list|,
name|DIOCXCOMMIT
argument_list|,
literal|0
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"pfctl_clear_altq"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"altq cleared\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_clear_src_nodes
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCLRSRCNODES
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCCLRSRCNODES"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"source tracking entries cleared\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_clear_states
parameter_list|(
name|int
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|iface
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pfioc_state_kill
name|psk
decl_stmt|;
name|memset
argument_list|(
operator|&
name|psk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|!=
name|NULL
operator|&&
name|strlcpy
argument_list|(
name|psk
operator|.
name|psk_ifname
argument_list|,
name|iface
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_ifname
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_ifname
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid interface: %s"
argument_list|,
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCLRSTATES
argument_list|,
operator|&
name|psk
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCCLRSTATES"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d states cleared\n"
argument_list|,
name|psk
operator|.
name|psk_killed
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pfctl_addrprefix
parameter_list|(
name|char
modifier|*
name|addr
parameter_list|,
name|struct
name|pf_addr
modifier|*
name|mask
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|int
name|prefix
decl_stmt|,
name|ret_ga
decl_stmt|,
name|q
decl_stmt|,
name|r
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|addr
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|prefix
operator|=
name|strtonum
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|128
argument_list|,
operator|&
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"prefix is %s: %s"
argument_list|,
name|errstr
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|hints
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
comment|/* prefix only with numeric addresses */
name|hints
operator|.
name|ai_flags
operator||=
name|AI_NUMERICHOST
expr_stmt|;
if|if
condition|(
operator|(
name|ret_ga
operator|=
name|getaddrinfo
argument_list|(
name|addr
argument_list|,
name|NULL
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res
argument_list|)
operator|)
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"getaddrinfo: %s"
argument_list|,
name|gai_strerror
argument_list|(
name|ret_ga
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|res
operator|->
name|ai_family
operator|==
name|AF_INET
operator|&&
name|prefix
operator|>
literal|32
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"prefix too long for AF_INET"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|res
operator|->
name|ai_family
operator|==
name|AF_INET6
operator|&&
name|prefix
operator|>
literal|128
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"prefix too long for AF_INET6"
argument_list|)
expr_stmt|;
name|q
operator|=
name|prefix
operator|>>
literal|3
expr_stmt|;
name|r
operator|=
name|prefix
operator|&
literal|7
expr_stmt|;
switch|switch
condition|(
name|res
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|bzero
argument_list|(
operator|&
name|mask
operator|->
name|v4
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
operator|->
name|v4
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|->
name|v4
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
call|(
name|u_int32_t
call|)
argument_list|(
literal|0xffffffffffULL
operator|<<
operator|(
literal|32
operator|-
name|prefix
operator|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|bzero
argument_list|(
operator|&
name|mask
operator|->
name|v6
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
operator|->
name|v6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|>
literal|0
condition|)
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|mask
operator|->
name|v6
argument_list|,
literal|0xff
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
literal|0
condition|)
operator|*
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mask
operator|->
name|v6
operator|+
name|q
operator|)
operator|=
operator|(
literal|0xff00
operator|>>
name|r
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
block|}
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pfctl_kill_src_nodes
parameter_list|(
name|int
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|iface
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pfioc_src_node_kill
name|psnk
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|res
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|resp
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|sockaddr
name|last_src
decl_stmt|,
name|last_dst
decl_stmt|;
name|int
name|killed
decl_stmt|,
name|sources
decl_stmt|,
name|dests
decl_stmt|;
name|int
name|ret_ga
decl_stmt|;
name|killed
operator|=
name|sources
operator|=
name|dests
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|psnk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|psnk
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|psnk
operator|.
name|psnk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|psnk
operator|.
name|psnk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|last_src
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|last_src
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|last_dst
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|last_dst
argument_list|)
argument_list|)
expr_stmt|;
name|pfctl_addrprefix
argument_list|(
name|src_node_kill
index|[
literal|0
index|]
argument_list|,
operator|&
name|psnk
operator|.
name|psnk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_ga
operator|=
name|getaddrinfo
argument_list|(
name|src_node_kill
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|res
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"getaddrinfo: %s"
argument_list|,
name|gai_strerror
argument_list|(
name|ret_ga
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
for|for
control|(
name|resp
index|[
literal|0
index|]
operator|=
name|res
index|[
literal|0
index|]
init|;
name|resp
index|[
literal|0
index|]
condition|;
name|resp
index|[
literal|0
index|]
operator|=
name|resp
index|[
literal|0
index|]
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|resp
index|[
literal|0
index|]
operator|->
name|ai_addr
operator|==
name|NULL
condition|)
continue|continue;
comment|/* We get lots of duplicates.  Catch the easy ones */
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|last_src
argument_list|,
name|resp
index|[
literal|0
index|]
operator|->
name|ai_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|last_src
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|last_src
operator|=
operator|*
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|resp
index|[
literal|0
index|]
operator|->
name|ai_addr
expr_stmt|;
name|psnk
operator|.
name|psnk_af
operator|=
name|resp
index|[
literal|0
index|]
operator|->
name|ai_family
expr_stmt|;
name|sources
operator|++
expr_stmt|;
if|if
condition|(
name|psnk
operator|.
name|psnk_af
operator|==
name|AF_INET
condition|)
name|psnk
operator|.
name|psnk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
operator|.
name|v4
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|resp
index|[
literal|0
index|]
operator|->
name|ai_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|psnk
operator|.
name|psnk_af
operator|==
name|AF_INET6
condition|)
name|psnk
operator|.
name|psnk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
operator|.
name|v6
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|resp
index|[
literal|0
index|]
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_addr
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unknown address family %d"
argument_list|,
name|psnk
operator|.
name|psnk_af
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_node_killers
operator|>
literal|1
condition|)
block|{
name|dests
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|psnk
operator|.
name|psnk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|psnk
operator|.
name|psnk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|last_dst
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|last_dst
argument_list|)
argument_list|)
expr_stmt|;
name|pfctl_addrprefix
argument_list|(
name|src_node_kill
index|[
literal|1
index|]
argument_list|,
operator|&
name|psnk
operator|.
name|psnk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_ga
operator|=
name|getaddrinfo
argument_list|(
name|src_node_kill
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|res
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"getaddrinfo: %s"
argument_list|,
name|gai_strerror
argument_list|(
name|ret_ga
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
for|for
control|(
name|resp
index|[
literal|1
index|]
operator|=
name|res
index|[
literal|1
index|]
init|;
name|resp
index|[
literal|1
index|]
condition|;
name|resp
index|[
literal|1
index|]
operator|=
name|resp
index|[
literal|1
index|]
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|->
name|ai_addr
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|psnk
operator|.
name|psnk_af
operator|!=
name|resp
index|[
literal|1
index|]
operator|->
name|ai_family
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|last_dst
argument_list|,
name|resp
index|[
literal|1
index|]
operator|->
name|ai_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|last_dst
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|last_dst
operator|=
operator|*
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|resp
index|[
literal|1
index|]
operator|->
name|ai_addr
expr_stmt|;
name|dests
operator|++
expr_stmt|;
if|if
condition|(
name|psnk
operator|.
name|psnk_af
operator|==
name|AF_INET
condition|)
name|psnk
operator|.
name|psnk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
operator|.
name|v4
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|resp
index|[
literal|1
index|]
operator|->
name|ai_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|psnk
operator|.
name|psnk_af
operator|==
name|AF_INET6
condition|)
name|psnk
operator|.
name|psnk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
operator|.
name|v6
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|resp
index|[
literal|1
index|]
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_addr
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unknown address family %d"
argument_list|,
name|psnk
operator|.
name|psnk_af
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCKILLSRCNODES
argument_list|,
operator|&
name|psnk
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCKILLSRCNODES"
argument_list|)
expr_stmt|;
name|killed
operator|+=
name|psnk
operator|.
name|psnk_killed
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|res
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCKILLSRCNODES
argument_list|,
operator|&
name|psnk
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCKILLSRCNODES"
argument_list|)
expr_stmt|;
name|killed
operator|+=
name|psnk
operator|.
name|psnk_killed
expr_stmt|;
block|}
block|}
name|freeaddrinfo
argument_list|(
name|res
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"killed %d src nodes from %d sources and %d "
literal|"destinations\n"
argument_list|,
name|killed
argument_list|,
name|sources
argument_list|,
name|dests
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_net_kill_states
parameter_list|(
name|int
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|iface
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pfioc_state_kill
name|psk
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|res
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|resp
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|sockaddr
name|last_src
decl_stmt|,
name|last_dst
decl_stmt|;
name|int
name|killed
decl_stmt|,
name|sources
decl_stmt|,
name|dests
decl_stmt|;
name|int
name|ret_ga
decl_stmt|;
name|killed
operator|=
name|sources
operator|=
name|dests
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|psk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|psk
operator|.
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|last_src
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|last_src
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|last_dst
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|last_dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|!=
name|NULL
operator|&&
name|strlcpy
argument_list|(
name|psk
operator|.
name|psk_ifname
argument_list|,
name|iface
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_ifname
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_ifname
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid interface: %s"
argument_list|,
name|iface
argument_list|)
expr_stmt|;
name|pfctl_addrprefix
argument_list|(
name|state_kill
index|[
literal|0
index|]
argument_list|,
operator|&
name|psk
operator|.
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_ga
operator|=
name|getaddrinfo
argument_list|(
name|state_kill
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|res
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"getaddrinfo: %s"
argument_list|,
name|gai_strerror
argument_list|(
name|ret_ga
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
for|for
control|(
name|resp
index|[
literal|0
index|]
operator|=
name|res
index|[
literal|0
index|]
init|;
name|resp
index|[
literal|0
index|]
condition|;
name|resp
index|[
literal|0
index|]
operator|=
name|resp
index|[
literal|0
index|]
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|resp
index|[
literal|0
index|]
operator|->
name|ai_addr
operator|==
name|NULL
condition|)
continue|continue;
comment|/* We get lots of duplicates.  Catch the easy ones */
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|last_src
argument_list|,
name|resp
index|[
literal|0
index|]
operator|->
name|ai_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|last_src
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|last_src
operator|=
operator|*
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|resp
index|[
literal|0
index|]
operator|->
name|ai_addr
expr_stmt|;
name|psk
operator|.
name|psk_af
operator|=
name|resp
index|[
literal|0
index|]
operator|->
name|ai_family
expr_stmt|;
name|sources
operator|++
expr_stmt|;
if|if
condition|(
name|psk
operator|.
name|psk_af
operator|==
name|AF_INET
condition|)
name|psk
operator|.
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
operator|.
name|v4
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|resp
index|[
literal|0
index|]
operator|->
name|ai_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|psk
operator|.
name|psk_af
operator|==
name|AF_INET6
condition|)
name|psk
operator|.
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
operator|.
name|v6
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|resp
index|[
literal|0
index|]
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_addr
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unknown address family %d"
argument_list|,
name|psk
operator|.
name|psk_af
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_killers
operator|>
literal|1
condition|)
block|{
name|dests
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|psk
operator|.
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|last_dst
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|last_dst
argument_list|)
argument_list|)
expr_stmt|;
name|pfctl_addrprefix
argument_list|(
name|state_kill
index|[
literal|1
index|]
argument_list|,
operator|&
name|psk
operator|.
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_ga
operator|=
name|getaddrinfo
argument_list|(
name|state_kill
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|res
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"getaddrinfo: %s"
argument_list|,
name|gai_strerror
argument_list|(
name|ret_ga
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
for|for
control|(
name|resp
index|[
literal|1
index|]
operator|=
name|res
index|[
literal|1
index|]
init|;
name|resp
index|[
literal|1
index|]
condition|;
name|resp
index|[
literal|1
index|]
operator|=
name|resp
index|[
literal|1
index|]
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|->
name|ai_addr
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|psk
operator|.
name|psk_af
operator|!=
name|resp
index|[
literal|1
index|]
operator|->
name|ai_family
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|last_dst
argument_list|,
name|resp
index|[
literal|1
index|]
operator|->
name|ai_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|last_dst
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|last_dst
operator|=
operator|*
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|resp
index|[
literal|1
index|]
operator|->
name|ai_addr
expr_stmt|;
name|dests
operator|++
expr_stmt|;
if|if
condition|(
name|psk
operator|.
name|psk_af
operator|==
name|AF_INET
condition|)
name|psk
operator|.
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
operator|.
name|v4
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|resp
index|[
literal|1
index|]
operator|->
name|ai_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|psk
operator|.
name|psk_af
operator|==
name|AF_INET6
condition|)
name|psk
operator|.
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
operator|.
name|v6
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|resp
index|[
literal|1
index|]
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_addr
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unknown address family %d"
argument_list|,
name|psk
operator|.
name|psk_af
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCKILLSTATES
argument_list|,
operator|&
name|psk
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCKILLSTATES"
argument_list|)
expr_stmt|;
name|killed
operator|+=
name|psk
operator|.
name|psk_killed
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|res
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCKILLSTATES
argument_list|,
operator|&
name|psk
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCKILLSTATES"
argument_list|)
expr_stmt|;
name|killed
operator|+=
name|psk
operator|.
name|psk_killed
expr_stmt|;
block|}
block|}
name|freeaddrinfo
argument_list|(
name|res
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"killed %d states from %d sources and %d "
literal|"destinations\n"
argument_list|,
name|killed
argument_list|,
name|sources
argument_list|,
name|dests
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_label_kill_states
parameter_list|(
name|int
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|iface
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pfioc_state_kill
name|psk
decl_stmt|;
if|if
condition|(
name|state_killers
operator|!=
literal|2
operator|||
operator|(
name|strlen
argument_list|(
name|state_kill
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"no label specified"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|psk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|!=
name|NULL
operator|&&
name|strlcpy
argument_list|(
name|psk
operator|.
name|psk_ifname
argument_list|,
name|iface
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_ifname
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_ifname
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid interface: %s"
argument_list|,
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|psk
operator|.
name|psk_label
argument_list|,
name|state_kill
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_label
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_label
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"label too long: %s"
argument_list|,
name|state_kill
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCKILLSTATES
argument_list|,
operator|&
name|psk
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCKILLSTATES"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"killed %d states\n"
argument_list|,
name|psk
operator|.
name|psk_killed
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_id_kill_states
parameter_list|(
name|int
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|iface
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pfioc_state_kill
name|psk
decl_stmt|;
if|if
condition|(
name|state_killers
operator|!=
literal|2
operator|||
operator|(
name|strlen
argument_list|(
name|state_kill
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"no id specified"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|psk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sscanf
argument_list|(
name|state_kill
index|[
literal|1
index|]
argument_list|,
literal|"%jx/%x"
argument_list|,
operator|&
name|psk
operator|.
name|psk_pfcmp
operator|.
name|id
argument_list|,
operator|&
name|psk
operator|.
name|psk_pfcmp
operator|.
name|creatorid
argument_list|)
operator|)
operator|==
literal|2
condition|)
name|HTONL
argument_list|(
name|psk
operator|.
name|psk_pfcmp
operator|.
name|creatorid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sscanf
argument_list|(
name|state_kill
index|[
literal|1
index|]
argument_list|,
literal|"%jx"
argument_list|,
operator|&
name|psk
operator|.
name|psk_pfcmp
operator|.
name|id
argument_list|)
operator|)
operator|==
literal|1
condition|)
block|{
name|psk
operator|.
name|psk_pfcmp
operator|.
name|creatorid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"wrong id format specified"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|psk
operator|.
name|psk_pfcmp
operator|.
name|id
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"cannot kill id 0"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|psk
operator|.
name|psk_pfcmp
operator|.
name|id
operator|=
name|htobe64
argument_list|(
name|psk
operator|.
name|psk_pfcmp
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCKILLSTATES
argument_list|,
operator|&
name|psk
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCKILLSTATES"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"killed %d states\n"
argument_list|,
name|psk
operator|.
name|psk_killed
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_get_pool
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|pf_pool
modifier|*
name|pool
parameter_list|,
name|u_int32_t
name|nr
parameter_list|,
name|u_int32_t
name|ticket
parameter_list|,
name|int
name|r_action
parameter_list|,
name|char
modifier|*
name|anchorname
parameter_list|)
block|{
name|struct
name|pfioc_pooladdr
name|pp
decl_stmt|;
name|struct
name|pf_pooladdr
modifier|*
name|pa
decl_stmt|;
name|u_int32_t
name|pnr
decl_stmt|,
name|mpnr
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pp
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pp
operator|.
name|anchor
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|pp
operator|.
name|anchor
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|.
name|r_action
operator|=
name|r_action
expr_stmt|;
name|pp
operator|.
name|r_num
operator|=
name|nr
expr_stmt|;
name|pp
operator|.
name|ticket
operator|=
name|ticket
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETADDRS
argument_list|,
operator|&
name|pp
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETADDRS"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mpnr
operator|=
name|pp
operator|.
name|nr
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|pnr
operator|=
literal|0
init|;
name|pnr
operator|<
name|mpnr
condition|;
operator|++
name|pnr
control|)
block|{
name|pp
operator|.
name|nr
operator|=
name|pnr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETADDR
argument_list|,
operator|&
name|pp
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETADDR"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pa
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pp
operator|.
name|addr
argument_list|,
name|pa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pfctl_move_pool
parameter_list|(
name|struct
name|pf_pool
modifier|*
name|src
parameter_list|,
name|struct
name|pf_pool
modifier|*
name|dst
parameter_list|)
block|{
name|struct
name|pf_pooladdr
modifier|*
name|pa
decl_stmt|;
while|while
condition|(
operator|(
name|pa
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|src
operator|->
name|list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|src
operator|->
name|list
argument_list|,
name|pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dst
operator|->
name|list
argument_list|,
name|pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pfctl_clear_pool
parameter_list|(
name|struct
name|pf_pool
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|pf_pooladdr
modifier|*
name|pa
decl_stmt|;
while|while
condition|(
operator|(
name|pa
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pfctl_print_rule_counters
parameter_list|(
name|struct
name|pf_rule
modifier|*
name|rule
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
if|if
condition|(
name|opts
operator|&
name|PF_OPT_DEBUG
condition|)
block|{
specifier|const
name|char
modifier|*
name|t
index|[
name|PF_SKIP_COUNT
index|]
init|=
block|{
literal|"i"
block|,
literal|"d"
block|,
literal|"f"
block|,
literal|"p"
block|,
literal|"sa"
block|,
literal|"sp"
block|,
literal|"da"
block|,
literal|"dp"
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"  [ Skip steps: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PF_SKIP_COUNT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|rule
operator|->
name|skip
index|[
name|i
index|]
operator|.
name|nr
operator|==
name|rule
operator|->
name|nr
operator|+
literal|1
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%s="
argument_list|,
name|t
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|skip
index|[
name|i
index|]
operator|.
name|nr
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"end "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%u "
argument_list|,
name|rule
operator|->
name|skip
index|[
name|i
index|]
operator|.
name|nr
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  [ queue: qname=%s qid=%u pqname=%s pqid=%u ]\n"
argument_list|,
name|rule
operator|->
name|qname
argument_list|,
name|rule
operator|->
name|qid
argument_list|,
name|rule
operator|->
name|pqname
argument_list|,
name|rule
operator|->
name|pqid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
block|{
name|printf
argument_list|(
literal|"  [ Evaluations: %-8llu  Packets: %-8llu  "
literal|"Bytes: %-10llu  States: %-6lu]\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|rule
operator|->
name|evaluations
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
name|rule
operator|->
name|packets
index|[
literal|0
index|]
operator|+
name|rule
operator|->
name|packets
index|[
literal|1
index|]
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
name|rule
operator|->
name|bytes
index|[
literal|0
index|]
operator|+
name|rule
operator|->
name|bytes
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|rule
operator|->
name|u_states_cur
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|opts
operator|&
name|PF_OPT_DEBUG
operator|)
condition|)
name|printf
argument_list|(
literal|"  [ Inserted: uid %u pid %u "
literal|"State Creations: %-6lu]\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|rule
operator|->
name|cuid
argument_list|,
operator|(
name|unsigned
operator|)
name|rule
operator|->
name|cpid
argument_list|,
name|rule
operator|->
name|u_states_tot
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pfctl_print_title
parameter_list|(
name|char
modifier|*
name|title
parameter_list|)
block|{
if|if
condition|(
operator|!
name|first_title
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|first_title
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pfctl_show_rules
parameter_list|(
name|int
name|dev
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
name|opts
parameter_list|,
name|enum
name|pfctl_show
name|format
parameter_list|,
name|char
modifier|*
name|anchorname
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|pfioc_rule
name|pr
decl_stmt|;
name|u_int32_t
name|nr
decl_stmt|,
name|mnr
decl_stmt|,
name|header
init|=
literal|0
decl_stmt|;
name|int
name|rule_numbers
init|=
name|opts
operator|&
operator|(
name|PF_OPT_VERBOSE2
operator||
name|PF_OPT_DEBUG
operator|)
decl_stmt|;
name|int
name|numeric
init|=
name|opts
operator|&
name|PF_OPT_NUMERIC
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|int
name|brace
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|path
index|[
literal|0
index|]
condition|)
name|snprintf
argument_list|(
operator|&
name|path
index|[
name|len
index|]
argument_list|,
name|MAXPATHLEN
operator|-
name|len
argument_list|,
literal|"/%s"
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
operator|&
name|path
index|[
name|len
index|]
argument_list|,
name|MAXPATHLEN
operator|-
name|len
argument_list|,
literal|"%s"
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
operator|.
name|anchor
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|anchor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|&
name|PF_OPT_SHOWALL
condition|)
block|{
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_PASS
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETRULES"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|header
operator|++
expr_stmt|;
block|}
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_SCRUB
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETRULES"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|opts
operator|&
name|PF_OPT_SHOWALL
condition|)
block|{
if|if
condition|(
name|format
operator|==
name|PFCTL_SHOW_RULES
operator|&&
operator|(
name|pr
operator|.
name|nr
operator|>
literal|0
operator|||
name|header
operator|)
condition|)
name|pfctl_print_title
argument_list|(
literal|"FILTER RULES:"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|format
operator|==
name|PFCTL_SHOW_LABELS
operator|&&
name|labels
condition|)
name|pfctl_print_title
argument_list|(
literal|"LABEL COUNTERS:"
argument_list|)
expr_stmt|;
block|}
name|mnr
operator|=
name|pr
operator|.
name|nr
expr_stmt|;
if|if
condition|(
name|opts
operator|&
name|PF_OPT_CLRRULECTRS
condition|)
name|pr
operator|.
name|action
operator|=
name|PF_GET_CLR_CNTR
expr_stmt|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|mnr
condition|;
operator|++
name|nr
control|)
block|{
name|pr
operator|.
name|nr
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULE
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETRULE"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|pfctl_get_pool
argument_list|(
name|dev
argument_list|,
operator|&
name|pr
operator|.
name|rule
operator|.
name|rpool
argument_list|,
name|nr
argument_list|,
name|pr
operator|.
name|ticket
argument_list|,
name|PF_SCRUB
argument_list|,
name|path
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|PFCTL_SHOW_LABELS
case|:
break|break;
case|case
name|PFCTL_SHOW_RULES
case|:
if|if
condition|(
name|pr
operator|.
name|rule
operator|.
name|label
index|[
literal|0
index|]
operator|&&
operator|(
name|opts
operator|&
name|PF_OPT_SHOWALL
operator|)
condition|)
name|labels
operator|=
literal|1
expr_stmt|;
name|print_rule
argument_list|(
operator|&
name|pr
operator|.
name|rule
argument_list|,
name|pr
operator|.
name|anchor_call
argument_list|,
name|rule_numbers
argument_list|,
name|numeric
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|pfctl_print_rule_counters
argument_list|(
operator|&
name|pr
operator|.
name|rule
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
name|PFCTL_SHOW_NOTHING
case|:
break|break;
block|}
name|pfctl_clear_pool
argument_list|(
operator|&
name|pr
operator|.
name|rule
operator|.
name|rpool
argument_list|)
expr_stmt|;
block|}
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_PASS
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETRULES"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|mnr
operator|=
name|pr
operator|.
name|nr
expr_stmt|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|mnr
condition|;
operator|++
name|nr
control|)
block|{
name|pr
operator|.
name|nr
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULE
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETRULE"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|pfctl_get_pool
argument_list|(
name|dev
argument_list|,
operator|&
name|pr
operator|.
name|rule
operator|.
name|rpool
argument_list|,
name|nr
argument_list|,
name|pr
operator|.
name|ticket
argument_list|,
name|PF_PASS
argument_list|,
name|path
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|PFCTL_SHOW_LABELS
case|:
if|if
condition|(
name|pr
operator|.
name|rule
operator|.
name|label
index|[
literal|0
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"%s %llu %llu %llu %llu"
literal|" %llu %llu %llu %llu\n"
argument_list|,
name|pr
operator|.
name|rule
operator|.
name|label
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pr
operator|.
name|rule
operator|.
name|evaluations
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
name|pr
operator|.
name|rule
operator|.
name|packets
index|[
literal|0
index|]
operator|+
name|pr
operator|.
name|rule
operator|.
name|packets
index|[
literal|1
index|]
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
name|pr
operator|.
name|rule
operator|.
name|bytes
index|[
literal|0
index|]
operator|+
name|pr
operator|.
name|rule
operator|.
name|bytes
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pr
operator|.
name|rule
operator|.
name|packets
index|[
literal|0
index|]
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pr
operator|.
name|rule
operator|.
name|bytes
index|[
literal|0
index|]
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pr
operator|.
name|rule
operator|.
name|packets
index|[
literal|1
index|]
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pr
operator|.
name|rule
operator|.
name|bytes
index|[
literal|1
index|]
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pr
operator|.
name|rule
operator|.
name|u_states_tot
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PFCTL_SHOW_RULES
case|:
name|brace
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pr
operator|.
name|rule
operator|.
name|label
index|[
literal|0
index|]
operator|&&
operator|(
name|opts
operator|&
name|PF_OPT_SHOWALL
operator|)
condition|)
name|labels
operator|=
literal|1
expr_stmt|;
name|INDENT
argument_list|(
name|depth
argument_list|,
operator|!
operator|(
name|opts
operator|&
name|PF_OPT_VERBOSE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|.
name|anchor_call
index|[
literal|0
index|]
operator|&&
operator|(
operator|(
operator|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|pr
operator|.
name|anchor_call
argument_list|,
literal|'_'
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|void
operator|*
operator|)
name|p
operator|==
operator|(
name|void
operator|*
operator|)
name|pr
operator|.
name|anchor_call
operator|||
operator|*
operator|(
operator|--
name|p
operator|)
operator|==
literal|'/'
operator|)
operator|)
operator|||
operator|(
name|opts
operator|&
name|PF_OPT_RECURSE
operator|)
operator|)
condition|)
block|{
name|brace
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|pr
operator|.
name|anchor_call
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|p
operator|++
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|pr
operator|.
name|anchor_call
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
name|p
operator|=
operator|&
name|pr
operator|.
name|anchor_call
index|[
literal|0
index|]
expr_stmt|;
name|print_rule
argument_list|(
operator|&
name|pr
operator|.
name|rule
argument_list|,
name|p
argument_list|,
name|rule_numbers
argument_list|,
name|numeric
argument_list|)
expr_stmt|;
if|if
condition|(
name|brace
condition|)
name|printf
argument_list|(
literal|" {\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|pfctl_print_rule_counters
argument_list|(
operator|&
name|pr
operator|.
name|rule
argument_list|,
name|opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|brace
condition|)
block|{
name|pfctl_show_rules
argument_list|(
name|dev
argument_list|,
name|path
argument_list|,
name|opts
argument_list|,
name|format
argument_list|,
name|p
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
name|INDENT
argument_list|(
name|depth
argument_list|,
operator|!
operator|(
name|opts
operator|&
name|PF_OPT_VERBOSE
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PFCTL_SHOW_NOTHING
case|:
break|break;
block|}
name|pfctl_clear_pool
argument_list|(
operator|&
name|pr
operator|.
name|rule
operator|.
name|rpool
argument_list|)
expr_stmt|;
block|}
name|path
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|path
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_show_nat
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|,
name|char
modifier|*
name|anchorname
parameter_list|)
block|{
name|struct
name|pfioc_rule
name|pr
decl_stmt|;
name|u_int32_t
name|mnr
decl_stmt|,
name|nr
decl_stmt|;
specifier|static
name|int
name|nattype
index|[
literal|3
index|]
init|=
block|{
name|PF_NAT
block|,
name|PF_RDR
block|,
name|PF_BINAT
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dotitle
init|=
name|opts
operator|&
name|PF_OPT_SHOWALL
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
operator|.
name|anchor
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|anchor
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|nattype
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETRULES"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mnr
operator|=
name|pr
operator|.
name|nr
expr_stmt|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|mnr
condition|;
operator|++
name|nr
control|)
block|{
name|pr
operator|.
name|nr
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULE
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETRULE"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pfctl_get_pool
argument_list|(
name|dev
argument_list|,
operator|&
name|pr
operator|.
name|rule
operator|.
name|rpool
argument_list|,
name|nr
argument_list|,
name|pr
operator|.
name|ticket
argument_list|,
name|nattype
index|[
name|i
index|]
argument_list|,
name|anchorname
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dotitle
condition|)
block|{
name|pfctl_print_title
argument_list|(
literal|"TRANSLATION RULES:"
argument_list|)
expr_stmt|;
name|dotitle
operator|=
literal|0
expr_stmt|;
block|}
name|print_rule
argument_list|(
operator|&
name|pr
operator|.
name|rule
argument_list|,
name|pr
operator|.
name|anchor_call
argument_list|,
name|opts
operator|&
name|PF_OPT_VERBOSE2
argument_list|,
name|opts
operator|&
name|PF_OPT_NUMERIC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|pfctl_print_rule_counters
argument_list|(
operator|&
name|pr
operator|.
name|rule
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_clear_pool
argument_list|(
operator|&
name|pr
operator|.
name|rule
operator|.
name|rpool
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_show_src_nodes
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pfioc_src_nodes
name|psn
decl_stmt|;
name|struct
name|pf_src_node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|inbuf
init|=
name|NULL
decl_stmt|,
modifier|*
name|newinbuf
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|psn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|psn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|psn
operator|.
name|psn_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|newinbuf
operator|=
name|realloc
argument_list|(
name|inbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newinbuf
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"realloc"
argument_list|)
expr_stmt|;
name|psn
operator|.
name|psn_buf
operator|=
name|inbuf
operator|=
name|newinbuf
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETSRCNODES
argument_list|,
operator|&
name|psn
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETSRCNODES"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|psn
operator|.
name|psn_len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pfioc_src_nodes
argument_list|)
operator|<
name|len
condition|)
break|break;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|psn
operator|.
name|psn_len
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|psn
operator|.
name|psn_len
operator|!=
literal|0
condition|)
name|len
operator|=
name|psn
operator|.
name|psn_len
expr_stmt|;
if|if
condition|(
name|psn
operator|.
name|psn_len
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* no src_nodes */
name|len
operator|*=
literal|2
expr_stmt|;
block|}
name|p
operator|=
name|psn
operator|.
name|psn_src_nodes
expr_stmt|;
if|if
condition|(
name|psn
operator|.
name|psn_len
operator|>
literal|0
operator|&&
operator|(
name|opts
operator|&
name|PF_OPT_SHOWALL
operator|)
condition|)
name|pfctl_print_title
argument_list|(
literal|"SOURCE TRACKING NODES:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|psn
operator|.
name|psn_len
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
control|)
block|{
name|print_src_node
argument_list|(
name|p
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|done
label|:
name|free
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_show_states
parameter_list|(
name|int
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|iface
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pfioc_states
name|ps
decl_stmt|;
name|struct
name|pfsync_state
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|inbuf
init|=
name|NULL
decl_stmt|,
modifier|*
name|newinbuf
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dotitle
init|=
operator|(
name|opts
operator|&
name|PF_OPT_SHOWALL
operator|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ps
operator|.
name|ps_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|newinbuf
operator|=
name|realloc
argument_list|(
name|inbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newinbuf
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"realloc"
argument_list|)
expr_stmt|;
name|ps
operator|.
name|ps_buf
operator|=
name|inbuf
operator|=
name|newinbuf
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETSTATES
argument_list|,
operator|&
name|ps
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETSTATES"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ps
operator|.
name|ps_len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pfioc_states
argument_list|)
operator|<
name|len
condition|)
break|break;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|ps
operator|.
name|ps_len
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|ps
operator|.
name|ps_len
operator|!=
literal|0
condition|)
name|len
operator|=
name|ps
operator|.
name|ps_len
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|ps_len
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* no states */
name|len
operator|*=
literal|2
expr_stmt|;
block|}
name|p
operator|=
name|ps
operator|.
name|ps_states
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ps
operator|.
name|ps_len
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
name|iface
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|p
operator|->
name|ifname
argument_list|,
name|iface
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dotitle
condition|)
block|{
name|pfctl_print_title
argument_list|(
literal|"STATES:"
argument_list|)
expr_stmt|;
name|dotitle
operator|=
literal|0
expr_stmt|;
block|}
name|print_state
argument_list|(
name|p
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|free
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_show_status
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pf_status
name|status
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETSTATUS
argument_list|,
operator|&
name|status
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETSTATUS"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|opts
operator|&
name|PF_OPT_SHOWALL
condition|)
name|pfctl_print_title
argument_list|(
literal|"INFO:"
argument_list|)
expr_stmt|;
name|print_status
argument_list|(
operator|&
name|status
argument_list|,
name|opts
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_show_timeouts
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pfioc_tm
name|pt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|opts
operator|&
name|PF_OPT_SHOWALL
condition|)
name|pfctl_print_title
argument_list|(
literal|"TIMEOUTS:"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pt
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|pt
operator|.
name|timeout
operator|=
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|timeout
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETTIMEOUT
argument_list|,
operator|&
name|pt
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETTIMEOUT"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-20s %10d"
argument_list|,
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|pt
operator|.
name|seconds
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|timeout
operator|>=
name|PFTM_ADAPTIVE_START
operator|&&
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|timeout
operator|<=
name|PFTM_ADAPTIVE_END
condition|)
name|printf
argument_list|(
literal|" states"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"s"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_show_limits
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pfioc_limit
name|pl
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|opts
operator|&
name|PF_OPT_SHOWALL
condition|)
name|pfctl_print_title
argument_list|(
literal|"LIMITS:"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pl
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pf_limits
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|pl
operator|.
name|index
operator|=
name|pf_limits
index|[
name|i
index|]
operator|.
name|index
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETLIMIT
argument_list|,
operator|&
name|pl
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETLIMIT"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-13s "
argument_list|,
name|pf_limits
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pl
operator|.
name|limit
operator|==
name|UINT_MAX
condition|)
name|printf
argument_list|(
literal|"unlimited\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"hard limit %8u\n"
argument_list|,
name|pl
operator|.
name|limit
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* callbacks for rule/nat/rdr/addr */
end_comment

begin_function
name|int
name|pfctl_add_pool
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|struct
name|pf_pool
modifier|*
name|p
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
name|struct
name|pf_pooladdr
modifier|*
name|pa
decl_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCBEGINADDRS
argument_list|,
operator|&
name|pf
operator|->
name|paddr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCBEGINADDRS"
argument_list|)
expr_stmt|;
block|}
name|pf
operator|->
name|paddr
operator|.
name|af
operator|=
name|af
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pa
argument_list|,
argument|&p->list
argument_list|,
argument|entries
argument_list|)
block|{
name|memcpy
argument_list|(
operator|&
name|pf
operator|->
name|paddr
operator|.
name|addr
argument_list|,
name|pa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCADDADDR
argument_list|,
operator|&
name|pf
operator|->
name|paddr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCADDADDR"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_add_rule
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|struct
name|pf_rule
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|anchor_call
parameter_list|)
block|{
name|u_int8_t
name|rs_num
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|r
operator|->
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|==
name|PF_RULESET_MAX
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Invalid rule type %d"
argument_list|,
name|r
operator|->
name|action
argument_list|)
expr_stmt|;
name|rs
operator|=
operator|&
name|pf
operator|->
name|anchor
operator|->
name|ruleset
expr_stmt|;
if|if
condition|(
name|anchor_call
index|[
literal|0
index|]
operator|&&
name|r
operator|->
name|anchor
operator|==
name|NULL
condition|)
block|{
comment|/*  		 * Don't make non-brace anchors part of the main anchor pool. 		 */
if|if
condition|(
operator|(
name|r
operator|->
name|anchor
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
operator|->
name|anchor
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"pfctl_add_rule: calloc"
argument_list|)
expr_stmt|;
name|pf_init_ruleset
argument_list|(
operator|&
name|r
operator|->
name|anchor
operator|->
name|ruleset
argument_list|)
expr_stmt|;
name|r
operator|->
name|anchor
operator|->
name|ruleset
operator|.
name|anchor
operator|=
name|r
operator|->
name|anchor
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|r
operator|->
name|anchor
operator|->
name|path
argument_list|,
name|anchor_call
argument_list|,
sizeof|sizeof
argument_list|(
name|rule
operator|->
name|anchor
operator|->
name|path
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|rule
operator|->
name|anchor
operator|->
name|path
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"pfctl_add_rule: strlcpy"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|anchor_call
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|strlen
argument_list|(
name|p
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"pfctl_add_rule: bad anchor name %s"
argument_list|,
name|anchor_call
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|anchor_call
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|r
operator|->
name|anchor
operator|->
name|name
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|rule
operator|->
name|anchor
operator|->
name|name
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|rule
operator|->
name|anchor
operator|->
name|name
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"pfctl_add_rule: strlcpy"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rule
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rule
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|r
argument_list|,
name|rule
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rule
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|rule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
name|pfctl_move_pool
argument_list|(
operator|&
name|r
operator|->
name|rpool
argument_list|,
operator|&
name|rule
operator|->
name|rpool
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|rule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_ruleset_trans
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|pf_anchor
modifier|*
name|a
parameter_list|)
block|{
name|int
name|osize
init|=
name|pf
operator|->
name|trans
operator|->
name|pfrb_size
decl_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|loadopt
operator|&
name|PFCTL_FLAG_NAT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pfctl_add_trans
argument_list|(
name|pf
operator|->
name|trans
argument_list|,
name|PF_RULESET_NAT
argument_list|,
name|path
argument_list|)
operator|||
name|pfctl_add_trans
argument_list|(
name|pf
operator|->
name|trans
argument_list|,
name|PF_RULESET_BINAT
argument_list|,
name|path
argument_list|)
operator|||
name|pfctl_add_trans
argument_list|(
name|pf
operator|->
name|trans
argument_list|,
name|PF_RULESET_RDR
argument_list|,
name|path
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|a
operator|==
name|pf
operator|->
name|astack
index|[
literal|0
index|]
operator|&&
operator|(
operator|(
name|altqsupport
operator|&&
operator|(
name|pf
operator|->
name|loadopt
operator|&
name|PFCTL_FLAG_ALTQ
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|pfctl_add_trans
argument_list|(
name|pf
operator|->
name|trans
argument_list|,
name|PF_RULESET_ALTQ
argument_list|,
name|path
argument_list|)
condition|)
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|pf
operator|->
name|loadopt
operator|&
name|PFCTL_FLAG_FILTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pfctl_add_trans
argument_list|(
name|pf
operator|->
name|trans
argument_list|,
name|PF_RULESET_SCRUB
argument_list|,
name|path
argument_list|)
operator|||
name|pfctl_add_trans
argument_list|(
name|pf
operator|->
name|trans
argument_list|,
name|PF_RULESET_FILTER
argument_list|,
name|path
argument_list|)
condition|)
return|return
operator|(
literal|3
operator|)
return|;
block|}
if|if
condition|(
name|pf
operator|->
name|loadopt
operator|&
name|PFCTL_FLAG_TABLE
condition|)
if|if
condition|(
name|pfctl_add_trans
argument_list|(
name|pf
operator|->
name|trans
argument_list|,
name|PF_RULESET_TABLE
argument_list|,
name|path
argument_list|)
condition|)
return|return
operator|(
literal|4
operator|)
return|;
if|if
condition|(
name|pfctl_trans
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|pf
operator|->
name|trans
argument_list|,
name|DIOCXBEGIN
argument_list|,
name|osize
argument_list|)
condition|)
return|return
operator|(
literal|5
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_load_ruleset
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|pf_ruleset
modifier|*
name|rs
parameter_list|,
name|int
name|rs_num
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|pf_rule
modifier|*
name|r
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|int
name|brace
init|=
literal|0
decl_stmt|;
name|pf
operator|->
name|anchor
operator|=
name|rs
operator|->
name|anchor
expr_stmt|;
if|if
condition|(
name|path
index|[
literal|0
index|]
condition|)
name|snprintf
argument_list|(
operator|&
name|path
index|[
name|len
index|]
argument_list|,
name|MAXPATHLEN
operator|-
name|len
argument_list|,
literal|"/%s"
argument_list|,
name|pf
operator|->
name|anchor
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
operator|&
name|path
index|[
name|len
index|]
argument_list|,
name|MAXPATHLEN
operator|-
name|len
argument_list|,
literal|"%s"
argument_list|,
name|pf
operator|->
name|anchor
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
condition|)
block|{
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|brace
operator|++
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
name|printf
argument_list|(
literal|" {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|pfctl_ruleset_trans
argument_list|(
name|pf
argument_list|,
name|path
argument_list|,
name|rs
operator|->
name|anchor
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pfctl_load_rulesets: "
literal|"pfctl_ruleset_trans %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pf
operator|->
name|optimize
operator|&&
name|rs_num
operator|==
name|PF_RULESET_FILTER
condition|)
name|pfctl_optimize_ruleset
argument_list|(
name|pf
argument_list|,
name|rs
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|TAILQ_FIRST
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pfctl_load_rule
argument_list|(
name|pf
argument_list|,
name|path
argument_list|,
name|r
argument_list|,
name|depth
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|r
operator|->
name|anchor
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|pfctl_load_ruleset
argument_list|(
name|pf
argument_list|,
name|path
argument_list|,
operator|&
name|r
operator|->
name|anchor
operator|->
name|ruleset
argument_list|,
name|rs_num
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|brace
operator|&&
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
block|{
name|INDENT
argument_list|(
name|depth
operator|-
literal|1
argument_list|,
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
name|path
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|path
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_load_rule
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|pf_rule
modifier|*
name|r
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|u_int8_t
name|rs_num
init|=
name|pf_get_ruleset_number
argument_list|(
name|r
operator|->
name|action
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|pfioc_rule
name|pr
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|pr
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set up anchor before adding to path for anchor_call */
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
name|pr
operator|.
name|ticket
operator|=
name|pfctl_get_ticket
argument_list|(
name|pf
operator|->
name|trans
argument_list|,
name|rs_num
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|pr
operator|.
name|anchor
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|anchor
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|anchor
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"pfctl_load_rule: strlcpy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|anchor
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|anchor
operator|->
name|match
condition|)
block|{
if|if
condition|(
name|path
index|[
literal|0
index|]
condition|)
name|snprintf
argument_list|(
operator|&
name|path
index|[
name|len
index|]
argument_list|,
name|MAXPATHLEN
operator|-
name|len
argument_list|,
literal|"/%s"
argument_list|,
name|r
operator|->
name|anchor
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
operator|&
name|path
index|[
name|len
index|]
argument_list|,
name|MAXPATHLEN
operator|-
name|len
argument_list|,
literal|"%s"
argument_list|,
name|r
operator|->
name|anchor
operator|->
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|path
expr_stmt|;
block|}
else|else
name|name
operator|=
name|r
operator|->
name|anchor
operator|->
name|path
expr_stmt|;
block|}
else|else
name|name
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pfctl_add_pool
argument_list|(
name|pf
argument_list|,
operator|&
name|r
operator|->
name|rpool
argument_list|,
name|r
operator|->
name|af
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|pr
operator|.
name|pool_ticket
operator|=
name|pf
operator|->
name|paddr
operator|.
name|ticket
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pr
operator|.
name|rule
argument_list|,
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|rule
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|anchor
operator|&&
name|strlcpy
argument_list|(
name|pr
operator|.
name|anchor_call
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|anchor_call
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|anchor_call
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"pfctl_load_rule: strlcpy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCADDRULE
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCADDRULE"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
block|{
name|INDENT
argument_list|(
name|depth
argument_list|,
operator|!
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE2
operator|)
argument_list|)
expr_stmt|;
name|print_rule
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|anchor
condition|?
name|r
operator|->
name|anchor
operator|->
name|name
else|:
literal|""
argument_list|,
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE2
argument_list|,
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_NUMERIC
argument_list|)
expr_stmt|;
block|}
name|path
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pfctl_clear_pool
argument_list|(
operator|&
name|r
operator|->
name|rpool
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_add_altq
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|struct
name|pf_altq
modifier|*
name|a
parameter_list|)
block|{
if|if
condition|(
name|altqsupport
operator|&&
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_ALTQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|pf
operator|->
name|paltq
operator|->
name|altq
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_altq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCADDALTQ
argument_list|,
name|pf
operator|->
name|paltq
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENXIO
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"qtype not configured"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENODEV
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: driver does not support "
literal|"altq"
argument_list|,
name|a
operator|->
name|ifname
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCADDALTQ"
argument_list|)
expr_stmt|;
block|}
block|}
name|pfaltq_store
argument_list|(
operator|&
name|pf
operator|->
name|paltq
operator|->
name|altq
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_rules
parameter_list|(
name|int
name|dev
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|opts
parameter_list|,
name|int
name|optimize
parameter_list|,
name|char
modifier|*
name|anchorname
parameter_list|,
name|struct
name|pfr_buffer
modifier|*
name|trans
parameter_list|)
block|{
define|#
directive|define
name|ERR
parameter_list|(
name|x
parameter_list|)
value|do { warn(x); goto _error; } while(0)
define|#
directive|define
name|ERRX
parameter_list|(
name|x
parameter_list|)
value|do { warnx(x); goto _error; } while(0)
name|struct
name|pfr_buffer
modifier|*
name|t
decl_stmt|,
name|buf
decl_stmt|;
name|struct
name|pfioc_altq
name|pa
decl_stmt|;
name|struct
name|pfctl
name|pf
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|struct
name|pfr_table
name|trs
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|osize
decl_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|pf_anchors
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pf_main_anchor
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pf_main_anchor
argument_list|)
argument_list|)
expr_stmt|;
name|pf_init_ruleset
argument_list|(
operator|&
name|pf_main_anchor
operator|.
name|ruleset
argument_list|)
expr_stmt|;
name|pf_main_anchor
operator|.
name|ruleset
operator|.
name|anchor
operator|=
operator|&
name|pf_main_anchor
expr_stmt|;
if|if
condition|(
name|trans
operator|==
name|NULL
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|.
name|pfrb_type
operator|=
name|PFRB_TRANS
expr_stmt|;
name|t
operator|=
operator|&
name|buf
expr_stmt|;
name|osize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|trans
expr_stmt|;
name|osize
operator|=
name|t
operator|->
name|pfrb_size
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|pa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pa
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|trs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|trs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|path
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|MAXPATHLEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERRX
argument_list|(
literal|"pfctl_rules: calloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|trs
operator|.
name|pfrt_anchor
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|trs
operator|.
name|pfrt_anchor
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|trs
operator|.
name|pfrt_anchor
argument_list|)
condition|)
name|ERRX
argument_list|(
literal|"pfctl_rules: strlcpy"
argument_list|)
expr_stmt|;
name|pf
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|pf
operator|.
name|opts
operator|=
name|opts
expr_stmt|;
name|pf
operator|.
name|optimize
operator|=
name|optimize
expr_stmt|;
name|pf
operator|.
name|loadopt
operator|=
name|loadopt
expr_stmt|;
comment|/* non-brace anchor, create without resolving the path */
if|if
condition|(
operator|(
name|pf
operator|.
name|anchor
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pf
operator|.
name|anchor
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERRX
argument_list|(
literal|"pfctl_rules: calloc"
argument_list|)
expr_stmt|;
name|rs
operator|=
operator|&
name|pf
operator|.
name|anchor
operator|->
name|ruleset
expr_stmt|;
name|pf_init_ruleset
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|->
name|anchor
operator|=
name|pf
operator|.
name|anchor
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|pf
operator|.
name|anchor
operator|->
name|path
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|pf
operator|.
name|anchor
operator|->
name|path
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|pf
operator|.
name|anchor
operator|->
name|path
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"pfctl_add_rule: strlcpy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|pf
operator|.
name|anchor
operator|->
name|name
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|pf
operator|.
name|anchor
operator|->
name|name
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|pf
operator|.
name|anchor
operator|->
name|name
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"pfctl_add_rule: strlcpy"
argument_list|)
expr_stmt|;
name|pf
operator|.
name|astack
index|[
literal|0
index|]
operator|=
name|pf
operator|.
name|anchor
expr_stmt|;
name|pf
operator|.
name|asd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|anchorname
index|[
literal|0
index|]
condition|)
name|pf
operator|.
name|loadopt
operator|&=
operator|~
name|PFCTL_FLAG_ALTQ
expr_stmt|;
name|pf
operator|.
name|paltq
operator|=
operator|&
name|pa
expr_stmt|;
name|pf
operator|.
name|trans
operator|=
name|t
expr_stmt|;
name|pfctl_init_options
argument_list|(
operator|&
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * XXX For the time being we need to open transactions for 		 * the main ruleset before parsing, because tables are still 		 * loaded at parse time. 		 */
if|if
condition|(
name|pfctl_ruleset_trans
argument_list|(
operator|&
name|pf
argument_list|,
name|anchorname
argument_list|,
name|pf
operator|.
name|anchor
argument_list|)
condition|)
name|ERRX
argument_list|(
literal|"pfctl_rules"
argument_list|)
expr_stmt|;
if|if
condition|(
name|altqsupport
operator|&&
operator|(
name|pf
operator|.
name|loadopt
operator|&
name|PFCTL_FLAG_ALTQ
operator|)
condition|)
name|pa
operator|.
name|ticket
operator|=
name|pfctl_get_ticket
argument_list|(
name|t
argument_list|,
name|PF_RULESET_ALTQ
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|.
name|loadopt
operator|&
name|PFCTL_FLAG_TABLE
condition|)
name|pf
operator|.
name|astack
index|[
literal|0
index|]
operator|->
name|ruleset
operator|.
name|tticket
operator|=
name|pfctl_get_ticket
argument_list|(
name|t
argument_list|,
name|PF_RULESET_TABLE
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parse_config
argument_list|(
name|filename
argument_list|,
operator|&
name|pf
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
name|ERRX
argument_list|(
literal|"Syntax error in config file: "
literal|"pf rules not loaded"
argument_list|)
expr_stmt|;
else|else
goto|goto
name|_error
goto|;
block|}
if|if
condition|(
operator|(
name|pf
operator|.
name|loadopt
operator|&
name|PFCTL_FLAG_FILTER
operator|&&
operator|(
name|pfctl_load_ruleset
argument_list|(
operator|&
name|pf
argument_list|,
name|path
argument_list|,
name|rs
argument_list|,
name|PF_RULESET_SCRUB
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|pf
operator|.
name|loadopt
operator|&
name|PFCTL_FLAG_NAT
operator|&&
operator|(
name|pfctl_load_ruleset
argument_list|(
operator|&
name|pf
argument_list|,
name|path
argument_list|,
name|rs
argument_list|,
name|PF_RULESET_NAT
argument_list|,
literal|0
argument_list|)
operator|||
name|pfctl_load_ruleset
argument_list|(
operator|&
name|pf
argument_list|,
name|path
argument_list|,
name|rs
argument_list|,
name|PF_RULESET_RDR
argument_list|,
literal|0
argument_list|)
operator|||
name|pfctl_load_ruleset
argument_list|(
operator|&
name|pf
argument_list|,
name|path
argument_list|,
name|rs
argument_list|,
name|PF_RULESET_BINAT
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|pf
operator|.
name|loadopt
operator|&
name|PFCTL_FLAG_FILTER
operator|&&
name|pfctl_load_ruleset
argument_list|(
operator|&
name|pf
argument_list|,
name|path
argument_list|,
name|rs
argument_list|,
name|PF_RULESET_FILTER
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
name|ERRX
argument_list|(
literal|"Unable to load rules into kernel"
argument_list|)
expr_stmt|;
else|else
goto|goto
name|_error
goto|;
block|}
if|if
condition|(
operator|(
name|altqsupport
operator|&&
operator|(
name|pf
operator|.
name|loadopt
operator|&
name|PFCTL_FLAG_ALTQ
operator|)
operator|!=
literal|0
operator|)
condition|)
if|if
condition|(
name|check_commit_altq
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
operator|!=
literal|0
condition|)
name|ERRX
argument_list|(
literal|"errors in altq config"
argument_list|)
expr_stmt|;
comment|/* process "load anchor" directives */
if|if
condition|(
operator|!
name|anchorname
index|[
literal|0
index|]
condition|)
if|if
condition|(
name|pfctl_load_anchors
argument_list|(
name|dev
argument_list|,
operator|&
name|pf
argument_list|,
name|t
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ERRX
argument_list|(
literal|"load anchors"
argument_list|)
expr_stmt|;
if|if
condition|(
name|trans
operator|==
name|NULL
operator|&&
operator|(
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|anchorname
index|[
literal|0
index|]
condition|)
if|if
condition|(
name|pfctl_load_options
argument_list|(
operator|&
name|pf
argument_list|)
condition|)
goto|goto
name|_error
goto|;
if|if
condition|(
name|pfctl_trans
argument_list|(
name|dev
argument_list|,
name|t
argument_list|,
name|DIOCXCOMMIT
argument_list|,
name|osize
argument_list|)
condition|)
name|ERR
argument_list|(
literal|"DIOCXCOMMIT"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|_error
label|:
if|if
condition|(
name|trans
operator|==
name|NULL
condition|)
block|{
comment|/* main ruleset */
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|pfctl_trans
argument_list|(
name|dev
argument_list|,
name|t
argument_list|,
name|DIOCXROLLBACK
argument_list|,
name|osize
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCXROLLBACK"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* sub ruleset */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
undef|#
directive|undef
name|ERR
undef|#
directive|undef
name|ERRX
block|}
end_function

begin_function
name|FILE
modifier|*
name|pfctl_fopen
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EISDIR
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pfctl_init_options
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|)
block|{
name|pf
operator|->
name|timeout
index|[
name|PFTM_TCP_FIRST_PACKET
index|]
operator|=
name|PFTM_TCP_FIRST_PACKET_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_TCP_OPENING
index|]
operator|=
name|PFTM_TCP_OPENING_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_TCP_ESTABLISHED
index|]
operator|=
name|PFTM_TCP_ESTABLISHED_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_TCP_CLOSING
index|]
operator|=
name|PFTM_TCP_CLOSING_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_TCP_FIN_WAIT
index|]
operator|=
name|PFTM_TCP_FIN_WAIT_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_TCP_CLOSED
index|]
operator|=
name|PFTM_TCP_CLOSED_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_UDP_FIRST_PACKET
index|]
operator|=
name|PFTM_UDP_FIRST_PACKET_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_UDP_SINGLE
index|]
operator|=
name|PFTM_UDP_SINGLE_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_UDP_MULTIPLE
index|]
operator|=
name|PFTM_UDP_MULTIPLE_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_ICMP_FIRST_PACKET
index|]
operator|=
name|PFTM_ICMP_FIRST_PACKET_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_ICMP_ERROR_REPLY
index|]
operator|=
name|PFTM_ICMP_ERROR_REPLY_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_OTHER_FIRST_PACKET
index|]
operator|=
name|PFTM_OTHER_FIRST_PACKET_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_OTHER_SINGLE
index|]
operator|=
name|PFTM_OTHER_SINGLE_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_OTHER_MULTIPLE
index|]
operator|=
name|PFTM_OTHER_MULTIPLE_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_FRAG
index|]
operator|=
name|PFTM_FRAG_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_INTERVAL
index|]
operator|=
name|PFTM_INTERVAL_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_SRC_NODE
index|]
operator|=
name|PFTM_SRC_NODE_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_TS_DIFF
index|]
operator|=
name|PFTM_TS_DIFF_VAL
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_ADAPTIVE_START
index|]
operator|=
name|PFSTATE_ADAPT_START
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_ADAPTIVE_END
index|]
operator|=
name|PFSTATE_ADAPT_END
expr_stmt|;
name|pf
operator|->
name|limit
index|[
name|PF_LIMIT_STATES
index|]
operator|=
name|PFSTATE_HIWAT
expr_stmt|;
name|pf
operator|->
name|limit
index|[
name|PF_LIMIT_FRAGS
index|]
operator|=
name|PFFRAG_FRENT_HIWAT
expr_stmt|;
name|pf
operator|->
name|limit
index|[
name|PF_LIMIT_SRC_NODES
index|]
operator|=
name|PFSNODE_HIWAT
expr_stmt|;
name|pf
operator|->
name|limit
index|[
name|PF_LIMIT_TABLE_ENTRIES
index|]
operator|=
name|PFR_KENTRY_HIWAT
expr_stmt|;
name|pf
operator|->
name|debug
operator|=
name|PF_DEBUG_URGENT
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pfctl_load_options
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_OPTION
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* load limits */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PF_LIMIT_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_MERGE
operator|)
operator|&&
operator|!
name|pf
operator|->
name|limit_set
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|pfctl_load_limit
argument_list|(
name|pf
argument_list|,
name|i
argument_list|,
name|pf
operator|->
name|limit
index|[
name|i
index|]
argument_list|)
condition|)
name|error
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If we've set the limit, but haven't explicitly set adaptive 	 * timeouts, do it now with a start of 60% and end of 120%. 	 */
if|if
condition|(
name|pf
operator|->
name|limit_set
index|[
name|PF_LIMIT_STATES
index|]
operator|&&
operator|!
name|pf
operator|->
name|timeout_set
index|[
name|PFTM_ADAPTIVE_START
index|]
operator|&&
operator|!
name|pf
operator|->
name|timeout_set
index|[
name|PFTM_ADAPTIVE_END
index|]
condition|)
block|{
name|pf
operator|->
name|timeout
index|[
name|PFTM_ADAPTIVE_START
index|]
operator|=
operator|(
name|pf
operator|->
name|limit
index|[
name|PF_LIMIT_STATES
index|]
operator|/
literal|10
operator|)
operator|*
literal|6
expr_stmt|;
name|pf
operator|->
name|timeout_set
index|[
name|PFTM_ADAPTIVE_START
index|]
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|timeout
index|[
name|PFTM_ADAPTIVE_END
index|]
operator|=
operator|(
name|pf
operator|->
name|limit
index|[
name|PF_LIMIT_STATES
index|]
operator|/
literal|10
operator|)
operator|*
literal|12
expr_stmt|;
name|pf
operator|->
name|timeout_set
index|[
name|PFTM_ADAPTIVE_END
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* load timeouts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PFTM_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_MERGE
operator|)
operator|&&
operator|!
name|pf
operator|->
name|timeout_set
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|pfctl_load_timeout
argument_list|(
name|pf
argument_list|,
name|i
argument_list|,
name|pf
operator|->
name|timeout
index|[
name|i
index|]
argument_list|)
condition|)
name|error
operator|=
literal|1
expr_stmt|;
block|}
comment|/* load debug */
if|if
condition|(
operator|!
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_MERGE
operator|)
operator|||
name|pf
operator|->
name|debug_set
condition|)
if|if
condition|(
name|pfctl_load_debug
argument_list|(
name|pf
argument_list|,
name|pf
operator|->
name|debug
argument_list|)
condition|)
name|error
operator|=
literal|1
expr_stmt|;
comment|/* load logif */
if|if
condition|(
operator|!
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_MERGE
operator|)
operator|||
name|pf
operator|->
name|ifname_set
condition|)
if|if
condition|(
name|pfctl_load_logif
argument_list|(
name|pf
argument_list|,
name|pf
operator|->
name|ifname
argument_list|)
condition|)
name|error
operator|=
literal|1
expr_stmt|;
comment|/* load hostid */
if|if
condition|(
operator|!
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_MERGE
operator|)
operator|||
name|pf
operator|->
name|hostid_set
condition|)
if|if
condition|(
name|pfctl_load_hostid
argument_list|(
name|pf
argument_list|,
name|pf
operator|->
name|hostid
argument_list|)
condition|)
name|error
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_set_limit
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
specifier|const
name|char
modifier|*
name|opt
parameter_list|,
name|unsigned
name|int
name|limit
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pf_limits
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|opt
argument_list|,
name|pf_limits
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pf
operator|->
name|limit
index|[
name|pf_limits
index|[
name|i
index|]
operator|.
name|index
index|]
operator|=
name|limit
expr_stmt|;
name|pf
operator|->
name|limit_set
index|[
name|pf_limits
index|[
name|i
index|]
operator|.
name|index
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pf_limits
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Bad pool name."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
name|printf
argument_list|(
literal|"set limit %s %d\n"
argument_list|,
name|opt
argument_list|,
name|limit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_load_limit
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|unsigned
name|int
name|limit
parameter_list|)
block|{
name|struct
name|pfioc_limit
name|pl
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pl
argument_list|)
argument_list|)
expr_stmt|;
name|pl
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|pl
operator|.
name|limit
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCSETLIMIT
argument_list|,
operator|&
name|pl
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EBUSY
condition|)
name|warnx
argument_list|(
literal|"Current pool size exceeds requested hard limit"
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"DIOCSETLIMIT"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_set_timeout
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
specifier|const
name|char
modifier|*
name|opt
parameter_list|,
name|int
name|seconds
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_OPTION
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|opt
argument_list|,
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pf
operator|->
name|timeout
index|[
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|timeout
index|]
operator|=
name|seconds
expr_stmt|;
name|pf
operator|->
name|timeout_set
index|[
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|timeout
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Bad timeout name."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
operator|&&
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"set timeout %s %d\n"
argument_list|,
name|opt
argument_list|,
name|seconds
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_load_timeout
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|unsigned
name|int
name|timeout
parameter_list|,
name|unsigned
name|int
name|seconds
parameter_list|)
block|{
name|struct
name|pfioc_tm
name|pt
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pt
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
name|pt
operator|.
name|seconds
operator|=
name|seconds
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCSETTIMEOUT
argument_list|,
operator|&
name|pt
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"DIOCSETTIMEOUT"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_set_optimization
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
specifier|const
name|char
modifier|*
name|opt
parameter_list|)
block|{
specifier|const
name|struct
name|pf_hint
modifier|*
name|hint
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_OPTION
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pf_hints
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|opt
argument_list|,
name|pf_hints
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|hint
operator|=
name|pf_hints
index|[
name|i
index|]
operator|.
name|hint
expr_stmt|;
if|if
condition|(
name|hint
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid state timeouts optimization"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hint
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|r
operator|=
name|pfctl_set_timeout
argument_list|(
name|pf
argument_list|,
name|hint
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|hint
index|[
name|i
index|]
operator|.
name|timeout
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
name|printf
argument_list|(
literal|"set optimization %s\n"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_set_logif
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|char
modifier|*
name|ifname
parameter_list|)
block|{
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_OPTION
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ifname
argument_list|,
literal|"none"
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|pf
operator|->
name|ifname
argument_list|)
expr_stmt|;
name|pf
operator|->
name|ifname
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|pf
operator|->
name|ifname
operator|=
name|strdup
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pf
operator|->
name|ifname
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"pfctl_set_logif: strdup"
argument_list|)
expr_stmt|;
block|}
name|pf
operator|->
name|ifname_set
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
name|printf
argument_list|(
literal|"set loginterface %s\n"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_load_logif
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|char
modifier|*
name|ifname
parameter_list|)
block|{
name|struct
name|pfioc_if
name|pi
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifname
operator|&&
name|strlcpy
argument_list|(
name|pi
operator|.
name|ifname
argument_list|,
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|.
name|ifname
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|pi
operator|.
name|ifname
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"pfctl_load_logif: strlcpy"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCSETSTATUSIF
argument_list|,
operator|&
name|pi
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"DIOCSETSTATUSIF"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_set_hostid
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|u_int32_t
name|hostid
parameter_list|)
block|{
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_OPTION
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|HTONL
argument_list|(
name|hostid
argument_list|)
expr_stmt|;
name|pf
operator|->
name|hostid
operator|=
name|hostid
expr_stmt|;
name|pf
operator|->
name|hostid_set
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
name|printf
argument_list|(
literal|"set hostid 0x%08x\n"
argument_list|,
name|ntohl
argument_list|(
name|hostid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_load_hostid
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|u_int32_t
name|hostid
parameter_list|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCSETHOSTID
argument_list|,
operator|&
name|hostid
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"DIOCSETHOSTID"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_set_debug
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|char
modifier|*
name|d
parameter_list|)
block|{
name|u_int32_t
name|level
decl_stmt|;
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_OPTION
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|d
argument_list|,
literal|"none"
argument_list|)
condition|)
name|pf
operator|->
name|debug
operator|=
name|PF_DEBUG_NONE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|d
argument_list|,
literal|"urgent"
argument_list|)
condition|)
name|pf
operator|->
name|debug
operator|=
name|PF_DEBUG_URGENT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|d
argument_list|,
literal|"misc"
argument_list|)
condition|)
name|pf
operator|->
name|debug
operator|=
name|PF_DEBUG_MISC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|d
argument_list|,
literal|"loud"
argument_list|)
condition|)
name|pf
operator|->
name|debug
operator|=
name|PF_DEBUG_NOISY
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"unknown debug level \"%s\""
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pf
operator|->
name|debug_set
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCSETDEBUG
argument_list|,
operator|&
name|level
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCSETDEBUG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
name|printf
argument_list|(
literal|"set debug %s\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_load_debug
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|unsigned
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCSETDEBUG
argument_list|,
operator|&
name|level
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"DIOCSETDEBUG"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_set_interface_flags
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|char
modifier|*
name|ifname
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|struct
name|pfioc_iface
name|pi
decl_stmt|;
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_OPTION
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|pi
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|.
name|pfiio_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|pi
operator|.
name|pfiio_name
argument_list|,
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|.
name|pfiio_name
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|pi
operator|.
name|pfiio_name
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"pfctl_set_interface_flags: strlcpy"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|how
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCCLRIFFLAG
argument_list|,
operator|&
name|pi
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCCLRIFFLAG"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCSETIFFLAG
argument_list|,
operator|&
name|pi
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCSETIFFLAG"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pfctl_debug
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_int32_t
name|level
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCSETDEBUG
argument_list|,
operator|&
name|level
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCSETDEBUG"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"debug level set to '"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|PF_DEBUG_NONE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"none"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_DEBUG_URGENT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"urgent"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_DEBUG_MISC
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"misc"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_DEBUG_NOISY
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"loud"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<invalid>"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|pfctl_test_altqsupport
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pfioc_altq
name|pa
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETALTQS
argument_list|,
operator|&
name|pa
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENODEV
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No ALTQ support in kernel\n"
literal|"ALTQ related functions disabled\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETALTQS"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_show_anchors
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|,
name|char
modifier|*
name|anchorname
parameter_list|)
block|{
name|struct
name|pfioc_ruleset
name|pr
decl_stmt|;
name|u_int32_t
name|mnr
decl_stmt|,
name|nr
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
operator|.
name|path
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULESETS
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Anchor '%s' not found.\n"
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETRULESETS"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mnr
operator|=
name|pr
operator|.
name|nr
expr_stmt|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|mnr
condition|;
operator|++
name|nr
control|)
block|{
name|char
name|sub
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|pr
operator|.
name|nr
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULESET
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETRULESET"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pr
operator|.
name|name
argument_list|,
name|PF_RESERVED_ANCHOR
argument_list|)
condition|)
continue|continue;
name|sub
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pr
operator|.
name|path
index|[
literal|0
index|]
condition|)
block|{
name|strlcat
argument_list|(
name|sub
argument_list|,
name|pr
operator|.
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|sub
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|sub
argument_list|,
name|pr
operator|.
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub
index|[
literal|0
index|]
operator|!=
literal|'_'
operator|||
operator|(
name|opts
operator|&
name|PF_OPT_VERBOSE
operator|)
condition|)
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_VERBOSE
operator|)
operator|&&
name|pfctl_show_anchors
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|sub
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|pfctl_lookup_option
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|cmd
operator|!=
name|NULL
operator|&&
operator|*
name|cmd
condition|)
for|for
control|(
init|;
operator|*
name|list
condition|;
name|list
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cmd
argument_list|,
operator|*
name|list
argument_list|,
name|strlen
argument_list|(
name|cmd
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|*
name|list
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|mode
init|=
name|O_RDONLY
decl_stmt|;
name|int
name|opts
init|=
literal|0
decl_stmt|;
name|int
name|optimize
init|=
name|PF_OPTIMIZE_BASIC
decl_stmt|;
name|char
name|anchorname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:AdD:eqf:F:ghi:k:K:mnNOo:Pp:rRs:t:T:vx:z"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|anchoropt
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|opts
operator||=
name|PF_OPT_DISABLE
expr_stmt|;
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|pfctl_cmdline_symset
argument_list|(
name|optarg
argument_list|)
operator|<
literal|0
condition|)
name|warnx
argument_list|(
literal|"could not parse macro definition %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|opts
operator||=
name|PF_OPT_ENABLE
expr_stmt|;
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|opts
operator||=
name|PF_OPT_QUIET
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|clearopt
operator|=
name|pfctl_lookup_option
argument_list|(
name|optarg
argument_list|,
name|clearopt_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|clearopt
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Unknown flush modifier '%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|ifaceopt
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|state_killers
operator|>=
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"can only specify -k twice"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|state_kill
index|[
name|state_killers
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
if|if
condition|(
name|src_node_killers
operator|>=
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"can only specify -K twice"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|src_node_kill
index|[
name|src_node_killers
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|opts
operator||=
name|PF_OPT_MERGE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|opts
operator||=
name|PF_OPT_NOACTION
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|loadopt
operator||=
name|PFCTL_FLAG_NAT
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|opts
operator||=
name|PF_OPT_USEDNS
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|rulesopt
operator|=
name|optarg
expr_stmt|;
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|opts
operator||=
name|PF_OPT_DEBUG
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|loadopt
operator||=
name|PFCTL_FLAG_ALTQ
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|loadopt
operator||=
name|PFCTL_FLAG_FILTER
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|optiopt
operator|=
name|pfctl_lookup_option
argument_list|(
name|optarg
argument_list|,
name|optiopt_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|optiopt
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Unknown optimization '%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|opts
operator||=
name|PF_OPT_OPTIMIZE
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|loadopt
operator||=
name|PFCTL_FLAG_OPTION
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pf_device
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|opts
operator||=
name|PF_OPT_NUMERIC
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|showopt
operator|=
name|pfctl_lookup_option
argument_list|(
name|optarg
argument_list|,
name|showopt_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|showopt
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Unknown show modifier '%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|tableopt
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|tblcmdopt
operator|=
name|pfctl_lookup_option
argument_list|(
name|optarg
argument_list|,
name|tblcmdopt_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|tblcmdopt
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Unknown table command '%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
name|opts
operator||=
name|PF_OPT_VERBOSE2
expr_stmt|;
name|opts
operator||=
name|PF_OPT_VERBOSE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|debugopt
operator|=
name|pfctl_lookup_option
argument_list|(
name|optarg
argument_list|,
name|debugopt_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugopt
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Unknown debug level '%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|opts
operator||=
name|PF_OPT_CLRRULECTRS
expr_stmt|;
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* FALLTHROUGH */
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
if|if
condition|(
name|tblcmdopt
operator|!=
name|NULL
condition|)
block|{
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|ch
operator|=
operator|*
name|tblcmdopt
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'l'
condition|)
block|{
name|loadopt
operator||=
name|PFCTL_FLAG_TABLE
expr_stmt|;
name|tblcmdopt
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|mode
operator|=
name|strchr
argument_list|(
literal|"acdefkrz"
argument_list|,
name|ch
argument_list|)
condition|?
name|O_RDWR
else|:
name|O_RDONLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|!=
name|optind
condition|)
block|{
name|warnx
argument_list|(
literal|"unknown command line argument: %s ..."
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|loadopt
operator|==
literal|0
condition|)
name|loadopt
operator|=
operator|~
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|path
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|MAXPATHLEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"pfctl: calloc"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|anchorname
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|anchorname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|anchoropt
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|anchoropt
argument_list|)
decl_stmt|;
if|if
condition|(
name|anchoropt
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|len
operator|>=
literal|2
operator|&&
name|anchoropt
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'/'
condition|)
name|anchoropt
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|anchoropt
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator||=
name|PF_OPT_RECURSE
expr_stmt|;
block|}
if|if
condition|(
name|strlcpy
argument_list|(
name|anchorname
argument_list|,
name|anchoropt
argument_list|,
sizeof|sizeof
argument_list|(
name|anchorname
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|anchorname
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"anchor name '%s' too long"
argument_list|,
name|anchoropt
argument_list|)
expr_stmt|;
name|loadopt
operator|&=
name|PFCTL_FLAG_FILTER
operator||
name|PFCTL_FLAG_NAT
operator||
name|PFCTL_FLAG_TABLE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
name|dev
operator|=
name|open
argument_list|(
name|pf_device
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|pf_device
argument_list|)
expr_stmt|;
name|altqsupport
operator|=
name|pfctl_test_altqsupport
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|=
name|open
argument_list|(
name|pf_device
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|>=
literal|0
condition|)
name|opts
operator||=
name|PF_OPT_DUMMYACTION
expr_stmt|;
comment|/* turn off options */
name|opts
operator|&=
operator|~
operator|(
name|PF_OPT_DISABLE
operator||
name|PF_OPT_ENABLE
operator|)
expr_stmt|;
name|clearopt
operator|=
name|showopt
operator|=
name|debugopt
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ENABLE_ALTQ
argument_list|)
name|altqsupport
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|altqsupport
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|opts
operator|&
name|PF_OPT_DISABLE
condition|)
if|if
condition|(
name|pfctl_disable
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
condition|)
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|showopt
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
operator|*
name|showopt
condition|)
block|{
case|case
literal|'A'
case|:
name|pfctl_show_anchors
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|pfctl_load_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_rules
argument_list|(
name|dev
argument_list|,
name|path
argument_list|,
name|opts
argument_list|,
name|PFCTL_SHOW_RULES
argument_list|,
name|anchorname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|pfctl_load_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_rules
argument_list|(
name|dev
argument_list|,
name|path
argument_list|,
name|opts
argument_list|,
name|PFCTL_SHOW_LABELS
argument_list|,
name|anchorname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|pfctl_load_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_nat
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|pfctl_show_altq
argument_list|(
name|dev
argument_list|,
name|ifaceopt
argument_list|,
name|opts
argument_list|,
name|opts
operator|&
name|PF_OPT_VERBOSE2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|pfctl_show_states
argument_list|(
name|dev
argument_list|,
name|ifaceopt
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|pfctl_show_src_nodes
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|pfctl_show_status
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|pfctl_show_timeouts
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|pfctl_show_limits
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|opts
operator||=
name|PF_OPT_SHOWALL
expr_stmt|;
name|pfctl_load_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_nat
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
name|pfctl_show_rules
argument_list|(
name|dev
argument_list|,
name|path
argument_list|,
name|opts
argument_list|,
literal|0
argument_list|,
name|anchorname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfctl_show_altq
argument_list|(
name|dev
argument_list|,
name|ifaceopt
argument_list|,
name|opts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfctl_show_states
argument_list|(
name|dev
argument_list|,
name|ifaceopt
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_src_nodes
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_status
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_rules
argument_list|(
name|dev
argument_list|,
name|path
argument_list|,
name|opts
argument_list|,
literal|1
argument_list|,
name|anchorname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfctl_show_timeouts
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_limits
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_tables
argument_list|(
name|anchorname
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_fingerprints
argument_list|(
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|pfctl_show_tables
argument_list|(
name|anchorname
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|pfctl_load_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_fingerprints
argument_list|(
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|pfctl_show_ifaces
argument_list|(
name|ifaceopt
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_CLRRULECTRS
operator|)
operator|&&
name|showopt
operator|==
name|NULL
condition|)
name|pfctl_show_rules
argument_list|(
name|dev
argument_list|,
name|path
argument_list|,
name|opts
argument_list|,
name|PFCTL_SHOW_NOTHING
argument_list|,
name|anchorname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clearopt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|anchorname
index|[
literal|0
index|]
operator|==
literal|'_'
operator|||
name|strstr
argument_list|(
name|anchorname
argument_list|,
literal|"/_"
argument_list|)
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"anchor names beginning with '_' cannot "
literal|"be modified from the command line"
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|clearopt
condition|)
block|{
case|case
literal|'r'
case|:
name|pfctl_clear_rules
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|pfctl_clear_nat
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|pfctl_clear_altq
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|pfctl_clear_states
argument_list|(
name|dev
argument_list|,
name|ifaceopt
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|pfctl_clear_src_nodes
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|pfctl_clear_stats
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|pfctl_clear_rules
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
name|pfctl_clear_nat
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
name|pfctl_clear_tables
argument_list|(
name|anchorname
argument_list|,
name|opts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|anchorname
condition|)
block|{
name|pfctl_clear_altq
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_clear_states
argument_list|(
name|dev
argument_list|,
name|ifaceopt
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_clear_src_nodes
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_clear_stats
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_clear_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_clear_interface_flags
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
name|pfctl_clear_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|pfctl_clear_tables
argument_list|(
name|anchorname
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|state_killers
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|state_kill
index|[
literal|0
index|]
argument_list|,
literal|"label"
argument_list|)
condition|)
name|pfctl_label_kill_states
argument_list|(
name|dev
argument_list|,
name|ifaceopt
argument_list|,
name|opts
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|state_kill
index|[
literal|0
index|]
argument_list|,
literal|"id"
argument_list|)
condition|)
name|pfctl_id_kill_states
argument_list|(
name|dev
argument_list|,
name|ifaceopt
argument_list|,
name|opts
argument_list|)
expr_stmt|;
else|else
name|pfctl_net_kill_states
argument_list|(
name|dev
argument_list|,
name|ifaceopt
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src_node_killers
condition|)
name|pfctl_kill_src_nodes
argument_list|(
name|dev
argument_list|,
name|ifaceopt
argument_list|,
name|opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|tblcmdopt
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|pfctl_command_tables
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|tableopt
argument_list|,
name|tblcmdopt
argument_list|,
name|rulesopt
argument_list|,
name|anchorname
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|rulesopt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|optiopt
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
operator|*
name|optiopt
condition|)
block|{
case|case
literal|'n'
case|:
name|optimize
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|optimize
operator||=
name|PF_OPTIMIZE_BASIC
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
name|optimize
operator||=
name|PF_OPTIMIZE_PROFILE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|rulesopt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_OPTION
operator|)
operator|&&
operator|!
name|anchorname
index|[
literal|0
index|]
condition|)
if|if
condition|(
name|pfctl_clear_interface_flags
argument_list|(
name|dev
argument_list|,
name|opts
operator||
name|PF_OPT_QUIET
argument_list|)
condition|)
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rulesopt
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|opts
operator|&
operator|(
name|PF_OPT_MERGE
operator||
name|PF_OPT_NOACTION
operator|)
operator|)
operator|&&
operator|!
name|anchorname
index|[
literal|0
index|]
operator|&&
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_OPTION
operator|)
condition|)
if|if
condition|(
name|pfctl_file_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|PF_OSFP_FILE
argument_list|)
condition|)
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rulesopt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|anchorname
index|[
literal|0
index|]
operator|==
literal|'_'
operator|||
name|strstr
argument_list|(
name|anchorname
argument_list|,
literal|"/_"
argument_list|)
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"anchor names beginning with '_' cannot "
literal|"be modified from the command line"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfctl_rules
argument_list|(
name|dev
argument_list|,
name|rulesopt
argument_list|,
name|opts
argument_list|,
name|optimize
argument_list|,
name|anchorname
argument_list|,
name|NULL
argument_list|)
condition|)
name|error
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|&&
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_TABLE
operator|)
condition|)
name|warn_namespace_collision
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opts
operator|&
name|PF_OPT_ENABLE
condition|)
if|if
condition|(
name|pfctl_enable
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
condition|)
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|debugopt
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
operator|*
name|debugopt
condition|)
block|{
case|case
literal|'n'
case|:
name|pfctl_debug
argument_list|(
name|dev
argument_list|,
name|PF_DEBUG_NONE
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|pfctl_debug
argument_list|(
name|dev
argument_list|,
name|PF_DEBUG_URGENT
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|pfctl_debug
argument_list|(
name|dev
argument_list|,
name|PF_DEBUG_MISC
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|pfctl_debug
argument_list|(
name|dev
argument_list|,
name|PF_DEBUG_NOISY
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|exit
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

