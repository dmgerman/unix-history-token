begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: pfctl_osfp.c,v 1.14 2006/04/08 02:13:14 ray Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2003 Mike Frantzen<frantzen@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/pfvar.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"pfctl_parser.h"
end_include

begin_include
include|#
directive|include
file|"pfctl.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)< (b)) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MIN */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)> (b)) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAX */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|DEBUG
parameter_list|(
name|fp
parameter_list|,
name|str
parameter_list|,
name|v
modifier|...
parameter_list|)
define|\
value|fprintf(stderr, "%s:%s:%s " str "\n", (fp)->fp_os.fp_class_nm, \ 	    (fp)->fp_os.fp_version_nm, (fp)->fp_os.fp_subtype_nm , ## v);
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEBUG
parameter_list|(
name|fp
parameter_list|,
name|str
parameter_list|,
name|v
modifier|...
parameter_list|)
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct_decl
struct_decl|struct
name|name_entry
struct_decl|;
end_struct_decl

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|name_list
argument_list|,
name|name_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|name_entry
block|{
name|LIST_ENTRY
argument_list|(
argument|name_entry
argument_list|)
name|nm_entry
expr_stmt|;
name|int
name|nm_num
decl_stmt|;
name|char
name|nm_name
index|[
name|PF_OSFP_LEN
index|]
decl_stmt|;
name|struct
name|name_list
name|nm_sublist
decl_stmt|;
name|int
name|nm_sublist_num
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|name_list
name|classes
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
operator|&
name|classes
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|class_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fingerprint_count
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|add_fingerprint
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|pf_osfp_ioctl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|name_entry
modifier|*
name|fingerprint_name_entry
parameter_list|(
name|struct
name|name_list
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pfctl_flush_my_fingerprints
parameter_list|(
name|struct
name|name_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|get_field
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|get_int
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|get_str
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|get_tcpopts
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|pf_tcpopts_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|import_fingerprint
parameter_list|(
name|struct
name|pf_osfp_ioctl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|char
modifier|*
name|print_ioctl
parameter_list|(
name|struct
name|pf_osfp_ioctl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_name_list
parameter_list|(
name|int
parameter_list|,
name|struct
name|name_list
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sort_name_list
parameter_list|(
name|int
parameter_list|,
name|struct
name|name_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|name_entry
modifier|*
name|lookup_name_list
parameter_list|(
name|struct
name|name_list
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Load fingerprints from a file */
end_comment

begin_function
name|int
name|pfctl_file_fingerprints
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|,
specifier|const
name|char
modifier|*
name|fp_filename
parameter_list|)
block|{
name|FILE
modifier|*
name|in
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lineno
init|=
literal|0
decl_stmt|;
name|int
name|window
decl_stmt|,
name|w_mod
decl_stmt|,
name|ttl
decl_stmt|,
name|df
decl_stmt|,
name|psize
decl_stmt|,
name|p_mod
decl_stmt|,
name|mss
decl_stmt|,
name|mss_mod
decl_stmt|,
name|wscale
decl_stmt|,
name|wscale_mod
decl_stmt|,
name|optcnt
decl_stmt|,
name|ts0
decl_stmt|;
name|pf_tcpopts_t
name|packed_tcpopts
decl_stmt|;
name|char
modifier|*
name|class
decl_stmt|,
modifier|*
name|version
decl_stmt|,
modifier|*
name|subtype
decl_stmt|,
modifier|*
name|desc
decl_stmt|,
modifier|*
name|tcpopts
decl_stmt|;
name|struct
name|pf_osfp_ioctl
name|fp
decl_stmt|;
name|pfctl_flush_my_fingerprints
argument_list|(
operator|&
name|classes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|pfctl_fopen
argument_list|(
name|fp_filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|fp_filename
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|class
operator|=
name|version
operator|=
name|subtype
operator|=
name|desc
operator|=
name|tcpopts
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
name|pfctl_clear_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|fgetln
argument_list|(
name|in
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|class
condition|)
name|free
argument_list|(
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
condition|)
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtype
condition|)
name|free
argument_list|(
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
condition|)
name|free
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcpopts
condition|)
name|free
argument_list|(
name|tcpopts
argument_list|)
expr_stmt|;
name|class
operator|=
name|version
operator|=
name|subtype
operator|=
name|desc
operator|=
name|tcpopts
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Chop off comment */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|line
index|[
name|i
index|]
operator|==
literal|'#'
condition|)
block|{
name|len
operator|=
name|i
expr_stmt|;
break|break;
block|}
comment|/* Chop off whitespace */
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
name|line
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|len
operator|--
expr_stmt|;
name|line
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
define|#
directive|define
name|T_DC
value|0x01
comment|/* Allow don't care */
define|#
directive|define
name|T_MSS
value|0x02
comment|/* Allow MSS multiple */
define|#
directive|define
name|T_MTU
value|0x04
comment|/* Allow MTU multiple */
define|#
directive|define
name|T_MOD
value|0x08
comment|/* Allow modulus */
define|#
directive|define
name|GET_INT
parameter_list|(
name|v
parameter_list|,
name|mod
parameter_list|,
name|n
parameter_list|,
name|ty
parameter_list|,
name|mx
parameter_list|)
define|\
value|get_int(&line,&len,&v, mod, n, ty, mx, fp_filename, lineno)
define|#
directive|define
name|GET_STR
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|,
name|mn
parameter_list|)
define|\
value|get_str(&line,&len,&v, n, mn, fp_filename, lineno)
if|if
condition|(
name|GET_INT
argument_list|(
name|window
argument_list|,
operator|&
name|w_mod
argument_list|,
literal|"window size"
argument_list|,
name|T_DC
operator||
name|T_MSS
operator||
name|T_MTU
operator||
name|T_MOD
argument_list|,
literal|0xffff
argument_list|)
operator|||
name|GET_INT
argument_list|(
name|ttl
argument_list|,
name|NULL
argument_list|,
literal|"ttl"
argument_list|,
literal|0
argument_list|,
literal|0xff
argument_list|)
operator|||
name|GET_INT
argument_list|(
name|df
argument_list|,
name|NULL
argument_list|,
literal|"don't fragment frag"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|||
name|GET_INT
argument_list|(
name|psize
argument_list|,
operator|&
name|p_mod
argument_list|,
literal|"overall packet size"
argument_list|,
name|T_MOD
operator||
name|T_DC
argument_list|,
literal|8192
argument_list|)
operator|||
name|GET_STR
argument_list|(
name|tcpopts
argument_list|,
literal|"TCP Options"
argument_list|,
literal|1
argument_list|)
operator|||
name|GET_STR
argument_list|(
name|class
argument_list|,
literal|"OS class"
argument_list|,
literal|1
argument_list|)
operator|||
name|GET_STR
argument_list|(
name|version
argument_list|,
literal|"OS version"
argument_list|,
literal|0
argument_list|)
operator|||
name|GET_STR
argument_list|(
name|subtype
argument_list|,
literal|"OS subtype"
argument_list|,
literal|0
argument_list|)
operator|||
name|GET_STR
argument_list|(
name|desc
argument_list|,
literal|"OS description"
argument_list|,
literal|2
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|get_tcpopts
argument_list|(
name|fp_filename
argument_list|,
name|lineno
argument_list|,
name|tcpopts
argument_list|,
operator|&
name|packed_tcpopts
argument_list|,
operator|&
name|optcnt
argument_list|,
operator|&
name|mss
argument_list|,
operator|&
name|mss_mod
argument_list|,
operator|&
name|wscale
argument_list|,
operator|&
name|wscale_mod
argument_list|,
operator|&
name|ts0
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d excess field\n"
argument_list|,
name|fp_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fp
operator|.
name|fp_ttl
operator|=
name|ttl
expr_stmt|;
if|if
condition|(
name|df
condition|)
name|fp
operator|.
name|fp_flags
operator||=
name|PF_OSFP_DF
expr_stmt|;
switch|switch
condition|(
name|w_mod
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
name|T_DC
case|:
name|fp
operator|.
name|fp_flags
operator||=
name|PF_OSFP_WSIZE_DC
expr_stmt|;
break|break;
case|case
name|T_MSS
case|:
name|fp
operator|.
name|fp_flags
operator||=
name|PF_OSFP_WSIZE_MSS
expr_stmt|;
break|break;
case|case
name|T_MTU
case|:
name|fp
operator|.
name|fp_flags
operator||=
name|PF_OSFP_WSIZE_MTU
expr_stmt|;
break|break;
case|case
name|T_MOD
case|:
name|fp
operator|.
name|fp_flags
operator||=
name|PF_OSFP_WSIZE_MOD
expr_stmt|;
break|break;
block|}
name|fp
operator|.
name|fp_wsize
operator|=
name|window
expr_stmt|;
switch|switch
condition|(
name|p_mod
condition|)
block|{
case|case
name|T_DC
case|:
name|fp
operator|.
name|fp_flags
operator||=
name|PF_OSFP_PSIZE_DC
expr_stmt|;
break|break;
case|case
name|T_MOD
case|:
name|fp
operator|.
name|fp_flags
operator||=
name|PF_OSFP_PSIZE_MOD
expr_stmt|;
block|}
name|fp
operator|.
name|fp_psize
operator|=
name|psize
expr_stmt|;
switch|switch
condition|(
name|wscale_mod
condition|)
block|{
case|case
name|T_DC
case|:
name|fp
operator|.
name|fp_flags
operator||=
name|PF_OSFP_WSCALE_DC
expr_stmt|;
break|break;
case|case
name|T_MOD
case|:
name|fp
operator|.
name|fp_flags
operator||=
name|PF_OSFP_WSCALE_MOD
expr_stmt|;
block|}
name|fp
operator|.
name|fp_wscale
operator|=
name|wscale
expr_stmt|;
switch|switch
condition|(
name|mss_mod
condition|)
block|{
case|case
name|T_DC
case|:
name|fp
operator|.
name|fp_flags
operator||=
name|PF_OSFP_MSS_DC
expr_stmt|;
break|break;
case|case
name|T_MOD
case|:
name|fp
operator|.
name|fp_flags
operator||=
name|PF_OSFP_MSS_MOD
expr_stmt|;
break|break;
block|}
name|fp
operator|.
name|fp_mss
operator|=
name|mss
expr_stmt|;
name|fp
operator|.
name|fp_tcpopts
operator|=
name|packed_tcpopts
expr_stmt|;
name|fp
operator|.
name|fp_optcnt
operator|=
name|optcnt
expr_stmt|;
if|if
condition|(
name|ts0
condition|)
name|fp
operator|.
name|fp_flags
operator||=
name|PF_OSFP_TS0
expr_stmt|;
if|if
condition|(
name|class
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
name|fp
operator|.
name|fp_os
operator|.
name|fp_enflags
operator||=
name|PF_OSFP_GENERIC
expr_stmt|;
if|if
condition|(
name|class
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|fp
operator|.
name|fp_os
operator|.
name|fp_enflags
operator||=
name|PF_OSFP_NODETAIL
expr_stmt|;
if|if
condition|(
name|class
index|[
literal|0
index|]
operator|==
literal|'@'
operator|||
name|class
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|strlcpy
argument_list|(
name|fp
operator|.
name|fp_os
operator|.
name|fp_class_nm
argument_list|,
name|class
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|.
name|fp_os
operator|.
name|fp_class_nm
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|fp
operator|.
name|fp_os
operator|.
name|fp_class_nm
argument_list|,
name|class
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|.
name|fp_os
operator|.
name|fp_class_nm
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|fp
operator|.
name|fp_os
operator|.
name|fp_version_nm
argument_list|,
name|version
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|.
name|fp_os
operator|.
name|fp_version_nm
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|fp
operator|.
name|fp_os
operator|.
name|fp_subtype_nm
argument_list|,
name|subtype
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|.
name|fp_os
operator|.
name|fp_subtype_nm
argument_list|)
argument_list|)
expr_stmt|;
name|add_fingerprint
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|.
name|fp_flags
operator||=
operator|(
name|PF_OSFP_DF
operator||
name|PF_OSFP_INET6
operator|)
expr_stmt|;
name|fp
operator|.
name|fp_psize
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|add_fingerprint
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|class
condition|)
name|free
argument_list|(
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
condition|)
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtype
condition|)
name|free
argument_list|(
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
condition|)
name|free
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcpopts
condition|)
name|free
argument_list|(
name|tcpopts
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|&
name|PF_OPT_VERBOSE2
condition|)
name|printf
argument_list|(
literal|"Loaded %d passive OS fingerprints\n"
argument_list|,
name|fingerprint_count
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* flush the kernel's fingerprints */
end_comment

begin_function
name|void
name|pfctl_clear_fingerprints
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCOSFPFLUSH
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCOSFPFLUSH"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* flush pfctl's view of the fingerprints */
end_comment

begin_function
name|void
name|pfctl_flush_my_fingerprints
parameter_list|(
name|struct
name|name_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|name_entry
modifier|*
name|nm
decl_stmt|;
while|while
condition|(
operator|(
name|nm
operator|=
name|LIST_FIRST
argument_list|(
name|list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|nm
argument_list|,
name|nm_entry
argument_list|)
expr_stmt|;
name|pfctl_flush_my_fingerprints
argument_list|(
operator|&
name|nm
operator|->
name|nm_sublist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
block|}
name|fingerprint_count
operator|=
literal|0
expr_stmt|;
name|class_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch the active fingerprints from the kernel */
end_comment

begin_function
name|int
name|pfctl_load_fingerprints
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pf_osfp_ioctl
name|io
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pfctl_flush_my_fingerprints
argument_list|(
operator|&
name|classes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|memset
argument_list|(
operator|&
name|io
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
name|io
operator|.
name|fp_getnum
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCOSFPGET
argument_list|,
operator|&
name|io
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EBUSY
condition|)
break|break;
name|warn
argument_list|(
literal|"DIOCOSFPGET"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|import_fingerprint
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* List the fingerprints */
end_comment

begin_function
name|void
name|pfctl_show_fingerprints
parameter_list|(
name|int
name|opts
parameter_list|)
block|{
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|classes
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|opts
operator|&
name|PF_OPT_SHOWALL
condition|)
block|{
name|pfctl_print_title
argument_list|(
literal|"OS FINGERPRINTS:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%u fingerprints loaded\n"
argument_list|,
name|fingerprint_count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Class\tVersion\tSubtype(subversion)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-----\t-------\t-------------------\n"
argument_list|)
expr_stmt|;
name|sort_name_list
argument_list|(
name|opts
argument_list|,
operator|&
name|classes
argument_list|)
expr_stmt|;
name|print_name_list
argument_list|(
name|opts
argument_list|,
operator|&
name|classes
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Lookup a fingerprint */
end_comment

begin_function
name|pf_osfp_t
name|pfctl_get_fingerprint
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|name_entry
modifier|*
name|nm
decl_stmt|,
modifier|*
name|class_nm
decl_stmt|,
modifier|*
name|version_nm
decl_stmt|,
modifier|*
name|subtype_nm
decl_stmt|;
name|pf_osfp_t
name|ret
init|=
name|PF_OSFP_NOMATCH
decl_stmt|;
name|int
name|class
decl_stmt|,
name|version
decl_stmt|,
name|subtype
decl_stmt|;
name|int
name|unp_class
decl_stmt|,
name|unp_version
decl_stmt|,
name|unp_subtype
decl_stmt|;
name|int
name|wr_len
decl_stmt|,
name|version_len
decl_stmt|,
name|subtype_len
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|wr_name
decl_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
literal|"unknown"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|PF_OSFP_UNKNOWN
operator|)
return|;
comment|/* Try most likely no version and no subtype */
if|if
condition|(
operator|(
name|nm
operator|=
name|lookup_name_list
argument_list|(
operator|&
name|classes
argument_list|,
name|name
argument_list|)
operator|)
condition|)
block|{
name|class
operator|=
name|nm
operator|->
name|nm_num
expr_stmt|;
name|version
operator|=
name|PF_OSFP_ANY
expr_stmt|;
name|subtype
operator|=
name|PF_OSFP_ANY
expr_stmt|;
goto|goto
name|found
goto|;
block|}
else|else
block|{
comment|/* Chop it up into class/version/subtype */
if|if
condition|(
operator|(
name|wr_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|strchr
argument_list|(
name|wr_name
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|wr_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_OSFP_NOMATCH
operator|)
return|;
block|}
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* The class is easy to find since it is delimited by a space */
if|if
condition|(
operator|(
name|class_nm
operator|=
name|lookup_name_list
argument_list|(
operator|&
name|classes
argument_list|,
name|wr_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|wr_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_OSFP_NOMATCH
operator|)
return|;
block|}
name|class
operator|=
name|class_nm
operator|->
name|nm_num
expr_stmt|;
comment|/* Try no subtype */
if|if
condition|(
operator|(
name|version_nm
operator|=
name|lookup_name_list
argument_list|(
operator|&
name|class_nm
operator|->
name|nm_sublist
argument_list|,
name|ptr
argument_list|)
operator|)
condition|)
block|{
name|version
operator|=
name|version_nm
operator|->
name|nm_num
expr_stmt|;
name|subtype
operator|=
name|PF_OSFP_ANY
expr_stmt|;
name|free
argument_list|(
name|wr_name
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
comment|/* 		 * There must be a version and a subtype. 		 * We'll do some fuzzy matching to pick up things like: 		 *   Linux 2.2.14 (version=2.2 subtype=14) 		 *   FreeBSD 4.0-STABLE (version=4.0 subtype=STABLE) 		 *   Windows 2000 SP2	(version=2000 subtype=SP2) 		 */
define|#
directive|define
name|CONNECTOR
parameter_list|(
name|x
parameter_list|)
value|((x) == '.' || (x) == ' ' || (x) == '\t' || (x) == '-')
name|wr_len
operator|=
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|version_nm
argument_list|,
argument|&class_nm->nm_sublist
argument_list|,
argument|nm_entry
argument_list|)
block|{
name|version_len
operator|=
name|strlen
argument_list|(
name|version_nm
operator|->
name|nm_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr_len
operator|<
name|version_len
operator|+
literal|2
operator|||
operator|!
name|CONNECTOR
argument_list|(
name|ptr
index|[
name|version_len
index|]
argument_list|)
condition|)
continue|continue;
comment|/* first part of the string must be version */
if|if
condition|(
name|strncasecmp
argument_list|(
name|ptr
argument_list|,
name|version_nm
operator|->
name|nm_name
argument_list|,
name|version_len
argument_list|)
condition|)
continue|continue;
name|LIST_FOREACH
argument_list|(
argument|subtype_nm
argument_list|,
argument|&version_nm->nm_sublist
argument_list|,
argument|nm_entry
argument_list|)
block|{
name|subtype_len
operator|=
name|strlen
argument_list|(
name|subtype_nm
operator|->
name|nm_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr_len
operator|!=
name|version_len
operator|+
name|subtype_len
operator|+
literal|1
condition|)
continue|continue;
comment|/* last part of the string must be subtype */
if|if
condition|(
name|strcasecmp
argument_list|(
operator|&
name|ptr
index|[
name|version_len
operator|+
literal|1
index|]
argument_list|,
name|subtype_nm
operator|->
name|nm_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Found it!! */
name|version
operator|=
name|version_nm
operator|->
name|nm_num
expr_stmt|;
name|subtype
operator|=
name|subtype_nm
operator|->
name|nm_num
expr_stmt|;
name|free
argument_list|(
name|wr_name
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
name|free
argument_list|(
name|wr_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_OSFP_NOMATCH
operator|)
return|;
block|}
name|found
label|:
name|PF_OSFP_PACK
argument_list|(
name|ret
argument_list|,
name|class
argument_list|,
name|version
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|PF_OSFP_NOMATCH
condition|)
block|{
name|PF_OSFP_UNPACK
argument_list|(
name|ret
argument_list|,
name|unp_class
argument_list|,
name|unp_version
argument_list|,
name|unp_subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|unp_class
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: fingerprint table overflowed "
literal|"classes\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_OSFP_NOMATCH
operator|)
return|;
block|}
if|if
condition|(
name|version
operator|!=
name|unp_version
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: fingerprint table overflowed "
literal|"versions\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_OSFP_NOMATCH
operator|)
return|;
block|}
if|if
condition|(
name|subtype
operator|!=
name|unp_subtype
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: fingerprint table overflowed "
literal|"subtypes\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_OSFP_NOMATCH
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
name|PF_OSFP_ANY
condition|)
block|{
comment|/* should never happen */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: fingerprint packed to 'any'\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_OSFP_NOMATCH
operator|)
return|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup a fingerprint name by ID */
end_comment

begin_function
name|char
modifier|*
name|pfctl_lookup_fingerprint
parameter_list|(
name|pf_osfp_t
name|fp
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|class
decl_stmt|,
name|version
decl_stmt|,
name|subtype
decl_stmt|;
name|struct
name|name_list
modifier|*
name|list
decl_stmt|;
name|struct
name|name_entry
modifier|*
name|nm
decl_stmt|;
name|char
modifier|*
name|class_name
decl_stmt|,
modifier|*
name|version_name
decl_stmt|,
modifier|*
name|subtype_name
decl_stmt|;
name|class_name
operator|=
name|version_name
operator|=
name|subtype_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|PF_OSFP_UNKNOWN
condition|)
block|{
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"unknown"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
if|if
condition|(
name|fp
operator|==
name|PF_OSFP_ANY
condition|)
block|{
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"any"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
name|PF_OSFP_UNPACK
argument_list|(
name|fp
argument_list|,
name|class
argument_list|,
name|version
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|>=
operator|(
literal|1
operator|<<
name|_FP_CLASS_BITS
operator|)
operator|||
name|version
operator|>=
operator|(
literal|1
operator|<<
name|_FP_VERSION_BITS
operator|)
operator|||
name|subtype
operator|>=
operator|(
literal|1
operator|<<
name|_FP_SUBTYPE_BITS
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"PF_OSFP_UNPACK(0x%x) failed!!"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"nomatch"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|nm
argument_list|,
argument|&classes
argument_list|,
argument|nm_entry
argument_list|)
block|{
if|if
condition|(
name|nm
operator|->
name|nm_num
operator|==
name|class
condition|)
block|{
name|class_name
operator|=
name|nm
operator|->
name|nm_name
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|PF_OSFP_ANY
condition|)
goto|goto
name|found
goto|;
name|list
operator|=
operator|&
name|nm
operator|->
name|nm_sublist
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|nm
argument_list|,
argument|list
argument_list|,
argument|nm_entry
argument_list|)
block|{
if|if
condition|(
name|nm
operator|->
name|nm_num
operator|==
name|version
condition|)
block|{
name|version_name
operator|=
name|nm
operator|->
name|nm_name
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|PF_OSFP_ANY
condition|)
goto|goto
name|found
goto|;
name|list
operator|=
operator|&
name|nm
operator|->
name|nm_sublist
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|nm
argument_list|,
argument|list
argument_list|,
argument|nm_entry
argument_list|)
block|{
if|if
condition|(
name|nm
operator|->
name|nm_num
operator|==
name|subtype
condition|)
block|{
name|subtype_name
operator|=
name|nm
operator|->
name|nm_name
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
comment|/* foreach subtype */
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"nomatch"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
block|}
comment|/* foreach version */
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"nomatch"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
block|}
comment|/* foreach class */
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"nomatch"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
name|found
label|:
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%s"
argument_list|,
name|class_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|version_name
condition|)
block|{
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|version_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtype_name
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|version_name
argument_list|,
literal|' '
argument_list|)
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|,
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|version_name
argument_list|,
literal|'.'
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|subtype_name
argument_list|)
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"."
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|subtype_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* lookup a name in a list */
end_comment

begin_function
name|struct
name|name_entry
modifier|*
name|lookup_name_list
parameter_list|(
name|struct
name|name_list
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|name_entry
modifier|*
name|nm
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|nm
argument_list|,
argument|list
argument_list|,
argument|nm_entry
argument_list|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|nm
operator|->
name|nm_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|nm
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|add_fingerprint
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|,
name|struct
name|pf_osfp_ioctl
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|pf_osfp_ioctl
name|fptmp
decl_stmt|;
name|struct
name|name_entry
modifier|*
name|nm_class
decl_stmt|,
modifier|*
name|nm_version
decl_stmt|,
modifier|*
name|nm_subtype
decl_stmt|;
name|int
name|class
decl_stmt|,
name|version
decl_stmt|,
name|subtype
decl_stmt|;
comment|/* We expand #-# or #.#-#.# version/subtypes into multiple fingerprints */
define|#
directive|define
name|EXPAND
parameter_list|(
name|field
parameter_list|)
value|do {						\ 	int _dot = -1, _start = -1, _end = -1, _i = 0;			\
comment|/* pick major version out of #.# */
value|\ 	if (isdigit(fp->field[_i])&& fp->field[_i+1] == '.') {		\ 		_dot = fp->field[_i] - '0';				\ 		_i += 2;						\ 	}								\ 	if (isdigit(fp->field[_i]))					\ 		_start = fp->field[_i++] - '0';				\ 	else								\ 		break;							\ 	if (isdigit(fp->field[_i]))					\ 		_start = (_start * 10) + fp->field[_i++] - '0';		\ 	if (fp->field[_i++] != '-')					\ 		break;							\ 	if (isdigit(fp->field[_i])&& fp->field[_i+1] == '.'&&		\ 	    fp->field[_i] - '0' == _dot)				\ 		_i += 2;						\ 	else if (_dot != -1)						\ 		break;							\ 	if (isdigit(fp->field[_i]))					\ 		_end = fp->field[_i++] - '0';				\ 	else								\ 		break;							\ 	if (isdigit(fp->field[_i]))					\ 		_end = (_end * 10) + fp->field[_i++] - '0';		\ 	if (isdigit(fp->field[_i]))					\ 		_end = (_end * 10) + fp->field[_i++] - '0';		\ 	if (fp->field[_i] != '\0')					\ 		break;							\ 	memcpy(&fptmp, fp, sizeof(fptmp));				\ 	for (;_start<= _end; _start++) {				\ 		memset(fptmp.field, 0, sizeof(fptmp.field));		\ 		fptmp.fp_os.fp_enflags |= PF_OSFP_EXPANDED;		\ 		if (_dot == -1)						\ 			snprintf(fptmp.field, sizeof(fptmp.field),	\ 			    "%d", _start);				\ 		    else						\ 			snprintf(fptmp.field, sizeof(fptmp.field),	\ 			    "%d.%d", _dot, _start);			\ 		add_fingerprint(dev, opts,&fptmp);			\ 	}								\ } while(0)
comment|/* We allow "#-#" as a version or subtype and we'll expand it */
name|EXPAND
argument_list|(
name|fp_os
operator|.
name|fp_version_nm
argument_list|)
expr_stmt|;
name|EXPAND
argument_list|(
name|fp_os
operator|.
name|fp_subtype_nm
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|fp
operator|->
name|fp_os
operator|.
name|fp_class_nm
argument_list|,
literal|"nomatch"
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"fingerprint class \"nomatch\" is reserved"
argument_list|)
expr_stmt|;
name|version
operator|=
name|PF_OSFP_ANY
expr_stmt|;
name|subtype
operator|=
name|PF_OSFP_ANY
expr_stmt|;
name|nm_class
operator|=
name|fingerprint_name_entry
argument_list|(
operator|&
name|classes
argument_list|,
name|fp
operator|->
name|fp_os
operator|.
name|fp_class_nm
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_class
operator|->
name|nm_num
operator|==
literal|0
condition|)
name|nm_class
operator|->
name|nm_num
operator|=
operator|++
name|class_count
expr_stmt|;
name|class
operator|=
name|nm_class
operator|->
name|nm_num
expr_stmt|;
name|nm_version
operator|=
name|fingerprint_name_entry
argument_list|(
operator|&
name|nm_class
operator|->
name|nm_sublist
argument_list|,
name|fp
operator|->
name|fp_os
operator|.
name|fp_version_nm
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_version
condition|)
block|{
if|if
condition|(
name|nm_version
operator|->
name|nm_num
operator|==
literal|0
condition|)
name|nm_version
operator|->
name|nm_num
operator|=
operator|++
name|nm_class
operator|->
name|nm_sublist_num
expr_stmt|;
name|version
operator|=
name|nm_version
operator|->
name|nm_num
expr_stmt|;
name|nm_subtype
operator|=
name|fingerprint_name_entry
argument_list|(
operator|&
name|nm_version
operator|->
name|nm_sublist
argument_list|,
name|fp
operator|->
name|fp_os
operator|.
name|fp_subtype_nm
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_subtype
condition|)
block|{
if|if
condition|(
name|nm_subtype
operator|->
name|nm_num
operator|==
literal|0
condition|)
name|nm_subtype
operator|->
name|nm_num
operator|=
operator|++
name|nm_version
operator|->
name|nm_sublist_num
expr_stmt|;
name|subtype
operator|=
name|nm_subtype
operator|->
name|nm_num
expr_stmt|;
block|}
block|}
name|DEBUG
argument_list|(
name|fp
argument_list|,
literal|"\tsignature %d:%d:%d %s"
argument_list|,
name|class
argument_list|,
name|version
argument_list|,
name|subtype
argument_list|,
name|print_ioctl
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|PF_OSFP_PACK
argument_list|(
name|fp
operator|->
name|fp_os
operator|.
name|fp_os
argument_list|,
name|class
argument_list|,
name|version
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
name|fingerprint_count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|FAKE_PF_KERNEL
comment|/* Linked to the sys/net/pf_osfp.c.  Call pf_osfp_add() */
if|if
condition|(
operator|(
name|errno
operator|=
name|pf_osfp_add
argument_list|(
name|fp
argument_list|)
operator|)
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
operator|&&
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCOSFPADD
argument_list|,
name|fp
argument_list|)
condition|)
endif|#
directive|endif
comment|/* FAKE_PF_KERNEL */
block|{
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
block|{
name|warn
argument_list|(
literal|"Duplicate signature for %s %s %s"
argument_list|,
name|fp
operator|->
name|fp_os
operator|.
name|fp_class_nm
argument_list|,
name|fp
operator|->
name|fp_os
operator|.
name|fp_version_nm
argument_list|,
name|fp
operator|->
name|fp_os
operator|.
name|fp_subtype_nm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCOSFPADD"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* import a fingerprint from the kernel */
end_comment

begin_function
name|void
name|import_fingerprint
parameter_list|(
name|struct
name|pf_osfp_ioctl
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|name_entry
modifier|*
name|nm_class
decl_stmt|,
modifier|*
name|nm_version
decl_stmt|,
modifier|*
name|nm_subtype
decl_stmt|;
name|int
name|class
decl_stmt|,
name|version
decl_stmt|,
name|subtype
decl_stmt|;
name|PF_OSFP_UNPACK
argument_list|(
name|fp
operator|->
name|fp_os
operator|.
name|fp_os
argument_list|,
name|class
argument_list|,
name|version
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
name|nm_class
operator|=
name|fingerprint_name_entry
argument_list|(
operator|&
name|classes
argument_list|,
name|fp
operator|->
name|fp_os
operator|.
name|fp_class_nm
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_class
operator|->
name|nm_num
operator|==
literal|0
condition|)
block|{
name|nm_class
operator|->
name|nm_num
operator|=
name|class
expr_stmt|;
name|class_count
operator|=
name|MAX
argument_list|(
name|class_count
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
name|nm_version
operator|=
name|fingerprint_name_entry
argument_list|(
operator|&
name|nm_class
operator|->
name|nm_sublist
argument_list|,
name|fp
operator|->
name|fp_os
operator|.
name|fp_version_nm
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_version
condition|)
block|{
if|if
condition|(
name|nm_version
operator|->
name|nm_num
operator|==
literal|0
condition|)
block|{
name|nm_version
operator|->
name|nm_num
operator|=
name|version
expr_stmt|;
name|nm_class
operator|->
name|nm_sublist_num
operator|=
name|MAX
argument_list|(
name|nm_class
operator|->
name|nm_sublist_num
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
name|nm_subtype
operator|=
name|fingerprint_name_entry
argument_list|(
operator|&
name|nm_version
operator|->
name|nm_sublist
argument_list|,
name|fp
operator|->
name|fp_os
operator|.
name|fp_subtype_nm
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_subtype
condition|)
block|{
if|if
condition|(
name|nm_subtype
operator|->
name|nm_num
operator|==
literal|0
condition|)
block|{
name|nm_subtype
operator|->
name|nm_num
operator|=
name|subtype
expr_stmt|;
name|nm_version
operator|->
name|nm_sublist_num
operator|=
name|MAX
argument_list|(
name|nm_version
operator|->
name|nm_sublist_num
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fingerprint_count
operator|++
expr_stmt|;
name|DEBUG
argument_list|(
name|fp
argument_list|,
literal|"import signature %d:%d:%d"
argument_list|,
name|class
argument_list|,
name|version
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find an entry for a fingerprints class/version/subtype */
end_comment

begin_function
name|struct
name|name_entry
modifier|*
name|fingerprint_name_entry
parameter_list|(
name|struct
name|name_list
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|name_entry
modifier|*
name|nm_entry
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|nm_entry
argument_list|,
argument|list
argument_list|,
argument|nm_entry
argument_list|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|nm_entry
operator|->
name|nm_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We'll move this to the front of the list later */
name|LIST_REMOVE
argument_list|(
name|nm_entry
argument_list|,
name|nm_entry
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nm_entry
operator|==
name|NULL
condition|)
block|{
name|nm_entry
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nm_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_entry
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|nm_entry
operator|->
name|nm_sublist
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|nm_entry
operator|->
name|nm_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|nm_entry
operator|->
name|nm_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
name|list
argument_list|,
name|nm_entry
argument_list|,
name|nm_entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|nm_entry
operator|)
return|;
block|}
end_function

begin_function
name|void
name|print_name_list
parameter_list|(
name|int
name|opts
parameter_list|,
name|struct
name|name_list
modifier|*
name|nml
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|char
name|newprefix
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|name_entry
modifier|*
name|nm
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|nm
argument_list|,
argument|nml
argument_list|,
argument|nm_entry
argument_list|)
block|{
name|snprintf
argument_list|(
name|newprefix
argument_list|,
sizeof|sizeof
argument_list|(
name|newprefix
argument_list|)
argument_list|,
literal|"%s%s\t"
argument_list|,
name|prefix
argument_list|,
name|nm
operator|->
name|nm_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|newprefix
argument_list|)
expr_stmt|;
name|print_name_list
argument_list|(
name|opts
argument_list|,
operator|&
name|nm
operator|->
name|nm_sublist
argument_list|,
name|newprefix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sort_name_list
parameter_list|(
name|int
name|opts
parameter_list|,
name|struct
name|name_list
modifier|*
name|nml
parameter_list|)
block|{
name|struct
name|name_list
name|new
decl_stmt|;
name|struct
name|name_entry
modifier|*
name|nm
decl_stmt|,
modifier|*
name|nmsearch
decl_stmt|,
modifier|*
name|nmlast
decl_stmt|;
comment|/* yes yes, it's a very slow sort.  so sue me */
name|LIST_INIT
argument_list|(
operator|&
name|new
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nm
operator|=
name|LIST_FIRST
argument_list|(
name|nml
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|nm
argument_list|,
name|nm_entry
argument_list|)
expr_stmt|;
name|nmlast
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|nmsearch
argument_list|,
argument|&new
argument_list|,
argument|nm_entry
argument_list|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|nmsearch
operator|->
name|nm_name
argument_list|,
name|nm
operator|->
name|nm_name
argument_list|)
operator|>
literal|0
condition|)
block|{
name|LIST_INSERT_BEFORE
argument_list|(
name|nmsearch
argument_list|,
name|nm
argument_list|,
name|nm_entry
argument_list|)
expr_stmt|;
break|break;
block|}
name|nmlast
operator|=
name|nmsearch
expr_stmt|;
block|}
if|if
condition|(
name|nmsearch
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nmlast
condition|)
name|LIST_INSERT_AFTER
argument_list|(
name|nmlast
argument_list|,
name|nm
argument_list|,
name|nm_entry
argument_list|)
expr_stmt|;
else|else
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|new
argument_list|,
name|nm
argument_list|,
name|nm_entry
argument_list|)
expr_stmt|;
block|}
name|sort_name_list
argument_list|(
name|opts
argument_list|,
operator|&
name|nm
operator|->
name|nm_sublist
argument_list|)
expr_stmt|;
block|}
name|nmlast
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|nm
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|new
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|nm
argument_list|,
name|nm_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmlast
operator|==
name|NULL
condition|)
name|LIST_INSERT_HEAD
argument_list|(
name|nml
argument_list|,
name|nm
argument_list|,
name|nm_entry
argument_list|)
expr_stmt|;
else|else
name|LIST_INSERT_AFTER
argument_list|(
name|nmlast
argument_list|,
name|nm
argument_list|,
name|nm_entry
argument_list|)
expr_stmt|;
name|nmlast
operator|=
name|nm
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* parse the next integer in a formatted config file line */
end_comment

begin_function
name|int
name|get_int
parameter_list|(
name|char
modifier|*
modifier|*
name|line
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|int
modifier|*
name|var
parameter_list|,
name|int
modifier|*
name|mod
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|max
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|int
name|fieldlen
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|field
decl_stmt|;
name|long
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mod
condition|)
operator|*
name|mod
operator|=
literal|0
expr_stmt|;
operator|*
name|var
operator|=
literal|0
expr_stmt|;
name|field
operator|=
name|get_field
argument_list|(
name|line
argument_list|,
name|len
argument_list|,
operator|&
name|fieldlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|fieldlen
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d empty %s\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|field
operator|==
literal|'%'
operator|||
operator|*
name|field
operator|==
literal|'S'
operator|||
operator|*
name|field
operator|==
literal|'T'
operator|||
operator|*
name|field
operator|==
literal|'*'
operator|)
operator|&&
name|fieldlen
operator|>=
literal|1
condition|)
block|{
switch|switch
condition|(
operator|*
name|field
condition|)
block|{
case|case
literal|'S'
case|:
if|if
condition|(
name|mod
operator|&&
operator|(
name|flags
operator|&
name|T_MSS
operator|)
condition|)
operator|*
name|mod
operator|=
name|T_MSS
expr_stmt|;
if|if
condition|(
name|fieldlen
operator|==
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|mod
operator|&&
operator|(
name|flags
operator|&
name|T_MTU
operator|)
condition|)
operator|*
name|mod
operator|=
name|T_MTU
expr_stmt|;
if|if
condition|(
name|fieldlen
operator|==
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|fieldlen
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d long '%c' %s\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
operator|*
name|field
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|mod
operator|&&
operator|(
name|flags
operator|&
name|T_DC
operator|)
condition|)
block|{
operator|*
name|mod
operator|=
name|T_DC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
literal|'%'
case|:
if|if
condition|(
name|mod
operator|&&
operator|(
name|flags
operator|&
name|T_MOD
operator|)
condition|)
operator|*
name|mod
operator|=
name|T_MOD
expr_stmt|;
if|if
condition|(
name|fieldlen
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d modulus %s must have a "
literal|"value\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
block|}
if|if
condition|(
name|mod
operator|==
name|NULL
operator|||
operator|*
name|mod
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d does not allow %c' %s\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
operator|*
name|field
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|fieldlen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|field
index|[
name|i
index|]
operator|<
literal|'0'
operator|||
name|field
index|[
name|i
index|]
operator|>
literal|'9'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d non-digit character in %s\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|val
operator|=
name|val
operator|*
literal|10
operator|+
name|field
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d %s overflowed\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|val
operator|>
name|max
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d %s value %ld> %d\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|name
argument_list|,
name|val
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|var
operator|=
operator|(
name|int
operator|)
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* parse the next string in a formatted config file line */
end_comment

begin_function
name|int
name|get_str
parameter_list|(
name|char
modifier|*
modifier|*
name|line
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|char
modifier|*
modifier|*
name|v
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|minlen
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|int
name|fieldlen
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|get_field
argument_list|(
name|line
argument_list|,
name|len
argument_list|,
operator|&
name|fieldlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|fieldlen
operator|<
name|minlen
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d too short %s\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|v
operator|=
name|malloc
argument_list|(
name|fieldlen
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"malloc()"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|*
name|v
argument_list|,
name|ptr
argument_list|,
name|fieldlen
argument_list|)
expr_stmt|;
operator|(
operator|*
name|v
operator|)
index|[
name|fieldlen
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse out the TCP opts */
end_comment

begin_function
name|int
name|get_tcpopts
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|lineno
parameter_list|,
specifier|const
name|char
modifier|*
name|tcpopts
parameter_list|,
name|pf_tcpopts_t
modifier|*
name|packed
parameter_list|,
name|int
modifier|*
name|optcnt
parameter_list|,
name|int
modifier|*
name|mss
parameter_list|,
name|int
modifier|*
name|mss_mod
parameter_list|,
name|int
modifier|*
name|wscale
parameter_list|,
name|int
modifier|*
name|wscale_mod
parameter_list|,
name|int
modifier|*
name|ts0
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|opt
decl_stmt|;
operator|*
name|packed
operator|=
literal|0
expr_stmt|;
operator|*
name|optcnt
operator|=
literal|0
expr_stmt|;
operator|*
name|wscale
operator|=
literal|0
expr_stmt|;
operator|*
name|wscale_mod
operator|=
name|T_DC
expr_stmt|;
operator|*
name|mss
operator|=
literal|0
expr_stmt|;
operator|*
name|mss_mod
operator|=
name|T_DC
expr_stmt|;
operator|*
name|ts0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|tcpopts
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tcpopts
index|[
name|i
index|]
operator|&&
operator|*
name|optcnt
operator|<
name|PF_OSFP_MAX_OPTS
condition|;
control|)
block|{
switch|switch
condition|(
operator|(
name|opt
operator|=
name|toupper
argument_list|(
name|tcpopts
index|[
name|i
operator|++
index|]
argument_list|)
operator|)
condition|)
block|{
case|case
literal|'N'
case|:
comment|/* FALLTHROUGH */
case|case
literal|'S'
case|:
operator|*
name|packed
operator|=
operator|(
operator|*
name|packed
operator|<<
name|PF_OSFP_TCPOPT_BITS
operator|)
operator||
operator|(
name|opt
operator|==
literal|'N'
condition|?
name|PF_OSFP_TCPOPT_NOP
else|:
name|PF_OSFP_TCPOPT_SACK
operator|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
comment|/* FALLTHROUGH */
case|case
literal|'M'
case|:
block|{
name|int
modifier|*
name|this_mod
decl_stmt|,
modifier|*
name|this
decl_stmt|;
if|if
condition|(
name|opt
operator|==
literal|'W'
condition|)
block|{
name|this
operator|=
name|wscale
expr_stmt|;
name|this_mod
operator|=
name|wscale_mod
expr_stmt|;
block|}
else|else
block|{
name|this
operator|=
name|mss
expr_stmt|;
name|this_mod
operator|=
name|mss_mod
expr_stmt|;
block|}
operator|*
name|this
operator|=
literal|0
expr_stmt|;
operator|*
name|this_mod
operator|=
literal|0
expr_stmt|;
operator|*
name|packed
operator|=
operator|(
operator|*
name|packed
operator|<<
name|PF_OSFP_TCPOPT_BITS
operator|)
operator||
operator|(
name|opt
operator|==
literal|'W'
condition|?
name|PF_OSFP_TCPOPT_WSCALE
else|:
name|PF_OSFP_TCPOPT_MSS
operator|)
expr_stmt|;
if|if
condition|(
name|tcpopts
index|[
name|i
index|]
operator|==
literal|'*'
operator|&&
operator|(
name|tcpopts
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|tcpopts
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|','
operator|)
condition|)
block|{
operator|*
name|this_mod
operator|=
name|T_DC
expr_stmt|;
name|i
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tcpopts
index|[
name|i
index|]
operator|==
literal|'%'
condition|)
block|{
operator|*
name|this_mod
operator|=
name|T_MOD
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|tcpopts
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d unknown "
literal|"character '%c' in %c TCP opt\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|tcpopts
index|[
name|i
index|]
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|this
operator|=
operator|(
operator|*
name|this
operator|*
literal|10
operator|)
operator|+
name|tcpopts
index|[
name|i
operator|++
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|tcpopts
index|[
name|i
index|]
operator|!=
literal|','
operator|&&
name|tcpopts
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|)
do|;
break|break;
block|}
case|case
literal|'T'
case|:
if|if
condition|(
name|tcpopts
index|[
name|i
index|]
operator|==
literal|'0'
condition|)
block|{
operator|*
name|ts0
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
operator|*
name|packed
operator|=
operator|(
operator|*
name|packed
operator|<<
name|PF_OSFP_TCPOPT_BITS
operator|)
operator||
name|PF_OSFP_TCPOPT_TS
expr_stmt|;
break|break;
block|}
operator|(
operator|*
name|optcnt
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|tcpopts
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|tcpopts
index|[
name|i
index|]
operator|!=
literal|','
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d unknown option to %c TCP opt\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* rip the next field ouf of a formatted config file line */
end_comment

begin_function
name|char
modifier|*
name|get_field
parameter_list|(
name|char
modifier|*
modifier|*
name|line
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|int
modifier|*
name|fieldlen
parameter_list|)
block|{
name|char
modifier|*
name|ret
decl_stmt|,
modifier|*
name|ptr
init|=
operator|*
name|line
decl_stmt|;
name|size_t
name|plen
init|=
operator|*
name|len
decl_stmt|;
while|while
condition|(
name|plen
operator|&&
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
block|{
name|plen
operator|--
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
name|ret
operator|=
name|ptr
expr_stmt|;
operator|*
name|fieldlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|plen
operator|>
literal|0
operator|&&
operator|*
name|ptr
operator|!=
literal|':'
condition|;
name|plen
operator|--
operator|,
name|ptr
operator|++
control|)
operator|(
operator|*
name|fieldlen
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|plen
condition|)
block|{
operator|*
name|line
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
operator|*
name|len
operator|=
name|plen
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|fieldlen
operator|&&
name|isspace
argument_list|(
name|ret
index|[
operator|*
name|fieldlen
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|(
operator|*
name|fieldlen
operator|)
operator|--
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|print_ioctl
parameter_list|(
name|struct
name|pf_osfp_ioctl
modifier|*
name|fp
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|tmp
index|[
literal|32
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|opt
decl_stmt|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fp_flags
operator|&
name|PF_OSFP_WSIZE_DC
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"*"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|fp_flags
operator|&
name|PF_OSFP_WSIZE_MSS
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"S"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|fp_flags
operator|&
name|PF_OSFP_WSIZE_MTU
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"T"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fp
operator|->
name|fp_flags
operator|&
name|PF_OSFP_WSIZE_MOD
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"%"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|fp
operator|->
name|fp_wsize
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|fp
operator|->
name|fp_ttl
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fp_flags
operator|&
name|PF_OSFP_DF
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"1"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"0"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fp_flags
operator|&
name|PF_OSFP_PSIZE_DC
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"*"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fp
operator|->
name|fp_flags
operator|&
name|PF_OSFP_PSIZE_MOD
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"%"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|fp
operator|->
name|fp_psize
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fp_optcnt
operator|==
literal|0
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"."
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|fp
operator|->
name|fp_optcnt
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|opt
operator|=
name|fp
operator|->
name|fp_tcpopts
operator|>>
operator|(
name|i
operator|*
name|PF_OSFP_TCPOPT_BITS
operator|)
expr_stmt|;
name|opt
operator|&=
operator|(
literal|1
operator|<<
name|PF_OSFP_TCPOPT_BITS
operator|)
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|PF_OSFP_TCPOPT_NOP
case|:
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"N"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_OSFP_TCPOPT_SACK
case|:
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"S"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_OSFP_TCPOPT_TS
case|:
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"T"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fp_flags
operator|&
name|PF_OSFP_TS0
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"0"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_OSFP_TCPOPT_MSS
case|:
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"M"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fp_flags
operator|&
name|PF_OSFP_MSS_DC
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"*"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fp
operator|->
name|fp_flags
operator|&
name|PF_OSFP_MSS_MOD
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"%"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|fp
operator|->
name|fp_mss
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PF_OSFP_TCPOPT_WSCALE
case|:
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"W"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fp_flags
operator|&
name|PF_OSFP_WSCALE_DC
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"*"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fp
operator|->
name|fp_flags
operator|&
name|PF_OSFP_WSCALE_MOD
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"%"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|fp
operator|->
name|fp_wscale
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|","
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|fp
operator|->
name|fp_os
operator|.
name|fp_class_nm
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|fp
operator|->
name|fp_os
operator|.
name|fp_version_nm
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|fp
operator|->
name|fp_os
operator|.
name|fp_subtype_nm
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"TcpOpts %d 0x%llx"
argument_list|,
name|fp
operator|->
name|fp_optcnt
argument_list|,
operator|(
name|long
name|long
name|int
operator|)
name|fp
operator|->
name|fp_tcpopts
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

end_unit

