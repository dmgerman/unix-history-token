begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*	$NetBSD: rcorder.c,v 1.7 2000/08/04 07:33:55 enami Exp $	*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Copyright (c) 1998, 1999 Matthew R. Green  * All rights reserved.  * Copyright (c) 1998  * 	Perry E. Metzger.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed for the NetBSD Project  *	by Perry E. Metzger.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_include
include|#
directive|include
file|"ealloc.h"
end_include

begin_include
include|#
directive|include
file|"sprite.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|args
parameter_list|)
value|if (debug) { fflush(stdout); fprintf args; }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|args
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|REQUIRE_STR
value|"# REQUIRE:"
end_define

begin_define
define|#
directive|define
name|REQUIRE_LEN
value|(sizeof(REQUIRE_STR) - 1)
end_define

begin_define
define|#
directive|define
name|REQUIRES_STR
value|"# REQUIRES:"
end_define

begin_define
define|#
directive|define
name|REQUIRES_LEN
value|(sizeof(REQUIRES_STR) - 1)
end_define

begin_define
define|#
directive|define
name|PROVIDE_STR
value|"# PROVIDE:"
end_define

begin_define
define|#
directive|define
name|PROVIDE_LEN
value|(sizeof(PROVIDE_STR) - 1)
end_define

begin_define
define|#
directive|define
name|PROVIDES_STR
value|"# PROVIDES:"
end_define

begin_define
define|#
directive|define
name|PROVIDES_LEN
value|(sizeof(PROVIDES_STR) - 1)
end_define

begin_define
define|#
directive|define
name|BEFORE_STR
value|"# BEFORE:"
end_define

begin_define
define|#
directive|define
name|BEFORE_LEN
value|(sizeof(BEFORE_STR) - 1)
end_define

begin_define
define|#
directive|define
name|KEYWORD_STR
value|"# KEYWORD:"
end_define

begin_define
define|#
directive|define
name|KEYWORD_LEN
value|(sizeof(KEYWORD_STR) - 1)
end_define

begin_define
define|#
directive|define
name|KEYWORDS_STR
value|"# KEYWORDS:"
end_define

begin_define
define|#
directive|define
name|KEYWORDS_LEN
value|(sizeof(KEYWORDS_STR) - 1)
end_define

begin_decl_stmt
name|int
name|exit_code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|file_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|file_list
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|int
name|bool
typedef|;
end_typedef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_typedef
typedef|typedef
name|bool
name|flag
typedef|;
end_typedef

begin_define
define|#
directive|define
name|SET
value|TRUE
end_define

begin_define
define|#
directive|define
name|RESET
value|FALSE
end_define

begin_decl_stmt
name|Hash_Table
name|provide_hash_s
decl_stmt|,
modifier|*
name|provide_hash
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|struct
name|provnode
name|provnode
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|filenode
name|filenode
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|f_provnode
name|f_provnode
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|f_reqnode
name|f_reqnode
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|strnodelist
name|strnodelist
typedef|;
end_typedef

begin_struct
struct|struct
name|provnode
block|{
name|flag
name|head
decl_stmt|;
name|flag
name|in_progress
decl_stmt|;
name|filenode
modifier|*
name|fnode
decl_stmt|;
name|provnode
modifier|*
name|next
decl_stmt|,
modifier|*
name|last
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|f_provnode
block|{
name|provnode
modifier|*
name|pnode
decl_stmt|;
name|f_provnode
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|f_reqnode
block|{
name|Hash_Entry
modifier|*
name|entry
decl_stmt|;
name|f_reqnode
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|strnodelist
block|{
name|filenode
modifier|*
name|node
decl_stmt|;
name|strnodelist
modifier|*
name|next
decl_stmt|;
name|char
name|s
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|filenode
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|flag
name|in_progress
decl_stmt|;
name|filenode
modifier|*
name|next
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|f_reqnode
modifier|*
name|req_list
decl_stmt|;
name|f_provnode
modifier|*
name|prov_list
decl_stmt|;
name|strnodelist
modifier|*
name|keyword_list
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|filenode
name|fn_head_s
decl_stmt|,
modifier|*
name|fn_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|strnodelist
modifier|*
name|bl_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|strnodelist
modifier|*
name|keep_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|strnodelist
modifier|*
name|skip_list
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|do_file
parameter_list|(
name|filenode
modifier|*
name|fnode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|strnode_add
parameter_list|(
name|strnodelist
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|filenode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|skip_ok
parameter_list|(
name|filenode
modifier|*
name|fnode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|keep_ok
parameter_list|(
name|filenode
modifier|*
name|fnode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|satisfy_req
parameter_list|(
name|f_reqnode
modifier|*
name|rnode
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|crunch_file
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|parse_require
parameter_list|(
name|filenode
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|parse_provide
parameter_list|(
name|filenode
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|parse_before
parameter_list|(
name|filenode
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|parse_keywords
parameter_list|(
name|filenode
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|filenode
modifier|*
name|filenode_new
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add_require
parameter_list|(
name|filenode
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add_provide
parameter_list|(
name|filenode
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add_before
parameter_list|(
name|filenode
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add_keyword
parameter_list|(
name|filenode
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert_before
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Hash_Entry
modifier|*
name|make_fake_provision
parameter_list|(
name|filenode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|crunch_all_files
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|initialize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|generate_ordering
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"dk:s:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|warnx
argument_list|(
literal|"debugging not compiled in, -d ignored"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'k'
case|:
name|strnode_add
argument_list|(
operator|&
name|keep_list
argument_list|,
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|strnode_add
argument_list|(
operator|&
name|skip_list
argument_list|,
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* XXX should crunch it? */
break|break;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|file_count
operator|=
name|argc
expr_stmt|;
name|file_list
operator|=
name|argv
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"parse_args\n"
operator|)
argument_list|)
expr_stmt|;
name|initialize
argument_list|()
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"initialize\n"
operator|)
argument_list|)
expr_stmt|;
name|crunch_all_files
argument_list|()
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"crunch_all_files\n"
operator|)
argument_list|)
expr_stmt|;
name|generate_ordering
argument_list|()
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"generate_ordering\n"
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * initialise various variables.  */
end_comment

begin_function
name|void
name|initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|fn_head
operator|=
operator|&
name|fn_head_s
expr_stmt|;
name|provide_hash
operator|=
operator|&
name|provide_hash_s
expr_stmt|;
name|Hash_InitTable
argument_list|(
name|provide_hash
argument_list|,
name|file_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* generic function to insert a new strnodelist element */
end_comment

begin_function
name|void
name|strnode_add
parameter_list|(
name|strnodelist
modifier|*
modifier|*
name|listp
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|filenode
modifier|*
name|fnode
parameter_list|)
block|{
name|strnodelist
modifier|*
name|ent
decl_stmt|;
name|ent
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|ent
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ent
operator|->
name|node
operator|=
name|fnode
expr_stmt|;
name|strcpy
argument_list|(
name|ent
operator|->
name|s
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ent
operator|->
name|next
operator|=
operator|*
name|listp
expr_stmt|;
operator|*
name|listp
operator|=
name|ent
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * below are the functions that deal with creating the lists  * from the filename's given and the dependancies and provisions  * in each of these files.  no ordering or checking is done here.  */
end_comment

begin_comment
comment|/*  * we have a new filename, create a new filenode structure.  * fill in the bits, and put it in the filenode linked list  */
end_comment

begin_function
name|filenode
modifier|*
name|filenode_new
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|filenode
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|filename
operator|=
name|estrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|temp
operator|->
name|req_list
operator|=
name|NULL
expr_stmt|;
name|temp
operator|->
name|prov_list
operator|=
name|NULL
expr_stmt|;
name|temp
operator|->
name|keyword_list
operator|=
name|NULL
expr_stmt|;
name|temp
operator|->
name|in_progress
operator|=
name|RESET
expr_stmt|;
comment|/* 	 * link the filenode into the list of filenodes. 	 * note that the double linking means we can delete a 	 * filenode without searching for where it belongs. 	 */
name|temp
operator|->
name|next
operator|=
name|fn_head
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|temp
operator|->
name|next
operator|->
name|last
operator|=
name|temp
expr_stmt|;
name|temp
operator|->
name|last
operator|=
name|fn_head
expr_stmt|;
name|fn_head
operator|->
name|next
operator|=
name|temp
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * add a requirement to a filenode.  */
end_comment

begin_function
name|void
name|add_require
parameter_list|(
name|filenode
modifier|*
name|fnode
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|Hash_Entry
modifier|*
name|entry
decl_stmt|;
name|f_reqnode
modifier|*
name|rnode
decl_stmt|;
name|int
name|new
decl_stmt|;
name|entry
operator|=
name|Hash_CreateEntry
argument_list|(
name|provide_hash
argument_list|,
name|s
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
name|Hash_SetValue
argument_list|(
name|entry
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rnode
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rnode
argument_list|)
argument_list|)
expr_stmt|;
name|rnode
operator|->
name|entry
operator|=
name|entry
expr_stmt|;
name|rnode
operator|->
name|next
operator|=
name|fnode
operator|->
name|req_list
expr_stmt|;
name|fnode
operator|->
name|req_list
operator|=
name|rnode
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * add a provision to a filenode.  if this provision doesn't  * have a head node, create one here.  */
end_comment

begin_function
name|void
name|add_provide
parameter_list|(
name|filenode
modifier|*
name|fnode
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|Hash_Entry
modifier|*
name|entry
decl_stmt|;
name|f_provnode
modifier|*
name|f_pnode
decl_stmt|;
name|provnode
modifier|*
name|pnode
decl_stmt|,
modifier|*
name|head
decl_stmt|;
name|int
name|new
decl_stmt|;
name|entry
operator|=
name|Hash_CreateEntry
argument_list|(
name|provide_hash
argument_list|,
name|s
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
name|head
operator|=
name|Hash_GetValue
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* create a head node if necessary. */
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
name|head
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|->
name|head
operator|=
name|SET
expr_stmt|;
name|head
operator|->
name|in_progress
operator|=
name|RESET
expr_stmt|;
name|head
operator|->
name|fnode
operator|=
name|NULL
expr_stmt|;
name|head
operator|->
name|last
operator|=
name|head
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|Hash_SetValue
argument_list|(
name|entry
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* 	 * Don't warn about this.  We want to be able to support 	 * scripts that do two complex things: 	 * 	 *	- Two independent scripts which both provide the 	 *	  same thing.  Both scripts must be executed in 	 *	  any order to meet the barrier.  An example: 	 * 	 *		Script 1: 	 * 	 *			PROVIDE: mail 	 *			REQUIRE: LOGIN 	 * 	 *		Script 2: 	 * 	 *			PROVIDE: mail 	 *			REQUIRE: LOGIN 	 * 	 * 	- Two interdependent scripts which both provide the 	 *	  same thing.  Both scripts must be executed in 	 *	  graph order to meet the barrier.  An example: 	 * 	 *		Script 1: 	 * 	 *			PROVIDE: nameservice dnscache 	 *			REQUIRE: SERVERS 	 * 	 *		Script 2: 	 * 	 *			PROVIDE: nameservice nscd 	 *			REQUIRE: dnscache 	 */
block|else if (new == 0) { 		warnx("file `%s' provides `%s'.", fnode->filename, s); 		warnx("\tpreviously seen in `%s'.", 		    head->next->fnode->filename); 	}
endif|#
directive|endif
name|pnode
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pnode
argument_list|)
argument_list|)
expr_stmt|;
name|pnode
operator|->
name|head
operator|=
name|RESET
expr_stmt|;
name|pnode
operator|->
name|in_progress
operator|=
name|RESET
expr_stmt|;
name|pnode
operator|->
name|fnode
operator|=
name|fnode
expr_stmt|;
name|pnode
operator|->
name|next
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|pnode
operator|->
name|last
operator|=
name|head
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|pnode
expr_stmt|;
if|if
condition|(
name|pnode
operator|->
name|next
operator|!=
name|NULL
condition|)
name|pnode
operator|->
name|next
operator|->
name|last
operator|=
name|pnode
expr_stmt|;
name|f_pnode
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|f_pnode
argument_list|)
argument_list|)
expr_stmt|;
name|f_pnode
operator|->
name|pnode
operator|=
name|pnode
expr_stmt|;
name|f_pnode
operator|->
name|next
operator|=
name|fnode
operator|->
name|prov_list
expr_stmt|;
name|fnode
operator|->
name|prov_list
operator|=
name|f_pnode
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * put the BEFORE: lines to a list and handle them later.  */
end_comment

begin_function
name|void
name|add_before
parameter_list|(
name|filenode
modifier|*
name|fnode
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|strnodelist
modifier|*
name|bf_ent
decl_stmt|;
name|bf_ent
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|bf_ent
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|bf_ent
operator|->
name|node
operator|=
name|fnode
expr_stmt|;
name|strcpy
argument_list|(
name|bf_ent
operator|->
name|s
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|bf_ent
operator|->
name|next
operator|=
name|bl_list
expr_stmt|;
name|bl_list
operator|=
name|bf_ent
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * add a key to a filenode.  */
end_comment

begin_function
name|void
name|add_keyword
parameter_list|(
name|filenode
modifier|*
name|fnode
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|strnode_add
argument_list|(
operator|&
name|fnode
operator|->
name|keyword_list
argument_list|,
name|s
argument_list|,
name|fnode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * loop over the rest of a REQUIRE line, giving each word to  * add_require() to do the real work.  */
end_comment

begin_function
name|void
name|parse_require
parameter_list|(
name|filenode
modifier|*
name|node
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|strsep
argument_list|(
operator|&
name|buffer
argument_list|,
literal|" \t\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|add_require
argument_list|(
name|node
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * loop over the rest of a PROVIDE line, giving each word to  * add_provide() to do the real work.  */
end_comment

begin_function
name|void
name|parse_provide
parameter_list|(
name|filenode
modifier|*
name|node
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|strsep
argument_list|(
operator|&
name|buffer
argument_list|,
literal|" \t\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|add_provide
argument_list|(
name|node
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * loop over the rest of a BEFORE line, giving each word to  * add_before() to do the real work.  */
end_comment

begin_function
name|void
name|parse_before
parameter_list|(
name|filenode
modifier|*
name|node
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|strsep
argument_list|(
operator|&
name|buffer
argument_list|,
literal|" \t\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|add_before
argument_list|(
name|node
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * loop over the rest of a KEYWORD line, giving each word to  * add_keyword() to do the real work.  */
end_comment

begin_function
name|void
name|parse_keywords
parameter_list|(
name|filenode
modifier|*
name|node
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|strsep
argument_list|(
operator|&
name|buffer
argument_list|,
literal|" \t\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|add_keyword
argument_list|(
name|node
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * given a file name, create a filenode for it, read in lines looking  * for provision and requirement lines, building the graphs as needed.  */
end_comment

begin_function
name|void
name|crunch_file
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|require_flag
decl_stmt|,
name|provide_flag
decl_stmt|,
name|before_flag
decl_stmt|,
name|keywords_flag
decl_stmt|;
enum|enum
block|{
name|BEFORE_PARSING
block|,
name|PARSING
block|,
name|PARSING_DONE
block|}
name|state
enum|;
name|filenode
modifier|*
name|node
decl_stmt|;
name|char
name|delims
index|[
literal|3
index|]
init|=
block|{
literal|'\\'
block|,
literal|'\\'
block|,
literal|'\0'
block|}
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"could not open %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"could not stat %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|warnx("%s is not a file", filename);
endif|#
directive|endif
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
name|node
operator|=
name|filenode_new
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* 	 * we don't care about length, line number, don't want # for comments, 	 * and have no flags. 	 */
for|for
control|(
name|state
operator|=
name|BEFORE_PARSING
init|;
name|state
operator|!=
name|PARSING_DONE
operator|&&
operator|(
name|buf
operator|=
name|fparseln
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|delims
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|free
argument_list|(
name|buf
argument_list|)
control|)
block|{
name|require_flag
operator|=
name|provide_flag
operator|=
name|before_flag
operator|=
name|keywords_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|REQUIRE_STR
argument_list|,
name|buf
argument_list|,
name|REQUIRE_LEN
argument_list|)
operator|==
literal|0
condition|)
name|require_flag
operator|=
name|REQUIRE_LEN
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|REQUIRES_STR
argument_list|,
name|buf
argument_list|,
name|REQUIRES_LEN
argument_list|)
operator|==
literal|0
condition|)
name|require_flag
operator|=
name|REQUIRES_LEN
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|PROVIDE_STR
argument_list|,
name|buf
argument_list|,
name|PROVIDE_LEN
argument_list|)
operator|==
literal|0
condition|)
name|provide_flag
operator|=
name|PROVIDE_LEN
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|PROVIDES_STR
argument_list|,
name|buf
argument_list|,
name|PROVIDES_LEN
argument_list|)
operator|==
literal|0
condition|)
name|provide_flag
operator|=
name|PROVIDES_LEN
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|BEFORE_STR
argument_list|,
name|buf
argument_list|,
name|BEFORE_LEN
argument_list|)
operator|==
literal|0
condition|)
name|before_flag
operator|=
name|BEFORE_LEN
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|KEYWORD_STR
argument_list|,
name|buf
argument_list|,
name|KEYWORD_LEN
argument_list|)
operator|==
literal|0
condition|)
name|keywords_flag
operator|=
name|KEYWORD_LEN
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|KEYWORDS_STR
argument_list|,
name|buf
argument_list|,
name|KEYWORDS_LEN
argument_list|)
operator|==
literal|0
condition|)
name|keywords_flag
operator|=
name|KEYWORDS_LEN
expr_stmt|;
else|else
block|{
if|if
condition|(
name|state
operator|==
name|PARSING
condition|)
name|state
operator|=
name|PARSING_DONE
expr_stmt|;
continue|continue;
block|}
name|state
operator|=
name|PARSING
expr_stmt|;
if|if
condition|(
name|require_flag
condition|)
name|parse_require
argument_list|(
name|node
argument_list|,
name|buf
operator|+
name|require_flag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|provide_flag
condition|)
name|parse_provide
argument_list|(
name|node
argument_list|,
name|buf
operator|+
name|provide_flag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|before_flag
condition|)
name|parse_before
argument_list|(
name|node
argument_list|,
name|buf
operator|+
name|before_flag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|keywords_flag
condition|)
name|parse_keywords
argument_list|(
name|node
argument_list|,
name|buf
operator|+
name|keywords_flag
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hash_Entry
modifier|*
name|make_fake_provision
parameter_list|(
name|filenode
modifier|*
name|node
parameter_list|)
block|{
name|Hash_Entry
modifier|*
name|entry
decl_stmt|;
name|f_provnode
modifier|*
name|f_pnode
decl_stmt|;
name|provnode
modifier|*
name|head
decl_stmt|,
modifier|*
name|pnode
decl_stmt|;
specifier|static
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|new
decl_stmt|;
name|char
name|buffer
index|[
literal|30
index|]
decl_stmt|;
do|do
block|{
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
literal|"fake_prov_%08d"
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|entry
operator|=
name|Hash_CreateEntry
argument_list|(
name|provide_hash
argument_list|,
name|buffer
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|new
operator|==
literal|0
condition|)
do|;
name|head
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|->
name|head
operator|=
name|SET
expr_stmt|;
name|head
operator|->
name|in_progress
operator|=
name|RESET
expr_stmt|;
name|head
operator|->
name|fnode
operator|=
name|NULL
expr_stmt|;
name|head
operator|->
name|last
operator|=
name|head
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|Hash_SetValue
argument_list|(
name|entry
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|pnode
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pnode
argument_list|)
argument_list|)
expr_stmt|;
name|pnode
operator|->
name|head
operator|=
name|RESET
expr_stmt|;
name|pnode
operator|->
name|in_progress
operator|=
name|RESET
expr_stmt|;
name|pnode
operator|->
name|fnode
operator|=
name|node
expr_stmt|;
name|pnode
operator|->
name|next
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|pnode
operator|->
name|last
operator|=
name|head
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|pnode
expr_stmt|;
if|if
condition|(
name|pnode
operator|->
name|next
operator|!=
name|NULL
condition|)
name|pnode
operator|->
name|next
operator|->
name|last
operator|=
name|pnode
expr_stmt|;
name|f_pnode
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|f_pnode
argument_list|)
argument_list|)
expr_stmt|;
name|f_pnode
operator|->
name|pnode
operator|=
name|pnode
expr_stmt|;
name|f_pnode
operator|->
name|next
operator|=
name|node
operator|->
name|prov_list
expr_stmt|;
name|node
operator|->
name|prov_list
operator|=
name|f_pnode
expr_stmt|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * go through the BEFORE list, inserting requirements into the graph(s)  * as required.  in the before list, for each entry B, we have a file F  * and a string S.  we create a "fake" provision (P) that F provides.  * for each entry in the provision list for S, add a requirement to  * that provisions filenode for P.  */
end_comment

begin_function
name|void
name|insert_before
parameter_list|(
name|void
parameter_list|)
block|{
name|Hash_Entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|fake_prov_entry
decl_stmt|;
name|provnode
modifier|*
name|pnode
decl_stmt|;
name|f_reqnode
modifier|*
name|rnode
decl_stmt|;
name|strnodelist
modifier|*
name|bl
decl_stmt|;
name|int
name|new
decl_stmt|;
while|while
condition|(
name|bl_list
operator|!=
name|NULL
condition|)
block|{
name|bl
operator|=
name|bl_list
operator|->
name|next
expr_stmt|;
name|fake_prov_entry
operator|=
name|make_fake_provision
argument_list|(
name|bl_list
operator|->
name|node
argument_list|)
expr_stmt|;
name|entry
operator|=
name|Hash_CreateEntry
argument_list|(
name|provide_hash
argument_list|,
name|bl_list
operator|->
name|s
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|1
condition|)
name|warnx
argument_list|(
literal|"file `%s' is before unknown provision `%s'"
argument_list|,
name|bl_list
operator|->
name|node
operator|->
name|filename
argument_list|,
name|bl_list
operator|->
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|pnode
operator|=
name|Hash_GetValue
argument_list|(
name|entry
argument_list|)
init|;
name|pnode
condition|;
name|pnode
operator|=
name|pnode
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pnode
operator|->
name|head
condition|)
continue|continue;
name|rnode
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rnode
argument_list|)
argument_list|)
expr_stmt|;
name|rnode
operator|->
name|entry
operator|=
name|fake_prov_entry
expr_stmt|;
name|rnode
operator|->
name|next
operator|=
name|pnode
operator|->
name|fnode
operator|->
name|req_list
expr_stmt|;
name|pnode
operator|->
name|fnode
operator|->
name|req_list
operator|=
name|rnode
expr_stmt|;
block|}
name|free
argument_list|(
name|bl_list
argument_list|)
expr_stmt|;
name|bl_list
operator|=
name|bl
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * loop over all the files calling crunch_file() on them to do the  * real work.  after we have built all the nodes, insert the BEFORE:  * lines into graph(s).  */
end_comment

begin_function
name|void
name|crunch_all_files
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file_count
condition|;
name|i
operator|++
control|)
name|crunch_file
argument_list|(
name|file_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|insert_before
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * below are the functions that traverse the graphs we have built  * finding out the desired ordering, printing each file in turn.  * if missing requirements, or cyclic graphs are detected, a  * warning will be issued, and we will continue on..  */
end_comment

begin_comment
comment|/*  * given a requirement node (in a filename) we attempt to satisfy it.  * we do some sanity checking first, to ensure that we have providers,  * aren't already satisfied and aren't already being satisfied (ie,  * cyclic).  if we pass all this, we loop over the provision list  * calling do_file() (enter recursion) for each filenode in this  * provision.  */
end_comment

begin_function
name|void
name|satisfy_req
parameter_list|(
name|f_reqnode
modifier|*
name|rnode
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|Hash_Entry
modifier|*
name|entry
decl_stmt|;
name|provnode
modifier|*
name|head
decl_stmt|;
name|entry
operator|=
name|rnode
operator|->
name|entry
expr_stmt|;
name|head
operator|=
name|Hash_GetValue
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"requirement `%s' in file `%s' has no providers."
argument_list|,
name|Hash_GetKey
argument_list|(
name|entry
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit_code
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* return if the requirement is already satisfied. */
if|if
condition|(
name|head
operator|->
name|next
operator|==
name|NULL
condition|)
return|return;
comment|/*  	 * if list is marked as in progress, 	 *	print that there is a circular dependency on it and abort 	 */
if|if
condition|(
name|head
operator|->
name|in_progress
operator|==
name|SET
condition|)
block|{
name|warnx
argument_list|(
literal|"Circular dependency on provision `%s' in file `%s'."
argument_list|,
name|Hash_GetKey
argument_list|(
name|entry
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit_code
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|head
operator|->
name|in_progress
operator|=
name|SET
expr_stmt|;
comment|/* 	 * while provision_list is not empty 	 *	do_file(first_member_of(provision_list)); 	 */
while|while
condition|(
name|head
operator|->
name|next
operator|!=
name|NULL
condition|)
name|do_file
argument_list|(
name|head
operator|->
name|next
operator|->
name|fnode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|skip_ok
parameter_list|(
name|filenode
modifier|*
name|fnode
parameter_list|)
block|{
name|strnodelist
modifier|*
name|s
decl_stmt|;
name|strnodelist
modifier|*
name|k
decl_stmt|;
for|for
control|(
name|s
operator|=
name|skip_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
for|for
control|(
name|k
operator|=
name|fnode
operator|->
name|keyword_list
init|;
name|k
condition|;
name|k
operator|=
name|k
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|k
operator|->
name|s
argument_list|,
name|s
operator|->
name|s
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|keep_ok
parameter_list|(
name|filenode
modifier|*
name|fnode
parameter_list|)
block|{
name|strnodelist
modifier|*
name|s
decl_stmt|;
name|strnodelist
modifier|*
name|k
decl_stmt|;
for|for
control|(
name|s
operator|=
name|keep_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
for|for
control|(
name|k
operator|=
name|fnode
operator|->
name|keyword_list
init|;
name|k
condition|;
name|k
operator|=
name|k
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|k
operator|->
name|s
argument_list|,
name|s
operator|->
name|s
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* an empty keep_list means every one */
return|return
operator|(
operator|!
name|keep_list
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * given a filenode, we ensure we are not a cyclic graph.  if this  * is ok, we loop over the filenodes requirements, calling satisfy_req()  * for each of them.. once we have done this, remove this filenode  * from each provision table, as we are now done.  *  * NOTE: do_file() is called recursively from several places and cannot  * safely free() anything related to items that may be recursed on.  * Circular dependancies will cause problems if we do.  */
end_comment

begin_function
name|void
name|do_file
parameter_list|(
name|filenode
modifier|*
name|fnode
parameter_list|)
block|{
name|f_reqnode
modifier|*
name|r
decl_stmt|,
modifier|*
name|r_tmp
decl_stmt|;
name|f_provnode
modifier|*
name|p
decl_stmt|,
modifier|*
name|p_tmp
decl_stmt|;
name|provnode
modifier|*
name|pnode
decl_stmt|;
name|int
name|was_set
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"do_file on %s.\n"
operator|,
name|fnode
operator|->
name|filename
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * if fnode is marked as in progress, 	 *	 print that fnode; is circularly depended upon and abort. 	 */
if|if
condition|(
name|fnode
operator|->
name|in_progress
operator|==
name|SET
condition|)
block|{
name|warnx
argument_list|(
literal|"Circular dependency on file `%s'."
argument_list|,
name|fnode
operator|->
name|filename
argument_list|)
expr_stmt|;
name|was_set
operator|=
name|exit_code
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|was_set
operator|=
literal|0
expr_stmt|;
comment|/* mark fnode */
name|fnode
operator|->
name|in_progress
operator|=
name|SET
expr_stmt|;
comment|/* 	 * for each requirement of fnode -> r 	 *	satisfy_req(r, filename) 	 */
name|r
operator|=
name|fnode
operator|->
name|req_list
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
name|r_tmp
operator|=
name|r
expr_stmt|;
name|satisfy_req
argument_list|(
name|r
argument_list|,
name|fnode
operator|->
name|filename
argument_list|)
expr_stmt|;
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
if|#
directive|if
literal|0
block|if (was_set == 0) 			free(r_tmp);
endif|#
directive|endif
block|}
name|fnode
operator|->
name|req_list
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * for each provision of fnode -> p 	 *	remove fnode from provision list for p in hash table 	 */
name|p
operator|=
name|fnode
operator|->
name|prov_list
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|p_tmp
operator|=
name|p
expr_stmt|;
name|pnode
operator|=
name|p
operator|->
name|pnode
expr_stmt|;
if|if
condition|(
name|pnode
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|pnode
operator|->
name|next
operator|->
name|last
operator|=
name|pnode
operator|->
name|last
expr_stmt|;
block|}
if|if
condition|(
name|pnode
operator|->
name|last
operator|!=
name|NULL
condition|)
block|{
name|pnode
operator|->
name|last
operator|->
name|next
operator|=
name|pnode
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|pnode
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p_tmp
argument_list|)
expr_stmt|;
block|}
name|fnode
operator|->
name|prov_list
operator|=
name|NULL
expr_stmt|;
comment|/* do_it(fnode) */
name|DPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"next do: "
operator|)
argument_list|)
expr_stmt|;
comment|/* if we were already in progress, don't print again */
if|if
condition|(
name|was_set
operator|==
literal|0
operator|&&
name|skip_ok
argument_list|(
name|fnode
argument_list|)
operator|&&
name|keep_ok
argument_list|(
name|fnode
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|fnode
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnode
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|fnode
operator|->
name|next
operator|->
name|last
operator|=
name|fnode
operator|->
name|last
expr_stmt|;
block|}
if|if
condition|(
name|fnode
operator|->
name|last
operator|!=
name|NULL
condition|)
block|{
name|fnode
operator|->
name|last
operator|->
name|next
operator|=
name|fnode
operator|->
name|next
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"nuking %s\n"
operator|,
name|fnode
operator|->
name|filename
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (was_set == 0) {    		free(fnode->filename);    		free(fnode); 	}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|generate_ordering
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * while there remain undone files{f}, 	 *	pick an arbitrary f, and do_file(f) 	 * Note that the first file in the file list is perfectly 	 * arbitrary, and easy to find, so we use that. 	 */
comment|/* 	 * N.B.: the file nodes "self delete" after they execute, so 	 * after each iteration of the loop, the head will be pointing 	 * to something totally different. The loop ends up being 	 * executed only once for every strongly connected set of 	 * nodes. 	 */
while|while
condition|(
name|fn_head
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
name|stderr
operator|,
literal|"generate on %s\n"
operator|,
name|fn_head
operator|->
name|next
operator|->
name|filename
operator|)
argument_list|)
expr_stmt|;
name|do_file
argument_list|(
name|fn_head
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

