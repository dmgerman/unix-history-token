begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)lfs.c	8.1 (Berkeley) 6/5/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dir.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/lfs/lfs.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_comment
comment|/*  * This table is indexed by the log base 2 of the block size.  * It returns the maximum file size allowed in a file system  * with the specified block size.  For block sizes smaller than  * 8K, the size is limited by tha maximum number of blocks that  * can be reached by triply indirect blocks:  *	NDADDR + INOPB(bsize) + INOPB(bsize)^2 + INOPB(bsize)^3  * For block size of 8K or larger, the file size is limited by the  * number of blocks that can be represented in the file system.  Since  * we use negative block numbers to represent indirect blocks, we can  * have a maximum of 2^31 blocks.  */
end_comment

begin_decl_stmt
name|u_quad_t
name|maxtable
index|[]
init|=
block|{
comment|/*    1 */
operator|-
literal|1
block|,
comment|/*    2 */
operator|-
literal|1
block|,
comment|/*    4 */
operator|-
literal|1
block|,
comment|/*    8 */
operator|-
literal|1
block|,
comment|/*   16 */
operator|-
literal|1
block|,
comment|/*   32 */
operator|-
literal|1
block|,
comment|/*   64 */
operator|-
literal|1
block|,
comment|/*  128 */
operator|-
literal|1
block|,
comment|/*  256 */
operator|-
literal|1
block|,
comment|/*  512 */
name|NDADDR
operator|+
literal|128
operator|+
literal|128
operator|*
literal|128
operator|+
literal|128
operator|*
literal|128
operator|*
literal|128
block|,
comment|/* 1024 */
name|NDADDR
operator|+
literal|256
operator|+
literal|256
operator|*
literal|256
operator|+
literal|256
operator|*
literal|256
operator|*
literal|256
block|,
comment|/* 2048 */
name|NDADDR
operator|+
literal|512
operator|+
literal|512
operator|*
literal|512
operator|+
literal|512
operator|*
literal|512
operator|*
literal|512
block|,
comment|/* 4096 */
name|NDADDR
operator|+
literal|1024
operator|+
literal|1024
operator|*
literal|1024
operator|+
literal|1024
operator|*
literal|1024
operator|*
literal|1024
block|,
comment|/* 8192 */
literal|1
operator|<<
literal|31
block|,
comment|/* 16 K */
literal|1
operator|<<
literal|31
block|,
comment|/* 32 K */
literal|1
operator|<<
literal|31
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lfs
name|lfs_default
init|=
block|{
comment|/* lfs_magic */
name|LFS_MAGIC
block|,
comment|/* lfs_version */
name|LFS_VERSION
block|,
comment|/* lfs_size */
literal|0
block|,
comment|/* lfs_ssize */
name|DFL_LFSSEG
operator|/
name|DFL_LFSBLOCK
block|,
comment|/* lfs_dsize */
literal|0
block|,
comment|/* lfs_bsize */
name|DFL_LFSBLOCK
block|,
comment|/* lfs_fsize */
name|DFL_LFSBLOCK
block|,
comment|/* lfs_frag */
literal|1
block|,
comment|/* lfs_free */
name|LFS_FIRST_INUM
block|,
comment|/* lfs_bfree */
literal|0
block|,
comment|/* lfs_nfiles */
literal|0
block|,
comment|/* lfs_avail */
literal|0
block|,
comment|/* lfs_uinodes */
literal|0
block|,
comment|/* lfs_idaddr */
literal|0
block|,
comment|/* lfs_ifile */
name|LFS_IFILE_INUM
block|,
comment|/* lfs_lastseg */
literal|0
block|,
comment|/* lfs_nextseg */
literal|0
block|,
comment|/* lfs_curseg */
literal|0
block|,
comment|/* lfs_offset */
literal|0
block|,
comment|/* lfs_lastpseg */
literal|0
block|,
comment|/* lfs_tstamp */
literal|0
block|,
comment|/* lfs_maxsymlinklen */
name|MAXSYMLINKLEN
block|,
comment|/* lfs_minfree */
name|MINFREE
block|,
comment|/* lfs_maxfilesize */
literal|0
block|,
comment|/* lfs_dbpseg */
name|DFL_LFSSEG
operator|/
name|DEV_BSIZE
block|,
comment|/* lfs_inopb */
name|DFL_LFSBLOCK
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
block|,
comment|/* lfs_ifpb */
name|DFL_LFSBLOCK
operator|/
sizeof|sizeof
argument_list|(
name|IFILE
argument_list|)
block|,
comment|/* lfs_sepb */
name|DFL_LFSBLOCK
operator|/
sizeof|sizeof
argument_list|(
name|SEGUSE
argument_list|)
block|,
comment|/* lfs_nindir */
name|DFL_LFSBLOCK
operator|/
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
block|,
comment|/* lfs_nseg */
literal|0
block|,
comment|/* lfs_nspf */
literal|0
block|,
comment|/* lfs_cleansz */
literal|0
block|,
comment|/* lfs_segtabsz */
literal|0
block|,
comment|/* lfs_segmask */
name|DFL_LFSSEG_MASK
block|,
comment|/* lfs_segshift */
name|DFL_LFSSEG_SHIFT
block|,
comment|/* lfs_bmask */
name|DFL_LFSBLOCK_MASK
block|,
comment|/* lfs_bshift */
name|DFL_LFSBLOCK_SHIFT
block|,
comment|/* lfs_ffmask */
literal|0
block|,
comment|/* lfs_ffshift */
literal|0
block|,
comment|/* lfs_fbmask */
literal|0
block|,
comment|/* lfs_fbshift */
literal|0
block|,
comment|/* lfs_fsbtodb */
literal|0
block|,
comment|/* lfs_sushift */
literal|0
block|,
comment|/* lfs_sboffs */
block|{
literal|0
block|}
block|,
comment|/* lfs_sp */
name|NULL
block|,
comment|/* lfs_ivnode */
name|NULL
block|,
comment|/* lfs_seglock */
literal|0
block|,
comment|/* lfs_lockpid */
literal|0
block|,
comment|/* lfs_iocount */
literal|0
block|,
comment|/* lfs_writer */
literal|0
block|,
comment|/* lfs_dirops */
literal|0
block|,
comment|/* lfs_doifile */
literal|0
block|,
comment|/* lfs_nactive */
literal|0
block|,
comment|/* lfs_fmod */
literal|0
block|,
comment|/* lfs_clean */
literal|0
block|,
comment|/* lfs_ronly */
literal|0
block|,
comment|/* lfs_flags */
literal|0
block|,
comment|/* lfs_fsmnt */
block|{
literal|0
block|}
block|,
comment|/* lfs_pad */
block|{
literal|0
block|}
block|,
comment|/* lfs_pad2 */
block|{
literal|0
block|}
block|,
comment|/* lfs_cksum */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|direct
name|lfs_root_dir
index|[]
init|=
block|{
block|{
name|ROOTINO
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
block|,
name|DT_DIR
block|,
literal|1
block|,
literal|"."
block|}
block|,
block|{
name|ROOTINO
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
block|,
name|DT_DIR
block|,
literal|2
block|,
literal|".."
block|}
block|,
block|{
name|LFS_IFILE_INUM
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
block|,
name|DT_REG
block|,
literal|5
block|,
literal|"ifile"
block|}
block|,
block|{
name|LOSTFOUNDINO
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
block|,
name|DT_DIR
block|,
literal|10
block|,
literal|"lost+found"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|direct
name|lfs_lf_dir
index|[]
init|=
block|{
block|{
name|LOSTFOUNDINO
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
block|,
name|DT_DIR
block|,
literal|1
block|,
literal|"."
block|}
block|,
block|{
name|ROOTINO
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
block|,
name|DT_DIR
block|,
literal|2
block|,
literal|".."
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|daddr_t
name|make_dinode
name|__P
argument_list|(
operator|(
name|ino_t
operator|,
expr|struct
name|dinode
operator|*
operator|,
name|int
operator|,
name|daddr_t
operator|,
expr|struct
name|lfs
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_dir
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
expr|struct
name|direct
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|put
name|__P
argument_list|(
operator|(
name|int
operator|,
name|off_t
operator|,
name|void
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|make_lfs
parameter_list|(
name|fd
parameter_list|,
name|lp
parameter_list|,
name|partp
parameter_list|,
name|minfree
parameter_list|,
name|bsize
parameter_list|,
name|seg_size
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|struct
name|partition
modifier|*
name|partp
decl_stmt|;
name|int
name|minfree
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|int
name|seg_size
decl_stmt|;
block|{
name|struct
name|dinode
modifier|*
name|dip
decl_stmt|;
comment|/* Pointer to a disk inode */
name|struct
name|dinode
modifier|*
name|dpagep
decl_stmt|;
comment|/* Pointer to page of disk inodes */
name|CLEANERINFO
modifier|*
name|cleaninfo
decl_stmt|;
comment|/* Segment cleaner information table */
name|FINFO
name|file_info
decl_stmt|;
comment|/* File info structure in summary blocks */
name|IFILE
modifier|*
name|ifile
decl_stmt|;
comment|/* Pointer to array of ifile structures */
name|IFILE
modifier|*
name|ip
decl_stmt|;
comment|/* Pointer to array of ifile structures */
name|struct
name|lfs
modifier|*
name|lfsp
decl_stmt|;
comment|/* Superblock */
name|SEGUSE
modifier|*
name|segp
decl_stmt|;
comment|/* Segment usage table */
name|SEGUSE
modifier|*
name|segtable
decl_stmt|;
comment|/* Segment usage table */
name|SEGSUM
name|summary
decl_stmt|;
comment|/* Segment summary structure */
name|SEGSUM
modifier|*
name|sp
decl_stmt|;
comment|/* Segment summary pointer */
name|daddr_t
name|last_sb_addr
decl_stmt|;
comment|/* Address of superblocks */
name|daddr_t
name|last_addr
decl_stmt|;
comment|/* Previous segment address */
name|daddr_t
name|sb_addr
decl_stmt|;
comment|/* Address of superblocks */
name|daddr_t
name|seg_addr
decl_stmt|;
comment|/* Address of current segment */
name|void
modifier|*
name|ipagep
decl_stmt|;
comment|/* Pointer to the page we use to write stuff */
name|void
modifier|*
name|sump
decl_stmt|;
comment|/* Used to copy stuff into segment buffer */
name|u_long
modifier|*
name|block_array
decl_stmt|;
comment|/* Array of logical block nos to put in sum */
name|u_long
name|blocks_used
decl_stmt|;
comment|/* Number of blocks in first segment */
name|u_long
modifier|*
name|dp
decl_stmt|;
comment|/* Used to computed checksum on data */
name|u_long
modifier|*
name|datasump
decl_stmt|;
comment|/* Used to computed checksum on data */
name|int
name|block_array_size
decl_stmt|;
comment|/* How many entries in block array */
name|int
name|db_per_fb
decl_stmt|;
comment|/* Disk blocks per file block */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|off
decl_stmt|;
comment|/* Offset at which to write */
name|int
name|sb_interval
decl_stmt|;
comment|/* number of segs between super blocks */
name|int
name|seg_seek
decl_stmt|;
comment|/* Seek offset for a segment */
name|int
name|ssize
decl_stmt|;
comment|/* Segment size */
name|int
name|sum_size
decl_stmt|;
comment|/* Size of the summary block */
name|lfsp
operator|=
operator|&
name|lfs_default
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ssize
operator|=
name|seg_size
operator|)
condition|)
name|ssize
operator|=
name|DFL_LFSSEG
expr_stmt|;
comment|/* Modify parts of superblock overridden by command line arguments */
if|if
condition|(
name|bsize
operator|!=
name|DFL_LFSBLOCK
condition|)
block|{
name|lfsp
operator|->
name|lfs_bshift
operator|=
name|log2
argument_list|(
name|bsize
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<<
name|lfsp
operator|->
name|lfs_bshift
operator|!=
name|bsize
condition|)
name|fatal
argument_list|(
literal|"%d: block size not a power of 2"
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
name|lfsp
operator|->
name|lfs_bsize
operator|=
name|bsize
expr_stmt|;
name|lfsp
operator|->
name|lfs_fsize
operator|=
name|bsize
expr_stmt|;
name|lfsp
operator|->
name|lfs_bmask
operator|=
name|bsize
operator|-
literal|1
expr_stmt|;
name|lfsp
operator|->
name|lfs_inopb
operator|=
name|bsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
expr_stmt|;
comment|/* MIS -- should I round to power of 2 */
name|lfsp
operator|->
name|lfs_ifpb
operator|=
name|bsize
operator|/
sizeof|sizeof
argument_list|(
name|IFILE
argument_list|)
expr_stmt|;
name|lfsp
operator|->
name|lfs_sepb
operator|=
name|bsize
operator|/
sizeof|sizeof
argument_list|(
name|SEGUSE
argument_list|)
expr_stmt|;
name|lfsp
operator|->
name|lfs_nindir
operator|=
name|bsize
operator|/
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ssize
operator|!=
name|DFL_LFSSEG
condition|)
block|{
name|lfsp
operator|->
name|lfs_segshift
operator|=
name|log2
argument_list|(
name|ssize
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<<
name|lfsp
operator|->
name|lfs_segshift
operator|!=
name|ssize
condition|)
name|fatal
argument_list|(
literal|"%d: segment size not power of 2"
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
name|lfsp
operator|->
name|lfs_ssize
operator|=
name|ssize
expr_stmt|;
name|lfsp
operator|->
name|lfs_segmask
operator|=
name|ssize
operator|-
literal|1
expr_stmt|;
name|lfsp
operator|->
name|lfs_dbpseg
operator|=
name|ssize
operator|/
name|DEV_BSIZE
expr_stmt|;
block|}
name|lfsp
operator|->
name|lfs_ssize
operator|=
name|ssize
operator|>>
name|lfsp
operator|->
name|lfs_bshift
expr_stmt|;
if|if
condition|(
name|minfree
condition|)
name|lfsp
operator|->
name|lfs_minfree
operator|=
name|minfree
expr_stmt|;
comment|/* 	 * Fill in parts of superblock that can be computed from file system 	 * size, disk geometry and current time. 	 */
name|db_per_fb
operator|=
name|bsize
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|lfsp
operator|->
name|lfs_fsbtodb
operator|=
name|log2
argument_list|(
name|db_per_fb
argument_list|)
expr_stmt|;
name|lfsp
operator|->
name|lfs_sushift
operator|=
name|log2
argument_list|(
name|lfsp
operator|->
name|lfs_sepb
argument_list|)
expr_stmt|;
name|lfsp
operator|->
name|lfs_size
operator|=
name|partp
operator|->
name|p_size
operator|>>
name|lfsp
operator|->
name|lfs_fsbtodb
expr_stmt|;
name|lfsp
operator|->
name|lfs_dsize
operator|=
name|lfsp
operator|->
name|lfs_size
operator|-
operator|(
name|LFS_LABELPAD
operator|>>
name|lfsp
operator|->
name|lfs_bshift
operator|)
expr_stmt|;
name|lfsp
operator|->
name|lfs_nseg
operator|=
name|lfsp
operator|->
name|lfs_dsize
operator|/
name|lfsp
operator|->
name|lfs_ssize
expr_stmt|;
name|lfsp
operator|->
name|lfs_maxfilesize
operator|=
name|maxtable
index|[
name|lfsp
operator|->
name|lfs_bshift
index|]
operator|<<
name|lfsp
operator|->
name|lfs_bshift
expr_stmt|;
comment|/* 	 * The number of free blocks is set from the number of segments times 	 * the segment size - 2 (that we never write because we need to make 	 * sure the cleaner can run).  Then we'll subtract off the room for the 	 * superblocks ifile entries and segment usage table. 	 */
name|lfsp
operator|->
name|lfs_dsize
operator|=
name|fsbtodb
argument_list|(
name|lfsp
argument_list|,
operator|(
name|lfsp
operator|->
name|lfs_nseg
operator|-
literal|2
operator|)
operator|*
name|lfsp
operator|->
name|lfs_ssize
argument_list|)
expr_stmt|;
name|lfsp
operator|->
name|lfs_bfree
operator|=
name|lfsp
operator|->
name|lfs_dsize
expr_stmt|;
name|lfsp
operator|->
name|lfs_segtabsz
operator|=
name|SEGTABSIZE_SU
argument_list|(
name|lfsp
argument_list|)
expr_stmt|;
name|lfsp
operator|->
name|lfs_cleansz
operator|=
name|CLEANSIZE_SU
argument_list|(
name|lfsp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lfsp
operator|->
name|lfs_tstamp
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"time: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sb_interval
operator|=
name|lfsp
operator|->
name|lfs_nseg
operator|/
name|LFS_MAXNUMSB
operator|)
operator|<
name|LFS_MIN_SBINTERVAL
condition|)
name|sb_interval
operator|=
name|LFS_MIN_SBINTERVAL
expr_stmt|;
comment|/* 	 * Now, lay out the file system.  We need to figure out where 	 * the superblocks go, initialize the checkpoint information 	 * for the first two superblocks, initialize the segment usage 	 * information, put the segusage information in the ifile, create 	 * the first block of IFILE structures, and link all the IFILE 	 * structures into a free list. 	 */
comment|/* Figure out where the superblocks are going to live */
name|lfsp
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
operator|=
name|LFS_LABELPAD
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|LFS_MAXNUMSB
condition|;
name|i
operator|++
control|)
block|{
name|sb_addr
operator|=
operator|(
operator|(
name|i
operator|*
name|sb_interval
operator|)
operator|<<
operator|(
name|lfsp
operator|->
name|lfs_segshift
operator|-
name|lfsp
operator|->
name|lfs_bshift
operator|+
name|lfsp
operator|->
name|lfs_fsbtodb
operator|)
operator|)
operator|+
name|lfsp
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|sb_addr
operator|>
name|partp
operator|->
name|p_size
condition|)
break|break;
name|lfsp
operator|->
name|lfs_sboffs
index|[
name|i
index|]
operator|=
name|sb_addr
expr_stmt|;
block|}
name|last_sb_addr
operator|=
name|lfsp
operator|->
name|lfs_sboffs
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|lfsp
operator|->
name|lfs_lastseg
operator|=
name|lfsp
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
expr_stmt|;
name|lfsp
operator|->
name|lfs_nextseg
operator|=
name|lfsp
operator|->
name|lfs_sboffs
index|[
literal|1
index|]
condition|?
name|lfsp
operator|->
name|lfs_sboffs
index|[
literal|1
index|]
else|:
name|lfsp
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
expr_stmt|;
name|lfsp
operator|->
name|lfs_curseg
operator|=
name|lfsp
operator|->
name|lfs_lastseg
expr_stmt|;
comment|/* 	 * Initialize the segment usage table.  The first segment will 	 * contain the superblock, the cleanerinfo (cleansz), the segusage 	 * table * (segtabsz), 1 block's worth of IFILE entries, the root 	 * directory, the lost+found directory and one block's worth of 	 * inodes (containing the ifile, root, and l+f inodes). 	 */
if|if
condition|(
operator|!
operator|(
name|cleaninfo
operator|=
name|malloc
argument_list|(
name|lfsp
operator|->
name|lfs_cleansz
operator|<<
name|lfsp
operator|->
name|lfs_bshift
argument_list|)
operator|)
condition|)
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|cleaninfo
operator|->
name|clean
operator|=
name|lfsp
operator|->
name|lfs_nseg
operator|-
literal|1
expr_stmt|;
name|cleaninfo
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|segtable
operator|=
name|malloc
argument_list|(
name|lfsp
operator|->
name|lfs_segtabsz
operator|<<
name|lfsp
operator|->
name|lfs_bshift
argument_list|)
operator|)
condition|)
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|segp
operator|=
name|segtable
expr_stmt|;
name|blocks_used
operator|=
name|lfsp
operator|->
name|lfs_segtabsz
operator|+
name|lfsp
operator|->
name|lfs_cleansz
operator|+
literal|4
expr_stmt|;
name|segp
operator|->
name|su_nbytes
operator|=
operator|(
operator|(
name|blocks_used
operator|-
literal|1
operator|)
operator|<<
name|lfsp
operator|->
name|lfs_bshift
operator|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
operator|+
name|LFS_SUMMARY_SIZE
expr_stmt|;
name|segp
operator|->
name|su_lastmod
operator|=
name|lfsp
operator|->
name|lfs_tstamp
expr_stmt|;
name|segp
operator|->
name|su_nsums
operator|=
literal|1
expr_stmt|;
comment|/* 1 summary blocks */
name|segp
operator|->
name|su_ninos
operator|=
literal|1
expr_stmt|;
comment|/* 1 inode block */
name|segp
operator|->
name|su_flags
operator|=
name|SEGUSE_SUPERBLOCK
operator||
name|SEGUSE_DIRTY
expr_stmt|;
name|lfsp
operator|->
name|lfs_bfree
operator|-=
name|LFS_SUMMARY_SIZE
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|lfsp
operator|->
name|lfs_bfree
operator|-=
name|fsbtodb
argument_list|(
name|lfsp
argument_list|,
name|lfsp
operator|->
name|lfs_cleansz
operator|+
name|lfsp
operator|->
name|lfs_segtabsz
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* 	 * Now figure out the address of the ifile inode. The inode block 	 * appears immediately after the segment summary. 	 */
name|lfsp
operator|->
name|lfs_idaddr
operator|=
operator|(
name|LFS_LABELPAD
operator|+
name|LFS_SBPAD
operator|+
name|LFS_SUMMARY_SIZE
operator|)
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
for|for
control|(
name|segp
operator|=
name|segtable
operator|+
literal|1
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lfsp
operator|->
name|lfs_nseg
condition|;
name|i
operator|++
operator|,
name|segp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
name|sb_interval
operator|)
operator|==
literal|0
condition|)
block|{
name|segp
operator|->
name|su_flags
operator|=
name|SEGUSE_SUPERBLOCK
expr_stmt|;
name|lfsp
operator|->
name|lfs_bfree
operator|-=
operator|(
name|LFS_SBPAD
operator|/
name|lp
operator|->
name|d_secsize
operator|)
expr_stmt|;
block|}
else|else
name|segp
operator|->
name|su_flags
operator|=
literal|0
expr_stmt|;
name|segp
operator|->
name|su_lastmod
operator|=
literal|0
expr_stmt|;
name|segp
operator|->
name|su_nbytes
operator|=
literal|0
expr_stmt|;
name|segp
operator|->
name|su_ninos
operator|=
literal|0
expr_stmt|;
name|segp
operator|->
name|su_nsums
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Initialize dynamic accounting.  The blocks available for 	 * writing are the bfree blocks minus 1 segment summary for 	 * each segment since you can't write any new data without 	 * creating a segment summary - 2 segments that the cleaner 	 * needs. 	 */
name|lfsp
operator|->
name|lfs_avail
operator|=
name|lfsp
operator|->
name|lfs_bfree
operator|-
name|lfsp
operator|->
name|lfs_nseg
operator|-
name|fsbtodb
argument_list|(
name|lfsp
argument_list|,
literal|2
operator|*
name|lfsp
operator|->
name|lfs_ssize
argument_list|)
expr_stmt|;
name|lfsp
operator|->
name|lfs_uinodes
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Ready to start writing segments.  The first segment is different 	 * because it contains the segment usage table and the ifile inode 	 * as well as a superblock.  For the rest of the segments, set the 	 * time stamp to be 0 so that the first segment is the most recent. 	 * For each segment that is supposed to contain a copy of the super 	 * block, initialize its first few blocks and its segment summary 	 * to indicate this. 	 */
name|lfsp
operator|->
name|lfs_nfiles
operator|=
name|LFS_FIRST_INUM
operator|-
literal|1
expr_stmt|;
name|lfsp
operator|->
name|lfs_cksum
operator|=
name|cksum
argument_list|(
name|lfsp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lfs
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|lfsp
operator|->
name|lfs_cksum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now create a block of disk inodes */
if|if
condition|(
operator|!
operator|(
name|dpagep
operator|=
name|malloc
argument_list|(
name|lfsp
operator|->
name|lfs_bsize
argument_list|)
operator|)
condition|)
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dip
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|dpagep
expr_stmt|;
name|bzero
argument_list|(
name|dip
argument_list|,
name|lfsp
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
comment|/* Create a block of IFILE structures. */
if|if
condition|(
operator|!
operator|(
name|ipagep
operator|=
name|malloc
argument_list|(
name|lfsp
operator|->
name|lfs_bsize
argument_list|)
operator|)
condition|)
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ifile
operator|=
operator|(
name|IFILE
operator|*
operator|)
name|ipagep
expr_stmt|;
comment|/* 	 * Initialize IFILE.  It is the next block following the 	 * block of inodes (whose address has been calculated in 	 * lfsp->lfs_idaddr; 	 */
name|sb_addr
operator|=
name|lfsp
operator|->
name|lfs_idaddr
operator|+
name|lfsp
operator|->
name|lfs_bsize
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|sb_addr
operator|=
name|make_dinode
argument_list|(
name|LFS_IFILE_INUM
argument_list|,
name|dip
argument_list|,
name|lfsp
operator|->
name|lfs_cleansz
operator|+
name|lfsp
operator|->
name|lfs_segtabsz
operator|+
literal|1
argument_list|,
name|sb_addr
argument_list|,
name|lfsp
argument_list|)
expr_stmt|;
name|dip
operator|->
name|di_mode
operator|=
name|IFREG
operator||
name|IREAD
operator||
name|IWRITE
expr_stmt|;
name|ip
operator|=
operator|&
name|ifile
index|[
name|LFS_IFILE_INUM
index|]
expr_stmt|;
name|ip
operator|->
name|if_version
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|if_daddr
operator|=
name|lfsp
operator|->
name|lfs_idaddr
expr_stmt|;
comment|/* Initialize the ROOT Directory */
name|sb_addr
operator|=
name|make_dinode
argument_list|(
name|ROOTINO
argument_list|,
operator|++
name|dip
argument_list|,
literal|1
argument_list|,
name|sb_addr
argument_list|,
name|lfsp
argument_list|)
expr_stmt|;
name|dip
operator|->
name|di_mode
operator|=
name|IFDIR
operator||
name|IREAD
operator||
name|IWRITE
operator||
name|IEXEC
expr_stmt|;
name|dip
operator|->
name|di_size
operator|=
name|DIRBLKSIZ
expr_stmt|;
name|dip
operator|->
name|di_nlink
operator|=
literal|3
expr_stmt|;
name|ip
operator|=
operator|&
name|ifile
index|[
name|ROOTINO
index|]
expr_stmt|;
name|ip
operator|->
name|if_version
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|if_daddr
operator|=
name|lfsp
operator|->
name|lfs_idaddr
expr_stmt|;
comment|/* Initialize the lost+found Directory */
name|sb_addr
operator|=
name|make_dinode
argument_list|(
name|LOSTFOUNDINO
argument_list|,
operator|++
name|dip
argument_list|,
literal|1
argument_list|,
name|sb_addr
argument_list|,
name|lfsp
argument_list|)
expr_stmt|;
name|dip
operator|->
name|di_mode
operator|=
name|IFDIR
operator||
name|IREAD
operator||
name|IWRITE
operator||
name|IEXEC
expr_stmt|;
name|dip
operator|->
name|di_size
operator|=
name|DIRBLKSIZ
expr_stmt|;
name|dip
operator|->
name|di_nlink
operator|=
literal|2
expr_stmt|;
name|ip
operator|=
operator|&
name|ifile
index|[
name|LOSTFOUNDINO
index|]
expr_stmt|;
name|ip
operator|->
name|if_version
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|if_daddr
operator|=
name|lfsp
operator|->
name|lfs_idaddr
expr_stmt|;
comment|/* Make all the other dinodes invalid */
for|for
control|(
name|i
operator|=
name|INOPB
argument_list|(
name|lfsp
argument_list|)
operator|-
literal|3
operator|,
name|dip
operator|++
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|dip
operator|++
control|)
name|dip
operator|->
name|di_inumber
operator|=
name|LFS_UNUSED_INUM
expr_stmt|;
comment|/* Link remaining IFILE entries in free list */
for|for
control|(
name|ip
operator|=
operator|&
name|ifile
index|[
name|LFS_FIRST_INUM
index|]
operator|,
name|i
operator|=
name|LFS_FIRST_INUM
init|;
name|i
operator|<
name|lfsp
operator|->
name|lfs_ifpb
condition|;
operator|++
name|ip
control|)
block|{
name|ip
operator|->
name|if_version
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|if_daddr
operator|=
name|LFS_UNUSED_DADDR
expr_stmt|;
name|ip
operator|->
name|if_nextfree
operator|=
operator|++
name|i
expr_stmt|;
block|}
name|ifile
index|[
name|lfsp
operator|->
name|lfs_ifpb
operator|-
literal|1
index|]
operator|.
name|if_nextfree
operator|=
name|LFS_UNUSED_INUM
expr_stmt|;
comment|/* Now, write the segment */
comment|/* Compute a checksum across all the data you're writing */
name|dp
operator|=
name|datasump
operator|=
name|malloc
argument_list|(
name|blocks_used
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|(
operator|(
name|u_long
operator|*
operator|)
name|dpagep
operator|)
index|[
literal|0
index|]
expr_stmt|;
comment|/* inode block */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lfsp
operator|->
name|lfs_cleansz
condition|;
name|i
operator|++
control|)
operator|*
name|dp
operator|++
operator|=
operator|(
operator|(
name|u_long
operator|*
operator|)
name|cleaninfo
operator|)
index|[
operator|(
name|i
operator|<<
name|lfsp
operator|->
name|lfs_bshift
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
index|]
expr_stmt|;
comment|/* Cleaner info */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lfsp
operator|->
name|lfs_segtabsz
condition|;
name|i
operator|++
control|)
operator|*
name|dp
operator|++
operator|=
operator|(
operator|(
name|u_long
operator|*
operator|)
name|segtable
operator|)
index|[
operator|(
name|i
operator|<<
name|lfsp
operator|->
name|lfs_bshift
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
index|]
expr_stmt|;
comment|/* Segusage table */
operator|*
name|dp
operator|++
operator|=
operator|(
operator|(
name|u_long
operator|*
operator|)
name|ifile
operator|)
index|[
literal|0
index|]
expr_stmt|;
comment|/* Ifile */
comment|/* Still need the root and l+f bytes; get them later */
comment|/* Write out the inode block */
name|off
operator|=
name|LFS_LABELPAD
operator|+
name|LFS_SBPAD
operator|+
name|LFS_SUMMARY_SIZE
expr_stmt|;
name|put
argument_list|(
name|fd
argument_list|,
name|off
argument_list|,
name|dpagep
argument_list|,
name|lfsp
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dpagep
argument_list|)
expr_stmt|;
name|off
operator|+=
name|lfsp
operator|->
name|lfs_bsize
expr_stmt|;
comment|/* Write out the ifile */
name|put
argument_list|(
name|fd
argument_list|,
name|off
argument_list|,
name|cleaninfo
argument_list|,
name|lfsp
operator|->
name|lfs_cleansz
operator|<<
name|lfsp
operator|->
name|lfs_bshift
argument_list|)
expr_stmt|;
name|off
operator|+=
operator|(
name|lfsp
operator|->
name|lfs_cleansz
operator|<<
name|lfsp
operator|->
name|lfs_bshift
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
name|cleaninfo
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|fd
argument_list|,
name|off
argument_list|,
name|segtable
argument_list|,
name|lfsp
operator|->
name|lfs_segtabsz
operator|<<
name|lfsp
operator|->
name|lfs_bshift
argument_list|)
expr_stmt|;
name|off
operator|+=
operator|(
name|lfsp
operator|->
name|lfs_segtabsz
operator|<<
name|lfsp
operator|->
name|lfs_bshift
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
name|segtable
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|fd
argument_list|,
name|off
argument_list|,
name|ifile
argument_list|,
name|lfsp
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
name|off
operator|+=
name|lfsp
operator|->
name|lfs_bsize
expr_stmt|;
comment|/* 	 * use ipagep for space for writing out other stuff.  It used to 	 * contain the ifile, but we're done with it. 	 */
comment|/* Write out the root and lost and found directories */
name|bzero
argument_list|(
name|ipagep
argument_list|,
name|lfsp
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
name|make_dir
argument_list|(
name|ipagep
argument_list|,
name|lfs_root_dir
argument_list|,
sizeof|sizeof
argument_list|(
name|lfs_root_dir
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|(
operator|(
name|u_long
operator|*
operator|)
name|ipagep
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|put
argument_list|(
name|fd
argument_list|,
name|off
argument_list|,
name|ipagep
argument_list|,
name|lfsp
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
name|off
operator|+=
name|lfsp
operator|->
name|lfs_bsize
expr_stmt|;
name|bzero
argument_list|(
name|ipagep
argument_list|,
name|lfsp
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
name|make_dir
argument_list|(
name|ipagep
argument_list|,
name|lfs_lf_dir
argument_list|,
sizeof|sizeof
argument_list|(
name|lfs_lf_dir
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|(
operator|(
name|u_long
operator|*
operator|)
name|ipagep
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|put
argument_list|(
name|fd
argument_list|,
name|off
argument_list|,
name|ipagep
argument_list|,
name|lfsp
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
comment|/* Write Supberblock */
name|lfsp
operator|->
name|lfs_offset
operator|=
operator|(
name|off
operator|+
name|lfsp
operator|->
name|lfs_bsize
operator|)
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|put
argument_list|(
name|fd
argument_list|,
name|LFS_LABELPAD
argument_list|,
name|lfsp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lfs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Finally, calculate all the fields for the summary structure 	 * and write it. 	 */
name|summary
operator|.
name|ss_next
operator|=
name|lfsp
operator|->
name|lfs_nextseg
expr_stmt|;
name|summary
operator|.
name|ss_create
operator|=
name|lfsp
operator|->
name|lfs_tstamp
expr_stmt|;
name|summary
operator|.
name|ss_nfinfo
operator|=
literal|3
expr_stmt|;
name|summary
operator|.
name|ss_ninos
operator|=
literal|3
expr_stmt|;
name|summary
operator|.
name|ss_datasum
operator|=
name|cksum
argument_list|(
name|datasump
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|blocks_used
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure that we don't overflow a summary block. We have to 	 * record: FINFO structures for ifile, root, and l+f.  The number 	 * of blocks recorded for the ifile is determined by the size of 	 * the cleaner info and the segments usage table.  There is room 	 * for one block included in sizeof(FINFO) so we don't need to add 	 * any extra space for the ROOT and L+F, and one block of the ifile 	 * is already counted.  Finally, we leave room for 1 inode block 	 * address. 	 */
name|sum_size
operator|=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|+
operator|(
name|lfsp
operator|->
name|lfs_cleansz
operator|+
name|lfsp
operator|->
name|lfs_segtabsz
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
define|#
directive|define
name|SUMERR
define|\
value|"Multiple summary blocks in segment 1 not yet implemented\nsummary is %d bytes."
if|if
condition|(
name|sum_size
operator|>
name|LFS_SUMMARY_SIZE
condition|)
name|fatal
argument_list|(
name|SUMERR
argument_list|,
name|sum_size
argument_list|)
expr_stmt|;
name|block_array_size
operator|=
name|lfsp
operator|->
name|lfs_cleansz
operator|+
name|lfsp
operator|->
name|lfs_segtabsz
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|block_array
operator|=
name|malloc
argument_list|(
name|block_array_size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
condition|)
name|fatal
argument_list|(
literal|"%s: %s"
argument_list|,
name|special
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill in the array */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|block_array_size
condition|;
name|i
operator|++
control|)
name|block_array
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* copy into segment */
name|sump
operator|=
name|ipagep
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|summary
argument_list|,
name|sump
argument_list|,
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
argument_list|)
expr_stmt|;
name|sump
operator|+=
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
expr_stmt|;
comment|/* Now, add the ifile */
name|file_info
operator|.
name|fi_nblocks
operator|=
name|block_array_size
expr_stmt|;
name|file_info
operator|.
name|fi_version
operator|=
literal|1
expr_stmt|;
name|file_info
operator|.
name|fi_ino
operator|=
name|LFS_IFILE_INUM
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|file_info
argument_list|,
name|sump
argument_list|,
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|sump
operator|+=
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|block_array
argument_list|,
name|sump
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|file_info
operator|.
name|fi_nblocks
argument_list|)
expr_stmt|;
name|sump
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|file_info
operator|.
name|fi_nblocks
expr_stmt|;
comment|/* Now, add the root directory */
name|file_info
operator|.
name|fi_nblocks
operator|=
literal|1
expr_stmt|;
name|file_info
operator|.
name|fi_version
operator|=
literal|1
expr_stmt|;
name|file_info
operator|.
name|fi_ino
operator|=
name|ROOTINO
expr_stmt|;
name|file_info
operator|.
name|fi_blocks
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|file_info
argument_list|,
name|sump
argument_list|,
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
argument_list|)
expr_stmt|;
name|sump
operator|+=
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
expr_stmt|;
comment|/* Now, add the lost and found */
name|file_info
operator|.
name|fi_ino
operator|=
name|LOSTFOUNDINO
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|file_info
argument_list|,
name|sump
argument_list|,
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|daddr_t
operator|*
operator|)
name|ipagep
operator|)
index|[
name|LFS_SUMMARY_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
operator|-
literal|1
index|]
operator|=
name|lfsp
operator|->
name|lfs_idaddr
expr_stmt|;
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
name|ipagep
operator|)
operator|->
name|ss_sumsum
operator|=
name|cksum
argument_list|(
name|ipagep
operator|+
sizeof|sizeof
argument_list|(
name|summary
operator|.
name|ss_sumsum
argument_list|)
argument_list|,
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|summary
operator|.
name|ss_sumsum
argument_list|)
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|fd
argument_list|,
name|LFS_LABELPAD
operator|+
name|LFS_SBPAD
argument_list|,
name|ipagep
argument_list|,
name|LFS_SUMMARY_SIZE
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|(
name|SEGSUM
operator|*
operator|)
name|ipagep
expr_stmt|;
name|sp
operator|->
name|ss_create
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|ss_nfinfo
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|ss_ninos
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|ss_datasum
operator|=
literal|0
expr_stmt|;
comment|/* Now write the summary block for the next partial so it's invalid */
name|lfsp
operator|->
name|lfs_tstamp
operator|=
literal|0
expr_stmt|;
name|off
operator|+=
name|lfsp
operator|->
name|lfs_bsize
expr_stmt|;
name|sp
operator|->
name|ss_sumsum
operator|=
name|cksum
argument_list|(
operator|&
name|sp
operator|->
name|ss_datasum
argument_list|,
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|ss_sumsum
argument_list|)
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|fd
argument_list|,
name|off
argument_list|,
name|sp
argument_list|,
name|LFS_SUMMARY_SIZE
argument_list|)
expr_stmt|;
comment|/* Now, write rest of segments containing superblocks */
name|lfsp
operator|->
name|lfs_cksum
operator|=
name|cksum
argument_list|(
name|lfsp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lfs
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|lfsp
operator|->
name|lfs_cksum
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|seg_addr
operator|=
name|last_addr
operator|=
name|lfsp
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
operator|,
name|j
operator|=
literal|1
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lfsp
operator|->
name|lfs_nseg
condition|;
name|i
operator|++
control|)
block|{
name|seg_addr
operator|+=
name|lfsp
operator|->
name|lfs_ssize
operator|<<
name|lfsp
operator|->
name|lfs_fsbtodb
expr_stmt|;
name|sp
operator|->
name|ss_next
operator|=
name|last_addr
expr_stmt|;
name|last_addr
operator|=
name|seg_addr
expr_stmt|;
name|seg_seek
operator|=
name|seg_addr
operator|*
name|lp
operator|->
name|d_secsize
expr_stmt|;
if|if
condition|(
name|seg_addr
operator|==
name|lfsp
operator|->
name|lfs_sboffs
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
name|j
operator|<
operator|(
name|LFS_MAXNUMSB
operator|-
literal|2
operator|)
condition|)
name|j
operator|++
expr_stmt|;
name|put
argument_list|(
name|fd
argument_list|,
name|seg_seek
argument_list|,
name|lfsp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lfs
argument_list|)
argument_list|)
expr_stmt|;
name|seg_seek
operator|+=
name|LFS_SBPAD
expr_stmt|;
block|}
comment|/* Summary */
name|sp
operator|->
name|ss_sumsum
operator|=
name|cksum
argument_list|(
operator|&
name|sp
operator|->
name|ss_datasum
argument_list|,
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|ss_sumsum
argument_list|)
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|fd
argument_list|,
name|seg_seek
argument_list|,
name|sp
argument_list|,
name|LFS_SUMMARY_SIZE
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ipagep
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|put
parameter_list|(
name|fd
parameter_list|,
name|off
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|int
name|fd
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|int
name|wbytes
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: %s"
argument_list|,
name|special
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wbytes
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: %s"
argument_list|,
name|special
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wbytes
operator|!=
name|len
condition|)
name|fatal
argument_list|(
literal|"%s: short write (%d, not %d)"
argument_list|,
name|special
argument_list|,
name|wbytes
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create the root directory for this file system and the lost+found  * directory.  */
end_comment

begin_decl_stmt
name|u_long
name|d_ino
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* inode number of entry */
end_comment

begin_decl_stmt
name|u_short
name|d_reclen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of this record */
end_comment

begin_decl_stmt
name|u_short
name|d_namlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of string in d_name */
end_comment

begin_decl_stmt
name|char
name|d_name
index|[
name|MAXNAMLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name with length<= MAXNAMLEN */
end_comment

begin_function
name|void
name|lfsinit
parameter_list|()
block|{}
end_function

begin_function
specifier|static
name|daddr_t
name|make_dinode
parameter_list|(
name|ino
parameter_list|,
name|dip
parameter_list|,
name|nblocks
parameter_list|,
name|saddr
parameter_list|,
name|lfsp
parameter_list|)
name|ino_t
name|ino
decl_stmt|;
comment|/* inode we're creating */
name|struct
name|dinode
modifier|*
name|dip
decl_stmt|;
comment|/* disk inode */
name|int
name|nblocks
decl_stmt|;
comment|/* number of blocks in file */
name|daddr_t
name|saddr
decl_stmt|;
comment|/* starting block address */
name|struct
name|lfs
modifier|*
name|lfsp
decl_stmt|;
comment|/* superblock */
block|{
name|int
name|db_per_fb
decl_stmt|,
name|i
decl_stmt|;
name|dip
operator|->
name|di_nlink
operator|=
literal|1
expr_stmt|;
name|dip
operator|->
name|di_blocks
operator|=
name|nblocks
operator|<<
name|lfsp
operator|->
name|lfs_fsbtodb
expr_stmt|;
name|dip
operator|->
name|di_size
operator|=
operator|(
name|nblocks
operator|<<
name|lfsp
operator|->
name|lfs_bshift
operator|)
expr_stmt|;
name|dip
operator|->
name|di_atime
operator|.
name|tv_sec
operator|=
name|dip
operator|->
name|di_mtime
operator|.
name|tv_sec
operator|=
name|dip
operator|->
name|di_ctime
operator|.
name|tv_sec
operator|=
name|lfsp
operator|->
name|lfs_tstamp
expr_stmt|;
name|dip
operator|->
name|di_atime
operator|.
name|tv_nsec
operator|=
name|dip
operator|->
name|di_mtime
operator|.
name|tv_nsec
operator|=
name|dip
operator|->
name|di_ctime
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|dip
operator|->
name|di_inumber
operator|=
name|ino
expr_stmt|;
define|#
directive|define
name|SEGERR
define|\
value|"File requires more than the number of direct blocks; increase block or segment size."
if|if
condition|(
name|NDADDR
operator|<
name|nblocks
condition|)
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|SEGERR
argument_list|)
expr_stmt|;
comment|/* Assign the block addresses for the ifile */
name|db_per_fb
operator|=
literal|1
operator|<<
name|lfsp
operator|->
name|lfs_fsbtodb
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblocks
condition|;
name|i
operator|++
operator|,
name|saddr
operator|+=
name|db_per_fb
control|)
name|dip
operator|->
name|di_db
index|[
name|i
index|]
operator|=
name|saddr
expr_stmt|;
return|return
operator|(
name|saddr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Construct a set of directory entries in "bufp".  We assume that all the  * entries in protodir fir in the first DIRBLKSIZ.  */
end_comment

begin_function
specifier|static
name|void
name|make_dir
parameter_list|(
name|bufp
parameter_list|,
name|protodir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|bufp
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|protodir
decl_stmt|;
name|int
name|entries
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|spcleft
decl_stmt|;
name|spcleft
operator|=
name|DIRBLKSIZ
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|bufp
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|protodir
index|[
name|i
index|]
operator|.
name|d_reclen
operator|=
name|DIRSIZ
argument_list|(
name|NEWDIRFMT
argument_list|,
operator|&
name|protodir
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|protodir
index|[
name|i
index|]
argument_list|,
name|cp
argument_list|,
name|protodir
index|[
name|i
index|]
operator|.
name|d_reclen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|protodir
index|[
name|i
index|]
operator|.
name|d_reclen
expr_stmt|;
if|if
condition|(
operator|(
name|spcleft
operator|-=
name|protodir
index|[
name|i
index|]
operator|.
name|d_reclen
operator|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: %s"
argument_list|,
name|special
argument_list|,
literal|"directory too big"
argument_list|)
expr_stmt|;
block|}
name|protodir
index|[
name|i
index|]
operator|.
name|d_reclen
operator|=
name|spcleft
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|protodir
index|[
name|i
index|]
argument_list|,
name|cp
argument_list|,
name|DIRSIZ
argument_list|(
name|NEWDIRFMT
argument_list|,
operator|&
name|protodir
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

