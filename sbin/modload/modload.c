begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 Terrence R. Lambert.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Terrence R. Lambert.  * 4. The name Terrence R. Lambert may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY TERRENCE R. LAMBERT ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE TERRENCE R. LAMBERT BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/lkm.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dounlink
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Expected linker options:  *  * -A		executable to link against  * -e		entry point  * -o		output file  * -T		address to link to in hex (assumes it's a page boundry)  *<target>	object file  */
end_comment

begin_function
name|void
name|linkcmd
parameter_list|(
name|kernel
parameter_list|,
name|entry
parameter_list|,
name|outfile
parameter_list|,
name|address
parameter_list|,
name|object
parameter_list|)
name|char
modifier|*
name|kernel
decl_stmt|,
decl|*
name|entry
decl_stmt|,
modifier|*
name|outfile
decl_stmt|;
end_function

begin_decl_stmt
name|u_int
name|address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|char
modifier|*
name|object
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|addrbuf
index|[
literal|32
index|]
decl_stmt|,
name|entrybuf
index|[
name|_POSIX2_LINE_MAX
index|]
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|snprintf
argument_list|(
name|entrybuf
argument_list|,
sizeof|sizeof
name|entrybuf
argument_list|,
literal|"_%s"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|addrbuf
argument_list|,
sizeof|sizeof
name|addrbuf
argument_list|,
literal|"%x"
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s -A %s -e %s -o %s -T %s %s\n"
argument_list|,
name|_PATH_LD
argument_list|,
name|kernel
argument_list|,
name|entrybuf
argument_list|,
name|outfile
argument_list|,
name|addrbuf
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|18
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|execl
argument_list|(
name|_PATH_LD
argument_list|,
literal|"ld"
argument_list|,
literal|"-A"
argument_list|,
name|kernel
argument_list|,
literal|"-e"
argument_list|,
name|entrybuf
argument_list|,
literal|"-o"
argument_list|,
name|outfile
argument_list|,
literal|"-T"
argument_list|,
name|addrbuf
argument_list|,
name|object
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|128
operator|+
name|errno
argument_list|)
expr_stmt|;
block|}
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s got signal: %s"
argument_list|,
name|_PATH_LD
argument_list|,
name|sys_siglist
index|[
name|WTERMSIG
argument_list|(
name|status
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|>
literal|128
condition|)
block|{
name|errno
operator|=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|-
literal|128
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"exec(%s)"
argument_list|,
name|_PATH_LD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: return code %d"
argument_list|,
name|_PATH_LD
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: modload [-d] [-v] [-q] [-u] [-A<kernel>] [-e<entry]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"               [-p<postinstall>] [-o<output file>]<input file>\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|fileopen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEV_OPEN
value|0x01
end_define

begin_define
define|#
directive|define
name|MOD_OPEN
value|0x02
end_define

begin_define
define|#
directive|define
name|PART_RESRV
value|0x04
end_define

begin_decl_stmt
name|int
name|devfd
decl_stmt|,
name|modfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lmc_resrv
name|resrv
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|fileopen
operator|&
name|PART_RESRV
condition|)
block|{
comment|/* 		 * Free up kernel memory 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|devfd
argument_list|,
name|LMUNRESRV
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|warn
argument_list|(
literal|"can't release slot 0x%08x memory"
argument_list|,
name|resrv
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fileopen
operator|&
name|DEV_OPEN
condition|)
name|close
argument_list|(
name|devfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileopen
operator|&
name|MOD_OPEN
condition|)
name|close
argument_list|(
name|modfd
argument_list|)
expr_stmt|;
name|fileopen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|kname
init|=
operator|(
name|char
operator|*
operator|)
name|getbootfile
argument_list|()
decl_stmt|;
name|char
modifier|*
name|entry
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|post
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|out
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|modobj
decl_stmt|;
name|char
name|modout
index|[
literal|80
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|exec
name|info_buf
decl_stmt|;
name|u_int
name|modsize
decl_stmt|;
comment|/* XXX */
name|u_int
name|modentry
decl_stmt|;
comment|/* XXX */
name|struct
name|lmc_loadbuf
name|ldbuf
decl_stmt|;
name|int
name|sz
decl_stmt|,
name|bytesleft
decl_stmt|;
name|char
name|buf
index|[
name|MODIOBUF
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"dvquA:e:p:o:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* debug */
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* verbose */
case|case
literal|'u'
case|:
name|dounlink
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|kname
operator|=
name|optarg
expr_stmt|;
break|break;
comment|/* kernel */
case|case
literal|'e'
case|:
name|entry
operator|=
name|optarg
expr_stmt|;
break|break;
comment|/* entry point */
case|case
literal|'p'
case|:
name|post
operator|=
name|optarg
expr_stmt|;
break|break;
comment|/* postinstall */
case|case
literal|'o'
case|:
name|out
operator|=
name|optarg
expr_stmt|;
break|break;
comment|/* output file */
case|case
literal|'?'
case|:
name|usage
argument_list|()
expr_stmt|;
default|default:
name|printf
argument_list|(
literal|"default!\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|modobj
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|atexit
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
comment|/* 	 * Open the virtual device device driver for exclusive use (needed 	 * to write the new module to it as our means of getting it in the 	 * kernel). 	 */
if|if
condition|(
operator|(
name|devfd
operator|=
name|open
argument_list|(
name|_PATH_LKM
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|3
argument_list|,
name|_PATH_LKM
argument_list|)
expr_stmt|;
name|fileopen
operator||=
name|DEV_OPEN
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|modobj
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".o"
argument_list|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"module object must end in .o"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
name|p
operator|=
name|strrchr
argument_list|(
name|modobj
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|++
expr_stmt|;
comment|/* skip over '/' */
else|else
name|p
operator|=
name|modobj
expr_stmt|;
name|snprintf
argument_list|(
name|modout
argument_list|,
sizeof|sizeof
name|modout
argument_list|,
literal|"%s%sut"
argument_list|,
name|_PATH_TMP
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|out
operator|=
name|modout
expr_stmt|;
comment|/* 		 * reverse meaning of -u - if we've generated a /tmp 		 * file, remove it automatically... 		 */
name|dounlink
operator|=
operator|!
name|dounlink
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|entry
condition|)
block|{
comment|/* calculate default entry point */
name|entry
operator|=
name|strrchr
argument_list|(
name|modobj
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
name|entry
operator|++
expr_stmt|;
comment|/* skip over '/' */
else|else
name|entry
operator|=
name|modobj
expr_stmt|;
name|entry
operator|=
name|strdup
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* so we can modify it */
if|if
condition|(
operator|!
name|entry
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Could not allocate memory"
argument_list|)
expr_stmt|;
name|entry
index|[
name|strlen
argument_list|(
name|entry
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* chop off .o */
block|}
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|modfd
operator|=
name|open
argument_list|(
name|out
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|modfd
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"creating %s"
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|modfd
argument_list|)
expr_stmt|;
comment|/* 	 * Prelink to get file size 	 */
name|linkcmd
argument_list|(
name|kname
argument_list|,
name|entry
argument_list|,
name|out
argument_list|,
literal|0
argument_list|,
name|modobj
argument_list|)
expr_stmt|;
comment|/* 	 * Pre-open the 0-linked module to get the size information 	 */
if|if
condition|(
operator|(
name|modfd
operator|=
name|open
argument_list|(
name|out
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|4
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fileopen
operator||=
name|MOD_OPEN
expr_stmt|;
comment|/* 	 * Get the load module post load size... do this by reading the 	 * header and doing page counts. 	 */
if|if
condition|(
name|read
argument_list|(
name|modfd
argument_list|,
operator|&
name|info_buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|3
argument_list|,
literal|"read `%s'"
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* 	 * Close the dummy module -- we have our sizing information. 	 */
name|close
argument_list|(
name|modfd
argument_list|)
expr_stmt|;
name|fileopen
operator|&=
operator|~
name|MOD_OPEN
expr_stmt|;
comment|/* 	 * Magic number... 	 */
if|if
condition|(
name|N_BADMAG
argument_list|(
name|info_buf
argument_list|)
condition|)
name|errx
argument_list|(
literal|4
argument_list|,
literal|"not an a.out format file"
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the size of the module 	 */
name|modsize
operator|=
name|info_buf
operator|.
name|a_text
operator|+
name|info_buf
operator|.
name|a_data
operator|+
name|info_buf
operator|.
name|a_bss
expr_stmt|;
comment|/* 	 * Reserve the required amount of kernel memory -- this may fail 	 * to be successful. 	 */
name|resrv
operator|.
name|size
operator|=
name|modsize
expr_stmt|;
comment|/* size in bytes */
name|resrv
operator|.
name|name
operator|=
name|modout
expr_stmt|;
comment|/* objname w/o ".o" */
name|resrv
operator|.
name|slot
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* returned */
name|resrv
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* returned */
if|if
condition|(
name|ioctl
argument_list|(
name|devfd
argument_list|,
name|LMRESERV
argument_list|,
operator|&
name|resrv
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|9
argument_list|,
literal|"can't reserve memory"
argument_list|)
expr_stmt|;
name|fileopen
operator||=
name|PART_RESRV
expr_stmt|;
comment|/* 	 * Relink at kernel load address 	 */
name|linkcmd
argument_list|(
name|kname
argument_list|,
name|entry
argument_list|,
name|out
argument_list|,
name|resrv
operator|.
name|addr
argument_list|,
name|modobj
argument_list|)
expr_stmt|;
comment|/* 	 * Open the relinked module to load it... 	 */
if|if
condition|(
operator|(
name|modfd
operator|=
name|open
argument_list|(
name|out
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|4
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fileopen
operator||=
name|MOD_OPEN
expr_stmt|;
comment|/* 	 * Reread the header to get the actual entry point *after* the 	 * relink. 	 */
if|if
condition|(
name|read
argument_list|(
name|modfd
argument_list|,
operator|&
name|info_buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|3
argument_list|,
literal|"read `%s'"
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* 	 * Get the entry point (for initialization) 	 */
name|modentry
operator|=
name|info_buf
operator|.
name|a_entry
expr_stmt|;
comment|/* place to call */
comment|/* 	 * Seek to the text offset to start loading... 	 */
if|if
condition|(
name|lseek
argument_list|(
name|modfd
argument_list|,
name|N_TXTOFF
argument_list|(
name|info_buf
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|12
argument_list|,
literal|"lseek"
argument_list|)
expr_stmt|;
comment|/* 	 * Transfer the relinked module to kernel memory in chunks of 	 * MODIOBUF size at a time. 	 */
for|for
control|(
name|bytesleft
operator|=
name|info_buf
operator|.
name|a_text
operator|+
name|info_buf
operator|.
name|a_data
init|;
name|bytesleft
operator|>
literal|0
condition|;
name|bytesleft
operator|-=
name|sz
control|)
block|{
name|sz
operator|=
name|min
argument_list|(
name|bytesleft
argument_list|,
name|MODIOBUF
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|modfd
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ldbuf
operator|.
name|cnt
operator|=
name|sz
expr_stmt|;
name|ldbuf
operator|.
name|data
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|devfd
argument_list|,
name|LMLOADBUF
argument_list|,
operator|&
name|ldbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|11
argument_list|,
literal|"error transferring buffer"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Save ourselves before disaster (potentially) strikes... 	 */
name|sync
argument_list|()
expr_stmt|;
comment|/* 	 * Trigger the module as loaded by calling the entry procedure; 	 * this will do all necessary table fixup to ensure that state 	 * is maintained on success, or blow everything back to ground 	 * zero on failure. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|devfd
argument_list|,
name|LMREADY
argument_list|,
operator|&
name|modentry
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|14
argument_list|,
literal|"error initializing module"
argument_list|)
expr_stmt|;
comment|/* 	 * Success! 	 */
name|fileopen
operator|&=
operator|~
name|PART_RESRV
expr_stmt|;
comment|/* loaded */
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Module loaded as ID %d\n"
argument_list|,
name|resrv
operator|.
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|dounlink
operator|&&
name|unlink
argument_list|(
name|out
argument_list|)
condition|)
name|err
argument_list|(
literal|17
argument_list|,
literal|"unlink(%s)"
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|post
condition|)
block|{
name|struct
name|lmc_stat
name|sbuf
decl_stmt|;
name|char
name|id
index|[
literal|16
index|]
decl_stmt|,
name|type
index|[
literal|16
index|]
decl_stmt|,
name|offset
index|[
literal|16
index|]
decl_stmt|;
name|sbuf
operator|.
name|id
operator|=
name|resrv
operator|.
name|slot
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|devfd
argument_list|,
name|LMSTAT
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|15
argument_list|,
literal|"error fetching module stats for post-install"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|id
argument_list|,
literal|"%d"
argument_list|,
name|sbuf
operator|.
name|id
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|type
argument_list|,
literal|"0x%x"
argument_list|,
name|sbuf
operator|.
name|type
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|offset
argument_list|,
literal|"%d"
argument_list|,
name|sbuf
operator|.
name|offset
argument_list|)
expr_stmt|;
comment|/* XXX the modload docs say that drivers can install bdevsw& 	       cdevsw, but the interface only supports one at a time.  sigh. */
comment|/* Free resources before calling post-install program */
name|cleanup
argument_list|()
expr_stmt|;
name|execl
argument_list|(
name|post
argument_list|,
name|post
argument_list|,
name|id
argument_list|,
name|type
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|16
argument_list|,
literal|"can't exec '%s'"
argument_list|,
name|post
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

