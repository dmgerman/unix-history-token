begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 Terrence R. Lambert.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Terrence R. Lambert.  * 4. The name Terrence R. Lambert may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY TERRENCE R. LAMBERT ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE TERRENCE R. LAMBERT BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: modload.c,v 1.4 1994/09/22 22:35:53 wollman Exp $  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/lkm.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DFLT_ENTRY
end_ifndef

begin_define
define|#
directive|define
name|DFLT_ENTRY
value|"xxxinit"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DFLT_ENTRY */
end_comment

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_comment
comment|/*  * Expected linker options:  *  * -A		executable to link against  * -e		entry point  * -o		output file  * -T		address to link to in hex (assumes it's a page boundry)  *<target>	object file  */
end_comment

begin_define
define|#
directive|define
name|LINKCMD
value|"ld -A %s -e _%s -o %s -T %x %s"
end_define

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dounlink
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|linkcmd
parameter_list|(
name|kernel
parameter_list|,
name|entry
parameter_list|,
name|outfile
parameter_list|,
name|address
parameter_list|,
name|object
parameter_list|)
name|char
modifier|*
name|kernel
decl_stmt|,
decl|*
name|entry
decl_stmt|,
modifier|*
name|outfile
decl_stmt|;
end_function

begin_decl_stmt
name|u_int
name|address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|char
modifier|*
name|object
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|cmdbuf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sprintf
argument_list|(
name|cmdbuf
argument_list|,
name|LINKCMD
argument_list|,
name|kernel
argument_list|,
name|entry
argument_list|,
name|outfile
argument_list|,
name|address
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|system
argument_list|(
name|cmdbuf
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* SUCCESS! */
break|break;
case|case
literal|1
case|:
comment|/* uninformitive error */
comment|/* 		 * Someone needs to fix the return values from the FreeBSD 		 * ld program -- it's totally uninformative. 		 * 		 * No such file		(4 on SunOS) 		 * Can't write output	(2 on SunOS) 		 * Undefined symbol	(1 on SunOS) 		 * etc. 		 */
case|case
literal|127
case|:
comment|/* can't load shell */
case|case
literal|32512
case|:
default|default:
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_block

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"modload [-d] [-v] [-q] [-u] [-A<kernel>] [-e<entry]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[-p<postinstall>] [-o<output file>]<input file>\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|fileopen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEV_OPEN
value|0x01
end_define

begin_define
define|#
directive|define
name|MOD_OPEN
value|0x02
end_define

begin_define
define|#
directive|define
name|PART_RESRV
value|0x04
end_define

begin_decl_stmt
name|int
name|devfd
decl_stmt|,
name|modfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lmc_resrv
name|resrv
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|fileopen
operator|&
name|PART_RESRV
condition|)
block|{
comment|/* 		 * Free up kernel memory 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|devfd
argument_list|,
name|LMUNRESRV
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|warn
argument_list|(
literal|"can't release slot 0x%08x memory"
argument_list|,
name|resrv
operator|.
name|slot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fileopen
operator|&
name|DEV_OPEN
condition|)
name|close
argument_list|(
name|devfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileopen
operator|&
name|MOD_OPEN
condition|)
name|close
argument_list|(
name|modfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|kname
init|=
operator|(
name|char
operator|*
operator|)
name|getbootfile
argument_list|()
decl_stmt|;
name|char
modifier|*
name|entry
init|=
name|DFLT_ENTRY
decl_stmt|;
name|char
modifier|*
name|post
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|out
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|modobj
decl_stmt|;
name|char
name|modout
index|[
literal|80
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|exec
name|info_buf
decl_stmt|;
name|u_int
name|modsize
decl_stmt|;
comment|/* XXX */
name|u_int
name|modentry
decl_stmt|;
comment|/* XXX */
name|struct
name|lmc_loadbuf
name|ldbuf
decl_stmt|;
name|int
name|sz
decl_stmt|,
name|bytesleft
decl_stmt|;
name|char
name|buf
index|[
name|MODIOBUF
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"dvquA:e:p:o:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* debug */
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* verbose */
case|case
literal|'u'
case|:
name|dounlink
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|kname
operator|=
name|optarg
expr_stmt|;
break|break;
comment|/* kernel */
case|case
literal|'e'
case|:
name|entry
operator|=
name|optarg
expr_stmt|;
break|break;
comment|/* entry point */
case|case
literal|'p'
case|:
name|post
operator|=
name|optarg
expr_stmt|;
break|break;
comment|/* postinstall */
case|case
literal|'o'
case|:
name|out
operator|=
name|optarg
expr_stmt|;
break|break;
comment|/* output file */
case|case
literal|'?'
case|:
name|usage
argument_list|()
expr_stmt|;
default|default:
name|printf
argument_list|(
literal|"default!\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|modobj
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|atexit
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
comment|/* 	 * Open the virtual device device driver for exclusive use (needed 	 * to write the new module to it as our means of getting it in the 	 * kernel). 	 */
if|if
condition|(
operator|(
name|devfd
operator|=
name|open
argument_list|(
name|_PATH_LKM
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|3
argument_list|,
name|_PATH_LKM
argument_list|)
expr_stmt|;
name|fileopen
operator||=
name|DEV_OPEN
expr_stmt|;
name|strcpy
argument_list|(
name|modout
argument_list|,
name|modobj
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|modout
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".o"
argument_list|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"module object must end in .o"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
block|{
name|out
operator|=
name|modout
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Prelink to get file size 	 */
if|if
condition|(
name|linkcmd
argument_list|(
name|kname
argument_list|,
name|entry
argument_list|,
name|out
argument_list|,
literal|0
argument_list|,
name|modobj
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"can't prelink `%s' creating `%s'"
argument_list|,
name|modobj
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* 	 * Pre-open the 0-linked module to get the size information 	 */
if|if
condition|(
operator|(
name|modfd
operator|=
name|open
argument_list|(
name|out
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|4
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fileopen
operator||=
name|MOD_OPEN
expr_stmt|;
comment|/* 	 * Get the load module post load size... do this by reading the 	 * header and doing page counts. 	 */
if|if
condition|(
name|read
argument_list|(
name|modfd
argument_list|,
operator|&
name|info_buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|3
argument_list|,
literal|"read `%s'"
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* 	 * Close the dummy module -- we have our sizing information. 	 */
name|close
argument_list|(
name|modfd
argument_list|)
expr_stmt|;
name|fileopen
operator|&=
operator|~
name|MOD_OPEN
expr_stmt|;
comment|/* 	 * Magic number... 	 */
if|if
condition|(
name|N_BADMAG
argument_list|(
name|info_buf
argument_list|)
condition|)
name|errx
argument_list|(
literal|4
argument_list|,
literal|"not an a.out format file"
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the size of the module 	 */
name|modsize
operator|=
name|info_buf
operator|.
name|a_text
operator|+
name|info_buf
operator|.
name|a_data
operator|+
name|info_buf
operator|.
name|a_bss
expr_stmt|;
comment|/* 	 * Reserve the required amount of kernel memory -- this may fail 	 * to be successful. 	 */
name|resrv
operator|.
name|size
operator|=
name|modsize
expr_stmt|;
comment|/* size in bytes */
name|resrv
operator|.
name|name
operator|=
name|modout
expr_stmt|;
comment|/* objname w/o ".o" */
name|resrv
operator|.
name|slot
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* returned */
name|resrv
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* returned */
if|if
condition|(
name|ioctl
argument_list|(
name|devfd
argument_list|,
name|LMRESERV
argument_list|,
operator|&
name|resrv
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|9
argument_list|,
literal|"can't reserve memory"
argument_list|)
expr_stmt|;
name|fileopen
operator||=
name|PART_RESRV
expr_stmt|;
comment|/* 	 * Relink at kernel load address 	 */
if|if
condition|(
name|linkcmd
argument_list|(
name|kname
argument_list|,
name|entry
argument_list|,
name|out
argument_list|,
name|resrv
operator|.
name|addr
argument_list|,
name|modobj
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"can't link `%s' creating `%s' bound to 0x%08x"
argument_list|,
name|modobj
argument_list|,
name|out
argument_list|,
name|resrv
operator|.
name|addr
argument_list|)
expr_stmt|;
comment|/* 	 * Open the relinked module to load it... 	 */
if|if
condition|(
operator|(
name|modfd
operator|=
name|open
argument_list|(
name|out
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|4
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fileopen
operator||=
name|MOD_OPEN
expr_stmt|;
comment|/* 	 * Reread the header to get the actual entry point *after* the 	 * relink. 	 */
if|if
condition|(
name|read
argument_list|(
name|modfd
argument_list|,
operator|&
name|info_buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|3
argument_list|,
literal|"read `%s'"
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* 	 * Get the entry point (for initialization) 	 */
name|modentry
operator|=
name|info_buf
operator|.
name|a_entry
expr_stmt|;
comment|/* place to call */
comment|/* 	 * Seek to the text offset to start loading... 	 */
if|if
condition|(
name|lseek
argument_list|(
name|modfd
argument_list|,
name|N_TXTOFF
argument_list|(
name|info_buf
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|12
argument_list|,
literal|"lseek"
argument_list|)
expr_stmt|;
comment|/* 	 * Transfer the relinked module to kernel memory in chunks of 	 * MODIOBUF size at a time. 	 */
for|for
control|(
name|bytesleft
operator|=
name|info_buf
operator|.
name|a_text
operator|+
name|info_buf
operator|.
name|a_data
init|;
name|bytesleft
operator|>
literal|0
condition|;
name|bytesleft
operator|-=
name|sz
control|)
block|{
name|sz
operator|=
name|min
argument_list|(
name|bytesleft
argument_list|,
name|MODIOBUF
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|modfd
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ldbuf
operator|.
name|cnt
operator|=
name|sz
expr_stmt|;
name|ldbuf
operator|.
name|data
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|devfd
argument_list|,
name|LMLOADBUF
argument_list|,
operator|&
name|ldbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|11
argument_list|,
literal|"error transferring buffer"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Save ourselves before disaster (potentitally) strikes... 	 */
name|sync
argument_list|()
expr_stmt|;
comment|/* 	 * Trigger the module as loaded by calling the entry procedure; 	 * this will do all necessary table fixup to ensure that state 	 * is maintained on success, or blow everything back to ground 	 * zero on failure. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|devfd
argument_list|,
name|LMREADY
argument_list|,
operator|&
name|modentry
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|14
argument_list|,
literal|"error initializing module"
argument_list|)
expr_stmt|;
comment|/* 	 * Success! 	 */
name|fileopen
operator|&=
operator|~
name|PART_RESRV
expr_stmt|;
comment|/* loaded */
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Module loaded as ID %d\n"
argument_list|,
name|resrv
operator|.
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|post
condition|)
block|{
name|struct
name|lmc_stat
name|sbuf
decl_stmt|;
name|char
name|id
index|[
literal|16
index|]
decl_stmt|,
name|type
index|[
literal|16
index|]
decl_stmt|,
name|offset
index|[
literal|16
index|]
decl_stmt|;
name|sbuf
operator|.
name|id
operator|=
name|resrv
operator|.
name|slot
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|devfd
argument_list|,
name|LMSTAT
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|15
argument_list|,
literal|"error fetching module stats for post-install"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|id
argument_list|,
literal|"%d"
argument_list|,
name|sbuf
operator|.
name|id
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|type
argument_list|,
literal|"0x%x"
argument_list|,
name|sbuf
operator|.
name|type
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|offset
argument_list|,
literal|"%d"
argument_list|,
name|sbuf
operator|.
name|offset
argument_list|)
expr_stmt|;
comment|/* XXX the modload docs say that drivers can install bdevsw& 	       cdevsw, but the interface only supports one at a time.  sigh. */
name|execl
argument_list|(
name|post
argument_list|,
name|post
argument_list|,
name|id
argument_list|,
name|type
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|16
argument_list|,
literal|"can't exec '%s'"
argument_list|,
name|post
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dounlink
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|out
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|17
argument_list|,
literal|"unlink(%s)"
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

