begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2012 Semihalf.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/fdcio.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/uuid.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<libgeom.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fs/nandfs/nandfs_fs.h>
end_include

begin_include
include|#
directive|include
file|<dev/nand/nand_dev.h>
end_include

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_undef
undef|#
directive|undef
name|DEBUG
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|debug
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do { \ 	printf("nandfs:" fmt "\n", ##args); } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debug
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NANDFS_FIRST_BLOCK
value|nandfs_first_block()
end_define

begin_define
define|#
directive|define
name|NANDFS_FIRST_CNO
value|1
end_define

begin_define
define|#
directive|define
name|NANDFS_BLOCK_BAD
value|1
end_define

begin_define
define|#
directive|define
name|NANDFS_BLOCK_GOOD
value|0
end_define

begin_struct
struct|struct
name|file_info
block|{
name|uint64_t
name|ino
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint32_t
name|mode
decl_stmt|;
name|uint64_t
name|size
decl_stmt|;
name|uint8_t
name|nblocks
decl_stmt|;
name|uint32_t
modifier|*
name|blocks
decl_stmt|;
name|struct
name|nandfs_inode
modifier|*
name|inode
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|file_info
name|user_files
index|[]
init|=
block|{
block|{
name|NANDFS_ROOT_INO
block|,
name|NULL
block|,
name|S_IFDIR
operator||
literal|0755
block|,
literal|0
block|,
literal|1
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_info
name|ifile
init|=
block|{
name|NANDFS_IFILE_INO
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_info
name|sufile
init|=
block|{
name|NANDFS_SUFILE_INO
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_info
name|cpfile
init|=
block|{
name|NANDFS_CPFILE_INO
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_info
name|datfile
init|=
block|{
name|NANDFS_DAT_INO
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|nandfs_block
block|{
name|LIST_ENTRY
argument_list|(
argument|nandfs_block
argument_list|)
name|block_link
expr_stmt|;
name|uint32_t
name|number
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|nandfs_block
argument_list|)
name|block_head
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
operator|&
name|block_head
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Storage geometry */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|mediasize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ssize_t
name|sectorsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|nsegments
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|erasesize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|segsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nandfs_fsdata
name|fsdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nandfs_super_block
name|super_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_nand
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nandfs parameters */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|blocksize
init|=
name|NANDFS_DEF_BLOCKSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|blocks_per_segment
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|rsv_segment_percent
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|nandfs_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|bad_segments_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
modifier|*
name|bad_segments
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|fsdata_blocks_state
index|[
name|NANDFS_NFSAREAS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|volumelabel
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nandfs_super_root
modifier|*
name|sr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|nuserfiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|seg_nblocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|seg_endblock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SIZE_TO_BLOCK
parameter_list|(
name|size
parameter_list|)
value|(((size) + (blocksize - 1)) / blocksize)
end_define

begin_function
specifier|static
name|uint32_t
name|nandfs_first_block
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|,
name|first_free
decl_stmt|,
name|start_bad_segments
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bad_segments_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|bad_segments
index|[
name|i
index|]
condition|)
name|start_bad_segments
operator|++
expr_stmt|;
else|else
break|break;
block|}
name|first_free
operator|=
name|SIZE_TO_BLOCK
argument_list|(
name|NANDFS_DATA_OFFSET_BYTES
argument_list|(
name|erasesize
argument_list|)
operator|+
operator|(
name|start_bad_segments
operator|*
name|segsize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_free
operator|<
operator|(
name|uint32_t
operator|)
name|blocks_per_segment
condition|)
return|return
operator|(
name|blocks_per_segment
operator|)
return|;
else|else
return|return
operator|(
name|first_free
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: newfs_nandfs [ -options ] device\n"
literal|"where the options are:\n"
literal|"\t-b block-size\n"
literal|"\t-B blocks-per-segment\n"
literal|"\t-L volume label\n"
literal|"\t-m reserved-segments-percentage\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_log2
parameter_list|(
name|unsigned
name|n
parameter_list|)
block|{
name|unsigned
name|count
decl_stmt|;
comment|/* 	 * N.B. this function will return 0 if supplied 0. 	 */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|n
operator|/
literal|2
condition|;
name|count
operator|++
control|)
name|n
operator|/=
literal|2
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* from NetBSD's src/sys/net/if_ethersubr.c */
end_comment

begin_function
specifier|static
name|uint32_t
name|crc32_le
parameter_list|(
name|uint32_t
name|crc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|static
specifier|const
name|uint32_t
name|crctab
index|[]
init|=
block|{
literal|0x00000000
block|,
literal|0x1db71064
block|,
literal|0x3b6e20c8
block|,
literal|0x26d930ac
block|,
literal|0x76dc4190
block|,
literal|0x6b6b51f4
block|,
literal|0x4db26158
block|,
literal|0x5005713c
block|,
literal|0xedb88320
block|,
literal|0xf00f9344
block|,
literal|0xd6d6a3e8
block|,
literal|0xcb61b38c
block|,
literal|0x9b64c2b0
block|,
literal|0x86d3d2d4
block|,
literal|0xa00ae278
block|,
literal|0xbdbdf21c
block|}
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|crc
operator|=
name|crc
operator|^
operator|~
literal|0U
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|crc
operator|^=
name|buf
index|[
name|i
index|]
expr_stmt|;
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|4
operator|)
operator|^
name|crctab
index|[
name|crc
operator|&
literal|0xf
index|]
expr_stmt|;
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|4
operator|)
operator|^
name|crctab
index|[
name|crc
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
return|return
operator|(
name|crc
operator|^
operator|~
literal|0U
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_block
parameter_list|(
name|uint32_t
name|block_nr
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
name|struct
name|nandfs_block
modifier|*
name|block
decl_stmt|,
modifier|*
name|new_block
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|block
argument_list|,
argument|&block_head
argument_list|,
argument|block_link
argument_list|)
block|{
if|if
condition|(
name|block
operator|->
name|number
operator|==
name|block_nr
condition|)
return|return
name|block
operator|->
name|data
return|;
block|}
name|debug
argument_list|(
literal|"allocating block %x\n"
argument_list|,
name|block_nr
argument_list|)
expr_stmt|;
name|new_block
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_block
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cannot allocate block"
argument_list|)
expr_stmt|;
name|new_block
operator|->
name|number
operator|=
name|block_nr
expr_stmt|;
name|new_block
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|new_block
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_block
operator|->
name|data
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cannot allocate block data"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_block
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|block_head
argument_list|,
name|new_block
argument_list|,
name|block_link
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_block
operator|->
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_seg_usage_blk_offset
parameter_list|(
name|uint64_t
name|seg
parameter_list|,
name|uint64_t
modifier|*
name|blk
parameter_list|,
name|uint64_t
modifier|*
name|offset
parameter_list|)
block|{
name|uint64_t
name|off
decl_stmt|;
name|uint16_t
name|seg_size
decl_stmt|;
name|seg_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_segment_usage
argument_list|)
expr_stmt|;
name|off
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_sufile_header
argument_list|)
argument_list|,
name|seg_size
argument_list|)
expr_stmt|;
name|off
operator|+=
operator|(
name|seg
operator|*
name|seg_size
operator|)
expr_stmt|;
operator|*
name|blk
operator|=
name|off
operator|/
name|blocksize
expr_stmt|;
operator|*
name|offset
operator|=
operator|(
name|off
operator|%
name|blocksize
operator|)
operator|/
name|seg_size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|segment_size
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|size
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_segment_summary
argument_list|)
expr_stmt|;
name|size
operator|+=
name|seg_nblocks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_binfo_v
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|blocksize
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"segsum info bigger that blocksize"
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prepare_blockgrouped_file
parameter_list|(
name|uint32_t
name|block
parameter_list|)
block|{
name|struct
name|nandfs_block_group_desc
modifier|*
name|desc
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|entries
decl_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|nandfs_block_group_desc
operator|*
operator|)
name|get_block
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|entries
operator|=
name|blocksize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_block_group_desc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
condition|;
name|i
operator|++
control|)
name|desc
index|[
name|i
index|]
operator|.
name|bg_nfrees
operator|=
name|blocksize
operator|*
literal|8
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|alloc_blockgrouped_file
parameter_list|(
name|uint32_t
name|block
parameter_list|,
name|uint32_t
name|entry
parameter_list|)
block|{
name|struct
name|nandfs_block_group_desc
modifier|*
name|desc
decl_stmt|;
name|uint32_t
name|desc_nr
decl_stmt|;
name|uint32_t
modifier|*
name|bitmap
decl_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|nandfs_block_group_desc
operator|*
operator|)
name|get_block
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bitmap
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|get_block
argument_list|(
name|block
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bitmap
operator|+=
operator|(
name|entry
operator|>>
literal|5
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|bitmap
operator|&
operator|(
literal|1
operator|<<
operator|(
name|entry
operator|%
literal|32
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"nandfs: blockgrouped entry %d already allocated\n"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
operator|*
name|bitmap
operator||=
operator|(
literal|1
operator|<<
operator|(
name|entry
operator|%
literal|32
operator|)
operator|)
expr_stmt|;
name|desc_nr
operator|=
name|entry
operator|/
operator|(
name|blocksize
operator|*
literal|8
operator|)
expr_stmt|;
name|desc
index|[
name|desc_nr
index|]
operator|.
name|bg_nfrees
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|count_su_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|maxblk
decl_stmt|,
name|blk
decl_stmt|,
name|offset
decl_stmt|,
name|i
decl_stmt|;
name|maxblk
operator|=
name|blk
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bad_segments_count
condition|;
name|i
operator|++
control|)
block|{
name|nandfs_seg_usage_blk_offset
argument_list|(
name|bad_segments
index|[
name|i
index|]
argument_list|,
operator|&
name|blk
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"bad segment at block:%jx off: %jx"
argument_list|,
name|blk
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|>
name|maxblk
condition|)
name|maxblk
operator|=
name|blk
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"bad segment needs %#jx"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|>=
name|NDADDR
condition|)
block|{
name|printf
argument_list|(
literal|"nandfs: file too big (%jd> %d)\n"
argument_list|,
name|blk
argument_list|,
name|NDADDR
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|sufile
operator|.
name|size
operator|=
operator|(
name|blk
operator|+
literal|1
operator|)
operator|*
name|blocksize
expr_stmt|;
return|return
operator|(
name|blk
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|count_seg_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nuserfiles
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|user_files
index|[
name|i
index|]
operator|.
name|nblocks
condition|)
block|{
name|seg_nblocks
operator|+=
name|user_files
index|[
name|i
index|]
operator|.
name|nblocks
expr_stmt|;
name|user_files
index|[
name|i
index|]
operator|.
name|blocks
operator|=
name|malloc
argument_list|(
name|user_files
index|[
name|i
index|]
operator|.
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ifile
operator|.
name|nblocks
operator|=
literal|2
operator|+
name|SIZE_TO_BLOCK
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_inode
argument_list|)
operator|*
operator|(
name|NANDFS_USER_INO
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|ifile
operator|.
name|blocks
operator|=
name|malloc
argument_list|(
name|ifile
operator|.
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|seg_nblocks
operator|+=
name|ifile
operator|.
name|nblocks
expr_stmt|;
name|cpfile
operator|.
name|nblocks
operator|=
name|SIZE_TO_BLOCK
argument_list|(
operator|(
name|NANDFS_CPFILE_FIRST_CHECKPOINT_OFFSET
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_checkpoint
argument_list|)
argument_list|)
expr_stmt|;
name|cpfile
operator|.
name|blocks
operator|=
name|malloc
argument_list|(
name|cpfile
operator|.
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|seg_nblocks
operator|+=
name|cpfile
operator|.
name|nblocks
expr_stmt|;
if|if
condition|(
operator|!
name|bad_segments
condition|)
block|{
name|sufile
operator|.
name|nblocks
operator|=
name|SIZE_TO_BLOCK
argument_list|(
operator|(
name|NANDFS_SUFILE_FIRST_SEGMENT_USAGE_OFFSET
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_segment_usage
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"bad blocks found: extra space for sufile"
argument_list|)
expr_stmt|;
name|sufile
operator|.
name|nblocks
operator|=
name|count_su_blocks
argument_list|()
expr_stmt|;
block|}
name|sufile
operator|.
name|blocks
operator|=
name|malloc
argument_list|(
name|sufile
operator|.
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|seg_nblocks
operator|+=
name|sufile
operator|.
name|nblocks
expr_stmt|;
name|datfile
operator|.
name|nblocks
operator|=
literal|2
operator|+
name|SIZE_TO_BLOCK
argument_list|(
operator|(
name|seg_nblocks
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_dat_entry
argument_list|)
argument_list|)
expr_stmt|;
name|datfile
operator|.
name|blocks
operator|=
name|malloc
argument_list|(
name|datfile
operator|.
name|nblocks
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|seg_nblocks
operator|+=
name|datfile
operator|.
name|nblocks
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|assign_file_blocks
parameter_list|(
name|uint64_t
name|start_block
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nuserfiles
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|user_files
index|[
name|i
index|]
operator|.
name|nblocks
condition|;
name|j
operator|++
control|)
block|{
name|debug
argument_list|(
literal|"user file %d at block %d at %#jx"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
operator|(
name|uintmax_t
operator|)
name|start_block
argument_list|)
expr_stmt|;
name|user_files
index|[
name|i
index|]
operator|.
name|blocks
index|[
name|j
index|]
operator|=
name|start_block
operator|++
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ifile
operator|.
name|nblocks
condition|;
name|j
operator|++
control|)
block|{
name|debug
argument_list|(
literal|"ifile block %d at %#jx"
argument_list|,
name|j
argument_list|,
operator|(
name|uintmax_t
operator|)
name|start_block
argument_list|)
expr_stmt|;
name|ifile
operator|.
name|blocks
index|[
name|j
index|]
operator|=
name|start_block
operator|++
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cpfile
operator|.
name|nblocks
condition|;
name|j
operator|++
control|)
block|{
name|debug
argument_list|(
literal|"cpfile block %d at %#jx"
argument_list|,
name|j
argument_list|,
operator|(
name|uintmax_t
operator|)
name|start_block
argument_list|)
expr_stmt|;
name|cpfile
operator|.
name|blocks
index|[
name|j
index|]
operator|=
name|start_block
operator|++
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sufile
operator|.
name|nblocks
condition|;
name|j
operator|++
control|)
block|{
name|debug
argument_list|(
literal|"sufile block %d at %#jx"
argument_list|,
name|j
argument_list|,
operator|(
name|uintmax_t
operator|)
name|start_block
argument_list|)
expr_stmt|;
name|sufile
operator|.
name|blocks
index|[
name|j
index|]
operator|=
name|start_block
operator|++
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|datfile
operator|.
name|nblocks
condition|;
name|j
operator|++
control|)
block|{
name|debug
argument_list|(
literal|"datfile block %d at %#jx"
argument_list|,
name|j
argument_list|,
operator|(
name|uintmax_t
operator|)
name|start_block
argument_list|)
expr_stmt|;
name|datfile
operator|.
name|blocks
index|[
name|j
index|]
operator|=
name|start_block
operator|++
expr_stmt|;
block|}
comment|/* add one for superroot */
name|debug
argument_list|(
literal|"sr at block %#jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|start_block
argument_list|)
expr_stmt|;
name|sr
operator|=
operator|(
expr|struct
name|nandfs_super_root
operator|*
operator|)
name|get_block
argument_list|(
name|start_block
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seg_endblock
operator|=
name|start_block
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_datfile
parameter_list|(
name|void
parameter_list|)
block|{
name|prepare_blockgrouped_file
argument_list|(
name|datfile
operator|.
name|blocks
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|update_datfile
parameter_list|(
name|uint64_t
name|block
parameter_list|)
block|{
name|struct
name|nandfs_dat_entry
modifier|*
name|dat
decl_stmt|;
specifier|static
name|uint64_t
name|vblock
init|=
literal|0
decl_stmt|;
name|uint64_t
name|allocated
decl_stmt|,
name|i
decl_stmt|,
name|off
decl_stmt|;
if|if
condition|(
name|vblock
operator|==
literal|0
condition|)
block|{
name|alloc_blockgrouped_file
argument_list|(
name|datfile
operator|.
name|blocks
index|[
literal|0
index|]
argument_list|,
name|vblock
argument_list|)
expr_stmt|;
name|vblock
operator|++
expr_stmt|;
block|}
name|allocated
operator|=
name|vblock
expr_stmt|;
name|i
operator|=
name|vblock
operator|/
operator|(
name|blocksize
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|dat
argument_list|)
operator|)
expr_stmt|;
name|off
operator|=
name|vblock
operator|%
operator|(
name|blocksize
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|dat
argument_list|)
operator|)
expr_stmt|;
name|vblock
operator|++
expr_stmt|;
name|dat
operator|=
operator|(
expr|struct
name|nandfs_dat_entry
operator|*
operator|)
name|get_block
argument_list|(
name|datfile
operator|.
name|blocks
index|[
literal|2
operator|+
name|i
index|]
argument_list|,
literal|2
operator|+
name|i
argument_list|)
expr_stmt|;
name|alloc_blockgrouped_file
argument_list|(
name|datfile
operator|.
name|blocks
index|[
literal|0
index|]
argument_list|,
name|allocated
argument_list|)
expr_stmt|;
name|dat
index|[
name|off
index|]
operator|.
name|de_blocknr
operator|=
name|block
expr_stmt|;
name|dat
index|[
name|off
index|]
operator|.
name|de_start
operator|=
name|NANDFS_FIRST_CNO
expr_stmt|;
name|dat
index|[
name|off
index|]
operator|.
name|de_end
operator|=
name|UINTMAX_MAX
expr_stmt|;
return|return
operator|(
name|allocated
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|union
name|nandfs_binfo
modifier|*
name|update_block_info
parameter_list|(
name|union
name|nandfs_binfo
modifier|*
name|binfo
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|)
block|{
name|nandfs_daddr_t
name|vblock
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file
operator|->
name|nblocks
condition|;
name|i
operator|++
control|)
block|{
name|debug
argument_list|(
literal|"%s: blk %x"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|ino
operator|!=
name|NANDFS_DAT_INO
condition|)
block|{
name|vblock
operator|=
name|update_datfile
argument_list|(
name|file
operator|->
name|blocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|binfo
operator|->
name|bi_v
operator|.
name|bi_vblocknr
operator|=
name|vblock
expr_stmt|;
name|binfo
operator|->
name|bi_v
operator|.
name|bi_blkoff
operator|=
name|i
expr_stmt|;
name|binfo
operator|->
name|bi_v
operator|.
name|bi_ino
operator|=
name|file
operator|->
name|ino
expr_stmt|;
name|file
operator|->
name|inode
operator|->
name|i_db
index|[
name|i
index|]
operator|=
name|vblock
expr_stmt|;
block|}
else|else
block|{
name|binfo
operator|->
name|bi_dat
operator|.
name|bi_blkoff
operator|=
name|i
expr_stmt|;
name|binfo
operator|->
name|bi_dat
operator|.
name|bi_ino
operator|=
name|file
operator|->
name|ino
expr_stmt|;
name|file
operator|->
name|inode
operator|->
name|i_db
index|[
name|i
index|]
operator|=
name|datfile
operator|.
name|blocks
index|[
name|i
index|]
expr_stmt|;
block|}
name|binfo
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|binfo
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_segsum
parameter_list|(
name|struct
name|nandfs_segment_summary
modifier|*
name|ss
parameter_list|)
block|{
name|union
name|nandfs_binfo
modifier|*
name|binfo
decl_stmt|;
name|struct
name|nandfs_block
modifier|*
name|block
decl_stmt|;
name|uint32_t
name|sum_bytes
decl_stmt|,
name|i
decl_stmt|;
name|uint8_t
name|crc_data
decl_stmt|,
name|crc_skip
decl_stmt|;
name|sum_bytes
operator|=
name|segment_size
argument_list|()
expr_stmt|;
name|ss
operator|->
name|ss_magic
operator|=
name|NANDFS_SEGSUM_MAGIC
expr_stmt|;
name|ss
operator|->
name|ss_bytes
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_segment_summary
argument_list|)
expr_stmt|;
name|ss
operator|->
name|ss_flags
operator|=
name|NANDFS_SS_LOGBGN
operator||
name|NANDFS_SS_LOGEND
operator||
name|NANDFS_SS_SR
expr_stmt|;
name|ss
operator|->
name|ss_seq
operator|=
literal|1
expr_stmt|;
name|ss
operator|->
name|ss_create
operator|=
name|nandfs_time
expr_stmt|;
name|ss
operator|->
name|ss_next
operator|=
name|nandfs_first_block
argument_list|()
operator|+
name|blocks_per_segment
expr_stmt|;
comment|/* nblocks = segment blocks + segsum block + superroot */
name|ss
operator|->
name|ss_nblocks
operator|=
name|seg_nblocks
operator|+
literal|2
expr_stmt|;
name|ss
operator|->
name|ss_nbinfos
operator|=
name|seg_nblocks
expr_stmt|;
name|ss
operator|->
name|ss_sumbytes
operator|=
name|sum_bytes
expr_stmt|;
name|crc_skip
operator|=
sizeof|sizeof
argument_list|(
name|ss
operator|->
name|ss_datasum
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ss
operator|->
name|ss_sumsum
argument_list|)
expr_stmt|;
name|ss
operator|->
name|ss_sumsum
operator|=
name|crc32_le
argument_list|(
literal|0
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|ss
operator|+
name|crc_skip
argument_list|,
name|sum_bytes
operator|-
name|crc_skip
argument_list|)
expr_stmt|;
name|crc_data
operator|=
literal|0
expr_stmt|;
name|binfo
operator|=
operator|(
expr|union
name|nandfs_binfo
operator|*
operator|)
operator|(
name|ss
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nuserfiles
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|user_files
index|[
name|i
index|]
operator|.
name|nblocks
condition|)
name|binfo
operator|=
name|update_block_info
argument_list|(
name|binfo
argument_list|,
operator|&
name|user_files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|binfo
operator|=
name|update_block_info
argument_list|(
name|binfo
argument_list|,
operator|&
name|ifile
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|update_block_info
argument_list|(
name|binfo
argument_list|,
operator|&
name|cpfile
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|update_block_info
argument_list|(
name|binfo
argument_list|,
operator|&
name|sufile
argument_list|)
expr_stmt|;
name|update_block_info
argument_list|(
name|binfo
argument_list|,
operator|&
name|datfile
argument_list|)
expr_stmt|;
comment|/* save superroot crc */
name|crc_skip
operator|=
sizeof|sizeof
argument_list|(
name|sr
operator|->
name|sr_sum
argument_list|)
expr_stmt|;
name|sr
operator|->
name|sr_sum
operator|=
name|crc32_le
argument_list|(
literal|0
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|sr
operator|+
name|crc_skip
argument_list|,
name|NANDFS_SR_BYTES
operator|-
name|crc_skip
argument_list|)
expr_stmt|;
comment|/* segment checksup */
name|crc_skip
operator|=
sizeof|sizeof
argument_list|(
name|ss
operator|->
name|ss_datasum
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|block
argument_list|,
argument|&block_head
argument_list|,
argument|block_link
argument_list|)
block|{
if|if
condition|(
name|block
operator|->
name|number
operator|<
name|NANDFS_FIRST_BLOCK
condition|)
continue|continue;
if|if
condition|(
name|block
operator|->
name|number
operator|==
name|NANDFS_FIRST_BLOCK
condition|)
name|crc_data
operator|=
name|crc32_le
argument_list|(
literal|0
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|block
operator|->
name|data
operator|+
name|crc_skip
argument_list|,
name|blocksize
operator|-
name|crc_skip
argument_list|)
expr_stmt|;
else|else
name|crc_data
operator|=
name|crc32_le
argument_list|(
name|crc_data
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|block
operator|->
name|data
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
block|}
name|ss
operator|->
name|ss_datasum
operator|=
name|crc_data
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_fsdata
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|uuid
name|tmp
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fsdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_fsdata
argument_list|)
argument_list|)
expr_stmt|;
name|fsdata
operator|.
name|f_magic
operator|=
name|NANDFS_FSDATA_MAGIC
expr_stmt|;
name|fsdata
operator|.
name|f_nsegments
operator|=
name|nsegments
expr_stmt|;
name|fsdata
operator|.
name|f_erasesize
operator|=
name|erasesize
expr_stmt|;
name|fsdata
operator|.
name|f_first_data_block
operator|=
name|NANDFS_FIRST_BLOCK
expr_stmt|;
name|fsdata
operator|.
name|f_blocks_per_segment
operator|=
name|blocks_per_segment
expr_stmt|;
name|fsdata
operator|.
name|f_r_segments_percentage
operator|=
name|rsv_segment_percent
expr_stmt|;
name|fsdata
operator|.
name|f_rev_level
operator|=
name|NANDFS_CURRENT_REV
expr_stmt|;
name|fsdata
operator|.
name|f_sbbytes
operator|=
name|NANDFS_SB_BYTES
expr_stmt|;
name|fsdata
operator|.
name|f_bytes
operator|=
name|NANDFS_FSDATA_CRC_BYTES
expr_stmt|;
name|fsdata
operator|.
name|f_ctime
operator|=
name|nandfs_time
expr_stmt|;
name|fsdata
operator|.
name|f_log_block_size
operator|=
name|nandfs_log2
argument_list|(
name|blocksize
argument_list|)
operator|-
literal|10
expr_stmt|;
name|fsdata
operator|.
name|f_errors
operator|=
literal|1
expr_stmt|;
name|fsdata
operator|.
name|f_inode_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_inode
argument_list|)
expr_stmt|;
name|fsdata
operator|.
name|f_dat_entry_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_dat_entry
argument_list|)
expr_stmt|;
name|fsdata
operator|.
name|f_checkpoint_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_checkpoint
argument_list|)
expr_stmt|;
name|fsdata
operator|.
name|f_segment_usage_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_segment_usage
argument_list|)
expr_stmt|;
name|uuidgen
argument_list|(
operator|&
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fsdata
operator|.
name|f_uuid
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|volumelabel
condition|)
name|memcpy
argument_list|(
name|fsdata
operator|.
name|f_volume_name
argument_list|,
name|volumelabel
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|fsdata
operator|.
name|f_sum
operator|=
name|crc32_le
argument_list|(
literal|0
argument_list|,
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|&
name|fsdata
argument_list|,
name|NANDFS_FSDATA_CRC_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_fsdata
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|memcpy
argument_list|(
name|data
argument_list|,
operator|&
name|fsdata
argument_list|,
sizeof|sizeof
argument_list|(
name|fsdata
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_super_block
parameter_list|(
name|void
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|super_block
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_super_block
argument_list|)
argument_list|)
expr_stmt|;
name|super_block
operator|.
name|s_magic
operator|=
name|NANDFS_SUPER_MAGIC
expr_stmt|;
name|super_block
operator|.
name|s_last_cno
operator|=
name|NANDFS_FIRST_CNO
expr_stmt|;
name|super_block
operator|.
name|s_last_pseg
operator|=
name|NANDFS_FIRST_BLOCK
expr_stmt|;
name|super_block
operator|.
name|s_last_seq
operator|=
literal|1
expr_stmt|;
name|super_block
operator|.
name|s_free_blocks_count
operator|=
operator|(
name|nsegments
operator|-
name|bad_segments_count
operator|)
operator|*
name|blocks_per_segment
expr_stmt|;
name|super_block
operator|.
name|s_mtime
operator|=
literal|0
expr_stmt|;
name|super_block
operator|.
name|s_wtime
operator|=
name|nandfs_time
expr_stmt|;
name|super_block
operator|.
name|s_state
operator|=
name|NANDFS_VALID_FS
expr_stmt|;
name|super_block
operator|.
name|s_sum
operator|=
name|crc32_le
argument_list|(
literal|0
argument_list|,
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|&
name|super_block
argument_list|,
name|NANDFS_SB_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_super_block
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|memcpy
argument_list|(
name|data
argument_list|,
operator|&
name|super_block
argument_list|,
sizeof|sizeof
argument_list|(
name|super_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_super_root
parameter_list|(
name|void
parameter_list|)
block|{
name|sr
operator|->
name|sr_bytes
operator|=
name|NANDFS_SR_BYTES
expr_stmt|;
name|sr
operator|->
name|sr_flags
operator|=
literal|0
expr_stmt|;
name|sr
operator|->
name|sr_nongc_ctime
operator|=
name|nandfs_time
expr_stmt|;
name|datfile
operator|.
name|inode
operator|=
operator|&
name|sr
operator|->
name|sr_dat
expr_stmt|;
name|cpfile
operator|.
name|inode
operator|=
operator|&
name|sr
operator|->
name|sr_cpfile
expr_stmt|;
name|sufile
operator|.
name|inode
operator|=
operator|&
name|sr
operator|->
name|sr_sufile
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|nandfs_dir_entry
modifier|*
name|add_de
parameter_list|(
name|void
modifier|*
name|block
parameter_list|,
name|struct
name|nandfs_dir_entry
modifier|*
name|de
parameter_list|,
name|uint64_t
name|ino
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
name|type
parameter_list|)
block|{
name|uint16_t
name|reclen
decl_stmt|;
comment|/* modify last de */
name|de
operator|->
name|rec_len
operator|=
name|NANDFS_DIR_REC_LEN
argument_list|(
name|de
operator|->
name|name_len
argument_list|)
expr_stmt|;
name|de
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|de
operator|+
name|de
operator|->
name|rec_len
operator|)
expr_stmt|;
name|reclen
operator|=
name|blocksize
operator|-
operator|(
operator|(
name|uintptr_t
operator|)
name|de
operator|-
operator|(
name|uintptr_t
operator|)
name|block
operator|)
expr_stmt|;
if|if
condition|(
name|reclen
operator|<
name|NANDFS_DIR_REC_LEN
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"nandfs: too many dir entries for one block\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|de
operator|->
name|inode
operator|=
name|ino
expr_stmt|;
name|de
operator|->
name|rec_len
operator|=
name|reclen
expr_stmt|;
name|de
operator|->
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|de
operator|->
name|file_type
operator|=
name|type
expr_stmt|;
name|memset
argument_list|(
name|de
operator|->
name|name
argument_list|,
literal|0
argument_list|,
operator|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|NANDFS_DIR_PAD
operator|-
literal|1
operator|)
operator|&
operator|~
name|NANDFS_DIR_ROUND
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|de
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|de
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|nandfs_dir_entry
modifier|*
name|make_dir
parameter_list|(
name|void
modifier|*
name|block
parameter_list|,
name|uint64_t
name|ino
parameter_list|,
name|uint64_t
name|parent_ino
parameter_list|)
block|{
name|struct
name|nandfs_dir_entry
modifier|*
name|de
init|=
operator|(
expr|struct
name|nandfs_dir_entry
operator|*
operator|)
name|block
decl_stmt|;
comment|/* create '..' entry */
name|de
operator|->
name|inode
operator|=
name|parent_ino
expr_stmt|;
name|de
operator|->
name|rec_len
operator|=
name|NANDFS_DIR_REC_LEN
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|de
operator|->
name|name_len
operator|=
literal|2
expr_stmt|;
name|de
operator|->
name|file_type
operator|=
name|DT_DIR
expr_stmt|;
name|memset
argument_list|(
name|de
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|NANDFS_DIR_NAME_LEN
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|de
operator|->
name|name
argument_list|,
literal|".."
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* create '.' entry */
name|de
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|block
operator|+
name|NANDFS_DIR_REC_LEN
argument_list|(
literal|2
argument_list|)
operator|)
expr_stmt|;
name|de
operator|->
name|inode
operator|=
name|ino
expr_stmt|;
name|de
operator|->
name|rec_len
operator|=
name|blocksize
operator|-
name|NANDFS_DIR_REC_LEN
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|de
operator|->
name|name_len
operator|=
literal|1
expr_stmt|;
name|de
operator|->
name|file_type
operator|=
name|DT_DIR
expr_stmt|;
name|memset
argument_list|(
name|de
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|NANDFS_DIR_NAME_LEN
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|de
operator|->
name|name
argument_list|,
literal|"."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|de
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_root_dir
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|file_info
modifier|*
name|root
init|=
operator|&
name|user_files
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|nandfs_dir_entry
modifier|*
name|de
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|void
modifier|*
name|block
decl_stmt|;
name|block
operator|=
name|get_block
argument_list|(
name|root
operator|->
name|blocks
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|de
operator|=
name|make_dir
argument_list|(
name|block
argument_list|,
name|root
operator|->
name|ino
argument_list|,
name|root
operator|->
name|ino
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nuserfiles
condition|;
name|i
operator|++
control|)
name|de
operator|=
name|add_de
argument_list|(
name|block
argument_list|,
name|de
argument_list|,
name|user_files
index|[
name|i
index|]
operator|.
name|ino
argument_list|,
name|user_files
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|IFTODT
argument_list|(
name|user_files
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|root
operator|->
name|size
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|de
operator|-
operator|(
name|uintptr_t
operator|)
name|block
operator|)
operator|+
name|NANDFS_DIR_REC_LEN
argument_list|(
name|de
operator|->
name|name_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_sufile
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|nandfs_sufile_header
modifier|*
name|header
decl_stmt|;
name|struct
name|nandfs_segment_usage
modifier|*
name|su
decl_stmt|;
name|uint64_t
name|blk
decl_stmt|,
name|i
decl_stmt|,
name|off
decl_stmt|;
name|void
modifier|*
name|block
decl_stmt|;
name|int
name|start
decl_stmt|;
comment|/* 	 * At the beginning just zero-out everything 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sufile
operator|.
name|nblocks
condition|;
name|i
operator|++
control|)
name|get_block
argument_list|(
name|sufile
operator|.
name|blocks
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|block
operator|=
name|get_block
argument_list|(
name|sufile
operator|.
name|blocks
index|[
name|start
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|header
operator|=
operator|(
expr|struct
name|nandfs_sufile_header
operator|*
operator|)
name|block
expr_stmt|;
name|header
operator|->
name|sh_ncleansegs
operator|=
name|nsegments
operator|-
name|bad_segments_count
operator|-
literal|1
expr_stmt|;
name|header
operator|->
name|sh_ndirtysegs
operator|=
literal|1
expr_stmt|;
name|header
operator|->
name|sh_last_alloc
operator|=
literal|1
expr_stmt|;
name|su
operator|=
operator|(
expr|struct
name|nandfs_segment_usage
operator|*
operator|)
name|header
expr_stmt|;
name|off
operator|=
name|NANDFS_SUFILE_FIRST_SEGMENT_USAGE_OFFSET
expr_stmt|;
comment|/* Allocate data segment */
name|su
index|[
name|off
index|]
operator|.
name|su_lastmod
operator|=
name|nandfs_time
expr_stmt|;
comment|/* nblocks = segment blocks + segsum block + superroot */
name|su
index|[
name|off
index|]
operator|.
name|su_nblocks
operator|=
name|seg_nblocks
operator|+
literal|2
expr_stmt|;
name|su
index|[
name|off
index|]
operator|.
name|su_flags
operator|=
name|NANDFS_SEGMENT_USAGE_DIRTY
expr_stmt|;
name|off
operator|++
expr_stmt|;
comment|/* Allocate next segment */
name|su
index|[
name|off
index|]
operator|.
name|su_lastmod
operator|=
name|nandfs_time
expr_stmt|;
name|su
index|[
name|off
index|]
operator|.
name|su_nblocks
operator|=
literal|0
expr_stmt|;
name|su
index|[
name|off
index|]
operator|.
name|su_flags
operator|=
name|NANDFS_SEGMENT_USAGE_DIRTY
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bad_segments_count
condition|;
name|i
operator|++
control|)
block|{
name|nandfs_seg_usage_blk_offset
argument_list|(
name|bad_segments
index|[
name|i
index|]
argument_list|,
operator|&
name|blk
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"storing bad_segments[%jd]=%x at %jx off %jx\n"
argument_list|,
name|i
argument_list|,
name|bad_segments
index|[
name|i
index|]
argument_list|,
name|blk
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|block
operator|=
name|get_block
argument_list|(
name|sufile
operator|.
name|blocks
index|[
name|blk
index|]
argument_list|,
name|off
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_segment_usage
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|su
operator|=
operator|(
expr|struct
name|nandfs_segment_usage
operator|*
operator|)
name|block
expr_stmt|;
name|su
index|[
name|off
index|]
operator|.
name|su_lastmod
operator|=
name|nandfs_time
expr_stmt|;
name|su
index|[
name|off
index|]
operator|.
name|su_nblocks
operator|=
literal|0
expr_stmt|;
name|su
index|[
name|off
index|]
operator|.
name|su_flags
operator|=
name|NANDFS_SEGMENT_USAGE_ERROR
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|save_cpfile
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|nandfs_cpfile_header
modifier|*
name|header
decl_stmt|;
name|struct
name|nandfs_checkpoint
modifier|*
name|cp
decl_stmt|,
modifier|*
name|initial_cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|entries
init|=
name|blocksize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_checkpoint
argument_list|)
decl_stmt|;
name|uint64_t
name|cno
decl_stmt|;
name|header
operator|=
operator|(
expr|struct
name|nandfs_cpfile_header
operator|*
operator|)
name|get_block
argument_list|(
name|cpfile
operator|.
name|blocks
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|header
operator|->
name|ch_ncheckpoints
operator|=
literal|1
expr_stmt|;
name|header
operator|->
name|ch_nsnapshots
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
operator|(
expr|struct
name|nandfs_checkpoint
operator|*
operator|)
name|header
expr_stmt|;
comment|/* fill first checkpoint data*/
name|initial_cp
operator|=
operator|&
name|cp
index|[
name|NANDFS_CPFILE_FIRST_CHECKPOINT_OFFSET
index|]
expr_stmt|;
name|initial_cp
operator|->
name|cp_flags
operator|=
literal|0
expr_stmt|;
name|initial_cp
operator|->
name|cp_checkpoints_count
operator|=
literal|0
expr_stmt|;
name|initial_cp
operator|->
name|cp_cno
operator|=
name|NANDFS_FIRST_CNO
expr_stmt|;
name|initial_cp
operator|->
name|cp_create
operator|=
name|nandfs_time
expr_stmt|;
name|initial_cp
operator|->
name|cp_nblk_inc
operator|=
name|seg_endblock
operator|-
literal|1
expr_stmt|;
name|initial_cp
operator|->
name|cp_blocks_count
operator|=
name|seg_nblocks
expr_stmt|;
name|memset
argument_list|(
operator|&
name|initial_cp
operator|->
name|cp_snapshot_list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_snapshot_list
argument_list|)
argument_list|)
expr_stmt|;
name|ifile
operator|.
name|inode
operator|=
operator|&
name|initial_cp
operator|->
name|cp_ifile_inode
expr_stmt|;
comment|/* mark rest of cp as invalid */
name|cno
operator|=
name|NANDFS_FIRST_CNO
operator|+
literal|1
expr_stmt|;
name|i
operator|=
name|NANDFS_CPFILE_FIRST_CHECKPOINT_OFFSET
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|entries
condition|;
name|i
operator|++
control|)
block|{
name|cp
index|[
name|i
index|]
operator|.
name|cp_cno
operator|=
name|cno
operator|++
expr_stmt|;
name|cp
index|[
name|i
index|]
operator|.
name|cp_flags
operator|=
name|NANDFS_CHECKPOINT_INVALID
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|init_inode
parameter_list|(
name|struct
name|nandfs_inode
modifier|*
name|inode
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|)
block|{
name|inode
operator|->
name|i_blocks
operator|=
name|file
operator|->
name|nblocks
expr_stmt|;
name|inode
operator|->
name|i_ctime
operator|=
name|nandfs_time
expr_stmt|;
name|inode
operator|->
name|i_mtime
operator|=
name|nandfs_time
expr_stmt|;
name|inode
operator|->
name|i_mode
operator|=
name|file
operator|->
name|mode
operator|&
literal|0xffff
expr_stmt|;
name|inode
operator|->
name|i_links_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|size
operator|>
literal|0
condition|)
name|inode
operator|->
name|i_size
operator|=
name|file
operator|->
name|size
expr_stmt|;
else|else
name|inode
operator|->
name|i_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|ino
operator|==
name|NANDFS_USER_INO
condition|)
name|inode
operator|->
name|i_flags
operator|=
name|SF_NOUNLINK
operator||
name|UF_NOUNLINK
expr_stmt|;
else|else
name|inode
operator|->
name|i_flags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_ifile
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|nandfs_inode
modifier|*
name|inode
decl_stmt|;
name|struct
name|file_info
modifier|*
name|file
decl_stmt|;
name|uint64_t
name|ino
decl_stmt|,
name|blk
decl_stmt|,
name|off
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|prepare_blockgrouped_file
argument_list|(
name|ifile
operator|.
name|blocks
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NANDFS_USER_INO
condition|;
name|i
operator|++
control|)
name|alloc_blockgrouped_file
argument_list|(
name|ifile
operator|.
name|blocks
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nuserfiles
condition|;
name|i
operator|++
control|)
block|{
name|file
operator|=
operator|&
name|user_files
index|[
name|i
index|]
expr_stmt|;
name|ino
operator|=
name|file
operator|->
name|ino
expr_stmt|;
name|blk
operator|=
name|ino
operator|/
operator|(
name|blocksize
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|inode
argument_list|)
operator|)
expr_stmt|;
name|off
operator|=
name|ino
operator|%
operator|(
name|blocksize
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|inode
argument_list|)
operator|)
expr_stmt|;
name|inode
operator|=
operator|(
expr|struct
name|nandfs_inode
operator|*
operator|)
name|get_block
argument_list|(
name|ifile
operator|.
name|blocks
index|[
literal|2
operator|+
name|blk
index|]
argument_list|,
literal|2
operator|+
name|blk
argument_list|)
expr_stmt|;
name|file
operator|->
name|inode
operator|=
operator|&
name|inode
index|[
name|off
index|]
expr_stmt|;
name|init_inode
argument_list|(
name|file
operator|->
name|inode
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|init_inode
argument_list|(
name|ifile
operator|.
name|inode
argument_list|,
operator|&
name|ifile
argument_list|)
expr_stmt|;
name|init_inode
argument_list|(
name|cpfile
operator|.
name|inode
argument_list|,
operator|&
name|cpfile
argument_list|)
expr_stmt|;
name|init_inode
argument_list|(
name|sufile
operator|.
name|inode
argument_list|,
operator|&
name|sufile
argument_list|)
expr_stmt|;
name|init_inode
argument_list|(
name|datfile
operator|.
name|inode
argument_list|,
operator|&
name|datfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|create_fs
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|start_block
decl_stmt|;
name|uint32_t
name|segsum_size
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|nuserfiles
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|user_files
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|user_files
index|[
literal|0
index|]
argument_list|)
operator|)
expr_stmt|;
comment|/* Count and assign blocks */
name|count_seg_blocks
argument_list|()
expr_stmt|;
name|segsum_size
operator|=
name|segment_size
argument_list|()
expr_stmt|;
name|start_block
operator|=
name|NANDFS_FIRST_BLOCK
operator|+
name|SIZE_TO_BLOCK
argument_list|(
name|segsum_size
argument_list|)
expr_stmt|;
name|assign_file_blocks
argument_list|(
name|start_block
argument_list|)
expr_stmt|;
comment|/* Create super root structure */
name|save_super_root
argument_list|()
expr_stmt|;
comment|/* Create root directory */
name|save_root_dir
argument_list|()
expr_stmt|;
comment|/* Fill in file contents */
name|save_sufile
argument_list|()
expr_stmt|;
name|save_cpfile
argument_list|()
expr_stmt|;
name|save_ifile
argument_list|()
expr_stmt|;
name|save_datfile
argument_list|()
expr_stmt|;
comment|/* Save fsdata and superblocks */
name|create_fsdata
argument_list|()
expr_stmt|;
name|create_super_block
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NANDFS_NFSAREAS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fsdata_blocks_state
index|[
name|i
index|]
operator|!=
name|NANDFS_BLOCK_GOOD
condition|)
continue|continue;
name|data
operator|=
name|get_block
argument_list|(
operator|(
name|i
operator|*
name|erasesize
operator|)
operator|/
name|blocksize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|save_fsdata
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|get_block
argument_list|(
operator|(
name|i
operator|*
name|erasesize
operator|+
name|NANDFS_SBLOCK_OFFSET_BYTES
operator|)
operator|/
name|blocksize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocksize
operator|>
name|NANDFS_SBLOCK_OFFSET_BYTES
condition|)
name|data
operator|+=
name|NANDFS_SBLOCK_OFFSET_BYTES
expr_stmt|;
name|save_super_block
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_super_block
argument_list|)
argument_list|,
literal|0xff
argument_list|,
operator|(
name|blocksize
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_super_block
argument_list|)
operator|-
name|NANDFS_SBLOCK_OFFSET_BYTES
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Save segment summary and CRCs */
name|save_segsum
argument_list|(
name|get_block
argument_list|(
name|NANDFS_FIRST_BLOCK
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_fs
parameter_list|(
name|int
name|fda
parameter_list|)
block|{
name|struct
name|nandfs_block
modifier|*
name|block
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|u_int
name|ret
decl_stmt|;
comment|/* Overwrite next block with ff if not nand device */
if|if
condition|(
operator|!
name|is_nand
condition|)
block|{
name|data
operator|=
name|get_block
argument_list|(
name|seg_endblock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0xff
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|block
argument_list|,
argument|&block_head
argument_list|,
argument|block_link
argument_list|)
block|{
name|lseek
argument_list|(
name|fda
argument_list|,
name|block
operator|->
name|number
operator|*
name|blocksize
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|fda
argument_list|,
name|block
operator|->
name|data
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|blocksize
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cannot write filesystem data"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_parameters
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* check blocksize */
if|if
condition|(
operator|(
name|blocksize
operator|<
name|NANDFS_MIN_BLOCKSIZE
operator|)
operator|||
operator|(
name|blocksize
operator|>
name|MAXBSIZE
operator|)
operator|||
operator|(
operator|(
name|blocksize
operator|-
literal|1
operator|)
operator|&
name|blocksize
operator|)
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Bad blocksize (%zu). Must be in range [%u-%u] "
literal|"and a power of two."
argument_list|,
name|blocksize
argument_list|,
name|NANDFS_MIN_BLOCKSIZE
argument_list|,
name|MAXBSIZE
argument_list|)
expr_stmt|;
block|}
comment|/* check blocks per segments */
if|if
condition|(
operator|(
name|blocks_per_segment
operator|<
name|NANDFS_SEG_MIN_BLOCKS
operator|)
operator|||
operator|(
operator|(
name|blocksize
operator|-
literal|1
operator|)
operator|&
name|blocksize
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Bad blocks per segment (%lu). Must be greater than "
literal|"%u and a power of two."
argument_list|,
name|blocks_per_segment
argument_list|,
name|NANDFS_SEG_MIN_BLOCKS
argument_list|)
expr_stmt|;
comment|/* check reserved segment percentage */
if|if
condition|(
operator|(
name|rsv_segment_percent
operator|<
literal|1
operator|)
operator|||
operator|(
name|rsv_segment_percent
operator|>
literal|99
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Bad reserved segment percentage. "
literal|"Must in range 1..99."
argument_list|)
expr_stmt|;
comment|/* check volume label */
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|volumelabel
condition|)
block|{
while|while
condition|(
name|isalnum
argument_list|(
name|volumelabel
index|[
operator|++
name|i
index|]
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|volumelabel
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"bad volume label. "
literal|"Valid characters are alphanumerics."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|volumelabel
argument_list|)
operator|>=
literal|16
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Bad volume label. Length is longer than %d."
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
name|nandfs_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_parameters
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"filesystem parameters:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"blocksize: %#zx sectorsize: %#zx\n"
argument_list|,
name|blocksize
argument_list|,
name|sectorsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"erasesize: %#jx mediasize: %#jx\n"
argument_list|,
name|erasesize
argument_list|,
name|mediasize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"segment size: %#jx blocks per segment: %#x\n"
argument_list|,
name|segsize
argument_list|,
operator|(
name|uint32_t
operator|)
name|blocks_per_segment
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Exit with error if file system is mounted.  */
end_comment

begin_function
specifier|static
name|void
name|check_mounted
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|struct
name|statfs
modifier|*
name|mp
decl_stmt|;
specifier|const
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|n
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|n
operator|=
name|getmntinfo
argument_list|(
operator|&
name|mp
argument_list|,
name|MNT_NOWAIT
argument_list|)
operator|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"getmntinfo"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|_PATH_DEV
argument_list|)
expr_stmt|;
name|s1
operator|=
name|fname
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|s1
argument_list|,
name|_PATH_DEV
argument_list|,
name|len
argument_list|)
condition|)
name|s1
operator|+=
name|len
expr_stmt|;
name|r
operator|=
name|S_ISCHR
argument_list|(
name|mode
argument_list|)
operator|&&
name|s1
operator|!=
name|fname
operator|&&
operator|*
name|s1
operator|==
literal|'r'
expr_stmt|;
for|for
control|(
init|;
name|n
operator|--
condition|;
name|mp
operator|++
control|)
block|{
name|s2
operator|=
name|mp
operator|->
name|f_mntfromname
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|s2
argument_list|,
name|_PATH_DEV
argument_list|,
name|len
argument_list|)
condition|)
name|s2
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&&
name|s2
operator|!=
name|mp
operator|->
name|f_mntfromname
operator|&&
operator|!
name|strcmp
argument_list|(
name|s1
operator|+
literal|1
argument_list|,
name|s2
argument_list|)
operator|)
operator|||
operator|!
name|strcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s is mounted on %s"
argument_list|,
name|fname
argument_list|,
name|mp
operator|->
name|f_mntonname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|calculate_geometry
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|struct
name|chip_param_io
name|chip_params
decl_stmt|;
name|char
name|ident
index|[
name|DISK_IDENT_SIZE
index|]
decl_stmt|;
name|char
name|medianame
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* Check storage type */
name|g_get_ident
argument_list|(
name|fd
argument_list|,
name|ident
argument_list|,
name|DISK_IDENT_SIZE
argument_list|)
expr_stmt|;
name|g_get_name
argument_list|(
name|ident
argument_list|,
name|medianame
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"device name: %s"
argument_list|,
name|medianame
argument_list|)
expr_stmt|;
name|is_nand
operator|=
operator|(
name|strstr
argument_list|(
name|medianame
argument_list|,
literal|"gnand"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|debug
argument_list|(
literal|"is_nand = %d"
argument_list|,
name|is_nand
argument_list|)
expr_stmt|;
name|sectorsize
operator|=
name|g_sectorsize
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"sectorsize: %#zx"
argument_list|,
name|sectorsize
argument_list|)
expr_stmt|;
comment|/* Get storage size */
name|mediasize
operator|=
name|g_mediasize
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"mediasize: %#jx"
argument_list|,
name|mediasize
argument_list|)
expr_stmt|;
comment|/* Get storage erase unit size */
if|if
condition|(
operator|!
name|is_nand
condition|)
name|erasesize
operator|=
name|NANDFS_DEF_ERASESIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|NAND_IO_GET_CHIP_PARAM
argument_list|,
operator|&
name|chip_params
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|erasesize
operator|=
name|chip_params
operator|.
name|page_size
operator|*
name|chip_params
operator|.
name|pages_per_block
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Cannot ioctl(NAND_IO_GET_CHIP_PARAM)"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"erasesize: %#jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|erasesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocks_per_segment
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|erasesize
operator|>=
name|NANDFS_MIN_SEGSIZE
condition|)
name|blocks_per_segment
operator|=
name|erasesize
operator|/
name|blocksize
expr_stmt|;
else|else
name|blocks_per_segment
operator|=
name|NANDFS_MIN_SEGSIZE
operator|/
name|blocksize
expr_stmt|;
block|}
comment|/* Calculate number of segments */
name|segsize
operator|=
name|blocksize
operator|*
name|blocks_per_segment
expr_stmt|;
name|nsegments
operator|=
operator|(
operator|(
name|mediasize
operator|-
name|NANDFS_NFSAREAS
operator|*
name|erasesize
operator|)
operator|/
name|segsize
operator|)
operator|-
literal|2
expr_stmt|;
name|debug
argument_list|(
literal|"segsize: %#jx"
argument_list|,
name|segsize
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"nsegments: %#jx"
argument_list|,
name|nsegments
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|erase_device
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|rest
decl_stmt|,
name|failed
decl_stmt|;
name|uint64_t
name|i
decl_stmt|,
name|nblocks
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|failed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NANDFS_NFSAREAS
condition|;
name|i
operator|++
control|)
block|{
name|debug
argument_list|(
literal|"Deleting %jx\n"
argument_list|,
name|i
operator|*
name|erasesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_delete
argument_list|(
name|fd
argument_list|,
name|i
operator|*
name|erasesize
argument_list|,
name|erasesize
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cannot delete %jx\n"
argument_list|,
name|i
operator|*
name|erasesize
argument_list|)
expr_stmt|;
name|fsdata_blocks_state
index|[
name|i
index|]
operator|=
name|NANDFS_BLOCK_BAD
expr_stmt|;
name|failed
operator|++
expr_stmt|;
block|}
else|else
name|fsdata_blocks_state
index|[
name|i
index|]
operator|=
name|NANDFS_BLOCK_GOOD
expr_stmt|;
block|}
if|if
condition|(
name|failed
operator|==
name|NANDFS_NFSAREAS
condition|)
block|{
name|printf
argument_list|(
literal|"%d first blocks not usable. Unable to create "
literal|"filesystem.\n"
argument_list|,
name|failed
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegments
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|=
name|NANDFS_NFSAREAS
operator|*
name|erasesize
operator|+
name|i
operator|*
name|segsize
expr_stmt|;
if|if
condition|(
name|g_delete
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|segsize
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cannot delete segment %jx (offset %jd)\n"
argument_list|,
name|i
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|bad_segments_count
operator|++
expr_stmt|;
name|bad_segments
operator|=
name|realloc
argument_list|(
name|bad_segments
argument_list|,
name|bad_segments_count
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|bad_segments
index|[
name|bad_segments_count
operator|-
literal|1
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bad_segments_count
operator|==
name|nsegments
condition|)
block|{
name|printf
argument_list|(
literal|"no valid segments\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Delete remaining blocks at the end of device */
name|rest
operator|=
name|mediasize
operator|%
name|segsize
expr_stmt|;
name|nblocks
operator|=
name|rest
operator|/
name|erasesize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblocks
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|=
operator|(
name|segsize
operator|*
name|nsegments
operator|)
operator|+
operator|(
name|i
operator|*
name|erasesize
operator|)
expr_stmt|;
if|if
condition|(
name|g_delete
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|erasesize
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cannot delete space after last segment "
literal|"- probably a bad block\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|erase_initial
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NANDFS_NFSAREAS
operator|*
name|erasesize
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
control|)
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_nandfs
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|create_fs
argument_list|()
expr_stmt|;
name|write_fs
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_summary
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"filesystem was created successfully\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total segments: %#jx valid segments: %#jx\n"
argument_list|,
name|nsegments
argument_list|,
name|nsegments
operator|-
name|bad_segments_count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total space: %ju MB free: %ju MB\n"
argument_list|,
operator|(
name|nsegments
operator|*
name|blocks_per_segment
operator|*
name|blocksize
operator|)
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|,
operator|(
operator|(
name|nsegments
operator|-
name|bad_segments_count
operator|)
operator|*
name|blocks_per_segment
operator|*
name|blocksize
operator|)
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
specifier|const
name|char
name|opts
index|[]
init|=
literal|"b:B:L:m:"
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|fd
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|opts
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'b'
case|:
name|blocksize
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocksize
operator|==
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|blocks_per_segment
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocks_per_segment
operator|==
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|volumelabel
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|rsv_segment_percent
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsv_segment_percent
operator|==
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
operator|||
name|argc
operator|>
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* construct proper device path */
name|fname
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|fname
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fname
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|fd
operator|=
name|g_open
argument_list|(
name|fname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Cannot open %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Cannot stat %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISCHR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
name|warnx
argument_list|(
literal|"%s is not a character device"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|check_mounted
argument_list|(
name|fname
argument_list|,
name|sb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|calculate_geometry
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|check_parameters
argument_list|()
expr_stmt|;
name|print_parameters
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_nand
condition|)
name|erase_device
argument_list|(
name|fd
argument_list|)
expr_stmt|;
else|else
name|erase_initial
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|create_nandfs
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|print_summary
argument_list|()
expr_stmt|;
name|g_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

