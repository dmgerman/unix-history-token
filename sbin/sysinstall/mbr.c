begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994, Paul Richards.  *  * All rights reserved.  *  * This software may be used, modified, copied, distributed, and  * sold, in both source and binary form provided that the above  * copyright and these terms are retained, verbatim, as the first  * lines of this file.  Under no circumstances is the author  * responsible for the proper functioning of this software, nor does  * the author assume any responsibility for damages incurred with  * its use.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<dialog.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|"mbr.h"
end_include

begin_include
include|#
directive|include
file|"sysinstall.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|mbr
modifier|*
name|mbr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|inst_part
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|whole_disk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|part_type
name|part_types
index|[]
init|=
name|PARTITION_TYPES
name|char
operator|*
name|part_type
argument_list|(
argument|int type
argument_list|)
block|{
name|int
name|num_types
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|part_types
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|part_type
argument_list|)
operator|)
block|;
name|int
name|next_type
operator|=
literal|0
block|;     struct
name|part_type
operator|*
name|ptr
operator|=
name|part_types
block|;
while|while
condition|(
name|next_type
operator|<
name|num_types
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|type
operator|==
name|type
condition|)
return|return
operator|(
name|ptr
operator|->
name|name
operator|)
return|;
name|ptr
operator|++
expr_stmt|;
name|next_type
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|"Unknown"
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|void
name|read_dospart
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|dos_partition
modifier|*
name|dp
parameter_list|)
block|{
name|u_char
name|buf
index|[
literal|512
index|]
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|AskAbort
argument_list|(
literal|"Couldn't seek for master boot record read\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
literal|512
argument_list|)
operator|!=
literal|512
condition|)
block|{
name|AskAbort
argument_list|(
literal|"Failed to read master boot record\n"
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|dp
argument_list|,
name|buf
operator|+
name|DOSPARTOFF
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
operator|*
name|NDOSPART
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_dospart
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|dos_partition
modifier|*
name|dp
parameter_list|)
block|{
name|u_char
name|buf
index|[
literal|512
index|]
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|AskAbort
argument_list|(
literal|"Couldn't seek for master boot record read\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
literal|512
argument_list|)
operator|!=
literal|512
condition|)
block|{
name|AskAbort
argument_list|(
literal|"Failed to read master boot record\n"
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buf
operator|+
name|DOSPARTOFF
argument_list|,
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
operator|*
name|NDOSPART
argument_list|)
expr_stmt|;
name|buf
index|[
literal|510
index|]
operator|=
literal|0x55
expr_stmt|;
name|buf
index|[
literal|511
index|]
operator|=
literal|0xaa
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|AskAbort
argument_list|(
literal|"Couldn't seek for master boot record write\n"
argument_list|)
expr_stmt|;
name|enable_label
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
literal|512
argument_list|)
operator|!=
literal|512
condition|)
name|AskAbort
argument_list|(
literal|"Failed to write master boot record\n"
argument_list|)
expr_stmt|;
name|disable_label
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_bootcode
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|u_char
name|buf
index|[
literal|512
index|]
decl_stmt|;
specifier|extern
specifier|const
name|char
name|boot0
index|[]
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|AskAbort
argument_list|(
literal|"Couldn't seek for master boot record read\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
literal|512
argument_list|)
operator|!=
literal|512
condition|)
block|{
name|AskAbort
argument_list|(
literal|"Failed to read master boot record\n"
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
name|boot0
argument_list|,
name|DOSPARTOFF
argument_list|)
expr_stmt|;
name|buf
index|[
literal|510
index|]
operator|=
literal|0x55
expr_stmt|;
name|buf
index|[
literal|511
index|]
operator|=
literal|0xaa
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|AskAbort
argument_list|(
literal|"Couldn't seek for master boot record write\n"
argument_list|)
expr_stmt|;
name|enable_label
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
literal|512
argument_list|)
operator|!=
literal|512
condition|)
name|AskAbort
argument_list|(
literal|"Failed to write master boot record\n"
argument_list|)
expr_stmt|;
name|disable_label
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|WriteBootblock
parameter_list|(
name|int
name|dfd
parameter_list|,
name|struct
name|disklabel
modifier|*
name|label
parameter_list|,
name|struct
name|dos_partition
modifier|*
name|dospart
parameter_list|)
block|{
name|off_t
name|of
init|=
name|label
operator|->
name|d_partitions
index|[
name|OURPART
index|]
operator|.
name|p_offset
decl_stmt|;
name|u_char
name|bootblocks
index|[
name|BBSIZE
index|]
decl_stmt|;
specifier|extern
specifier|const
name|char
name|boot1
index|[]
decl_stmt|;
specifier|extern
specifier|const
name|char
name|boot2
index|[]
decl_stmt|;
name|memcpy
argument_list|(
name|bootblocks
argument_list|,
name|boot1
argument_list|,
name|MBRSIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|bootblocks
index|[
name|MBRSIZE
index|]
argument_list|,
name|boot2
argument_list|,
call|(
name|int
call|)
argument_list|(
name|label
operator|->
name|d_bbsize
operator|-
name|MBRSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dospart
argument_list|,
operator|&
name|bootblocks
index|[
name|DOSPARTOFF
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dos_partition
argument_list|)
operator|*
name|NDOSPART
argument_list|)
expr_stmt|;
name|label
operator|->
name|d_checksum
operator|=
literal|0
expr_stmt|;
name|label
operator|->
name|d_checksum
operator|=
name|dkcksum
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|label
argument_list|,
operator|&
name|bootblocks
index|[
operator|(
name|LABELSECTOR
operator|*
name|label
operator|->
name|d_secsize
operator|)
operator|+
name|LABELOFFSET
index|]
argument_list|,
sizeof|sizeof
expr|*
name|label
argument_list|)
expr_stmt|;
name|Debug
argument_list|(
literal|"Seeking to byte %ld "
argument_list|,
name|of
operator|*
name|label
operator|->
name|d_secsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|dfd
argument_list|,
operator|(
name|of
operator|*
name|label
operator|->
name|d_secsize
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Fatal
argument_list|(
literal|"Couldn't seek to start of partition\n"
argument_list|)
expr_stmt|;
block|}
name|enable_label
argument_list|(
name|dfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|dfd
argument_list|,
name|bootblocks
argument_list|,
name|label
operator|->
name|d_bbsize
argument_list|)
operator|!=
name|label
operator|->
name|d_bbsize
condition|)
block|{
name|Fatal
argument_list|(
literal|"Failed to write bootblocks (%p,%d) %d %s\n"
argument_list|,
name|bootblocks
argument_list|,
name|label
operator|->
name|d_bbsize
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|disable_label
argument_list|(
name|dfd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FillIn
parameter_list|(
name|struct
name|dos_partition
modifier|*
name|dp
parameter_list|,
name|int
name|sec
parameter_list|,
name|int
name|hd
parameter_list|)
block|{
name|u_long
name|l2
decl_stmt|,
name|l3
init|=
literal|0
decl_stmt|,
name|sect
decl_stmt|,
name|c
decl_stmt|,
name|s
decl_stmt|,
name|h
decl_stmt|;
name|sect
operator|=
name|dp
operator|->
name|dp_start
expr_stmt|;
name|l2
operator|=
name|sect
operator|/
operator|(
name|sec
operator|*
name|hd
operator|)
expr_stmt|;
name|sect
operator|-=
name|l2
operator|*
name|sec
operator|*
name|hd
expr_stmt|;
if|if
condition|(
name|l2
operator|>
literal|1023
condition|)
name|l2
operator|=
literal|1023
expr_stmt|;
name|c
operator|=
operator|(
name|l2
operator|&
literal|0xff
operator|)
expr_stmt|;
name|s
operator|=
operator|(
name|l2
operator|>>
literal|2
operator|)
operator|&
literal|0xc0
expr_stmt|;
name|l2
operator|=
name|sect
operator|/
name|sec
expr_stmt|;
name|h
operator|=
name|l2
expr_stmt|;
name|sect
operator|-=
name|l2
operator|*
name|sec
expr_stmt|;
name|s
operator||=
operator|(
name|sect
operator|+
literal|1
operator|)
operator|&
literal|0x3f
expr_stmt|;
define|#
directive|define
name|NIC
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|if (a != b) {a = b; l3++;}
name|NIC
argument_list|(
name|dp
operator|->
name|dp_ssect
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|NIC
argument_list|(
name|dp
operator|->
name|dp_scyl
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|NIC
argument_list|(
name|dp
operator|->
name|dp_shd
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|sect
operator|=
name|dp
operator|->
name|dp_start
operator|+
name|dp
operator|->
name|dp_size
operator|-
literal|1
expr_stmt|;
name|l2
operator|=
name|sect
operator|/
operator|(
name|sec
operator|*
name|hd
operator|)
expr_stmt|;
name|sect
operator|-=
name|l2
operator|*
name|sec
operator|*
name|hd
expr_stmt|;
if|if
condition|(
name|l2
operator|>
literal|1023
condition|)
name|l2
operator|=
literal|1023
expr_stmt|;
name|c
operator|=
operator|(
name|l2
operator|&
literal|0xff
operator|)
expr_stmt|;
name|s
operator|=
operator|(
name|l2
operator|>>
literal|2
operator|)
operator|&
literal|0xc0
expr_stmt|;
name|l2
operator|=
name|sect
operator|/
name|sec
expr_stmt|;
name|h
operator|=
name|l2
expr_stmt|;
name|sect
operator|-=
name|l2
operator|*
name|sec
expr_stmt|;
name|s
operator||=
operator|(
name|sect
operator|+
literal|1
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|NIC
argument_list|(
name|dp
operator|->
name|dp_esect
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|NIC
argument_list|(
name|dp
operator|->
name|dp_ecyl
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|NIC
argument_list|(
name|dp
operator|->
name|dp_ehd
argument_list|,
name|h
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|NIC
return|return
name|l2
return|;
block|}
end_function

begin_function
name|void
name|Fdisk
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|,
name|diskno
decl_stmt|,
name|flag
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|dos_partition
name|dp
index|[
name|NDOSPART
index|]
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lbl
decl_stmt|;
name|u_long
name|cyl
decl_stmt|,
name|hd
decl_stmt|,
name|sec
decl_stmt|,
name|tsec
decl_stmt|;
name|u_long
name|l
decl_stmt|,
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|l3
decl_stmt|,
name|l4
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|grumble
init|=
name|NULL
decl_stmt|;
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|AskEm
argument_list|(
name|stdscr
argument_list|,
literal|"Enter number of disk to Fdisk> "
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
operator|&&
name|i
operator|!=
literal|'\r'
condition|)
return|return;
name|diskno
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|diskno
operator|>=
literal|0
operator|&&
name|diskno
operator|<
name|MAX_NO_DISKS
operator|&&
name|Dname
index|[
name|diskno
index|]
operator|)
condition|)
return|return;
name|lbl
operator|=
name|Dlbl
index|[
name|diskno
index|]
expr_stmt|;
name|lbl
operator|->
name|d_bbsize
operator|=
literal|8192
expr_stmt|;
name|hd
operator|=
name|lbl
operator|->
name|d_ntracks
expr_stmt|;
name|sec
operator|=
name|lbl
operator|->
name|d_nsectors
expr_stmt|;
name|tsec
operator|=
name|Dlbl
index|[
name|diskno
index|]
operator|->
name|d_partitions
index|[
name|RAWPART
index|]
operator|.
name|p_size
expr_stmt|;
name|cyl
operator|=
name|tsec
operator|/
operator|(
name|hd
operator|*
name|sec
operator|)
expr_stmt|;
name|read_dospart
argument_list|(
name|Dfd
index|[
name|diskno
index|]
argument_list|,
name|dp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|standend
argument_list|()
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|mvprintw
argument_list|(
name|j
operator|++
argument_list|,
literal|0
argument_list|,
literal|"%s -- Diskspace editor -- FDISK"
argument_list|,
name|TITLE
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|mvprintw
argument_list|(
name|j
operator|++
argument_list|,
literal|0
argument_list|,
literal|"Disk: %s   Geometry:  %lu Cyl * %lu Hd * %lu Sect"
argument_list|,
name|Dname
index|[
name|diskno
index|]
argument_list|,
name|cyl
argument_list|,
name|hd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|" = %luMb = %lu Sect"
argument_list|,
operator|(
name|tsec
operator|+
literal|1024
operator|)
operator|/
literal|2048
argument_list|,
name|tsec
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDOSPART
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
literal|4
control|)
block|{
name|mvprintw
argument_list|(
name|j
argument_list|,
literal|0
argument_list|,
literal|"%d "
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printw("[%02x %02x %02x %02x %02x %02x %02x %02x %08lx %08lx]\n", 		   dp[i].dp_flag, dp[i].dp_shd, dp[i].dp_ssect, dp[i].dp_scyl, 		   dp[i].dp_typ, dp[i].dp_ehd, dp[i].dp_esect, dp[i].dp_ecyl, 		   dp[i].dp_start, dp[i].dp_size);
endif|#
directive|endif
if|if
condition|(
operator|!
name|dp
index|[
name|i
index|]
operator|.
name|dp_size
condition|)
block|{
name|printw
argument_list|(
literal|"Unused"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printw
argument_list|(
literal|"Boot?=%s"
argument_list|,
name|dp
index|[
name|i
index|]
operator|.
name|dp_flag
operator|==
literal|0x80
condition|?
literal|"Yes"
else|:
literal|"No "
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"   Type=%s\n"
argument_list|,
name|part_type
argument_list|(
name|dp
index|[
name|i
index|]
operator|.
name|dp_typ
argument_list|)
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"  Phys=(c%d/h%d/s%d..c%d/h%d/s%d)"
argument_list|,
name|DPCYL
argument_list|(
name|dp
index|[
name|i
index|]
operator|.
name|dp_scyl
argument_list|,
name|dp
index|[
name|i
index|]
operator|.
name|dp_ssect
argument_list|)
argument_list|,
name|dp
index|[
name|i
index|]
operator|.
name|dp_shd
argument_list|,
name|DPSECT
argument_list|(
name|dp
index|[
name|i
index|]
operator|.
name|dp_ssect
argument_list|)
argument_list|,
name|DPCYL
argument_list|(
name|dp
index|[
name|i
index|]
operator|.
name|dp_ecyl
argument_list|,
name|dp
index|[
name|i
index|]
operator|.
name|dp_esect
argument_list|)
argument_list|,
name|dp
index|[
name|i
index|]
operator|.
name|dp_ehd
argument_list|,
name|DPSECT
argument_list|(
name|dp
index|[
name|i
index|]
operator|.
name|dp_esect
argument_list|)
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"   Sector=(%lu..%lu)\n"
argument_list|,
name|dp
index|[
name|i
index|]
operator|.
name|dp_start
argument_list|,
name|dp
index|[
name|i
index|]
operator|.
name|dp_size
operator|+
name|dp
index|[
name|i
index|]
operator|.
name|dp_start
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"  Size=%lu MB, %lu Cylinders"
argument_list|,
operator|(
name|dp
index|[
name|i
index|]
operator|.
name|dp_size
operator|+
literal|1024L
operator|)
operator|/
literal|2048L
argument_list|,
name|dp
index|[
name|i
index|]
operator|.
name|dp_size
operator|/
name|lbl
operator|->
name|d_secpercyl
argument_list|)
expr_stmt|;
name|l
operator|=
name|dp
index|[
name|i
index|]
operator|.
name|dp_size
operator|%
name|lbl
operator|->
name|d_secpercyl
expr_stmt|;
if|if
condition|(
name|l
condition|)
block|{
name|printw
argument_list|(
literal|" + %lu Tracks"
argument_list|,
name|l
operator|/
name|lbl
operator|->
name|d_nsectors
argument_list|)
expr_stmt|;
name|l
operator|=
name|l
operator|%
name|lbl
operator|->
name|d_nsectors
expr_stmt|;
if|if
condition|(
name|l
condition|)
block|{
name|printw
argument_list|(
literal|" + %lu Sectors"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mvprintw
argument_list|(
literal|20
argument_list|,
literal|0
argument_list|,
literal|"Commands available:   "
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|21
argument_list|,
literal|0
argument_list|,
literal|"(H)elp   (T)utorial   (D)elete   (E)dit   (R)eread   (W)rite MBR   (Q)uit"
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|22
argument_list|,
literal|0
argument_list|,
literal|"(U)se entire disk for FreeBSD   (G)eometry   use (B)oot manager"
argument_list|)
expr_stmt|;
if|if
condition|(
name|grumble
condition|)
block|{
name|standout
argument_list|()
expr_stmt|;
name|mvprintw
argument_list|(
literal|24
argument_list|,
literal|0
argument_list|,
name|grumble
argument_list|)
expr_stmt|;
name|standend
argument_list|()
expr_stmt|;
name|grumble
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|changed
condition|)
block|{
name|standout
argument_list|()
expr_stmt|;
name|mvprintw
argument_list|(
literal|24
argument_list|,
literal|0
argument_list|,
literal|"Use (W)rite to save changes to disk"
argument_list|)
expr_stmt|;
name|standend
argument_list|()
expr_stmt|;
block|}
name|mvprintw
argument_list|(
literal|23
argument_list|,
literal|0
argument_list|,
literal|"Enter Command> "
argument_list|)
expr_stmt|;
name|i
operator|=
name|getch
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
name|clear
argument_list|()
expr_stmt|;
name|mvprintw
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s -- Diskspace editor -- FDISK -- Command Help  Basic commands:  (H)elp          - This screen (T)utorial      - A more detailed discussion of MBR's, disklabels, etc. (D)elete        - Delete an existing partition (E)dit          - Edit an existing partition (R)eread        - Read fdisk information from disk again, abandoning changes (W)rite MBR     - Write modified fdisk information to disk (Q)uit          - Exit the FDISK editor  Advanced commands:  (U)se entire disk for FreeBSD   - Assign ALL disk space on current drive (G)eometry                      - Edit the default disk geometry settings Write (B)oot manager            - Install multi-OS bootmanager.   Press any key to return to FDISK editor... "
argument_list|,
name|TITLE
argument_list|)
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
name|ShowFile
argument_list|(
name|HELPME_FILE
argument_list|,
literal|"Help file for disklayout"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|read_dospart
argument_list|(
name|Dfd
index|[
name|diskno
index|]
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|grumble
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDOSPART
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dp
index|[
name|i
index|]
operator|.
name|dp_start
operator|==
literal|0
operator|&&
name|dp
index|[
name|i
index|]
operator|.
name|dp_typ
operator|==
name|MBR_PTYPE_FreeBSD
condition|)
block|{
name|grumble
operator|=
literal|"Boot manager not needed."
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|grumble
condition|)
name|write_bootcode
argument_list|(
name|Dfd
index|[
name|diskno
index|]
argument_list|)
expr_stmt|;
name|grumble
operator|=
literal|"Wrote boot manager"
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|AskEm
argument_list|(
name|stdscr
argument_list|,
literal|"Edit which Slice> "
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
operator|&&
name|i
operator|!=
literal|'\r'
condition|)
break|break;
name|l
operator|=
name|strtol
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|1
operator|||
name|l
operator|>
name|NDOSPART
condition|)
break|break;
name|l1
operator|=
name|sec
expr_stmt|;
name|l2
operator|=
name|tsec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDOSPART
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|==
name|l
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dp
index|[
name|i
index|]
operator|.
name|dp_size
condition|)
continue|continue;
if|if
condition|(
name|dp
index|[
name|i
index|]
operator|.
name|dp_start
operator|>
name|l2
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dp
index|[
name|i
index|]
operator|.
name|dp_start
operator|+
name|dp
index|[
name|i
index|]
operator|.
name|dp_size
operator|)
operator|<=
name|l1
condition|)
continue|continue;
if|if
condition|(
name|dp
index|[
name|i
index|]
operator|.
name|dp_start
operator|>
name|l1
condition|)
name|l3
operator|=
name|dp
index|[
name|i
index|]
operator|.
name|dp_start
operator|-
name|l1
expr_stmt|;
else|else
name|l3
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l2
operator|>
operator|(
name|dp
index|[
name|i
index|]
operator|.
name|dp_start
operator|+
name|dp
index|[
name|i
index|]
operator|.
name|dp_size
operator|)
condition|)
name|l4
operator|=
name|l2
operator|-
operator|(
name|dp
index|[
name|i
index|]
operator|.
name|dp_start
operator|+
name|dp
index|[
name|i
index|]
operator|.
name|dp_size
operator|)
expr_stmt|;
else|else
name|l4
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l3
operator|>=
name|l4
condition|)
name|l2
operator|=
name|dp
index|[
name|i
index|]
operator|.
name|dp_start
expr_stmt|;
else|else
name|l1
operator|=
name|dp
index|[
name|i
index|]
operator|.
name|dp_start
operator|+
name|dp
index|[
name|i
index|]
operator|.
name|dp_size
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|l2
operator|-
name|l1
operator|+
literal|1024L
operator|)
operator|/
literal|2048L
argument_list|)
expr_stmt|;
name|i
operator|=
name|AskEm
argument_list|(
name|stdscr
argument_list|,
literal|"Size of slice in MB> "
argument_list|,
name|buf
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|l3
operator|=
name|strtol
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|*
literal|2048L
expr_stmt|;
if|if
condition|(
operator|!
name|l3
condition|)
break|break;
if|if
condition|(
name|l3
operator|>
name|l2
operator|-
name|l1
condition|)
name|l3
operator|=
name|l2
operator|-
name|l1
expr_stmt|;
if|if
condition|(
operator|(
name|l1
operator|+
name|l3
operator|)
operator|%
name|lbl
operator|->
name|d_secpercyl
condition|)
block|{
comment|/* Special for cyl==0 */
name|l3
operator|+=
name|lbl
operator|->
name|d_secpercyl
operator|-
operator|(
operator|(
name|l1
operator|+
name|l3
operator|)
operator|%
name|lbl
operator|->
name|d_secpercyl
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|l3
operator|+
name|l1
operator|>
name|tsec
condition|)
name|l3
operator|=
name|tsec
operator|-
name|l1
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|dp
index|[
name|l
operator|-
literal|1
index|]
operator|.
name|dp_start
operator|=
name|l1
expr_stmt|;
name|dp
index|[
name|l
operator|-
literal|1
index|]
operator|.
name|dp_size
operator|=
name|l3
expr_stmt|;
name|FillIn
argument_list|(
operator|&
name|dp
index|[
name|l
operator|-
literal|1
index|]
argument_list|,
name|sec
argument_list|,
name|hd
argument_list|)
expr_stmt|;
name|l4
operator|=
name|dp
index|[
name|l
operator|-
literal|1
index|]
operator|.
name|dp_typ
expr_stmt|;
if|if
condition|(
operator|!
name|l4
condition|)
name|l4
operator|=
name|MBR_PTYPE_FreeBSD
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%lx"
argument_list|,
name|l4
argument_list|)
expr_stmt|;
name|i
operator|=
name|AskEm
argument_list|(
name|stdscr
argument_list|,
literal|"Type of slice (0xa5=FreeBSD)> "
argument_list|,
name|buf
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|l3
operator|=
name|strtol
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|l3
operator|==
name|MBR_PTYPE_FreeBSD
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDOSPART
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
operator|(
name|l
operator|-
literal|1
operator|)
operator|&&
name|dp
index|[
name|i
index|]
operator|.
name|dp_typ
operator|==
name|MBR_PTYPE_FreeBSD
condition|)
name|memset
argument_list|(
operator|&
name|dp
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|dp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x80"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
name|dp
index|[
name|l
operator|-
literal|1
index|]
operator|.
name|dp_typ
operator|=
name|l3
expr_stmt|;
name|i
operator|=
name|AskEm
argument_list|(
name|stdscr
argument_list|,
literal|"Bootflag (0x80 for YES)> "
argument_list|,
name|buf
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|dp
index|[
name|l
operator|-
literal|1
index|]
operator|.
name|dp_flag
operator|=
name|strtol
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
index|[
name|l
operator|-
literal|1
index|]
operator|.
name|dp_flag
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDOSPART
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
operator|(
name|l
operator|-
literal|1
operator|)
condition|)
name|dp
index|[
name|i
index|]
operator|.
name|dp_flag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
name|memset
argument_list|(
operator|&
name|dp
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|dp
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|dp
index|[
literal|0
index|]
operator|.
name|dp_start
operator|=
literal|0
expr_stmt|;
name|dp
index|[
literal|0
index|]
operator|.
name|dp_size
operator|=
name|tsec
expr_stmt|;
name|FillIn
argument_list|(
operator|&
name|dp
index|[
literal|0
index|]
argument_list|,
name|sec
argument_list|,
name|hd
argument_list|)
expr_stmt|;
name|dp
index|[
literal|0
index|]
operator|.
name|dp_typ
operator|=
name|MBR_PTYPE_FreeBSD
expr_stmt|;
name|dp
index|[
literal|0
index|]
operator|.
name|dp_flag
operator|=
literal|0x80
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lu"
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|i
operator|=
name|AskEm
argument_list|(
name|stdscr
argument_list|,
literal|"Number of Sectors> "
argument_list|,
name|buf
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|l2
operator|=
name|strtoul
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2
operator|!=
name|sec
condition|)
name|changed
operator|++
expr_stmt|;
name|sec
operator|=
name|l2
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lu"
argument_list|,
name|hd
argument_list|)
expr_stmt|;
name|i
operator|=
name|AskEm
argument_list|(
name|stdscr
argument_list|,
literal|"Number of Heads> "
argument_list|,
name|buf
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|l2
operator|=
name|strtoul
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2
operator|!=
name|hd
condition|)
name|changed
operator|++
expr_stmt|;
name|hd
operator|=
name|l2
expr_stmt|;
name|cyl
operator|=
name|tsec
operator|/
operator|(
name|hd
operator|*
name|sec
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lu"
argument_list|,
name|cyl
argument_list|)
expr_stmt|;
name|i
operator|=
name|AskEm
argument_list|(
name|stdscr
argument_list|,
literal|"Number of Cylinders> "
argument_list|,
name|buf
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|l2
operator|=
name|strtoul
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2
operator|!=
name|cyl
condition|)
name|changed
operator|++
expr_stmt|;
name|cyl
operator|=
name|l2
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|NDOSPART
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dp
index|[
name|l
index|]
operator|.
name|dp_typ
operator|||
operator|!
name|dp
index|[
name|l
index|]
operator|.
name|dp_size
condition|)
continue|continue;
name|changed
operator|+=
name|FillIn
argument_list|(
operator|&
name|dp
index|[
name|l
index|]
argument_list|,
name|sec
argument_list|,
name|hd
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|AskEm
argument_list|(
name|stdscr
argument_list|,
literal|"Delete which Slice> "
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
operator|&&
name|i
operator|!=
literal|'\r'
condition|)
break|break;
name|l
operator|=
name|strtol
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|1
operator|||
name|l
operator|>
name|NDOSPART
condition|)
break|break;
name|memset
argument_list|(
operator|&
name|dp
index|[
name|l
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|dp
index|[
name|l
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|write_dospart
argument_list|(
name|Dfd
index|[
name|diskno
index|]
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|Dlbl
index|[
name|diskno
index|]
operator|->
name|d_partitions
index|[
name|OURPART
index|]
operator|.
name|p_offset
operator|=
literal|0
expr_stmt|;
name|Dlbl
index|[
name|diskno
index|]
operator|->
name|d_partitions
index|[
name|OURPART
index|]
operator|.
name|p_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDOSPART
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dp
index|[
name|i
index|]
operator|.
name|dp_typ
operator|==
name|MBR_PTYPE_FreeBSD
condition|)
block|{
name|Dlbl
index|[
name|diskno
index|]
operator|->
name|d_partitions
index|[
name|OURPART
index|]
operator|.
name|p_offset
operator|=
name|dp
index|[
name|i
index|]
operator|.
name|dp_start
expr_stmt|;
name|Dlbl
index|[
name|diskno
index|]
operator|->
name|d_partitions
index|[
name|OURPART
index|]
operator|.
name|p_size
operator|=
name|dp
index|[
name|i
index|]
operator|.
name|dp_size
expr_stmt|;
goto|goto
name|wok
goto|;
block|}
block|}
name|grumble
operator|=
literal|"No FreeBSD slice, cannot write."
expr_stmt|;
break|break;
name|wok
label|:
name|Dlbl
index|[
name|diskno
index|]
operator|->
name|d_ntracks
operator|=
name|hd
expr_stmt|;
name|Dlbl
index|[
name|diskno
index|]
operator|->
name|d_nsectors
operator|=
name|sec
expr_stmt|;
name|Dlbl
index|[
name|diskno
index|]
operator|->
name|d_ncylinders
operator|=
name|cyl
expr_stmt|;
name|Dlbl
index|[
name|diskno
index|]
operator|->
name|d_secpercyl
operator|=
name|hd
operator|*
name|sec
expr_stmt|;
name|Dlbl
index|[
name|diskno
index|]
operator|->
name|d_magic
operator|=
name|DISKMAGIC
expr_stmt|;
name|Dlbl
index|[
name|diskno
index|]
operator|->
name|d_magic2
operator|=
name|DISKMAGIC
expr_stmt|;
name|Dlbl
index|[
name|diskno
index|]
operator|->
name|d_checksum
operator|=
literal|0
expr_stmt|;
name|Dlbl
index|[
name|diskno
index|]
operator|->
name|d_checksum
operator|=
name|dkcksum
argument_list|(
name|Dlbl
index|[
name|diskno
index|]
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
name|enable_label
argument_list|(
name|Dfd
index|[
name|diskno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|Dfd
index|[
name|diskno
index|]
argument_list|,
name|DIOCSDINFO
argument_list|,
name|Dlbl
index|[
name|diskno
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|AskAbort
argument_list|(
literal|"Couldn't set label: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|Dfd
index|[
name|diskno
index|]
argument_list|,
name|DIOCWDINFO
argument_list|,
name|Dlbl
index|[
name|diskno
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|AskAbort
argument_list|(
literal|"Couldn't write label: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
name|disable_label
argument_list|(
name|Dfd
index|[
name|diskno
index|]
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Dlbl
index|[
name|diskno
index|]
operator|->
name|d_partitions
index|[
name|OURPART
index|]
operator|.
name|p_size
condition|)
block|{
name|WriteBootblock
argument_list|(
name|Dfd
index|[
name|diskno
index|]
argument_list|,
name|lbl
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|grumble
operator|=
literal|"Wrote MBR and disklabel to disk"
expr_stmt|;
block|}
else|else
block|{
name|grumble
operator|=
literal|"Wrote MBR to disk"
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
return|return;
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

end_unit

