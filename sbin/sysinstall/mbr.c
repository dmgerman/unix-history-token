begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994, Paul Richards.  *  * All rights reserved.  *  * This software may be used, modified, copied, distributed, and  * sold, in both source and binary form provided that the above  * copyright and these terms are retained, verbatim, as the first  * lines of this file.  Under no circumstances is the author  * responsible for the proper functioning of this software, nor does  * the author assume any responsibility for damages incurred with  * its use.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<dialog.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|"mbr.h"
end_include

begin_include
include|#
directive|include
file|"sysinstall.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|mbr
modifier|*
name|mbr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|inst_part
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|whole_disk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|part_type
name|part_types
index|[]
init|=
name|PARTITION_TYPES
name|char
operator|*
name|part_type
argument_list|(
argument|int type
argument_list|)
block|{
name|int
name|num_types
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|part_types
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|part_type
argument_list|)
operator|)
block|;
name|int
name|next_type
operator|=
literal|0
block|; 	struct
name|part_type
operator|*
name|ptr
operator|=
name|part_types
block|;
while|while
condition|(
name|next_type
operator|<
name|num_types
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|type
operator|==
name|type
condition|)
return|return
operator|(
name|ptr
operator|->
name|name
operator|)
return|;
name|ptr
operator|++
expr_stmt|;
name|next_type
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|"Uknown"
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|int
name|read_mbr
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|mbr
modifier|*
name|mbr
parameter_list|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"Couldn't seek for master boot record read\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
operator|(
name|mbr
operator|->
name|bootcode
operator|)
argument_list|,
name|MBRSIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"Failed to read master boot record\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Validate the master boot record */
if|if
condition|(
name|mbr
operator|->
name|magic
operator|!=
name|MBR_MAGIC
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"Master boot record is invalid\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|write_mbr
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|mbr
modifier|*
name|mbr
parameter_list|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"Couldn't seek for master boot record write\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|enable_label
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|mbr
operator|->
name|bootcode
argument_list|,
name|MBRSIZE
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"Failed to write master boot record\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|disable_label
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|show_mbr
parameter_list|(
name|struct
name|mbr
modifier|*
name|mbr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|key
init|=
literal|0
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|window
operator|=
name|newwin
argument_list|(
name|LINES
argument_list|,
name|COLS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|window
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|draw_box
argument_list|(
name|window
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|1
argument_list|,
name|COLOR_PAIR
argument_list|(
name|COLOR_YELLOW
argument_list|)
argument_list|,
name|COLOR_PAIR
argument_list|(
name|COLOR_BLUE
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDOSPART
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NDOSPART
operator|/
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|x
operator|=
operator|(
name|j
operator|*
literal|38
operator|)
operator|+
literal|3
expr_stmt|;
name|y
operator|=
operator|(
name|i
operator|*
literal|11
operator|)
operator|+
literal|2
expr_stmt|;
name|mvwprintw
argument_list|(
name|window
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
literal|"Partition %d: flags = %x"
argument_list|,
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
name|j
argument_list|,
name|mbr
operator|->
name|dospart
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
name|j
index|]
operator|.
name|dp_flag
argument_list|)
expr_stmt|;
name|mvwprintw
argument_list|(
name|window
argument_list|,
name|y
operator|+
literal|1
argument_list|,
name|x
argument_list|,
literal|"Starting at (C%d, H%d, S%d)"
argument_list|,
name|mbr
operator|->
name|dospart
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
name|j
index|]
operator|.
name|dp_scyl
argument_list|,
name|mbr
operator|->
name|dospart
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
name|j
index|]
operator|.
name|dp_shd
argument_list|,
name|mbr
operator|->
name|dospart
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
name|j
index|]
operator|.
name|dp_ssect
argument_list|)
expr_stmt|;
name|mvwprintw
argument_list|(
name|window
argument_list|,
name|y
operator|+
literal|2
argument_list|,
name|x
argument_list|,
literal|"Type: %s (%x)"
argument_list|,
name|part_type
argument_list|(
name|mbr
operator|->
name|dospart
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
name|j
index|]
operator|.
name|dp_typ
argument_list|)
argument_list|,
name|mbr
operator|->
name|dospart
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
name|j
index|]
operator|.
name|dp_typ
argument_list|)
expr_stmt|;
name|mvwprintw
argument_list|(
name|window
argument_list|,
name|y
operator|+
literal|3
argument_list|,
name|x
argument_list|,
literal|"Ending at (C%d, H%d, S%d)"
argument_list|,
name|mbr
operator|->
name|dospart
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
name|j
index|]
operator|.
name|dp_ecyl
argument_list|,
name|mbr
operator|->
name|dospart
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
name|j
index|]
operator|.
name|dp_ehd
argument_list|,
name|mbr
operator|->
name|dospart
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
name|j
index|]
operator|.
name|dp_esect
argument_list|)
expr_stmt|;
name|mvwprintw
argument_list|(
name|window
argument_list|,
name|y
operator|+
literal|4
argument_list|,
name|x
argument_list|,
literal|"Absolute start sector %ld"
argument_list|,
name|mbr
operator|->
name|dospart
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
name|j
index|]
operator|.
name|dp_start
argument_list|)
expr_stmt|;
name|mvwprintw
argument_list|(
name|window
argument_list|,
name|y
operator|+
literal|5
argument_list|,
name|x
argument_list|,
literal|"Size (in sectors) %ld"
argument_list|,
name|mbr
operator|->
name|dospart
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
name|j
index|]
operator|.
name|dp_size
argument_list|)
expr_stmt|;
block|}
block|}
name|refresh
argument_list|()
expr_stmt|;
while|while
condition|(
name|key
operator|!=
literal|'\n'
condition|)
name|key
operator|=
name|wgetch
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|dialog_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|clear_mbr
parameter_list|(
name|struct
name|mbr
modifier|*
name|mbr
parameter_list|,
name|char
modifier|*
name|bootcode
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* 	 * If installing to the whole disk 	 * then clobber any existing bootcode. 	 */
name|sprintf
argument_list|(
name|scratch
argument_list|,
literal|"\nLoading MBR code from %s\n"
argument_list|,
name|bootcode
argument_list|)
expr_stmt|;
name|dialog_msgbox
argument_list|(
name|TITLE
argument_list|,
name|scratch
argument_list|,
literal|5
argument_list|,
literal|60
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|bootcode
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"Couldn't open boot file %s\n"
argument_list|,
name|bootcode
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|mbr
operator|->
name|bootcode
argument_list|,
name|MBRSIZE
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"Couldn't read from boot file %s\n"
argument_list|,
name|bootcode
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"Couldn't close boot file %s\n"
argument_list|,
name|bootcode
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Create an empty partition table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDOSPART
condition|;
name|i
operator|++
control|)
block|{
name|mbr
operator|->
name|dospart
index|[
name|i
index|]
operator|.
name|dp_flag
operator|=
literal|0
expr_stmt|;
name|mbr
operator|->
name|dospart
index|[
name|i
index|]
operator|.
name|dp_shd
operator|=
literal|0
expr_stmt|;
name|mbr
operator|->
name|dospart
index|[
name|i
index|]
operator|.
name|dp_ssect
operator|=
literal|0
expr_stmt|;
name|mbr
operator|->
name|dospart
index|[
name|i
index|]
operator|.
name|dp_scyl
operator|=
literal|0
expr_stmt|;
name|mbr
operator|->
name|dospart
index|[
name|i
index|]
operator|.
name|dp_typ
operator|=
literal|0
expr_stmt|;
name|mbr
operator|->
name|dospart
index|[
name|i
index|]
operator|.
name|dp_ehd
operator|=
literal|0
expr_stmt|;
name|mbr
operator|->
name|dospart
index|[
name|i
index|]
operator|.
name|dp_esect
operator|=
literal|0
expr_stmt|;
name|mbr
operator|->
name|dospart
index|[
name|i
index|]
operator|.
name|dp_ecyl
operator|=
literal|0
expr_stmt|;
name|mbr
operator|->
name|dospart
index|[
name|i
index|]
operator|.
name|dp_start
operator|=
literal|0
expr_stmt|;
name|mbr
operator|->
name|dospart
index|[
name|i
index|]
operator|.
name|dp_size
operator|=
literal|0
expr_stmt|;
block|}
name|mbr
operator|->
name|magic
operator|=
name|MBR_MAGIC
expr_stmt|;
name|dialog_clear
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|build_mbr
parameter_list|(
name|struct
name|mbr
modifier|*
name|mbr
parameter_list|,
name|char
modifier|*
name|bootcode
parameter_list|,
name|struct
name|disklabel
modifier|*
name|lb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|dos_partition
modifier|*
name|dp
init|=
operator|&
name|mbr
operator|->
name|dospart
index|[
name|inst_part
index|]
decl_stmt|;
if|if
condition|(
name|whole_disk
condition|)
block|{
comment|/* Install to entire disk */
if|if
condition|(
name|clear_mbr
argument_list|(
name|mbr
argument_list|,
name|bootcode
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|dp
operator|->
name|dp_scyl
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|dp_shd
operator|=
literal|1
expr_stmt|;
name|dp
operator|->
name|dp_ssect
operator|=
literal|1
expr_stmt|;
name|dp
operator|->
name|dp_ecyl
operator|=
name|lb
operator|->
name|d_ncylinders
operator|-
literal|1
expr_stmt|;
name|dp
operator|->
name|dp_ehd
operator|=
name|lb
operator|->
name|d_ntracks
operator|-
literal|1
expr_stmt|;
name|dp
operator|->
name|dp_esect
operator|=
name|lb
operator|->
name|d_nsectors
expr_stmt|;
name|dp
operator|->
name|dp_start
operator|=
operator|(
name|dp
operator|->
name|dp_scyl
operator|*
name|lb
operator|->
name|d_ntracks
operator|*
name|lb
operator|->
name|d_nsectors
operator|)
operator|+
operator|(
name|dp
operator|->
name|dp_shd
operator|*
name|lb
operator|->
name|d_nsectors
operator|)
operator|+
name|dp
operator|->
name|dp_ssect
operator|-
literal|1
expr_stmt|;
name|dp
operator|->
name|dp_size
operator|=
operator|(
name|lb
operator|->
name|d_nsectors
operator|*
name|lb
operator|->
name|d_ntracks
operator|*
name|lb
operator|->
name|d_ncylinders
operator|)
operator|-
name|dp
operator|->
name|dp_start
expr_stmt|;
block|}
comment|/* Validate partition - XXX need to spend some time making this robust */
if|if
condition|(
operator|!
name|dp
operator|->
name|dp_start
condition|)
block|{
name|strcpy
argument_list|(
name|errmsg
argument_list|,
literal|"The start address of the selected partition is 0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Set partition type to FreeBSD and make it the only active partition */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDOSPART
condition|;
name|i
operator|++
control|)
name|mbr
operator|->
name|dospart
index|[
name|i
index|]
operator|.
name|dp_flag
operator|&=
operator|~
name|ACTIVE
expr_stmt|;
name|dp
operator|->
name|dp_typ
operator|=
name|DOSPTYP_386BSD
expr_stmt|;
name|dp
operator|->
name|dp_flag
operator|=
name|ACTIVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|edit_mbr
parameter_list|(
name|struct
name|mbr
modifier|*
name|mbr
parameter_list|,
name|struct
name|disklabel
modifier|*
name|label
parameter_list|)
block|{
name|dialog_msgbox
argument_list|(
literal|"DOS partition table editor"
argument_list|,
literal|"This editor is still under construction :-)"
argument_list|,
literal|10
argument_list|,
literal|75
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|show_mbr
argument_list|(
name|mbr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

