begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* #define DEBUG  * Copyright (c) 1994, Paul Richards.  *  * All rights reserved.  *  * This software may be used, modified, copied, distributed, and  * sold, in both source and binary form provided that the above  * copyright and these terms are retained, verbatim, as the first  * lines of this file.  Under no circumstances is the author  * responsible for the proper functioning of this software, nor does  * the author assume any responsibility for damages incurred with  * its use.  */
end_comment

begin_include
include|#
directive|include
file|<dialog.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|<machine/console.h>
end_include

begin_include
include|#
directive|include
file|"mbr.h"
end_include

begin_include
include|#
directive|include
file|"sysinstall.h"
end_include

begin_include
include|#
directive|include
file|"bootarea.h"
end_include

begin_decl_stmt
name|struct
name|disklabel
modifier|*
name|avail_disklabels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|avail_fds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
modifier|*
name|options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
modifier|*
name|avail_disknames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|scratch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|errmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|bootblocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbr
modifier|*
name|mbr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|no_disks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inst_disk
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inst_part
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|whole_disk
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|custom_install
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dialog_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|exit_sysinstall
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|exit_prompt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|part_type
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|selection
index|[
literal|30
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|boot1
index|[]
init|=
name|BOOT1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|boot2
index|[]
init|=
name|BOOT2
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|alloc_memory
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|scratch
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|SCRATCHSIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scratch
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|errmsg
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|ERRMSGSIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errmsg
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|avail_disklabels
operator|=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|calloc
argument_list|(
name|MAX_NO_DISKS
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|disklabel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|avail_disklabels
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|avail_fds
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
name|MAX_NO_DISKS
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|avail_fds
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|avail_disknames
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|MAX_NO_DISKS
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|avail_disknames
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NO_DISKS
condition|;
name|i
operator|++
control|)
block|{
name|avail_disknames
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
literal|15
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|avail_disknames
index|[
name|i
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|options
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|MAX_NO_DISKS
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|options
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NO_DISKS
condition|;
name|i
operator|++
control|)
block|{
name|options
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
literal|100
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|options
index|[
name|i
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mbr
operator|=
operator|(
expr|struct
name|mbr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mbr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mbr
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bootblocks
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|BBSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bootblocks
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free_memory
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|free
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|avail_disklabels
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|avail_fds
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NO_DISKS
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|avail_disknames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|avail_disknames
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NO_DISKS
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|options
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mbr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bootblocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|device_list
index|[]
init|=
block|{
literal|"wd"
block|,
literal|"sd"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|query_disks
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|disk
index|[
literal|15
index|]
decl_stmt|;
name|char
name|diskname
index|[
literal|5
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|disklabel
name|dl
decl_stmt|;
name|int
name|fd
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NO_DISKS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|Dname
index|[
name|i
index|]
condition|)
block|{
name|close
argument_list|(
name|Dfd
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Dfd
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|Dlbl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Dlbl
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|Dname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Dname
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|Ndisk
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|device_list
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|diskname
argument_list|,
literal|"%s%d"
argument_list|,
name|device_list
index|[
name|j
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|disk
argument_list|,
literal|"/dev/r%sd"
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|disk
argument_list|,
operator|&
name|st
argument_list|)
operator|||
operator|!
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFCHR
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|disk
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|DIOCGDINFO
argument_list|,
operator|&
name|dl
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Dlbl
index|[
name|Ndisk
index|]
operator|=
name|Malloc
argument_list|(
sizeof|sizeof
name|dl
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|Dlbl
index|[
name|Ndisk
index|]
argument_list|,
operator|&
name|dl
argument_list|,
sizeof|sizeof
name|dl
argument_list|)
expr_stmt|;
name|Dname
index|[
name|Ndisk
index|]
operator|=
name|StrAlloc
argument_list|(
name|diskname
argument_list|)
expr_stmt|;
name|Dfd
index|[
name|Ndisk
index|]
operator|=
name|fd
expr_stmt|;
name|Ndisk
operator|++
expr_stmt|;
if|if
condition|(
name|Ndisk
operator|==
name|MAX_NO_DISKS
condition|)
return|return;
block|}
block|}
block|}
end_function

begin_function
name|int
name|select_disk
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|valid
decl_stmt|;
do|do
block|{
name|valid
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|scratch
argument_list|,
literal|"There are %d disks available for installation: "
argument_list|,
name|no_disks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|no_disks
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|options
index|[
operator|(
name|i
operator|*
literal|2
operator|)
index|]
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|options
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
literal|1
index|]
argument_list|,
literal|"%s, (%dMb) -> %s"
argument_list|,
name|avail_disklabels
index|[
name|i
index|]
operator|.
name|d_typename
argument_list|,
name|disk_size
argument_list|(
operator|&
name|avail_disklabels
index|[
name|i
index|]
argument_list|)
argument_list|,
name|avail_disknames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dialog_menu
argument_list|(
literal|"FreeBSD Installation"
argument_list|,
name|scratch
argument_list|,
literal|10
argument_list|,
literal|75
argument_list|,
literal|5
argument_list|,
name|no_disks
argument_list|,
name|options
argument_list|,
name|selection
argument_list|)
condition|)
block|{
name|dialog_clear
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|scratch
argument_list|,
literal|"\n\n\nYou did not select a valid disk.\n\n"
argument_list|)
expr_stmt|;
name|AskAbort
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|0
expr_stmt|;
block|}
name|dialog_clear
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|valid
condition|)
do|;
return|return
operator|(
name|atoi
argument_list|(
name|selection
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|select_partition
parameter_list|(
name|int
name|disk
parameter_list|)
block|{
name|int
name|valid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|choice
decl_stmt|;
do|do
block|{
name|valid
operator|=
literal|1
expr_stmt|;
name|whole_disk
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|scratch
argument_list|,
literal|"Select one of the following areas to install to:"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|options
index|[
literal|0
index|]
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|options
index|[
literal|1
index|]
argument_list|,
literal|"%s, (%dMb)"
argument_list|,
literal|"Install to entire disk"
argument_list|,
name|disk_size
argument_list|(
operator|&
name|avail_disklabels
index|[
name|inst_disk
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDOSPART
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|options
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
literal|2
index|]
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|options
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
literal|3
index|]
argument_list|,
literal|"%s, (%ldMb)"
argument_list|,
name|part_type
argument_list|(
name|mbr
operator|->
name|dospart
index|[
name|i
index|]
operator|.
name|dp_typ
argument_list|)
argument_list|,
name|mbr
operator|->
name|dospart
index|[
name|i
index|]
operator|.
name|dp_size
operator|*
literal|512
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dialog_menu
argument_list|(
name|TITLE
argument_list|,
name|scratch
argument_list|,
literal|10
argument_list|,
literal|75
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|options
argument_list|,
name|selection
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|scratch
argument_list|,
literal|"You did not select a valid partition"
argument_list|)
expr_stmt|;
name|dialog_clear
argument_list|()
expr_stmt|;
name|AskAbort
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|valid
operator|=
literal|0
expr_stmt|;
block|}
name|dialog_clear
argument_list|()
expr_stmt|;
name|choice
operator|=
name|atoi
argument_list|(
name|selection
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|choice
operator|==
operator|-
literal|1
condition|)
block|{
name|whole_disk
operator|=
literal|1
expr_stmt|;
name|choice
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dialog_yesno
argument_list|(
name|TITLE
argument_list|,
literal|"\n\nInstalling to the whole disk will erase all its current data.\n\nAre you sure you want to do this?"
argument_list|,
literal|10
argument_list|,
literal|75
argument_list|)
condition|)
block|{
name|valid
operator|=
literal|0
expr_stmt|;
name|whole_disk
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|dialog_clear
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|valid
condition|)
do|;
return|return
operator|(
name|choice
operator|)
return|;
block|}
end_function

begin_function
name|void
name|stage1
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
name|int
name|ready
init|=
literal|0
decl_stmt|;
name|query_disks
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|ready
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|standend
argument_list|()
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|mvprintw
argument_list|(
name|j
operator|++
argument_list|,
literal|0
argument_list|,
literal|"%s -- Diskspace editor"
argument_list|,
name|TITLE
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|mvprintw
argument_list|(
name|j
operator|++
argument_list|,
literal|0
argument_list|,
literal|"Disks         Total   FreeBSD "
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NO_DISKS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Dname
index|[
name|i
index|]
condition|)
continue|continue;
name|mvprintw
argument_list|(
name|j
operator|++
argument_list|,
literal|0
argument_list|,
literal|"%2d: %-6s %5lu MB  %5lu MB"
argument_list|,
name|i
argument_list|,
name|Dname
index|[
name|i
index|]
argument_list|,
name|PartMb
argument_list|(
name|Dlbl
index|[
name|i
index|]
argument_list|,
name|RAWPART
argument_list|)
argument_list|,
name|PartMb
argument_list|(
name|Dlbl
index|[
name|i
index|]
argument_list|,
name|OURPART
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
name|mvprintw
argument_list|(
name|j
operator|++
argument_list|,
literal|0
argument_list|,
literal|"Filesystems  Type        Size  Mountpoint"
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NO_FS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Fname
index|[
name|i
index|]
condition|)
continue|continue;
name|mvprintw
argument_list|(
name|j
operator|++
argument_list|,
literal|0
argument_list|,
literal|"%2d: %-5s    %-5s   %5lu MB  %-s"
argument_list|,
name|i
argument_list|,
name|Fname
index|[
name|i
index|]
argument_list|,
name|Ftype
index|[
name|i
index|]
argument_list|,
name|Fsize
index|[
name|i
index|]
argument_list|,
name|Fmount
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|mvprintw
argument_list|(
literal|21
argument_list|,
literal|0
argument_list|,
literal|"Commands available:"
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|22
argument_list|,
literal|0
argument_list|,
literal|"(F)disk  (D)isklabel  (Q)uit"
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|23
argument_list|,
literal|0
argument_list|,
literal|"Enter Command> "
argument_list|)
expr_stmt|;
name|i
operator|=
name|getch
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
return|return;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|Fdisk
argument_list|()
expr_stmt|;
name|query_disks
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|DiskLabel
argument_list|()
expr_stmt|;
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Dname
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|close
argument_list|(
name|Dfd
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|while (!ready) { 	    ready = 1;  	    inst_disk = select_disk();  	    if (read_mbr(avail_fds[inst_disk], mbr) == -1) { 		sprintf(scratch, "The following error occured while trying\nto read the master boot record:\n\n%s\nIn order to install FreeBSD a new master boot record\nwill have to be written which will mean all current\ndata on the hard disk will be lost.", errmsg); 		ok = 0; 		while (!ok) {	 		    AskAbort(scratch); 		    if (!dialog_yesno(TITLE, 				      "Are you sure you wish to proceed?", 				      10, 75)) { 			dialog_clear(); 			if (clear_mbr(mbr, boot1) == -1) { 			    sprintf(scratch, "\n\nCouldn't create new master boot record.\n\n%s", errmsg); 			    Fatal(scratch);; 			} 			ok = 1; 		    } 		    dialog_clear(); 		} 	    } 	    if (custom_install)  		if (!dialog_yesno(TITLE, "Do you wish to edit the DOS partition table?", 				  10, 75)) { 		    dialog_clear(); 		    edit_mbr(mbr,&avail_disklabels[inst_disk]); 		}  	    dialog_clear(); 	    inst_part = select_partition(inst_disk);  	    ok = 0; 	    while (!ok) { 		if (build_mbr(mbr, boot1,&avail_disklabels[inst_disk]) != -1) { 		    ready = 1; 		    ok = 1; 		} else { 		    sprintf(scratch, "The DOS partition table is inconsistent.\n\n%s\nDo you wish to edit it by hand?", errmsg); 		    if (!dialog_yesno(TITLE, scratch, 10, 75)) { 			dialog_clear(); 			edit_mbr(mbr,&avail_disklabels[inst_disk]); 		    } else { 			dialog_clear(); 			AskAbort("Installation cannot proceed without\na valid master boot record\n"); 			ok = 1; 			ready = 0; 		    } 		} 		dialog_clear(); 	    }  	    if (ready) { 		default_disklabel(&avail_disklabels[inst_disk], 				  mbr->dospart[inst_part].dp_size, 				  mbr->dospart[inst_part].dp_start); 		dialog_msgbox(TITLE, "This is an experimental disklabel configuration\nmenu. It doesn't perform any validation of the entries\nas yet so BE SURE YOU TYPE THINGS CORRECTLY.\n\n    Hit escape to quit the editor.\n\nThere may be some delay exiting because of a dialog bug", 20,70,1); 		dialog_clear(); 		edit_disklabel(&avail_disklabels[inst_disk]);  		build_disklabel(&avail_disklabels[inst_disk]); 		if (build_bootblocks(&avail_disklabels[inst_disk]) == -1) 		    Fatal(errmsg); 	    }
comment|/* ready could have been reset above */
end_comment

begin_comment
unit|if (ready) { 		if (dialog_yesno(TITLE, "We are now ready to format the hard disk for FreeBSD.\n\nSome or all of the disk will be overwritten during this process.\n\nAre you sure you wish to proceed ?", 10, 75)) { 		    dialog_clear(); 		    AskAbort("Do you want to quit?"); 		    ready = 0; 		} 		dialog_clear(); 	    } 	} 	if (getenv("STAGE0")) { 	    Fatal("We stop here"); 	}
comment|/* Write master boot record and bootblocks */
end_comment

begin_comment
unit|if (write_mbr(avail_fds[inst_disk], mbr) == -1) 		Fatal(errmsg); 	if (write_bootblocks(avail_fds[inst_disk], 		  mbr->dospart[inst_part].dp_start, 		  avail_disklabels[inst_disk].d_bbsize) == -1) 		Fatal(errmsg);
comment|/* close all the open disks */
end_comment

begin_endif
unit|for (i=0; i< no_disks; i++) 		if (close(avail_fds[i]) == -1) { 			sprintf(errmsg, "Error on closing file descriptors: %s\n", 					  strerror(errno)); 			Fatal(errmsg); 		} }
endif|#
directive|endif
end_endif

end_unit

