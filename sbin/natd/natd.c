begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * natd - Network Address Translation Daemon for FreeBSD.  *  * This software is provided free of charge, with no   * warranty of any kind, either expressed or implied.  * Use at your own risk.  *   * You may copy, modify and distribute this software (natd.c) freely.  *  * Ari Suutari<suutari@iki.fi>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SYSLOG_NAMES
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<alias.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"natd.h"
end_include

begin_struct
struct|struct
name|instance
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|libalias
modifier|*
name|la
decl_stmt|;
name|LIST_ENTRY
argument_list|(
argument|instance
argument_list|)
name|list
expr_stmt|;
name|int
name|ifIndex
decl_stmt|;
name|int
name|assignAliasAddr
decl_stmt|;
name|char
modifier|*
name|ifName
decl_stmt|;
name|int
name|logDropped
decl_stmt|;
name|u_short
name|inPort
decl_stmt|;
name|u_short
name|outPort
decl_stmt|;
name|u_short
name|inOutPort
decl_stmt|;
name|struct
name|in_addr
name|aliasAddr
decl_stmt|;
name|int
name|ifMTU
decl_stmt|;
name|int
name|aliasOverhead
decl_stmt|;
name|int
name|dropIgnoredIncoming
decl_stmt|;
name|int
name|divertIn
decl_stmt|;
name|int
name|divertOut
decl_stmt|;
name|int
name|divertInOut
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|instance
argument_list|)
name|root
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|root
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|libalias
modifier|*
name|mla
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|instance
modifier|*
name|mip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ninstance
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Default values for input and output  * divert socket ports.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_SERVICE
value|"natd"
end_define

begin_comment
comment|/*  * Definition of a port range, and macros to deal with values.  * FORMAT:  HI 16-bits == first port in range, 0 == all ports.  *          LO 16-bits == number of ports in range  * NOTES:   - Port values are not stored in network byte order.  */
end_comment

begin_typedef
typedef|typedef
name|u_long
name|port_range
typedef|;
end_typedef

begin_define
define|#
directive|define
name|GETLOPORT
parameter_list|(
name|x
parameter_list|)
value|((x)>> 0x10)
end_define

begin_define
define|#
directive|define
name|GETNUMPORTS
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x0000ffff)
end_define

begin_define
define|#
directive|define
name|GETHIPORT
parameter_list|(
name|x
parameter_list|)
value|(GETLOPORT((x)) + GETNUMPORTS((x)))
end_define

begin_comment
comment|/* Set y to be the low-port value in port_range variable x. */
end_comment

begin_define
define|#
directive|define
name|SETLOPORT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) = ((x)& 0x0000ffff) | ((y)<< 0x10))
end_define

begin_comment
comment|/* Set y to be the number of ports in port_range variable x. */
end_comment

begin_define
define|#
directive|define
name|SETNUMPORTS
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) = ((x)& 0xffff0000) | (y))
end_define

begin_comment
comment|/*  * Function prototypes.  */
end_comment

begin_function_decl
specifier|static
name|void
name|DoAliasing
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|direction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DaemonMode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|HandleRoutingInfo
parameter_list|(
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|FormatPacket
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|PrintPacket
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SyslogPacket
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|int
name|priority
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SetAliasAddressFromIfName
parameter_list|(
specifier|const
name|char
modifier|*
name|ifName
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|InitiateShutdown
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Shutdown
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RefreshAddr
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ParseOption
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|parms
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ReadConfigFile
parameter_list|(
specifier|const
name|char
modifier|*
name|fileName
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SetupPortRedirect
parameter_list|(
specifier|const
name|char
modifier|*
name|parms
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SetupProtoRedirect
parameter_list|(
specifier|const
name|char
modifier|*
name|parms
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SetupAddressRedirect
parameter_list|(
specifier|const
name|char
modifier|*
name|parms
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|StrToAddr
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_short
name|StrToPort
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|proto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|StrToPortRange
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|proto
parameter_list|,
name|port_range
modifier|*
name|portRange
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|StrToProto
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|StrToAddrAndPortRange
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|,
name|char
modifier|*
name|proto
parameter_list|,
name|port_range
modifier|*
name|portRange
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ParseArgs
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SetupPunchFW
parameter_list|(
specifier|const
name|char
modifier|*
name|strValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SetupSkinnyPort
parameter_list|(
specifier|const
name|char
modifier|*
name|strValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|NewInstance
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DoGlobal
parameter_list|(
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|CheckIpfwRulenum
parameter_list|(
name|unsigned
name|int
name|rnum
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Globals.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|background
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|running
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|logFacility
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dynamicMode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|icmpSock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|logIpfwDenied
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|pidName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|routeSock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|globalPort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|divertGlobal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exitDelay
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|fd_set
name|readMask
decl_stmt|;
name|int
name|fdMax
decl_stmt|;
comment|/*   * Initialize packet aliasing software.  * Done already here to be able to alter option bits  * during command line and configuration file processing.  */
name|NewInstance
argument_list|(
literal|"default"
argument_list|)
expr_stmt|;
comment|/*  * Parse options.  */
name|verbose
operator|=
literal|0
expr_stmt|;
name|background
operator|=
literal|0
expr_stmt|;
name|running
operator|=
literal|1
expr_stmt|;
name|dynamicMode
operator|=
literal|0
expr_stmt|;
name|logFacility
operator|=
name|LOG_DAEMON
expr_stmt|;
name|logIpfwDenied
operator|=
operator|-
literal|1
expr_stmt|;
name|pidName
operator|=
name|PIDFILE
expr_stmt|;
name|routeSock
operator|=
operator|-
literal|1
expr_stmt|;
name|icmpSock
operator|=
operator|-
literal|1
expr_stmt|;
name|fdMax
operator|=
operator|-
literal|1
expr_stmt|;
name|divertGlobal
operator|=
operator|-
literal|1
expr_stmt|;
name|exitDelay
operator|=
name|EXIT_DELAY
expr_stmt|;
name|ParseArgs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/*  * Log ipfw(8) denied packets by default in verbose mode.  */
if|if
condition|(
name|logIpfwDenied
operator|==
operator|-
literal|1
condition|)
name|logIpfwDenied
operator|=
name|verbose
expr_stmt|;
comment|/*  * Open syslog channel.  */
name|openlog
argument_list|(
literal|"natd"
argument_list|,
name|LOG_CONS
operator||
name|LOG_PID
operator||
operator|(
name|verbose
condition|?
name|LOG_PERROR
else|:
literal|0
operator|)
argument_list|,
name|logFacility
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|mip
argument_list|,
argument|&root
argument_list|,
argument|list
argument_list|)
block|{
name|mla
operator|=
name|mip
operator|->
name|la
expr_stmt|;
comment|/*  * If not doing the transparent proxying only,  * check that valid aliasing address has been given.  */
if|if
condition|(
name|mip
operator|->
name|aliasAddr
operator|.
name|s_addr
operator|==
name|INADDR_NONE
operator|&&
name|mip
operator|->
name|ifName
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|LibAliasSetMode
argument_list|(
name|mla
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|&
name|PKT_ALIAS_PROXY_ONLY
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"instance %s: aliasing address not given"
argument_list|,
name|mip
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mip
operator|->
name|aliasAddr
operator|.
name|s_addr
operator|!=
name|INADDR_NONE
operator|&&
name|mip
operator|->
name|ifName
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"both alias address and interface "
literal|"name are not allowed"
argument_list|)
expr_stmt|;
comment|/*  * Check that valid port number is known.  */
if|if
condition|(
name|mip
operator|->
name|inPort
operator|!=
literal|0
operator|||
name|mip
operator|->
name|outPort
operator|!=
literal|0
condition|)
if|if
condition|(
name|mip
operator|->
name|inPort
operator|==
literal|0
operator|||
name|mip
operator|->
name|outPort
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"both input and output ports are required"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mip
operator|->
name|inPort
operator|==
literal|0
operator|&&
name|mip
operator|->
name|outPort
operator|==
literal|0
operator|&&
name|mip
operator|->
name|inOutPort
operator|==
literal|0
condition|)
name|ParseOption
argument_list|(
literal|"port"
argument_list|,
name|DEFAULT_SERVICE
argument_list|)
expr_stmt|;
comment|/*  * Check if ignored packets should be dropped.  */
name|mip
operator|->
name|dropIgnoredIncoming
operator|=
name|LibAliasSetMode
argument_list|(
name|mla
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mip
operator|->
name|dropIgnoredIncoming
operator|&=
name|PKT_ALIAS_DENY_INCOMING
expr_stmt|;
comment|/*  * Create divert sockets. Use only one socket if -p was specified  * on command line. Otherwise, create separate sockets for  * outgoing and incoming connnections.  */
if|if
condition|(
name|mip
operator|->
name|inOutPort
condition|)
block|{
name|mip
operator|->
name|divertInOut
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_DIVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mip
operator|->
name|divertInOut
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to create divert socket."
argument_list|)
expr_stmt|;
if|if
condition|(
name|mip
operator|->
name|divertInOut
operator|>
name|fdMax
condition|)
name|fdMax
operator|=
name|mip
operator|->
name|divertInOut
expr_stmt|;
name|mip
operator|->
name|divertIn
operator|=
operator|-
literal|1
expr_stmt|;
name|mip
operator|->
name|divertOut
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*  * Bind socket.  */
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|mip
operator|->
name|inOutPort
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|mip
operator|->
name|divertInOut
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to bind divert socket."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mip
operator|->
name|divertIn
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_DIVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mip
operator|->
name|divertIn
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to create incoming divert socket."
argument_list|)
expr_stmt|;
if|if
condition|(
name|mip
operator|->
name|divertIn
operator|>
name|fdMax
condition|)
name|fdMax
operator|=
name|mip
operator|->
name|divertIn
expr_stmt|;
name|mip
operator|->
name|divertOut
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_DIVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mip
operator|->
name|divertOut
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to create outgoing divert socket."
argument_list|)
expr_stmt|;
if|if
condition|(
name|mip
operator|->
name|divertOut
operator|>
name|fdMax
condition|)
name|fdMax
operator|=
name|mip
operator|->
name|divertOut
expr_stmt|;
name|mip
operator|->
name|divertInOut
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*  * Bind divert sockets.  */
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|mip
operator|->
name|inPort
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|mip
operator|->
name|divertIn
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to bind incoming divert socket."
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|mip
operator|->
name|outPort
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|mip
operator|->
name|divertOut
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to bind outgoing divert socket."
argument_list|)
expr_stmt|;
block|}
comment|/*  * Create routing socket if interface name specified and in dynamic mode.  */
if|if
condition|(
name|mip
operator|->
name|ifName
condition|)
block|{
if|if
condition|(
name|dynamicMode
condition|)
block|{
if|if
condition|(
name|routeSock
operator|==
operator|-
literal|1
condition|)
name|routeSock
operator|=
name|socket
argument_list|(
name|PF_ROUTE
argument_list|,
name|SOCK_RAW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|routeSock
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to create routing info socket."
argument_list|)
expr_stmt|;
if|if
condition|(
name|routeSock
operator|>
name|fdMax
condition|)
name|fdMax
operator|=
name|routeSock
expr_stmt|;
name|mip
operator|->
name|assignAliasAddr
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|SetAliasAddressFromIfName
argument_list|(
name|mip
operator|->
name|ifName
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|globalPort
condition|)
block|{
name|divertGlobal
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_DIVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|divertGlobal
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to create divert socket."
argument_list|)
expr_stmt|;
if|if
condition|(
name|divertGlobal
operator|>
name|fdMax
condition|)
name|fdMax
operator|=
name|divertGlobal
expr_stmt|;
comment|/* * Bind socket. */
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|globalPort
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|divertGlobal
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to bind global divert socket."
argument_list|)
expr_stmt|;
block|}
comment|/*  * Create socket for sending ICMP messages.  */
name|icmpSock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_ICMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmpSock
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to create ICMP socket."
argument_list|)
expr_stmt|;
comment|/*  * And disable reads for the socket, otherwise it slowly fills  * up with received icmps which we do not use.  */
name|shutdown
argument_list|(
name|icmpSock
argument_list|,
name|SHUT_RD
argument_list|)
expr_stmt|;
comment|/*  * Become a daemon unless verbose mode was requested.  */
if|if
condition|(
operator|!
name|verbose
condition|)
name|DaemonMode
argument_list|()
expr_stmt|;
comment|/*  * Catch signals to manage shutdown and  * refresh of interface address.  */
name|siginterrupt
argument_list|(
name|SIGTERM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|siginterrupt
argument_list|(
name|SIGHUP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitDelay
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|InitiateShutdown
argument_list|)
expr_stmt|;
else|else
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|Shutdown
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|RefreshAddr
argument_list|)
expr_stmt|;
comment|/*  * Set alias address if it has been given.  */
name|mip
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|root
argument_list|)
expr_stmt|;
comment|/* XXX: simon */
name|LIST_FOREACH
argument_list|(
argument|mip
argument_list|,
argument|&root
argument_list|,
argument|list
argument_list|)
block|{
name|mla
operator|=
name|mip
operator|->
name|la
expr_stmt|;
if|if
condition|(
name|mip
operator|->
name|aliasAddr
operator|.
name|s_addr
operator|!=
name|INADDR_NONE
condition|)
name|LibAliasSetAddress
argument_list|(
name|mla
argument_list|,
name|mip
operator|->
name|aliasAddr
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|running
condition|)
block|{
name|mip
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|root
argument_list|)
expr_stmt|;
comment|/* XXX: simon */
if|if
condition|(
name|mip
operator|->
name|divertInOut
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|mip
operator|->
name|ifName
operator|&&
name|ninstance
operator|==
literal|1
condition|)
block|{
comment|/*  * When using only one socket, just call   * DoAliasing repeatedly to process packets.  */
name|DoAliasing
argument_list|(
name|mip
operator|->
name|divertInOut
argument_list|,
name|DONT_KNOW
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*   * Build read mask from socket descriptors to select.  */
name|FD_ZERO
argument_list|(
operator|&
name|readMask
argument_list|)
expr_stmt|;
comment|/*  * Check if new packets are available.  */
name|LIST_FOREACH
argument_list|(
argument|mip
argument_list|,
argument|&root
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|mip
operator|->
name|divertIn
operator|!=
operator|-
literal|1
condition|)
name|FD_SET
argument_list|(
name|mip
operator|->
name|divertIn
argument_list|,
operator|&
name|readMask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mip
operator|->
name|divertOut
operator|!=
operator|-
literal|1
condition|)
name|FD_SET
argument_list|(
name|mip
operator|->
name|divertOut
argument_list|,
operator|&
name|readMask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mip
operator|->
name|divertInOut
operator|!=
operator|-
literal|1
condition|)
name|FD_SET
argument_list|(
name|mip
operator|->
name|divertInOut
argument_list|,
operator|&
name|readMask
argument_list|)
expr_stmt|;
block|}
comment|/*  * Routing info is processed always.  */
if|if
condition|(
name|routeSock
operator|!=
operator|-
literal|1
condition|)
name|FD_SET
argument_list|(
name|routeSock
argument_list|,
operator|&
name|readMask
argument_list|)
expr_stmt|;
if|if
condition|(
name|divertGlobal
operator|!=
operator|-
literal|1
condition|)
name|FD_SET
argument_list|(
name|divertGlobal
argument_list|,
operator|&
name|readMask
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|fdMax
operator|+
literal|1
argument_list|,
operator|&
name|readMask
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|Quit
argument_list|(
literal|"Select failed."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|divertGlobal
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|divertGlobal
argument_list|,
operator|&
name|readMask
argument_list|)
condition|)
name|DoGlobal
argument_list|(
name|divertGlobal
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|mip
argument_list|,
argument|&root
argument_list|,
argument|list
argument_list|)
block|{
name|mla
operator|=
name|mip
operator|->
name|la
expr_stmt|;
if|if
condition|(
name|mip
operator|->
name|divertIn
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|mip
operator|->
name|divertIn
argument_list|,
operator|&
name|readMask
argument_list|)
condition|)
name|DoAliasing
argument_list|(
name|mip
operator|->
name|divertIn
argument_list|,
name|INPUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mip
operator|->
name|divertOut
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|mip
operator|->
name|divertOut
argument_list|,
operator|&
name|readMask
argument_list|)
condition|)
name|DoAliasing
argument_list|(
name|mip
operator|->
name|divertOut
argument_list|,
name|OUTPUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mip
operator|->
name|divertInOut
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|mip
operator|->
name|divertInOut
argument_list|,
operator|&
name|readMask
argument_list|)
condition|)
name|DoAliasing
argument_list|(
name|mip
operator|->
name|divertInOut
argument_list|,
name|DONT_KNOW
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|routeSock
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|routeSock
argument_list|,
operator|&
name|readMask
argument_list|)
condition|)
name|HandleRoutingInfo
argument_list|(
name|routeSock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|background
condition|)
name|unlink
argument_list|(
name|pidName
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|DaemonMode
parameter_list|()
block|{
name|FILE
modifier|*
name|pidFile
decl_stmt|;
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|background
operator|=
literal|1
expr_stmt|;
name|pidFile
operator|=
name|fopen
argument_list|(
name|pidName
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pidFile
condition|)
block|{
name|fprintf
argument_list|(
name|pidFile
argument_list|,
literal|"%d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|pidFile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ParseArgs
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|arg
decl_stmt|;
name|char
modifier|*
name|opt
decl_stmt|;
name|char
name|parmBuf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* bounds checking */
for|for
control|(
name|arg
operator|=
literal|1
init|;
name|arg
operator|<
name|argc
condition|;
name|arg
operator|++
control|)
block|{
name|opt
operator|=
name|argv
index|[
name|arg
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|opt
operator|!=
literal|'-'
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid option %s"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|Usage
argument_list|()
expr_stmt|;
block|}
name|parmBuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|arg
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|arg
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
break|break;
if|if
condition|(
name|len
condition|)
block|{
name|strncat
argument_list|(
name|parmBuf
argument_list|,
literal|" "
argument_list|,
sizeof|sizeof
argument_list|(
name|parmBuf
argument_list|)
operator|-
operator|(
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|parmBuf
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
operator|++
name|arg
expr_stmt|;
name|strncat
argument_list|(
name|parmBuf
argument_list|,
name|argv
index|[
name|arg
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|parmBuf
argument_list|)
operator|-
operator|(
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|parmBuf
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
name|ParseOption
argument_list|(
name|opt
operator|+
literal|1
argument_list|,
operator|(
name|len
condition|?
name|parmBuf
else|:
name|NULL
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|DoGlobal
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|bytes
decl_stmt|;
name|int
name|origBytes
decl_stmt|;
name|char
name|buf
index|[
name|IP_MAXPACKET
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|int
name|wrote
decl_stmt|;
name|socklen_t
name|addrSize
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|char
name|msgBuf
index|[
literal|80
index|]
decl_stmt|;
comment|/*  * Get packet from socket.  */
name|addrSize
operator|=
sizeof|sizeof
name|addr
expr_stmt|;
name|origBytes
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|addrSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|origBytes
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|Warn
argument_list|(
literal|"read from divert socket failed"
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
block|if (mip->assignAliasAddr) { 		SetAliasAddressFromIfName (mip->ifName); 		mip->assignAliasAddr = 0; 	}
endif|#
directive|endif
comment|/*  * This is an IP packet.  */
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
comment|/*  * Print packet direction and protocol type.  */
name|printf
argument_list|(
literal|"Glb "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|printf
argument_list|(
literal|"[TCP]  "
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|printf
argument_list|(
literal|"[UDP]  "
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|printf
argument_list|(
literal|"[ICMP] "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"[%d]    "
argument_list|,
name|ip
operator|->
name|ip_p
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*  * Print addresses.  */
name|PrintPacket
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|mip
argument_list|,
argument|&root
argument_list|,
argument|list
argument_list|)
block|{
name|mla
operator|=
name|mip
operator|->
name|la
expr_stmt|;
if|if
condition|(
name|LibAliasOutTry
argument_list|(
name|mla
argument_list|,
name|buf
argument_list|,
name|IP_MAXPACKET
argument_list|,
literal|0
argument_list|)
operator|!=
name|PKT_ALIAS_IGNORED
condition|)
break|break;
block|}
comment|/*  * Length might have changed during aliasing.  */
name|bytes
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
comment|/*  * Update alias overhead size for outgoing packets.  */
if|if
condition|(
name|mip
operator|!=
name|NULL
operator|&&
name|bytes
operator|-
name|origBytes
operator|>
name|mip
operator|->
name|aliasOverhead
condition|)
name|mip
operator|->
name|aliasOverhead
operator|=
name|bytes
operator|-
name|origBytes
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
comment|/*  * Print addresses after aliasing.  */
name|printf
argument_list|(
literal|" aliased to\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"           "
argument_list|)
expr_stmt|;
name|PrintPacket
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/*  * Put packet back for processing.  */
name|wrote
operator|=
name|sendto
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrote
operator|!=
name|bytes
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EMSGSIZE
condition|)
block|{
if|if
condition|(
name|mip
operator|->
name|ifMTU
operator|!=
operator|-
literal|1
condition|)
name|SendNeedFragIcmp
argument_list|(
name|icmpSock
argument_list|,
operator|(
expr|struct
name|ip
operator|*
operator|)
name|buf
argument_list|,
name|mip
operator|->
name|ifMTU
operator|-
name|mip
operator|->
name|aliasOverhead
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|EACCES
operator|&&
name|logIpfwDenied
condition|)
block|{
name|sprintf
argument_list|(
name|msgBuf
argument_list|,
literal|"failed to write packet back"
argument_list|)
expr_stmt|;
name|Warn
argument_list|(
name|msgBuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|DoAliasing
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|int
name|bytes
decl_stmt|;
name|int
name|origBytes
decl_stmt|;
name|char
name|buf
index|[
name|IP_MAXPACKET
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|int
name|wrote
decl_stmt|;
name|int
name|status
decl_stmt|;
name|socklen_t
name|addrSize
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|char
name|msgBuf
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|mip
operator|->
name|assignAliasAddr
condition|)
block|{
name|SetAliasAddressFromIfName
argument_list|(
name|mip
operator|->
name|ifName
argument_list|)
expr_stmt|;
name|mip
operator|->
name|assignAliasAddr
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  * Get packet from socket.  */
name|addrSize
operator|=
sizeof|sizeof
name|addr
expr_stmt|;
name|origBytes
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|addrSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|origBytes
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|Warn
argument_list|(
literal|"read from divert socket failed"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * This is an IP packet.  */
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|DONT_KNOW
condition|)
block|{
if|if
condition|(
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|direction
operator|=
name|OUTPUT
expr_stmt|;
else|else
name|direction
operator|=
name|INPUT
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
comment|/*  * Print packet direction and protocol type.  */
name|printf
argument_list|(
name|direction
operator|==
name|OUTPUT
condition|?
literal|"Out "
else|:
literal|"In  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ninstance
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"{%s}"
argument_list|,
name|mip
operator|->
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|printf
argument_list|(
literal|"[TCP]  "
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|printf
argument_list|(
literal|"[UDP]  "
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|printf
argument_list|(
literal|"[ICMP] "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"[%d]    "
argument_list|,
name|ip
operator|->
name|ip_p
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*  * Print addresses.  */
name|PrintPacket
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|direction
operator|==
name|OUTPUT
condition|)
block|{
comment|/*  * Outgoing packets. Do aliasing.  */
name|LibAliasOut
argument_list|(
name|mla
argument_list|,
name|buf
argument_list|,
name|IP_MAXPACKET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  * Do aliasing.  */
name|status
operator|=
name|LibAliasIn
argument_list|(
name|mla
argument_list|,
name|buf
argument_list|,
name|IP_MAXPACKET
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|PKT_ALIAS_IGNORED
operator|&&
name|mip
operator|->
name|dropIgnoredIncoming
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|" dropped.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mip
operator|->
name|logDropped
condition|)
name|SyslogPacket
argument_list|(
name|ip
argument_list|,
name|LOG_WARNING
argument_list|,
literal|"denied"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/*  * Length might have changed during aliasing.  */
name|bytes
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
comment|/*  * Update alias overhead size for outgoing packets.  */
if|if
condition|(
name|direction
operator|==
name|OUTPUT
operator|&&
name|bytes
operator|-
name|origBytes
operator|>
name|mip
operator|->
name|aliasOverhead
condition|)
name|mip
operator|->
name|aliasOverhead
operator|=
name|bytes
operator|-
name|origBytes
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
comment|/*  * Print addresses after aliasing.  */
name|printf
argument_list|(
literal|" aliased to\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"           "
argument_list|)
expr_stmt|;
name|PrintPacket
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/*  * Put packet back for processing.  */
name|wrote
operator|=
name|sendto
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrote
operator|!=
name|bytes
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EMSGSIZE
condition|)
block|{
if|if
condition|(
name|direction
operator|==
name|OUTPUT
operator|&&
name|mip
operator|->
name|ifMTU
operator|!=
operator|-
literal|1
condition|)
name|SendNeedFragIcmp
argument_list|(
name|icmpSock
argument_list|,
operator|(
expr|struct
name|ip
operator|*
operator|)
name|buf
argument_list|,
name|mip
operator|->
name|ifMTU
operator|-
name|mip
operator|->
name|aliasOverhead
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|EACCES
operator|&&
name|logIpfwDenied
condition|)
block|{
name|sprintf
argument_list|(
name|msgBuf
argument_list|,
literal|"failed to write packet back"
argument_list|)
expr_stmt|;
name|Warn
argument_list|(
name|msgBuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|HandleRoutingInfo
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|bytes
decl_stmt|;
name|struct
name|if_msghdr
name|ifMsg
decl_stmt|;
comment|/*  * Get packet from socket.  */
name|bytes
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|ifMsg
argument_list|,
sizeof|sizeof
name|ifMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
operator|-
literal|1
condition|)
block|{
name|Warn
argument_list|(
literal|"read from routing socket failed"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ifMsg
operator|.
name|ifm_version
operator|!=
name|RTM_VERSION
condition|)
block|{
name|Warn
argument_list|(
literal|"unexpected packet read from routing socket"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Routing message %#x received.\n"
argument_list|,
name|ifMsg
operator|.
name|ifm_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifMsg
operator|.
name|ifm_type
operator|==
name|RTM_NEWADDR
operator|||
name|ifMsg
operator|.
name|ifm_type
operator|==
name|RTM_IFINFO
operator|)
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|mip
argument_list|,
argument|&root
argument_list|,
argument|list
argument_list|)
block|{
name|mla
operator|=
name|mip
operator|->
name|la
expr_stmt|;
if|if
condition|(
name|ifMsg
operator|.
name|ifm_index
operator|==
name|mip
operator|->
name|ifIndex
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Interface address/MTU has probably changed.\n"
argument_list|)
expr_stmt|;
name|mip
operator|->
name|assignAliasAddr
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|PrintPacket
parameter_list|(
name|struct
name|ip
modifier|*
name|ip
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|FormatPacket
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|SyslogPacket
parameter_list|(
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|int
name|priority
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
name|syslog
argument_list|(
name|priority
argument_list|,
literal|"%s %s"
argument_list|,
name|label
argument_list|,
name|FormatPacket
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|FormatPacket
parameter_list|(
name|struct
name|ip
modifier|*
name|ip
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcphdr
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|udphdr
decl_stmt|;
name|struct
name|icmp
modifier|*
name|icmphdr
decl_stmt|;
name|char
name|src
index|[
literal|20
index|]
decl_stmt|;
name|char
name|dst
index|[
literal|20
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|src
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dst
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|tcphdr
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[TCP] %s:%d -> %s:%d"
argument_list|,
name|src
argument_list|,
name|ntohs
argument_list|(
name|tcphdr
operator|->
name|th_sport
argument_list|)
argument_list|,
name|dst
argument_list|,
name|ntohs
argument_list|(
name|tcphdr
operator|->
name|th_dport
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|udphdr
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[UDP] %s:%d -> %s:%d"
argument_list|,
name|src
argument_list|,
name|ntohs
argument_list|(
name|udphdr
operator|->
name|uh_sport
argument_list|)
argument_list|,
name|dst
argument_list|,
name|ntohs
argument_list|(
name|udphdr
operator|->
name|uh_dport
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|icmphdr
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[ICMP] %s -> %s %u(%u)"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|icmphdr
operator|->
name|icmp_type
argument_list|,
name|icmphdr
operator|->
name|icmp_code
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[%d] %s -> %s "
argument_list|,
name|ip
operator|->
name|ip_p
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|SetAliasAddressFromIfName
parameter_list|(
specifier|const
name|char
modifier|*
name|ifn
parameter_list|)
block|{
name|size_t
name|needed
decl_stmt|;
name|int
name|mib
index|[
literal|6
index|]
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|lim
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|if_msghdr
modifier|*
name|ifm
decl_stmt|;
name|struct
name|ifa_msghdr
modifier|*
name|ifam
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_NET
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|PF_ROUTE
expr_stmt|;
name|mib
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mib
index|[
literal|3
index|]
operator|=
name|AF_INET
expr_stmt|;
comment|/* Only IP addresses please */
name|mib
index|[
literal|4
index|]
operator|=
name|NET_RT_IFLIST
expr_stmt|;
name|mib
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* ifIndex??? */
comment|/*  * Get interface data.  */
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
name|NULL
argument_list|,
operator|&
name|needed
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"iflist-sysctl-estimate"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|needed
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
name|buf
argument_list|,
operator|&
name|needed
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|ENOMEM
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"iflist-sysctl-get"
argument_list|)
expr_stmt|;
name|lim
operator|=
name|buf
operator|+
name|needed
expr_stmt|;
comment|/*  * Loop through interfaces until one with  * given name is found. This is done to  * find correct interface index for routing  * message processing.  */
name|mip
operator|->
name|ifIndex
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|next
operator|<
name|lim
condition|)
block|{
name|ifm
operator|=
operator|(
expr|struct
name|if_msghdr
operator|*
operator|)
name|next
expr_stmt|;
name|next
operator|+=
name|ifm
operator|->
name|ifm_msglen
expr_stmt|;
if|if
condition|(
name|ifm
operator|->
name|ifm_version
operator|!=
name|RTM_VERSION
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|warnx
argument_list|(
literal|"routing message version %d "
literal|"not understood"
argument_list|,
name|ifm
operator|->
name|ifm_version
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ifm
operator|->
name|ifm_type
operator|==
name|RTM_IFINFO
condition|)
block|{
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|(
name|ifm
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|ifn
argument_list|)
operator|==
name|sdl
operator|->
name|sdl_nlen
operator|&&
name|strncmp
argument_list|(
name|ifn
argument_list|,
name|sdl
operator|->
name|sdl_data
argument_list|,
name|sdl
operator|->
name|sdl_nlen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mip
operator|->
name|ifIndex
operator|=
name|ifm
operator|->
name|ifm_index
expr_stmt|;
name|mip
operator|->
name|ifMTU
operator|=
name|ifm
operator|->
name|ifm_data
operator|.
name|ifi_mtu
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|mip
operator|->
name|ifIndex
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown interface name %s"
argument_list|,
name|ifn
argument_list|)
expr_stmt|;
comment|/*  * Get interface address.  */
name|sin
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|next
operator|<
name|lim
condition|)
block|{
name|ifam
operator|=
operator|(
expr|struct
name|ifa_msghdr
operator|*
operator|)
name|next
expr_stmt|;
name|next
operator|+=
name|ifam
operator|->
name|ifam_msglen
expr_stmt|;
if|if
condition|(
name|ifam
operator|->
name|ifam_version
operator|!=
name|RTM_VERSION
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|warnx
argument_list|(
literal|"routing message version %d "
literal|"not understood"
argument_list|,
name|ifam
operator|->
name|ifam_version
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ifam
operator|->
name|ifam_type
operator|!=
name|RTM_NEWADDR
condition|)
break|break;
if|if
condition|(
name|ifam
operator|->
name|ifam_addrs
operator|&
name|RTA_IFA
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ifam
operator|+
literal|1
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|RTA_IFA
condition|;
name|i
operator|<<=
literal|1
control|)
if|if
condition|(
name|ifam
operator|->
name|ifam_addrs
operator|&
name|i
condition|)
name|cp
operator|+=
name|SA_SIZE
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|cp
operator|)
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|cp
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: cannot get interface address"
argument_list|,
name|ifn
argument_list|)
expr_stmt|;
name|LibAliasSetAddress
argument_list|(
name|mla
argument_list|,
name|sin
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Aliasing to %s, mtu %d bytes"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|mip
operator|->
name|ifMTU
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Quit
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|Warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Warn
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|background
condition|)
name|syslog
argument_list|(
name|LOG_ALERT
argument_list|,
literal|"%s (%m)"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|RefreshAddr
parameter_list|(
name|int
name|sig
name|__unused
parameter_list|)
block|{
name|LibAliasRefreshModules
argument_list|()
expr_stmt|;
if|if
condition|(
name|mip
operator|!=
name|NULL
operator|&&
name|mip
operator|->
name|ifName
operator|!=
name|NULL
condition|)
name|mip
operator|->
name|assignAliasAddr
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|InitiateShutdown
parameter_list|(
name|int
name|sig
name|__unused
parameter_list|)
block|{
comment|/*  * Start timer to allow kernel gracefully  * shutdown existing connections when system  * is shut down.  */
name|siginterrupt
argument_list|(
name|SIGALRM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|Shutdown
argument_list|)
expr_stmt|;
name|ualarm
argument_list|(
name|exitDelay
operator|*
literal|1000
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Shutdown
parameter_list|(
name|int
name|sig
name|__unused
parameter_list|)
block|{
name|running
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Different options recognized by this program.  */
end_comment

begin_enum
enum|enum
name|Option
block|{
name|LibAliasOption
block|,
name|Instance
block|,
name|Verbose
block|,
name|InPort
block|,
name|OutPort
block|,
name|Port
block|,
name|GlobalPort
block|,
name|AliasAddress
block|,
name|TargetAddress
block|,
name|InterfaceName
block|,
name|RedirectPort
block|,
name|RedirectProto
block|,
name|RedirectAddress
block|,
name|ConfigFile
block|,
name|DynamicMode
block|,
name|ProxyRule
block|,
name|LogDenied
block|,
name|LogFacility
block|,
name|PunchFW
block|,
name|SkinnyPort
block|,
name|LogIpfwDenied
block|,
name|PidFile
block|,
name|ExitDelay
block|}
enum|;
end_enum

begin_enum
enum|enum
name|Param
block|{
name|YesNo
block|,
name|Numeric
block|,
name|String
block|,
name|None
block|,
name|Address
block|,
name|Service
block|}
enum|;
end_enum

begin_comment
comment|/*  * Option information structure (used by ParseOption).  */
end_comment

begin_struct
struct|struct
name|OptionInfo
block|{
name|enum
name|Option
name|type
decl_stmt|;
name|int
name|packetAliasOpt
decl_stmt|;
name|enum
name|Param
name|parm
decl_stmt|;
specifier|const
name|char
modifier|*
name|parmDescription
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|shortName
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Table of known options.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|OptionInfo
name|optionTable
index|[]
init|=
block|{
block|{
name|LibAliasOption
block|,
name|PKT_ALIAS_UNREGISTERED_ONLY
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"alias only unregistered addresses"
block|,
literal|"unregistered_only"
block|,
literal|"u"
block|}
block|,
block|{
name|LibAliasOption
block|,
name|PKT_ALIAS_LOG
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"enable logging"
block|,
literal|"log"
block|,
literal|"l"
block|}
block|,
block|{
name|LibAliasOption
block|,
name|PKT_ALIAS_PROXY_ONLY
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"proxy only"
block|,
literal|"proxy_only"
block|,
name|NULL
block|}
block|,
block|{
name|LibAliasOption
block|,
name|PKT_ALIAS_REVERSE
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"operate in reverse mode"
block|,
literal|"reverse"
block|,
name|NULL
block|}
block|,
block|{
name|LibAliasOption
block|,
name|PKT_ALIAS_DENY_INCOMING
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"allow incoming connections"
block|,
literal|"deny_incoming"
block|,
literal|"d"
block|}
block|,
block|{
name|LibAliasOption
block|,
name|PKT_ALIAS_USE_SOCKETS
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"use sockets to inhibit port conflict"
block|,
literal|"use_sockets"
block|,
literal|"s"
block|}
block|,
block|{
name|LibAliasOption
block|,
name|PKT_ALIAS_SAME_PORTS
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"try to keep original port numbers for connections"
block|,
literal|"same_ports"
block|,
literal|"m"
block|}
block|,
block|{
name|Verbose
block|,
literal|0
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"verbose mode, dump packet information"
block|,
literal|"verbose"
block|,
literal|"v"
block|}
block|,
block|{
name|DynamicMode
block|,
literal|0
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"dynamic mode, automatically detect interface address changes"
block|,
literal|"dynamic"
block|,
name|NULL
block|}
block|,
block|{
name|InPort
block|,
literal|0
block|,
name|Service
block|,
literal|"number|service_name"
block|,
literal|"set port for incoming packets"
block|,
literal|"in_port"
block|,
literal|"i"
block|}
block|,
block|{
name|OutPort
block|,
literal|0
block|,
name|Service
block|,
literal|"number|service_name"
block|,
literal|"set port for outgoing packets"
block|,
literal|"out_port"
block|,
literal|"o"
block|}
block|,
block|{
name|Port
block|,
literal|0
block|,
name|Service
block|,
literal|"number|service_name"
block|,
literal|"set port (defaults to natd/divert)"
block|,
literal|"port"
block|,
literal|"p"
block|}
block|,
block|{
name|GlobalPort
block|,
literal|0
block|,
name|Service
block|,
literal|"number|service_name"
block|,
literal|"set globalport"
block|,
literal|"globalport"
block|,
name|NULL
block|}
block|,
block|{
name|AliasAddress
block|,
literal|0
block|,
name|Address
block|,
literal|"x.x.x.x"
block|,
literal|"address to use for aliasing"
block|,
literal|"alias_address"
block|,
literal|"a"
block|}
block|,
block|{
name|TargetAddress
block|,
literal|0
block|,
name|Address
block|,
literal|"x.x.x.x"
block|,
literal|"address to use for incoming sessions"
block|,
literal|"target_address"
block|,
literal|"t"
block|}
block|,
block|{
name|InterfaceName
block|,
literal|0
block|,
name|String
block|,
literal|"network_if_name"
block|,
literal|"take aliasing address from interface"
block|,
literal|"interface"
block|,
literal|"n"
block|}
block|,
block|{
name|ProxyRule
block|,
literal|0
block|,
name|String
block|,
literal|"[type encode_ip_hdr|encode_tcp_stream] port xxxx server "
literal|"a.b.c.d:yyyy"
block|,
literal|"add transparent proxying / destination NAT"
block|,
literal|"proxy_rule"
block|,
name|NULL
block|}
block|,
block|{
name|RedirectPort
block|,
literal|0
block|,
name|String
block|,
literal|"tcp|udp local_addr:local_port_range[,...] [public_addr:]public_port_range"
literal|" [remote_addr[:remote_port_range]]"
block|,
literal|"redirect a port (or ports) for incoming traffic"
block|,
literal|"redirect_port"
block|,
name|NULL
block|}
block|,
block|{
name|RedirectProto
block|,
literal|0
block|,
name|String
block|,
literal|"proto local_addr [public_addr] [remote_addr]"
block|,
literal|"redirect packets of a given proto"
block|,
literal|"redirect_proto"
block|,
name|NULL
block|}
block|,
block|{
name|RedirectAddress
block|,
literal|0
block|,
name|String
block|,
literal|"local_addr[,...] public_addr"
block|,
literal|"define mapping between local and public addresses"
block|,
literal|"redirect_address"
block|,
name|NULL
block|}
block|,
block|{
name|ConfigFile
block|,
literal|0
block|,
name|String
block|,
literal|"file_name"
block|,
literal|"read options from configuration file"
block|,
literal|"config"
block|,
literal|"f"
block|}
block|,
block|{
name|LogDenied
block|,
literal|0
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"enable logging of denied incoming packets"
block|,
literal|"log_denied"
block|,
name|NULL
block|}
block|,
block|{
name|LogFacility
block|,
literal|0
block|,
name|String
block|,
literal|"facility"
block|,
literal|"name of syslog facility to use for logging"
block|,
literal|"log_facility"
block|,
name|NULL
block|}
block|,
block|{
name|PunchFW
block|,
literal|0
block|,
name|String
block|,
literal|"basenumber:count"
block|,
literal|"punch holes in the firewall for incoming FTP/IRC DCC connections"
block|,
literal|"punch_fw"
block|,
name|NULL
block|}
block|,
block|{
name|SkinnyPort
block|,
literal|0
block|,
name|String
block|,
literal|"port"
block|,
literal|"set the TCP port for use with the Skinny Station protocol"
block|,
literal|"skinny_port"
block|,
name|NULL
block|}
block|,
block|{
name|LogIpfwDenied
block|,
literal|0
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"log packets converted by natd, but denied by ipfw"
block|,
literal|"log_ipfw_denied"
block|,
name|NULL
block|}
block|,
block|{
name|PidFile
block|,
literal|0
block|,
name|String
block|,
literal|"file_name"
block|,
literal|"store PID in an alternate file"
block|,
literal|"pid_file"
block|,
literal|"P"
block|}
block|,
block|{
name|Instance
block|,
literal|0
block|,
name|String
block|,
literal|"instance name"
block|,
literal|"name of aliasing engine instance"
block|,
literal|"instance"
block|,
name|NULL
block|}
block|,
block|{
name|ExitDelay
block|,
literal|0
block|,
name|Numeric
block|,
literal|"ms"
block|,
literal|"delay in ms before daemon exit after signal"
block|,
literal|"exit_delay"
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ParseOption
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|parms
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|OptionInfo
modifier|*
name|info
decl_stmt|;
name|int
name|yesNoValue
decl_stmt|;
name|int
name|aliasValue
decl_stmt|;
name|int
name|numValue
decl_stmt|;
name|u_short
name|uNumValue
decl_stmt|;
specifier|const
name|char
modifier|*
name|strValue
decl_stmt|;
name|struct
name|in_addr
name|addrValue
decl_stmt|;
name|int
name|max
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|CODE
modifier|*
name|fac_record
init|=
name|NULL
decl_stmt|;
comment|/*  * Find option from table.  */
name|max
operator|=
sizeof|sizeof
argument_list|(
name|optionTable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|OptionInfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|info
operator|=
name|optionTable
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
operator|,
name|info
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
name|option
argument_list|)
condition|)
break|break;
if|if
condition|(
name|info
operator|->
name|shortName
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|shortName
argument_list|,
name|option
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|max
condition|)
block|{
name|warnx
argument_list|(
literal|"unknown option %s"
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|Usage
argument_list|()
expr_stmt|;
block|}
name|uNumValue
operator|=
literal|0
expr_stmt|;
name|yesNoValue
operator|=
literal|0
expr_stmt|;
name|numValue
operator|=
literal|0
expr_stmt|;
name|strValue
operator|=
name|NULL
expr_stmt|;
comment|/*  * Check parameters.  */
switch|switch
condition|(
name|info
operator|->
name|parm
condition|)
block|{
case|case
name|YesNo
case|:
if|if
condition|(
operator|!
name|parms
condition|)
name|parms
operator|=
literal|"yes"
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|parms
argument_list|,
literal|"yes"
argument_list|)
condition|)
name|yesNoValue
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|parms
argument_list|,
literal|"no"
argument_list|)
condition|)
name|yesNoValue
operator|=
literal|0
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s needs yes/no parameter"
argument_list|,
name|option
argument_list|)
expr_stmt|;
break|break;
case|case
name|Service
case|:
if|if
condition|(
operator|!
name|parms
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s needs service name or "
literal|"port number parameter"
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|uNumValue
operator|=
name|StrToPort
argument_list|(
name|parms
argument_list|,
literal|"divert"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Numeric
case|:
if|if
condition|(
name|parms
condition|)
name|numValue
operator|=
name|strtol
argument_list|(
name|parms
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|else
name|end
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|parms
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s needs numeric parameter"
argument_list|,
name|option
argument_list|)
expr_stmt|;
break|break;
case|case
name|String
case|:
name|strValue
operator|=
name|parms
expr_stmt|;
if|if
condition|(
operator|!
name|strValue
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s needs parameter"
argument_list|,
name|option
argument_list|)
expr_stmt|;
break|break;
case|case
name|None
case|:
if|if
condition|(
name|parms
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s does not take parameters"
argument_list|,
name|option
argument_list|)
expr_stmt|;
break|break;
case|case
name|Address
case|:
if|if
condition|(
operator|!
name|parms
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s needs address/host parameter"
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|StrToAddr
argument_list|(
name|parms
argument_list|,
operator|&
name|addrValue
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|info
operator|->
name|type
condition|)
block|{
case|case
name|LibAliasOption
case|:
name|aliasValue
operator|=
name|yesNoValue
condition|?
name|info
operator|->
name|packetAliasOpt
else|:
literal|0
expr_stmt|;
name|LibAliasSetMode
argument_list|(
name|mla
argument_list|,
name|aliasValue
argument_list|,
name|info
operator|->
name|packetAliasOpt
argument_list|)
expr_stmt|;
break|break;
case|case
name|Verbose
case|:
name|verbose
operator|=
name|yesNoValue
expr_stmt|;
break|break;
case|case
name|DynamicMode
case|:
name|dynamicMode
operator|=
name|yesNoValue
expr_stmt|;
break|break;
case|case
name|InPort
case|:
name|mip
operator|->
name|inPort
operator|=
name|uNumValue
expr_stmt|;
break|break;
case|case
name|OutPort
case|:
name|mip
operator|->
name|outPort
operator|=
name|uNumValue
expr_stmt|;
break|break;
case|case
name|Port
case|:
name|mip
operator|->
name|inOutPort
operator|=
name|uNumValue
expr_stmt|;
break|break;
case|case
name|GlobalPort
case|:
name|globalPort
operator|=
name|uNumValue
expr_stmt|;
break|break;
case|case
name|AliasAddress
case|:
name|memcpy
argument_list|(
operator|&
name|mip
operator|->
name|aliasAddr
argument_list|,
operator|&
name|addrValue
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TargetAddress
case|:
name|LibAliasSetTarget
argument_list|(
name|mla
argument_list|,
name|addrValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|RedirectPort
case|:
name|SetupPortRedirect
argument_list|(
name|strValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|RedirectProto
case|:
name|SetupProtoRedirect
argument_list|(
name|strValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|RedirectAddress
case|:
name|SetupAddressRedirect
argument_list|(
name|strValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|ProxyRule
case|:
name|LibAliasProxyRule
argument_list|(
name|mla
argument_list|,
name|strValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|InterfaceName
case|:
if|if
condition|(
name|mip
operator|->
name|ifName
condition|)
name|free
argument_list|(
name|mip
operator|->
name|ifName
argument_list|)
expr_stmt|;
name|mip
operator|->
name|ifName
operator|=
name|strdup
argument_list|(
name|strValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|ConfigFile
case|:
name|ReadConfigFile
argument_list|(
name|strValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|LogDenied
case|:
name|mip
operator|->
name|logDropped
operator|=
name|yesNoValue
expr_stmt|;
break|break;
case|case
name|LogFacility
case|:
name|fac_record
operator|=
name|facilitynames
expr_stmt|;
while|while
condition|(
name|fac_record
operator|->
name|c_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fac_record
operator|->
name|c_name
argument_list|,
name|strValue
argument_list|)
condition|)
block|{
name|logFacility
operator|=
name|fac_record
operator|->
name|c_val
expr_stmt|;
break|break;
block|}
else|else
name|fac_record
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fac_record
operator|->
name|c_name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unknown log facility name: %s"
argument_list|,
name|strValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|PunchFW
case|:
name|SetupPunchFW
argument_list|(
name|strValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|SkinnyPort
case|:
name|SetupSkinnyPort
argument_list|(
name|strValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|LogIpfwDenied
case|:
name|logIpfwDenied
operator|=
name|yesNoValue
expr_stmt|;
empty_stmt|;
break|break;
case|case
name|PidFile
case|:
name|pidName
operator|=
name|strdup
argument_list|(
name|strValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|Instance
case|:
name|NewInstance
argument_list|(
name|strValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|ExitDelay
case|:
if|if
condition|(
name|numValue
operator|<
literal|0
operator|||
name|numValue
operator|>
name|MAX_EXIT_DELAY
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Incorrect exit delay: %d"
argument_list|,
name|numValue
argument_list|)
expr_stmt|;
name|exitDelay
operator|=
name|numValue
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|ReadConfigFile
parameter_list|(
specifier|const
name|char
modifier|*
name|fileName
parameter_list|)
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|option
decl_stmt|;
name|file
operator|=
name|fopen
argument_list|(
name|fileName
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cannot open config file %s"
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|buf
operator|=
name|fgetln
argument_list|(
name|file
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"config file format error: "
literal|"last line should end with newline"
argument_list|)
expr_stmt|;
comment|/*  * Check for comments, strip off trailing spaces.  */
if|if
condition|(
operator|(
name|ptr
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'#'
argument_list|)
operator|)
condition|)
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|buf
init|;
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
condition|;
operator|++
name|ptr
control|)
continue|continue;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\0'
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|)
init|;
name|isspace
argument_list|(
operator|*
operator|--
name|p
argument_list|)
condition|;
control|)
continue|continue;
operator|*
operator|++
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/*  * Extract option name.  */
name|option
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
block|}
comment|/*  * Skip white space between name and parms.  */
while|while
condition|(
operator|*
name|ptr
operator|&&
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
operator|++
name|ptr
expr_stmt|;
name|ParseOption
argument_list|(
name|option
argument_list|,
operator|*
name|ptr
condition|?
name|ptr
else|:
name|NULL
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Usage
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|max
decl_stmt|;
name|struct
name|OptionInfo
modifier|*
name|info
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Recognized options:\n\n"
argument_list|)
expr_stmt|;
name|max
operator|=
sizeof|sizeof
argument_list|(
name|optionTable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|OptionInfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|info
operator|=
name|optionTable
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
operator|,
name|info
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%-20s %s\n"
argument_list|,
name|info
operator|->
name|name
argument_list|,
name|info
operator|->
name|parmDescription
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shortName
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%-20s %s\n"
argument_list|,
name|info
operator|->
name|shortName
argument_list|,
name|info
operator|->
name|parmDescription
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      %s\n\n"
argument_list|,
name|info
operator|->
name|description
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetupPortRedirect
parameter_list|(
specifier|const
name|char
modifier|*
name|parms
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|serverPool
decl_stmt|;
name|struct
name|in_addr
name|localAddr
decl_stmt|;
name|struct
name|in_addr
name|publicAddr
decl_stmt|;
name|struct
name|in_addr
name|remoteAddr
decl_stmt|;
name|port_range
name|portRange
decl_stmt|;
name|u_short
name|localPort
init|=
literal|0
decl_stmt|;
name|u_short
name|publicPort
init|=
literal|0
decl_stmt|;
name|u_short
name|remotePort
init|=
literal|0
decl_stmt|;
name|u_short
name|numLocalPorts
init|=
literal|0
decl_stmt|;
name|u_short
name|numPublicPorts
init|=
literal|0
decl_stmt|;
name|u_short
name|numRemotePorts
init|=
literal|0
decl_stmt|;
name|int
name|proto
decl_stmt|;
name|char
modifier|*
name|protoName
decl_stmt|;
name|char
modifier|*
name|separator
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|aliaslink
init|=
name|NULL
decl_stmt|;
name|buf
operator|=
name|strdup
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: strdup() failed"
argument_list|)
expr_stmt|;
comment|/*  * Extract protocol.  */
name|protoName
operator|=
name|strtok
argument_list|(
name|buf
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|protoName
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: missing protocol"
argument_list|)
expr_stmt|;
name|proto
operator|=
name|StrToProto
argument_list|(
name|protoName
argument_list|)
expr_stmt|;
comment|/*  * Extract local address.  */
name|ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: missing local address"
argument_list|)
expr_stmt|;
name|separator
operator|=
name|strchr
argument_list|(
name|ptr
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|separator
condition|)
block|{
comment|/* LSNAT redirection syntax. */
name|localAddr
operator|.
name|s_addr
operator|=
name|INADDR_NONE
expr_stmt|;
name|localPort
operator|=
operator|~
literal|0
expr_stmt|;
name|numLocalPorts
operator|=
literal|1
expr_stmt|;
name|serverPool
operator|=
name|ptr
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|StrToAddrAndPortRange
argument_list|(
name|ptr
argument_list|,
operator|&
name|localAddr
argument_list|,
name|protoName
argument_list|,
operator|&
name|portRange
argument_list|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: invalid local port range"
argument_list|)
expr_stmt|;
name|localPort
operator|=
name|GETLOPORT
argument_list|(
name|portRange
argument_list|)
expr_stmt|;
name|numLocalPorts
operator|=
name|GETNUMPORTS
argument_list|(
name|portRange
argument_list|)
expr_stmt|;
name|serverPool
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*  * Extract public port and optionally address.  */
name|ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: missing public port"
argument_list|)
expr_stmt|;
name|separator
operator|=
name|strchr
argument_list|(
name|ptr
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|separator
condition|)
block|{
if|if
condition|(
name|StrToAddrAndPortRange
argument_list|(
name|ptr
argument_list|,
operator|&
name|publicAddr
argument_list|,
name|protoName
argument_list|,
operator|&
name|portRange
argument_list|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: invalid public port range"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|publicAddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
name|StrToPortRange
argument_list|(
name|ptr
argument_list|,
name|protoName
argument_list|,
operator|&
name|portRange
argument_list|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: invalid public port range"
argument_list|)
expr_stmt|;
block|}
name|publicPort
operator|=
name|GETLOPORT
argument_list|(
name|portRange
argument_list|)
expr_stmt|;
name|numPublicPorts
operator|=
name|GETNUMPORTS
argument_list|(
name|portRange
argument_list|)
expr_stmt|;
comment|/*  * Extract remote address and optionally port.  */
name|ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
name|separator
operator|=
name|strchr
argument_list|(
name|ptr
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|separator
condition|)
block|{
if|if
condition|(
name|StrToAddrAndPortRange
argument_list|(
name|ptr
argument_list|,
operator|&
name|remoteAddr
argument_list|,
name|protoName
argument_list|,
operator|&
name|portRange
argument_list|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: invalid remote port range"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SETLOPORT
argument_list|(
name|portRange
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SETNUMPORTS
argument_list|(
name|portRange
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|StrToAddr
argument_list|(
name|ptr
argument_list|,
operator|&
name|remoteAddr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SETLOPORT
argument_list|(
name|portRange
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SETNUMPORTS
argument_list|(
name|portRange
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|remoteAddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
block|}
name|remotePort
operator|=
name|GETLOPORT
argument_list|(
name|portRange
argument_list|)
expr_stmt|;
name|numRemotePorts
operator|=
name|GETNUMPORTS
argument_list|(
name|portRange
argument_list|)
expr_stmt|;
comment|/*  * Make sure port ranges match up, then add the redirect ports.  */
if|if
condition|(
name|numLocalPorts
operator|!=
name|numPublicPorts
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: port ranges must be equal in size"
argument_list|)
expr_stmt|;
comment|/* Remote port range is allowed to be '0' which means all ports. */
if|if
condition|(
name|numRemotePorts
operator|!=
name|numLocalPorts
operator|&&
operator|(
name|numRemotePorts
operator|!=
literal|1
operator|||
name|remotePort
operator|!=
literal|0
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: remote port must be 0 or equal to local port range in size"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numPublicPorts
condition|;
operator|++
name|i
control|)
block|{
comment|/* If remotePort is all ports, set it to 0. */
name|u_short
name|remotePortCopy
init|=
name|remotePort
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|numRemotePorts
operator|==
literal|1
operator|&&
name|remotePort
operator|==
literal|0
condition|)
name|remotePortCopy
operator|=
literal|0
expr_stmt|;
name|aliaslink
operator|=
name|LibAliasRedirectPort
argument_list|(
name|mla
argument_list|,
name|localAddr
argument_list|,
name|htons
argument_list|(
name|localPort
operator|+
name|i
argument_list|)
argument_list|,
name|remoteAddr
argument_list|,
name|htons
argument_list|(
name|remotePortCopy
argument_list|)
argument_list|,
name|publicAddr
argument_list|,
name|htons
argument_list|(
name|publicPort
operator|+
name|i
argument_list|)
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
comment|/*  * Setup LSNAT server pool.  */
if|if
condition|(
name|serverPool
operator|!=
name|NULL
operator|&&
name|aliaslink
operator|!=
name|NULL
condition|)
block|{
name|ptr
operator|=
name|strtok
argument_list|(
name|serverPool
argument_list|,
literal|","
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|StrToAddrAndPortRange
argument_list|(
name|ptr
argument_list|,
operator|&
name|localAddr
argument_list|,
name|protoName
argument_list|,
operator|&
name|portRange
argument_list|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: invalid local port range"
argument_list|)
expr_stmt|;
name|localPort
operator|=
name|GETLOPORT
argument_list|(
name|portRange
argument_list|)
expr_stmt|;
if|if
condition|(
name|GETNUMPORTS
argument_list|(
name|portRange
argument_list|)
operator|!=
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: local port must be single in this context"
argument_list|)
expr_stmt|;
name|LibAliasAddServer
argument_list|(
name|mla
argument_list|,
name|aliaslink
argument_list|,
name|localAddr
argument_list|,
name|htons
argument_list|(
name|localPort
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetupProtoRedirect
parameter_list|(
specifier|const
name|char
modifier|*
name|parms
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|struct
name|in_addr
name|localAddr
decl_stmt|;
name|struct
name|in_addr
name|publicAddr
decl_stmt|;
name|struct
name|in_addr
name|remoteAddr
decl_stmt|;
name|int
name|proto
decl_stmt|;
name|char
modifier|*
name|protoName
decl_stmt|;
name|struct
name|protoent
modifier|*
name|protoent
decl_stmt|;
name|buf
operator|=
name|strdup
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: strdup() failed"
argument_list|)
expr_stmt|;
comment|/*  * Extract protocol.  */
name|protoName
operator|=
name|strtok
argument_list|(
name|buf
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|protoName
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_proto: missing protocol"
argument_list|)
expr_stmt|;
name|protoent
operator|=
name|getprotobyname
argument_list|(
name|protoName
argument_list|)
expr_stmt|;
if|if
condition|(
name|protoent
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_proto: unknown protocol %s"
argument_list|,
name|protoName
argument_list|)
expr_stmt|;
else|else
name|proto
operator|=
name|protoent
operator|->
name|p_proto
expr_stmt|;
comment|/*  * Extract local address.  */
name|ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_proto: missing local address"
argument_list|)
expr_stmt|;
else|else
name|StrToAddr
argument_list|(
name|ptr
argument_list|,
operator|&
name|localAddr
argument_list|)
expr_stmt|;
comment|/*  * Extract optional public address.  */
name|ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|StrToAddr
argument_list|(
name|ptr
argument_list|,
operator|&
name|publicAddr
argument_list|)
expr_stmt|;
else|else
name|publicAddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
comment|/*  * Extract optional remote address.  */
name|ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|StrToAddr
argument_list|(
name|ptr
argument_list|,
operator|&
name|remoteAddr
argument_list|)
expr_stmt|;
else|else
name|remoteAddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
comment|/*  * Create aliasing link.  */
operator|(
name|void
operator|)
name|LibAliasRedirectProto
argument_list|(
name|mla
argument_list|,
name|localAddr
argument_list|,
name|remoteAddr
argument_list|,
name|publicAddr
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetupAddressRedirect
parameter_list|(
specifier|const
name|char
modifier|*
name|parms
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|separator
decl_stmt|;
name|struct
name|in_addr
name|localAddr
decl_stmt|;
name|struct
name|in_addr
name|publicAddr
decl_stmt|;
name|char
modifier|*
name|serverPool
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|aliaslink
decl_stmt|;
name|buf
operator|=
name|strdup
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: strdup() failed"
argument_list|)
expr_stmt|;
comment|/*  * Extract local address.  */
name|ptr
operator|=
name|strtok
argument_list|(
name|buf
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_address: missing local address"
argument_list|)
expr_stmt|;
name|separator
operator|=
name|strchr
argument_list|(
name|ptr
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|separator
condition|)
block|{
comment|/* LSNAT redirection syntax. */
name|localAddr
operator|.
name|s_addr
operator|=
name|INADDR_NONE
expr_stmt|;
name|serverPool
operator|=
name|ptr
expr_stmt|;
block|}
else|else
block|{
name|StrToAddr
argument_list|(
name|ptr
argument_list|,
operator|&
name|localAddr
argument_list|)
expr_stmt|;
name|serverPool
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*  * Extract public address.  */
name|ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_address: missing public address"
argument_list|)
expr_stmt|;
name|StrToAddr
argument_list|(
name|ptr
argument_list|,
operator|&
name|publicAddr
argument_list|)
expr_stmt|;
name|aliaslink
operator|=
name|LibAliasRedirectAddr
argument_list|(
name|mla
argument_list|,
name|localAddr
argument_list|,
name|publicAddr
argument_list|)
expr_stmt|;
comment|/*  * Setup LSNAT server pool.  */
if|if
condition|(
name|serverPool
operator|!=
name|NULL
operator|&&
name|aliaslink
operator|!=
name|NULL
condition|)
block|{
name|ptr
operator|=
name|strtok
argument_list|(
name|serverPool
argument_list|,
literal|","
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|StrToAddr
argument_list|(
name|ptr
argument_list|,
operator|&
name|localAddr
argument_list|)
expr_stmt|;
name|LibAliasAddServer
argument_list|(
name|mla
argument_list|,
name|aliaslink
argument_list|,
name|localAddr
argument_list|,
name|htons
argument_list|(
operator|~
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|StrToAddr
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
name|inet_aton
argument_list|(
name|str
argument_list|,
name|addr
argument_list|)
condition|)
return|return;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown host %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|addr
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_short
name|StrToPort
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|proto
parameter_list|)
block|{
name|u_short
name|port
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|port
operator|=
name|strtol
argument_list|(
name|str
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|str
condition|)
return|return
name|htons
argument_list|(
name|port
argument_list|)
return|;
name|sp
operator|=
name|getservbyname
argument_list|(
name|str
argument_list|,
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sp
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s/%s: unknown service"
argument_list|,
name|str
argument_list|,
name|proto
argument_list|)
expr_stmt|;
return|return
name|sp
operator|->
name|s_port
return|;
block|}
end_function

begin_function
name|int
name|StrToPortRange
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|proto
parameter_list|,
name|port_range
modifier|*
name|portRange
parameter_list|)
block|{
name|char
modifier|*
name|sep
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|u_short
name|loPort
decl_stmt|;
name|u_short
name|hiPort
decl_stmt|;
comment|/* First see if this is a service, return corresponding port if so. */
name|sp
operator|=
name|getservbyname
argument_list|(
name|str
argument_list|,
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
name|SETLOPORT
argument_list|(
operator|*
name|portRange
argument_list|,
name|ntohs
argument_list|(
name|sp
operator|->
name|s_port
argument_list|)
argument_list|)
expr_stmt|;
name|SETNUMPORTS
argument_list|(
operator|*
name|portRange
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Not a service, see if it's a single port or port range. */
name|sep
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|==
name|NULL
condition|)
block|{
name|SETLOPORT
argument_list|(
operator|*
name|portRange
argument_list|,
name|strtol
argument_list|(
name|str
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|str
condition|)
block|{
comment|/* Single port. */
name|SETNUMPORTS
argument_list|(
operator|*
name|portRange
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Error in port range field. */
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s/%s: unknown service"
argument_list|,
name|str
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
comment|/* Port range, get the values and sanity check. */
name|sscanf
argument_list|(
name|str
argument_list|,
literal|"%hu-%hu"
argument_list|,
operator|&
name|loPort
argument_list|,
operator|&
name|hiPort
argument_list|)
expr_stmt|;
name|SETLOPORT
argument_list|(
operator|*
name|portRange
argument_list|,
name|loPort
argument_list|)
expr_stmt|;
name|SETNUMPORTS
argument_list|(
operator|*
name|portRange
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Error by default */
if|if
condition|(
name|loPort
operator|<=
name|hiPort
condition|)
name|SETNUMPORTS
argument_list|(
operator|*
name|portRange
argument_list|,
name|hiPort
operator|-
name|loPort
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GETNUMPORTS
argument_list|(
operator|*
name|portRange
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid port range %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|StrToProto
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"tcp"
argument_list|)
condition|)
return|return
name|IPPROTO_TCP
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"udp"
argument_list|)
condition|)
return|return
name|IPPROTO_UDP
return|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown protocol %s. Expected tcp or udp"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|StrToAddrAndPortRange
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|,
name|char
modifier|*
name|proto
parameter_list|,
name|port_range
modifier|*
name|portRange
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s is missing port number"
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
name|StrToAddr
argument_list|(
name|str
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|StrToPortRange
argument_list|(
name|ptr
argument_list|,
name|proto
argument_list|,
name|portRange
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|SetupPunchFW
parameter_list|(
specifier|const
name|char
modifier|*
name|strValue
parameter_list|)
block|{
name|unsigned
name|int
name|base
decl_stmt|,
name|num
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|strValue
argument_list|,
literal|"%u:%u"
argument_list|,
operator|&
name|base
argument_list|,
operator|&
name|num
argument_list|)
operator|!=
literal|2
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"punch_fw: basenumber:count parameter required"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CheckIpfwRulenum
argument_list|(
name|base
operator|+
name|num
operator|-
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"punch_fw: basenumber:count parameter should fit "
literal|"the maximum allowed rule numbers"
argument_list|)
expr_stmt|;
name|LibAliasSetFWBase
argument_list|(
name|mla
argument_list|,
name|base
argument_list|,
name|num
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|LibAliasSetMode
argument_list|(
name|mla
argument_list|,
name|PKT_ALIAS_PUNCH_FW
argument_list|,
name|PKT_ALIAS_PUNCH_FW
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|SetupSkinnyPort
parameter_list|(
specifier|const
name|char
modifier|*
name|strValue
parameter_list|)
block|{
name|unsigned
name|int
name|port
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|strValue
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|port
argument_list|)
operator|!=
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"skinny_port: port parameter required"
argument_list|)
expr_stmt|;
name|LibAliasSetSkinnyPort
argument_list|(
name|mla
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|NewInstance
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|instance
modifier|*
name|ip
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ip
argument_list|,
argument|&root
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ip
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|mla
operator|=
name|ip
operator|->
name|la
expr_stmt|;
name|mip
operator|=
name|ip
expr_stmt|;
return|return;
block|}
block|}
name|ninstance
operator|++
expr_stmt|;
name|ip
operator|=
name|calloc
argument_list|(
sizeof|sizeof
expr|*
name|ip
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ip
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ip
operator|->
name|la
operator|=
name|LibAliasInit
argument_list|(
name|ip
operator|->
name|la
argument_list|)
expr_stmt|;
name|ip
operator|->
name|assignAliasAddr
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ifName
operator|=
name|NULL
expr_stmt|;
name|ip
operator|->
name|logDropped
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|inPort
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|outPort
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|inOutPort
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|aliasAddr
operator|.
name|s_addr
operator|=
name|INADDR_NONE
expr_stmt|;
name|ip
operator|->
name|ifMTU
operator|=
operator|-
literal|1
expr_stmt|;
name|ip
operator|->
name|aliasOverhead
operator|=
literal|12
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|root
argument_list|,
name|ip
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|mla
operator|=
name|ip
operator|->
name|la
expr_stmt|;
name|mip
operator|=
name|ip
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|CheckIpfwRulenum
parameter_list|(
name|unsigned
name|int
name|rnum
parameter_list|)
block|{
name|unsigned
name|int
name|default_rule
decl_stmt|;
name|size_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|default_rule
argument_list|)
decl_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"net.inet.ip.fw.default_rule"
argument_list|,
operator|&
name|default_rule
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"Failed to get the default ipfw rule number, using "
literal|"default historical value 65535.  The reason was"
argument_list|)
expr_stmt|;
name|default_rule
operator|=
literal|65535
expr_stmt|;
block|}
if|if
condition|(
name|rnum
operator|>=
name|default_rule
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

