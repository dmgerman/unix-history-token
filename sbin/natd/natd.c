begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * natd - Network Address Translation Daemon for FreeBSD.  *  * This software ois provided free of charge, with no   * warranty of any kind, either expressed or implied.  * Use at your own risk.  *   * You may copy, modify and distribute this software (natd.c) freely.  *  * Ari Suutari<suutari@iki.fi>  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<alias.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"natd.h"
end_include

begin_comment
comment|/*   * Default values for input and output  * divert socket ports.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_SERVICE
value|"natd"
end_define

begin_comment
comment|/*  * Function prototypes.  */
end_comment

begin_function_decl
specifier|static
name|void
name|DoAliasing
parameter_list|(
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DaemonMode
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|HandleRoutingInfo
parameter_list|(
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Usage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|PrintPacket
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SetAliasAddressFromIfName
parameter_list|(
name|char
modifier|*
name|ifName
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|InitiateShutdown
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Shutdown
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RefreshAddr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ParseOption
parameter_list|(
name|char
modifier|*
name|option
parameter_list|,
name|char
modifier|*
name|parms
parameter_list|,
name|int
name|cmdLine
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ReadConfigFile
parameter_list|(
name|char
modifier|*
name|fileName
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SetupPermanentLink
parameter_list|(
name|char
modifier|*
name|parms
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SetupPortRedirect
parameter_list|(
name|char
modifier|*
name|parms
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SetupAddressRedirect
parameter_list|(
name|char
modifier|*
name|parms
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|StrToAddr
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|StrToPort
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
name|proto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|StrToProto
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|StrToAddrAndPort
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|,
name|char
modifier|*
name|proto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ParseArgs
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|FlushPacketBuffer
parameter_list|(
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Globals.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|background
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|running
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|assignAliasAddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ifName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ifIndex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inPort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|outPort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inOutPort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|in_addr
name|aliasAddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dynamicMode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ifMTU
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aliasOverhead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|icmpSock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|packetBuf
index|[
name|IP_MAXPACKET
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|packetLen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
name|packetAddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|packetSock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dropIgnoredIncoming
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|divertIn
decl_stmt|;
name|int
name|divertOut
decl_stmt|;
name|int
name|divertInOut
decl_stmt|;
name|int
name|routeSock
decl_stmt|;
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|fd_set
name|readMask
decl_stmt|;
name|fd_set
name|writeMask
decl_stmt|;
name|int
name|fdMax
decl_stmt|;
comment|/*   * Initialize packet aliasing software.  * Done already here to be able to alter option bits  * during command line and configuration file processing.  */
name|PacketAliasInit
argument_list|()
expr_stmt|;
comment|/*  * Parse options.  */
name|inPort
operator|=
literal|0
expr_stmt|;
name|outPort
operator|=
literal|0
expr_stmt|;
name|verbose
operator|=
literal|0
expr_stmt|;
name|inOutPort
operator|=
literal|0
expr_stmt|;
name|ifName
operator|=
name|NULL
expr_stmt|;
name|ifMTU
operator|=
operator|-
literal|1
expr_stmt|;
name|background
operator|=
literal|0
expr_stmt|;
name|running
operator|=
literal|1
expr_stmt|;
name|assignAliasAddr
operator|=
literal|0
expr_stmt|;
name|aliasAddr
operator|.
name|s_addr
operator|=
name|INADDR_NONE
expr_stmt|;
name|aliasOverhead
operator|=
literal|12
expr_stmt|;
name|dynamicMode
operator|=
literal|0
expr_stmt|;
comment|/*  * Mark packet buffer empty.  */
name|packetSock
operator|=
operator|-
literal|1
expr_stmt|;
name|ParseArgs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/*  * Check that valid aliasing address has been given.  */
if|if
condition|(
name|aliasAddr
operator|.
name|s_addr
operator|==
name|INADDR_NONE
operator|&&
name|ifName
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"aliasing address not given"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasAddr
operator|.
name|s_addr
operator|!=
name|INADDR_NONE
operator|&&
name|ifName
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"both alias address and interface name are not allowed"
argument_list|)
expr_stmt|;
comment|/*  * Check that valid port number is known.  */
if|if
condition|(
name|inPort
operator|!=
literal|0
operator|||
name|outPort
operator|!=
literal|0
condition|)
if|if
condition|(
name|inPort
operator|==
literal|0
operator|||
name|outPort
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"both input and output ports are required"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inPort
operator|==
literal|0
operator|&&
name|outPort
operator|==
literal|0
operator|&&
name|inOutPort
operator|==
literal|0
condition|)
name|ParseOption
argument_list|(
literal|"port"
argument_list|,
name|DEFAULT_SERVICE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  * Check if ignored packets should be dropped.  */
name|dropIgnoredIncoming
operator|=
name|PacketAliasSetMode
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dropIgnoredIncoming
operator|&=
name|PKT_ALIAS_DENY_INCOMING
expr_stmt|;
comment|/*  * Create divert sockets. Use only one socket if -p was specified  * on command line. Otherwise, create separate sockets for  * outgoing and incoming connnections.  */
if|if
condition|(
name|inOutPort
condition|)
block|{
name|divertInOut
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_DIVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|divertInOut
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to create divert socket."
argument_list|)
expr_stmt|;
name|divertIn
operator|=
operator|-
literal|1
expr_stmt|;
name|divertOut
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*  * Bind socket.  */
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|inOutPort
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|divertInOut
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to bind divert socket."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|divertIn
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_DIVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|divertIn
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to create incoming divert socket."
argument_list|)
expr_stmt|;
name|divertOut
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_DIVERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|divertOut
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to create outgoing divert socket."
argument_list|)
expr_stmt|;
name|divertInOut
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*  * Bind divert sockets.  */
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|inPort
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|divertIn
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to bind incoming divert socket."
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|outPort
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|divertOut
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to bind outgoing divert socket."
argument_list|)
expr_stmt|;
block|}
comment|/*  * Create routing socket if interface name specified.  */
if|if
condition|(
name|ifName
operator|&&
name|dynamicMode
condition|)
block|{
name|routeSock
operator|=
name|socket
argument_list|(
name|PF_ROUTE
argument_list|,
name|SOCK_RAW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|routeSock
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to create routing info socket."
argument_list|)
expr_stmt|;
block|}
else|else
name|routeSock
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*  * Create socket for sending ICMP messages.  */
name|icmpSock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_ICMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|icmpSock
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Unable to create ICMP socket."
argument_list|)
expr_stmt|;
comment|/*  * Become a daemon unless verbose mode was requested.  */
if|if
condition|(
operator|!
name|verbose
condition|)
name|DaemonMode
argument_list|()
expr_stmt|;
comment|/*  * Catch signals to manage shutdown and  * refresh of interface address.  */
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|InitiateShutdown
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|RefreshAddr
argument_list|)
expr_stmt|;
comment|/*  * Set alias address if it has been given.  */
if|if
condition|(
name|aliasAddr
operator|.
name|s_addr
operator|!=
name|INADDR_NONE
condition|)
name|PacketAliasSetAddress
argument_list|(
name|aliasAddr
argument_list|)
expr_stmt|;
comment|/*  * We need largest descriptor number for select.  */
name|fdMax
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|divertIn
operator|>
name|fdMax
condition|)
name|fdMax
operator|=
name|divertIn
expr_stmt|;
if|if
condition|(
name|divertOut
operator|>
name|fdMax
condition|)
name|fdMax
operator|=
name|divertOut
expr_stmt|;
if|if
condition|(
name|divertInOut
operator|>
name|fdMax
condition|)
name|fdMax
operator|=
name|divertInOut
expr_stmt|;
if|if
condition|(
name|routeSock
operator|>
name|fdMax
condition|)
name|fdMax
operator|=
name|routeSock
expr_stmt|;
while|while
condition|(
name|running
condition|)
block|{
if|if
condition|(
name|divertInOut
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|ifName
operator|&&
name|packetSock
operator|==
operator|-
literal|1
condition|)
block|{
comment|/*  * When using only one socket, just call   * DoAliasing repeatedly to process packets.  */
name|DoAliasing
argument_list|(
name|divertInOut
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*   * Build read mask from socket descriptors to select.  */
name|FD_ZERO
argument_list|(
operator|&
name|readMask
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|writeMask
argument_list|)
expr_stmt|;
comment|/*  * If there is unsent packet in buffer, use select  * to check when socket comes writable again.  */
if|if
condition|(
name|packetSock
operator|!=
operator|-
literal|1
condition|)
block|{
name|FD_SET
argument_list|(
name|packetSock
argument_list|,
operator|&
name|writeMask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  * No unsent packet exists - safe to check if  * new ones are available.  */
if|if
condition|(
name|divertIn
operator|!=
operator|-
literal|1
condition|)
name|FD_SET
argument_list|(
name|divertIn
argument_list|,
operator|&
name|readMask
argument_list|)
expr_stmt|;
if|if
condition|(
name|divertOut
operator|!=
operator|-
literal|1
condition|)
name|FD_SET
argument_list|(
name|divertOut
argument_list|,
operator|&
name|readMask
argument_list|)
expr_stmt|;
if|if
condition|(
name|divertInOut
operator|!=
operator|-
literal|1
condition|)
name|FD_SET
argument_list|(
name|divertInOut
argument_list|,
operator|&
name|readMask
argument_list|)
expr_stmt|;
block|}
comment|/*  * Routing info is processed always.  */
if|if
condition|(
name|routeSock
operator|!=
operator|-
literal|1
condition|)
name|FD_SET
argument_list|(
name|routeSock
argument_list|,
operator|&
name|readMask
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|fdMax
operator|+
literal|1
argument_list|,
operator|&
name|readMask
argument_list|,
operator|&
name|writeMask
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|Quit
argument_list|(
literal|"Select failed."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|packetSock
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|packetSock
argument_list|,
operator|&
name|writeMask
argument_list|)
condition|)
name|FlushPacketBuffer
argument_list|(
name|packetSock
argument_list|)
expr_stmt|;
if|if
condition|(
name|divertIn
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|divertIn
argument_list|,
operator|&
name|readMask
argument_list|)
condition|)
name|DoAliasing
argument_list|(
name|divertIn
argument_list|)
expr_stmt|;
if|if
condition|(
name|divertOut
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|divertOut
argument_list|,
operator|&
name|readMask
argument_list|)
condition|)
name|DoAliasing
argument_list|(
name|divertOut
argument_list|)
expr_stmt|;
if|if
condition|(
name|divertInOut
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|divertInOut
argument_list|,
operator|&
name|readMask
argument_list|)
condition|)
name|DoAliasing
argument_list|(
name|divertInOut
argument_list|)
expr_stmt|;
if|if
condition|(
name|routeSock
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|routeSock
argument_list|,
operator|&
name|readMask
argument_list|)
condition|)
name|HandleRoutingInfo
argument_list|(
name|routeSock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|background
condition|)
name|unlink
argument_list|(
name|PIDFILE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|DaemonMode
parameter_list|()
block|{
name|FILE
modifier|*
name|pidFile
decl_stmt|;
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|background
operator|=
literal|1
expr_stmt|;
name|pidFile
operator|=
name|fopen
argument_list|(
name|PIDFILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pidFile
condition|)
block|{
name|fprintf
argument_list|(
name|pidFile
argument_list|,
literal|"%d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|pidFile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ParseArgs
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|arg
decl_stmt|;
name|char
modifier|*
name|parm
decl_stmt|;
name|char
modifier|*
name|opt
decl_stmt|;
name|char
name|parmBuf
index|[
literal|256
index|]
decl_stmt|;
for|for
control|(
name|arg
operator|=
literal|1
init|;
name|arg
operator|<
name|argc
condition|;
name|arg
operator|++
control|)
block|{
name|opt
operator|=
name|argv
index|[
name|arg
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|opt
operator|!=
literal|'-'
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid option %s"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|Usage
argument_list|()
expr_stmt|;
block|}
name|parm
operator|=
name|NULL
expr_stmt|;
name|parmBuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|arg
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|arg
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
break|break;
if|if
condition|(
name|parm
condition|)
name|strcat
argument_list|(
name|parmBuf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|++
name|arg
expr_stmt|;
name|parm
operator|=
name|parmBuf
expr_stmt|;
name|strcat
argument_list|(
name|parmBuf
argument_list|,
name|argv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
block|}
name|ParseOption
argument_list|(
name|opt
operator|+
literal|1
argument_list|,
name|parm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|DoAliasing
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|bytes
decl_stmt|;
name|int
name|origBytes
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|addrSize
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
name|assignAliasAddr
condition|)
block|{
name|SetAliasAddressFromIfName
argument_list|(
name|ifName
argument_list|)
expr_stmt|;
name|assignAliasAddr
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  * Get packet from socket.  */
name|addrSize
operator|=
sizeof|sizeof
name|packetAddr
expr_stmt|;
name|origBytes
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|packetBuf
argument_list|,
sizeof|sizeof
name|packetBuf
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|packetAddr
argument_list|,
operator|&
name|addrSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|origBytes
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|Warn
argument_list|(
literal|"read from divert socket failed"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * This is a IP packet.  */
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|packetBuf
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
comment|/*  * Print packet direction and protocol type.  */
if|if
condition|(
name|packetAddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|printf
argument_list|(
literal|"Out "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"In  "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|printf
argument_list|(
literal|"[TCP]  "
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|printf
argument_list|(
literal|"[UDP]  "
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|printf
argument_list|(
literal|"[ICMP] "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"[?]    "
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*  * Print addresses.  */
name|PrintPacket
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|packetAddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
comment|/*  * Outgoing packets. Do aliasing.  */
name|PacketAliasOut
argument_list|(
name|packetBuf
argument_list|,
name|IP_MAXPACKET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  * Do aliasing.  */
name|status
operator|=
name|PacketAliasIn
argument_list|(
name|packetBuf
argument_list|,
name|IP_MAXPACKET
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|PKT_ALIAS_IGNORED
operator|&&
name|dropIgnoredIncoming
condition|)
block|{
name|printf
argument_list|(
literal|" dropped.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/*  * Length might have changed during aliasing.  */
name|bytes
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
comment|/*  * Update alias overhead size for outgoing packets.  */
if|if
condition|(
name|packetAddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|&&
name|bytes
operator|-
name|origBytes
operator|>
name|aliasOverhead
condition|)
name|aliasOverhead
operator|=
name|bytes
operator|-
name|origBytes
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
comment|/*  * Print addresses after aliasing.  */
name|printf
argument_list|(
literal|" aliased to\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"           "
argument_list|)
expr_stmt|;
name|PrintPacket
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|packetLen
operator|=
name|bytes
expr_stmt|;
name|packetSock
operator|=
name|fd
expr_stmt|;
name|FlushPacketBuffer
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FlushPacketBuffer
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|wrote
decl_stmt|;
name|char
name|msgBuf
index|[
literal|80
index|]
decl_stmt|;
comment|/*  * Put packet back for processing.  */
name|wrote
operator|=
name|sendto
argument_list|(
name|fd
argument_list|,
name|packetBuf
argument_list|,
name|packetLen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|packetAddr
argument_list|,
sizeof|sizeof
name|packetAddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrote
operator|!=
name|packetLen
condition|)
block|{
comment|/*  * If buffer space is not available,  * just return. Main loop will take care of   * retrying send when space becomes available.  */
if|if
condition|(
name|errno
operator|==
name|ENOBUFS
condition|)
return|return;
if|if
condition|(
name|errno
operator|==
name|EMSGSIZE
condition|)
block|{
if|if
condition|(
name|packetAddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|&&
name|ifMTU
operator|!=
operator|-
literal|1
condition|)
name|SendNeedFragIcmp
argument_list|(
name|icmpSock
argument_list|,
operator|(
expr|struct
name|ip
operator|*
operator|)
name|packetBuf
argument_list|,
name|ifMTU
operator|-
name|aliasOverhead
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|msgBuf
argument_list|,
literal|"failed to write packet back"
argument_list|)
expr_stmt|;
name|Warn
argument_list|(
name|msgBuf
argument_list|)
expr_stmt|;
block|}
block|}
name|packetSock
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|HandleRoutingInfo
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|bytes
decl_stmt|;
name|struct
name|if_msghdr
name|ifMsg
decl_stmt|;
comment|/*  * Get packet from socket.  */
name|bytes
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|ifMsg
argument_list|,
sizeof|sizeof
name|ifMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
operator|-
literal|1
condition|)
block|{
name|Warn
argument_list|(
literal|"read from routing socket failed"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ifMsg
operator|.
name|ifm_version
operator|!=
name|RTM_VERSION
condition|)
block|{
name|Warn
argument_list|(
literal|"unexpected packet read from routing socket"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Routing message %X received.\n"
argument_list|,
name|ifMsg
operator|.
name|ifm_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifMsg
operator|.
name|ifm_type
operator|!=
name|RTM_NEWADDR
condition|)
return|return;
if|if
condition|(
name|verbose
operator|&&
name|ifMsg
operator|.
name|ifm_index
operator|==
name|ifIndex
condition|)
name|printf
argument_list|(
literal|"Interface address has changed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifMsg
operator|.
name|ifm_index
operator|==
name|ifIndex
condition|)
name|assignAliasAddr
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|PrintPacket
parameter_list|(
name|struct
name|ip
modifier|*
name|ip
parameter_list|)
block|{
name|struct
name|tcphdr
modifier|*
name|tcphdr
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
name|tcphdr
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
else|else
name|tcphdr
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcphdr
condition|)
name|printf
argument_list|(
literal|":%d"
argument_list|,
name|ntohs
argument_list|(
name|tcphdr
operator|->
name|th_sport
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -> "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcphdr
condition|)
name|printf
argument_list|(
literal|":%d"
argument_list|,
name|ntohs
argument_list|(
name|tcphdr
operator|->
name|th_dport
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|SetAliasAddressFromIfName
parameter_list|(
name|char
modifier|*
name|ifName
parameter_list|)
block|{
name|struct
name|ifconf
name|cf
decl_stmt|;
name|struct
name|ifreq
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|char
name|msg
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifPtr
decl_stmt|;
name|int
name|extra
decl_stmt|;
name|int
name|helperSock
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
name|int
name|found
decl_stmt|;
name|struct
name|ifreq
name|req
decl_stmt|;
name|char
name|last
index|[
literal|10
index|]
decl_stmt|;
comment|/*  * Create a dummy socket to access interface information.  */
name|helperSock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|helperSock
operator|==
operator|-
literal|1
condition|)
block|{
name|Quit
argument_list|(
literal|"Failed to create helper socket."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cf
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|cf
operator|.
name|ifc_req
operator|=
name|buf
expr_stmt|;
comment|/*  * Get interface data.  */
if|if
condition|(
name|ioctl
argument_list|(
name|helperSock
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|&
name|cf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|Quit
argument_list|(
literal|"Ioctl SIOCGIFCONF failed."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ifIndex
operator|=
literal|0
expr_stmt|;
name|ifPtr
operator|=
name|buf
expr_stmt|;
name|bytes
operator|=
name|cf
operator|.
name|ifc_len
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|last
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*  * Loop through interfaces until one with  * given name is found. This is done to  * find correct interface index for routing  * message processing.  */
while|while
condition|(
name|bytes
condition|)
block|{
if|if
condition|(
name|ifPtr
operator|->
name|ifr_addr
operator|.
name|sa_family
operator|==
name|AF_INET
operator|&&
operator|!
name|strcmp
argument_list|(
name|ifPtr
operator|->
name|ifr_name
argument_list|,
name|ifName
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|last
argument_list|,
name|ifPtr
operator|->
name|ifr_name
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|last
argument_list|,
name|ifPtr
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
operator|++
name|ifIndex
expr_stmt|;
block|}
name|extra
operator|=
name|ifPtr
operator|->
name|ifr_addr
operator|.
name|sa_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
expr_stmt|;
name|ifPtr
operator|++
expr_stmt|;
name|ifPtr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ifPtr
operator|+
name|extra
operator|)
expr_stmt|;
name|bytes
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
operator|+
name|extra
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|close
argument_list|(
name|helperSock
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"Unknown interface name %s.\n"
argument_list|,
name|ifName
argument_list|)
expr_stmt|;
name|Quit
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/*  * Get MTU size.  */
name|strcpy
argument_list|(
name|req
operator|.
name|ifr_name
argument_list|,
name|ifName
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|helperSock
argument_list|,
name|SIOCGIFMTU
argument_list|,
operator|&
name|req
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Cannot get interface mtu size."
argument_list|)
expr_stmt|;
name|ifMTU
operator|=
name|req
operator|.
name|ifr_mtu
expr_stmt|;
comment|/*  * Get interface address.  */
if|if
condition|(
name|ioctl
argument_list|(
name|helperSock
argument_list|,
name|SIOCGIFADDR
argument_list|,
operator|&
name|req
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Quit
argument_list|(
literal|"Cannot get interface address."
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|req
operator|.
name|ifr_addr
expr_stmt|;
name|SetPacketAliasAddress
argument_list|(
name|addr
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Aliasing to %s, mtu %d bytes"
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ifMTU
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|helperSock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Quit
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|Warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Warn
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|background
condition|)
name|syslog
argument_list|(
name|LOG_ALERT
argument_list|,
literal|"%s (%m)"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|RefreshAddr
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|RefreshAddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifName
condition|)
name|assignAliasAddr
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|InitiateShutdown
parameter_list|()
block|{
comment|/*  * Start timer to allow kernel gracefully  * shutdown existing connections when system  * is shut down.  */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|Shutdown
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Shutdown
parameter_list|()
block|{
name|running
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Different options recognized by this program.  */
end_comment

begin_enum
enum|enum
name|Option
block|{
name|PacketAliasOption
block|,
name|Verbose
block|,
name|InPort
block|,
name|OutPort
block|,
name|Port
block|,
name|AliasAddress
block|,
name|InterfaceName
block|,
name|PermanentLink
block|,
name|RedirectPort
block|,
name|RedirectAddress
block|,
name|ConfigFile
block|,
name|DynamicMode
block|}
enum|;
end_enum

begin_enum
enum|enum
name|Param
block|{
name|YesNo
block|,
name|Numeric
block|,
name|String
block|,
name|None
block|,
name|Address
block|,
name|Service
block|}
enum|;
end_enum

begin_comment
comment|/*  * Option information structure (used by ParseOption).  */
end_comment

begin_struct
struct|struct
name|OptionInfo
block|{
name|enum
name|Option
name|type
decl_stmt|;
name|int
name|packetAliasOpt
decl_stmt|;
name|enum
name|Param
name|parm
decl_stmt|;
name|char
modifier|*
name|parmDescription
decl_stmt|;
name|char
modifier|*
name|description
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|shortName
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Table of known options.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|OptionInfo
name|optionTable
index|[]
init|=
block|{
block|{
name|PacketAliasOption
block|,
name|PKT_ALIAS_UNREGISTERED_ONLY
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"alias only unregistered addresses"
block|,
literal|"unregistered_only"
block|,
literal|"u"
block|}
block|,
block|{
name|PacketAliasOption
block|,
name|PKT_ALIAS_LOG
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"enable logging"
block|,
literal|"log"
block|,
literal|"l"
block|}
block|,
block|{
name|PacketAliasOption
block|,
name|PKT_ALIAS_DENY_INCOMING
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"allow incoming connections"
block|,
literal|"deny_incoming"
block|,
literal|"d"
block|}
block|,
block|{
name|PacketAliasOption
block|,
name|PKT_ALIAS_USE_SOCKETS
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"use sockets to inhibit port conflict"
block|,
literal|"use_sockets"
block|,
literal|"s"
block|}
block|,
block|{
name|PacketAliasOption
block|,
name|PKT_ALIAS_SAME_PORTS
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"try to keep original port numbers for connections"
block|,
literal|"same_ports"
block|,
literal|"m"
block|}
block|,
block|{
name|Verbose
block|,
literal|0
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"verbose mode, dump packet information"
block|,
literal|"verbose"
block|,
literal|"v"
block|}
block|,
block|{
name|DynamicMode
block|,
literal|0
block|,
name|YesNo
block|,
literal|"[yes|no]"
block|,
literal|"dynamic mode, automatically detect interface address changes"
block|,
literal|"dynamic"
block|,
name|NULL
block|}
block|,
block|{
name|InPort
block|,
literal|0
block|,
name|Service
block|,
literal|"number|service_name"
block|,
literal|"set port for incoming packets"
block|,
literal|"in_port"
block|,
literal|"i"
block|}
block|,
block|{
name|OutPort
block|,
literal|0
block|,
name|Service
block|,
literal|"number|service_name"
block|,
literal|"set port for outgoing packets"
block|,
literal|"out_port"
block|,
literal|"o"
block|}
block|,
block|{
name|Port
block|,
literal|0
block|,
name|Service
block|,
literal|"number|service_name"
block|,
literal|"set port (defaults to natd/divert)"
block|,
literal|"port"
block|,
literal|"p"
block|}
block|,
block|{
name|AliasAddress
block|,
literal|0
block|,
name|Address
block|,
literal|"x.x.x.x"
block|,
literal|"address to use for aliasing"
block|,
literal|"alias_address"
block|,
literal|"a"
block|}
block|,
block|{
name|InterfaceName
block|,
literal|0
block|,
name|String
block|,
literal|"network_if_name"
block|,
literal|"take aliasing address from interface"
block|,
literal|"interface"
block|,
literal|"n"
block|}
block|,
block|{
name|PermanentLink
block|,
literal|0
block|,
name|String
block|,
literal|"tcp|udp src:port dst:port alias"
block|,
literal|"define permanent link for incoming connection"
block|,
literal|"permanent_link"
block|,
name|NULL
block|}
block|,
block|{
name|RedirectPort
block|,
literal|0
block|,
name|String
block|,
literal|"tcp|udp local_addr:local_port [public_addr:]public_port"
literal|" [remote_addr[:remote_port]]"
block|,
literal|"redirect a port for incoming traffic"
block|,
literal|"redirect_port"
block|,
name|NULL
block|}
block|,
block|{
name|RedirectAddress
block|,
literal|0
block|,
name|String
block|,
literal|"local_addr public_addr"
block|,
literal|"define mapping between local and public addresses"
block|,
literal|"redirect_address"
block|,
name|NULL
block|}
block|,
block|{
name|ConfigFile
block|,
literal|0
block|,
name|String
block|,
literal|"file_name"
block|,
literal|"read options from configuration file"
block|,
literal|"config"
block|,
literal|"f"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ParseOption
parameter_list|(
name|char
modifier|*
name|option
parameter_list|,
name|char
modifier|*
name|parms
parameter_list|,
name|int
name|cmdLine
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|OptionInfo
modifier|*
name|info
decl_stmt|;
name|int
name|yesNoValue
decl_stmt|;
name|int
name|aliasValue
decl_stmt|;
name|int
name|numValue
decl_stmt|;
name|char
modifier|*
name|strValue
decl_stmt|;
name|struct
name|in_addr
name|addrValue
decl_stmt|;
name|int
name|max
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
comment|/*  * Find option from table.  */
name|max
operator|=
sizeof|sizeof
argument_list|(
name|optionTable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|OptionInfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|info
operator|=
name|optionTable
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
operator|,
name|info
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|name
argument_list|,
name|option
argument_list|)
condition|)
break|break;
if|if
condition|(
name|info
operator|->
name|shortName
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|info
operator|->
name|shortName
argument_list|,
name|option
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|max
condition|)
block|{
name|warnx
argument_list|(
literal|"unknown option %s"
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|Usage
argument_list|()
expr_stmt|;
block|}
name|yesNoValue
operator|=
literal|0
expr_stmt|;
name|numValue
operator|=
literal|0
expr_stmt|;
name|strValue
operator|=
name|NULL
expr_stmt|;
comment|/*  * Check parameters.  */
switch|switch
condition|(
name|info
operator|->
name|parm
condition|)
block|{
case|case
name|YesNo
case|:
if|if
condition|(
operator|!
name|parms
condition|)
name|parms
operator|=
literal|"yes"
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|parms
argument_list|,
literal|"yes"
argument_list|)
condition|)
name|yesNoValue
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|parms
argument_list|,
literal|"no"
argument_list|)
condition|)
name|yesNoValue
operator|=
literal|0
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s needs yes/no parameter"
argument_list|,
name|option
argument_list|)
expr_stmt|;
break|break;
case|case
name|Service
case|:
if|if
condition|(
operator|!
name|parms
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s needs service name or port number parameter"
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|numValue
operator|=
name|StrToPort
argument_list|(
name|parms
argument_list|,
literal|"divert"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Numeric
case|:
if|if
condition|(
name|parms
condition|)
name|numValue
operator|=
name|strtol
argument_list|(
name|parms
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|else
name|end
operator|=
name|parms
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|parms
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s needs numeric parameter"
argument_list|,
name|option
argument_list|)
expr_stmt|;
break|break;
case|case
name|String
case|:
name|strValue
operator|=
name|parms
expr_stmt|;
if|if
condition|(
operator|!
name|strValue
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s needs parameter"
argument_list|,
name|option
argument_list|)
expr_stmt|;
break|break;
case|case
name|None
case|:
if|if
condition|(
name|parms
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s does not take parameters"
argument_list|,
name|option
argument_list|)
expr_stmt|;
break|break;
case|case
name|Address
case|:
if|if
condition|(
operator|!
name|parms
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s needs address/host parameter"
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|StrToAddr
argument_list|(
name|parms
argument_list|,
operator|&
name|addrValue
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|info
operator|->
name|type
condition|)
block|{
case|case
name|PacketAliasOption
case|:
name|aliasValue
operator|=
name|yesNoValue
condition|?
name|info
operator|->
name|packetAliasOpt
else|:
literal|0
expr_stmt|;
name|PacketAliasSetMode
argument_list|(
name|aliasValue
argument_list|,
name|info
operator|->
name|packetAliasOpt
argument_list|)
expr_stmt|;
break|break;
case|case
name|Verbose
case|:
name|verbose
operator|=
name|yesNoValue
expr_stmt|;
break|break;
case|case
name|DynamicMode
case|:
name|dynamicMode
operator|=
name|yesNoValue
expr_stmt|;
break|break;
case|case
name|InPort
case|:
name|inPort
operator|=
name|numValue
expr_stmt|;
break|break;
case|case
name|OutPort
case|:
name|outPort
operator|=
name|numValue
expr_stmt|;
break|break;
case|case
name|Port
case|:
name|inOutPort
operator|=
name|numValue
expr_stmt|;
break|break;
case|case
name|AliasAddress
case|:
name|memcpy
argument_list|(
operator|&
name|aliasAddr
argument_list|,
operator|&
name|addrValue
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PermanentLink
case|:
name|SetupPermanentLink
argument_list|(
name|strValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|RedirectPort
case|:
name|SetupPortRedirect
argument_list|(
name|strValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|RedirectAddress
case|:
name|SetupAddressRedirect
argument_list|(
name|strValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|InterfaceName
case|:
if|if
condition|(
name|ifName
condition|)
name|free
argument_list|(
name|ifName
argument_list|)
expr_stmt|;
name|ifName
operator|=
name|strdup
argument_list|(
name|strValue
argument_list|)
expr_stmt|;
name|assignAliasAddr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ConfigFile
case|:
name|ReadConfigFile
argument_list|(
name|strValue
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|ReadConfigFile
parameter_list|(
name|char
modifier|*
name|fileName
parameter_list|)
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|option
decl_stmt|;
name|file
operator|=
name|fopen
argument_list|(
name|fileName
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Cannot open config file %s.\n"
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|Quit
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|file
argument_list|)
condition|)
block|{
name|ptr
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"config line too link: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
name|ptr
operator|=
name|buf
expr_stmt|;
comment|/*  * Skip white space at beginning of line.  */
while|while
condition|(
operator|*
name|ptr
operator|&&
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/*  * Extract option name.  */
name|option
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
block|}
comment|/*  * Skip white space between name and parms.  */
while|while
condition|(
operator|*
name|ptr
operator|&&
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
operator|++
name|ptr
expr_stmt|;
name|ParseOption
argument_list|(
name|option
argument_list|,
operator|*
name|ptr
condition|?
name|ptr
else|:
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Usage
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|max
decl_stmt|;
name|struct
name|OptionInfo
modifier|*
name|info
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Recognized options:\n\n"
argument_list|)
expr_stmt|;
name|max
operator|=
sizeof|sizeof
argument_list|(
name|optionTable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|OptionInfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|info
operator|=
name|optionTable
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
operator|,
name|info
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%-20s %s\n"
argument_list|,
name|info
operator|->
name|name
argument_list|,
name|info
operator|->
name|parmDescription
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shortName
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%-20s %s\n"
argument_list|,
name|info
operator|->
name|shortName
argument_list|,
name|info
operator|->
name|parmDescription
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      %s\n\n"
argument_list|,
name|info
operator|->
name|description
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetupPermanentLink
parameter_list|(
name|char
modifier|*
name|parms
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|struct
name|in_addr
name|srcAddr
decl_stmt|;
name|struct
name|in_addr
name|dstAddr
decl_stmt|;
name|int
name|srcPort
decl_stmt|;
name|int
name|dstPort
decl_stmt|;
name|int
name|aliasPort
decl_stmt|;
name|int
name|proto
decl_stmt|;
name|char
modifier|*
name|protoName
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|parms
argument_list|)
expr_stmt|;
comment|/*  * Extract protocol.  */
name|protoName
operator|=
name|strtok
argument_list|(
name|buf
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|protoName
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"permanent_link: missing protocol"
argument_list|)
expr_stmt|;
name|proto
operator|=
name|StrToProto
argument_list|(
name|protoName
argument_list|)
expr_stmt|;
comment|/*  * Extract source address.  */
name|ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"permanent_link: missing src address"
argument_list|)
expr_stmt|;
name|srcPort
operator|=
name|StrToAddrAndPort
argument_list|(
name|ptr
argument_list|,
operator|&
name|srcAddr
argument_list|,
name|protoName
argument_list|)
expr_stmt|;
comment|/*  * Extract destination address.  */
name|ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"permanent_link: missing dst address"
argument_list|)
expr_stmt|;
name|dstPort
operator|=
name|StrToAddrAndPort
argument_list|(
name|ptr
argument_list|,
operator|&
name|dstAddr
argument_list|,
name|protoName
argument_list|)
expr_stmt|;
comment|/*  * Export alias port.  */
name|ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"permanent_link: missing alias port"
argument_list|)
expr_stmt|;
name|aliasPort
operator|=
name|StrToPort
argument_list|(
name|ptr
argument_list|,
name|protoName
argument_list|)
expr_stmt|;
name|PacketAliasPermanentLink
argument_list|(
name|srcAddr
argument_list|,
name|srcPort
argument_list|,
name|dstAddr
argument_list|,
name|dstPort
argument_list|,
name|aliasPort
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetupPortRedirect
parameter_list|(
name|char
modifier|*
name|parms
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|struct
name|in_addr
name|localAddr
decl_stmt|;
name|struct
name|in_addr
name|publicAddr
decl_stmt|;
name|struct
name|in_addr
name|remoteAddr
decl_stmt|;
name|int
name|localPort
decl_stmt|;
name|int
name|publicPort
decl_stmt|;
name|int
name|remotePort
decl_stmt|;
name|int
name|proto
decl_stmt|;
name|char
modifier|*
name|protoName
decl_stmt|;
name|char
modifier|*
name|separator
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|parms
argument_list|)
expr_stmt|;
comment|/*  * Extract protocol.  */
name|protoName
operator|=
name|strtok
argument_list|(
name|buf
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|protoName
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: missing protocol"
argument_list|)
expr_stmt|;
name|proto
operator|=
name|StrToProto
argument_list|(
name|protoName
argument_list|)
expr_stmt|;
comment|/*  * Extract local address.  */
name|ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: missing local address"
argument_list|)
expr_stmt|;
name|localPort
operator|=
name|StrToAddrAndPort
argument_list|(
name|ptr
argument_list|,
operator|&
name|localAddr
argument_list|,
name|protoName
argument_list|)
expr_stmt|;
comment|/*  * Extract public port and optinally address.  */
name|ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_port: missing public port"
argument_list|)
expr_stmt|;
name|separator
operator|=
name|strchr
argument_list|(
name|ptr
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|separator
condition|)
name|publicPort
operator|=
name|StrToAddrAndPort
argument_list|(
name|ptr
argument_list|,
operator|&
name|publicAddr
argument_list|,
name|protoName
argument_list|)
expr_stmt|;
else|else
block|{
name|publicAddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|publicPort
operator|=
name|StrToPort
argument_list|(
name|ptr
argument_list|,
name|protoName
argument_list|)
expr_stmt|;
block|}
comment|/*  * Extract remote address and optionally port.  */
name|ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
name|separator
operator|=
name|strchr
argument_list|(
name|ptr
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|separator
condition|)
name|remotePort
operator|=
name|StrToAddrAndPort
argument_list|(
name|ptr
argument_list|,
operator|&
name|remoteAddr
argument_list|,
name|protoName
argument_list|)
expr_stmt|;
else|else
block|{
name|remotePort
operator|=
literal|0
expr_stmt|;
name|StrToAddr
argument_list|(
name|ptr
argument_list|,
operator|&
name|remoteAddr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|remotePort
operator|=
literal|0
expr_stmt|;
name|remoteAddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
block|}
name|PacketAliasRedirectPort
argument_list|(
name|localAddr
argument_list|,
name|localPort
argument_list|,
name|remoteAddr
argument_list|,
name|remotePort
argument_list|,
name|publicAddr
argument_list|,
name|publicPort
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetupAddressRedirect
parameter_list|(
name|char
modifier|*
name|parms
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|struct
name|in_addr
name|localAddr
decl_stmt|;
name|struct
name|in_addr
name|publicAddr
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|parms
argument_list|)
expr_stmt|;
comment|/*  * Extract local address.  */
name|ptr
operator|=
name|strtok
argument_list|(
name|buf
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_address: missing local address"
argument_list|)
expr_stmt|;
name|StrToAddr
argument_list|(
name|ptr
argument_list|,
operator|&
name|localAddr
argument_list|)
expr_stmt|;
comment|/*  * Extract public address.  */
name|ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"redirect_address: missing public address"
argument_list|)
expr_stmt|;
name|StrToAddr
argument_list|(
name|ptr
argument_list|,
operator|&
name|publicAddr
argument_list|)
expr_stmt|;
name|PacketAliasRedirectAddr
argument_list|(
name|localAddr
argument_list|,
name|publicAddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|StrToAddr
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
name|inet_aton
argument_list|(
name|str
argument_list|,
name|addr
argument_list|)
condition|)
return|return;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown host %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|addr
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|StrToPort
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
name|proto
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|port
operator|=
name|strtol
argument_list|(
name|str
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|str
condition|)
return|return
name|htons
argument_list|(
name|port
argument_list|)
return|;
name|sp
operator|=
name|getservbyname
argument_list|(
name|str
argument_list|,
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sp
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown service %s/%s"
argument_list|,
name|str
argument_list|,
name|proto
argument_list|)
expr_stmt|;
return|return
name|sp
operator|->
name|s_port
return|;
block|}
end_function

begin_function
name|int
name|StrToProto
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"tcp"
argument_list|)
condition|)
return|return
name|IPPROTO_TCP
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"udp"
argument_list|)
condition|)
return|return
name|IPPROTO_UDP
return|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown protocol %s. Expected tcp or udp"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|StrToAddrAndPort
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr
parameter_list|,
name|char
modifier|*
name|proto
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s is missing port number"
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
name|StrToAddr
argument_list|(
name|str
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|StrToPort
argument_list|(
name|ptr
argument_list|,
name|proto
argument_list|)
return|;
block|}
end_function

end_unit

