begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vinum.c: vinum interface program */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997, 1998  *	Nan Yang Computer Services Limited.  All rights reserved.  *  *  Written by Greg Lehey  *  *  This software is distributed under the so-called ``Berkeley  *  License'':  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Nan Yang Computer  *      Services Limited.  * 4. Neither the name of the Company nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * This software is provided ``as is'', and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose are disclaimed.  * In no event shall the company or contributors be liable for any  * direct, indirect, incidental, special, exemplary, or consequential  * damages (including, but not limited to, procurement of substitute  * goods or services; loss of use, data, or profits; or business  * interruption) however caused and on any theory of liability, whether  * in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this software, even if  * advised of the possibility of such damage.  *  * $Id: v.c,v 1.31 2000/09/03 01:29:26 grog Exp grog $  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/vinum/vinumhdr.h>
end_include

begin_include
include|#
directive|include
file|"vext.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<readline/history.h>
end_include

begin_include
include|#
directive|include
file|<readline/readline.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_decl_stmt
name|FILE
modifier|*
name|cf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* config file handle */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|history
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* history file */
end_comment

begin_decl_stmt
name|char
modifier|*
name|historyfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and its name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dateformat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* format in which to store date */
end_comment

begin_decl_stmt
name|char
name|buffer
index|[
name|BUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer to read in to */
end_comment

begin_decl_stmt
name|int
name|line
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stdin line number for error messages */
end_comment

begin_decl_stmt
name|int
name|file_line
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and line in input file (yes, this is tacky) */
end_comment

begin_decl_stmt
name|int
name|inerror
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 to exit after end of config file */
end_comment

begin_comment
comment|/* flags */
end_comment

begin_if
if|#
directive|if
name|VINUMDEBUG
end_if

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug flag, usage varies */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 to force some dangerous ops */
end_comment

begin_decl_stmt
name|int
name|interval
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interval in ms between init/revive */
end_comment

begin_decl_stmt
name|int
name|vflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set verbose operation or verify */
end_comment

begin_decl_stmt
name|int
name|Verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set very verbose operation */
end_comment

begin_decl_stmt
name|int
name|recurse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set recursion */
end_comment

begin_decl_stmt
name|int
name|sflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show statistics */
end_comment

begin_decl_stmt
name|int
name|SSize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sector size for revive */
end_comment

begin_decl_stmt
name|int
name|dowait
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wait for completion */
end_comment

begin_decl_stmt
name|char
modifier|*
name|objectname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name to be passed for -n flag */
end_comment

begin_comment
comment|/* Structures to read kernel data into */
end_comment

begin_decl_stmt
name|struct
name|_vinum_conf
name|vinum_conf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* configuration information */
end_comment

begin_decl_stmt
name|struct
name|volume
name|vol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|plex
name|plex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sd
name|sd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|drive
name|drive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|command_fail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* return on a failed command */
end_comment

begin_decl_stmt
name|int
name|superdev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* vinum super device */
end_comment

begin_function_decl
name|void
name|start_daemon
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ofs
parameter_list|(
name|x
parameter_list|)
value|((void *) (& ((struct confdata *) 0)->x))
end_define

begin_comment
comment|/* offset of x in struct confdata */
end_comment

begin_decl_stmt
name|char
modifier|*
name|token
index|[
name|MAXARGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to individual tokens */
end_comment

begin_decl_stmt
name|int
name|tokens
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of tokens */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|char
modifier|*
name|envp
index|[]
parameter_list|)
block|{
name|struct
name|stat
name|histstat
decl_stmt|;
if|if
condition|(
name|modfind
argument_list|(
name|VINUMMOD
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* need to load the vinum module */
if|if
condition|(
name|kldload
argument_list|(
name|VINUMMOD
argument_list|)
operator|<
literal|0
operator|||
name|modfind
argument_list|(
name|VINUMMOD
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|VINUMMOD
literal|": Kernel module not available"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|dateformat
operator|=
name|getenv
argument_list|(
literal|"VINUM_DATEFORMAT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dateformat
operator|==
name|NULL
condition|)
name|dateformat
operator|=
literal|"%e %b %Y %H:%M:%S"
expr_stmt|;
name|historyfile
operator|=
name|getenv
argument_list|(
literal|"VINUM_HISTORY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|historyfile
operator|==
name|NULL
condition|)
name|historyfile
operator|=
name|DEFAULT_HISTORYFILE
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|historyfile
argument_list|,
operator|&
name|histstat
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* history file exists */
if|if
condition|(
operator|(
name|histstat
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Vinum history file %s must be a regular file\n"
argument_list|,
name|historyfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|errno
operator|!=
name|ENOENT
operator|)
comment|/* not "not there",  */
operator|&&
operator|(
name|errno
operator|!=
name|EROFS
operator|)
condition|)
block|{
comment|/* and not read-only file system */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s: %s (%d)\n"
argument_list|,
name|historyfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|history
operator|=
name|fopen
argument_list|(
name|historyfile
argument_list|,
literal|"a+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|history
operator|!=
name|NULL
condition|)
block|{
name|timestamp
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|history
argument_list|,
literal|"*** "
name|VINUMMOD
literal|" started ***\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|history
argument_list|)
expr_stmt|;
comment|/* before we start the daemon */
block|}
name|superdev
operator|=
name|open
argument_list|(
name|VINUM_SUPERDEV_NAME
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
comment|/* open vinum superdevice */
if|if
condition|(
name|superdev
operator|<
literal|0
condition|)
block|{
comment|/* no go */
if|if
condition|(
name|errno
operator|==
name|ENODEV
condition|)
block|{
comment|/* not configured, */
name|superdev
operator|=
name|open
argument_list|(
name|VINUM_WRONGSUPERDEV_NAME
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
comment|/* do we have a debug mismatch? */
if|if
condition|(
name|superdev
operator|>=
literal|0
condition|)
block|{
comment|/* yup! */
if|#
directive|if
name|VINUMDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"This program is compiled with debug support, but the kernel module does\n"
literal|"not have debug support.  This program must be matched with the kernel\n"
literal|"module.  Please alter /usr/src/sbin/"
name|VINUMMOD
literal|"/Makefile and remove\n"
literal|"the option -DVINUMDEBUG from the CFLAGS definition, or alternatively\n"
literal|"edit /usr/src/sys/modules/"
name|VINUMMOD
literal|"/Makefile and add the option\n"
literal|"-DVINUMDEBUG to the CFLAGS definition.  Then rebuild the component\n"
literal|"of your choice with 'make clean all install'.  If you rebuild the kernel\n"
literal|"module, you must stop "
name|VINUMMOD
literal|" and restart it\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"This program is compiled without debug support, but the kernel module\n"
literal|"includes debug support.  This program must be matched with the kernel\n"
literal|"module.  Please alter /usr/src/sbin/"
name|VINUMMOD
literal|"/Makefile and add\n"
literal|"the option -DVINUMDEBUG to the CFLAGS definition, or alternatively\n"
literal|"edit /usr/src/sys/modules/"
name|VINUMMOD
literal|"/Makefile and remove the option\n"
literal|"-DVINUMDEBUG from the CFLAGS definition.  Then rebuild the component\n"
literal|"of your choice with 'make clean all install'.  If you rebuild the kernel\n"
literal|"module, you must stop "
name|VINUMMOD
literal|" and restart it\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
comment|/* we don't have our node, */
name|make_devices
argument_list|()
expr_stmt|;
comment|/* create them first */
if|if
condition|(
name|superdev
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Can't open "
name|VINUM_SUPERDEV_NAME
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Check if the dæmon is running.  If not, start it in the      * background */
name|start_daemon
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
comment|/* we have a command on the line */
if|if
condition|(
name|setjmp
argument_list|(
name|command_fail
argument_list|)
operator|!=
literal|0
condition|)
comment|/* long jumped out */
return|return
operator|-
literal|1
return|;
name|parseline
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
operator|&
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* do it */
block|}
else|else
block|{
comment|/* 	 * Catch a possible race condition which could cause us to 	 * longjmp() into nowhere if we receive a SIGINT in the next few 	 * lines. 	 */
if|if
condition|(
name|setjmp
argument_list|(
name|command_fail
argument_list|)
condition|)
comment|/* come back here on catastrophic failure */
return|return
literal|1
return|;
name|setsigs
argument_list|()
expr_stmt|;
comment|/* set signal handler */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* ugh */
name|char
modifier|*
name|c
decl_stmt|;
name|int
name|childstatus
decl_stmt|;
comment|/* from wait4 */
if|if
condition|(
name|setjmp
argument_list|(
name|command_fail
argument_list|)
operator|==
literal|2
condition|)
comment|/* come back here on catastrophic failure */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** interrupted ***\n"
argument_list|)
expr_stmt|;
comment|/* interrupted */
while|while
condition|(
name|wait4
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|childstatus
argument_list|,
name|WNOHANG
argument_list|,
name|NULL
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
comment|/* wait for all dead children */
name|c
operator|=
name|readline
argument_list|(
name|VINUMMOD
literal|" -> "
argument_list|)
expr_stmt|;
comment|/* get an input */
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
comment|/* EOF or error */
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read input: %s (%d)\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* EOF */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|c
condition|)
block|{
comment|/* got something there */
name|add_history
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* save it in the history */
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* put it where we can munge it */
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|line
operator|++
expr_stmt|;
comment|/* count the lines */
name|tokens
operator|=
name|tokenize
argument_list|(
name|buffer
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* got something potentially worth parsing */
if|if
condition|(
name|tokens
condition|)
name|parseline
argument_list|(
name|tokens
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* and do what he says */
block|}
if|if
condition|(
name|history
condition|)
name|fflush
argument_list|(
name|history
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
comment|/* normal completion */
block|}
end_function

begin_comment
comment|/* stop the hard way */
end_comment

begin_function
name|void
name|vinum_quit
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|char
modifier|*
name|argv0
index|[]
parameter_list|)
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set action on receiving a SIGINT */
end_comment

begin_function
name|void
name|setsigs
parameter_list|()
block|{
name|struct
name|sigaction
name|act
decl_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|catchsig
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|catchsig
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|longjmp
argument_list|(
name|command_fail
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|FUNKEY
parameter_list|(
name|x
parameter_list|)
value|{ kw_##x,&vinum_##x }
end_define

begin_comment
comment|/* create pair "kw_foo", vinum_foo */
end_comment

begin_define
define|#
directive|define
name|vinum_move
value|vinum_mv
end_define

begin_comment
comment|/* synonym for 'mv' */
end_comment

begin_struct
struct|struct
name|funkey
block|{
name|enum
name|keyword
name|kw
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|char
modifier|*
name|arg0
index|[]
parameter_list|)
function_decl|;
block|}
name|funkeys
index|[]
init|=
block|{
name|FUNKEY
argument_list|(
name|create
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|read
argument_list|)
block|,
ifdef|#
directive|ifdef
name|VINUMDEBUG
name|FUNKEY
argument_list|(
name|debug
argument_list|)
block|,
endif|#
directive|endif
name|FUNKEY
argument_list|(
name|modify
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|list
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|ld
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|ls
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|lp
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|lv
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|info
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|set
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|init
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|label
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|resetconfig
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|rm
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|mv
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|move
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|attach
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|detach
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|rename
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|replace
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|printconfig
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|saveconfig
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|start
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|stop
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|makedev
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|help
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|quit
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|concat
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|stripe
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|raid4
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|raid5
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|mirror
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|setdaemon
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|readpol
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|resetstats
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|setstate
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|checkparity
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|rebuildparity
argument_list|)
block|,
name|FUNKEY
argument_list|(
argument|dumpconfig
argument_list|)
block|}
struct|;
end_struct

begin_comment
comment|/* Take args arguments at argv and attempt to perform the operation specified */
end_comment

begin_function
name|void
name|parseline
parameter_list|(
name|int
name|args
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|enum
name|keyword
name|command
decl_stmt|;
comment|/* command to execute */
if|if
condition|(
name|history
operator|!=
name|NULL
condition|)
block|{
comment|/* save the command to history file */
name|timestamp
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
condition|;
name|i
operator|++
control|)
comment|/* all args */
name|fprintf
argument_list|(
name|history
argument_list|,
literal|"%s "
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|history
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|args
operator|==
literal|0
operator|)
comment|/* empty line */
operator|||
operator|(
operator|*
name|argv
index|[
literal|0
index|]
operator|==
literal|'#'
operator|)
condition|)
comment|/* or a comment, */
return|return;
if|if
condition|(
name|args
operator|==
name|MAXARGS
condition|)
block|{
comment|/* too many arguments, */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many arguments to %s, this can't be right\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|command
operator|=
name|get_keyword
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|keyword_set
argument_list|)
expr_stmt|;
name|dowait
operator|=
literal|0
expr_stmt|;
comment|/* initialize flags */
name|force
operator|=
literal|0
expr_stmt|;
comment|/* initialize flags */
name|vflag
operator|=
literal|0
expr_stmt|;
comment|/* initialize flags */
name|Verbose
operator|=
literal|0
expr_stmt|;
comment|/* initialize flags */
name|recurse
operator|=
literal|0
expr_stmt|;
comment|/* initialize flags */
name|sflag
operator|=
literal|0
expr_stmt|;
comment|/* initialize flags */
name|objectname
operator|=
name|NULL
expr_stmt|;
comment|/* no name yet */
comment|/*      * first handle generic options      * We don't use getopt(3) because      * getopt doesn't allow merging flags      * (for example, -fr).      */
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|i
operator|<
name|args
operator|)
operator|&&
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* while we have flags */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
block|{
if|#
directive|if
name|VINUMDEBUG
case|case
literal|'d'
case|:
comment|/* -d: debug */
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'f'
case|:
comment|/* -f: force */
name|force
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* interval */
name|interval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
operator|+
literal|1
index|]
operator|!=
literal|'\0'
condition|)
comment|/* operand follows, */
name|interval
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
name|i
index|]
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* use it */
elseif|else
if|if
condition|(
name|args
operator|>
operator|(
name|i
operator|+
literal|1
operator|)
condition|)
comment|/* another following, */
name|interval
operator|=
name|atoi
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* use it */
if|if
condition|(
name|interval
operator|==
literal|0
condition|)
comment|/* nothing valid, */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-i: no interval specified\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* -n: get name */
if|if
condition|(
name|i
operator|==
name|args
operator|-
literal|1
condition|)
block|{
comment|/* last arg */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-n requires a name parameter\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|objectname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
comment|/* pick it up */
name|j
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* skip the next parm */
break|break;
case|case
literal|'r'
case|:
comment|/* -r: recurse */
name|recurse
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* -s: show statistics */
name|sflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|SSize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
operator|+
literal|1
index|]
operator|!=
literal|'\0'
condition|)
comment|/* operand follows, */
name|SSize
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
name|i
index|]
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* use it */
elseif|else
if|if
condition|(
name|args
operator|>
operator|(
name|i
operator|+
literal|1
operator|)
condition|)
comment|/* another following, */
name|SSize
operator|=
name|atoi
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* use it */
if|if
condition|(
name|SSize
operator|==
literal|0
condition|)
comment|/* nothing valid, */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-S: no size specified\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* -v: verbose */
name|vflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* -V: Very verbose */
name|vflag
operator|++
expr_stmt|;
name|Verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* -w: wait for completion */
name|dowait
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid flag: %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Pass what we have left to the command to handle it */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|funkeys
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|funkey
argument_list|)
operator|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|funkeys
index|[
name|j
index|]
operator|.
name|kw
operator|==
name|command
condition|)
block|{
comment|/* found the command */
name|funkeys
index|[
name|j
index|]
operator|.
name|fun
argument_list|(
name|args
operator|-
name|i
argument_list|,
operator|&
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown command: %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|get_drive_info
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|,
name|int
name|index
parameter_list|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|drive
operator|=
name|index
expr_stmt|;
comment|/* put in drive to hand to driver */
if|if
condition|(
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_DRIVECONFIG
argument_list|,
name|drive
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get config for drive %d: %s\n"
argument_list|,
name|index
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|command_fail
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|get_sd_info
parameter_list|(
name|struct
name|sd
modifier|*
name|sd
parameter_list|,
name|int
name|index
parameter_list|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|sd
operator|=
name|index
expr_stmt|;
comment|/* put in sd to hand to driver */
if|if
condition|(
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_SDCONFIG
argument_list|,
name|sd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get config for subdisk %d: %s\n"
argument_list|,
name|index
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|command_fail
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get the contents of the sd entry for subdisk<sdno>  * of the specified plex. */
end_comment

begin_function
name|void
name|get_plex_sd_info
parameter_list|(
name|struct
name|sd
modifier|*
name|sd
parameter_list|,
name|int
name|plexno
parameter_list|,
name|int
name|sdno
parameter_list|)
block|{
operator|(
operator|(
name|int
operator|*
operator|)
name|sd
operator|)
index|[
literal|0
index|]
operator|=
name|plexno
expr_stmt|;
operator|(
operator|(
name|int
operator|*
operator|)
name|sd
operator|)
index|[
literal|1
index|]
operator|=
name|sdno
expr_stmt|;
comment|/* pass parameters */
if|if
condition|(
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_PLEXSDCONFIG
argument_list|,
name|sd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get config for subdisk %d (part of plex %d): %s\n"
argument_list|,
name|sdno
argument_list|,
name|plexno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|command_fail
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|get_plex_info
parameter_list|(
name|struct
name|plex
modifier|*
name|plex
parameter_list|,
name|int
name|index
parameter_list|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|plex
operator|=
name|index
expr_stmt|;
comment|/* put in plex to hand to driver */
if|if
condition|(
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_PLEXCONFIG
argument_list|,
name|plex
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get config for plex %d: %s\n"
argument_list|,
name|index
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|command_fail
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|get_volume_info
parameter_list|(
name|struct
name|volume
modifier|*
name|volume
parameter_list|,
name|int
name|index
parameter_list|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|volume
operator|=
name|index
expr_stmt|;
comment|/* put in volume to hand to driver */
if|if
condition|(
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_VOLCONFIG
argument_list|,
name|volume
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get config for volume %d: %s\n"
argument_list|,
name|index
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|command_fail
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|drive
modifier|*
name|find_drive_by_devname
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|driveno
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_GETCONFIG
argument_list|,
operator|&
name|vinum_conf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Can't get vinum config"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|vinum_conf
operator|.
name|drives_allocated
condition|;
name|driveno
operator|++
control|)
block|{
name|get_drive_info
argument_list|(
operator|&
name|drive
argument_list|,
name|driveno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|drive
operator|.
name|state
operator|!=
name|drive_unallocated
operator|)
comment|/* real drive */
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|drive
operator|.
name|devicename
argument_list|,
name|name
argument_list|)
operator|)
condition|)
comment|/* and the name's right, */
return|return
operator|&
name|drive
return|;
comment|/* found it */
block|}
return|return
name|NULL
return|;
comment|/* no drive of that name */
block|}
end_function

begin_comment
comment|/* Create the device nodes for vinum objects */
end_comment

begin_function
name|void
name|make_devices
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|volno
decl_stmt|;
name|int
name|plexno
decl_stmt|;
name|int
name|sdno
decl_stmt|;
name|int
name|driveno
decl_stmt|;
if|if
condition|(
name|access
argument_list|(
literal|"/dev"
argument_list|,
name|W_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* can't access /dev to write? */
if|if
condition|(
name|errno
operator|==
name|EROFS
condition|)
comment|/* because it's read-only, */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|VINUMMOD
literal|": /dev is mounted read-only, not rebuilding "
name|VINUM_DIR
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|perror
argument_list|(
name|VINUMMOD
literal|": Can't write to /dev"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|history
condition|)
block|{
name|timestamp
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|history
argument_list|,
literal|"*** Created devices ***\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|superdev
operator|>=
literal|0
condition|)
comment|/* super device open */
name|close
argument_list|(
name|superdev
argument_list|)
expr_stmt|;
name|system
argument_list|(
literal|"rm -rf "
name|VINUM_DIR
argument_list|)
expr_stmt|;
comment|/* remove the old directories */
name|system
argument_list|(
literal|"mkdir -p "
name|VINUM_DIR
literal|"/drive "
comment|/* and make them again */
name|VINUM_DIR
literal|"/plex "
name|VINUM_DIR
literal|"/sd "
name|VINUM_DIR
literal|"/vol"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|VINUM_SUPERDEV_NAME
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IFCHR
argument_list|,
comment|/* user only */
name|makedev
argument_list|(
name|VINUM_CDEV_MAJOR
argument_list|,
name|VINUM_SUPERDEV
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|VINUM_SUPERDEV_NAME
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|VINUM_WRONGSUPERDEV_NAME
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IFCHR
argument_list|,
comment|/* user only */
name|makedev
argument_list|(
name|VINUM_CDEV_MAJOR
argument_list|,
name|VINUM_WRONGSUPERDEV
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|VINUM_WRONGSUPERDEV_NAME
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|superdev
operator|=
name|open
argument_list|(
name|VINUM_SUPERDEV_NAME
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
comment|/* open the super device */
if|if
condition|(
name|mknod
argument_list|(
name|VINUM_DAEMON_DEV_NAME
argument_list|,
comment|/* daemon super device */
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IFCHR
argument_list|,
comment|/* user only */
name|makedev
argument_list|(
name|VINUM_CDEV_MAJOR
argument_list|,
name|VINUM_DAEMON_DEV
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|VINUM_DAEMON_DEV_NAME
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_GETCONFIG
argument_list|,
operator|&
name|vinum_conf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Can't get vinum config"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|volno
operator|=
literal|0
init|;
name|volno
operator|<
name|vinum_conf
operator|.
name|volumes_allocated
condition|;
name|volno
operator|++
control|)
name|make_vol_dev
argument_list|(
name|volno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vinum_conf
operator|.
name|plexes_allocated
condition|;
name|plexno
operator|++
control|)
name|make_plex_dev
argument_list|(
name|plexno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|vinum_conf
operator|.
name|subdisks_allocated
condition|;
name|sdno
operator|++
control|)
name|make_sd_dev
argument_list|(
name|sdno
argument_list|)
expr_stmt|;
comment|/* Drives.  Do this later (both logical and physical names) XXX */
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|vinum_conf
operator|.
name|drives_allocated
condition|;
name|driveno
operator|++
control|)
block|{
name|char
name|filename
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* for forming file names */
name|get_drive_info
argument_list|(
operator|&
name|drive
argument_list|,
name|driveno
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive
operator|.
name|state
operator|>
name|drive_referenced
condition|)
block|{
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"ln -s %s "
name|VINUM_DIR
literal|"/drive/%s"
argument_list|,
name|drive
operator|.
name|devicename
argument_list|,
name|drive
operator|.
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* make the devices for a volume */
end_comment

begin_function
name|void
name|make_vol_dev
parameter_list|(
name|int
name|volno
parameter_list|,
name|int
name|recurse
parameter_list|)
block|{
name|dev_t
name|voldev
decl_stmt|;
name|char
name|filename
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* for forming file names */
name|int
name|plexno
decl_stmt|;
name|get_volume_info
argument_list|(
operator|&
name|vol
argument_list|,
name|volno
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|.
name|state
operator|!=
name|volume_unallocated
condition|)
block|{
comment|/* we could have holes in our lists */
name|voldev
operator|=
name|VINUMDEV
argument_list|(
name|volno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|VINUM_VOLUME_TYPE
argument_list|)
expr_stmt|;
comment|/* create a device number */
comment|/* Create /dev/vinum/<myvol> */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/%s"
argument_list|,
name|vol
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|filename
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IFCHR
argument_list|,
name|voldev
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create /dev/vinum/vol/<myvol> */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/vol/%s"
argument_list|,
name|vol
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|filename
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IFCHR
argument_list|,
name|voldev
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|.
name|plexes
operator|>
literal|0
condition|)
block|{
comment|/* Create /dev/vinum/vol/<myvol>.plex/ */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/vol/%s.plex"
argument_list|,
name|vol
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|filename
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IXOTH
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recurse
condition|)
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vol
operator|.
name|plexes
condition|;
name|plexno
operator|++
control|)
name|make_plex_dev
argument_list|(
name|plex
operator|.
name|plexno
argument_list|,
name|recurse
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Create device entries for the plexes in  * /dev/vinum/<vol>.plex/ and /dev/vinum/plex.  */
end_comment

begin_function
name|void
name|make_plex_dev
parameter_list|(
name|int
name|plexno
parameter_list|,
name|int
name|recurse
parameter_list|)
block|{
name|dev_t
name|plexdev
decl_stmt|;
comment|/* device */
name|char
name|filename
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* for forming file names */
name|int
name|sdno
decl_stmt|;
name|get_plex_info
argument_list|(
operator|&
name|plex
argument_list|,
name|plexno
argument_list|)
expr_stmt|;
if|if
condition|(
name|plex
operator|.
name|state
operator|!=
name|plex_unallocated
condition|)
block|{
name|plexdev
operator|=
name|VINUM_PLEX
argument_list|(
name|plexno
argument_list|)
expr_stmt|;
comment|/* /dev/vinum/plex/<plex> */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/plex/%s"
argument_list|,
name|plex
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|filename
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IFCHR
argument_list|,
name|plexdev
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plex
operator|.
name|volno
operator|>=
literal|0
condition|)
block|{
name|get_volume_info
argument_list|(
operator|&
name|vol
argument_list|,
name|plex
operator|.
name|volno
argument_list|)
expr_stmt|;
name|plexdev
operator|=
name|VINUMDEV
argument_list|(
name|plex
operator|.
name|volno
argument_list|,
name|plexno
argument_list|,
literal|0
argument_list|,
name|VINUM_PLEX_TYPE
argument_list|)
expr_stmt|;
comment|/* Create device /dev/vinum/vol/<vol>.plex/<plex> */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/vol/%s.plex/%s"
argument_list|,
name|vol
operator|.
name|name
argument_list|,
name|plex
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|filename
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IFCHR
argument_list|,
name|plexdev
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create directory /dev/vinum/vol/<vol>.plex/<plex>.sd */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/vol/%s.plex/%s.sd"
argument_list|,
name|vol
operator|.
name|name
argument_list|,
name|plex
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|filename
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IXOTH
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recurse
condition|)
block|{
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|.
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
name|get_plex_sd_info
argument_list|(
operator|&
name|sd
argument_list|,
name|plex
operator|.
name|plexno
argument_list|,
name|sdno
argument_list|)
expr_stmt|;
name|make_sd_dev
argument_list|(
name|sd
operator|.
name|sdno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Create the contents of /dev/vinum/sd and /dev/vinum/rsd */
end_comment

begin_function
name|void
name|make_sd_dev
parameter_list|(
name|int
name|sdno
parameter_list|)
block|{
name|dev_t
name|sddev
decl_stmt|;
comment|/* device */
name|char
name|filename
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* for forming file names */
name|get_sd_info
argument_list|(
operator|&
name|sd
argument_list|,
name|sdno
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|.
name|state
operator|!=
name|sd_unallocated
condition|)
block|{
name|sddev
operator|=
name|VINUM_SD
argument_list|(
name|sdno
argument_list|)
expr_stmt|;
comment|/* /dev/vinum/sd/<sd> */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/sd/%s"
argument_list|,
name|sd
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|filename
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IFCHR
argument_list|,
name|sddev
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* command line interface for the 'makedev' command */
end_comment

begin_function
name|void
name|vinum_makedev
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|char
modifier|*
name|arg0
index|[]
parameter_list|)
block|{
name|make_devices
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the object "name".  Return object type at type,  * and the index as the return value.  * If not found, return -1 and invalid_object.  */
end_comment

begin_function
name|int
name|find_object
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|objecttype
modifier|*
name|type
parameter_list|)
block|{
name|int
name|object
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_GETCONFIG
argument_list|,
operator|&
name|vinum_conf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Can't get vinum config"
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|invalid_object
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Search the drive table */
for|for
control|(
name|object
operator|=
literal|0
init|;
name|object
operator|<
name|vinum_conf
operator|.
name|drives_allocated
condition|;
name|object
operator|++
control|)
block|{
name|get_drive_info
argument_list|(
operator|&
name|drive
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|drive
operator|.
name|label
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|type
operator|=
name|drive_object
expr_stmt|;
return|return
name|object
return|;
block|}
block|}
comment|/* Search the subdisk table */
for|for
control|(
name|object
operator|=
literal|0
init|;
name|object
operator|<
name|vinum_conf
operator|.
name|subdisks_allocated
condition|;
name|object
operator|++
control|)
block|{
name|get_sd_info
argument_list|(
operator|&
name|sd
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|sd
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|type
operator|=
name|sd_object
expr_stmt|;
return|return
name|object
return|;
block|}
block|}
comment|/* Search the plex table */
for|for
control|(
name|object
operator|=
literal|0
init|;
name|object
operator|<
name|vinum_conf
operator|.
name|plexes_allocated
condition|;
name|object
operator|++
control|)
block|{
name|get_plex_info
argument_list|(
operator|&
name|plex
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|plex
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|type
operator|=
name|plex_object
expr_stmt|;
return|return
name|object
return|;
block|}
block|}
comment|/* Search the volume table */
for|for
control|(
name|object
operator|=
literal|0
init|;
name|object
operator|<
name|vinum_conf
operator|.
name|volumes_allocated
condition|;
name|object
operator|++
control|)
block|{
name|get_volume_info
argument_list|(
operator|&
name|vol
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|vol
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|type
operator|=
name|volume_object
expr_stmt|;
return|return
name|object
return|;
block|}
block|}
comment|/* Didn't find the name: invalid */
operator|*
name|type
operator|=
name|invalid_object
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Continue reviving a subdisk in the background */
end_comment

begin_function
name|void
name|continue_revive
parameter_list|(
name|int
name|sdno
parameter_list|)
block|{
name|struct
name|sd
name|sd
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|get_sd_info
argument_list|(
operator|&
name|sd
argument_list|,
name|sdno
argument_list|)
expr_stmt|;
if|if
condition|(
name|dowait
operator|==
literal|0
condition|)
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
comment|/* do this in the background */
else|else
name|pid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* we're the child */
name|struct
name|_ioctl_reply
name|reply
decl_stmt|;
name|struct
name|vinum_ioctl_msg
modifier|*
name|message
init|=
operator|(
expr|struct
name|vinum_ioctl_msg
operator|*
operator|)
operator|&
name|reply
decl_stmt|;
name|openlog
argument_list|(
name|VINUMMOD
argument_list|,
name|LOG_CONS
operator||
name|LOG_PERROR
operator||
name|LOG_PID
argument_list|,
name|LOG_KERN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
operator||
name|LOG_KERN
argument_list|,
literal|"reviving %s"
argument_list|,
name|sd
operator|.
name|name
argument_list|)
expr_stmt|;
name|setproctitle
argument_list|(
literal|"reviving %s"
argument_list|,
name|sd
operator|.
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|reply
operator|.
name|error
operator|=
name|EAGAIN
init|;
name|reply
operator|.
name|error
operator|==
name|EAGAIN
condition|;
control|)
block|{
comment|/* revive the subdisk */
if|if
condition|(
name|interval
condition|)
name|usleep
argument_list|(
name|interval
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* pause between each copy */
name|message
operator|->
name|index
operator|=
name|sdno
expr_stmt|;
comment|/* pass sd number */
name|message
operator|->
name|type
operator|=
name|sd_object
expr_stmt|;
comment|/* and type of object */
name|message
operator|->
name|state
operator|=
name|object_up
expr_stmt|;
if|if
condition|(
name|SSize
operator|!=
literal|0
condition|)
block|{
comment|/* specified a size for init */
if|if
condition|(
name|SSize
operator|<
literal|512
condition|)
name|SSize
operator|<<=
name|DEV_BSHIFT
expr_stmt|;
name|message
operator|->
name|blocksize
operator|=
name|SSize
expr_stmt|;
block|}
else|else
name|message
operator|->
name|blocksize
operator|=
name|DEFAULT_REVIVE_BLOCKSIZE
expr_stmt|;
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_SETSTATE
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reply
operator|.
name|error
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
operator||
name|LOG_KERN
argument_list|,
literal|"can't revive %s: %s"
argument_list|,
name|sd
operator|.
name|name
argument_list|,
name|reply
operator|.
name|msg
index|[
literal|0
index|]
condition|?
name|reply
operator|.
name|msg
else|:
name|strerror
argument_list|(
name|reply
operator|.
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dowait
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|get_sd_info
argument_list|(
operator|&
name|sd
argument_list|,
name|sdno
argument_list|)
expr_stmt|;
comment|/* update the info */
name|syslog
argument_list|(
name|LOG_INFO
operator||
name|LOG_KERN
argument_list|,
literal|"%s is %s"
argument_list|,
name|sd
operator|.
name|name
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dowait
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
comment|/* couldn't fork? */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't continue reviving %s: %s\n"
argument_list|,
name|sd
operator|.
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* parent */
name|printf
argument_list|(
literal|"Reviving %s in the background\n"
argument_list|,
name|sd
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if the daemon is running,  * start it if it isn't.  The check itself  * could take a while, so we do it as a separate  * process, which will become the daemon if one isn't  * running already  */
end_comment

begin_function
name|void
name|start_daemon
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pid
operator|=
operator|(
name|int
operator|)
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* We're the child, do the work */
comment|/* 	 * We have a problem when stopping the subsystem: 	 * The only way to know that we're idle is when 	 * all open superdevs close.  But we want the 	 * daemon to clean up for us, and since we can't 	 * count the opens, we need to have the main device 	 * closed when we stop.  We solve this conundrum 	 * by getting the daemon to open a separate device. 	 */
name|close
argument_list|(
name|superdev
argument_list|)
expr_stmt|;
comment|/* this is the wrong device */
name|superdev
operator|=
name|open
argument_list|(
name|VINUM_DAEMON_DEV_NAME
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
comment|/* open deamon superdevice */
if|if
condition|(
name|superdev
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Can't open "
name|VINUM_DAEMON_DEV_NAME
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* this will fork again, but who's counting? */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't start daemon: %s (%d)\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|setproctitle
argument_list|(
name|VINUMMOD
literal|" daemon"
argument_list|)
expr_stmt|;
comment|/* show what we're doing */
name|status
operator|=
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_FINDDAEMON
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
comment|/* no daemon, */
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_DAEMON
argument_list|,
operator|&
name|vflag
argument_list|)
expr_stmt|;
comment|/* we should hang here */
name|syslog
argument_list|(
name|LOG_ERR
operator||
name|LOG_KERN
argument_list|,
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* when told to die */
block|}
elseif|else
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
comment|/* couldn't fork */
name|printf
argument_list|(
literal|"Can't fork to check daemon\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|timestamp
parameter_list|()
block|{
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|tm
modifier|*
name|date
decl_stmt|;
name|char
name|datetext
index|[
name|MAXDATETEXT
index|]
decl_stmt|;
name|time_t
name|sec
decl_stmt|;
if|if
condition|(
name|history
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get time: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|sec
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|date
operator|=
name|localtime
argument_list|(
operator|&
name|sec
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|datetext
argument_list|,
name|MAXDATETEXT
argument_list|,
name|dateformat
argument_list|,
name|date
argument_list|)
operator|,
name|fprintf
argument_list|(
name|history
argument_list|,
literal|"%s.%06ld "
argument_list|,
name|datetext
argument_list|,
name|now
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

