begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vinum.c: vinum interface program */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997, 1998  *	Nan Yang Computer Services Limited.  All rights reserved.  *  *  This software is distributed under the so-called ``Berkeley  *  License'':  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Nan Yang Computer  *      Services Limited.  * 4. Neither the name of the Company nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * This software is provided ``as is'', and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose are disclaimed.  * In no event shall the company or contributors be liable for any  * direct, indirect, incidental, special, exemplary, or consequential  * damages (including, but not limited to, procurement of substitute  * goods or services; loss of use, data, or profits; or business  * interruption) however caused and on any theory of liability, whether  * in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this software, even if  * advised of the possibility of such damage.  *  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/vinum/vinumhdr.h>
end_include

begin_include
include|#
directive|include
file|"vext.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<readline/history.h>
end_include

begin_include
include|#
directive|include
file|<readline/readline.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_decl_stmt
name|FILE
modifier|*
name|cf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* config file handle */
end_comment

begin_decl_stmt
name|char
name|buffer
index|[
name|BUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer to read in to */
end_comment

begin_decl_stmt
name|int
name|line
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stdin line number for error messages */
end_comment

begin_decl_stmt
name|int
name|file_line
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and line in input file (yes, this is tacky) */
end_comment

begin_decl_stmt
name|int
name|inerror
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 to exit after end of config file */
end_comment

begin_comment
comment|/* flags */
end_comment

begin_if
if|#
directive|if
name|VINUMDEBUG
end_if

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug flag, usage varies */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 to force some dangerous ops */
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set verbose operation */
end_comment

begin_decl_stmt
name|int
name|Verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set very verbose operation */
end_comment

begin_decl_stmt
name|int
name|recurse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set recursion */
end_comment

begin_decl_stmt
name|int
name|stats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show statistics */
end_comment

begin_comment
comment|/* Structures to read kernel data into */
end_comment

begin_decl_stmt
name|struct
name|_vinum_conf
name|vinum_conf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* configuration information */
end_comment

begin_decl_stmt
name|struct
name|volume
name|vol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|plex
name|plex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sd
name|sd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|drive
name|drive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|command_fail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* return on a failed command */
end_comment

begin_decl_stmt
name|int
name|superdev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* vinum super device */
end_comment

begin_function_decl
name|void
name|start_daemon
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ofs
parameter_list|(
name|x
parameter_list|)
value|((void *) (& ((struct confdata *) 0)->x))
end_define

begin_comment
comment|/* offset of x in struct confdata */
end_comment

begin_comment
comment|/*   create description-file    Create a volume as described in description-file    modify description-file    Modify the objects as described in description-file    list [-r] [volume | plex | subdisk]    List information about specified objects    set [-f] state volume | plex | subdisk | disk    Set the state of the object to state    rm [-f] [-r] volume | plex | subdisk    Remove an object    start [volume | plex | subdisk]    Allow the system to access the objects    stop [-f] [volume | plex | subdisk]    Terminate access the objects  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|token
index|[
name|MAXARGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to individual tokens */
end_comment

begin_decl_stmt
name|int
name|tokens
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of tokens */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|superdev
operator|=
name|open
argument_list|(
name|VINUM_SUPERDEV_NAME
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
comment|/* open it */
if|if
condition|(
name|superdev
operator|<
literal|0
condition|)
block|{
comment|/* no go */
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
comment|/* we don't have our node, */
name|make_devices
argument_list|()
expr_stmt|;
comment|/* create them first */
if|if
condition|(
name|superdev
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Can't open "
name|VINUM_SUPERDEV_NAME
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Check if the dÃ¦mon is running.  If not, start it in the      * background */
name|start_daemon
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
comment|/* we have a command on the line */
if|if
condition|(
name|setjmp
argument_list|(
name|command_fail
argument_list|)
operator|!=
literal|0
condition|)
comment|/* long jumped out */
return|return
operator|-
literal|1
return|;
name|parseline
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
operator|&
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* do it */
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* ugh */
name|char
modifier|*
name|c
decl_stmt|;
name|setjmp
argument_list|(
name|command_fail
argument_list|)
expr_stmt|;
comment|/* come back here on catastrophic failure */
name|c
operator|=
name|readline
argument_list|(
literal|"vinum -> "
argument_list|)
expr_stmt|;
comment|/* get an input */
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
comment|/* EOF or error */
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read input: %s (%d)\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* EOF */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|c
condition|)
block|{
comment|/* got something there */
name|add_history
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* save it in the history */
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* put it where we can munge it */
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|line
operator|++
expr_stmt|;
comment|/* count the lines */
name|tokens
operator|=
name|tokenize
argument_list|(
name|buffer
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* got something potentially worth parsing */
if|if
condition|(
name|tokens
condition|)
name|parseline
argument_list|(
name|tokens
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* and do what he says */
block|}
block|}
block|}
return|return
literal|0
return|;
comment|/* normal completion */
block|}
end_function

begin_comment
comment|/* stop the hard way */
end_comment

begin_function
name|void
name|vinum_quit
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|char
modifier|*
name|argv0
index|[]
parameter_list|)
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|FUNKEY
parameter_list|(
name|x
parameter_list|)
value|{ kw_##x,&vinum_##x }
end_define

begin_comment
comment|/* create pair "kw_foo", vinum_foo */
end_comment

begin_struct
struct|struct
name|funkey
block|{
name|enum
name|keyword
name|kw
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|char
modifier|*
name|arg0
index|[]
parameter_list|)
function_decl|;
block|}
name|funkeys
index|[]
init|=
block|{
name|FUNKEY
argument_list|(
name|create
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|read
argument_list|)
block|,
ifdef|#
directive|ifdef
name|VINUMDEBUG
name|FUNKEY
argument_list|(
name|debug
argument_list|)
block|,
endif|#
directive|endif
name|FUNKEY
argument_list|(
name|volume
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|plex
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|sd
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|drive
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|modify
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|list
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|ld
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|ls
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|lp
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|lv
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|info
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|set
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|init
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|label
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|resetconfig
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|rm
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|attach
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|detach
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|rename
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|replace
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|printconfig
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|start
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|stop
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|makedev
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|help
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|quit
argument_list|)
block|,
name|FUNKEY
argument_list|(
name|setdaemon
argument_list|)
block|,
name|FUNKEY
argument_list|(
argument|resetstats
argument_list|)
block|}
struct|;
end_struct

begin_comment
comment|/* Take args arguments at argv and attempt to perform the operation specified */
end_comment

begin_function
name|void
name|parseline
parameter_list|(
name|int
name|args
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|enum
name|keyword
name|command
decl_stmt|;
comment|/* command to execute */
if|if
condition|(
operator|(
name|args
operator|==
literal|0
operator|)
comment|/* empty line */
operator|||
operator|(
operator|*
name|argv
index|[
literal|0
index|]
operator|==
literal|'#'
operator|)
condition|)
comment|/* or a comment, */
return|return;
if|if
condition|(
name|args
operator|==
name|MAXARGS
condition|)
block|{
comment|/* too many arguments, */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many arguments to %s, this can't be right\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|command
operator|=
name|get_keyword
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|keyword_set
argument_list|)
expr_stmt|;
name|force
operator|=
literal|0
expr_stmt|;
comment|/* initialize flags */
name|verbose
operator|=
literal|0
expr_stmt|;
comment|/* initialize flags */
name|Verbose
operator|=
literal|0
expr_stmt|;
comment|/* initialize flags */
name|recurse
operator|=
literal|0
expr_stmt|;
comment|/* initialize flags */
name|stats
operator|=
literal|0
expr_stmt|;
comment|/* initialize flags */
comment|/* First handle generic options */
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|i
operator|<
name|args
operator|)
operator|&&
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* while we have flags */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
block|{
if|#
directive|if
name|VINUMDEBUG
case|case
literal|'d'
case|:
comment|/* -d: debug */
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'f'
case|:
comment|/* -f: force */
name|force
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* -v: verbose */
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* -V: Very verbose */
name|verbose
operator|++
expr_stmt|;
name|Verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* -r: recurse */
name|recurse
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* -s: show statistics */
name|stats
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid flag: %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Pass what we have left to the command to handle it */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|funkeys
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|funkey
argument_list|)
operator|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|funkeys
index|[
name|j
index|]
operator|.
name|kw
operator|==
name|command
condition|)
block|{
comment|/* found the command */
name|funkeys
index|[
name|j
index|]
operator|.
name|fun
argument_list|(
name|args
operator|-
name|i
argument_list|,
operator|&
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown command: %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|get_drive_info
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|,
name|int
name|index
parameter_list|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|drive
operator|=
name|index
expr_stmt|;
comment|/* put in drive to hand to driver */
if|if
condition|(
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_DRIVECONFIG
argument_list|,
name|drive
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get config for drive %d: %s\n"
argument_list|,
name|index
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|command_fail
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|get_sd_info
parameter_list|(
name|struct
name|sd
modifier|*
name|sd
parameter_list|,
name|int
name|index
parameter_list|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|sd
operator|=
name|index
expr_stmt|;
comment|/* put in sd to hand to driver */
if|if
condition|(
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_SDCONFIG
argument_list|,
name|sd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get config for subdisk %d: %s\n"
argument_list|,
name|index
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|command_fail
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get the contents of the sd entry for subdisk<sdno>  * of the specified plex. */
end_comment

begin_function
name|void
name|get_plex_sd_info
parameter_list|(
name|struct
name|sd
modifier|*
name|sd
parameter_list|,
name|int
name|plexno
parameter_list|,
name|int
name|sdno
parameter_list|)
block|{
operator|(
operator|(
name|int
operator|*
operator|)
name|sd
operator|)
index|[
literal|0
index|]
operator|=
name|plexno
expr_stmt|;
operator|(
operator|(
name|int
operator|*
operator|)
name|sd
operator|)
index|[
literal|1
index|]
operator|=
name|sdno
expr_stmt|;
comment|/* pass parameters */
if|if
condition|(
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_PLEXSDCONFIG
argument_list|,
name|sd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get config for subdisk %d (part of plex %d): %s\n"
argument_list|,
name|sdno
argument_list|,
name|plexno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|command_fail
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|get_plex_info
parameter_list|(
name|struct
name|plex
modifier|*
name|plex
parameter_list|,
name|int
name|index
parameter_list|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|plex
operator|=
name|index
expr_stmt|;
comment|/* put in plex to hand to driver */
if|if
condition|(
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_PLEXCONFIG
argument_list|,
name|plex
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get config for plex %d: %s\n"
argument_list|,
name|index
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|command_fail
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|get_volume_info
parameter_list|(
name|struct
name|volume
modifier|*
name|volume
parameter_list|,
name|int
name|index
parameter_list|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|volume
operator|=
name|index
expr_stmt|;
comment|/* put in volume to hand to driver */
if|if
condition|(
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_VOLCONFIG
argument_list|,
name|volume
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get config for volume %d: %s\n"
argument_list|,
name|index
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|command_fail
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create the device nodes for vinum objects */
end_comment

begin_function
name|void
name|make_devices
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|volno
decl_stmt|;
name|int
name|plexno
decl_stmt|;
name|int
name|sdno
decl_stmt|;
name|int
name|driveno
decl_stmt|;
name|char
name|filename
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* for forming file names */
if|if
condition|(
name|superdev
operator|>=
literal|0
condition|)
comment|/* super device open */
name|close
argument_list|(
name|superdev
argument_list|)
expr_stmt|;
name|system
argument_list|(
literal|"rm -rf "
name|VINUM_DIR
literal|" "
name|VINUM_RDIR
argument_list|)
expr_stmt|;
comment|/* remove the old directories */
name|system
argument_list|(
literal|"mkdir -p "
name|VINUM_DIR
literal|"/drive "
comment|/* and make them again */
name|VINUM_DIR
literal|"/plex "
name|VINUM_DIR
literal|"/sd "
name|VINUM_DIR
literal|"/rsd "
name|VINUM_DIR
literal|"/vol "
name|VINUM_DIR
literal|"/rvol "
name|VINUM_RDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|VINUM_SUPERDEV_NAME
argument_list|,
name|S_IRWXU
operator||
name|S_IFBLK
argument_list|,
comment|/* block device, user only */
name|VINUM_SUPERDEV
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|VINUM_SUPERDEV_NAME
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|superdev
operator|=
name|open
argument_list|(
name|VINUM_SUPERDEV_NAME
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
comment|/* open the super device */
if|if
condition|(
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_GETCONFIG
argument_list|,
operator|&
name|vinum_conf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Can't get vinum config"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* First, create directories for the volumes */
for|for
control|(
name|volno
operator|=
literal|0
init|;
name|volno
operator|<
name|vinum_conf
operator|.
name|volumes_used
condition|;
name|volno
operator|++
control|)
block|{
name|dev_t
name|voldev
decl_stmt|;
name|dev_t
name|rvoldev
decl_stmt|;
name|get_volume_info
argument_list|(
operator|&
name|vol
argument_list|,
name|volno
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|.
name|state
operator|!=
name|volume_unallocated
condition|)
block|{
comment|/* we could have holes in our lists */
name|voldev
operator|=
name|VINUMBDEV
argument_list|(
name|volno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|VINUM_VOLUME_TYPE
argument_list|)
expr_stmt|;
comment|/* create a block device number */
name|rvoldev
operator|=
name|VINUMCDEV
argument_list|(
name|volno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|VINUM_VOLUME_TYPE
argument_list|)
expr_stmt|;
comment|/* and a character device */
comment|/* Create /dev/vinum/<myvol> */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/%s"
argument_list|,
name|vol
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|filename
argument_list|,
name|S_IRWXU
operator||
name|S_IRGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IFBLK
argument_list|,
name|voldev
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create /dev/rvinum/<myvol> */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_RDIR
literal|"/%s"
argument_list|,
name|vol
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|filename
argument_list|,
name|S_IRWXU
operator||
name|S_IRGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IFCHR
argument_list|,
name|rvoldev
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create /dev/vinum/r<myvol> XXX until we fix fsck and friends */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/r%s"
argument_list|,
name|vol
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|filename
argument_list|,
name|S_IRWXU
operator||
name|S_IRGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IFCHR
argument_list|,
name|rvoldev
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create /dev/vinum/vol/<myvol> */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/vol/%s"
argument_list|,
name|vol
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|filename
argument_list|,
name|S_IRWXU
operator||
name|S_IRGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IFBLK
argument_list|,
name|voldev
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create /dev/vinum/rvol/<myvol> */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/rvol/%s"
argument_list|,
name|vol
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|filename
argument_list|,
name|S_IRWXU
operator||
name|S_IRGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IFCHR
argument_list|,
name|rvoldev
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create /dev/vinum/vol/<myvol>.plex/ */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/vol/%s.plex"
argument_list|,
name|vol
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|filename
argument_list|,
name|S_IRWXU
operator||
name|S_IRGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IXOTH
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now create device entries for the plexes in 	     * /dev/vinum/<vol>.plex/ and /dev/vinum/plex */
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vol
operator|.
name|plexes
condition|;
name|plexno
operator|++
control|)
block|{
name|dev_t
name|plexdev
decl_stmt|;
name|get_plex_info
argument_list|(
operator|&
name|plex
argument_list|,
name|vol
operator|.
name|plex
index|[
name|plexno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|plex
operator|.
name|state
operator|!=
name|plex_unallocated
condition|)
block|{
name|plexdev
operator|=
name|VINUMBDEV
argument_list|(
name|volno
argument_list|,
name|plexno
argument_list|,
literal|0
argument_list|,
name|VINUM_PLEX_TYPE
argument_list|)
expr_stmt|;
comment|/* Create device /dev/vinum/vol/<vol>.plex/<plex> */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/vol/%s.plex/%s"
argument_list|,
name|vol
operator|.
name|name
argument_list|,
name|plex
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|filename
argument_list|,
name|S_IRWXU
operator||
name|S_IRGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IFBLK
argument_list|,
name|plexdev
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And /dev/vinum/plex/<plex> */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/plex/%s"
argument_list|,
name|plex
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|filename
argument_list|,
name|S_IRWXU
operator||
name|S_IRGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IFBLK
argument_list|,
name|plexdev
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create directory /dev/vinum/vol/<vol>.plex/<plex>.sd */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/vol/%s.plex/%s.sd"
argument_list|,
name|vol
operator|.
name|name
argument_list|,
name|plex
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|filename
argument_list|,
name|S_IRWXU
operator||
name|S_IRGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IXOTH
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the contents of /dev/vinum/<vol>.plex/<plex>.sd */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|.
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
name|dev_t
name|sddev
decl_stmt|;
name|get_plex_sd_info
argument_list|(
operator|&
name|sd
argument_list|,
name|vol
operator|.
name|plex
index|[
name|plexno
index|]
argument_list|,
name|sdno
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|.
name|state
operator|!=
name|sd_unallocated
condition|)
block|{
name|sddev
operator|=
name|VINUMBDEV
argument_list|(
name|volno
argument_list|,
name|plexno
argument_list|,
name|sdno
argument_list|,
name|VINUM_SD_TYPE
argument_list|)
expr_stmt|;
comment|/* Create /dev/vinum/vol/<vol>.plex/<plex>.sd/<sd> */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/vol/%s.plex/%s.sd/%s"
argument_list|,
name|vol
operator|.
name|name
argument_list|,
name|plex
operator|.
name|name
argument_list|,
name|sd
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|filename
argument_list|,
name|S_IRWXU
operator||
name|S_IRGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IFBLK
argument_list|,
name|sddev
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* /dev/vinum/sd/<sd> */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/sd/%s"
argument_list|,
name|sd
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|filename
argument_list|,
name|S_IRWXU
operator||
name|S_IRGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IFBLK
argument_list|,
name|sddev
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And /dev/vinum/rsd/<sd> */
name|sprintf
argument_list|(
name|filename
argument_list|,
name|VINUM_DIR
literal|"/rsd/%s"
argument_list|,
name|sd
operator|.
name|name
argument_list|)
expr_stmt|;
name|sddev
operator|=
name|VINUMCDEV
argument_list|(
name|volno
argument_list|,
name|plexno
argument_list|,
name|sdno
argument_list|,
name|VINUM_SD_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|filename
argument_list|,
name|S_IRWXU
operator||
name|S_IRGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IFCHR
argument_list|,
name|sddev
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* Drives.  Do this later (both logical and physical names) XXX */
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|vinum_conf
operator|.
name|drives_used
condition|;
name|driveno
operator|++
control|)
block|{
name|get_drive_info
argument_list|(
operator|&
name|drive
argument_list|,
name|driveno
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive
operator|.
name|state
operator|!=
name|drive_unallocated
condition|)
block|{
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"ln -s %s "
name|VINUM_DIR
literal|"/drive/%s"
argument_list|,
name|drive
operator|.
name|devicename
argument_list|,
name|drive
operator|.
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* command line interface for the 'makedev' command */
end_comment

begin_function
name|void
name|vinum_makedev
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|char
modifier|*
name|arg0
index|[]
parameter_list|)
block|{
name|make_devices
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the object "name".  Return object type at type,  * and the index as the return value.  * If not found, return -1 and invalid_object.  */
end_comment

begin_function
name|int
name|find_object
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|objecttype
modifier|*
name|type
parameter_list|)
block|{
name|int
name|object
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_GETCONFIG
argument_list|,
operator|&
name|vinum_conf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Can't get vinum config"
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|invalid_object
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Search the drive table */
for|for
control|(
name|object
operator|=
literal|0
init|;
name|object
operator|<
name|vinum_conf
operator|.
name|drives_used
condition|;
name|object
operator|++
control|)
block|{
name|get_drive_info
argument_list|(
operator|&
name|drive
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|drive
operator|.
name|label
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|type
operator|=
name|drive_object
expr_stmt|;
return|return
name|object
return|;
block|}
block|}
comment|/* Search the subdisk table */
for|for
control|(
name|object
operator|=
literal|0
init|;
name|object
operator|<
name|vinum_conf
operator|.
name|subdisks_used
condition|;
name|object
operator|++
control|)
block|{
name|get_sd_info
argument_list|(
operator|&
name|sd
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|sd
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|type
operator|=
name|sd_object
expr_stmt|;
return|return
name|object
return|;
block|}
block|}
comment|/* Search the plex table */
for|for
control|(
name|object
operator|=
literal|0
init|;
name|object
operator|<
name|vinum_conf
operator|.
name|plexes_used
condition|;
name|object
operator|++
control|)
block|{
name|get_plex_info
argument_list|(
operator|&
name|plex
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|plex
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|type
operator|=
name|plex_object
expr_stmt|;
return|return
name|object
return|;
block|}
block|}
comment|/* Search the volume table */
for|for
control|(
name|object
operator|=
literal|0
init|;
name|object
operator|<
name|vinum_conf
operator|.
name|volumes_used
condition|;
name|object
operator|++
control|)
block|{
name|get_volume_info
argument_list|(
operator|&
name|vol
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|vol
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|type
operator|=
name|volume_object
expr_stmt|;
return|return
name|object
return|;
block|}
block|}
comment|/* Didn't find the name: invalid */
operator|*
name|type
operator|=
name|invalid_object
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Continue reviving a subdisk in the background */
end_comment

begin_function
name|void
name|continue_revive
parameter_list|(
name|int
name|sdno
parameter_list|)
block|{
name|struct
name|sd
name|sd
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|get_sd_info
argument_list|(
operator|&
name|sd
argument_list|,
name|sdno
argument_list|)
expr_stmt|;
if|#
directive|if
name|VINUMDEBUG
if|if
condition|(
name|debug
condition|)
name|pid
operator|=
literal|0
expr_stmt|;
comment|/* wander through into the "child" process */
else|else
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
comment|/* do this in the background */
else|#
directive|else
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
comment|/* do this in the background */
endif|#
directive|endif
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* we're the child */
name|struct
name|_ioctl_reply
name|reply
decl_stmt|;
name|struct
name|vinum_ioctl_msg
modifier|*
name|message
init|=
operator|(
expr|struct
name|vinum_ioctl_msg
operator|*
operator|)
operator|&
name|reply
decl_stmt|;
name|openlog
argument_list|(
literal|"vinum"
argument_list|,
name|LOG_CONS
operator||
name|LOG_PERROR
operator||
name|LOG_PID
argument_list|,
name|LOG_KERN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
operator||
name|LOG_KERN
argument_list|,
literal|"reviving %s"
argument_list|,
name|sd
operator|.
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|reply
operator|.
name|error
operator|=
name|EAGAIN
init|;
name|reply
operator|.
name|error
operator|==
name|EAGAIN
condition|;
control|)
block|{
name|message
operator|->
name|index
operator|=
name|sdno
expr_stmt|;
comment|/* pass sd number */
name|message
operator|->
name|type
operator|=
name|sd_object
expr_stmt|;
comment|/* and type of object */
name|message
operator|->
name|state
operator|=
name|object_up
expr_stmt|;
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_SETSTATE
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reply
operator|.
name|error
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
operator||
name|LOG_KERN
argument_list|,
literal|"can't revive %s: %s"
argument_list|,
name|sd
operator|.
name|name
argument_list|,
name|reply
operator|.
name|msg
index|[
literal|0
index|]
condition|?
name|reply
operator|.
name|msg
else|:
name|strerror
argument_list|(
name|reply
operator|.
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|get_sd_info
argument_list|(
operator|&
name|sd
argument_list|,
name|sdno
argument_list|)
expr_stmt|;
comment|/* update the info */
name|syslog
argument_list|(
name|LOG_INFO
operator||
name|LOG_KERN
argument_list|,
literal|"%s is %s"
argument_list|,
name|sd
operator|.
name|name
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
comment|/* couldn't fork? */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't continue reviving %s: %s\n"
argument_list|,
name|sd
operator|.
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Reviving %s in the background\n"
argument_list|,
name|sd
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check if the daemon is running,  * start it if it isn't.  The check itself  * could take a while, so we do it as a separate  * process, which will become the daemon if one isn't  * running already */
end_comment

begin_function
name|void
name|start_daemon
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pid
operator|=
operator|(
name|int
operator|)
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* We're the child, do the work */
name|error
operator|=
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* this will fork again, but who's counting? */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't start daemon: %s (%d)\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|setproctitle
argument_list|(
literal|"Vinum daemon"
argument_list|)
expr_stmt|;
comment|/* show what we're doing */
name|status
operator|=
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_FINDDAEMON
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
comment|/* no daemon, */
name|ioctl
argument_list|(
name|superdev
argument_list|,
name|VINUM_DAEMON
argument_list|,
operator|&
name|verbose
argument_list|)
expr_stmt|;
comment|/* we should hang here */
name|syslog
argument_list|(
name|LOG_ERR
operator||
name|LOG_KERN
argument_list|,
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* when told to die */
block|}
elseif|else
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
comment|/* couldn't fork */
name|printf
argument_list|(
literal|"Can't fork to check daemon\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

