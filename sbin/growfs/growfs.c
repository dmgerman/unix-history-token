begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000 Christoph Herrmann, Thomas-Henning von Kamptz  * Copyright (c) 1980, 1989, 1993 The Regents of the University of California.  * All rights reserved.  *   * This code is derived from software contributed to Berkeley by  * Christoph Herrmann and Thomas-Henning von Kamptz, Munich and Frankfurt.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors, as well as Christoph  *      Herrmann and Thomas-Henning von Kamptz.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $TSHeader: src/sbin/growfs/growfs.c,v 1.5 2000/12/12 19:31:00 tomsoft Exp $  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 2000 Christoph Herrmann, Thomas-Henning von Kamptz\n\ Copyright (c) 1980, 1989, 1993 The Regents of the University of California.\n\ All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* ********************************************************** INCLUDES ***** */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_comment
comment|/* *************************************************** GLOBALS& TYPES ***** */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FS_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|_dbg_lvl_
init|=
operator|(
name|DL_INFO
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DL_TRC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FS_DEBUG */
end_comment

begin_union
specifier|static
union|union
block|{
name|struct
name|fs
name|fs
decl_stmt|;
name|char
name|pad
index|[
name|SBSIZE
index|]
decl_stmt|;
block|}
name|fsun1
union|,
name|fsun2
union|;
end_union

begin_define
define|#
directive|define
name|sblock
value|fsun1.fs
end_define

begin_comment
comment|/* the new superblock */
end_comment

begin_define
define|#
directive|define
name|osblock
value|fsun2.fs
end_define

begin_comment
comment|/* the old superblock */
end_comment

begin_union
specifier|static
union|union
block|{
name|struct
name|cg
name|cg
decl_stmt|;
name|char
name|pad
index|[
name|MAXBSIZE
index|]
decl_stmt|;
block|}
name|cgun1
union|,
name|cgun2
union|;
end_union

begin_define
define|#
directive|define
name|acg
value|cgun1.cg
end_define

begin_comment
comment|/* a cylinder cgroup (new) */
end_comment

begin_define
define|#
directive|define
name|aocg
value|cgun2.cg
end_define

begin_comment
comment|/* an old cylinder group */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ablk
index|[
name|MAXBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a block */
end_comment

begin_decl_stmt
specifier|static
name|char
name|i1blk
index|[
name|MAXBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* some indirect blocks */
end_comment

begin_decl_stmt
specifier|static
name|char
name|i2blk
index|[
name|MAXBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|i3blk
index|[
name|MAXBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where to write back updated blocks */
end_comment

begin_decl_stmt
specifier|static
name|daddr_t
name|in_src
decl_stmt|,
name|i1_src
decl_stmt|,
name|i2_src
decl_stmt|,
name|i3_src
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* what object contains the reference */
end_comment

begin_enum
enum|enum
name|pointer_source
block|{
name|GFS_PS_INODE
block|,
name|GFS_PS_IND_BLK_LVL1
block|,
name|GFS_PS_IND_BLK_LVL2
block|,
name|GFS_PS_IND_BLK_LVL3
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|struct
name|csum
modifier|*
name|fscs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cylinder summary */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dinode
name|zino
index|[
name|MAXBSIZE
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* some inodes */
end_comment

begin_comment
comment|/*  * An  array of elements of type struct gfs_bpp describes all blocks  to  * be relocated in order to free the space needed for the cylinder group  * summary for all cylinder groups located in the first cylinder group.  */
end_comment

begin_struct
struct|struct
name|gfs_bpp
block|{
name|daddr_t
name|old
decl_stmt|;
comment|/* old block number */
name|daddr_t
name|new
decl_stmt|;
comment|/* new block number */
define|#
directive|define
name|GFS_FL_FIRST
value|1
define|#
directive|define
name|GFS_FL_LAST
value|2
name|unsigned
name|int
name|flags
decl_stmt|;
comment|/* special handling required */
name|int
name|found
decl_stmt|;
comment|/* how many references were updated */
block|}
struct|;
end_struct

begin_comment
comment|/* ******************************************************** PROTOTYPES ***** */
end_comment

begin_function_decl
specifier|static
name|void
name|growfs
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdfs
parameter_list|(
name|daddr_t
parameter_list|,
name|size_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wtfs
parameter_list|(
name|daddr_t
parameter_list|,
name|size_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|daddr_t
name|alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|charsperline
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isblock
parameter_list|(
name|struct
name|fs
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clrblock
parameter_list|(
name|struct
name|fs
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setblock
parameter_list|(
name|struct
name|fs
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initcg
parameter_list|(
name|int
parameter_list|,
name|time_t
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|updjcg
parameter_list|(
name|int
parameter_list|,
name|time_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|updcsloc
parameter_list|(
name|time_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|disklabel
modifier|*
name|get_disklabel
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|return_disklabel
parameter_list|(
name|int
parameter_list|,
name|struct
name|disklabel
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|dinode
modifier|*
name|ginode
parameter_list|(
name|ino_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|frag_adjust
parameter_list|(
name|daddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cond_bl_upd
parameter_list|(
name|ufs_daddr_t
modifier|*
parameter_list|,
name|struct
name|gfs_bpp
modifier|*
parameter_list|,
name|enum
name|pointer_source
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|updclst
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|updrefs
parameter_list|(
name|int
parameter_list|,
name|ino_t
parameter_list|,
name|struct
name|gfs_bpp
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ************************************************************ growfs ***** */
end_comment

begin_comment
comment|/*  * Here  we actually start growing the filesystem. We basically  read  the  * cylinder  summary  from the first cylinder group as we want  to  update  * this  on  the fly during our various operations. First  we  handle  the  * changes in the former last cylinder group. Afterwards we create all new  * cylinder  groups.  Now  we handle the  cylinder  group  containing  the  * cylinder  summary  which  might result in a  relocation  of  the  whole  * structure.  In the end we write back the updated cylinder summary,  the  * new superblock, and slightly patched versions of the super block  * copies.  */
end_comment

begin_function
specifier|static
name|void
name|growfs
parameter_list|(
name|int
name|fsi
parameter_list|,
name|int
name|fso
parameter_list|,
name|unsigned
name|int
name|Nflag
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"growfs"
argument_list|)
name|int
name|i
decl_stmt|;
name|int
name|cylno
decl_stmt|,
name|j
decl_stmt|;
name|time_t
name|utime
decl_stmt|;
name|int
name|width
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|100
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|FSIRAND
specifier|static
name|int
name|randinit
init|=
literal|0
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
if|if
condition|(
operator|!
name|randinit
condition|)
block|{
name|randinit
operator|=
literal|1
expr_stmt|;
name|srandomdev
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
comment|/* not FSIRAND */
name|DBG_ENTER
expr_stmt|;
endif|#
directive|endif
comment|/* FSIRAND */
name|time
argument_list|(
operator|&
name|utime
argument_list|)
expr_stmt|;
comment|/* 	 * Get the cylinder summary into the memory. 	 */
name|fscs
operator|=
operator|(
expr|struct
name|csum
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_cssize
argument_list|)
expr_stmt|;
if|if
condition|(
name|fscs
operator|==
name|NULL
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|osblock
operator|.
name|fs_cssize
condition|;
name|i
operator|+=
name|osblock
operator|.
name|fs_bsize
control|)
block|{
name|rdfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|osblock
argument_list|,
name|osblock
operator|.
name|fs_csaddr
operator|+
name|numfrags
argument_list|(
operator|&
name|osblock
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|MIN
argument_list|(
name|osblock
operator|.
name|fs_cssize
operator|-
name|i
argument_list|,
name|osblock
operator|.
name|fs_bsize
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|fscs
operator|)
operator|+
name|i
operator|)
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FS_DEBUG
block|{
name|struct
name|csum
modifier|*
name|dbg_csp
decl_stmt|;
name|int
name|dbg_csc
decl_stmt|;
name|char
name|dbg_line
index|[
literal|80
index|]
decl_stmt|;
name|dbg_csp
operator|=
name|fscs
expr_stmt|;
for|for
control|(
name|dbg_csc
operator|=
literal|0
init|;
name|dbg_csc
operator|<
name|osblock
operator|.
name|fs_ncg
condition|;
name|dbg_csc
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|dbg_line
argument_list|,
sizeof|sizeof
argument_list|(
name|dbg_line
argument_list|)
argument_list|,
literal|"%d. old csum in old location"
argument_list|,
name|dbg_csc
argument_list|)
expr_stmt|;
name|DBG_DUMP_CSUM
argument_list|(
operator|&
name|osblock
argument_list|,
name|dbg_line
argument_list|,
name|dbg_csp
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* FS_DEBUG */
name|DBG_PRINT0
argument_list|(
literal|"fscs read\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Do all needed changes in the former last cylinder group. 	 */
name|updjcg
argument_list|(
name|osblock
operator|.
name|fs_ncg
operator|-
literal|1
argument_list|,
name|utime
argument_list|,
name|fsi
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
comment|/* 	 * Dump out summary information about file system. 	 */
name|printf
argument_list|(
literal|"growfs:\t%d sectors in %d %s of %d tracks, %d sectors\n"
argument_list|,
name|sblock
operator|.
name|fs_size
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_ncyl
argument_list|,
literal|"cylinders"
argument_list|,
name|sblock
operator|.
name|fs_ntrak
argument_list|,
name|sblock
operator|.
name|fs_nsect
argument_list|)
expr_stmt|;
define|#
directive|define
name|B2MBFACTOR
value|(1 / (1024.0 * 1024.0))
name|printf
argument_list|(
literal|"\t%.1fMB in %d cyl groups (%d c/g, %.2fMB/g, %d i/g)\n"
argument_list|,
operator|(
name|float
operator|)
name|sblock
operator|.
name|fs_size
operator|*
name|sblock
operator|.
name|fs_fsize
operator|*
name|B2MBFACTOR
argument_list|,
name|sblock
operator|.
name|fs_ncg
argument_list|,
name|sblock
operator|.
name|fs_cpg
argument_list|,
operator|(
name|float
operator|)
name|sblock
operator|.
name|fs_fpg
operator|*
name|sblock
operator|.
name|fs_fsize
operator|*
name|B2MBFACTOR
argument_list|,
name|sblock
operator|.
name|fs_ipg
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|B2MBFACTOR
comment|/* 	 * Now build the cylinders group blocks and 	 * then print out indices of cylinder groups. 	 */
name|printf
argument_list|(
literal|"super-block backups (for fsck -b #) at:\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|width
operator|=
name|charsperline
argument_list|()
expr_stmt|;
comment|/* 	 * Iterate for only the new cylinder groups. 	 */
for|for
control|(
name|cylno
operator|=
name|osblock
operator|.
name|fs_ncg
init|;
name|cylno
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|cylno
operator|++
control|)
block|{
name|initcg
argument_list|(
name|cylno
argument_list|,
name|utime
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|j
operator|=
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|" %d%s"
argument_list|,
operator|(
name|int
operator|)
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
argument_list|,
name|cylno
operator|<
operator|(
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
operator|)
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|j
operator|>=
name|width
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|+=
name|j
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Do all needed changes in the first cylinder group. 	 * allocate blocks in new location 	 */
name|updcsloc
argument_list|(
name|utime
argument_list|,
name|fsi
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
comment|/* 	 * Now write the cylinder summary back to disk. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_cssize
condition|;
name|i
operator|+=
name|sblock
operator|.
name|fs_bsize
control|)
block|{
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_csaddr
operator|+
name|numfrags
argument_list|(
operator|&
name|sblock
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|MIN
argument_list|(
name|sblock
operator|.
name|fs_cssize
operator|-
name|i
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|fscs
operator|)
operator|+
name|i
operator|)
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
block|}
name|DBG_PRINT0
argument_list|(
literal|"fscs written\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FS_DEBUG
block|{
name|struct
name|csum
modifier|*
name|dbg_csp
decl_stmt|;
name|int
name|dbg_csc
decl_stmt|;
name|char
name|dbg_line
index|[
literal|80
index|]
decl_stmt|;
name|dbg_csp
operator|=
name|fscs
expr_stmt|;
for|for
control|(
name|dbg_csc
operator|=
literal|0
init|;
name|dbg_csc
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|dbg_csc
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|dbg_line
argument_list|,
sizeof|sizeof
argument_list|(
name|dbg_line
argument_list|)
argument_list|,
literal|"%d. new csum in new location"
argument_list|,
name|dbg_csc
argument_list|)
expr_stmt|;
name|DBG_DUMP_CSUM
argument_list|(
operator|&
name|sblock
argument_list|,
name|dbg_line
argument_list|,
name|dbg_csp
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* FS_DEBUG */
comment|/* 	 * Now write the new superblock back to disk. 	 */
name|sblock
operator|.
name|fs_time
operator|=
name|utime
expr_stmt|;
name|wtfs
argument_list|(
call|(
name|daddr_t
call|)
argument_list|(
name|SBOFF
operator|/
name|DEV_BSIZE
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|SBSIZE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sblock
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"sblock written\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_FS
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"new initial sblock"
argument_list|)
expr_stmt|;
comment|/* 	 * Clean up the dynamic fields in our superblock copies. 	 */
name|sblock
operator|.
name|fs_fmod
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_clean
operator|=
literal|1
expr_stmt|;
name|sblock
operator|.
name|fs_ronly
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_cgrotor
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_state
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|sblock
operator|.
name|fs_fsmnt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sblock
operator|.
name|fs_fsmnt
argument_list|)
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_flags
operator|&=
name|FS_DOSOFTDEP
expr_stmt|;
comment|/* 	 * XXX 	 * The following fields are currently distributed from the  superblock 	 * to the copies: 	 *     fs_minfree 	 *     fs_rotdelay 	 *     fs_maxcontig 	 *     fs_maxbpg 	 *     fs_minfree, 	 *     fs_optim 	 *     fs_flags regarding SOFTPDATES 	 * 	 * We probably should rather change the summary for the cylinder group 	 * statistics here to the value of what would be in there, if the file 	 * system were created initially with the new size. Therefor we  still 	 * need to find an easy way of calculating that. 	 * Possibly we can try to read the first superblock copy and apply the 	 * "diffed" stats between the old and new superblock by still  copying 	 * certain parameters onto that. 	 */
comment|/* 	 * Write out the duplicate super blocks. 	 */
for|for
control|(
name|cylno
operator|=
literal|0
init|;
name|cylno
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|cylno
operator|++
control|)
block|{
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|SBSIZE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sblock
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
block|}
name|DBG_PRINT0
argument_list|(
literal|"sblock copies written\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_FS
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"new other sblocks"
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************ initcg ***** */
end_comment

begin_comment
comment|/*  * This creates a new cylinder group structure, for more details please  see  * the  source of newfs(8), as this function is taken over almost unchanged.  * As  this  is  never called for the  first  cylinder  group,  the  special  * provisions for that case are removed here.  */
end_comment

begin_function
specifier|static
name|void
name|initcg
parameter_list|(
name|int
name|cylno
parameter_list|,
name|time_t
name|utime
parameter_list|,
name|int
name|fso
parameter_list|,
name|unsigned
name|int
name|Nflag
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"initcg"
argument_list|)
name|daddr_t
name|cbase
decl_stmt|,
name|d
decl_stmt|,
name|dlower
decl_stmt|,
name|dupper
decl_stmt|,
name|dmax
decl_stmt|,
name|blkno
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|csum
modifier|*
name|cs
decl_stmt|;
ifdef|#
directive|ifdef
name|FSIRAND
name|int
name|j
decl_stmt|;
endif|#
directive|endif
name|DBG_ENTER
expr_stmt|;
comment|/* 	 * Determine block bounds for cylinder group. 	 */
name|cbase
operator|=
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
expr_stmt|;
name|dmax
operator|=
name|cbase
operator|+
name|sblock
operator|.
name|fs_fpg
expr_stmt|;
if|if
condition|(
name|dmax
operator|>
name|sblock
operator|.
name|fs_size
condition|)
block|{
name|dmax
operator|=
name|sblock
operator|.
name|fs_size
expr_stmt|;
block|}
name|dlower
operator|=
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
operator|-
name|cbase
expr_stmt|;
name|dupper
operator|=
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
operator|-
name|cbase
expr_stmt|;
if|if
condition|(
name|cylno
operator|==
literal|0
condition|)
block|{
comment|/* XXX fscs may be relocated */
name|dupper
operator|+=
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
block|}
name|cs
operator|=
name|fscs
operator|+
name|cylno
expr_stmt|;
name|memset
argument_list|(
operator|&
name|acg
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_cgsize
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_time
operator|=
name|utime
expr_stmt|;
name|acg
operator|.
name|cg_magic
operator|=
name|CG_MAGIC
expr_stmt|;
name|acg
operator|.
name|cg_cgx
operator|=
name|cylno
expr_stmt|;
if|if
condition|(
name|cylno
operator|==
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
condition|)
block|{
name|acg
operator|.
name|cg_ncyl
operator|=
name|sblock
operator|.
name|fs_ncyl
operator|%
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
block|}
else|else
block|{
name|acg
operator|.
name|cg_ncyl
operator|=
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
block|}
name|acg
operator|.
name|cg_niblk
operator|=
name|sblock
operator|.
name|fs_ipg
expr_stmt|;
name|acg
operator|.
name|cg_ndblk
operator|=
name|dmax
operator|-
name|cbase
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|acg
operator|.
name|cg_nclusterblks
operator|=
name|acg
operator|.
name|cg_ndblk
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
block|}
name|acg
operator|.
name|cg_btotoff
operator|=
operator|&
name|acg
operator|.
name|cg_space
index|[
literal|0
index|]
operator|-
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|acg
operator|.
name|cg_firstfield
operator|)
expr_stmt|;
name|acg
operator|.
name|cg_boff
operator|=
name|acg
operator|.
name|cg_btotoff
operator|+
name|sblock
operator|.
name|fs_cpg
operator|*
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_iusedoff
operator|=
name|acg
operator|.
name|cg_boff
operator|+
name|sblock
operator|.
name|fs_cpg
operator|*
name|sblock
operator|.
name|fs_nrpos
operator|*
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_freeoff
operator|=
name|acg
operator|.
name|cg_iusedoff
operator|+
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_ipg
argument_list|,
name|NBBY
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|<=
literal|0
condition|)
block|{
name|acg
operator|.
name|cg_nextfreeoff
operator|=
name|acg
operator|.
name|cg_freeoff
operator|+
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cpg
operator|*
name|sblock
operator|.
name|fs_spc
operator|/
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|,
name|NBBY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|acg
operator|.
name|cg_clustersumoff
operator|=
name|acg
operator|.
name|cg_freeoff
operator|+
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cpg
operator|*
name|sblock
operator|.
name|fs_spc
operator|/
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|,
name|NBBY
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_clustersumoff
operator|=
name|roundup
argument_list|(
name|acg
operator|.
name|cg_clustersumoff
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_clusteroff
operator|=
name|acg
operator|.
name|cg_clustersumoff
operator|+
operator|(
name|sblock
operator|.
name|fs_contigsumsize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_nextfreeoff
operator|=
name|acg
operator|.
name|cg_clusteroff
operator|+
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cpg
operator|*
name|sblock
operator|.
name|fs_spc
operator|/
name|NSPB
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|,
name|NBBY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acg
operator|.
name|cg_nextfreeoff
operator|-
call|(
name|int
call|)
argument_list|(
operator|&
name|acg
operator|.
name|cg_firstfield
argument_list|)
operator|>
name|sblock
operator|.
name|fs_cgsize
condition|)
block|{
comment|/* 		 * XXX This should never happen as we would have had that panic 		 *     already on filesystem creation 		 */
name|errx
argument_list|(
literal|37
argument_list|,
literal|"panic: cylinder group too big"
argument_list|)
expr_stmt|;
block|}
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|+=
name|sblock
operator|.
name|fs_ipg
expr_stmt|;
if|if
condition|(
name|cylno
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|ROOTINO
condition|;
name|i
operator|++
control|)
block|{
name|setbit
argument_list|(
name|cg_inosused
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|--
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_ipg
operator|/
name|INOPF
argument_list|(
operator|&
name|sblock
argument_list|)
condition|;
name|i
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
ifdef|#
directive|ifdef
name|FSIRAND
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sblock
operator|.
name|fs_bsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|zino
index|[
name|j
index|]
operator|.
name|di_gen
operator|=
name|random
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgimin
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
operator|+
name|i
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
name|void
operator|*
operator|)
name|zino
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|dlower
condition|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|blkno
operator|=
name|d
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|setblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|setbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
block|}
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|cg_blktot
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|++
expr_stmt|;
name|cg_blks
argument_list|(
operator|&
name|sblock
argument_list|,
operator|&
name|acg
argument_list|,
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
argument_list|)
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|++
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_dsize
operator|+=
name|dlower
expr_stmt|;
name|sblock
operator|.
name|fs_dsize
operator|+=
name|acg
operator|.
name|cg_ndblk
operator|-
name|dupper
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|dupper
operator|%
name|sblock
operator|.
name|fs_frag
operator|)
condition|)
block|{
name|acg
operator|.
name|cg_frsum
index|[
name|sblock
operator|.
name|fs_frag
operator|-
name|i
index|]
operator|++
expr_stmt|;
for|for
control|(
name|d
operator|=
name|dupper
operator|+
name|sblock
operator|.
name|fs_frag
operator|-
name|i
init|;
name|dupper
operator|<
name|d
condition|;
name|dupper
operator|++
control|)
block|{
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|dupper
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|d
operator|=
name|dupper
init|;
name|d
operator|+
name|sblock
operator|.
name|fs_frag
operator|<=
name|dmax
operator|-
name|cbase
condition|;
control|)
block|{
name|blkno
operator|=
name|d
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|setblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|setbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
block|}
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|cg_blktot
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|++
expr_stmt|;
name|cg_blks
argument_list|(
operator|&
name|sblock
argument_list|,
operator|&
name|acg
argument_list|,
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
argument_list|)
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|++
expr_stmt|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|<
name|dmax
operator|-
name|cbase
condition|)
block|{
name|acg
operator|.
name|cg_frsum
index|[
name|dmax
operator|-
name|cbase
operator|-
name|d
index|]
operator|++
expr_stmt|;
for|for
control|(
init|;
name|d
operator|<
name|dmax
operator|-
name|cbase
condition|;
name|d
operator|++
control|)
block|{
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|int32_t
modifier|*
name|sump
init|=
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
decl_stmt|;
name|u_char
modifier|*
name|mapp
init|=
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
decl_stmt|;
name|int
name|map
init|=
operator|*
name|mapp
operator|++
decl_stmt|;
name|int
name|bit
init|=
literal|1
decl_stmt|;
name|int
name|run
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acg
operator|.
name|cg_nclusterblks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|map
operator|&
name|bit
operator|)
operator|!=
literal|0
condition|)
block|{
name|run
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|run
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|run
operator|>
name|sblock
operator|.
name|fs_contigsumsize
condition|)
block|{
name|run
operator|=
name|sblock
operator|.
name|fs_contigsumsize
expr_stmt|;
block|}
name|sump
index|[
name|run
index|]
operator|++
expr_stmt|;
name|run
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|&
operator|(
name|NBBY
operator|-
literal|1
operator|)
operator|)
operator|!=
operator|(
name|NBBY
operator|-
literal|1
operator|)
condition|)
block|{
name|bit
operator|<<=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|map
operator|=
operator|*
name|mapp
operator|++
expr_stmt|;
name|bit
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|run
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|run
operator|>
name|sblock
operator|.
name|fs_contigsumsize
condition|)
block|{
name|run
operator|=
name|sblock
operator|.
name|fs_contigsumsize
expr_stmt|;
block|}
name|sump
index|[
name|run
index|]
operator|++
expr_stmt|;
block|}
block|}
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_ndir
operator|+=
name|acg
operator|.
name|cg_cs
operator|.
name|cs_ndir
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|+=
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|+=
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nifree
operator|+=
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nifree
expr_stmt|;
operator|*
name|cs
operator|=
name|acg
operator|.
name|cg_cs
expr_stmt|;
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|acg
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"new cg"
argument_list|,
operator|&
name|acg
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ******************************************************* frag_adjust ***** */
end_comment

begin_comment
comment|/*  * Here  we add or subtract (sign +1/-1) the available fragments in  a  given  * block to or from the fragment statistics. By subtracting before and adding  * after  an operation on the free frag map we can easy update  the  fragment  * statistic, which seems to be otherwise an rather complex operation.  */
end_comment

begin_function
specifier|static
name|void
name|frag_adjust
parameter_list|(
name|daddr_t
name|frag
parameter_list|,
name|int
name|sign
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"frag_adjust"
argument_list|)
name|int
name|fragsize
decl_stmt|;
name|int
name|f
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
name|fragsize
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Here frag only needs to point to any fragment in the block we want 	 * to examine. 	 */
for|for
control|(
name|f
operator|=
name|rounddown
argument_list|(
name|frag
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
init|;
name|f
operator|<
name|roundup
argument_list|(
name|frag
operator|+
literal|1
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
condition|;
name|f
operator|++
control|)
block|{
comment|/* 		 * Count contiguos free fragments. 		 */
if|if
condition|(
name|isset
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|fragsize
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fragsize
operator|&&
name|fragsize
operator|<
name|sblock
operator|.
name|fs_frag
condition|)
block|{
comment|/* 				 * We found something in between. 				 */
name|acg
operator|.
name|cg_frsum
index|[
name|fragsize
index|]
operator|+=
name|sign
expr_stmt|;
name|DBG_PRINT2
argument_list|(
literal|"frag_adjust [%d]+=%d\n"
argument_list|,
name|fragsize
argument_list|,
name|sign
argument_list|)
expr_stmt|;
block|}
name|fragsize
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fragsize
operator|&&
name|fragsize
operator|<
name|sblock
operator|.
name|fs_frag
condition|)
block|{
comment|/* 		 * We found something. 		 */
name|acg
operator|.
name|cg_frsum
index|[
name|fragsize
index|]
operator|+=
name|sign
expr_stmt|;
name|DBG_PRINT2
argument_list|(
literal|"frag_adjust [%d]+=%d\n"
argument_list|,
name|fragsize
argument_list|,
name|sign
argument_list|)
expr_stmt|;
block|}
name|DBG_PRINT2
argument_list|(
literal|"frag_adjust [[%d]]+=%d\n"
argument_list|,
name|fragsize
argument_list|,
name|sign
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ******************************************************* cond_bl_upd ***** */
end_comment

begin_comment
comment|/*  * Here we conditionally update a pointer to a fragment. We check for all  * relocated blocks if any of it's fragments is referenced by the current  * field,  and update the pointer to the respective fragment in  our  new  * block.  If  we find a reference we write back the  block  immediately,  * as there is no easy way for our general block reading engine to figure  * out if a write back operation is needed.  */
end_comment

begin_function
specifier|static
name|void
name|cond_bl_upd
parameter_list|(
name|ufs_daddr_t
modifier|*
name|block
parameter_list|,
name|struct
name|gfs_bpp
modifier|*
name|field
parameter_list|,
name|enum
name|pointer_source
name|source
parameter_list|,
name|int
name|fso
parameter_list|,
name|unsigned
name|int
name|Nflag
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"cond_bl_upd"
argument_list|)
name|struct
name|gfs_bpp
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|daddr_t
name|dst
init|=
literal|0
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
name|f
operator|=
name|field
expr_stmt|;
while|while
condition|(
name|f
operator|->
name|old
condition|)
block|{
comment|/* for all old blocks */
if|if
condition|(
operator|*
name|block
operator|/
name|sblock
operator|.
name|fs_frag
operator|==
name|f
operator|->
name|old
condition|)
block|{
comment|/* 			 * The fragment is part of the block, so update. 			 */
operator|*
name|block
operator|=
operator|(
name|f
operator|->
name|new
operator|*
name|sblock
operator|.
name|fs_frag
operator|+
operator|(
operator|*
name|block
operator|%
name|sblock
operator|.
name|fs_frag
operator|)
operator|)
expr_stmt|;
name|f
operator|->
name|found
operator|++
expr_stmt|;
name|DBG_PRINT3
argument_list|(
literal|"scg (%d->%d)[%d] reference updated\n"
argument_list|,
name|f
operator|->
name|old
argument_list|,
name|f
operator|->
name|new
argument_list|,
operator|*
name|block
operator|%
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
comment|/* Write the block back to disk immediately */
switch|switch
condition|(
name|source
condition|)
block|{
case|case
name|GFS_PS_INODE
case|:
name|src
operator|=
name|ablk
expr_stmt|;
name|dst
operator|=
name|in_src
expr_stmt|;
break|break;
case|case
name|GFS_PS_IND_BLK_LVL1
case|:
name|src
operator|=
name|i1blk
expr_stmt|;
name|dst
operator|=
name|i1_src
expr_stmt|;
break|break;
case|case
name|GFS_PS_IND_BLK_LVL2
case|:
name|src
operator|=
name|i2blk
expr_stmt|;
name|dst
operator|=
name|i2_src
expr_stmt|;
break|break;
case|case
name|GFS_PS_IND_BLK_LVL3
case|:
name|src
operator|=
name|i3blk
expr_stmt|;
name|dst
operator|=
name|i3_src
expr_stmt|;
break|break;
default|default:
comment|/* error */
name|src
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|src
condition|)
block|{
comment|/* 				 * XXX	If src is not of type inode we have to 				 *	implement  copy on write here in  case 				 *	of active snapshots. 				 */
name|wtfs
argument_list|(
name|dst
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
name|void
operator|*
operator|)
name|src
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * The same block can't be found again in this loop. 			 */
break|break;
block|}
name|f
operator|++
expr_stmt|;
block|}
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************ updjcg ***** */
end_comment

begin_comment
comment|/*  * Here we do all needed work for the former last cylinder group. It has to be  * changed  in  any case, even if the filesystem ended exactly on the  end  of  * this  group, as there is some slightly inconsistent handling of the  number  * of cylinders in the cylinder group. We start again by reading the  cylinder  * group from disk. If the last block was not fully available, we first handle  * the  missing  fragments, then we handle all new full blocks  in  that  file  * system  and  finally we handle the new last fragmented block  in  the  file  * system.  We again have to handle the fragment statistics rotational  layout  * tables and cluster summary during all those operations.  */
end_comment

begin_function
specifier|static
name|void
name|updjcg
parameter_list|(
name|int
name|cylno
parameter_list|,
name|time_t
name|utime
parameter_list|,
name|int
name|fsi
parameter_list|,
name|int
name|fso
parameter_list|,
name|unsigned
name|int
name|Nflag
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"updjcg"
argument_list|)
name|daddr_t
name|cbase
decl_stmt|,
name|dmax
decl_stmt|,
name|dupper
decl_stmt|;
name|struct
name|csum
modifier|*
name|cs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
comment|/* 	 * Read the former last (joining) cylinder group from disk, and make 	 * a copy. 	 */
name|rdfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|osblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|osblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|osblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|aocg
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"jcg read\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"old joining cg"
argument_list|,
operator|&
name|aocg
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|cgun1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cgun2
argument_list|,
sizeof|sizeof
argument_list|(
name|cgun2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If  the  cylinder  group had already it's  new  final  size  almost 	 * nothing is to be done ... except: 	 * For some reason the value of cg_ncyl in the last cylinder group has 	 * to  be  zero instead of fs_cpg. As this is now no longer  the  last 	 * cylinder group we have to change that value now to fs_cpg. 	 */
if|if
condition|(
name|cgbase
argument_list|(
operator|&
name|osblock
argument_list|,
name|cylno
operator|+
literal|1
argument_list|)
operator|==
name|osblock
operator|.
name|fs_size
condition|)
block|{
name|acg
operator|.
name|cg_ncyl
operator|=
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|acg
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"jcg written\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"new joining cg"
argument_list|,
operator|&
name|acg
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set up some variables needed later. 	 */
name|cbase
operator|=
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
expr_stmt|;
name|dmax
operator|=
name|cbase
operator|+
name|sblock
operator|.
name|fs_fpg
expr_stmt|;
if|if
condition|(
name|dmax
operator|>
name|sblock
operator|.
name|fs_size
condition|)
name|dmax
operator|=
name|sblock
operator|.
name|fs_size
expr_stmt|;
name|dupper
operator|=
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
operator|-
name|cbase
expr_stmt|;
if|if
condition|(
name|cylno
operator|==
literal|0
condition|)
block|{
comment|/* XXX fscs may be relocated */
name|dupper
operator|+=
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set pointer to the cylinder summary for our cylinder group. 	 */
name|cs
operator|=
name|fscs
operator|+
name|cylno
expr_stmt|;
comment|/* 	 * Touch the cylinder group, update all fields in the cylinder group as 	 * needed, update the free space in the superblock. 	 */
name|acg
operator|.
name|cg_time
operator|=
name|utime
expr_stmt|;
if|if
condition|(
name|cylno
operator|==
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
condition|)
block|{
comment|/* 		 * This is still the last cylinder group. 		 */
name|acg
operator|.
name|cg_ncyl
operator|=
name|sblock
operator|.
name|fs_ncyl
operator|%
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
block|}
else|else
block|{
name|acg
operator|.
name|cg_ncyl
operator|=
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
block|}
name|DBG_PRINT4
argument_list|(
literal|"jcg dbg: %d %u %d %u\n"
argument_list|,
name|cylno
argument_list|,
name|sblock
operator|.
name|fs_ncg
argument_list|,
name|acg
operator|.
name|cg_ncyl
argument_list|,
name|sblock
operator|.
name|fs_cpg
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_ndblk
operator|=
name|dmax
operator|-
name|cbase
expr_stmt|;
name|sblock
operator|.
name|fs_dsize
operator|+=
name|acg
operator|.
name|cg_ndblk
operator|-
name|aocg
operator|.
name|cg_ndblk
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|acg
operator|.
name|cg_nclusterblks
operator|=
name|acg
operator|.
name|cg_ndblk
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
block|}
comment|/* 	 * Now  we have to update the free fragment bitmap for our new  free 	 * space.  There again we have to handle the fragmentation and  also 	 * the  rotational  layout tables and the cluster summary.  This  is 	 * also  done per fragment for the first new block if the  old  file 	 * system end was not on a block boundary, per fragment for the  new 	 * last block if the new file system end is not on a block boundary, 	 * and per block for all space in between. 	 * 	 * Handle the first new block here if it was partially available 	 * before. 	 */
if|if
condition|(
name|osblock
operator|.
name|fs_size
operator|%
name|sblock
operator|.
name|fs_frag
condition|)
block|{
if|if
condition|(
name|roundup
argument_list|(
name|osblock
operator|.
name|fs_size
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
operator|<=
name|sblock
operator|.
name|fs_size
condition|)
block|{
comment|/* 			 * The new space is enough to fill at least this 			 * block 			 */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|roundup
argument_list|(
name|osblock
operator|.
name|fs_size
operator|-
name|cbase
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|osblock
operator|.
name|fs_size
operator|-
name|cbase
condition|;
name|i
operator|--
control|)
block|{
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
comment|/* 			 * Check  if the fragment just created could join  an 			 * already existing fragment at the former end of the 			 * file system. 			 */
if|if
condition|(
name|isblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
operator|(
operator|(
name|osblock
operator|.
name|fs_size
operator|-
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
operator|)
argument_list|)
condition|)
block|{
comment|/* 				 * The block is now completely available 				 */
name|DBG_PRINT0
argument_list|(
literal|"block was\n"
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_frsum
index|[
name|osblock
operator|.
name|fs_size
operator|%
name|sblock
operator|.
name|fs_frag
index|]
operator|--
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|-=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|k
operator|=
name|rounddown
argument_list|(
name|osblock
operator|.
name|fs_size
operator|-
name|cbase
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|cg_blktot
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|k
argument_list|)
index|]
operator|++
expr_stmt|;
name|cg_blks
argument_list|(
operator|&
name|sblock
argument_list|,
operator|&
name|acg
argument_list|,
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|k
argument_list|)
argument_list|)
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|k
argument_list|)
index|]
operator|++
expr_stmt|;
name|updclst
argument_list|(
operator|(
name|osblock
operator|.
name|fs_size
operator|-
name|cbase
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Lets rejoin a possible partially growed 				 * fragment. 				 */
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isset
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|i
argument_list|)
operator|&&
operator|(
name|i
operator|>=
name|rounddown
argument_list|(
name|osblock
operator|.
name|fs_size
operator|-
name|cbase
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
operator|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|k
condition|)
block|{
name|acg
operator|.
name|cg_frsum
index|[
name|k
index|]
operator|--
expr_stmt|;
block|}
name|acg
operator|.
name|cg_frsum
index|[
name|k
operator|+
name|j
index|]
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * We only grow by some fragments within this last 			 * block. 			 */
for|for
control|(
name|i
operator|=
name|sblock
operator|.
name|fs_size
operator|-
name|cbase
operator|-
literal|1
init|;
name|i
operator|>=
name|osblock
operator|.
name|fs_size
operator|-
name|cbase
condition|;
name|i
operator|--
control|)
block|{
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
comment|/* 			 * Lets rejoin a possible partially growed fragment. 			 */
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isset
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|i
argument_list|)
operator|&&
operator|(
name|i
operator|>=
name|rounddown
argument_list|(
name|osblock
operator|.
name|fs_size
operator|-
name|cbase
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
operator|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|k
condition|)
block|{
name|acg
operator|.
name|cg_frsum
index|[
name|k
index|]
operator|--
expr_stmt|;
block|}
name|acg
operator|.
name|cg_frsum
index|[
name|k
operator|+
name|j
index|]
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Handle all new complete blocks here. 	 */
for|for
control|(
name|i
operator|=
name|roundup
argument_list|(
name|osblock
operator|.
name|fs_size
operator|-
name|cbase
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
init|;
name|i
operator|+
name|sblock
operator|.
name|fs_frag
operator|<=
name|dmax
operator|-
name|cbase
condition|;
comment|/* XXX<= or only< ? */
name|i
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|j
operator|=
name|i
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|setblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|updclst
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|cg_blktot
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|i
argument_list|)
index|]
operator|++
expr_stmt|;
name|cg_blks
argument_list|(
operator|&
name|sblock
argument_list|,
operator|&
name|acg
argument_list|,
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|i
argument_list|)
argument_list|)
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|i
argument_list|)
index|]
operator|++
expr_stmt|;
block|}
comment|/* 	 * Handle the last new block if there are stll some new fragments left. 	 * Here  we don't have to bother about the cluster summary or the  even 	 * the rotational layout table. 	 */
if|if
condition|(
name|i
operator|<
operator|(
name|dmax
operator|-
name|cbase
operator|)
condition|)
block|{
name|acg
operator|.
name|cg_frsum
index|[
name|dmax
operator|-
name|cbase
operator|-
name|i
index|]
operator|++
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|dmax
operator|-
name|cbase
condition|;
name|i
operator|++
control|)
block|{
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
block|}
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|+=
operator|(
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|-
name|aocg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|)
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|+=
operator|(
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|-
name|aocg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|)
expr_stmt|;
comment|/* 	 * The following statistics are not changed here: 	 *     sblock.fs_cstotal.cs_ndir 	 *     sblock.fs_cstotal.cs_nifree 	 * As the statistics for this cylinder group are ready, copy it to 	 * the summary information array. 	 */
operator|*
name|cs
operator|=
name|acg
operator|.
name|cg_cs
expr_stmt|;
comment|/* 	 * Write the updated "joining" cylinder group back to disk. 	 */
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|acg
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"jcg written\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"new joining cg"
argument_list|,
operator|&
name|acg
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************** updcsloc ***** */
end_comment

begin_comment
comment|/*  * Here  we update the location of the cylinder summary. We have  two  possible  * ways of growing the cylinder summary.  * (1)	We can try to grow the summary in the current location, and  relocate  *	possibly used blocks within the current cylinder group.  * (2)	Alternatively we can relocate the whole cylinder summary to the first  *	new completely empty cylinder group. Once the cylinder summary is  no  *	longer in the beginning of the first cylinder group you should  never  *	use  a version of fsck which is not aware of the possibility to  have  *	this structure in a non standard place.  * Option (1) is considered to be less intrusive to the structure of the  file-  * system. So we try to stick to that whenever possible. If there is not enough  * space  in the cylinder group containing the cylinder summary we have to  use  * method  (2). In case of active snapshots in the filesystem we  probably  can  * completely avoid implementing copy on write if we stick to method (2) only.  */
end_comment

begin_function
specifier|static
name|void
name|updcsloc
parameter_list|(
name|time_t
name|utime
parameter_list|,
name|int
name|fsi
parameter_list|,
name|int
name|fso
parameter_list|,
name|unsigned
name|int
name|Nflag
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"updcsloc"
argument_list|)
name|struct
name|csum
modifier|*
name|cs
decl_stmt|;
name|int
name|ocscg
decl_stmt|,
name|ncscg
decl_stmt|;
name|int
name|blocks
decl_stmt|;
name|daddr_t
name|cbase
decl_stmt|,
name|dupper
decl_stmt|,
name|odupper
decl_stmt|,
name|d
decl_stmt|,
name|f
decl_stmt|,
name|g
decl_stmt|;
name|int
name|ind
decl_stmt|;
name|int
name|cylno
decl_stmt|,
name|inc
decl_stmt|;
name|struct
name|gfs_bpp
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|int
name|lcs
init|=
literal|0
decl_stmt|;
name|int
name|block
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
if|if
condition|(
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
operator|==
name|howmany
argument_list|(
name|osblock
operator|.
name|fs_cssize
argument_list|,
name|osblock
operator|.
name|fs_fsize
argument_list|)
condition|)
block|{
comment|/* 		 * No new fragment needed. 		 */
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
name|ocscg
operator|=
name|dtog
argument_list|(
operator|&
name|osblock
argument_list|,
name|osblock
operator|.
name|fs_csaddr
argument_list|)
expr_stmt|;
name|cs
operator|=
name|fscs
operator|+
name|ocscg
expr_stmt|;
name|blocks
operator|=
literal|1
operator|+
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
operator|-
name|howmany
argument_list|(
name|osblock
operator|.
name|fs_cssize
argument_list|,
name|osblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
comment|/* 	 * Read original cylinder group from disk, and make a copy. 	 * XXX	If Nflag is set in some very rare cases we now miss 	 *	some changes done in updjcg by reading the unmodified 	 *	block from disk. 	 */
name|rdfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|osblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|osblock
argument_list|,
name|ocscg
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|osblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|aocg
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"oscg read\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"old summary cg"
argument_list|,
operator|&
name|aocg
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|cgun1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cgun2
argument_list|,
sizeof|sizeof
argument_list|(
name|cgun2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Touch the cylinder group, set up local variables needed later 	 * and update the superblock. 	 */
name|acg
operator|.
name|cg_time
operator|=
name|utime
expr_stmt|;
comment|/* 	 * XXX	In the case of having active snapshots we may need much more 	 *	blocks for the copy on write. We need each block twice,  and 	 *	also  up to 8*3 blocks for indirect blocks for all  possible 	 *	references. 	 */
if|if
condition|(
comment|/*((int)sblock.fs_time&0x3)>0||*/
name|cs
operator|->
name|cs_nbfree
operator|<
name|blocks
condition|)
block|{
comment|/* 		 * There  is  not enough space in the old cylinder  group  to 		 * relocate  all blocks as needed, so we relocate  the  whole 		 * cylinder  group summary to a new group. We try to use  the 		 * first complete new cylinder group just created. Within the 		 * cylinder  group we allign the area immediately  after  the 		 * cylinder  group  information location in order  to  be  as 		 * close as possible to the original implementation of ffs. 		 * 		 * First  we have to make sure we'll find enough space in  the 		 * new  cylinder  group. If not, then we  currently  give  up. 		 * We  start  with freeing everything which was  used  by  the 		 * fragments of the old cylinder summary in the current group. 		 * Now  we write back the group meta data, read in the  needed 		 * meta data from the new cylinder group, and start allocating 		 * within  that  group. Here we can assume, the  group  to  be 		 * completely empty. Which makes the handling of fragments and 		 * clusters a lot easier. 		 */
name|DBG_TRC
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_ncg
operator|-
name|osblock
operator|.
name|fs_ncg
operator|<
literal|2
condition|)
block|{
name|errx
argument_list|(
literal|2
argument_list|,
literal|"panic: not enough space"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Point "d" to the first fragment not used by the cylinder 		 * summary. 		 */
name|d
operator|=
name|osblock
operator|.
name|fs_csaddr
operator|+
operator|(
name|osblock
operator|.
name|fs_cssize
operator|/
name|osblock
operator|.
name|fs_fsize
operator|)
expr_stmt|;
comment|/* 		 * Set up last cluster size ("lcs") already here. Calculate 		 * the size for the trailing cluster just behind where  "d" 		 * points to. 		 */
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|block
operator|=
name|howmany
argument_list|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
operator|,
name|lcs
operator|=
literal|0
init|;
name|lcs
operator|<
name|sblock
operator|.
name|fs_contigsumsize
condition|;
name|block
operator|++
operator|,
name|lcs
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|block
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|/* 		 * Point "d" to the last frag used by the cylinder summary. 		 */
name|d
operator|--
expr_stmt|;
name|DBG_PRINT1
argument_list|(
literal|"d=%d\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|+
literal|1
operator|)
operator|%
name|sblock
operator|.
name|fs_frag
condition|)
block|{
comment|/* 			 * The end of the cylinder summary is not a complete 			 * block. 			 */
name|DBG_TRC
expr_stmt|;
name|frag_adjust
argument_list|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|d
operator|+
literal|1
operator|)
operator|%
name|sblock
operator|.
name|fs_frag
condition|;
name|d
operator|--
control|)
block|{
name|DBG_PRINT1
argument_list|(
literal|"d=%d\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
comment|/* 			 * Point  "d" to the last fragment of the  last 			 * (incomplete) block of the clinder summary. 			 */
name|d
operator|++
expr_stmt|;
name|frag_adjust
argument_list|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
operator|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
condition|)
block|{
name|DBG_PRINT1
argument_list|(
literal|"d=%d\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|-=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|-=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|cg_blktot
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|)
index|]
operator|++
expr_stmt|;
name|cg_blks
argument_list|(
operator|&
name|sblock
argument_list|,
operator|&
name|acg
argument_list|,
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|)
argument_list|)
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|)
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|setbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
operator|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcs
operator|<
name|sblock
operator|.
name|fs_contigsumsize
condition|)
block|{
if|if
condition|(
name|lcs
condition|)
block|{
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs
index|]
operator|--
expr_stmt|;
block|}
name|lcs
operator|++
expr_stmt|;
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* 			 * Point "d" to the first fragment of the block before 			 * the last incomplete block. 			 */
name|d
operator|--
expr_stmt|;
block|}
name|DBG_PRINT1
argument_list|(
literal|"d=%d\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|rounddown
argument_list|(
name|d
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
init|;
name|d
operator|>=
name|osblock
operator|.
name|fs_csaddr
condition|;
name|d
operator|-=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|DBG_TRC
expr_stmt|;
name|DBG_PRINT1
argument_list|(
literal|"d=%d\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|setblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
operator|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|cg_blktot
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|)
index|]
operator|++
expr_stmt|;
name|cg_blks
argument_list|(
operator|&
name|sblock
argument_list|,
operator|&
name|acg
argument_list|,
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|)
argument_list|)
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|)
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|setbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
operator|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
comment|/* 				 * The last cluster size is already set up. 				 */
if|if
condition|(
name|lcs
operator|<
name|sblock
operator|.
name|fs_contigsumsize
condition|)
block|{
if|if
condition|(
name|lcs
condition|)
block|{
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs
index|]
operator|--
expr_stmt|;
block|}
name|lcs
operator|++
expr_stmt|;
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
operator|*
name|cs
operator|=
name|acg
operator|.
name|cg_cs
expr_stmt|;
comment|/* 		 * Now write the former cylinder group containing the cylinder 		 * summary back to disk. 		 */
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|ocscg
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|acg
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"oscg written\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"old summary cg"
argument_list|,
operator|&
name|acg
argument_list|)
expr_stmt|;
comment|/* 		 * Find the beginning of the new cylinder group containing the 		 * cylinder summary. 		 */
name|sblock
operator|.
name|fs_csaddr
operator|=
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|osblock
operator|.
name|fs_ncg
argument_list|)
expr_stmt|;
name|ncscg
operator|=
name|dtog
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_csaddr
argument_list|)
expr_stmt|;
name|cs
operator|=
name|fscs
operator|+
name|ncscg
expr_stmt|;
comment|/* 		 * If Nflag is specified, we would now read random data instead 		 * of an empty cg structure from disk. So we can't simulate that 		 * part for now. 		 */
if|if
condition|(
name|Nflag
condition|)
block|{
name|DBG_PRINT0
argument_list|(
literal|"nscg update skipped\n"
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
comment|/* 		 * Read the future cylinder group containing the cylinder 		 * summary from disk, and make a copy. 		 */
name|rdfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|ncscg
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|aocg
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"nscg read\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"new summary cg"
argument_list|,
operator|&
name|aocg
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|cgun1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cgun2
argument_list|,
sizeof|sizeof
argument_list|(
name|cgun2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate all complete blocks used by the new cylinder 		 * summary. 		 */
for|for
control|(
name|d
operator|=
name|sblock
operator|.
name|fs_csaddr
init|;
name|d
operator|+
name|sblock
operator|.
name|fs_frag
operator|<=
name|sblock
operator|.
name|fs_csaddr
operator|+
operator|(
name|sblock
operator|.
name|fs_cssize
operator|/
name|sblock
operator|.
name|fs_fsize
operator|)
condition|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|clrblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
operator|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|cg_blktot
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|)
index|]
operator|--
expr_stmt|;
name|cg_blks
argument_list|(
operator|&
name|sblock
argument_list|,
operator|&
name|acg
argument_list|,
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|)
argument_list|)
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|)
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|clrbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
operator|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Allocate all fragments used by the cylinder summary in the 		 * last block. 		 */
if|if
condition|(
name|d
operator|<
name|sblock
operator|.
name|fs_csaddr
operator|+
operator|(
name|sblock
operator|.
name|fs_cssize
operator|/
name|sblock
operator|.
name|fs_fsize
operator|)
condition|)
block|{
for|for
control|(
init|;
name|d
operator|-
name|sblock
operator|.
name|fs_csaddr
operator|<
name|sblock
operator|.
name|fs_cssize
operator|/
name|sblock
operator|.
name|fs_fsize
condition|;
name|d
operator|++
control|)
block|{
name|clrbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|--
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|--
expr_stmt|;
block|}
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|+=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|+=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|cg_blktot
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|)
index|]
operator|--
expr_stmt|;
name|cg_blks
argument_list|(
operator|&
name|sblock
argument_list|,
operator|&
name|acg
argument_list|,
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|)
argument_list|)
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|)
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|clrbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
operator|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
block|}
name|frag_adjust
argument_list|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|,
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * XXX	Handle the cluster statistics here in the case  this 		 *	cylinder group is now almost full, and the remaining 		 *	space is less then the maximum cluster size. This is 		 *	probably not needed, as you would hardly find a file 		 *	system which has only MAXCSBUFS+FS_MAXCONTIG of free 		 *	space right behind the cylinder group information in 		 *	any new cylinder group. 		 */
comment|/* 		 * Update our statistics in the cylinder summary. 		 */
operator|*
name|cs
operator|=
name|acg
operator|.
name|cg_cs
expr_stmt|;
comment|/* 		 * Write the new cylinder group containing the cylinder summary 		 * back to disk. 		 */
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|ncscg
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|acg
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"nscg written\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"new summary cg"
argument_list|,
operator|&
name|acg
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
comment|/* 	 * We have got enough of space in the current cylinder group, so we 	 * can relocate just a few blocks, and let the summary  information 	 * grow in place where it is right now. 	 */
name|DBG_TRC
expr_stmt|;
name|cbase
operator|=
name|cgbase
argument_list|(
operator|&
name|osblock
argument_list|,
name|ocscg
argument_list|)
expr_stmt|;
comment|/* old and new are equal */
name|dupper
operator|=
name|sblock
operator|.
name|fs_csaddr
operator|-
name|cbase
operator|+
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
name|odupper
operator|=
name|osblock
operator|.
name|fs_csaddr
operator|-
name|cbase
operator|+
name|howmany
argument_list|(
name|osblock
operator|.
name|fs_cssize
argument_list|,
name|osblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_dsize
operator|-=
name|dupper
operator|-
name|odupper
expr_stmt|;
comment|/* 	 * Allocate the space for the array of blocks to be relocated. 	 */
name|bp
operator|=
operator|(
expr|struct
name|gfs_bpp
operator|*
operator|)
name|malloc
argument_list|(
operator|(
operator|(
name|dupper
operator|-
name|odupper
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gfs_bpp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|dupper
operator|-
name|odupper
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gfs_bpp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Lock all new frags needed for the cylinder group summary. This  is 	 * done per fragment in the first and last block of the new  required 	 * area, and per block for all other blocks. 	 * 	 * Handle the first new  block here (but only if some fragments where 	 * already used for the cylinder summary). 	 */
name|ind
operator|=
literal|0
expr_stmt|;
name|frag_adjust
argument_list|(
name|odupper
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|odupper
init|;
operator|(
operator|(
name|d
operator|<
name|dupper
operator|)
operator|&&
operator|(
name|d
operator|%
name|sblock
operator|.
name|fs_frag
operator|)
operator|)
condition|;
name|d
operator|++
control|)
block|{
name|DBG_PRINT1
argument_list|(
literal|"scg first frag check loop d=%d\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|isclr
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ind
condition|)
block|{
name|bp
index|[
name|ind
index|]
operator|.
name|old
operator|=
name|d
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|bp
index|[
name|ind
index|]
operator|.
name|flags
operator||=
name|GFS_FL_FIRST
expr_stmt|;
if|if
condition|(
name|roundup
argument_list|(
name|d
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
operator|>=
name|dupper
condition|)
block|{
name|bp
index|[
name|ind
index|]
operator|.
name|flags
operator||=
name|GFS_FL_LAST
expr_stmt|;
block|}
name|ind
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|clrbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|--
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|--
expr_stmt|;
block|}
comment|/* 		 * No cluster handling is needed here, as there was at least 		 * one  fragment in use by the cylinder summary in  the  old 		 * file system. 		 * No block-free counter handling here as this block was not 		 * a free block. 		 */
block|}
name|frag_adjust
argument_list|(
name|odupper
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Handle all needed complete blocks here. 	 */
for|for
control|(
init|;
name|d
operator|+
name|sblock
operator|.
name|fs_frag
operator|<=
name|dupper
condition|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|DBG_PRINT1
argument_list|(
literal|"scg block check loop d=%d\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
condition|)
block|{
for|for
control|(
name|f
operator|=
name|d
init|;
name|f
operator|<
name|d
operator|+
name|sblock
operator|.
name|fs_frag
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|isset
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|aocg
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|--
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|--
expr_stmt|;
block|}
block|}
name|clrblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|bp
index|[
name|ind
index|]
operator|.
name|old
operator|=
name|d
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|ind
operator|++
expr_stmt|;
block|}
else|else
block|{
name|clrblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|cg_blktot
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|--
expr_stmt|;
name|cg_blks
argument_list|(
operator|&
name|sblock
argument_list|,
operator|&
name|acg
argument_list|,
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
argument_list|)
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|clrbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
for|for
control|(
name|lcs
operator|=
literal|0
operator|,
name|l
operator|=
operator|(
name|d
operator|/
name|sblock
operator|.
name|fs_frag
operator|)
operator|+
literal|1
init|;
name|lcs
operator|<
name|sblock
operator|.
name|fs_contigsumsize
condition|;
name|l
operator|++
operator|,
name|lcs
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|l
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|lcs
operator|<
name|sblock
operator|.
name|fs_contigsumsize
condition|)
block|{
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs
operator|+
literal|1
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|lcs
condition|)
block|{
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 		 * No fragment counter handling is needed here, as this finally 		 * doesn't change after the relocation. 		 */
block|}
comment|/* 	 * Handle all fragments needed in the last new affected block. 	 */
if|if
condition|(
name|d
operator|<
name|dupper
condition|)
block|{
name|frag_adjust
argument_list|(
name|dupper
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
condition|)
block|{
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|+=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|+=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|cg_blktot
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|--
expr_stmt|;
name|cg_blks
argument_list|(
operator|&
name|sblock
argument_list|,
operator|&
name|acg
argument_list|,
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
argument_list|)
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|clrbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
for|for
control|(
name|lcs
operator|=
literal|0
operator|,
name|l
operator|=
operator|(
name|d
operator|/
name|sblock
operator|.
name|fs_frag
operator|)
operator|+
literal|1
init|;
name|lcs
operator|<
name|sblock
operator|.
name|fs_contigsumsize
condition|;
name|l
operator|++
operator|,
name|lcs
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|l
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|lcs
operator|<
name|sblock
operator|.
name|fs_contigsumsize
condition|)
block|{
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs
operator|+
literal|1
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|lcs
condition|)
block|{
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
init|;
name|d
operator|<
name|dupper
condition|;
name|d
operator|++
control|)
block|{
name|DBG_PRINT1
argument_list|(
literal|"scg second frag check loop d=%d\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|isclr
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
argument_list|)
condition|)
block|{
name|bp
index|[
name|ind
index|]
operator|.
name|old
operator|=
name|d
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|bp
index|[
name|ind
index|]
operator|.
name|flags
operator||=
name|GFS_FL_LAST
expr_stmt|;
block|}
else|else
block|{
name|clrbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|--
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bp
index|[
name|ind
index|]
operator|.
name|flags
operator|&
name|GFS_FL_LAST
condition|)
block|{
comment|/* we have to advance here */
name|ind
operator|++
expr_stmt|;
block|}
name|frag_adjust
argument_list|(
name|dupper
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we found a block to relocate just do so. 	 */
if|if
condition|(
name|ind
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ind
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bp
index|[
name|i
index|]
operator|.
name|old
condition|)
block|{
comment|/* no more blocks listed */
comment|/* 				 * XXX	A relative blocknumber should not be 				 *	zero,   which  is   not   explicitly 				 *	guaranteed by our code. 				 */
break|break;
block|}
comment|/* 			 * Allocate a complete block in the same (current) 			 * cylinder group. 			 */
name|bp
index|[
name|i
index|]
operator|.
name|new
operator|=
name|alloc
argument_list|()
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
comment|/* 			 * There is no frag_adjust() needed for the new block 			 * as it will have no fragments yet :-). 			 */
for|for
control|(
name|f
operator|=
name|bp
index|[
name|i
index|]
operator|.
name|old
operator|*
name|sblock
operator|.
name|fs_frag
operator|,
name|g
operator|=
name|bp
index|[
name|i
index|]
operator|.
name|new
operator|*
name|sblock
operator|.
name|fs_frag
init|;
name|f
operator|<
operator|(
name|bp
index|[
name|i
index|]
operator|.
name|old
operator|+
literal|1
operator|)
operator|*
name|sblock
operator|.
name|fs_frag
condition|;
name|f
operator|++
operator|,
name|g
operator|++
control|)
block|{
if|if
condition|(
name|isset
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|aocg
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
block|}
comment|/* 			 * Special handling is required if this was the  first 			 * block. We have to consider the fragments which were 			 * used by the cylinder summary in the original  block 			 * which  re to be free in the copy of our  block.  We 			 * have  to be careful if this first block happens  to 			 * be also the last block to be relocated. 			 */
if|if
condition|(
name|bp
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|GFS_FL_FIRST
condition|)
block|{
for|for
control|(
name|f
operator|=
name|bp
index|[
name|i
index|]
operator|.
name|old
operator|*
name|sblock
operator|.
name|fs_frag
operator|,
name|g
operator|=
name|bp
index|[
name|i
index|]
operator|.
name|new
operator|*
name|sblock
operator|.
name|fs_frag
init|;
name|f
operator|<
name|odupper
condition|;
name|f
operator|++
operator|,
name|g
operator|++
control|)
block|{
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|bp
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|GFS_FL_LAST
operator|)
condition|)
block|{
name|frag_adjust
argument_list|(
name|bp
index|[
name|i
index|]
operator|.
name|new
operator|*
name|sblock
operator|.
name|fs_frag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * Special handling is required if this is the last 			 * block to be relocated. 			 */
if|if
condition|(
name|bp
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|GFS_FL_LAST
condition|)
block|{
name|frag_adjust
argument_list|(
name|bp
index|[
name|i
index|]
operator|.
name|new
operator|*
name|sblock
operator|.
name|fs_frag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frag_adjust
argument_list|(
name|bp
index|[
name|i
index|]
operator|.
name|old
operator|*
name|sblock
operator|.
name|fs_frag
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|dupper
init|;
name|f
operator|<
name|roundup
argument_list|(
name|dupper
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
block|}
name|frag_adjust
argument_list|(
name|bp
index|[
name|i
index|]
operator|.
name|old
operator|*
name|sblock
operator|.
name|fs_frag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * !!! Attach the cylindergroup offset here.  			 */
name|bp
index|[
name|i
index|]
operator|.
name|old
operator|+=
name|cbase
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|bp
index|[
name|i
index|]
operator|.
name|new
operator|+=
name|cbase
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
comment|/* 			 * Copy the content of the block. 			 */
comment|/* 			 * XXX	Here we will have to implement a copy on write 			 *	in the case we have any active snapshots. 			 */
name|rdfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|bp
index|[
name|i
index|]
operator|.
name|old
operator|*
name|sblock
operator|.
name|fs_frag
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ablk
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|bp
index|[
name|i
index|]
operator|.
name|new
operator|*
name|sblock
operator|.
name|fs_frag
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ablk
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|DBG_DUMP_HEX
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"copied full block"
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|ablk
argument_list|)
expr_stmt|;
name|DBG_PRINT2
argument_list|(
literal|"scg (%d->%d) block relocated\n"
argument_list|,
name|bp
index|[
name|i
index|]
operator|.
name|old
argument_list|,
name|bp
index|[
name|i
index|]
operator|.
name|new
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now we have to update all references to any fragment which 		 * belongs  to any block relocated. We iterate now  over  all 		 * cylinder  groups,  within those over all non  zero  length  		 * inodes. 		 */
for|for
control|(
name|cylno
operator|=
literal|0
init|;
name|cylno
operator|<
name|osblock
operator|.
name|fs_ncg
condition|;
name|cylno
operator|++
control|)
block|{
name|DBG_PRINT1
argument_list|(
literal|"scg doing cg (%d)\n"
argument_list|,
name|cylno
argument_list|)
expr_stmt|;
for|for
control|(
name|inc
operator|=
name|osblock
operator|.
name|fs_ipg
operator|-
literal|1
init|;
name|inc
operator|>=
literal|0
condition|;
name|inc
operator|--
control|)
block|{
name|updrefs
argument_list|(
name|cylno
argument_list|,
operator|(
name|ino_t
operator|)
name|inc
argument_list|,
name|bp
argument_list|,
name|fsi
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * All inodes are checked, now make sure the number of 		 * references found make sense. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ind
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bp
index|[
name|i
index|]
operator|.
name|found
operator|||
operator|(
name|bp
index|[
name|i
index|]
operator|.
name|found
operator|>
name|sblock
operator|.
name|fs_frag
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"error: %d refs found for block %d."
argument_list|,
name|bp
index|[
name|i
index|]
operator|.
name|found
argument_list|,
name|bp
index|[
name|i
index|]
operator|.
name|old
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * The following statistics are not changed here: 	 *     sblock.fs_cstotal.cs_ndir 	 *     sblock.fs_cstotal.cs_nifree 	 * The following statistics were already updated on the fly: 	 *     sblock.fs_cstotal.cs_nffree 	 *     sblock.fs_cstotal.cs_nbfree 	 * As the statistics for this cylinder group are ready, copy it to 	 * the summary information array. 	 */
operator|*
name|cs
operator|=
name|acg
operator|.
name|cg_cs
expr_stmt|;
comment|/* 	 * Write summary cylinder group back to disk. 	 */
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|ocscg
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|acg
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"scg written\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"new summary cg"
argument_list|,
operator|&
name|acg
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************** rdfs ***** */
end_comment

begin_comment
comment|/*  * Here we read some block(s) from disk.  */
end_comment

begin_function
specifier|static
name|void
name|rdfs
parameter_list|(
name|daddr_t
name|bno
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|bf
parameter_list|,
name|int
name|fsi
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"rdfs"
argument_list|)
name|ssize_t
name|n
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fsi
argument_list|,
operator|(
name|off_t
operator|)
name|bno
operator|*
name|DEV_BSIZE
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|33
argument_list|,
literal|"rdfs: seek error: %ld"
argument_list|,
operator|(
name|long
operator|)
name|bno
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|read
argument_list|(
name|fsi
argument_list|,
name|bf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
operator|(
name|ssize_t
operator|)
name|size
condition|)
block|{
name|err
argument_list|(
literal|34
argument_list|,
literal|"rdfs: read error: %ld"
argument_list|,
operator|(
name|long
operator|)
name|bno
argument_list|)
expr_stmt|;
block|}
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************** wtfs ***** */
end_comment

begin_comment
comment|/*  * Here we write some block(s) to disk.  */
end_comment

begin_function
specifier|static
name|void
name|wtfs
parameter_list|(
name|daddr_t
name|bno
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|bf
parameter_list|,
name|int
name|fso
parameter_list|,
name|unsigned
name|int
name|Nflag
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"wtfs"
argument_list|)
name|ssize_t
name|n
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
if|if
condition|(
name|Nflag
condition|)
block|{
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|fso
argument_list|,
operator|(
name|off_t
operator|)
name|bno
operator|*
name|DEV_BSIZE
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|35
argument_list|,
literal|"wtfs: seek error: %ld"
argument_list|,
operator|(
name|long
operator|)
name|bno
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|write
argument_list|(
name|fso
argument_list|,
name|bf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
operator|(
name|ssize_t
operator|)
name|size
condition|)
block|{
name|err
argument_list|(
literal|36
argument_list|,
literal|"wtfs: write error: %ld"
argument_list|,
operator|(
name|long
operator|)
name|bno
argument_list|)
expr_stmt|;
block|}
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************* alloc ***** */
end_comment

begin_comment
comment|/*  * Here we allocate a free block in the current cylinder group. It is assumed,  * that  acg contains the current cylinder group. As we may take a block  from  * somewhere in the filesystem we have to handle cluster summary here.  */
end_comment

begin_function
specifier|static
name|daddr_t
name|alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"alloc"
argument_list|)
name|daddr_t
name|d
decl_stmt|,
name|blkno
decl_stmt|;
name|int
name|lcs1
decl_stmt|,
name|lcs2
decl_stmt|;
name|int
name|l
decl_stmt|;
name|int
name|csmin
decl_stmt|,
name|csmax
decl_stmt|;
name|int
name|dlower
decl_stmt|,
name|dupper
decl_stmt|,
name|dmax
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
if|if
condition|(
name|acg
operator|.
name|cg_magic
operator|!=
name|CG_MAGIC
condition|)
block|{
name|warnx
argument_list|(
literal|"acg: bad magic number"
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"error: cylinder group ran out of space"
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We start seeking for free blocks only from the space available after 	 * the  end of the new grown cylinder summary. Otherwise we allocate  a 	 * block here which we have to relocate a couple of seconds later again 	 * again, and we are not prepared to to this anyway. 	 */
name|blkno
operator|=
operator|-
literal|1
expr_stmt|;
name|dlower
operator|=
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|acg
operator|.
name|cg_cgx
argument_list|)
operator|-
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|acg
operator|.
name|cg_cgx
argument_list|)
expr_stmt|;
name|dupper
operator|=
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|acg
operator|.
name|cg_cgx
argument_list|)
operator|-
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|acg
operator|.
name|cg_cgx
argument_list|)
expr_stmt|;
name|dmax
operator|=
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|acg
operator|.
name|cg_cgx
argument_list|)
operator|+
name|sblock
operator|.
name|fs_fpg
expr_stmt|;
if|if
condition|(
name|dmax
operator|>
name|sblock
operator|.
name|fs_size
condition|)
block|{
name|dmax
operator|=
name|sblock
operator|.
name|fs_size
expr_stmt|;
block|}
name|dmax
operator|-=
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|acg
operator|.
name|cg_cgx
argument_list|)
expr_stmt|;
comment|/* retransform into cg */
name|csmin
operator|=
name|sblock
operator|.
name|fs_csaddr
operator|-
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|acg
operator|.
name|cg_cgx
argument_list|)
expr_stmt|;
name|csmax
operator|=
name|csmin
operator|+
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
name|DBG_PRINT3
argument_list|(
literal|"seek range: dl=%d, du=%d, dm=%d\n"
argument_list|,
name|dlower
argument_list|,
name|dupper
argument_list|,
name|dmax
argument_list|)
expr_stmt|;
name|DBG_PRINT2
argument_list|(
literal|"range cont: csmin=%d, csmax=%d\n"
argument_list|,
name|csmin
argument_list|,
name|csmax
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
literal|0
init|;
operator|(
name|d
operator|<
name|dlower
operator|&&
name|blkno
operator|==
operator|-
literal|1
operator|)
condition|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
if|if
condition|(
name|d
operator|>=
name|csmin
operator|&&
name|d
operator|<=
name|csmax
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|isblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|fragstoblks
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
argument_list|)
condition|)
block|{
name|blkno
operator|=
name|fragstoblks
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* Yeah found a block */
break|break;
block|}
block|}
for|for
control|(
name|d
operator|=
name|dupper
init|;
operator|(
name|d
operator|<
name|dmax
operator|&&
name|blkno
operator|==
operator|-
literal|1
operator|)
condition|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
if|if
condition|(
name|d
operator|>=
name|csmin
operator|&&
name|d
operator|<=
name|csmax
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|isblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|fragstoblks
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
argument_list|)
condition|)
block|{
name|blkno
operator|=
name|fragstoblks
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* Yeah found a block */
break|break;
block|}
block|}
if|if
condition|(
name|blkno
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"internal error: couldn't find promised block in cg"
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * This is needed if the block was found already in the first loop. 	 */
name|d
operator|=
name|blkstofrags
argument_list|(
operator|&
name|sblock
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|clrblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Handle the cluster allocation bitmap. 		 */
name|clrbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
comment|/* 		 * We  possibly have split a cluster here, so we have  to  do 		 * recalculate the sizes of the remaining cluster halves now, 		 * and use them for updating the cluster summary information. 		 * 		 * Lets start with the blocks before our allocated block ... 		 */
for|for
control|(
name|lcs1
operator|=
literal|0
operator|,
name|l
operator|=
name|blkno
operator|-
literal|1
init|;
name|lcs1
operator|<
name|sblock
operator|.
name|fs_contigsumsize
condition|;
name|l
operator|--
operator|,
name|lcs1
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|l
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
comment|/* 		 * ... and continue with the blocks right after our allocated 		 * block. 		 */
for|for
control|(
name|lcs2
operator|=
literal|0
operator|,
name|l
operator|=
name|blkno
operator|+
literal|1
init|;
name|lcs2
operator|<
name|sblock
operator|.
name|fs_contigsumsize
condition|;
name|l
operator|++
operator|,
name|lcs2
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|l
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
comment|/* 		 * Now update all counters. 		 */
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|MIN
argument_list|(
name|lcs1
operator|+
name|lcs2
operator|+
literal|1
argument_list|,
name|sblock
operator|.
name|fs_contigsumsize
argument_list|)
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|lcs1
condition|)
block|{
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs1
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lcs2
condition|)
block|{
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs2
index|]
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Update all statistics based on blocks. 	 */
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|cg_blktot
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|--
expr_stmt|;
name|cg_blks
argument_list|(
operator|&
name|sblock
argument_list|,
operator|&
name|acg
argument_list|,
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
argument_list|)
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|--
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/* *********************************************************** isblock ***** */
end_comment

begin_comment
comment|/*  * Here  we check if all frags of a block are free. For more details  again  * please see the source of newfs(8), as this function is taken over almost  * unchanged.  */
end_comment

begin_function
specifier|static
name|int
name|isblock
parameter_list|(
name|struct
name|fs
modifier|*
name|fs
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"isblock"
argument_list|)
name|unsigned
name|char
name|mask
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
switch|switch
condition|(
name|fs
operator|->
name|fs_frag
condition|)
block|{
case|case
literal|8
case|:
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
name|cp
index|[
name|h
index|]
operator|==
literal|0xff
operator|)
return|;
case|case
literal|4
case|:
name|mask
operator|=
literal|0x0f
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x1
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
operator|(
name|cp
index|[
name|h
operator|>>
literal|1
index|]
operator|&
name|mask
operator|)
operator|==
name|mask
operator|)
return|;
case|case
literal|2
case|:
name|mask
operator|=
literal|0x03
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x3
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
operator|(
name|cp
index|[
name|h
operator|>>
literal|2
index|]
operator|&
name|mask
operator|)
operator|==
name|mask
operator|)
return|;
case|case
literal|1
case|:
name|mask
operator|=
literal|0x01
operator|<<
operator|(
name|h
operator|&
literal|0x7
operator|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
operator|(
name|cp
index|[
name|h
operator|>>
literal|3
index|]
operator|&
name|mask
operator|)
operator|==
name|mask
operator|)
return|;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"isblock bad fs_frag %d\n"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ********************************************************** clrblock ***** */
end_comment

begin_comment
comment|/*  * Here we allocate a complete block in the block map. For more details again  * please  see the source of newfs(8), as this function is taken over  almost  * unchanged.  */
end_comment

begin_function
specifier|static
name|void
name|clrblock
parameter_list|(
name|struct
name|fs
modifier|*
name|fs
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"clrblock"
argument_list|)
name|DBG_ENTER
expr_stmt|;
switch|switch
condition|(
operator|(
name|fs
operator|)
operator|->
name|fs_frag
condition|)
block|{
case|case
literal|8
case|:
name|cp
index|[
name|h
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cp
index|[
name|h
operator|>>
literal|1
index|]
operator|&=
operator|~
operator|(
literal|0x0f
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x1
operator|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cp
index|[
name|h
operator|>>
literal|2
index|]
operator|&=
operator|~
operator|(
literal|0x03
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x3
operator|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cp
index|[
name|h
operator|>>
literal|3
index|]
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
operator|(
name|h
operator|&
literal|0x7
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"clrblock bad fs_frag %d"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
break|break;
block|}
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ********************************************************** setblock ***** */
end_comment

begin_comment
comment|/*  * Here we free a complete block in the free block map. For more details again  * please  see the source of newfs(8), as this function is taken  over  almost  * unchanged.  */
end_comment

begin_function
specifier|static
name|void
name|setblock
parameter_list|(
name|struct
name|fs
modifier|*
name|fs
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"setblock"
argument_list|)
name|DBG_ENTER
expr_stmt|;
switch|switch
condition|(
name|fs
operator|->
name|fs_frag
condition|)
block|{
case|case
literal|8
case|:
name|cp
index|[
name|h
index|]
operator|=
literal|0xff
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cp
index|[
name|h
operator|>>
literal|1
index|]
operator||=
operator|(
literal|0x0f
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x1
operator|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cp
index|[
name|h
operator|>>
literal|2
index|]
operator||=
operator|(
literal|0x03
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x3
operator|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cp
index|[
name|h
operator|>>
literal|3
index|]
operator||=
operator|(
literal|0x01
operator|<<
operator|(
name|h
operator|&
literal|0x7
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"setblock bad fs_frag %d"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
break|break;
block|}
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ************************************************************ ginode ***** */
end_comment

begin_comment
comment|/*  * This function provides access to an individual inode. We find out in which  * block  the  requested inode is located, read it from disk if  needed,  and  * return  the pointer into that block. We maintain a cache of one  block  to  * not  read the same block again and again if we iterate linearly  over  all  * inodes.  */
end_comment

begin_function
specifier|static
name|struct
name|dinode
modifier|*
name|ginode
parameter_list|(
name|ino_t
name|inumber
parameter_list|,
name|int
name|fsi
parameter_list|,
name|int
name|cg
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"ginode"
argument_list|)
name|ufs_daddr_t
name|iblk
decl_stmt|;
specifier|static
name|ino_t
name|startinum
init|=
literal|0
decl_stmt|;
comment|/* first inode in cached block */
name|struct
name|dinode
modifier|*
name|pi
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
name|pi
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ablk
expr_stmt|;
name|inumber
operator|+=
operator|(
name|cg
operator|*
name|sblock
operator|.
name|fs_ipg
operator|)
expr_stmt|;
if|if
condition|(
name|startinum
operator|==
literal|0
operator|||
name|inumber
operator|<
name|startinum
operator|||
name|inumber
operator|>=
name|startinum
operator|+
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
block|{
comment|/* 		 * The block needed is not cached, so we have to read it from 		 * disk now. 		 */
name|iblk
operator|=
name|ino_to_fsba
argument_list|(
operator|&
name|sblock
argument_list|,
name|inumber
argument_list|)
expr_stmt|;
name|in_src
operator|=
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|iblk
argument_list|)
expr_stmt|;
name|rdfs
argument_list|(
name|in_src
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ablk
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
name|startinum
operator|=
operator|(
name|inumber
operator|/
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
operator|)
operator|*
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
block|}
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
operator|&
operator|(
name|pi
index|[
name|inumber
operator|%
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ****************************************************** charsperline ***** */
end_comment

begin_comment
comment|/*  * Figure out how many lines our current terminal has. For more details again  * please  see the source of newfs(8), as this function is taken over  almost  * unchanged.  */
end_comment

begin_function
specifier|static
name|int
name|charsperline
parameter_list|(
name|void
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"charsperline"
argument_list|)
name|int
name|columns
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|winsize
name|ws
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
name|columns
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|columns
operator|=
name|ws
operator|.
name|ws_col
expr_stmt|;
block|}
if|if
condition|(
name|columns
operator|==
literal|0
operator|&&
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
operator|)
condition|)
block|{
name|columns
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|columns
operator|==
literal|0
condition|)
block|{
name|columns
operator|=
literal|80
expr_stmt|;
comment|/* last resort */
block|}
name|DBG_LEAVE
expr_stmt|;
return|return
name|columns
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************** main ***** */
end_comment

begin_comment
comment|/*  * growfs(8)  is a utility which allows to increase the size of  an  existing  * ufs filesystem. Currently this can only be done on unmounted file  system.  * It  recognizes some command line options to specify the new desired  size,  * and  it does some basic checkings. The old file system size is  determined  * and  after some more checks like we can really access the new  last  block  * on the disk etc. we calculate the new parameters for the superblock. After  * having  done  this we just call growfs() which will do  the  work.  Before  * we finish the only thing left is to update the disklabel.  * We still have to provide support for snapshots. Therefore we first have to  * understand  what data structures are always replicated in the snapshot  on  * creation,  for all other blocks we touch during our procedure, we have  to  * keep the old blocks unchanged somewhere available for the snapshots. If we  * are lucky, then we only have to handle our blocks to be relocated in  that  * way.  * Also  we  have to consider in what order we actually update  the  critical  * data structures of the filesystem to make sure, that in case of a disaster  * fsck(8) is still able to restore any lost data.  * The  foreseen last step then will be to provide for growing  even  mounted  * file  systems. There we have to extend the mount() system call to  provide  * userland access to the file system locking facility.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"main"
argument_list|)
name|char
modifier|*
name|device
decl_stmt|,
modifier|*
name|special
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|unsigned
name|int
name|size
init|=
literal|0
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|unsigned
name|int
name|Nflag
init|=
literal|0
decl_stmt|;
name|int
name|ExpertFlag
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|struct
name|partition
modifier|*
name|pp
decl_stmt|;
name|int
name|fsi
decl_stmt|,
name|fso
decl_stmt|;
name|char
name|reply
index|[
literal|5
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|FSMAXSNAP
name|int
name|j
decl_stmt|;
endif|#
directive|endif
comment|/* FSMAXSNAP */
name|DBG_ENTER
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Ns:vy"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'N'
case|:
name|Nflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|size
operator|=
operator|(
name|size_t
operator|)
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
comment|/* for compatibility to newfs */
break|break;
case|case
literal|'y'
case|:
name|ExpertFlag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* FALLTHROUGH */
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
name|device
operator|=
operator|*
name|argv
expr_stmt|;
comment|/* 	 * Now try to guess the (raw)device name. 	 */
if|if
condition|(
literal|0
operator|==
name|strrchr
argument_list|(
name|device
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
comment|/* 		 * No path prefix was given, so try in that order: 		 *     /dev/r%s 		 *     /dev/%s 		 *     /dev/vinum/r%s 		 *     /dev/vinum/%s. 		 *  		 * FreeBSD now doesn't distinguish between raw and  block 		 * devices any longer, but it should still work this way. 		 */
name|len
operator|=
name|strlen
argument_list|(
name|device
argument_list|)
operator|+
name|strlen
argument_list|(
name|_PATH_DEV
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
literal|"vinum/"
argument_list|)
expr_stmt|;
name|special
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|special
operator|==
name|NULL
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|special
argument_list|,
name|len
argument_list|,
literal|"%sr%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|special
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|special
argument_list|,
name|len
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|special
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|special
argument_list|,
name|len
argument_list|,
literal|"%svinum/r%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|special
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* For now this is the 'last resort' */
name|snprintf
argument_list|(
name|special
argument_list|,
name|len
argument_list|,
literal|"%svinum/%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|device
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|device
operator|=
name|special
expr_stmt|;
block|}
comment|/* 	 * Try to access our devices for writing ... 	 */
if|if
condition|(
name|Nflag
condition|)
block|{
name|fso
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fso
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fso
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|device
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * ... and reading. 	 */
name|fsi
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsi
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|device
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Try  to read a label and gess the slice if not  specified.  This 	 * code  should guess the right thing and avaid to bother the  user 	 * user with the task of specifying the option -v on vinum volumes. 	 */
name|cp
operator|=
name|device
operator|+
name|strlen
argument_list|(
name|device
argument_list|)
operator|-
literal|1
expr_stmt|;
name|lp
operator|=
name|get_disklabel
argument_list|(
name|fsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|d_type
operator|==
name|DTYPE_VINUM
condition|)
block|{
name|pp
operator|=
operator|&
name|lp
operator|->
name|d_partitions
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|pp
operator|=
operator|&
name|lp
operator|->
name|d_partitions
index|[
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|>=
literal|'a'
operator|&&
operator|*
name|cp
operator|<=
literal|'h'
condition|)
block|{
name|pp
operator|=
operator|&
name|lp
operator|->
name|d_partitions
index|[
operator|*
name|cp
operator|-
literal|'a'
index|]
expr_stmt|;
block|}
else|else
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown device"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check if that partition looks suited for growing a file system. 	 */
if|if
condition|(
name|pp
operator|->
name|p_size
operator|<
literal|1
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"partition is unavailable"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|p_fstype
operator|!=
name|FS_BSDFFS
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"partition not 4.2BSD"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Read the current superblock, and take a backup. 	 */
name|rdfs
argument_list|(
call|(
name|daddr_t
call|)
argument_list|(
name|SBOFF
operator|/
name|DEV_BSIZE
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|SBSIZE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|osblock
operator|)
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|osblock
operator|.
name|fs_magic
operator|!=
name|FS_MAGIC
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"superblock not recognized"
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|fsun1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|fsun2
argument_list|,
sizeof|sizeof
argument_list|(
name|fsun2
argument_list|)
argument_list|)
expr_stmt|;
name|DBG_OPEN
argument_list|(
literal|"/tmp/growfs.debug"
argument_list|)
expr_stmt|;
comment|/* already here we need a superblock */
name|DBG_DUMP_FS
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"old sblock"
argument_list|)
expr_stmt|;
comment|/* 	 * Determine size to grow to. Default to the full size specified in 	 * the disk label. 	 */
name|sblock
operator|.
name|fs_size
operator|=
name|dbtofsb
argument_list|(
operator|&
name|osblock
argument_list|,
name|pp
operator|->
name|p_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|size
operator|>
name|pp
operator|->
name|p_size
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"There is not enough space (%d< %d)"
argument_list|,
name|pp
operator|->
name|p_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_size
operator|=
name|dbtofsb
argument_list|(
operator|&
name|osblock
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Are we really growing ? 	 */
if|if
condition|(
name|osblock
operator|.
name|fs_size
operator|>=
name|sblock
operator|.
name|fs_size
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"we are not growing (%d->%d)"
argument_list|,
name|osblock
operator|.
name|fs_size
argument_list|,
name|sblock
operator|.
name|fs_size
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FSMAXSNAP
comment|/* 	 * Check if we find an active snapshot. 	 */
if|if
condition|(
name|ExpertFlag
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FSMAXSNAP
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sblock
operator|.
name|fs_snapinum
index|[
name|j
index|]
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"active snapshot found in filesystem\n"
literal|"	please remove all snapshots before "
literal|"using growfs\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sblock
operator|.
name|fs_snapinum
index|[
name|j
index|]
condition|)
block|{
comment|/* list is dense */
break|break;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|ExpertFlag
operator|==
literal|0
operator|&&
name|Nflag
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"We strongly recommend you to make a backup "
literal|"before growing the Filesystem\n\n"
literal|" Did you backup your data (Yes/No) ? "
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|reply
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|reply
argument_list|,
literal|"Yes\n"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n Nothing done \n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"new filesystemsize is: %d frags\n"
argument_list|,
name|sblock
operator|.
name|fs_size
argument_list|)
expr_stmt|;
comment|/* 	 * Try to access our new last block in the filesystem. Even if we 	 * later on realize we have to abort our operation, on that block 	 * there should be no data, so we can't destroy something yet. 	 */
name|wtfs
argument_list|(
operator|(
name|daddr_t
operator|)
name|pp
operator|->
name|p_size
operator|-
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|DEV_BSIZE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sblock
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
comment|/* 	 * Now calculate new superblock values and check for reasonable 	 * bound for new file system size: 	 *     fs_size:    is derived from label or user input 	 *     fs_dsize:   should get updated in the routines creating or 	 *                 updating the cylinder groups on the fly 	 *     fs_cstotal: should get updated in the routines creating or 	 *                 updating the cylinder groups 	 */
comment|/* 	 * Update the number of cylinders in the filesystem. 	 */
name|sblock
operator|.
name|fs_ncyl
operator|=
name|sblock
operator|.
name|fs_size
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
operator|/
name|sblock
operator|.
name|fs_spc
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_size
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
operator|>
name|sblock
operator|.
name|fs_ncyl
operator|*
name|sblock
operator|.
name|fs_spc
condition|)
block|{
name|sblock
operator|.
name|fs_ncyl
operator|++
expr_stmt|;
block|}
comment|/* 	 * Update the number of cylinder groups in the filesystem. 	 */
name|sblock
operator|.
name|fs_ncg
operator|=
name|sblock
operator|.
name|fs_ncyl
operator|/
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_ncyl
operator|%
name|sblock
operator|.
name|fs_cpg
condition|)
block|{
name|sblock
operator|.
name|fs_ncg
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sblock
operator|.
name|fs_size
operator|-
operator|(
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
operator|)
operator|*
name|sblock
operator|.
name|fs_fpg
operator|)
operator|<
name|sblock
operator|.
name|fs_fpg
operator|&&
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
operator|(
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
operator|)
argument_list|)
operator|-
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
operator|(
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
operator|)
argument_list|)
operator|>
operator|(
name|sblock
operator|.
name|fs_size
operator|-
operator|(
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
operator|)
operator|*
name|sblock
operator|.
name|fs_fpg
operator|)
condition|)
block|{
comment|/* 		 * The space in the new last cylinder group is too small, 		 * so revert back. 		 */
name|sblock
operator|.
name|fs_ncg
operator|--
expr_stmt|;
if|#
directive|if
literal|1
comment|/* this is a bit more safe */
name|sblock
operator|.
name|fs_ncyl
operator|=
name|sblock
operator|.
name|fs_ncg
operator|*
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
else|#
directive|else
name|sblock
operator|.
name|fs_ncyl
operator|-=
name|sblock
operator|.
name|fs_ncyl
operator|%
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
endif|#
directive|endif
name|sblock
operator|.
name|fs_ncyl
operator|-=
name|sblock
operator|.
name|fs_ncyl
operator|%
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
name|printf
argument_list|(
literal|"Warning: %d sector(s) cannot be allocated.\n"
argument_list|,
operator|(
name|sblock
operator|.
name|fs_size
operator|-
operator|(
name|sblock
operator|.
name|fs_ncg
operator|)
operator|*
name|sblock
operator|.
name|fs_fpg
operator|)
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_size
operator|=
name|sblock
operator|.
name|fs_ncyl
operator|*
name|sblock
operator|.
name|fs_spc
operator|/
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update the space for the cylinder group summary information in the 	 * respective cylinder group data area. 	 */
name|sblock
operator|.
name|fs_cssize
operator|=
name|fragroundup
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_ncg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|csum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|osblock
operator|.
name|fs_size
operator|>=
name|sblock
operator|.
name|fs_size
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"not enough new space"
argument_list|)
expr_stmt|;
block|}
name|DBG_PRINT0
argument_list|(
literal|"sblock calculated\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Ok, everything prepared, so now let's do the tricks. 	 */
name|growfs
argument_list|(
name|fsi
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
comment|/* 	 * Update the disk label. 	 */
name|pp
operator|->
name|p_fsize
operator|=
name|sblock
operator|.
name|fs_fsize
expr_stmt|;
name|pp
operator|->
name|p_frag
operator|=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|pp
operator|->
name|p_cpg
operator|=
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
name|return_disklabel
argument_list|(
name|fso
argument_list|,
name|lp
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"label rewritten\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|fso
operator|>
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fso
argument_list|)
expr_stmt|;
name|DBG_CLOSE
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ************************************************** return_disklabel ***** */
end_comment

begin_comment
comment|/*  * Write the updated disklabel back to disk.  */
end_comment

begin_function
specifier|static
name|void
name|return_disklabel
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|disklabel
modifier|*
name|lp
parameter_list|,
name|unsigned
name|int
name|Nflag
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"return_disklabel"
argument_list|)
name|u_short
name|sum
decl_stmt|;
name|u_short
modifier|*
name|ptr
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
if|if
condition|(
operator|!
name|lp
condition|)
block|{
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|Nflag
condition|)
block|{
name|lp
operator|->
name|d_checksum
operator|=
literal|0
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
operator|(
name|u_short
operator|*
operator|)
name|lp
expr_stmt|;
comment|/* 		 * recalculate checksum 		 */
while|while
condition|(
name|ptr
operator|<
operator|(
name|u_short
operator|*
operator|)
operator|&
name|lp
operator|->
name|d_partitions
index|[
name|lp
operator|->
name|d_npartitions
index|]
condition|)
block|{
name|sum
operator|^=
operator|*
name|ptr
operator|++
expr_stmt|;
block|}
name|lp
operator|->
name|d_checksum
operator|=
name|sum
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|DIOCWDINFO
argument_list|,
operator|(
name|char
operator|*
operator|)
name|lp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"DIOCWDINFO failed"
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return ;
block|}
end_function

begin_comment
comment|/* ***************************************************** get_disklabel ***** */
end_comment

begin_comment
comment|/*  * Read the disklabel from disk.  */
end_comment

begin_function
specifier|static
name|struct
name|disklabel
modifier|*
name|get_disklabel
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"get_disklabel"
argument_list|)
specifier|static
name|struct
name|disklabel
modifier|*
name|lab
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
name|lab
operator|=
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|disklabel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lab
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|DIOCGDINFO
argument_list|,
operator|(
name|char
operator|*
operator|)
name|lab
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"DIOCGDINFO failed"
argument_list|)
expr_stmt|;
block|}
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
name|lab
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************************************* usage ***** */
end_comment

begin_comment
comment|/*  * Dump a line of usage.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"usage"
argument_list|)
name|DBG_ENTER
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: growfs [-Ny] [-s size] special\n"
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* *********************************************************** updclst ***** */
end_comment

begin_comment
comment|/*  * This updates most paramters and the bitmap related to cluster. We have to  * assume, that sblock, osblock, acg are set up.  */
end_comment

begin_function
specifier|static
name|void
name|updclst
parameter_list|(
name|int
name|block
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"updclst"
argument_list|)
specifier|static
name|int
name|lcs
init|=
literal|0
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|<
literal|1
condition|)
block|{
comment|/* no clustering */
return|return;
block|}
comment|/* 	 * update cluster allocation map 	 */
name|setbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|/* 	 * update cluster summary table 	 */
if|if
condition|(
operator|!
name|lcs
condition|)
block|{
comment|/* 		 * calculate size for the trailing cluster 		 */
for|for
control|(
name|block
operator|--
init|;
name|lcs
operator|<
name|sblock
operator|.
name|fs_contigsumsize
condition|;
name|block
operator|--
operator|,
name|lcs
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|block
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
name|lcs
operator|<
name|sblock
operator|.
name|fs_contigsumsize
condition|)
block|{
if|if
condition|(
name|lcs
condition|)
block|{
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs
index|]
operator|--
expr_stmt|;
block|}
name|lcs
operator|++
expr_stmt|;
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs
index|]
operator|++
expr_stmt|;
block|}
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* *********************************************************** updrefs ***** */
end_comment

begin_comment
comment|/*  * This updates all references to relocated blocks for the given inode.  The  * inode is given as number within the cylinder group, and the number of the  * cylinder group.  */
end_comment

begin_function
specifier|static
name|void
name|updrefs
parameter_list|(
name|int
name|cg
parameter_list|,
name|ino_t
name|in
parameter_list|,
name|struct
name|gfs_bpp
modifier|*
name|bp
parameter_list|,
name|int
name|fsi
parameter_list|,
name|int
name|fso
parameter_list|,
name|unsigned
name|int
name|Nflag
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"updrefs"
argument_list|)
name|unsigned
name|int
name|ictr
decl_stmt|,
name|ind2ctr
decl_stmt|,
name|ind3ctr
decl_stmt|;
name|ufs_daddr_t
modifier|*
name|iptr
decl_stmt|,
modifier|*
name|ind2ptr
decl_stmt|,
modifier|*
name|ind3ptr
decl_stmt|;
name|struct
name|dinode
modifier|*
name|ino
decl_stmt|;
name|int
name|remaining_blocks
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
comment|/* 	 * XXX We should skip unused inodes even from beeing read from disk 	 *     here by using the bitmap. 	 */
name|ino
operator|=
name|ginode
argument_list|(
name|in
argument_list|,
name|fsi
argument_list|,
name|cg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|ino
operator|->
name|di_mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
operator|||
operator|(
name|ino
operator|->
name|di_mode
operator|&
name|IFMT
operator|)
operator|==
name|IFREG
operator|||
operator|(
name|ino
operator|->
name|di_mode
operator|&
name|IFMT
operator|)
operator|==
name|IFLNK
operator|)
condition|)
block|{
name|DBG_LEAVE
expr_stmt|;
return|return;
comment|/* only check DIR, FILE, LINK */
block|}
if|if
condition|(
operator|(
operator|(
name|ino
operator|->
name|di_mode
operator|&
name|IFMT
operator|)
operator|==
name|IFLNK
operator|)
operator|&&
operator|(
name|ino
operator|->
name|di_size
operator|<
name|MAXSYMLINKLEN
operator|)
condition|)
block|{
name|DBG_LEAVE
expr_stmt|;
return|return;
comment|/* skip short symlinks */
block|}
if|if
condition|(
operator|!
name|ino
operator|->
name|di_size
condition|)
block|{
name|DBG_LEAVE
expr_stmt|;
return|return;
comment|/* skip empty file */
block|}
if|if
condition|(
operator|!
name|ino
operator|->
name|di_blocks
condition|)
block|{
name|DBG_LEAVE
expr_stmt|;
return|return;
comment|/* skip empty swiss cheesy file or old fastlink */
block|}
name|DBG_PRINT2
argument_list|(
literal|"scg checking inode (%d in %d)\n"
argument_list|,
name|in
argument_list|,
name|cg
argument_list|)
expr_stmt|;
comment|/* 	 * Start checking all direct blocks. 	 */
name|remaining_blocks
operator|=
name|howmany
argument_list|(
name|ino
operator|->
name|di_size
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
for|for
control|(
name|ictr
operator|=
literal|0
init|;
name|ictr
operator|<
name|MIN
argument_list|(
name|NDADDR
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|remaining_blocks
argument_list|)
condition|;
name|ictr
operator|++
control|)
block|{
name|iptr
operator|=
operator|&
operator|(
name|ino
operator|->
name|di_db
index|[
name|ictr
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|iptr
condition|)
block|{
name|cond_bl_upd
argument_list|(
name|iptr
argument_list|,
name|bp
argument_list|,
name|GFS_PS_INODE
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
block|}
block|}
name|DBG_PRINT0
argument_list|(
literal|"~~scg direct blocks checked\n"
argument_list|)
expr_stmt|;
name|remaining_blocks
operator|-=
name|NDADDR
expr_stmt|;
if|if
condition|(
name|remaining_blocks
operator|<
literal|0
condition|)
block|{
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ino
operator|->
name|di_ib
index|[
literal|0
index|]
condition|)
block|{
comment|/* 		 * Start checking first indirect block 		 */
name|cond_bl_upd
argument_list|(
operator|&
operator|(
name|ino
operator|->
name|di_ib
index|[
literal|0
index|]
operator|)
argument_list|,
name|bp
argument_list|,
name|GFS_PS_INODE
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|i1_src
operator|=
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|ino
operator|->
name|di_ib
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rdfs
argument_list|(
name|i1_src
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|i1blk
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
for|for
control|(
name|ictr
operator|=
literal|0
init|;
name|ictr
operator|<
name|MIN
argument_list|(
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_bsize
argument_list|,
sizeof|sizeof
argument_list|(
name|ufs_daddr_t
argument_list|)
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|remaining_blocks
argument_list|)
condition|;
name|ictr
operator|++
control|)
block|{
name|iptr
operator|=
operator|&
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|i1blk
operator|)
index|[
name|ictr
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|iptr
condition|)
block|{
name|cond_bl_upd
argument_list|(
name|iptr
argument_list|,
name|bp
argument_list|,
name|GFS_PS_IND_BLK_LVL1
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|DBG_PRINT0
argument_list|(
literal|"scg indirect_1 blocks checked\n"
argument_list|)
expr_stmt|;
name|remaining_blocks
operator|-=
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_bsize
argument_list|,
sizeof|sizeof
argument_list|(
name|ufs_daddr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|remaining_blocks
operator|<
literal|0
condition|)
block|{
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ino
operator|->
name|di_ib
index|[
literal|1
index|]
condition|)
block|{
comment|/* 		 * Start checking second indirect block 		 */
name|cond_bl_upd
argument_list|(
operator|&
operator|(
name|ino
operator|->
name|di_ib
index|[
literal|1
index|]
operator|)
argument_list|,
name|bp
argument_list|,
name|GFS_PS_INODE
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|i2_src
operator|=
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|ino
operator|->
name|di_ib
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rdfs
argument_list|(
name|i2_src
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|i2blk
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
for|for
control|(
name|ind2ctr
operator|=
literal|0
init|;
name|ind2ctr
operator|<
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_bsize
argument_list|,
sizeof|sizeof
argument_list|(
name|ufs_daddr_t
argument_list|)
argument_list|)
condition|;
name|ind2ctr
operator|++
control|)
block|{
name|ind2ptr
operator|=
operator|&
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|i2blk
operator|)
index|[
name|ind2ctr
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ind2ptr
condition|)
block|{
continue|continue;
block|}
name|cond_bl_upd
argument_list|(
name|ind2ptr
argument_list|,
name|bp
argument_list|,
name|GFS_PS_IND_BLK_LVL2
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|i1_src
operator|=
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
operator|*
name|ind2ptr
argument_list|)
expr_stmt|;
name|rdfs
argument_list|(
name|i1_src
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|i1blk
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
for|for
control|(
name|ictr
operator|=
literal|0
init|;
name|ictr
operator|<
name|MIN
argument_list|(
name|howmany
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|sblock
operator|.
name|fs_bsize
argument_list|,
sizeof|sizeof
argument_list|(
name|ufs_daddr_t
argument_list|)
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|remaining_blocks
argument_list|)
condition|;
name|ictr
operator|++
control|)
block|{
name|iptr
operator|=
operator|&
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|i1blk
operator|)
index|[
name|ictr
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|iptr
condition|)
block|{
name|cond_bl_upd
argument_list|(
name|iptr
argument_list|,
name|bp
argument_list|,
name|GFS_PS_IND_BLK_LVL1
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|DBG_PRINT0
argument_list|(
literal|"scg indirect_2 blocks checked\n"
argument_list|)
expr_stmt|;
define|#
directive|define
name|SQUARE
parameter_list|(
name|a
parameter_list|)
value|((a)*(a))
name|remaining_blocks
operator|-=
name|SQUARE
argument_list|(
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_bsize
argument_list|,
sizeof|sizeof
argument_list|(
name|ufs_daddr_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SQUARE
if|if
condition|(
name|remaining_blocks
operator|<
literal|0
condition|)
block|{
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ino
operator|->
name|di_ib
index|[
literal|2
index|]
condition|)
block|{
comment|/* 		 * Start checking third indirect block 		 */
name|cond_bl_upd
argument_list|(
operator|&
operator|(
name|ino
operator|->
name|di_ib
index|[
literal|2
index|]
operator|)
argument_list|,
name|bp
argument_list|,
name|GFS_PS_INODE
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|i3_src
operator|=
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|ino
operator|->
name|di_ib
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|rdfs
argument_list|(
name|i3_src
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|i3blk
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
for|for
control|(
name|ind3ctr
operator|=
literal|0
init|;
name|ind3ctr
operator|<
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_bsize
argument_list|,
sizeof|sizeof
argument_list|(
name|ufs_daddr_t
argument_list|)
argument_list|)
condition|;
name|ind3ctr
operator|++
control|)
block|{
name|ind3ptr
operator|=
operator|&
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|i3blk
operator|)
index|[
name|ind3ctr
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ind3ptr
condition|)
block|{
continue|continue;
block|}
name|cond_bl_upd
argument_list|(
name|ind3ptr
argument_list|,
name|bp
argument_list|,
name|GFS_PS_IND_BLK_LVL3
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|i2_src
operator|=
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
operator|*
name|ind3ptr
argument_list|)
expr_stmt|;
name|rdfs
argument_list|(
name|i2_src
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|i2blk
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
for|for
control|(
name|ind2ctr
operator|=
literal|0
init|;
name|ind2ctr
operator|<
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_bsize
argument_list|,
sizeof|sizeof
argument_list|(
name|ufs_daddr_t
argument_list|)
argument_list|)
condition|;
name|ind2ctr
operator|++
control|)
block|{
name|ind2ptr
operator|=
operator|&
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|i2blk
operator|)
index|[
name|ind2ctr
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ind2ptr
condition|)
block|{
continue|continue;
block|}
name|cond_bl_upd
argument_list|(
name|ind2ptr
argument_list|,
name|bp
argument_list|,
name|GFS_PS_IND_BLK_LVL2
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|i1_src
operator|=
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
operator|*
name|ind2ptr
argument_list|)
expr_stmt|;
name|rdfs
argument_list|(
name|i1_src
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|i1blk
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
for|for
control|(
name|ictr
operator|=
literal|0
init|;
name|ictr
operator|<
name|MIN
argument_list|(
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_bsize
argument_list|,
sizeof|sizeof
argument_list|(
name|ufs_daddr_t
argument_list|)
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|remaining_blocks
argument_list|)
condition|;
name|ictr
operator|++
control|)
block|{
name|iptr
operator|=
operator|&
operator|(
operator|(
name|ufs_daddr_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|i1blk
operator|)
index|[
name|ictr
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|iptr
condition|)
block|{
name|cond_bl_upd
argument_list|(
name|iptr
argument_list|,
name|bp
argument_list|,
name|GFS_PS_IND_BLK_LVL1
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|DBG_PRINT0
argument_list|(
literal|"scg indirect_3 blocks checked\n"
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

end_unit

