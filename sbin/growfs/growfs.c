begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980, 1989, 1993 The Regents of the University of California.  * Copyright (c) 2000 Christoph Herrmann, Thomas-Henning von Kamptz  * Copyright (c) 2012 The FreeBSD Foundation  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Christoph Herrmann and Thomas-Henning von Kamptz, Munich and Frankfurt.  *  * Portions of this software were developed by Edward Tomasz Napierala  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors, as well as Christoph  *      Herrmann and Thomas-Henning von Kamptz.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $TSHeader: src/sbin/growfs/growfs.c,v 1.5 2000/12/12 19:31:00 tomsoft Exp $  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 2000 Christoph Herrmann, Thomas-Henning von Kamptz\n\ Copyright (c) 1980, 1989, 1993 The Regents of the University of California.\n\ All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<fstab.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<mntopts.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FS_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|_dbg_lvl_
init|=
operator|(
name|DL_INFO
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DL_TRC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FS_DEBUG */
end_comment

begin_union
specifier|static
union|union
block|{
name|struct
name|fs
name|fs
decl_stmt|;
name|char
name|pad
index|[
name|SBLOCKSIZE
index|]
decl_stmt|;
block|}
name|fsun1
union|,
name|fsun2
union|;
end_union

begin_define
define|#
directive|define
name|sblock
value|fsun1.fs
end_define

begin_comment
comment|/* the new superblock */
end_comment

begin_define
define|#
directive|define
name|osblock
value|fsun2.fs
end_define

begin_comment
comment|/* the old superblock */
end_comment

begin_comment
comment|/*  * Possible superblock locations ordered from most to least likely.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sblock_try
index|[]
init|=
name|SBLOCKSEARCH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ufs2_daddr_t
name|sblockloc
decl_stmt|;
end_decl_stmt

begin_union
specifier|static
union|union
block|{
name|struct
name|cg
name|cg
decl_stmt|;
name|char
name|pad
index|[
name|MAXBSIZE
index|]
decl_stmt|;
block|}
name|cgun1
union|,
name|cgun2
union|;
end_union

begin_define
define|#
directive|define
name|acg
value|cgun1.cg
end_define

begin_comment
comment|/* a cylinder cgroup (new) */
end_comment

begin_define
define|#
directive|define
name|aocg
value|cgun2.cg
end_define

begin_comment
comment|/* an old cylinder group */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|csum
modifier|*
name|fscs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cylinder summary */
end_comment

begin_function_decl
specifier|static
name|void
name|growfs
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdfs
parameter_list|(
name|ufs2_daddr_t
parameter_list|,
name|size_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wtfs
parameter_list|(
name|ufs2_daddr_t
parameter_list|,
name|size_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|charsperline
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isblock
parameter_list|(
name|struct
name|fs
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clrblock
parameter_list|(
name|struct
name|fs
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setblock
parameter_list|(
name|struct
name|fs
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initcg
parameter_list|(
name|int
parameter_list|,
name|time_t
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|updjcg
parameter_list|(
name|int
parameter_list|,
name|time_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|updcsloc
parameter_list|(
name|time_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|frag_adjust
parameter_list|(
name|ufs2_daddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|updclst
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mount_reload
parameter_list|(
specifier|const
name|struct
name|statfs
modifier|*
name|stfs
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Here we actually start growing the file system. We basically read the  * cylinder summary from the first cylinder group as we want to update  * this on the fly during our various operations. First we handle the  * changes in the former last cylinder group. Afterwards we create all new  * cylinder groups.  Now we handle the cylinder group containing the  * cylinder summary which might result in a relocation of the whole  * structure.  In the end we write back the updated cylinder summary, the  * new superblock, and slightly patched versions of the super block  * copies.  */
end_comment

begin_function
specifier|static
name|void
name|growfs
parameter_list|(
name|int
name|fsi
parameter_list|,
name|int
name|fso
parameter_list|,
name|unsigned
name|int
name|Nflag
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"growfs"
argument_list|)
name|time_t
name|modtime
decl_stmt|;
name|uint
name|cylno
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|width
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|100
index|]
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
name|time
argument_list|(
operator|&
name|modtime
argument_list|)
expr_stmt|;
comment|/* 	 * Get the cylinder summary into the memory. 	 */
name|fscs
operator|=
operator|(
expr|struct
name|csum
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|size_t
operator|)
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_cssize
argument_list|)
expr_stmt|;
if|if
condition|(
name|fscs
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"calloc failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|osblock
operator|.
name|fs_cssize
condition|;
name|i
operator|+=
name|osblock
operator|.
name|fs_bsize
control|)
block|{
name|rdfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|osblock
argument_list|,
name|osblock
operator|.
name|fs_csaddr
operator|+
name|numfrags
argument_list|(
operator|&
name|osblock
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|MIN
argument_list|(
name|osblock
operator|.
name|fs_cssize
operator|-
name|i
argument_list|,
name|osblock
operator|.
name|fs_bsize
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|fscs
operator|)
operator|+
name|i
operator|)
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FS_DEBUG
block|{
name|struct
name|csum
modifier|*
name|dbg_csp
decl_stmt|;
name|int
name|dbg_csc
decl_stmt|;
name|char
name|dbg_line
index|[
literal|80
index|]
decl_stmt|;
name|dbg_csp
operator|=
name|fscs
expr_stmt|;
for|for
control|(
name|dbg_csc
operator|=
literal|0
init|;
name|dbg_csc
operator|<
name|osblock
operator|.
name|fs_ncg
condition|;
name|dbg_csc
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|dbg_line
argument_list|,
sizeof|sizeof
argument_list|(
name|dbg_line
argument_list|)
argument_list|,
literal|"%d. old csum in old location"
argument_list|,
name|dbg_csc
argument_list|)
expr_stmt|;
name|DBG_DUMP_CSUM
argument_list|(
operator|&
name|osblock
argument_list|,
name|dbg_line
argument_list|,
name|dbg_csp
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* FS_DEBUG */
name|DBG_PRINT0
argument_list|(
literal|"fscs read\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Do all needed changes in the former last cylinder group. 	 */
name|updjcg
argument_list|(
name|osblock
operator|.
name|fs_ncg
operator|-
literal|1
argument_list|,
name|modtime
argument_list|,
name|fsi
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
comment|/* 	 * Dump out summary information about file system. 	 */
ifdef|#
directive|ifdef
name|FS_DEBUG
define|#
directive|define
name|B2MBFACTOR
value|(1 / (1024.0 * 1024.0))
name|printf
argument_list|(
literal|"growfs: %.1fMB (%jd sectors) block size %d, fragment size %d\n"
argument_list|,
operator|(
name|float
operator|)
name|sblock
operator|.
name|fs_size
operator|*
name|sblock
operator|.
name|fs_fsize
operator|*
name|B2MBFACTOR
argument_list|,
operator|(
name|intmax_t
operator|)
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_size
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tusing %d cylinder groups of %.2fMB, %d blks, %d inodes.\n"
argument_list|,
name|sblock
operator|.
name|fs_ncg
argument_list|,
operator|(
name|float
operator|)
name|sblock
operator|.
name|fs_fpg
operator|*
name|sblock
operator|.
name|fs_fsize
operator|*
name|B2MBFACTOR
argument_list|,
name|sblock
operator|.
name|fs_fpg
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|,
name|sblock
operator|.
name|fs_ipg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_flags
operator|&
name|FS_DOSOFTDEP
condition|)
name|printf
argument_list|(
literal|"\twith soft updates\n"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|B2MBFACTOR
endif|#
directive|endif
comment|/* FS_DEBUG */
comment|/* 	 * Now build the cylinders group blocks and 	 * then print out indices of cylinder groups. 	 */
name|printf
argument_list|(
literal|"super-block backups (for fsck_ffs -b #) at:\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|width
operator|=
name|charsperline
argument_list|()
expr_stmt|;
comment|/* 	 * Iterate for only the new cylinder groups. 	 */
for|for
control|(
name|cylno
operator|=
name|osblock
operator|.
name|fs_ncg
init|;
name|cylno
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|cylno
operator|++
control|)
block|{
name|initcg
argument_list|(
name|cylno
argument_list|,
name|modtime
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|j
operator|=
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|" %jd%s"
argument_list|,
operator|(
name|intmax_t
operator|)
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
argument_list|,
name|cylno
operator|<
operator|(
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
operator|)
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|j
operator|>=
name|width
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|+=
name|j
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Do all needed changes in the first cylinder group. 	 * allocate blocks in new location 	 */
name|updcsloc
argument_list|(
name|modtime
argument_list|,
name|fsi
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
comment|/* 	 * Now write the cylinder summary back to disk. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_cssize
condition|;
name|i
operator|+=
name|sblock
operator|.
name|fs_bsize
control|)
block|{
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_csaddr
operator|+
name|numfrags
argument_list|(
operator|&
name|sblock
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|MIN
argument_list|(
name|sblock
operator|.
name|fs_cssize
operator|-
name|i
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|fscs
operator|)
operator|+
name|i
operator|)
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
block|}
name|DBG_PRINT0
argument_list|(
literal|"fscs written\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FS_DEBUG
block|{
name|struct
name|csum
modifier|*
name|dbg_csp
decl_stmt|;
name|int
name|dbg_csc
decl_stmt|;
name|char
name|dbg_line
index|[
literal|80
index|]
decl_stmt|;
name|dbg_csp
operator|=
name|fscs
expr_stmt|;
for|for
control|(
name|dbg_csc
operator|=
literal|0
init|;
name|dbg_csc
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|dbg_csc
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|dbg_line
argument_list|,
sizeof|sizeof
argument_list|(
name|dbg_line
argument_list|)
argument_list|,
literal|"%d. new csum in new location"
argument_list|,
name|dbg_csc
argument_list|)
expr_stmt|;
name|DBG_DUMP_CSUM
argument_list|(
operator|&
name|sblock
argument_list|,
name|dbg_line
argument_list|,
name|dbg_csp
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* FS_DEBUG */
comment|/* 	 * Now write the new superblock back to disk. 	 */
name|sblock
operator|.
name|fs_time
operator|=
name|modtime
expr_stmt|;
name|wtfs
argument_list|(
name|sblockloc
argument_list|,
operator|(
name|size_t
operator|)
name|SBLOCKSIZE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sblock
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"sblock written\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_FS
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"new initial sblock"
argument_list|)
expr_stmt|;
comment|/* 	 * Clean up the dynamic fields in our superblock copies. 	 */
name|sblock
operator|.
name|fs_fmod
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_clean
operator|=
literal|1
expr_stmt|;
name|sblock
operator|.
name|fs_ronly
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_cgrotor
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_state
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|sblock
operator|.
name|fs_fsmnt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sblock
operator|.
name|fs_fsmnt
argument_list|)
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_flags
operator|&=
name|FS_DOSOFTDEP
expr_stmt|;
comment|/* 	 * XXX 	 * The following fields are currently distributed from the superblock 	 * to the copies: 	 *     fs_minfree 	 *     fs_rotdelay 	 *     fs_maxcontig 	 *     fs_maxbpg 	 *     fs_minfree, 	 *     fs_optim 	 *     fs_flags regarding SOFTPDATES 	 * 	 * We probably should rather change the summary for the cylinder group 	 * statistics here to the value of what would be in there, if the file 	 * system were created initially with the new size. Therefor we still 	 * need to find an easy way of calculating that. 	 * Possibly we can try to read the first superblock copy and apply the 	 * "diffed" stats between the old and new superblock by still copying 	 * certain parameters onto that. 	 */
comment|/* 	 * Write out the duplicate super blocks. 	 */
for|for
control|(
name|cylno
operator|=
literal|0
init|;
name|cylno
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|cylno
operator|++
control|)
block|{
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|SBLOCKSIZE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sblock
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
block|}
name|DBG_PRINT0
argument_list|(
literal|"sblock copies written\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_FS
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"new other sblocks"
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This creates a new cylinder group structure, for more details please see  * the source of newfs(8), as this function is taken over almost unchanged.  * As this is never called for the first cylinder group, the special  * provisions for that case are removed here.  */
end_comment

begin_function
specifier|static
name|void
name|initcg
parameter_list|(
name|int
name|cylno
parameter_list|,
name|time_t
name|modtime
parameter_list|,
name|int
name|fso
parameter_list|,
name|unsigned
name|int
name|Nflag
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"initcg"
argument_list|)
specifier|static
name|caddr_t
name|iobuf
decl_stmt|;
name|long
name|blkno
decl_stmt|,
name|start
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|ufs2_daddr_t
name|i
decl_stmt|,
name|cbase
decl_stmt|,
name|dmax
decl_stmt|;
name|struct
name|ufs1_dinode
modifier|*
name|dp1
decl_stmt|;
name|struct
name|csum
modifier|*
name|cs
decl_stmt|;
name|uint
name|j
decl_stmt|,
name|d
decl_stmt|,
name|dupper
decl_stmt|,
name|dlower
decl_stmt|;
if|if
condition|(
name|iobuf
operator|==
name|NULL
operator|&&
operator|(
name|iobuf
operator|=
name|malloc
argument_list|(
name|sblock
operator|.
name|fs_bsize
operator|*
literal|3
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|37
argument_list|,
literal|"panic: cannot allocate I/O buffer"
argument_list|)
expr_stmt|;
comment|/* 	 * Determine block bounds for cylinder group. 	 * Allow space for super block summary information in first 	 * cylinder group. 	 */
name|cbase
operator|=
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
expr_stmt|;
name|dmax
operator|=
name|cbase
operator|+
name|sblock
operator|.
name|fs_fpg
expr_stmt|;
if|if
condition|(
name|dmax
operator|>
name|sblock
operator|.
name|fs_size
condition|)
name|dmax
operator|=
name|sblock
operator|.
name|fs_size
expr_stmt|;
name|dlower
operator|=
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
operator|-
name|cbase
expr_stmt|;
name|dupper
operator|=
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
operator|-
name|cbase
expr_stmt|;
if|if
condition|(
name|cylno
operator|==
literal|0
condition|)
comment|/* XXX fscs may be relocated */
name|dupper
operator|+=
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
name|cs
operator|=
operator|&
name|fscs
index|[
name|cylno
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|acg
argument_list|,
literal|0
argument_list|,
name|sblock
operator|.
name|fs_cgsize
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_time
operator|=
name|modtime
expr_stmt|;
name|acg
operator|.
name|cg_magic
operator|=
name|CG_MAGIC
expr_stmt|;
name|acg
operator|.
name|cg_cgx
operator|=
name|cylno
expr_stmt|;
name|acg
operator|.
name|cg_niblk
operator|=
name|sblock
operator|.
name|fs_ipg
expr_stmt|;
name|acg
operator|.
name|cg_initediblk
operator|=
name|sblock
operator|.
name|fs_ipg
operator|<
literal|2
operator|*
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
condition|?
name|sblock
operator|.
name|fs_ipg
else|:
literal|2
operator|*
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_ndblk
operator|=
name|dmax
operator|-
name|cbase
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
name|acg
operator|.
name|cg_nclusterblks
operator|=
name|acg
operator|.
name|cg_ndblk
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|start
operator|=
operator|&
name|acg
operator|.
name|cg_space
index|[
literal|0
index|]
operator|-
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|acg
operator|.
name|cg_firstfield
operator|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_magic
operator|==
name|FS_UFS2_MAGIC
condition|)
block|{
name|acg
operator|.
name|cg_iusedoff
operator|=
name|start
expr_stmt|;
block|}
else|else
block|{
name|acg
operator|.
name|cg_old_ncyl
operator|=
name|sblock
operator|.
name|fs_old_cpg
expr_stmt|;
name|acg
operator|.
name|cg_old_time
operator|=
name|acg
operator|.
name|cg_time
expr_stmt|;
name|acg
operator|.
name|cg_time
operator|=
literal|0
expr_stmt|;
name|acg
operator|.
name|cg_old_niblk
operator|=
name|acg
operator|.
name|cg_niblk
expr_stmt|;
name|acg
operator|.
name|cg_niblk
operator|=
literal|0
expr_stmt|;
name|acg
operator|.
name|cg_initediblk
operator|=
literal|0
expr_stmt|;
name|acg
operator|.
name|cg_old_btotoff
operator|=
name|start
expr_stmt|;
name|acg
operator|.
name|cg_old_boff
operator|=
name|acg
operator|.
name|cg_old_btotoff
operator|+
name|sblock
operator|.
name|fs_old_cpg
operator|*
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_iusedoff
operator|=
name|acg
operator|.
name|cg_old_boff
operator|+
name|sblock
operator|.
name|fs_old_cpg
operator|*
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
block|}
name|acg
operator|.
name|cg_freeoff
operator|=
name|acg
operator|.
name|cg_iusedoff
operator|+
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_ipg
argument_list|,
name|CHAR_BIT
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_nextfreeoff
operator|=
name|acg
operator|.
name|cg_freeoff
operator|+
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_fpg
argument_list|,
name|CHAR_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|acg
operator|.
name|cg_clustersumoff
operator|=
name|roundup
argument_list|(
name|acg
operator|.
name|cg_nextfreeoff
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_clustersumoff
operator|-=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_clusteroff
operator|=
name|acg
operator|.
name|cg_clustersumoff
operator|+
operator|(
name|sblock
operator|.
name|fs_contigsumsize
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_nextfreeoff
operator|=
name|acg
operator|.
name|cg_clusteroff
operator|+
name|howmany
argument_list|(
name|fragstoblks
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_fpg
argument_list|)
argument_list|,
name|CHAR_BIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acg
operator|.
name|cg_nextfreeoff
operator|>
operator|(
name|unsigned
operator|)
name|sblock
operator|.
name|fs_cgsize
condition|)
block|{
comment|/* 		 * This should never happen as we would have had that panic 		 * already on file system creation 		 */
name|errx
argument_list|(
literal|37
argument_list|,
literal|"panic: cylinder group too big"
argument_list|)
expr_stmt|;
block|}
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|+=
name|sblock
operator|.
name|fs_ipg
expr_stmt|;
if|if
condition|(
name|cylno
operator|==
literal|0
condition|)
for|for
control|(
name|ino
operator|=
literal|0
init|;
name|ino
operator|<
name|ROOTINO
condition|;
name|ino
operator|++
control|)
block|{
name|setbit
argument_list|(
name|cg_inosused
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|--
expr_stmt|;
block|}
comment|/* 	 * For the old file system, we have to initialize all the inodes. 	 */
if|if
condition|(
name|sblock
operator|.
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
block|{
name|bzero
argument_list|(
name|iobuf
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_ipg
operator|/
name|INOPF
argument_list|(
operator|&
name|sblock
argument_list|)
condition|;
name|i
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|dp1
operator|=
operator|(
expr|struct
name|ufs1_dinode
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|iobuf
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|dp1
operator|->
name|di_gen
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|dp1
operator|++
expr_stmt|;
block|}
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgimin
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
operator|+
name|i
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
name|iobuf
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cylno
operator|>
literal|0
condition|)
block|{
comment|/* 		 * In cylno 0, beginning space is reserved 		 * for boot and super blocks. 		 */
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|dlower
condition|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|blkno
operator|=
name|d
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|setblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
name|setbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_dsize
operator|+=
name|dlower
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_dsize
operator|+=
name|acg
operator|.
name|cg_ndblk
operator|-
name|dupper
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|dupper
operator|%
name|sblock
operator|.
name|fs_frag
operator|)
condition|)
block|{
name|acg
operator|.
name|cg_frsum
index|[
name|sblock
operator|.
name|fs_frag
operator|-
name|i
index|]
operator|++
expr_stmt|;
for|for
control|(
name|d
operator|=
name|dupper
operator|+
name|sblock
operator|.
name|fs_frag
operator|-
name|i
init|;
name|dupper
operator|<
name|d
condition|;
name|dupper
operator|++
control|)
block|{
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|dupper
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|d
operator|=
name|dupper
init|;
name|d
operator|+
name|sblock
operator|.
name|fs_frag
operator|<=
name|acg
operator|.
name|cg_ndblk
condition|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|blkno
operator|=
name|d
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|setblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
name|setbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|<
name|acg
operator|.
name|cg_ndblk
condition|)
block|{
name|acg
operator|.
name|cg_frsum
index|[
name|acg
operator|.
name|cg_ndblk
operator|-
name|d
index|]
operator|++
expr_stmt|;
for|for
control|(
init|;
name|d
operator|<
name|acg
operator|.
name|cg_ndblk
condition|;
name|d
operator|++
control|)
block|{
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|int32_t
modifier|*
name|sump
init|=
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
decl_stmt|;
name|u_char
modifier|*
name|mapp
init|=
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
decl_stmt|;
name|int
name|map
init|=
operator|*
name|mapp
operator|++
decl_stmt|;
name|int
name|bit
init|=
literal|1
decl_stmt|;
name|int
name|run
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acg
operator|.
name|cg_nclusterblks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|map
operator|&
name|bit
operator|)
operator|!=
literal|0
condition|)
name|run
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|run
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|run
operator|>
name|sblock
operator|.
name|fs_contigsumsize
condition|)
name|run
operator|=
name|sblock
operator|.
name|fs_contigsumsize
expr_stmt|;
name|sump
index|[
name|run
index|]
operator|++
expr_stmt|;
name|run
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|&
operator|(
name|CHAR_BIT
operator|-
literal|1
operator|)
operator|)
operator|!=
name|CHAR_BIT
operator|-
literal|1
condition|)
name|bit
operator|<<=
literal|1
expr_stmt|;
else|else
block|{
name|map
operator|=
operator|*
name|mapp
operator|++
expr_stmt|;
name|bit
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|run
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|run
operator|>
name|sblock
operator|.
name|fs_contigsumsize
condition|)
name|run
operator|=
name|sblock
operator|.
name|fs_contigsumsize
expr_stmt|;
name|sump
index|[
name|run
index|]
operator|++
expr_stmt|;
block|}
block|}
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_ndir
operator|+=
name|acg
operator|.
name|cg_cs
operator|.
name|cs_ndir
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|+=
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|+=
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nifree
operator|+=
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nifree
expr_stmt|;
operator|*
name|cs
operator|=
name|acg
operator|.
name|cg_cs
expr_stmt|;
name|memcpy
argument_list|(
name|iobuf
argument_list|,
operator|&
name|acg
argument_list|,
name|sblock
operator|.
name|fs_cgsize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|iobuf
operator|+
name|sblock
operator|.
name|fs_cgsize
argument_list|,
literal|'\0'
argument_list|,
name|sblock
operator|.
name|fs_bsize
operator|*
literal|3
operator|-
name|sblock
operator|.
name|fs_cgsize
argument_list|)
expr_stmt|;
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_bsize
operator|*
literal|3
argument_list|,
name|iobuf
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"new cg"
argument_list|,
operator|&
name|acg
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Here we add or subtract (sign +1/-1) the available fragments in a given  * block to or from the fragment statistics. By subtracting before and adding  * after an operation on the free frag map we can easy update the fragment  * statistic, which seems to be otherwise a rather complex operation.  */
end_comment

begin_function
specifier|static
name|void
name|frag_adjust
parameter_list|(
name|ufs2_daddr_t
name|frag
parameter_list|,
name|int
name|sign
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"frag_adjust"
argument_list|)
name|int
name|fragsize
decl_stmt|;
name|int
name|f
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
name|fragsize
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Here frag only needs to point to any fragment in the block we want 	 * to examine. 	 */
for|for
control|(
name|f
operator|=
name|rounddown
argument_list|(
name|frag
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
init|;
name|f
operator|<
name|roundup
argument_list|(
name|frag
operator|+
literal|1
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
condition|;
name|f
operator|++
control|)
block|{
comment|/* 		 * Count contiguous free fragments. 		 */
if|if
condition|(
name|isset
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|fragsize
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fragsize
operator|&&
name|fragsize
operator|<
name|sblock
operator|.
name|fs_frag
condition|)
block|{
comment|/* 				 * We found something in between. 				 */
name|acg
operator|.
name|cg_frsum
index|[
name|fragsize
index|]
operator|+=
name|sign
expr_stmt|;
name|DBG_PRINT2
argument_list|(
literal|"frag_adjust [%d]+=%d\n"
argument_list|,
name|fragsize
argument_list|,
name|sign
argument_list|)
expr_stmt|;
block|}
name|fragsize
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fragsize
operator|&&
name|fragsize
operator|<
name|sblock
operator|.
name|fs_frag
condition|)
block|{
comment|/* 		 * We found something. 		 */
name|acg
operator|.
name|cg_frsum
index|[
name|fragsize
index|]
operator|+=
name|sign
expr_stmt|;
name|DBG_PRINT2
argument_list|(
literal|"frag_adjust [%d]+=%d\n"
argument_list|,
name|fragsize
argument_list|,
name|sign
argument_list|)
expr_stmt|;
block|}
name|DBG_PRINT2
argument_list|(
literal|"frag_adjust [[%d]]+=%d\n"
argument_list|,
name|fragsize
argument_list|,
name|sign
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Here we do all needed work for the former last cylinder group. It has to be  * changed in any case, even if the file system ended exactly on the end of  * this group, as there is some slightly inconsistent handling of the number  * of cylinders in the cylinder group. We start again by reading the cylinder  * group from disk. If the last block was not fully available, we first handle  * the missing fragments, then we handle all new full blocks in that file  * system and finally we handle the new last fragmented block in the file  * system.  We again have to handle the fragment statistics rotational layout  * tables and cluster summary during all those operations.  */
end_comment

begin_function
specifier|static
name|void
name|updjcg
parameter_list|(
name|int
name|cylno
parameter_list|,
name|time_t
name|modtime
parameter_list|,
name|int
name|fsi
parameter_list|,
name|int
name|fso
parameter_list|,
name|unsigned
name|int
name|Nflag
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"updjcg"
argument_list|)
name|ufs2_daddr_t
name|cbase
decl_stmt|,
name|dmax
decl_stmt|,
name|dupper
decl_stmt|;
name|struct
name|csum
modifier|*
name|cs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
comment|/* 	 * Read the former last (joining) cylinder group from disk, and make 	 * a copy. 	 */
name|rdfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|osblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|osblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|osblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|aocg
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"jcg read\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"old joining cg"
argument_list|,
operator|&
name|aocg
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|cgun1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cgun2
argument_list|,
sizeof|sizeof
argument_list|(
name|cgun2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the cylinder group had already its new final size almost 	 * nothing is to be done ... except: 	 * For some reason the value of cg_ncyl in the last cylinder group has 	 * to be zero instead of fs_cpg. As this is now no longer the last 	 * cylinder group we have to change that value now to fs_cpg. 	 */
if|if
condition|(
name|cgbase
argument_list|(
operator|&
name|osblock
argument_list|,
name|cylno
operator|+
literal|1
argument_list|)
operator|==
name|osblock
operator|.
name|fs_size
condition|)
block|{
if|if
condition|(
name|sblock
operator|.
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|acg
operator|.
name|cg_old_ncyl
operator|=
name|sblock
operator|.
name|fs_old_cpg
expr_stmt|;
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|acg
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"jcg written\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"new joining cg"
argument_list|,
operator|&
name|acg
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set up some variables needed later. 	 */
name|cbase
operator|=
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
expr_stmt|;
name|dmax
operator|=
name|cbase
operator|+
name|sblock
operator|.
name|fs_fpg
expr_stmt|;
if|if
condition|(
name|dmax
operator|>
name|sblock
operator|.
name|fs_size
condition|)
name|dmax
operator|=
name|sblock
operator|.
name|fs_size
expr_stmt|;
name|dupper
operator|=
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
operator|-
name|cbase
expr_stmt|;
if|if
condition|(
name|cylno
operator|==
literal|0
condition|)
comment|/* XXX fscs may be relocated */
name|dupper
operator|+=
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
comment|/* 	 * Set pointer to the cylinder summary for our cylinder group. 	 */
name|cs
operator|=
name|fscs
operator|+
name|cylno
expr_stmt|;
comment|/* 	 * Touch the cylinder group, update all fields in the cylinder group as 	 * needed, update the free space in the superblock. 	 */
name|acg
operator|.
name|cg_time
operator|=
name|modtime
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|cylno
operator|==
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
condition|)
block|{
comment|/* 		 * This is still the last cylinder group. 		 */
if|if
condition|(
name|sblock
operator|.
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|acg
operator|.
name|cg_old_ncyl
operator|=
name|sblock
operator|.
name|fs_old_ncyl
operator|%
name|sblock
operator|.
name|fs_old_cpg
expr_stmt|;
block|}
else|else
block|{
name|acg
operator|.
name|cg_old_ncyl
operator|=
name|sblock
operator|.
name|fs_old_cpg
expr_stmt|;
block|}
name|DBG_PRINT2
argument_list|(
literal|"jcg dbg: %d %u"
argument_list|,
name|cylno
argument_list|,
name|sblock
operator|.
name|fs_ncg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FS_DEBUG
if|if
condition|(
name|sblock
operator|.
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|DBG_PRINT2
argument_list|(
literal|"%d %u"
argument_list|,
name|acg
operator|.
name|cg_old_ncyl
argument_list|,
name|sblock
operator|.
name|fs_old_cpg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DBG_PRINT0
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_ndblk
operator|=
name|dmax
operator|-
name|cbase
expr_stmt|;
name|sblock
operator|.
name|fs_dsize
operator|+=
name|acg
operator|.
name|cg_ndblk
operator|-
name|aocg
operator|.
name|cg_ndblk
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
name|acg
operator|.
name|cg_nclusterblks
operator|=
name|acg
operator|.
name|cg_ndblk
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
comment|/* 	 * Now we have to update the free fragment bitmap for our new free 	 * space.  There again we have to handle the fragmentation and also 	 * the rotational layout tables and the cluster summary.  This is 	 * also done per fragment for the first new block if the old file 	 * system end was not on a block boundary, per fragment for the new 	 * last block if the new file system end is not on a block boundary, 	 * and per block for all space in between. 	 * 	 * Handle the first new block here if it was partially available 	 * before. 	 */
if|if
condition|(
name|osblock
operator|.
name|fs_size
operator|%
name|sblock
operator|.
name|fs_frag
condition|)
block|{
if|if
condition|(
name|roundup
argument_list|(
name|osblock
operator|.
name|fs_size
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
operator|<=
name|sblock
operator|.
name|fs_size
condition|)
block|{
comment|/* 			 * The new space is enough to fill at least this 			 * block 			 */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|roundup
argument_list|(
name|osblock
operator|.
name|fs_size
operator|-
name|cbase
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|osblock
operator|.
name|fs_size
operator|-
name|cbase
condition|;
name|i
operator|--
control|)
block|{
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
comment|/* 			 * Check if the fragment just created could join an 			 * already existing fragment at the former end of the 			 * file system. 			 */
if|if
condition|(
name|isblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
operator|(
operator|(
name|osblock
operator|.
name|fs_size
operator|-
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
operator|)
argument_list|)
condition|)
block|{
comment|/* 				 * The block is now completely available. 				 */
name|DBG_PRINT0
argument_list|(
literal|"block was\n"
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_frsum
index|[
name|osblock
operator|.
name|fs_size
operator|%
name|sblock
operator|.
name|fs_frag
index|]
operator|--
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|-=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|k
operator|=
name|rounddown
argument_list|(
name|osblock
operator|.
name|fs_size
operator|-
name|cbase
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|updclst
argument_list|(
operator|(
name|osblock
operator|.
name|fs_size
operator|-
name|cbase
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Lets rejoin a possible partially growed 				 * fragment. 				 */
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isset
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|i
argument_list|)
operator|&&
operator|(
name|i
operator|>=
name|rounddown
argument_list|(
name|osblock
operator|.
name|fs_size
operator|-
name|cbase
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
operator|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|k
condition|)
name|acg
operator|.
name|cg_frsum
index|[
name|k
index|]
operator|--
expr_stmt|;
name|acg
operator|.
name|cg_frsum
index|[
name|k
operator|+
name|j
index|]
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * We only grow by some fragments within this last 			 * block. 			 */
for|for
control|(
name|i
operator|=
name|sblock
operator|.
name|fs_size
operator|-
name|cbase
operator|-
literal|1
init|;
name|i
operator|>=
name|osblock
operator|.
name|fs_size
operator|-
name|cbase
condition|;
name|i
operator|--
control|)
block|{
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
comment|/* 			 * Lets rejoin a possible partially growed fragment. 			 */
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isset
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|i
argument_list|)
operator|&&
operator|(
name|i
operator|>=
name|rounddown
argument_list|(
name|osblock
operator|.
name|fs_size
operator|-
name|cbase
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
operator|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|k
condition|)
name|acg
operator|.
name|cg_frsum
index|[
name|k
index|]
operator|--
expr_stmt|;
name|acg
operator|.
name|cg_frsum
index|[
name|k
operator|+
name|j
index|]
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Handle all new complete blocks here. 	 */
for|for
control|(
name|i
operator|=
name|roundup
argument_list|(
name|osblock
operator|.
name|fs_size
operator|-
name|cbase
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
init|;
name|i
operator|+
name|sblock
operator|.
name|fs_frag
operator|<=
name|dmax
operator|-
name|cbase
condition|;
comment|/* XXX<= or only< ? */
name|i
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|j
operator|=
name|i
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|setblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|updclst
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
block|}
comment|/* 	 * Handle the last new block if there are stll some new fragments left. 	 * Here we don't have to bother about the cluster summary or the even 	 * the rotational layout table. 	 */
if|if
condition|(
name|i
operator|<
operator|(
name|dmax
operator|-
name|cbase
operator|)
condition|)
block|{
name|acg
operator|.
name|cg_frsum
index|[
name|dmax
operator|-
name|cbase
operator|-
name|i
index|]
operator|++
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|dmax
operator|-
name|cbase
condition|;
name|i
operator|++
control|)
block|{
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
block|}
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|+=
operator|(
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|-
name|aocg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|)
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|+=
operator|(
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|-
name|aocg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|)
expr_stmt|;
comment|/* 	 * The following statistics are not changed here: 	 *     sblock.fs_cstotal.cs_ndir 	 *     sblock.fs_cstotal.cs_nifree 	 * As the statistics for this cylinder group are ready, copy it to 	 * the summary information array. 	 */
operator|*
name|cs
operator|=
name|acg
operator|.
name|cg_cs
expr_stmt|;
comment|/* 	 * Write the updated "joining" cylinder group back to disk. 	 */
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|acg
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"jcg written\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"new joining cg"
argument_list|,
operator|&
name|acg
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Here we update the location of the cylinder summary. We have two possible  * ways of growing the cylinder summary:  * (1)	We can try to grow the summary in the current location, and relocate  *	possibly used blocks within the current cylinder group.  * (2)	Alternatively we can relocate the whole cylinder summary to the first  *	new completely empty cylinder group. Once the cylinder summary is no  *	longer in the beginning of the first cylinder group you should never  *	use a version of fsck which is not aware of the possibility to have  *	this structure in a non standard place.  * Option (2) is considered to be less intrusive to the structure of the file-  * system, so that's the one being used.  */
end_comment

begin_function
specifier|static
name|void
name|updcsloc
parameter_list|(
name|time_t
name|modtime
parameter_list|,
name|int
name|fsi
parameter_list|,
name|int
name|fso
parameter_list|,
name|unsigned
name|int
name|Nflag
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"updcsloc"
argument_list|)
name|struct
name|csum
modifier|*
name|cs
decl_stmt|;
name|int
name|ocscg
decl_stmt|,
name|ncscg
decl_stmt|;
name|ufs2_daddr_t
name|d
decl_stmt|;
name|int
name|lcs
init|=
literal|0
decl_stmt|;
name|int
name|block
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
if|if
condition|(
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
operator|==
name|howmany
argument_list|(
name|osblock
operator|.
name|fs_cssize
argument_list|,
name|osblock
operator|.
name|fs_fsize
argument_list|)
condition|)
block|{
comment|/* 		 * No new fragment needed. 		 */
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
name|ocscg
operator|=
name|dtog
argument_list|(
operator|&
name|osblock
argument_list|,
name|osblock
operator|.
name|fs_csaddr
argument_list|)
expr_stmt|;
name|cs
operator|=
name|fscs
operator|+
name|ocscg
expr_stmt|;
comment|/* 	 * Read original cylinder group from disk, and make a copy. 	 * XXX	If Nflag is set in some very rare cases we now miss 	 *	some changes done in updjcg by reading the unmodified 	 *	block from disk. 	 */
name|rdfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|osblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|osblock
argument_list|,
name|ocscg
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|osblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|aocg
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"oscg read\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"old summary cg"
argument_list|,
operator|&
name|aocg
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|cgun1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cgun2
argument_list|,
sizeof|sizeof
argument_list|(
name|cgun2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Touch the cylinder group, set up local variables needed later 	 * and update the superblock. 	 */
name|acg
operator|.
name|cg_time
operator|=
name|modtime
expr_stmt|;
comment|/* 	 * XXX	In the case of having active snapshots we may need much more 	 *	blocks for the copy on write. We need each block twice, and 	 *	also up to 8*3 blocks for indirect blocks for all possible 	 *	references. 	 */
comment|/* 	 * There is not enough space in the old cylinder group to 	 * relocate all blocks as needed, so we relocate the whole 	 * cylinder group summary to a new group. We try to use the 	 * first complete new cylinder group just created. Within the 	 * cylinder group we align the area immediately after the 	 * cylinder group information location in order to be as 	 * close as possible to the original implementation of ffs. 	 * 	 * First we have to make sure we'll find enough space in the 	 * new cylinder group. If not, then we currently give up. 	 * We start with freeing everything which was used by the 	 * fragments of the old cylinder summary in the current group. 	 * Now we write back the group meta data, read in the needed 	 * meta data from the new cylinder group, and start allocating 	 * within that group. Here we can assume, the group to be 	 * completely empty. Which makes the handling of fragments and 	 * clusters a lot easier. 	 */
name|DBG_TRC
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_ncg
operator|-
name|osblock
operator|.
name|fs_ncg
operator|<
literal|2
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"panic: not enough space"
argument_list|)
expr_stmt|;
comment|/* 	 * Point "d" to the first fragment not used by the cylinder 	 * summary. 	 */
name|d
operator|=
name|osblock
operator|.
name|fs_csaddr
operator|+
operator|(
name|osblock
operator|.
name|fs_cssize
operator|/
name|osblock
operator|.
name|fs_fsize
operator|)
expr_stmt|;
comment|/* 	 * Set up last cluster size ("lcs") already here. Calculate 	 * the size for the trailing cluster just behind where "d" 	 * points to. 	 */
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|block
operator|=
name|howmany
argument_list|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
operator|,
name|lcs
operator|=
literal|0
init|;
name|lcs
operator|<
name|sblock
operator|.
name|fs_contigsumsize
condition|;
name|block
operator|++
operator|,
name|lcs
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|block
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* 	 * Point "d" to the last frag used by the cylinder summary. 	 */
name|d
operator|--
expr_stmt|;
name|DBG_PRINT1
argument_list|(
literal|"d=%jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|+
literal|1
operator|)
operator|%
name|sblock
operator|.
name|fs_frag
condition|)
block|{
comment|/* 		 * The end of the cylinder summary is not a complete 		 * block. 		 */
name|DBG_TRC
expr_stmt|;
name|frag_adjust
argument_list|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|d
operator|+
literal|1
operator|)
operator|%
name|sblock
operator|.
name|fs_frag
condition|;
name|d
operator|--
control|)
block|{
name|DBG_PRINT1
argument_list|(
literal|"d=%jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|d
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
comment|/* 		 * Point "d" to the last fragment of the last 		 * (incomplete) block of the cylinder summary. 		 */
name|d
operator|++
expr_stmt|;
name|frag_adjust
argument_list|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
operator|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
condition|)
block|{
name|DBG_PRINT1
argument_list|(
literal|"d=%jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|d
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|-=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|-=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|setbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
operator|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcs
operator|<
name|sblock
operator|.
name|fs_contigsumsize
condition|)
block|{
if|if
condition|(
name|lcs
condition|)
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs
index|]
operator|--
expr_stmt|;
name|lcs
operator|++
expr_stmt|;
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * Point "d" to the first fragment of the block before 		 * the last incomplete block. 		 */
name|d
operator|--
expr_stmt|;
block|}
name|DBG_PRINT1
argument_list|(
literal|"d=%jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|d
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|rounddown
argument_list|(
name|d
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
init|;
name|d
operator|>=
name|osblock
operator|.
name|fs_csaddr
condition|;
name|d
operator|-=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|DBG_TRC
expr_stmt|;
name|DBG_PRINT1
argument_list|(
literal|"d=%jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|d
argument_list|)
expr_stmt|;
name|setblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
operator|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|setbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
operator|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
comment|/* 			 * The last cluster size is already set up. 			 */
if|if
condition|(
name|lcs
operator|<
name|sblock
operator|.
name|fs_contigsumsize
condition|)
block|{
if|if
condition|(
name|lcs
condition|)
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs
index|]
operator|--
expr_stmt|;
name|lcs
operator|++
expr_stmt|;
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
operator|*
name|cs
operator|=
name|acg
operator|.
name|cg_cs
expr_stmt|;
comment|/* 	 * Now write the former cylinder group containing the cylinder 	 * summary back to disk. 	 */
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|ocscg
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|acg
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"oscg written\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"old summary cg"
argument_list|,
operator|&
name|acg
argument_list|)
expr_stmt|;
comment|/* 	 * Find the beginning of the new cylinder group containing the 	 * cylinder summary. 	 */
name|sblock
operator|.
name|fs_csaddr
operator|=
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|osblock
operator|.
name|fs_ncg
argument_list|)
expr_stmt|;
name|ncscg
operator|=
name|dtog
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_csaddr
argument_list|)
expr_stmt|;
name|cs
operator|=
name|fscs
operator|+
name|ncscg
expr_stmt|;
comment|/* 	 * If Nflag is specified, we would now read random data instead 	 * of an empty cg structure from disk. So we can't simulate that 	 * part for now. 	 */
if|if
condition|(
name|Nflag
condition|)
block|{
name|DBG_PRINT0
argument_list|(
literal|"nscg update skipped\n"
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
comment|/* 	 * Read the future cylinder group containing the cylinder 	 * summary from disk, and make a copy. 	 */
name|rdfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|ncscg
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|aocg
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"nscg read\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"new summary cg"
argument_list|,
operator|&
name|aocg
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|cgun1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cgun2
argument_list|,
sizeof|sizeof
argument_list|(
name|cgun2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate all complete blocks used by the new cylinder 	 * summary. 	 */
for|for
control|(
name|d
operator|=
name|sblock
operator|.
name|fs_csaddr
init|;
name|d
operator|+
name|sblock
operator|.
name|fs_frag
operator|<=
name|sblock
operator|.
name|fs_csaddr
operator|+
operator|(
name|sblock
operator|.
name|fs_cssize
operator|/
name|sblock
operator|.
name|fs_fsize
operator|)
condition|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|clrblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
operator|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
block|{
name|clrbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
operator|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Allocate all fragments used by the cylinder summary in the 	 * last block. 	 */
if|if
condition|(
name|d
operator|<
name|sblock
operator|.
name|fs_csaddr
operator|+
operator|(
name|sblock
operator|.
name|fs_cssize
operator|/
name|sblock
operator|.
name|fs_fsize
operator|)
condition|)
block|{
for|for
control|(
init|;
name|d
operator|-
name|sblock
operator|.
name|fs_csaddr
operator|<
name|sblock
operator|.
name|fs_cssize
operator|/
name|sblock
operator|.
name|fs_fsize
condition|;
name|d
operator|++
control|)
block|{
name|clrbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|--
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|--
expr_stmt|;
block|}
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|+=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|+=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|>
literal|0
condition|)
name|clrbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
operator|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|frag_adjust
argument_list|(
name|d
operator|%
name|sblock
operator|.
name|fs_fpg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX	Handle the cluster statistics here in the case this 	 *	cylinder group is now almost full, and the remaining 	 *	space is less then the maximum cluster size. This is 	 *	probably not needed, as you would hardly find a file 	 *	system which has only MAXCSBUFS+FS_MAXCONTIG of free 	 *	space right behind the cylinder group information in 	 *	any new cylinder group. 	 */
comment|/* 	 * Update our statistics in the cylinder summary. 	 */
operator|*
name|cs
operator|=
name|acg
operator|.
name|cg_cs
expr_stmt|;
comment|/* 	 * Write the new cylinder group containing the cylinder summary 	 * back to disk. 	 */
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|ncscg
argument_list|)
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|sblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|acg
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"nscg written\n"
argument_list|)
expr_stmt|;
name|DBG_DUMP_CG
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"new summary cg"
argument_list|,
operator|&
name|acg
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Here we read some block(s) from disk.  */
end_comment

begin_function
specifier|static
name|void
name|rdfs
parameter_list|(
name|ufs2_daddr_t
name|bno
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|bf
parameter_list|,
name|int
name|fsi
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"rdfs"
argument_list|)
name|ssize_t
name|n
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
if|if
condition|(
name|bno
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|32
argument_list|,
literal|"rdfs: attempting to read negative block number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fsi
argument_list|,
operator|(
name|off_t
operator|)
name|bno
operator|*
name|DEV_BSIZE
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|33
argument_list|,
literal|"rdfs: seek error: %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|bno
argument_list|)
expr_stmt|;
name|n
operator|=
name|read
argument_list|(
name|fsi
argument_list|,
name|bf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
operator|(
name|ssize_t
operator|)
name|size
condition|)
name|err
argument_list|(
literal|34
argument_list|,
literal|"rdfs: read error: %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|bno
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Here we write some block(s) to disk.  */
end_comment

begin_function
specifier|static
name|void
name|wtfs
parameter_list|(
name|ufs2_daddr_t
name|bno
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|bf
parameter_list|,
name|int
name|fso
parameter_list|,
name|unsigned
name|int
name|Nflag
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"wtfs"
argument_list|)
name|ssize_t
name|n
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
if|if
condition|(
name|Nflag
condition|)
block|{
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|fso
argument_list|,
operator|(
name|off_t
operator|)
name|bno
operator|*
name|DEV_BSIZE
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|35
argument_list|,
literal|"wtfs: seek error: %ld"
argument_list|,
operator|(
name|long
operator|)
name|bno
argument_list|)
expr_stmt|;
name|n
operator|=
name|write
argument_list|(
name|fso
argument_list|,
name|bf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
operator|(
name|ssize_t
operator|)
name|size
condition|)
name|err
argument_list|(
literal|36
argument_list|,
literal|"wtfs: write error: %ld"
argument_list|,
operator|(
name|long
operator|)
name|bno
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Here we check if all frags of a block are free. For more details again  * please see the source of newfs(8), as this function is taken over almost  * unchanged.  */
end_comment

begin_function
specifier|static
name|int
name|isblock
parameter_list|(
name|struct
name|fs
modifier|*
name|fs
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"isblock"
argument_list|)
name|unsigned
name|char
name|mask
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
switch|switch
condition|(
name|fs
operator|->
name|fs_frag
condition|)
block|{
case|case
literal|8
case|:
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
name|cp
index|[
name|h
index|]
operator|==
literal|0xff
operator|)
return|;
case|case
literal|4
case|:
name|mask
operator|=
literal|0x0f
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x1
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
operator|(
name|cp
index|[
name|h
operator|>>
literal|1
index|]
operator|&
name|mask
operator|)
operator|==
name|mask
operator|)
return|;
case|case
literal|2
case|:
name|mask
operator|=
literal|0x03
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x3
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
operator|(
name|cp
index|[
name|h
operator|>>
literal|2
index|]
operator|&
name|mask
operator|)
operator|==
name|mask
operator|)
return|;
case|case
literal|1
case|:
name|mask
operator|=
literal|0x01
operator|<<
operator|(
name|h
operator|&
literal|0x7
operator|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
operator|(
name|cp
index|[
name|h
operator|>>
literal|3
index|]
operator|&
name|mask
operator|)
operator|==
name|mask
operator|)
return|;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"isblock bad fs_frag %d\n"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Here we allocate a complete block in the block map. For more details again  * please see the source of newfs(8), as this function is taken over almost  * unchanged.  */
end_comment

begin_function
specifier|static
name|void
name|clrblock
parameter_list|(
name|struct
name|fs
modifier|*
name|fs
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"clrblock"
argument_list|)
name|DBG_ENTER
expr_stmt|;
switch|switch
condition|(
operator|(
name|fs
operator|)
operator|->
name|fs_frag
condition|)
block|{
case|case
literal|8
case|:
name|cp
index|[
name|h
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cp
index|[
name|h
operator|>>
literal|1
index|]
operator|&=
operator|~
operator|(
literal|0x0f
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x1
operator|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cp
index|[
name|h
operator|>>
literal|2
index|]
operator|&=
operator|~
operator|(
literal|0x03
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x3
operator|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cp
index|[
name|h
operator|>>
literal|3
index|]
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
operator|(
name|h
operator|&
literal|0x7
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"clrblock bad fs_frag %d"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
break|break;
block|}
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Here we free a complete block in the free block map. For more details again  * please see the source of newfs(8), as this function is taken over almost  * unchanged.  */
end_comment

begin_function
specifier|static
name|void
name|setblock
parameter_list|(
name|struct
name|fs
modifier|*
name|fs
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"setblock"
argument_list|)
name|DBG_ENTER
expr_stmt|;
switch|switch
condition|(
name|fs
operator|->
name|fs_frag
condition|)
block|{
case|case
literal|8
case|:
name|cp
index|[
name|h
index|]
operator|=
literal|0xff
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cp
index|[
name|h
operator|>>
literal|1
index|]
operator||=
operator|(
literal|0x0f
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x1
operator|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cp
index|[
name|h
operator|>>
literal|2
index|]
operator||=
operator|(
literal|0x03
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x3
operator|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cp
index|[
name|h
operator|>>
literal|3
index|]
operator||=
operator|(
literal|0x01
operator|<<
operator|(
name|h
operator|&
literal|0x7
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"setblock bad fs_frag %d"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
break|break;
block|}
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Figure out how many lines our current terminal has. For more details again  * please see the source of newfs(8), as this function is taken over almost  * unchanged.  */
end_comment

begin_function
specifier|static
name|int
name|charsperline
parameter_list|(
name|void
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"charsperline"
argument_list|)
name|int
name|columns
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|winsize
name|ws
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
name|columns
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|columns
operator|=
name|ws
operator|.
name|ws_col
expr_stmt|;
if|if
condition|(
name|columns
operator|==
literal|0
operator|&&
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
operator|)
condition|)
name|columns
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|columns
operator|==
literal|0
condition|)
name|columns
operator|=
literal|80
expr_stmt|;
comment|/* last resort */
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
name|columns
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_dev
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|stat
name|devstat
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|devstat
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|S_ISCHR
argument_list|(
name|devstat
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return mountpoint on which the device is currently mounted.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|statfs
modifier|*
name|dev_to_statfs
parameter_list|(
specifier|const
name|char
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|stat
name|devstat
decl_stmt|,
name|mntdevstat
decl_stmt|;
name|struct
name|statfs
modifier|*
name|mntbuf
decl_stmt|,
modifier|*
name|statfsp
decl_stmt|;
name|char
name|device
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|mntdevname
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mntsize
decl_stmt|;
comment|/* 	 * First check the mounted filesystems. 	 */
if|if
condition|(
name|stat
argument_list|(
name|dev
argument_list|,
operator|&
name|devstat
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
name|S_ISCHR
argument_list|(
name|devstat
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISBLK
argument_list|(
name|devstat
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mntsize
operator|=
name|getmntinfo
argument_list|(
operator|&
name|mntbuf
argument_list|,
name|MNT_NOWAIT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mntsize
condition|;
name|i
operator|++
control|)
block|{
name|statfsp
operator|=
operator|&
name|mntbuf
index|[
name|i
index|]
expr_stmt|;
name|mntdevname
operator|=
name|statfsp
operator|->
name|f_mntfromname
expr_stmt|;
if|if
condition|(
operator|*
name|mntdevname
operator|!=
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|device
argument_list|,
name|_PATH_DEV
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|device
argument_list|,
name|mntdevname
argument_list|)
expr_stmt|;
name|mntdevname
operator|=
name|device
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|mntdevname
argument_list|,
operator|&
name|mntdevstat
argument_list|)
operator|==
literal|0
operator|&&
name|mntdevstat
operator|.
name|st_rdev
operator|==
name|devstat
operator|.
name|st_rdev
condition|)
return|return
operator|(
name|statfsp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mountpoint_to_dev
parameter_list|(
specifier|const
name|char
modifier|*
name|mountpoint
parameter_list|)
block|{
name|struct
name|statfs
modifier|*
name|mntbuf
decl_stmt|,
modifier|*
name|statfsp
decl_stmt|;
name|struct
name|fstab
modifier|*
name|fs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mntsize
decl_stmt|;
comment|/* 	 * First check the mounted filesystems. 	 */
name|mntsize
operator|=
name|getmntinfo
argument_list|(
operator|&
name|mntbuf
argument_list|,
name|MNT_NOWAIT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mntsize
condition|;
name|i
operator|++
control|)
block|{
name|statfsp
operator|=
operator|&
name|mntbuf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|statfsp
operator|->
name|f_mntonname
argument_list|,
name|mountpoint
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|statfsp
operator|->
name|f_mntfromname
operator|)
return|;
block|}
comment|/* 	 * Check the fstab. 	 */
name|fs
operator|=
name|getfsfile
argument_list|(
name|mountpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|!=
name|NULL
condition|)
return|return
operator|(
name|fs
operator|->
name|fs_spec
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|getdev
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
name|char
name|device
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dev
decl_stmt|;
if|if
condition|(
name|is_dev
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
name|name
operator|)
return|;
name|cp
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|device
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_dev
argument_list|(
name|device
argument_list|)
condition|)
return|return
operator|(
name|device
operator|)
return|;
block|}
name|dev
operator|=
name|mountpoint_to_dev
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|!=
name|NULL
operator|&&
name|is_dev
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|dev
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * growfs(8) is a utility which allows to increase the size of an existing  * ufs file system. Currently this can only be done on unmounted file system.  * It recognizes some command line options to specify the new desired size,  * and it does some basic checkings. The old file system size is determined  * and after some more checks like we can really access the new last block  * on the disk etc. we calculate the new parameters for the superblock. After  * having done this we just call growfs() which will do the work.  * We still have to provide support for snapshots. Therefore we first have to  * understand what data structures are always replicated in the snapshot on  * creation, for all other blocks we touch during our procedure, we have to  * keep the old blocks unchanged somewhere available for the snapshots. If we  * are lucky, then we only have to handle our blocks to be relocated in that  * way.  * Also we have to consider in what order we actually update the critical  * data structures of the file system to make sure, that in case of a disaster  * fsck(8) is still able to restore any lost data.  * The foreseen last step then will be to provide for growing even mounted  * file systems. There we have to extend the mount() system call to provide  * userland access to the file system locking facility.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"main"
argument_list|)
specifier|const
name|char
modifier|*
name|device
decl_stmt|;
specifier|const
name|struct
name|statfs
modifier|*
name|statfsp
decl_stmt|;
name|uint64_t
name|size
init|=
literal|0
decl_stmt|;
name|off_t
name|mediasize
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|fsi
decl_stmt|,
name|fso
decl_stmt|,
name|ch
decl_stmt|,
name|Nflag
init|=
literal|0
decl_stmt|,
name|yflag
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|reply
index|[
literal|5
index|]
decl_stmt|,
name|oldsizebuf
index|[
literal|6
index|]
decl_stmt|,
name|newsizebuf
index|[
literal|6
index|]
decl_stmt|;
name|void
modifier|*
name|testbuf
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Ns:vy"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'N'
case|:
name|Nflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|size
operator|=
operator|(
name|off_t
operator|)
name|strtoumax
argument_list|(
name|optarg
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|size
operator|*=
name|DEV_BSIZE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'b'
operator|||
operator|*
name|p
operator|==
literal|'B'
condition|)
empty_stmt|;
comment|/* do nothing */
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'k'
operator|||
operator|*
name|p
operator|==
literal|'K'
condition|)
name|size
operator|<<=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'m'
operator|||
operator|*
name|p
operator|==
literal|'M'
condition|)
name|size
operator|<<=
literal|20
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'g'
operator|||
operator|*
name|p
operator|==
literal|'G'
condition|)
name|size
operator|<<=
literal|30
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'t'
operator|||
operator|*
name|p
operator|==
literal|'T'
condition|)
block|{
name|size
operator|<<=
literal|30
expr_stmt|;
name|size
operator|<<=
literal|10
expr_stmt|;
block|}
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown suffix on -s argument"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* for compatibility to newfs */
break|break;
case|case
literal|'y'
case|:
name|yflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* FALLTHROUGH */
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* 	 * Now try to guess the device name. 	 */
name|device
operator|=
name|getdev
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"cannot find special device for %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|statfsp
operator|=
name|dev_to_statfs
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|fsi
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsi
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|device
argument_list|)
expr_stmt|;
comment|/* 	 * Try to guess the slice size if not specified. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fsi
argument_list|,
name|DIOCGMEDIASIZE
argument_list|,
operator|&
name|mediasize
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGMEDIASIZE"
argument_list|)
expr_stmt|;
comment|/* 	 * Check if that partition is suitable for growing a file system. 	 */
if|if
condition|(
name|mediasize
operator|<
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"partition is unavailable"
argument_list|)
expr_stmt|;
comment|/* 	 * Read the current superblock, and take a backup. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sblock_try
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|sblockloc
operator|=
name|sblock_try
index|[
name|i
index|]
operator|/
name|DEV_BSIZE
expr_stmt|;
name|rdfs
argument_list|(
name|sblockloc
argument_list|,
operator|(
name|size_t
operator|)
name|SBLOCKSIZE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|osblock
operator|)
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|osblock
operator|.
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
operator|||
operator|(
name|osblock
operator|.
name|fs_magic
operator|==
name|FS_UFS2_MAGIC
operator|&&
name|osblock
operator|.
name|fs_sblockloc
operator|==
name|sblock_try
index|[
name|i
index|]
operator|)
operator|)
operator|&&
name|osblock
operator|.
name|fs_bsize
operator|<=
name|MAXBSIZE
operator|&&
name|osblock
operator|.
name|fs_bsize
operator|>=
operator|(
name|int32_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|fs
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|sblock_try
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"superblock not recognized"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|fsun1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|fsun2
argument_list|,
sizeof|sizeof
argument_list|(
name|fsun2
argument_list|)
argument_list|)
expr_stmt|;
name|DBG_OPEN
argument_list|(
literal|"/tmp/growfs.debug"
argument_list|)
expr_stmt|;
comment|/* already here we need a superblock */
name|DBG_DUMP_FS
argument_list|(
operator|&
name|sblock
argument_list|,
literal|"old sblock"
argument_list|)
expr_stmt|;
comment|/* 	 * Determine size to grow to. Default to the device size. 	 */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|mediasize
expr_stmt|;
else|else
block|{
if|if
condition|(
name|size
operator|>
operator|(
name|uint64_t
operator|)
name|mediasize
condition|)
block|{
name|humanize_number
argument_list|(
name|oldsizebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|oldsizebuf
argument_list|)
argument_list|,
name|size
argument_list|,
literal|"B"
argument_list|,
name|HN_AUTOSCALE
argument_list|,
name|HN_B
operator||
name|HN_NOSPACE
operator||
name|HN_DECIMAL
argument_list|)
expr_stmt|;
name|humanize_number
argument_list|(
name|newsizebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|newsizebuf
argument_list|)
argument_list|,
name|mediasize
argument_list|,
literal|"B"
argument_list|,
name|HN_AUTOSCALE
argument_list|,
name|HN_B
operator||
name|HN_NOSPACE
operator||
name|HN_DECIMAL
argument_list|)
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"requested size %s is larger "
literal|"than the available %s"
argument_list|,
name|oldsizebuf
argument_list|,
name|newsizebuf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Make sure the new size is a multiple of fs_fsize; /dev/ufssuspend 	 * only supports fragment-aligned IO requests. 	 */
name|size
operator|-=
name|size
operator|%
name|osblock
operator|.
name|fs_fsize
expr_stmt|;
if|if
condition|(
name|size
operator|<=
call|(
name|uint64_t
call|)
argument_list|(
name|osblock
operator|.
name|fs_size
operator|*
name|osblock
operator|.
name|fs_fsize
argument_list|)
condition|)
block|{
name|humanize_number
argument_list|(
name|oldsizebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|oldsizebuf
argument_list|)
argument_list|,
name|osblock
operator|.
name|fs_size
operator|*
name|osblock
operator|.
name|fs_fsize
argument_list|,
literal|"B"
argument_list|,
name|HN_AUTOSCALE
argument_list|,
name|HN_B
operator||
name|HN_NOSPACE
operator||
name|HN_DECIMAL
argument_list|)
expr_stmt|;
name|humanize_number
argument_list|(
name|newsizebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|newsizebuf
argument_list|)
argument_list|,
name|size
argument_list|,
literal|"B"
argument_list|,
name|HN_AUTOSCALE
argument_list|,
name|HN_B
operator||
name|HN_NOSPACE
operator||
name|HN_DECIMAL
argument_list|)
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"requested size %s is not larger than the current "
literal|"filesystem size %s"
argument_list|,
name|newsizebuf
argument_list|,
name|oldsizebuf
argument_list|)
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_size
operator|=
name|dbtofsb
argument_list|(
operator|&
name|osblock
argument_list|,
name|size
operator|/
name|DEV_BSIZE
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_providersize
operator|=
name|dbtofsb
argument_list|(
operator|&
name|osblock
argument_list|,
name|mediasize
operator|/
name|DEV_BSIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Are we really growing? 	 */
if|if
condition|(
name|osblock
operator|.
name|fs_size
operator|>=
name|sblock
operator|.
name|fs_size
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"we are not growing (%jd->%jd)"
argument_list|,
operator|(
name|intmax_t
operator|)
name|osblock
operator|.
name|fs_size
argument_list|,
operator|(
name|intmax_t
operator|)
name|sblock
operator|.
name|fs_size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check if we find an active snapshot. 	 */
if|if
condition|(
name|yflag
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FSMAXSNAP
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sblock
operator|.
name|fs_snapinum
index|[
name|j
index|]
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"active snapshot found in file system; "
literal|"please remove all snapshots before "
literal|"using growfs"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sblock
operator|.
name|fs_snapinum
index|[
name|j
index|]
condition|)
comment|/* list is dense */
break|break;
block|}
block|}
if|if
condition|(
name|yflag
operator|==
literal|0
operator|&&
name|Nflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|statfsp
operator|!=
name|NULL
operator|&&
operator|(
name|statfsp
operator|->
name|f_flags
operator|&
name|MNT_RDONLY
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Device is mounted read-write; resizing will "
literal|"result in temporary write suspension for %s.\n"
argument_list|,
name|statfsp
operator|->
name|f_mntonname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"It's strongly recommended to make a backup "
literal|"before growing the file system.\n"
literal|"OK to grow filesystem on %s"
argument_list|,
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|statfsp
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|", mounted on %s,"
argument_list|,
name|statfsp
operator|->
name|f_mntonname
argument_list|)
expr_stmt|;
name|humanize_number
argument_list|(
name|oldsizebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|oldsizebuf
argument_list|)
argument_list|,
name|osblock
operator|.
name|fs_size
operator|*
name|osblock
operator|.
name|fs_fsize
argument_list|,
literal|"B"
argument_list|,
name|HN_AUTOSCALE
argument_list|,
name|HN_B
operator||
name|HN_NOSPACE
operator||
name|HN_DECIMAL
argument_list|)
expr_stmt|;
name|humanize_number
argument_list|(
name|newsizebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|newsizebuf
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_size
operator|*
name|sblock
operator|.
name|fs_fsize
argument_list|,
literal|"B"
argument_list|,
name|HN_AUTOSCALE
argument_list|,
name|HN_B
operator||
name|HN_NOSPACE
operator||
name|HN_DECIMAL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" from %s to %s? [Yes/No] "
argument_list|,
name|oldsizebuf
argument_list|,
name|newsizebuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|reply
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|reply
argument_list|,
literal|"Yes\n"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nNothing done\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Try to access our device for writing.  If it's not mounted, 	 * or mounted read-only, simply open it; otherwise, use UFS 	 * suspension mechanism. 	 */
if|if
condition|(
name|Nflag
condition|)
block|{
name|fso
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|statfsp
operator|!=
name|NULL
operator|&&
operator|(
name|statfsp
operator|->
name|f_flags
operator|&
name|MNT_RDONLY
operator|)
operator|==
literal|0
condition|)
block|{
name|fso
operator|=
name|open
argument_list|(
name|_PATH_UFSSUSPEND
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fso
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"unable to open %s"
argument_list|,
name|_PATH_UFSSUSPEND
argument_list|)
expr_stmt|;
name|error
operator|=
name|ioctl
argument_list|(
name|fso
argument_list|,
name|UFSSUSPEND
argument_list|,
operator|&
name|statfsp
operator|->
name|f_fsid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"UFSSUSPEND"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fso
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fso
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|device
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Try to access our new last block in the file system. 	 */
name|testbuf
operator|=
name|malloc
argument_list|(
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|testbuf
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|rdfs
argument_list|(
call|(
name|ufs2_daddr_t
call|)
argument_list|(
operator|(
name|size
operator|-
name|sblock
operator|.
name|fs_fsize
operator|)
operator|/
name|DEV_BSIZE
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|,
name|testbuf
argument_list|,
name|fsi
argument_list|)
expr_stmt|;
name|wtfs
argument_list|(
call|(
name|ufs2_daddr_t
call|)
argument_list|(
operator|(
name|size
operator|-
name|sblock
operator|.
name|fs_fsize
operator|)
operator|/
name|DEV_BSIZE
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|,
name|testbuf
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|testbuf
argument_list|)
expr_stmt|;
comment|/* 	 * Now calculate new superblock values and check for reasonable 	 * bound for new file system size: 	 *     fs_size:    is derived from user input 	 *     fs_dsize:   should get updated in the routines creating or 	 *                 updating the cylinder groups on the fly 	 *     fs_cstotal: should get updated in the routines creating or 	 *                 updating the cylinder groups 	 */
comment|/* 	 * Update the number of cylinders and cylinder groups in the file system. 	 */
if|if
condition|(
name|sblock
operator|.
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
block|{
name|sblock
operator|.
name|fs_old_ncyl
operator|=
name|sblock
operator|.
name|fs_size
operator|*
name|sblock
operator|.
name|fs_old_nspf
operator|/
name|sblock
operator|.
name|fs_old_spc
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_size
operator|*
name|sblock
operator|.
name|fs_old_nspf
operator|>
name|sblock
operator|.
name|fs_old_ncyl
operator|*
name|sblock
operator|.
name|fs_old_spc
condition|)
name|sblock
operator|.
name|fs_old_ncyl
operator|++
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_ncg
operator|=
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_size
argument_list|,
name|sblock
operator|.
name|fs_fpg
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate last cylinder group only if there is enough room 	 * for at least one data block. 	 */
if|if
condition|(
name|sblock
operator|.
name|fs_size
operator|%
name|sblock
operator|.
name|fs_fpg
operator|!=
literal|0
operator|&&
name|sblock
operator|.
name|fs_size
operator|<=
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
argument_list|)
condition|)
block|{
name|humanize_number
argument_list|(
name|oldsizebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|oldsizebuf
argument_list|)
argument_list|,
operator|(
name|sblock
operator|.
name|fs_size
operator|%
name|sblock
operator|.
name|fs_fpg
operator|)
operator|*
name|sblock
operator|.
name|fs_fsize
argument_list|,
literal|"B"
argument_list|,
name|HN_AUTOSCALE
argument_list|,
name|HN_B
operator||
name|HN_NOSPACE
operator||
name|HN_DECIMAL
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"no room to allocate last cylinder group; "
literal|"leaving %s unused"
argument_list|,
name|oldsizebuf
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_ncg
operator|--
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|sblock
operator|.
name|fs_old_ncyl
operator|=
name|sblock
operator|.
name|fs_ncg
operator|*
name|sblock
operator|.
name|fs_old_cpg
expr_stmt|;
name|sblock
operator|.
name|fs_size
operator|=
name|sblock
operator|.
name|fs_ncg
operator|*
name|sblock
operator|.
name|fs_fpg
expr_stmt|;
block|}
comment|/* 	 * Update the space for the cylinder group summary information in the 	 * respective cylinder group data area. 	 */
name|sblock
operator|.
name|fs_cssize
operator|=
name|fragroundup
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_ncg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|csum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|osblock
operator|.
name|fs_size
operator|>=
name|sblock
operator|.
name|fs_size
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"not enough new space"
argument_list|)
expr_stmt|;
name|DBG_PRINT0
argument_list|(
literal|"sblock calculated\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Ok, everything prepared, so now let's do the tricks. 	 */
name|growfs
argument_list|(
name|fsi
argument_list|,
name|fso
argument_list|,
name|Nflag
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|fso
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|statfsp
operator|!=
name|NULL
operator|&&
operator|(
name|statfsp
operator|->
name|f_flags
operator|&
name|MNT_RDONLY
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ioctl
argument_list|(
name|fso
argument_list|,
name|UFSRESUME
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"UFSRESUME"
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|close
argument_list|(
name|fso
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|statfsp
operator|!=
name|NULL
operator|&&
operator|(
name|statfsp
operator|->
name|f_flags
operator|&
name|MNT_RDONLY
operator|)
operator|!=
literal|0
condition|)
name|mount_reload
argument_list|(
name|statfsp
argument_list|)
expr_stmt|;
block|}
name|DBG_CLOSE
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump a line of usage.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"usage"
argument_list|)
name|DBG_ENTER
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: growfs [-Ny] [-s size] special | filesystem\n"
argument_list|)
expr_stmt|;
name|DBG_LEAVE
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This updates most parameters and the bitmap related to cluster. We have to  * assume that sblock, osblock, acg are set up.  */
end_comment

begin_function
specifier|static
name|void
name|updclst
parameter_list|(
name|int
name|block
parameter_list|)
block|{
name|DBG_FUNC
argument_list|(
literal|"updclst"
argument_list|)
specifier|static
name|int
name|lcs
init|=
literal|0
decl_stmt|;
name|DBG_ENTER
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_contigsumsize
operator|<
literal|1
condition|)
comment|/* no clustering */
return|return;
comment|/* 	 * update cluster allocation map 	 */
name|setbit
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|/* 	 * update cluster summary table 	 */
if|if
condition|(
operator|!
name|lcs
condition|)
block|{
comment|/* 		 * calculate size for the trailing cluster 		 */
for|for
control|(
name|block
operator|--
init|;
name|lcs
operator|<
name|sblock
operator|.
name|fs_contigsumsize
condition|;
name|block
operator|--
operator|,
name|lcs
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|cg_clustersfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|block
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|lcs
operator|<
name|sblock
operator|.
name|fs_contigsumsize
condition|)
block|{
if|if
condition|(
name|lcs
condition|)
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs
index|]
operator|--
expr_stmt|;
name|lcs
operator|++
expr_stmt|;
name|cg_clustersum
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|lcs
index|]
operator|++
expr_stmt|;
block|}
name|DBG_LEAVE
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mount_reload
parameter_list|(
specifier|const
name|struct
name|statfs
modifier|*
name|stfs
parameter_list|)
block|{
name|char
name|errmsg
index|[
literal|255
index|]
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
name|int
name|iovlen
decl_stmt|;
name|iov
operator|=
name|NULL
expr_stmt|;
name|iovlen
operator|=
literal|0
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|'\0'
expr_stmt|;
name|build_iovec
argument_list|(
operator|&
name|iov
argument_list|,
operator|&
name|iovlen
argument_list|,
literal|"fstype"
argument_list|,
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
literal|"ffs"
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|build_iovec
argument_list|(
operator|&
name|iov
argument_list|,
operator|&
name|iovlen
argument_list|,
literal|"fspath"
argument_list|,
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|stfs
operator|->
name|f_mntonname
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|build_iovec
argument_list|(
operator|&
name|iov
argument_list|,
operator|&
name|iovlen
argument_list|,
literal|"errmsg"
argument_list|,
name|errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|errmsg
argument_list|)
argument_list|)
expr_stmt|;
name|build_iovec
argument_list|(
operator|&
name|iov
argument_list|,
operator|&
name|iovlen
argument_list|,
literal|"update"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|build_iovec
argument_list|(
operator|&
name|iov
argument_list|,
operator|&
name|iovlen
argument_list|,
literal|"reload"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmount
argument_list|(
name|iov
argument_list|,
name|iovlen
argument_list|,
name|stfs
operator|->
name|f_flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errmsg
index|[
sizeof|sizeof
argument_list|(
name|errmsg
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|err
argument_list|(
literal|9
argument_list|,
literal|"%s: cannot reload filesystem%s%s"
argument_list|,
name|stfs
operator|->
name|f_mntonname
argument_list|,
operator|*
name|errmsg
operator|!=
literal|'\0'
condition|?
literal|": "
else|:
literal|""
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

