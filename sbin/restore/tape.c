begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * SPDX-License-Identifier: BSD-3-Clause  *  * Copyright (c) 1983, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)tape.c	8.9 (Berkeley) 5/1/95";
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/extattr.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/extattr.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<protocols/dumprestore.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<timeconv.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"restore.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_decl_stmt
specifier|static
name|long
name|fssize
init|=
name|MAXBSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mt
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipein
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipecmdin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|popenfp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|magtape
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|blkcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|numtrec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tapebuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|union
name|u_spcl
name|endoftapemark
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|byteslide
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|blksread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* blocks read since last header */
end_comment

begin_decl_stmt
specifier|static
name|int64_t
name|tapeaddr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current TP_BSIZE tape record */
end_comment

begin_decl_stmt
specifier|static
name|long
name|tapesread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|restart
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gettingfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* restart has a valid frame */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|host
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readmapflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ofile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|lnkbuf
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pathlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Bcvt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Swap Bytes */
end_comment

begin_decl_stmt
name|int
name|oldinofmt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FreeBSD 1 inode format needs cvt */
end_comment

begin_define
define|#
directive|define
name|FLUSHTAPEBUF
parameter_list|()
value|blkcnt = ntrec + 1
end_define

begin_decl_stmt
name|char
modifier|*
name|namespace_names
index|[]
init|=
name|EXTATTR_NAMESPACE_NAMES
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|accthdr
parameter_list|(
name|struct
name|s_spcl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|checksum
parameter_list|(
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|findinode
parameter_list|(
name|struct
name|s_spcl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|findtapeblksize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|setupextattr
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtrattr
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|skiphole
parameter_list|(
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gethead
parameter_list|(
name|struct
name|s_spcl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|readtape
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setdumpnum
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_long
name|swabl
parameter_list|(
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
modifier|*
name|swablong
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
modifier|*
name|swabshort
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|terminateinput
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtrfile
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtrlnkfile
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtrlnkskip
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtrmap
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtrmapskip
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xtrskip
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Set up an input source  */
end_comment

begin_function
name|void
name|setinput
parameter_list|(
name|char
modifier|*
name|source
parameter_list|,
name|int
name|ispipecommand
parameter_list|)
block|{
name|FLUSHTAPEBUF
argument_list|()
expr_stmt|;
if|if
condition|(
name|bflag
condition|)
name|newtapebuf
argument_list|(
name|ntrec
argument_list|)
expr_stmt|;
else|else
name|newtapebuf
argument_list|(
name|MAX
argument_list|(
name|NTREC
argument_list|,
name|HIGHDENSITYTREC
argument_list|)
argument_list|)
expr_stmt|;
name|terminal
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
name|ispipecommand
condition|)
name|pipecmdin
operator|++
expr_stmt|;
elseif|else
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|strchr
argument_list|(
name|source
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|host
operator|=
name|source
expr_stmt|;
name|source
operator|=
name|strchr
argument_list|(
name|host
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|source
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rmthost
argument_list|(
name|host
argument_list|)
operator|==
literal|0
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|source
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Since input is coming from a pipe we must establish 		 * our own connection to the terminal. 		 */
name|terminal
operator|=
name|fopen
argument_list|(
name|_PATH_TTY
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|terminal
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot open %s: %s\n"
argument_list|,
name|_PATH_TTY
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|terminal
operator|=
name|fopen
argument_list|(
name|_PATH_DEVNULL
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|terminal
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot open %s: %s\n"
argument_list|,
name|_PATH_DEVNULL
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|pipein
operator|++
expr_stmt|;
block|}
comment|/* no longer need or want root privileges */
if|if
condition|(
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"setuid failed\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|magtape
operator|=
name|strdup
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|magtape
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot allocate space for magtape buffer\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|newtapebuf
parameter_list|(
name|long
name|size
parameter_list|)
block|{
specifier|static
name|int
name|tapebufsize
init|=
operator|-
literal|1
decl_stmt|;
name|ntrec
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|tapebufsize
condition|)
return|return;
if|if
condition|(
name|tapebuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tapebuf
operator|-
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|tapebuf
operator|=
name|malloc
argument_list|(
operator|(
name|size
operator|+
literal|1
operator|)
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tapebuf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot allocate space for tape buffer\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tapebuf
operator|+=
name|TP_BSIZE
expr_stmt|;
name|tapebufsize
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that the tape drive can be accessed and  * that it actually is a dump tape.  */
end_comment

begin_function
name|void
name|setup
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"Verify tape and initialize maps\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipecmdin
condition|)
block|{
if|if
condition|(
name|setenv
argument_list|(
literal|"RESTORE_VOLUME"
argument_list|,
literal|"1"
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot set $RESTORE_VOLUME: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|popenfp
operator|=
name|popen
argument_list|(
name|magtape
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|mt
operator|=
name|popenfp
condition|?
name|fileno
argument_list|(
name|popenfp
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|host
condition|)
name|mt
operator|=
name|rmtopen
argument_list|(
name|magtape
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|pipein
condition|)
name|mt
operator|=
literal|0
expr_stmt|;
else|else
name|mt
operator|=
name|open
argument_list|(
name|magtape
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mt
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|magtape
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|volno
operator|=
literal|1
expr_stmt|;
name|setdumpnum
argument_list|()
expr_stmt|;
name|FLUSHTAPEBUF
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pipein
operator|&&
operator|!
name|pipecmdin
operator|&&
operator|!
name|bflag
condition|)
name|findtapeblksize
argument_list|()
expr_stmt|;
if|if
condition|(
name|gethead
argument_list|(
operator|&
name|spcl
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tape is not a dump tape\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pipein
condition|)
block|{
name|endoftapemark
operator|.
name|s_spcl
operator|.
name|c_magic
operator|=
name|FS_UFS2_MAGIC
expr_stmt|;
name|endoftapemark
operator|.
name|s_spcl
operator|.
name|c_type
operator|=
name|TS_END
expr_stmt|;
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|endoftapemark
expr_stmt|;
name|j
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|u_spcl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
name|i
operator|+=
operator|*
name|ip
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|j
condition|)
do|;
name|endoftapemark
operator|.
name|s_spcl
operator|.
name|c_checksum
operator|=
name|CHECKSUM
operator|-
name|i
expr_stmt|;
block|}
if|if
condition|(
name|vflag
operator|||
name|command
operator|==
literal|'t'
condition|)
name|printdumpinfo
argument_list|()
expr_stmt|;
name|dumptime
operator|=
name|_time64_to_time
argument_list|(
name|spcl
operator|.
name|c_ddate
argument_list|)
expr_stmt|;
name|dumpdate
operator|=
name|_time64_to_time
argument_list|(
name|spcl
operator|.
name|c_date
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot stat .: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stbuf
operator|.
name|st_blksize
operator|>
literal|0
operator|&&
name|stbuf
operator|.
name|st_blksize
operator|<
name|TP_BSIZE
condition|)
name|fssize
operator|=
name|TP_BSIZE
expr_stmt|;
if|if
condition|(
name|stbuf
operator|.
name|st_blksize
operator|>=
name|TP_BSIZE
operator|&&
name|stbuf
operator|.
name|st_blksize
operator|<=
name|MAXBSIZE
condition|)
name|fssize
operator|=
name|stbuf
operator|.
name|st_blksize
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|TP_BSIZE
operator|-
literal|1
operator|)
operator|&
name|stbuf
operator|.
name|st_blksize
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: filesystem with non-multiple-of-%d "
literal|"blocksize (%d);\n"
argument_list|,
name|TP_BSIZE
argument_list|,
name|stbuf
operator|.
name|st_blksize
argument_list|)
expr_stmt|;
name|fssize
operator|=
name|roundup
argument_list|(
name|fssize
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\twriting using blocksize %ld\n"
argument_list|,
name|fssize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spcl
operator|.
name|c_volume
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tape is not volume 1 of the dump\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gethead
argument_list|(
operator|&
name|spcl
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"header read failed at %ld blocks\n"
argument_list|,
name|blksread
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"no header after volume mark!\n"
argument_list|)
expr_stmt|;
block|}
name|findinode
argument_list|(
operator|&
name|spcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|spcl
operator|.
name|c_type
operator|!=
name|TS_CLRI
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot find file removal list\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|maxino
operator|=
operator|(
name|spcl
operator|.
name|c_count
operator|*
name|TP_BSIZE
operator|*
name|NBBY
operator|)
operator|+
literal|1
expr_stmt|;
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"maxino = %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|maxino
argument_list|)
expr_stmt|;
name|map
operator|=
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|howmany
argument_list|(
name|maxino
argument_list|,
name|NBBY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"no memory for active inode map\n"
argument_list|)
expr_stmt|;
name|usedinomap
operator|=
name|map
expr_stmt|;
name|curfile
operator|.
name|action
operator|=
name|USING
expr_stmt|;
name|getfile
argument_list|(
name|xtrmap
argument_list|,
name|xtrmapskip
argument_list|,
name|xtrmapskip
argument_list|)
expr_stmt|;
if|if
condition|(
name|spcl
operator|.
name|c_type
operator|!=
name|TS_BITS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot find file dump list\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|map
operator|=
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|howmany
argument_list|(
name|maxino
argument_list|,
name|NBBY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|panic
argument_list|(
literal|"no memory for file dump list\n"
argument_list|)
expr_stmt|;
name|dumpmap
operator|=
name|map
expr_stmt|;
name|curfile
operator|.
name|action
operator|=
name|USING
expr_stmt|;
name|getfile
argument_list|(
name|xtrmap
argument_list|,
name|xtrmapskip
argument_list|,
name|xtrmapskip
argument_list|)
expr_stmt|;
comment|/* 	 * If there may be whiteout entries on the tape, pretend that the 	 * whiteout inode exists, so that the whiteout entries can be 	 * extracted. 	 */
name|SETINO
argument_list|(
name|UFS_WINO
argument_list|,
name|dumpmap
argument_list|)
expr_stmt|;
comment|/* 'r' restores don't call getvol() for tape 1, so mark it as read. */
if|if
condition|(
name|command
operator|==
literal|'r'
condition|)
name|tapesread
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prompt user to load a new dump volume.  * "Nextvol" is the next suggested volume to use.  * This suggested volume is enforced when doing full  * or incremental restores, but can be overridden by  * the user when only extracting a subset of the files.  */
end_comment

begin_function
name|void
name|getvol
parameter_list|(
name|long
name|nextvol
parameter_list|)
block|{
name|int64_t
name|prevtapea
decl_stmt|;
name|long
name|i
decl_stmt|,
name|newvol
decl_stmt|,
name|savecnt
decl_stmt|;
name|union
name|u_spcl
name|tmpspcl
decl_stmt|;
define|#
directive|define
name|tmpbuf
value|tmpspcl.s_spcl
name|char
name|buf
index|[
name|TP_BSIZE
index|]
decl_stmt|;
if|if
condition|(
name|nextvol
operator|==
literal|1
condition|)
block|{
name|tapesread
operator|=
literal|0
expr_stmt|;
name|gettingfile
operator|=
literal|0
expr_stmt|;
block|}
name|prevtapea
operator|=
name|tapeaddr
expr_stmt|;
name|savecnt
operator|=
name|blksread
expr_stmt|;
if|if
condition|(
name|pipein
condition|)
block|{
if|if
condition|(
name|nextvol
operator|!=
literal|1
condition|)
block|{
name|panic
argument_list|(
literal|"Changing volumes on pipe input?\n"
argument_list|)
expr_stmt|;
comment|/* Avoid looping if we couldn't ask the user. */
if|if
condition|(
name|yflag
operator|||
name|ferror
argument_list|(
name|terminal
argument_list|)
operator|||
name|feof
argument_list|(
name|terminal
argument_list|)
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|volno
operator|==
literal|1
condition|)
return|return;
name|newvol
operator|=
literal|0
expr_stmt|;
goto|goto
name|gethdr
goto|;
block|}
name|again
label|:
if|if
condition|(
name|pipein
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* pipes do not get a second chance */
if|if
condition|(
name|command
operator|==
literal|'R'
operator|||
name|command
operator|==
literal|'r'
operator|||
name|curfile
operator|.
name|action
operator|!=
name|SKIP
condition|)
name|newvol
operator|=
name|nextvol
expr_stmt|;
else|else
name|newvol
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|newvol
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|tapesread
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%s%s%s%s%s%s"
argument_list|,
literal|"You have not read any tapes yet.\n"
argument_list|,
literal|"If you are extracting just a few files,"
argument_list|,
literal|" start with the last volume\n"
argument_list|,
literal|"and work towards the first; restore"
argument_list|,
literal|" can quickly skip tapes that\n"
argument_list|,
literal|"have no further files to extract."
argument_list|,
literal|" Otherwise, begin with volume 1.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You have read volumes"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tapesread
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%ld"
argument_list|,
name|buf
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Specify next volume #: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|terminal
argument_list|)
operator|==
name|NULL
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
do|;
name|newvol
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvol
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Volume numbers are positive numerics\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newvol
operator|==
name|volno
condition|)
block|{
name|tapesread
operator||=
literal|1
operator|<<
operator|(
name|volno
operator|-
literal|1
operator|)
expr_stmt|;
return|return;
block|}
name|closemt
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Mount tape volume %ld\n"
argument_list|,
name|newvol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Enter ``none'' if there are no more tapes\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"otherwise enter tape name (default: %s) "
argument_list|,
name|magtape
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|terminal
argument_list|)
operator|==
name|NULL
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"none\n"
argument_list|)
condition|)
block|{
name|terminateinput
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|magtape
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|magtape
index|[
name|strlen
argument_list|(
name|magtape
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|pipecmdin
condition|)
block|{
name|char
name|volno
index|[
sizeof|sizeof
argument_list|(
literal|"2147483647"
argument_list|)
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|volno
argument_list|,
literal|"%ld"
argument_list|,
name|newvol
argument_list|)
expr_stmt|;
if|if
condition|(
name|setenv
argument_list|(
literal|"RESTORE_VOLUME"
argument_list|,
name|volno
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot set $RESTORE_VOLUME: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|popenfp
operator|=
name|popen
argument_list|(
name|magtape
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|mt
operator|=
name|popenfp
condition|?
name|fileno
argument_list|(
name|popenfp
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|host
condition|)
name|mt
operator|=
name|rmtopen
argument_list|(
name|magtape
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|mt
operator|=
name|open
argument_list|(
name|magtape
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mt
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open %s\n"
argument_list|,
name|magtape
argument_list|)
expr_stmt|;
name|volno
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|gethdr
label|:
name|volno
operator|=
name|newvol
expr_stmt|;
name|setdumpnum
argument_list|()
expr_stmt|;
name|FLUSHTAPEBUF
argument_list|()
expr_stmt|;
if|if
condition|(
name|gethead
argument_list|(
operator|&
name|tmpbuf
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"header read failed at %ld blocks\n"
argument_list|,
name|blksread
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tape is not dump tape\n"
argument_list|)
expr_stmt|;
name|volno
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|tmpbuf
operator|.
name|c_volume
operator|!=
name|volno
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Wrong volume (%jd)\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|tmpbuf
operator|.
name|c_volume
argument_list|)
expr_stmt|;
name|volno
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|_time64_to_time
argument_list|(
name|tmpbuf
operator|.
name|c_date
argument_list|)
operator|!=
name|dumpdate
operator|||
name|_time64_to_time
argument_list|(
name|tmpbuf
operator|.
name|c_ddate
argument_list|)
operator|!=
name|dumptime
condition|)
block|{
name|time_t
name|t
init|=
name|_time64_to_time
argument_list|(
name|tmpbuf
operator|.
name|c_date
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Wrong dump date\n\tgot: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\twanted: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|dumpdate
argument_list|)
argument_list|)
expr_stmt|;
name|volno
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|tapesread
operator||=
literal|1
operator|<<
operator|(
name|volno
operator|-
literal|1
operator|)
expr_stmt|;
name|blksread
operator|=
name|savecnt
expr_stmt|;
comment|/*  	 * If continuing from the previous volume, skip over any  	 * blocks read already at the end of the previous volume.  	 *  	 * If coming to this volume at random, skip to the beginning  	 * of the next record.  	 */
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"last rec %jd, tape starts with %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|prevtapea
argument_list|,
operator|(
name|intmax_t
operator|)
name|tmpbuf
operator|.
name|c_tapea
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpbuf
operator|.
name|c_type
operator|==
name|TS_TAPE
condition|)
block|{
if|if
condition|(
name|curfile
operator|.
name|action
operator|!=
name|USING
condition|)
block|{
comment|/* 			 * XXX Dump incorrectly sets c_count to 1 in the 			 * volume header of the first tape, so ignore 			 * c_count when volno == 1. 			 */
if|if
condition|(
name|volno
operator|!=
literal|1
condition|)
for|for
control|(
name|i
operator|=
name|tmpbuf
operator|.
name|c_count
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|readtape
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmpbuf
operator|.
name|c_tapea
operator|<=
name|prevtapea
condition|)
block|{
comment|/* 			 * Normally the value of c_tapea in the volume 			 * header is the record number of the header itself. 			 * However in the volume header following an EOT- 			 * terminated tape, it is the record number of the 			 * first continuation data block (dump bug?). 			 * 			 * The next record we want is `prevtapea + 1'. 			 */
name|i
operator|=
name|prevtapea
operator|+
literal|1
operator|-
name|tmpbuf
operator|.
name|c_tapea
expr_stmt|;
name|dprintf
argument_list|(
name|stderr
argument_list|,
literal|"Skipping %ld duplicate record%s.\n"
argument_list|,
name|i
argument_list|,
name|i
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|readtape
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|curfile
operator|.
name|action
operator|==
name|USING
condition|)
block|{
if|if
condition|(
name|volno
operator|==
literal|1
condition|)
name|panic
argument_list|(
literal|"active file into volume 1\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|gethead
argument_list|(
operator|&
name|spcl
argument_list|)
expr_stmt|;
name|findinode
argument_list|(
operator|&
name|spcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettingfile
condition|)
block|{
name|gettingfile
operator|=
literal|0
expr_stmt|;
name|longjmp
argument_list|(
name|restart
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle unexpected EOF.  */
end_comment

begin_function
specifier|static
name|void
name|terminateinput
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|gettingfile
operator|&&
name|curfile
operator|.
name|action
operator|==
name|USING
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: %s %s\n"
argument_list|,
literal|"End-of-input encountered while extracting"
argument_list|,
name|curfile
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|curfile
operator|.
name|name
operator|=
literal|"<name unknown>"
expr_stmt|;
name|curfile
operator|.
name|action
operator|=
name|UNKNOWN
expr_stmt|;
name|curfile
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|curfile
operator|.
name|ino
operator|=
name|maxino
expr_stmt|;
if|if
condition|(
name|gettingfile
condition|)
block|{
name|gettingfile
operator|=
literal|0
expr_stmt|;
name|longjmp
argument_list|(
name|restart
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * handle multiple dumps per tape by skipping forward to the  * appropriate one.  */
end_comment

begin_function
specifier|static
name|void
name|setdumpnum
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mtop
name|tcom
decl_stmt|;
if|if
condition|(
name|dumpnum
operator|==
literal|1
operator|||
name|volno
operator|!=
literal|1
condition|)
return|return;
if|if
condition|(
name|pipein
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot have multiple dumps on pipe input\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tcom
operator|.
name|mt_op
operator|=
name|MTFSF
expr_stmt|;
name|tcom
operator|.
name|mt_count
operator|=
name|dumpnum
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|host
condition|)
name|rmtioctl
argument_list|(
name|MTFSF
argument_list|,
name|dumpnum
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|!
name|pipecmdin
operator|&&
name|ioctl
argument_list|(
name|mt
argument_list|,
name|MTIOCTOP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tcom
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ioctl MTFSF: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printdumpinfo
parameter_list|(
name|void
parameter_list|)
block|{
name|time_t
name|t
decl_stmt|;
name|t
operator|=
name|_time64_to_time
argument_list|(
name|spcl
operator|.
name|c_date
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Dump   date: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|_time64_to_time
argument_list|(
name|spcl
operator|.
name|c_ddate
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Dumped from: %s"
argument_list|,
operator|(
name|spcl
operator|.
name|c_ddate
operator|==
literal|0
operator|)
condition|?
literal|"the epoch\n"
else|:
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spcl
operator|.
name|c_host
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Level %jd dump of %s on %s:%s\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|spcl
operator|.
name|c_level
argument_list|,
name|spcl
operator|.
name|c_filesys
argument_list|,
name|spcl
operator|.
name|c_host
argument_list|,
name|spcl
operator|.
name|c_dev
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Label: %s\n"
argument_list|,
name|spcl
operator|.
name|c_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|extractfile
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|u_int
name|flags
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|int
name|extsize
decl_stmt|;
name|struct
name|timespec
name|mtimep
index|[
literal|2
index|]
decl_stmt|,
name|ctimep
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|entry
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|curfile
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|curfile
operator|.
name|action
operator|=
name|USING
expr_stmt|;
name|mtimep
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|curfile
operator|.
name|atime_sec
expr_stmt|;
name|mtimep
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|=
name|curfile
operator|.
name|atime_nsec
expr_stmt|;
name|mtimep
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|curfile
operator|.
name|mtime_sec
expr_stmt|;
name|mtimep
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|=
name|curfile
operator|.
name|mtime_nsec
expr_stmt|;
name|ctimep
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|curfile
operator|.
name|atime_sec
expr_stmt|;
name|ctimep
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|=
name|curfile
operator|.
name|atime_nsec
expr_stmt|;
name|ctimep
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|curfile
operator|.
name|birthtime_sec
expr_stmt|;
name|ctimep
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|=
name|curfile
operator|.
name|birthtime_nsec
expr_stmt|;
name|extsize
operator|=
name|curfile
operator|.
name|extsize
expr_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|uid
operator|==
literal|0
condition|)
name|uid
operator|=
name|curfile
operator|.
name|uid
expr_stmt|;
name|gid
operator|=
name|curfile
operator|.
name|gid
expr_stmt|;
name|mode
operator|=
name|curfile
operator|.
name|mode
expr_stmt|;
name|flags
operator|=
name|curfile
operator|.
name|file_flags
expr_stmt|;
switch|switch
condition|(
name|mode
operator|&
name|IFMT
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown file mode 0%o\n"
argument_list|,
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
case|case
name|IFSOCK
case|:
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"skipped socket %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
case|case
name|IFDIR
case|:
if|if
condition|(
name|mflag
condition|)
block|{
name|ep
operator|=
name|lookupname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
operator|||
name|ep
operator|->
name|e_flags
operator|&
name|EXTRACT
condition|)
name|panic
argument_list|(
literal|"unextracted directory %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"extract file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|genliteraldir
argument_list|(
name|name
argument_list|,
name|curfile
operator|.
name|ino
argument_list|)
operator|)
return|;
case|case
name|IFLNK
case|:
name|lnkbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pathlen
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|setupextattr
argument_list|(
name|extsize
argument_list|)
expr_stmt|;
name|getfile
argument_list|(
name|xtrlnkfile
argument_list|,
name|xtrattr
argument_list|,
name|xtrlnkskip
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathlen
operator|==
literal|0
condition|)
block|{
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s: zero length symbolic link (ignored)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
if|if
condition|(
name|linkit
argument_list|(
name|lnkbuf
argument_list|,
name|name
argument_list|,
name|SYMLINK
argument_list|)
operator|==
name|GOOD
condition|)
block|{
if|if
condition|(
name|extsize
operator|>
literal|0
condition|)
name|set_extattr
argument_list|(
operator|-
literal|1
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|extsize
argument_list|,
name|SXA_LINK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lchown
argument_list|(
name|name
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lchmod
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|utimensat
argument_list|(
name|AT_FDCWD
argument_list|,
name|name
argument_list|,
name|ctimep
argument_list|,
name|AT_SYMLINK_NOFOLLOW
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|utimensat
argument_list|(
name|AT_FDCWD
argument_list|,
name|name
argument_list|,
name|mtimep
argument_list|,
name|AT_SYMLINK_NOFOLLOW
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lchflags
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
return|return
operator|(
name|FAIL
operator|)
return|;
case|case
name|IFIFO
case|:
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"extract fifo %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Nflag
condition|)
block|{
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
if|if
condition|(
name|uflag
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkfifo
argument_list|(
name|name
argument_list|,
literal|0600
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot create fifo: %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
if|if
condition|(
name|extsize
operator|==
literal|0
condition|)
block|{
name|skipfile
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|setupextattr
argument_list|(
name|extsize
argument_list|)
expr_stmt|;
name|getfile
argument_list|(
name|xtrnull
argument_list|,
name|xtrattr
argument_list|,
name|xtrnull
argument_list|)
expr_stmt|;
name|set_extattr
argument_list|(
operator|-
literal|1
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|extsize
argument_list|,
name|SXA_FILE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|chown
argument_list|(
name|name
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|utimensat
argument_list|(
name|AT_FDCWD
argument_list|,
name|name
argument_list|,
name|ctimep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|utimensat
argument_list|(
name|AT_FDCWD
argument_list|,
name|name
argument_list|,
name|mtimep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chflags
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
case|case
name|IFCHR
case|:
case|case
name|IFBLK
case|:
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"extract special file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Nflag
condition|)
block|{
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
if|if
condition|(
name|uflag
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|name
argument_list|,
operator|(
name|mode
operator|&
operator|(
name|IFCHR
operator||
name|IFBLK
operator|)
operator|)
operator||
literal|0600
argument_list|,
operator|(
name|int
operator|)
name|curfile
operator|.
name|rdev
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot create special file: %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
if|if
condition|(
name|extsize
operator|==
literal|0
condition|)
block|{
name|skipfile
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|setupextattr
argument_list|(
name|extsize
argument_list|)
expr_stmt|;
name|getfile
argument_list|(
name|xtrnull
argument_list|,
name|xtrattr
argument_list|,
name|xtrnull
argument_list|)
expr_stmt|;
name|set_extattr
argument_list|(
operator|-
literal|1
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|extsize
argument_list|,
name|SXA_FILE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|chown
argument_list|(
name|name
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|utimensat
argument_list|(
name|AT_FDCWD
argument_list|,
name|name
argument_list|,
name|ctimep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|utimensat
argument_list|(
name|AT_FDCWD
argument_list|,
name|name
argument_list|,
name|mtimep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chflags
argument_list|(
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
case|case
name|IFREG
case|:
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"extract file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Nflag
condition|)
block|{
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
if|if
condition|(
name|uflag
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ofile
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot create file: %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|buf
operator|=
name|setupextattr
argument_list|(
name|extsize
argument_list|)
expr_stmt|;
name|getfile
argument_list|(
name|xtrfile
argument_list|,
name|xtrattr
argument_list|,
name|xtrskip
argument_list|)
expr_stmt|;
if|if
condition|(
name|extsize
operator|>
literal|0
condition|)
name|set_extattr
argument_list|(
name|ofile
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
name|extsize
argument_list|,
name|SXA_FD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fchown
argument_list|(
name|ofile
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fchmod
argument_list|(
name|ofile
argument_list|,
name|mode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|futimens
argument_list|(
name|ofile
argument_list|,
name|ctimep
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|futimens
argument_list|(
name|ofile
argument_list|,
name|mtimep
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fchflags
argument_list|(
name|ofile
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Set attributes on a file descriptor, link, or file.  */
end_comment

begin_function
name|void
name|set_extattr
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|enum
name|set_extattr_mode
name|mode
parameter_list|)
block|{
name|struct
name|extattr
modifier|*
name|eap
decl_stmt|,
modifier|*
name|eaend
decl_stmt|;
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
name|ssize_t
name|res
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|eaname
index|[
name|EXTATTR_MAXNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"Set attributes for %s:"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|eaend
operator|=
name|buf
operator|+
name|size
expr_stmt|;
for|for
control|(
name|eap
operator|=
name|buf
init|;
name|eap
operator|<
name|eaend
condition|;
name|eap
operator|=
name|EXTATTR_NEXT
argument_list|(
name|eap
argument_list|)
control|)
block|{
comment|/* 		 * Make sure this entry is complete. 		 */
if|if
condition|(
name|EXTATTR_NEXT
argument_list|(
name|eap
argument_list|)
operator|>
name|eaend
operator|||
name|eap
operator|->
name|ea_length
operator|<=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n\t%scorrupted"
argument_list|,
name|eap
operator|==
name|buf
condition|?
literal|""
else|:
literal|"remainder "
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|eap
operator|->
name|ea_namespace
operator|==
name|EXTATTR_NAMESPACE_EMPTY
condition|)
continue|continue;
name|snprintf
argument_list|(
name|eaname
argument_list|,
sizeof|sizeof
argument_list|(
name|eaname
argument_list|)
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|eap
operator|->
name|ea_namelength
argument_list|,
name|eap
operator|->
name|ea_name
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n\t%s, (%d bytes), %s"
argument_list|,
name|namespace_names
index|[
name|eap
operator|->
name|ea_namespace
index|]
argument_list|,
name|eap
operator|->
name|ea_length
argument_list|,
name|eaname
argument_list|)
expr_stmt|;
comment|/* 		 * First we try the general attribute setting interface. 		 * However, some attributes can only be set by root or 		 * by using special interfaces (for example, ACLs). 		 */
if|if
condition|(
name|mode
operator|==
name|SXA_FD
condition|)
block|{
name|res
operator|=
name|extattr_set_fd
argument_list|(
name|fd
argument_list|,
name|eap
operator|->
name|ea_namespace
argument_list|,
name|eaname
argument_list|,
name|EXTATTR_CONTENT
argument_list|(
name|eap
argument_list|)
argument_list|,
name|EXTATTR_CONTENT_SIZE
argument_list|(
name|eap
argument_list|)
argument_list|)
expr_stmt|;
name|method
operator|=
literal|"extattr_set_fd"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|SXA_LINK
condition|)
block|{
name|res
operator|=
name|extattr_set_link
argument_list|(
name|name
argument_list|,
name|eap
operator|->
name|ea_namespace
argument_list|,
name|eaname
argument_list|,
name|EXTATTR_CONTENT
argument_list|(
name|eap
argument_list|)
argument_list|,
name|EXTATTR_CONTENT_SIZE
argument_list|(
name|eap
argument_list|)
argument_list|)
expr_stmt|;
name|method
operator|=
literal|"extattr_set_link"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|SXA_FILE
condition|)
block|{
name|res
operator|=
name|extattr_set_file
argument_list|(
name|name
argument_list|,
name|eap
operator|->
name|ea_namespace
argument_list|,
name|eaname
argument_list|,
name|EXTATTR_CONTENT
argument_list|(
name|eap
argument_list|)
argument_list|,
name|EXTATTR_CONTENT_SIZE
argument_list|(
name|eap
argument_list|)
argument_list|)
expr_stmt|;
name|method
operator|=
literal|"extattr_set_file"
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|!=
operator|-
literal|1
condition|)
block|{
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|" (set using %s)"
argument_list|,
name|method
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If the general interface refuses to set the attribute, 		 * then we try all the specialized interfaces that we 		 * know about. 		 */
if|if
condition|(
name|eap
operator|->
name|ea_namespace
operator|==
name|EXTATTR_NAMESPACE_SYSTEM
operator|&&
name|strcmp
argument_list|(
name|eaname
argument_list|,
name|POSIX1E_ACL_ACCESS_EXTATTR_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|SXA_FD
condition|)
block|{
name|error
operator|=
name|acl_set_fd
argument_list|(
name|fd
argument_list|,
name|EXTATTR_CONTENT
argument_list|(
name|eap
argument_list|)
argument_list|)
expr_stmt|;
name|method
operator|=
literal|"acl_set_fd"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|SXA_LINK
condition|)
block|{
name|error
operator|=
name|acl_set_link_np
argument_list|(
name|name
argument_list|,
name|ACL_TYPE_ACCESS
argument_list|,
name|EXTATTR_CONTENT
argument_list|(
name|eap
argument_list|)
argument_list|)
expr_stmt|;
name|method
operator|=
literal|"acl_set_link_np"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|SXA_FILE
condition|)
block|{
name|error
operator|=
name|acl_set_file
argument_list|(
name|name
argument_list|,
name|ACL_TYPE_ACCESS
argument_list|,
name|EXTATTR_CONTENT
argument_list|(
name|eap
argument_list|)
argument_list|)
expr_stmt|;
name|method
operator|=
literal|"acl_set_file"
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
operator|-
literal|1
condition|)
block|{
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|" (set using %s)"
argument_list|,
name|method
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|eap
operator|->
name|ea_namespace
operator|==
name|EXTATTR_NAMESPACE_SYSTEM
operator|&&
name|strcmp
argument_list|(
name|eaname
argument_list|,
name|POSIX1E_ACL_DEFAULT_EXTATTR_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|SXA_LINK
condition|)
block|{
name|error
operator|=
name|acl_set_link_np
argument_list|(
name|name
argument_list|,
name|ACL_TYPE_DEFAULT
argument_list|,
name|EXTATTR_CONTENT
argument_list|(
name|eap
argument_list|)
argument_list|)
expr_stmt|;
name|method
operator|=
literal|"acl_set_link_np"
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|acl_set_file
argument_list|(
name|name
argument_list|,
name|ACL_TYPE_DEFAULT
argument_list|,
name|EXTATTR_CONTENT
argument_list|(
name|eap
argument_list|)
argument_list|)
expr_stmt|;
name|method
operator|=
literal|"acl_set_file"
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
operator|-
literal|1
condition|)
block|{
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|" (set using %s)"
argument_list|,
name|method
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|" (unable to set)"
argument_list|)
expr_stmt|;
block|}
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * skip over bit maps on the tape  */
end_comment

begin_function
name|void
name|skipmaps
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|spcl
operator|.
name|c_type
operator|==
name|TS_BITS
operator|||
name|spcl
operator|.
name|c_type
operator|==
name|TS_CLRI
condition|)
name|skipfile
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * skip over a file on the tape  */
end_comment

begin_function
name|void
name|skipfile
parameter_list|(
name|void
parameter_list|)
block|{
name|curfile
operator|.
name|action
operator|=
name|SKIP
expr_stmt|;
name|getfile
argument_list|(
name|xtrnull
argument_list|,
name|xtrnull
argument_list|,
name|xtrnull
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Skip a hole in an output file  */
end_comment

begin_function
specifier|static
name|void
name|skiphole
parameter_list|(
name|void
function_decl|(
modifier|*
name|skip
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
parameter_list|,
name|size_t
modifier|*
name|seekpos
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAXBSIZE
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|seekpos
operator|>
literal|0
condition|)
block|{
call|(
modifier|*
name|skip
call|)
argument_list|(
name|buf
argument_list|,
operator|*
name|seekpos
argument_list|)
expr_stmt|;
operator|*
name|seekpos
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Extract a file from the tape.  * When an allocated block is found it is passed to the fill function;  * when an unallocated block (hole) is found, a zeroed buffer is passed  * to the skip function.  */
end_comment

begin_function
name|void
name|getfile
parameter_list|(
name|void
function_decl|(
modifier|*
name|datafill
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|attrfill
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|skip
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|volatile
name|off_t
name|size
decl_stmt|;
name|size_t
name|seekpos
decl_stmt|;
name|int
name|curblk
decl_stmt|,
name|attrsize
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fillit
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|char
name|buf
index|[
name|MAXBSIZE
operator|/
name|TP_BSIZE
index|]
index|[
name|TP_BSIZE
index|]
decl_stmt|;
name|char
name|junk
index|[
name|TP_BSIZE
index|]
decl_stmt|;
name|curblk
operator|=
literal|0
expr_stmt|;
name|size
operator|=
name|spcl
operator|.
name|c_size
expr_stmt|;
name|seekpos
operator|=
literal|0
expr_stmt|;
name|attrsize
operator|=
name|spcl
operator|.
name|c_extsize
expr_stmt|;
if|if
condition|(
name|spcl
operator|.
name|c_type
operator|==
name|TS_END
condition|)
name|panic
argument_list|(
literal|"ran off end of tape\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spcl
operator|.
name|c_magic
operator|!=
name|FS_UFS2_MAGIC
condition|)
name|panic
argument_list|(
literal|"not at beginning of a file\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gettingfile
operator|&&
name|setjmp
argument_list|(
name|restart
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|gettingfile
operator|++
expr_stmt|;
name|fillit
operator|=
name|datafill
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|&&
name|attrsize
operator|>
literal|0
condition|)
block|{
name|fillit
operator|=
name|attrfill
expr_stmt|;
name|size
operator|=
name|attrsize
expr_stmt|;
name|attrsize
operator|=
literal|0
expr_stmt|;
block|}
name|loop
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spcl
operator|.
name|c_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|readmapflag
operator|&&
name|i
operator|>
name|TP_NINDIR
condition|)
block|{
if|if
condition|(
name|Dflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"spcl.c_count = %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|spcl
operator|.
name|c_count
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|panic
argument_list|(
literal|"spcl.c_count = %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|spcl
operator|.
name|c_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readmapflag
operator|||
name|spcl
operator|.
name|c_addr
index|[
name|i
index|]
condition|)
block|{
name|readtape
argument_list|(
operator|&
name|buf
index|[
name|curblk
operator|++
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|curblk
operator|==
name|fssize
operator|/
name|TP_BSIZE
condition|)
block|{
name|skiphole
argument_list|(
name|skip
argument_list|,
operator|&
name|seekpos
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fillit
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
call|(
name|long
call|)
argument_list|(
name|size
operator|>
name|TP_BSIZE
condition|?
name|fssize
else|:
operator|(
name|curblk
operator|-
literal|1
operator|)
operator|*
name|TP_BSIZE
operator|+
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|curblk
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|curblk
operator|>
literal|0
condition|)
block|{
name|skiphole
argument_list|(
name|skip
argument_list|,
operator|&
name|seekpos
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fillit
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
call|(
name|long
call|)
argument_list|(
name|size
operator|>
name|TP_BSIZE
condition|?
name|curblk
operator|*
name|TP_BSIZE
else|:
operator|(
name|curblk
operator|-
literal|1
operator|)
operator|*
name|TP_BSIZE
operator|+
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|curblk
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * We have a block of a hole. Don't skip it 			 * now, because there may be next adjacent 			 * block of the hole in the file. Postpone the 			 * seek until next file write. 			 */
name|seekpos
operator|+=
operator|(
name|long
operator|)
name|MIN
argument_list|(
name|TP_BSIZE
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size
operator|-=
name|TP_BSIZE
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|size
operator|>
operator|-
name|TP_BSIZE
operator|&&
name|curblk
operator|>
literal|0
condition|)
block|{
name|skiphole
argument_list|(
name|skip
argument_list|,
operator|&
name|seekpos
argument_list|)
expr_stmt|;
call|(
modifier|*
name|fillit
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|curblk
operator|*
name|TP_BSIZE
operator|)
operator|+
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|curblk
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|attrsize
operator|>
literal|0
condition|)
block|{
name|fillit
operator|=
name|attrfill
expr_stmt|;
name|size
operator|=
name|attrsize
expr_stmt|;
name|attrsize
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|spcl
operator|.
name|c_count
operator|-
name|i
operator|>
literal|1
condition|)
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"skipping %d junk block(s)\n"
argument_list|,
name|spcl
operator|.
name|c_count
operator|-
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|spcl
operator|.
name|c_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|readmapflag
operator|&&
name|i
operator|>
name|TP_NINDIR
condition|)
block|{
if|if
condition|(
name|Dflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"spcl.c_count = %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|spcl
operator|.
name|c_count
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|panic
argument_list|(
literal|"spcl.c_count = %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|spcl
operator|.
name|c_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readmapflag
operator|||
name|spcl
operator|.
name|c_addr
index|[
name|i
index|]
condition|)
name|readtape
argument_list|(
name|junk
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|gethead
argument_list|(
operator|&
name|spcl
argument_list|)
operator|==
name|GOOD
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|spcl
operator|.
name|c_type
operator|==
name|TS_ADDR
condition|)
goto|goto
name|loop
goto|;
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"Missing address (header) block for %s at %ld blocks\n"
argument_list|,
name|curfile
operator|.
name|name
argument_list|,
name|blksread
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curblk
operator|>
literal|0
condition|)
name|panic
argument_list|(
literal|"getfile: lost data\n"
argument_list|)
expr_stmt|;
name|findinode
argument_list|(
operator|&
name|spcl
argument_list|)
expr_stmt|;
name|gettingfile
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * These variables are shared between the next two functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|extbufsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|extbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|extloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate a buffer into which to extract extended attributes.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|setupextattr
parameter_list|(
name|int
name|extsize
parameter_list|)
block|{
name|extloc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|extsize
operator|<=
name|extbufsize
condition|)
return|return
operator|(
name|extbuf
operator|)
return|;
if|if
condition|(
name|extbufsize
operator|>
literal|0
condition|)
name|free
argument_list|(
name|extbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|extbuf
operator|=
name|malloc
argument_list|(
name|extsize
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|extbufsize
operator|=
name|extsize
expr_stmt|;
return|return
operator|(
name|extbuf
operator|)
return|;
block|}
name|extbufsize
operator|=
literal|0
expr_stmt|;
name|extbuf
operator|=
name|NULL
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot extract %d bytes %s for inode %ju, name %s\n"
argument_list|,
name|extsize
argument_list|,
literal|"of extended attributes"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|curfile
operator|.
name|ino
argument_list|,
name|curfile
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Extract the next block of extended attributes.  */
end_comment

begin_function
specifier|static
name|void
name|xtrattr
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|extloc
operator|+
name|size
operator|>
name|extbufsize
condition|)
name|panic
argument_list|(
literal|"overrun attribute buffer\n"
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|extbuf
index|[
name|extloc
index|]
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|extloc
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write out the next block of a file.  */
end_comment

begin_function
specifier|static
name|void
name|xtrfile
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|Nflag
condition|)
return|return;
if|if
condition|(
name|write
argument_list|(
name|ofile
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"write error extracting inode %ju, name %s\nwrite: %s\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|curfile
operator|.
name|ino
argument_list|,
name|curfile
operator|.
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Skip over a hole in a file.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|xtrskip
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|ofile
argument_list|,
name|size
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"seek error extracting inode %ju, name %s\nlseek: %s\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|curfile
operator|.
name|ino
argument_list|,
name|curfile
operator|.
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Collect the next block of a symbolic link.  */
end_comment

begin_function
specifier|static
name|void
name|xtrlnkfile
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|pathlen
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|pathlen
operator|>
name|MAXPATHLEN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"symbolic link name: %s->%s%s; too long %d\n"
argument_list|,
name|curfile
operator|.
name|name
argument_list|,
name|lnkbuf
argument_list|,
name|buf
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|lnkbuf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Skip over a hole in a symbolic link (should never happen).  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|xtrlnkskip
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unallocated block in symbolic link %s\n"
argument_list|,
name|curfile
operator|.
name|name
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Collect the next block of a bit map.  */
end_comment

begin_function
specifier|static
name|void
name|xtrmap
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|memmove
argument_list|(
name|map
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|map
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Skip over a hole in a bit map (should never happen).  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|xtrmapskip
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|panic
argument_list|(
literal|"hole in map\n"
argument_list|)
expr_stmt|;
name|map
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Noop, when an extraction function is not needed.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|xtrnull
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/*  * Read TP_BSIZE blocks from the input.  * Handle read errors, and end of media.  */
end_comment

begin_function
specifier|static
name|void
name|readtape
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|long
name|rd
decl_stmt|,
name|newvol
decl_stmt|,
name|i
decl_stmt|,
name|oldnumtrec
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|seek_failed
decl_stmt|;
if|if
condition|(
name|blkcnt
operator|+
operator|(
name|byteslide
operator|>
literal|0
operator|)
operator|<
name|numtrec
condition|)
block|{
name|memmove
argument_list|(
name|buf
argument_list|,
operator|&
name|tapebuf
index|[
operator|(
name|blkcnt
operator|++
operator|*
name|TP_BSIZE
operator|)
operator|+
name|byteslide
index|]
argument_list|,
operator|(
name|long
operator|)
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|blksread
operator|++
expr_stmt|;
name|tapeaddr
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|numtrec
operator|>
literal|0
condition|)
name|memmove
argument_list|(
operator|&
name|tapebuf
index|[
operator|-
name|TP_BSIZE
index|]
argument_list|,
operator|&
name|tapebuf
index|[
operator|(
name|numtrec
operator|-
literal|1
operator|)
operator|*
name|TP_BSIZE
index|]
argument_list|,
operator|(
name|long
operator|)
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|oldnumtrec
operator|=
name|numtrec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntrec
condition|;
name|i
operator|++
control|)
operator|(
operator|(
expr|struct
name|s_spcl
operator|*
operator|)
operator|&
name|tapebuf
index|[
name|i
operator|*
name|TP_BSIZE
index|]
operator|)
operator|->
name|c_magic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|numtrec
operator|==
literal|0
condition|)
name|numtrec
operator|=
name|ntrec
expr_stmt|;
name|cnt
operator|=
name|ntrec
operator|*
name|TP_BSIZE
expr_stmt|;
name|rd
operator|=
literal|0
expr_stmt|;
name|getmore
label|:
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|host
condition|)
name|i
operator|=
name|rmtread
argument_list|(
operator|&
name|tapebuf
index|[
name|rd
index|]
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|i
operator|=
name|read
argument_list|(
name|mt
argument_list|,
operator|&
name|tapebuf
index|[
name|rd
index|]
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* 	 * Check for mid-tape short read error. 	 * If found, skip rest of buffer and start with the next. 	 */
if|if
condition|(
operator|!
name|pipein
operator|&&
operator|!
name|pipecmdin
operator|&&
name|numtrec
operator|<
name|ntrec
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"mid-media short read error.\n"
argument_list|)
expr_stmt|;
name|numtrec
operator|=
name|ntrec
expr_stmt|;
block|}
comment|/* 	 * Handle partial block read. 	 */
if|if
condition|(
operator|(
name|pipein
operator|||
name|pipecmdin
operator|)
operator|&&
name|i
operator|==
literal|0
operator|&&
name|rd
operator|>
literal|0
condition|)
name|i
operator|=
name|rd
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|i
operator|!=
name|ntrec
operator|*
name|TP_BSIZE
condition|)
block|{
if|if
condition|(
name|pipein
operator|||
name|pipecmdin
condition|)
block|{
name|rd
operator|+=
name|i
expr_stmt|;
name|cnt
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
goto|goto
name|getmore
goto|;
name|i
operator|=
name|rd
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Short read. Process the blocks read. 			 */
if|if
condition|(
name|i
operator|%
name|TP_BSIZE
operator|!=
literal|0
condition|)
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"partial block read: %ld should be %ld\n"
argument_list|,
name|i
argument_list|,
name|ntrec
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|numtrec
operator|=
name|i
operator|/
name|TP_BSIZE
expr_stmt|;
block|}
block|}
comment|/* 	 * Handle read error. 	 */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tape read error while "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|curfile
operator|.
name|action
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"trying to set up tape\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNKNOWN
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"trying to resynchronize\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|USING
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"restoring %s\n"
argument_list|,
name|curfile
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKIP
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"skipping over inode %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|curfile
operator|.
name|ino
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|yflag
operator|&&
operator|!
name|reply
argument_list|(
literal|"continue"
argument_list|)
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|ntrec
operator|*
name|TP_BSIZE
expr_stmt|;
name|memset
argument_list|(
name|tapebuf
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|host
condition|)
name|seek_failed
operator|=
operator|(
name|rmtseek
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
name|seek_failed
operator|=
operator|(
name|lseek
argument_list|(
name|mt
argument_list|,
name|i
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|seek_failed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"continuation failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Handle end of tape. 	 */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"End-of-tape encountered\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pipein
condition|)
block|{
name|newvol
operator|=
name|volno
operator|+
literal|1
expr_stmt|;
name|volno
operator|=
literal|0
expr_stmt|;
name|numtrec
operator|=
literal|0
expr_stmt|;
name|getvol
argument_list|(
name|newvol
argument_list|)
expr_stmt|;
name|readtape
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rd
operator|%
name|TP_BSIZE
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"partial block read: %ld should be %ld\n"
argument_list|,
name|rd
argument_list|,
name|ntrec
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|terminateinput
argument_list|()
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|tapebuf
index|[
name|rd
index|]
argument_list|,
operator|&
name|endoftapemark
argument_list|,
operator|(
name|long
operator|)
name|TP_BSIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldnumtrec
operator|==
literal|0
condition|)
name|blkcnt
operator|=
literal|0
expr_stmt|;
else|else
name|blkcnt
operator|-=
name|oldnumtrec
expr_stmt|;
name|memmove
argument_list|(
name|buf
argument_list|,
operator|&
name|tapebuf
index|[
operator|(
name|blkcnt
operator|++
operator|*
name|TP_BSIZE
operator|)
operator|+
name|byteslide
index|]
argument_list|,
operator|(
name|long
operator|)
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|blksread
operator|++
expr_stmt|;
name|tapeaddr
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|findtapeblksize
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntrec
condition|;
name|i
operator|++
control|)
operator|(
operator|(
expr|struct
name|s_spcl
operator|*
operator|)
operator|&
name|tapebuf
index|[
name|i
operator|*
name|TP_BSIZE
index|]
operator|)
operator|->
name|c_magic
operator|=
literal|0
expr_stmt|;
name|blkcnt
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|host
condition|)
name|i
operator|=
name|rmtread
argument_list|(
name|tapebuf
argument_list|,
name|ntrec
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|i
operator|=
name|read
argument_list|(
name|mt
argument_list|,
name|tapebuf
argument_list|,
name|ntrec
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tape read error: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|%
name|TP_BSIZE
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tape block size (%ld) %s (%d)\n"
argument_list|,
name|i
argument_list|,
literal|"is not a multiple of dump block size"
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ntrec
operator|=
name|i
operator|/
name|TP_BSIZE
expr_stmt|;
name|numtrec
operator|=
name|ntrec
expr_stmt|;
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"Tape block size is %ld\n"
argument_list|,
name|ntrec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|closemt
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mt
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|pipecmdin
condition|)
block|{
name|pclose
argument_list|(
name|popenfp
argument_list|)
expr_stmt|;
name|popenfp
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|host
condition|)
name|rmtclose
argument_list|()
expr_stmt|;
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|mt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the next block from the tape.  * If it is not any valid header, return an error.  */
end_comment

begin_function
specifier|static
name|int
name|gethead
parameter_list|(
name|struct
name|s_spcl
modifier|*
name|buf
parameter_list|)
block|{
name|long
name|i
decl_stmt|;
name|readtape
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|c_magic
operator|!=
name|FS_UFS2_MAGIC
operator|&&
name|buf
operator|->
name|c_magic
operator|!=
name|NFS_MAGIC
condition|)
block|{
if|if
condition|(
name|buf
operator|->
name|c_magic
operator|==
name|OFS_MAGIC
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Format of dump tape is too old. Must use\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a version of restore from before 2002.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
if|if
condition|(
name|swabl
argument_list|(
name|buf
operator|->
name|c_magic
argument_list|)
operator|!=
name|FS_UFS2_MAGIC
operator|&&
name|buf
operator|->
name|c_magic
operator|!=
name|NFS_MAGIC
condition|)
block|{
if|if
condition|(
name|buf
operator|->
name|c_magic
operator|==
name|OFS_MAGIC
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Format of dump tape is too old. Must use\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a version of restore from before 2002.\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|Bcvt
condition|)
block|{
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"Note: Doing Byte swapping\n"
argument_list|)
expr_stmt|;
name|Bcvt
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|checksum
argument_list|(
operator|(
name|int
operator|*
operator|)
name|buf
argument_list|)
operator|==
name|FAIL
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
if|if
condition|(
name|Bcvt
condition|)
block|{
name|swabst
argument_list|(
operator|(
name|u_char
operator|*
operator|)
literal|"8l4s1q8l2q17l"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|swabst
argument_list|(
operator|(
name|u_char
operator|*
operator|)
literal|"l"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|buf
operator|->
name|c_level
argument_list|)
expr_stmt|;
name|swabst
argument_list|(
operator|(
name|u_char
operator|*
operator|)
literal|"2l4q"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|buf
operator|->
name|c_flags
argument_list|)
expr_stmt|;
block|}
name|readmapflag
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|buf
operator|->
name|c_type
condition|)
block|{
case|case
name|TS_CLRI
case|:
case|case
name|TS_BITS
case|:
comment|/* 		 * Have to patch up missing information in bit map headers 		 */
name|buf
operator|->
name|c_size
operator|=
name|buf
operator|->
name|c_count
operator|*
name|TP_BSIZE
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|c_count
operator|>
name|TP_NINDIR
condition|)
name|readmapflag
operator|=
literal|1
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buf
operator|->
name|c_count
condition|;
name|i
operator|++
control|)
name|buf
operator|->
name|c_addr
index|[
name|i
index|]
operator|++
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|TS_TAPE
case|:
if|if
condition|(
name|buf
operator|->
name|c_magic
operator|==
name|NFS_MAGIC
operator|&&
operator|(
name|buf
operator|->
name|c_flags
operator|&
name|NFS_DR_NEWINODEFMT
operator|)
operator|==
literal|0
condition|)
name|oldinofmt
operator|=
literal|1
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|TS_END
case|:
name|buf
operator|->
name|c_inumber
operator|=
literal|0
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|TS_ADDR
case|:
case|case
name|TS_INODE
case|:
comment|/* 		 * For old dump tapes, have to copy up old fields to 		 * new locations. 		 */
if|if
condition|(
name|buf
operator|->
name|c_magic
operator|==
name|NFS_MAGIC
condition|)
block|{
name|buf
operator|->
name|c_tapea
operator|=
name|buf
operator|->
name|c_old_tapea
expr_stmt|;
name|buf
operator|->
name|c_firstrec
operator|=
name|buf
operator|->
name|c_old_firstrec
expr_stmt|;
name|buf
operator|->
name|c_date
operator|=
name|_time32_to_time
argument_list|(
name|buf
operator|->
name|c_old_date
argument_list|)
expr_stmt|;
name|buf
operator|->
name|c_ddate
operator|=
name|_time32_to_time
argument_list|(
name|buf
operator|->
name|c_old_ddate
argument_list|)
expr_stmt|;
name|buf
operator|->
name|c_atime
operator|=
name|_time32_to_time
argument_list|(
name|buf
operator|->
name|c_old_atime
argument_list|)
expr_stmt|;
name|buf
operator|->
name|c_mtime
operator|=
name|_time32_to_time
argument_list|(
name|buf
operator|->
name|c_old_mtime
argument_list|)
expr_stmt|;
name|buf
operator|->
name|c_birthtime
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|c_birthtimensec
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|c_extsize
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"gethead: unknown inode type %d\n"
argument_list|,
name|buf
operator|->
name|c_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dumpdate
operator|!=
literal|0
operator|&&
name|_time64_to_time
argument_list|(
name|buf
operator|->
name|c_date
argument_list|)
operator|!=
name|dumpdate
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Header with wrong dumpdate.\n"
argument_list|)
expr_stmt|;
comment|/* 	 * If we're restoring a filesystem with the old (FreeBSD 1) 	 * format inodes, copy the uid/gid to the new location 	 */
if|if
condition|(
name|oldinofmt
condition|)
block|{
name|buf
operator|->
name|c_uid
operator|=
name|buf
operator|->
name|c_spare1
index|[
literal|1
index|]
expr_stmt|;
name|buf
operator|->
name|c_gid
operator|=
name|buf
operator|->
name|c_spare1
index|[
literal|2
index|]
expr_stmt|;
block|}
name|buf
operator|->
name|c_magic
operator|=
name|FS_UFS2_MAGIC
expr_stmt|;
name|tapeaddr
operator|=
name|buf
operator|->
name|c_tapea
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|accthdr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check that a header is where it belongs and predict the next header  */
end_comment

begin_function
specifier|static
name|void
name|accthdr
parameter_list|(
name|struct
name|s_spcl
modifier|*
name|header
parameter_list|)
block|{
specifier|static
name|ino_t
name|previno
init|=
literal|0x7fffffff
decl_stmt|;
specifier|static
name|int
name|prevtype
decl_stmt|;
specifier|static
name|long
name|predict
decl_stmt|;
name|long
name|blks
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|header
operator|->
name|c_type
operator|==
name|TS_TAPE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Volume header "
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|c_firstrec
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"begins with record %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|header
operator|->
name|c_firstrec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|previno
operator|=
literal|0x7fffffff
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|previno
operator|==
literal|0x7fffffff
condition|)
goto|goto
name|newcalc
goto|;
switch|switch
condition|(
name|prevtype
condition|)
block|{
case|case
name|TS_BITS
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Dumped inodes map header"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TS_CLRI
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Used inodes map header"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TS_INODE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File header, ino %ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|previno
argument_list|)
expr_stmt|;
break|break;
case|case
name|TS_ADDR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File continuation header, ino %ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|previno
argument_list|)
expr_stmt|;
break|break;
case|case
name|TS_END
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"End of tape header"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|predict
operator|!=
name|blksread
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"; predicted %ld blocks, got %ld blocks"
argument_list|,
name|predict
argument_list|,
name|blksread
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|newcalc
label|:
name|blks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|c_type
operator|!=
name|TS_END
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header
operator|->
name|c_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|readmapflag
operator|||
name|header
operator|->
name|c_addr
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|blks
operator|++
expr_stmt|;
name|predict
operator|=
name|blks
expr_stmt|;
name|blksread
operator|=
literal|0
expr_stmt|;
name|prevtype
operator|=
name|header
operator|->
name|c_type
expr_stmt|;
name|previno
operator|=
name|header
operator|->
name|c_inumber
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find an inode header.  * Complain if had to skip.  */
end_comment

begin_function
specifier|static
name|void
name|findinode
parameter_list|(
name|struct
name|s_spcl
modifier|*
name|header
parameter_list|)
block|{
specifier|static
name|long
name|skipcnt
init|=
literal|0
decl_stmt|;
name|long
name|i
decl_stmt|;
name|char
name|buf
index|[
name|TP_BSIZE
index|]
decl_stmt|;
name|int
name|htype
decl_stmt|;
name|curfile
operator|.
name|name
operator|=
literal|"<name unknown>"
expr_stmt|;
name|curfile
operator|.
name|action
operator|=
name|UNKNOWN
expr_stmt|;
name|curfile
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|curfile
operator|.
name|ino
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|htype
operator|=
name|header
operator|->
name|c_type
expr_stmt|;
switch|switch
condition|(
name|htype
condition|)
block|{
case|case
name|TS_ADDR
case|:
comment|/* 			 * Skip up to the beginning of the next record 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header
operator|->
name|c_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|header
operator|->
name|c_addr
index|[
name|i
index|]
condition|)
name|readtape
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|gethead
argument_list|(
name|header
argument_list|)
operator|==
name|FAIL
operator|||
name|_time64_to_time
argument_list|(
name|header
operator|->
name|c_date
argument_list|)
operator|!=
name|dumpdate
condition|)
block|{
name|skipcnt
operator|++
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
block|{
name|byteslide
operator|++
expr_stmt|;
if|if
condition|(
name|byteslide
operator|<
name|TP_BSIZE
condition|)
block|{
name|blkcnt
operator|--
expr_stmt|;
name|blksread
operator|--
expr_stmt|;
block|}
else|else
name|byteslide
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TS_INODE
case|:
name|curfile
operator|.
name|mode
operator|=
name|header
operator|->
name|c_mode
expr_stmt|;
name|curfile
operator|.
name|uid
operator|=
name|header
operator|->
name|c_uid
expr_stmt|;
name|curfile
operator|.
name|gid
operator|=
name|header
operator|->
name|c_gid
expr_stmt|;
name|curfile
operator|.
name|file_flags
operator|=
name|header
operator|->
name|c_file_flags
expr_stmt|;
name|curfile
operator|.
name|rdev
operator|=
name|header
operator|->
name|c_rdev
expr_stmt|;
name|curfile
operator|.
name|atime_sec
operator|=
name|header
operator|->
name|c_atime
expr_stmt|;
name|curfile
operator|.
name|atime_nsec
operator|=
name|header
operator|->
name|c_atimensec
expr_stmt|;
name|curfile
operator|.
name|mtime_sec
operator|=
name|header
operator|->
name|c_mtime
expr_stmt|;
name|curfile
operator|.
name|mtime_nsec
operator|=
name|header
operator|->
name|c_mtimensec
expr_stmt|;
name|curfile
operator|.
name|birthtime_sec
operator|=
name|header
operator|->
name|c_birthtime
expr_stmt|;
name|curfile
operator|.
name|birthtime_nsec
operator|=
name|header
operator|->
name|c_birthtimensec
expr_stmt|;
name|curfile
operator|.
name|extsize
operator|=
name|header
operator|->
name|c_extsize
expr_stmt|;
name|curfile
operator|.
name|size
operator|=
name|header
operator|->
name|c_size
expr_stmt|;
name|curfile
operator|.
name|ino
operator|=
name|header
operator|->
name|c_inumber
expr_stmt|;
break|break;
case|case
name|TS_END
case|:
comment|/* If we missed some tapes, get another volume. */
if|if
condition|(
name|tapesread
operator|&
operator|(
name|tapesread
operator|+
literal|1
operator|)
condition|)
block|{
name|getvol
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|curfile
operator|.
name|ino
operator|=
name|maxino
expr_stmt|;
break|break;
case|case
name|TS_CLRI
case|:
name|curfile
operator|.
name|name
operator|=
literal|"<file removal list>"
expr_stmt|;
break|break;
case|case
name|TS_BITS
case|:
name|curfile
operator|.
name|name
operator|=
literal|"<file dump list>"
expr_stmt|;
break|break;
case|case
name|TS_TAPE
case|:
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unexpected tape header\n"
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"unexpected tape header\n"
argument_list|)
expr_stmt|;
default|default:
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown tape header type %d\n"
argument_list|,
name|spcl
operator|.
name|c_type
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"unknown tape header type %d\n"
argument_list|,
name|spcl
operator|.
name|c_type
argument_list|)
expr_stmt|;
while|while
condition|(
name|gethead
argument_list|(
name|header
argument_list|)
operator|==
name|FAIL
operator|||
name|_time64_to_time
argument_list|(
name|header
operator|->
name|c_date
argument_list|)
operator|!=
name|dumpdate
condition|)
block|{
name|skipcnt
operator|++
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
block|{
name|byteslide
operator|++
expr_stmt|;
if|if
condition|(
name|byteslide
operator|<
name|TP_BSIZE
condition|)
block|{
name|blkcnt
operator|--
expr_stmt|;
name|blksread
operator|--
expr_stmt|;
block|}
else|else
name|byteslide
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|htype
operator|==
name|TS_ADDR
condition|)
do|;
if|if
condition|(
name|skipcnt
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"resync restore, skipped %ld %s\n"
argument_list|,
name|skipcnt
argument_list|,
name|Dflag
condition|?
literal|"bytes"
else|:
literal|"blocks"
argument_list|)
expr_stmt|;
name|skipcnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|checksum
parameter_list|(
name|int
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|u_spcl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|Bcvt
condition|)
block|{
do|do
name|i
operator|+=
operator|*
name|buf
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|j
condition|)
do|;
block|}
else|else
block|{
comment|/* What happens if we want to read restore tapes 			for a 16bit int machine??? */
do|do
name|i
operator|+=
name|swabl
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|j
condition|)
do|;
block|}
if|if
condition|(
name|i
operator|!=
name|CHECKSUM
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Checksum error %o, inode %ju file %s\n"
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|curfile
operator|.
name|ino
argument_list|,
name|curfile
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|RRESTORE
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_function
name|void
name|msg
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RRESTORE */
end_comment

begin_function
specifier|static
name|u_char
modifier|*
name|swabshort
parameter_list|(
name|u_char
modifier|*
name|sp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|sp
index|[
literal|0
index|]
expr_stmt|;
name|sp
index|[
literal|0
index|]
operator|=
name|sp
index|[
literal|1
index|]
expr_stmt|;
name|sp
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
block|}
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_char
modifier|*
name|swablong
parameter_list|(
name|u_char
modifier|*
name|sp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|sp
index|[
literal|0
index|]
expr_stmt|;
name|sp
index|[
literal|0
index|]
operator|=
name|sp
index|[
literal|3
index|]
expr_stmt|;
name|sp
index|[
literal|3
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|sp
index|[
literal|2
index|]
expr_stmt|;
name|sp
index|[
literal|2
index|]
operator|=
name|sp
index|[
literal|1
index|]
expr_stmt|;
name|sp
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|sp
operator|+=
literal|4
expr_stmt|;
block|}
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_char
modifier|*
name|swabquad
parameter_list|(
name|u_char
modifier|*
name|sp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|sp
index|[
literal|0
index|]
expr_stmt|;
name|sp
index|[
literal|0
index|]
operator|=
name|sp
index|[
literal|7
index|]
expr_stmt|;
name|sp
index|[
literal|7
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|sp
index|[
literal|1
index|]
expr_stmt|;
name|sp
index|[
literal|1
index|]
operator|=
name|sp
index|[
literal|6
index|]
expr_stmt|;
name|sp
index|[
literal|6
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|sp
index|[
literal|2
index|]
expr_stmt|;
name|sp
index|[
literal|2
index|]
operator|=
name|sp
index|[
literal|5
index|]
expr_stmt|;
name|sp
index|[
literal|5
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|sp
index|[
literal|3
index|]
expr_stmt|;
name|sp
index|[
literal|3
index|]
operator|=
name|sp
index|[
literal|4
index|]
expr_stmt|;
name|sp
index|[
literal|4
index|]
operator|=
name|c
expr_stmt|;
name|sp
operator|+=
literal|8
expr_stmt|;
block|}
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|swabst
parameter_list|(
name|u_char
modifier|*
name|cp
parameter_list|,
name|u_char
modifier|*
name|sp
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|n
operator|=
operator|(
name|n
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
case|case
literal|'w'
case|:
case|case
literal|'h'
case|:
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|swabshort
argument_list|(
name|sp
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|swablong
argument_list|(
name|sp
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|swabquad
argument_list|(
name|sp
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|sp
operator|+=
name|n
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown conversion character: %c\n"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|cp
operator|++
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_long
name|swabl
parameter_list|(
name|u_long
name|x
parameter_list|)
block|{
name|swabst
argument_list|(
operator|(
name|u_char
operator|*
operator|)
literal|"l"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

end_unit

