begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) UNIX System Laboratories, Inc.  All or some portions  * of this file are derived from material licensed to the  * University of California by American Telephone and Telegraph Co.  * or UNIX System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  *	$Id$  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1983 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)tape.c	5.21 (Berkeley) 2/22/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"restore.h"
end_include

begin_include
include|#
directive|include
file|<protocols/dumprestore.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_decl_stmt
specifier|static
name|long
name|fssize
init|=
name|MAXBSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mt
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipein
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|magtape
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bct
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|numtrec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tbf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|union
name|u_spcl
name|endoftapemark
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|blksread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|tapesread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|restart
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gettingfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* restart has a valid frame */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ofile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|lnkbuf
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pathlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Bcvt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Swap Bytes (for CCI or sun) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Qcvt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Swap quads (for sun) */
end_comment

begin_function_decl
name|u_long
name|swabl
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Set up an input source  */
end_comment

begin_macro
name|setinput
argument_list|(
argument|source
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|source
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
ifdef|#
directive|ifdef
name|RRESTORE
name|char
modifier|*
name|host
decl_stmt|,
modifier|*
name|tape
decl_stmt|;
name|char
modifier|*
name|ruser
decl_stmt|;
endif|#
directive|endif
endif|RRESTORE
name|char
modifier|*
name|strerror
parameter_list|()
function_decl|;
name|flsht
argument_list|()
expr_stmt|;
if|if
condition|(
name|bflag
condition|)
name|newtapebuf
argument_list|(
name|ntrec
argument_list|)
expr_stmt|;
else|else
name|newtapebuf
argument_list|(
name|NTREC
operator|>
name|HIGHDENSITYTREC
condition|?
name|NTREC
else|:
name|HIGHDENSITYTREC
argument_list|)
expr_stmt|;
name|terminal
operator|=
name|stdin
expr_stmt|;
ifdef|#
directive|ifdef
name|RRESTORE
name|host
operator|=
name|source
expr_stmt|;
name|tape
operator|=
name|index
argument_list|(
name|host
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|host
operator|=
name|index
argument_list|(
name|source
argument_list|,
literal|'@'
argument_list|)
operator|)
condition|)
block|{
operator|*
name|host
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ruser
operator|=
name|source
expr_stmt|;
block|}
else|else
block|{
name|host
operator|=
name|source
expr_stmt|;
name|ruser
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tape
operator|==
literal|0
condition|)
block|{
name|nohost
label|:
name|msg
argument_list|(
literal|"need keyletter ``f'' and device ``host:tape''\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|tape
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|magtape
argument_list|,
name|tape
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmthost
argument_list|(
name|host
argument_list|,
name|ruser
argument_list|)
operator|==
literal|0
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* no longer need or want root privileges */
else|#
directive|else
if|if
condition|(
name|strcmp
argument_list|(
name|source
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Since input is coming from a pipe we must establish 		 * our own connection to the terminal. 		 */
name|terminal
operator|=
name|fopen
argument_list|(
name|_PATH_TTY
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|terminal
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open %s: %s\n"
argument_list|,
name|_PATH_TTY
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|terminal
operator|=
name|fopen
argument_list|(
name|_PATH_DEVNULL
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|terminal
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open %s: %s\n"
argument_list|,
name|_PATH_DEVNULL
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|pipein
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|magtape
argument_list|,
name|source
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|RRESTORE
block|}
end_block

begin_macro
name|newtapebuf
argument_list|(
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|tbfsize
operator|=
operator|-
literal|1
expr_stmt|;
name|ntrec
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|tbfsize
condition|)
return|return;
if|if
condition|(
name|tbf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tbf
argument_list|)
expr_stmt|;
name|tbf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot allocate space for tape buffer\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tbfsize
operator|=
name|size
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Verify that the tape drive can be accessed and  * that it actually is a dump tape.  */
end_comment

begin_macro
name|setup
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
specifier|extern
name|int
name|xtrmap
argument_list|()
decl_stmt|,
name|xtrmapskip
argument_list|()
decl_stmt|;
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"Verify tape and initialize maps\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
operator|(
name|mt
operator|=
name|rmtopen
argument_list|(
name|magtape
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|pipein
condition|)
name|mt
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mt
operator|=
name|open
argument_list|(
name|magtape
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
name|perror
argument_list|(
name|magtape
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|volno
operator|=
literal|1
expr_stmt|;
name|setdumpnum
argument_list|()
expr_stmt|;
name|flsht
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pipein
operator|&&
operator|!
name|bflag
condition|)
name|findtapeblksize
argument_list|()
expr_stmt|;
if|if
condition|(
name|gethead
argument_list|(
operator|&
name|spcl
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|bct
operator|--
expr_stmt|;
comment|/* push back this block */
name|cvtflag
operator|++
expr_stmt|;
if|if
condition|(
name|gethead
argument_list|(
operator|&
name|spcl
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tape is not a dump tape\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Converting to new file system format.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pipein
condition|)
block|{
name|endoftapemark
operator|.
name|s_spcl
operator|.
name|c_magic
operator|=
name|cvtflag
condition|?
name|OFS_MAGIC
else|:
name|NFS_MAGIC
expr_stmt|;
name|endoftapemark
operator|.
name|s_spcl
operator|.
name|c_type
operator|=
name|TS_END
expr_stmt|;
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|endoftapemark
expr_stmt|;
name|j
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|u_spcl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
name|i
operator|+=
operator|*
name|ip
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|j
condition|)
do|;
name|endoftapemark
operator|.
name|s_spcl
operator|.
name|c_checksum
operator|=
name|CHECKSUM
operator|-
name|i
expr_stmt|;
block|}
if|if
condition|(
name|vflag
operator|||
name|command
operator|==
literal|'t'
condition|)
name|printdumpinfo
argument_list|()
expr_stmt|;
name|dumptime
operator|=
name|spcl
operator|.
name|c_ddate
expr_stmt|;
name|dumpdate
operator|=
name|spcl
operator|.
name|c_date
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"cannot stat ."
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stbuf
operator|.
name|st_blksize
operator|>
literal|0
operator|&&
name|stbuf
operator|.
name|st_blksize
operator|<=
name|MAXBSIZE
condition|)
name|fssize
operator|=
name|stbuf
operator|.
name|st_blksize
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|fssize
operator|-
literal|1
operator|)
operator|&
name|fssize
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad block size %d\n"
argument_list|,
name|fssize
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|checkvol
argument_list|(
operator|&
name|spcl
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tape is not volume 1 of the dump\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readhdr
argument_list|(
operator|&
name|spcl
argument_list|)
operator|==
name|FAIL
condition|)
name|panic
argument_list|(
literal|"no header after volume mark!\n"
argument_list|)
expr_stmt|;
name|findinode
argument_list|(
operator|&
name|spcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|checktype
argument_list|(
operator|&
name|spcl
argument_list|,
name|TS_CLRI
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot find file removal list\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|maxino
operator|=
operator|(
name|spcl
operator|.
name|c_count
operator|*
name|TP_BSIZE
operator|*
name|NBBY
operator|)
operator|+
literal|1
expr_stmt|;
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"maxino = %d\n"
argument_list|,
name|maxino
argument_list|)
expr_stmt|;
name|map
operator|=
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|howmany
argument_list|(
name|maxino
argument_list|,
name|NBBY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
operator|(
name|char
operator|*
operator|)
name|NIL
condition|)
name|panic
argument_list|(
literal|"no memory for file removal list\n"
argument_list|)
expr_stmt|;
name|clrimap
operator|=
name|map
expr_stmt|;
name|curfile
operator|.
name|action
operator|=
name|USING
expr_stmt|;
name|getfile
argument_list|(
name|xtrmap
argument_list|,
name|xtrmapskip
argument_list|)
expr_stmt|;
if|if
condition|(
name|checktype
argument_list|(
operator|&
name|spcl
argument_list|,
name|TS_BITS
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot find file dump list\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|map
operator|=
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|howmany
argument_list|(
name|maxino
argument_list|,
name|NBBY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|panic
argument_list|(
literal|"no memory for file dump list\n"
argument_list|)
expr_stmt|;
name|dumpmap
operator|=
name|map
expr_stmt|;
name|curfile
operator|.
name|action
operator|=
name|USING
expr_stmt|;
name|getfile
argument_list|(
name|xtrmap
argument_list|,
name|xtrmapskip
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Prompt user to load a new dump volume.  * "Nextvol" is the next suggested volume to use.  * This suggested volume is enforced when doing full  * or incremental restores, but can be overrridden by  * the user when only extracting a subset of the files.  */
end_comment

begin_macro
name|getvol
argument_list|(
argument|nextvol
argument_list|)
end_macro

begin_decl_stmt
name|long
name|nextvol
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|newvol
decl_stmt|;
name|long
name|savecnt
decl_stmt|,
name|i
decl_stmt|;
name|union
name|u_spcl
name|tmpspcl
decl_stmt|;
define|#
directive|define
name|tmpbuf
value|tmpspcl.s_spcl
name|char
name|buf
index|[
name|TP_BSIZE
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
if|if
condition|(
name|nextvol
operator|==
literal|1
condition|)
block|{
name|tapesread
operator|=
literal|0
expr_stmt|;
name|gettingfile
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pipein
condition|)
block|{
if|if
condition|(
name|nextvol
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"Changing volumes on pipe input?\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volno
operator|==
literal|1
condition|)
return|return;
goto|goto
name|gethdr
goto|;
block|}
name|savecnt
operator|=
name|blksread
expr_stmt|;
name|again
label|:
if|if
condition|(
name|pipein
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* pipes do not get a second chance */
if|if
condition|(
name|command
operator|==
literal|'R'
operator|||
name|command
operator|==
literal|'r'
operator|||
name|curfile
operator|.
name|action
operator|!=
name|SKIP
condition|)
name|newvol
operator|=
name|nextvol
expr_stmt|;
else|else
name|newvol
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|newvol
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|tapesread
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%s%s%s%s"
argument_list|,
literal|"You have not read any tapes yet.\n"
argument_list|,
literal|"Unless you know which volume your"
argument_list|,
literal|" file(s) are on you should start\n"
argument_list|,
literal|"with the last volume and work"
argument_list|,
literal|" towards towards the first.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You have read volumes"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tbf
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tapesread
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%d"
argument_list|,
name|tbf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tbf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Specify next volume #: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|tbf
argument_list|,
name|BUFSIZ
argument_list|,
name|terminal
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|feof
argument_list|(
name|terminal
argument_list|)
operator|&&
name|tbf
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
do|;
if|if
condition|(
name|feof
argument_list|(
name|terminal
argument_list|)
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|newvol
operator|=
name|atoi
argument_list|(
name|tbf
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvol
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Volume numbers are positive numerics\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newvol
operator|==
name|volno
condition|)
block|{
name|tapesread
operator||=
literal|1
operator|<<
name|volno
expr_stmt|;
return|return;
block|}
name|closemt
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Mount tape volume %d\n"
argument_list|,
name|newvol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Enter ``none'' if there are no more tapes\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"otherwise enter tape name (default: %s) "
argument_list|,
name|magtape
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|tbf
argument_list|,
name|BUFSIZ
argument_list|,
name|terminal
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|terminal
argument_list|)
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tbf
argument_list|,
literal|"none\n"
argument_list|)
condition|)
block|{
name|curfile
operator|.
name|name
operator|=
literal|"<name unknown>"
expr_stmt|;
name|curfile
operator|.
name|action
operator|=
name|UNKNOWN
expr_stmt|;
name|curfile
operator|.
name|dip
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|NIL
expr_stmt|;
name|curfile
operator|.
name|ino
operator|=
name|maxino
expr_stmt|;
if|if
condition|(
name|gettingfile
condition|)
block|{
name|gettingfile
operator|=
literal|0
expr_stmt|;
name|longjmp
argument_list|(
name|restart
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tbf
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|magtape
argument_list|,
name|tbf
argument_list|)
expr_stmt|;
name|magtape
index|[
name|strlen
argument_list|(
name|magtape
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
operator|(
name|mt
operator|=
name|rmtopen
argument_list|(
name|magtape
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|mt
operator|=
name|open
argument_list|(
name|magtape
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open %s\n"
argument_list|,
name|magtape
argument_list|)
expr_stmt|;
name|volno
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|gethdr
label|:
name|volno
operator|=
name|newvol
expr_stmt|;
name|setdumpnum
argument_list|()
expr_stmt|;
name|flsht
argument_list|()
expr_stmt|;
if|if
condition|(
name|readhdr
argument_list|(
operator|&
name|tmpbuf
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tape is not dump tape\n"
argument_list|)
expr_stmt|;
name|volno
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|checkvol
argument_list|(
operator|&
name|tmpbuf
argument_list|,
name|volno
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Wrong volume (%d)\n"
argument_list|,
name|tmpbuf
operator|.
name|c_volume
argument_list|)
expr_stmt|;
name|volno
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|tmpbuf
operator|.
name|c_date
operator|!=
name|dumpdate
operator|||
name|tmpbuf
operator|.
name|c_ddate
operator|!=
name|dumptime
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Wrong dump date\n\tgot: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|tmpbuf
operator|.
name|c_date
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\twanted: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|dumpdate
argument_list|)
argument_list|)
expr_stmt|;
name|volno
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|tapesread
operator||=
literal|1
operator|<<
name|volno
expr_stmt|;
name|blksread
operator|=
name|savecnt
expr_stmt|;
if|if
condition|(
name|curfile
operator|.
name|action
operator|==
name|USING
condition|)
block|{
if|if
condition|(
name|volno
operator|==
literal|1
condition|)
name|panic
argument_list|(
literal|"active file into volume 1\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Skip up to the beginning of the next record 	 */
if|if
condition|(
name|tmpbuf
operator|.
name|c_type
operator|==
name|TS_TAPE
operator|&&
operator|(
name|tmpbuf
operator|.
name|c_flags
operator|&
name|DR_NEWHEADER
operator|)
condition|)
for|for
control|(
name|i
operator|=
name|tmpbuf
operator|.
name|c_count
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|readtape
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gethead
argument_list|(
operator|&
name|spcl
argument_list|)
expr_stmt|;
name|findinode
argument_list|(
operator|&
name|spcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettingfile
condition|)
block|{
name|gettingfile
operator|=
literal|0
expr_stmt|;
name|longjmp
argument_list|(
name|restart
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * handle multiple dumps per tape by skipping forward to the  * appropriate one.  */
end_comment

begin_macro
name|setdumpnum
argument_list|()
end_macro

begin_block
block|{
name|struct
name|mtop
name|tcom
decl_stmt|;
if|if
condition|(
name|dumpnum
operator|==
literal|1
operator|||
name|volno
operator|!=
literal|1
condition|)
return|return;
if|if
condition|(
name|pipein
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot have multiple dumps on pipe input\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tcom
operator|.
name|mt_op
operator|=
name|MTFSF
expr_stmt|;
name|tcom
operator|.
name|mt_count
operator|=
name|dumpnum
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|RRESTORE
name|rmtioctl
argument_list|(
name|MTFSF
argument_list|,
name|dumpnum
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|mt
argument_list|,
operator|(
name|int
operator|)
name|MTIOCTOP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tcom
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"ioctl MTFSF"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|printdumpinfo
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Dump   date: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|spcl
operator|.
name|c_date
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Dumped from: %s"
argument_list|,
operator|(
name|spcl
operator|.
name|c_ddate
operator|==
literal|0
operator|)
condition|?
literal|"the epoch\n"
else|:
name|ctime
argument_list|(
operator|&
name|spcl
operator|.
name|c_ddate
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spcl
operator|.
name|c_host
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Level %d dump of %s on %s:%s\n"
argument_list|,
name|spcl
operator|.
name|c_level
argument_list|,
name|spcl
operator|.
name|c_filesys
argument_list|,
name|spcl
operator|.
name|c_host
argument_list|,
name|spcl
operator|.
name|c_dev
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Label: %s\n"
argument_list|,
name|spcl
operator|.
name|c_label
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|extractfile
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|mode
decl_stmt|;
name|struct
name|timeval
name|timep
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|entry
modifier|*
name|ep
decl_stmt|;
specifier|extern
name|int
name|xtrlnkfile
argument_list|()
decl_stmt|,
name|xtrlnkskip
argument_list|()
decl_stmt|;
specifier|extern
name|int
name|xtrfile
argument_list|()
decl_stmt|,
name|xtrskip
argument_list|()
decl_stmt|;
name|curfile
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|curfile
operator|.
name|action
operator|=
name|USING
expr_stmt|;
name|timep
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|curfile
operator|.
name|dip
operator|->
name|di_atime
expr_stmt|;
name|timep
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|timep
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|curfile
operator|.
name|dip
operator|->
name|di_mtime
expr_stmt|;
name|timep
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
name|curfile
operator|.
name|dip
operator|->
name|di_mode
expr_stmt|;
switch|switch
condition|(
name|mode
operator|&
name|IFMT
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown file mode 0%o\n"
argument_list|,
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
case|case
name|IFSOCK
case|:
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"skipped socket %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
case|case
name|IFDIR
case|:
if|if
condition|(
name|mflag
condition|)
block|{
name|ep
operator|=
name|lookupname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NIL
operator|||
name|ep
operator|->
name|e_flags
operator|&
name|EXTRACT
condition|)
name|panic
argument_list|(
literal|"unextracted directory %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"extract file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|genliteraldir
argument_list|(
name|name
argument_list|,
name|curfile
operator|.
name|ino
argument_list|)
operator|)
return|;
case|case
name|IFLNK
case|:
name|lnkbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pathlen
operator|=
literal|0
expr_stmt|;
name|getfile
argument_list|(
name|xtrlnkfile
argument_list|,
name|xtrlnkskip
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathlen
operator|==
literal|0
condition|)
block|{
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s: zero length symbolic link (ignored)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
return|return
operator|(
name|linkit
argument_list|(
name|lnkbuf
argument_list|,
name|name
argument_list|,
name|SYMLINK
argument_list|)
operator|)
return|;
case|case
name|IFCHR
case|:
case|case
name|IFBLK
case|:
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"extract special file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Nflag
condition|)
block|{
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
if|if
condition|(
name|mknod
argument_list|(
name|name
argument_list|,
name|mode
argument_list|,
operator|(
name|int
operator|)
name|curfile
operator|.
name|dip
operator|->
name|di_rdev
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"cannot create special file"
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|chown
argument_list|(
name|name
argument_list|,
name|curfile
operator|.
name|dip
operator|->
name|di_uid
argument_list|,
name|curfile
operator|.
name|dip
operator|->
name|di_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
name|utimes
argument_list|(
name|name
argument_list|,
name|timep
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
case|case
name|IFREG
case|:
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"extract file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Nflag
condition|)
block|{
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ofile
operator|=
name|creat
argument_list|(
name|name
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"cannot create file"
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fchown
argument_list|(
name|ofile
argument_list|,
name|curfile
operator|.
name|dip
operator|->
name|di_uid
argument_list|,
name|curfile
operator|.
name|dip
operator|->
name|di_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fchmod
argument_list|(
name|ofile
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|getfile
argument_list|(
name|xtrfile
argument_list|,
name|xtrskip
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
name|utimes
argument_list|(
name|name
argument_list|,
name|timep
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*  * skip over bit maps on the tape  */
end_comment

begin_macro
name|skipmaps
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|checktype
argument_list|(
operator|&
name|spcl
argument_list|,
name|TS_CLRI
argument_list|)
operator|==
name|GOOD
operator|||
name|checktype
argument_list|(
operator|&
name|spcl
argument_list|,
name|TS_BITS
argument_list|)
operator|==
name|GOOD
condition|)
name|skipfile
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * skip over a file on the tape  */
end_comment

begin_macro
name|skipfile
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|null
parameter_list|()
function_decl|;
name|curfile
operator|.
name|action
operator|=
name|SKIP
expr_stmt|;
name|getfile
argument_list|(
name|null
argument_list|,
name|null
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Do the file extraction, calling the supplied functions  * with the blocks  */
end_comment

begin_macro
name|getfile
argument_list|(
argument|f1
argument_list|,
argument|f2
argument_list|)
end_macro

begin_decl_stmt
name|int
argument_list|(
operator|*
name|f2
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|f1
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|curblk
init|=
literal|0
decl_stmt|;
name|off_t
name|size
init|=
name|spcl
operator|.
name|c_dinode
operator|.
name|di_size
decl_stmt|;
specifier|static
name|char
name|clearedbuf
index|[
name|MAXBSIZE
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXBSIZE
operator|/
name|TP_BSIZE
index|]
index|[
name|TP_BSIZE
index|]
decl_stmt|;
name|char
name|junk
index|[
name|TP_BSIZE
index|]
decl_stmt|;
if|if
condition|(
name|checktype
argument_list|(
operator|&
name|spcl
argument_list|,
name|TS_END
argument_list|)
operator|==
name|GOOD
condition|)
name|panic
argument_list|(
literal|"ran off end of tape\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ishead
argument_list|(
operator|&
name|spcl
argument_list|)
operator|==
name|FAIL
condition|)
name|panic
argument_list|(
literal|"not at beginning of a file\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gettingfile
operator|&&
name|setjmp
argument_list|(
name|restart
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|gettingfile
operator|++
expr_stmt|;
name|loop
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spcl
operator|.
name|c_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|spcl
operator|.
name|c_addr
index|[
name|i
index|]
condition|)
block|{
name|readtape
argument_list|(
operator|&
name|buf
index|[
name|curblk
operator|++
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|curblk
operator|==
name|fssize
operator|/
name|TP_BSIZE
condition|)
block|{
call|(
modifier|*
name|f1
call|)
argument_list|(
name|buf
argument_list|,
name|size
operator|>
name|TP_BSIZE
condition|?
call|(
name|long
call|)
argument_list|(
name|fssize
argument_list|)
else|:
operator|(
name|curblk
operator|-
literal|1
operator|)
operator|*
name|TP_BSIZE
operator|+
name|size
argument_list|)
expr_stmt|;
name|curblk
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|curblk
operator|>
literal|0
condition|)
block|{
call|(
modifier|*
name|f1
call|)
argument_list|(
name|buf
argument_list|,
name|size
operator|>
name|TP_BSIZE
condition|?
call|(
name|long
call|)
argument_list|(
name|curblk
operator|*
name|TP_BSIZE
argument_list|)
else|:
operator|(
name|curblk
operator|-
literal|1
operator|)
operator|*
name|TP_BSIZE
operator|+
name|size
argument_list|)
expr_stmt|;
name|curblk
operator|=
literal|0
expr_stmt|;
block|}
call|(
modifier|*
name|f2
call|)
argument_list|(
name|clearedbuf
argument_list|,
name|size
operator|>
name|TP_BSIZE
condition|?
operator|(
name|long
operator|)
name|TP_BSIZE
else|:
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size
operator|-=
name|TP_BSIZE
operator|)
operator|<=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|spcl
operator|.
name|c_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|spcl
operator|.
name|c_addr
index|[
name|i
index|]
condition|)
name|readtape
argument_list|(
name|junk
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|readhdr
argument_list|(
operator|&
name|spcl
argument_list|)
operator|==
name|GOOD
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|checktype
argument_list|(
operator|&
name|spcl
argument_list|,
name|TS_ADDR
argument_list|)
operator|==
name|GOOD
condition|)
goto|goto
name|loop
goto|;
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"Missing address (header) block for %s\n"
argument_list|,
name|curfile
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curblk
operator|>
literal|0
condition|)
call|(
modifier|*
name|f1
call|)
argument_list|(
name|buf
argument_list|,
operator|(
name|curblk
operator|*
name|TP_BSIZE
operator|)
operator|+
name|size
argument_list|)
expr_stmt|;
name|findinode
argument_list|(
operator|&
name|spcl
argument_list|)
expr_stmt|;
name|gettingfile
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The next routines are called during file extraction to  * put the data into the right form and place.  */
end_comment

begin_macro
name|xtrfile
argument_list|(
argument|buf
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Nflag
condition|)
return|return;
if|if
condition|(
name|write
argument_list|(
name|ofile
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"write error extracting inode %d, name %s\n"
argument_list|,
name|curfile
operator|.
name|ino
argument_list|,
name|curfile
operator|.
name|name
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|xtrskip
argument_list|(
argument|buf
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|lint
name|buf
operator|=
name|buf
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lseek
argument_list|(
name|ofile
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
operator|==
operator|(
name|long
operator|)
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"seek error extracting inode %d, name %s\n"
argument_list|,
name|curfile
operator|.
name|ino
argument_list|,
name|curfile
operator|.
name|name
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"lseek"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|xtrlnkfile
argument_list|(
argument|buf
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|pathlen
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|pathlen
operator|>
name|MAXPATHLEN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"symbolic link name: %s->%s%s; too long %d\n"
argument_list|,
name|curfile
operator|.
name|name
argument_list|,
name|lnkbuf
argument_list|,
name|buf
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|lnkbuf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|xtrlnkskip
argument_list|(
argument|buf
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|lint
name|buf
operator|=
name|buf
operator|,
name|size
operator|=
name|size
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unallocated block in symbolic link %s\n"
argument_list|,
name|curfile
operator|.
name|name
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|xtrmap
argument_list|(
argument|buf
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bcopy
argument_list|(
name|buf
argument_list|,
name|map
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|map
operator|+=
name|size
expr_stmt|;
block|}
end_block

begin_macro
name|xtrmapskip
argument_list|(
argument|buf
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|lint
name|buf
operator|=
name|buf
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"hole in map\n"
argument_list|)
expr_stmt|;
name|map
operator|+=
name|size
expr_stmt|;
block|}
end_block

begin_macro
name|null
argument_list|()
end_macro

begin_block
block|{
empty_stmt|;
block|}
end_block

begin_comment
comment|/*  * Do the tape i/o, dealing with volume changes  * etc..  */
end_comment

begin_macro
name|readtape
argument_list|(
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
name|i
decl_stmt|;
name|long
name|rd
decl_stmt|,
name|newvol
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|top
label|:
if|if
condition|(
name|bct
operator|<
name|numtrec
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|tbf
index|[
operator|(
name|bct
operator|++
operator|*
name|TP_BSIZE
operator|)
index|]
argument_list|,
name|b
argument_list|,
operator|(
name|long
operator|)
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|blksread
operator|++
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntrec
condition|;
name|i
operator|++
control|)
operator|(
operator|(
expr|struct
name|s_spcl
operator|*
operator|)
operator|&
name|tbf
index|[
name|i
operator|*
name|TP_BSIZE
index|]
operator|)
operator|->
name|c_magic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|numtrec
operator|==
literal|0
condition|)
name|numtrec
operator|=
name|ntrec
expr_stmt|;
name|cnt
operator|=
name|ntrec
operator|*
name|TP_BSIZE
expr_stmt|;
name|rd
operator|=
literal|0
expr_stmt|;
name|getmore
label|:
ifdef|#
directive|ifdef
name|RRESTORE
name|i
operator|=
name|rmtread
argument_list|(
operator|&
name|tbf
index|[
name|rd
index|]
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
else|#
directive|else
name|i
operator|=
name|read
argument_list|(
name|mt
argument_list|,
operator|&
name|tbf
index|[
name|rd
index|]
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Check for mid-tape short read error. 	 * If found, return rest of buffer. 	 */
if|if
condition|(
name|numtrec
operator|<
name|ntrec
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
name|numtrec
operator|=
name|ntrec
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/* 	 * Handle partial block read. 	 */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|i
operator|!=
name|ntrec
operator|*
name|TP_BSIZE
condition|)
block|{
if|if
condition|(
name|pipein
condition|)
block|{
name|rd
operator|+=
name|i
expr_stmt|;
name|cnt
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
goto|goto
name|getmore
goto|;
name|i
operator|=
name|rd
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|%
name|TP_BSIZE
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"partial block read: %d should be %d\n"
argument_list|,
name|i
argument_list|,
name|ntrec
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|numtrec
operator|=
name|i
operator|/
name|TP_BSIZE
expr_stmt|;
block|}
block|}
comment|/* 	 * Handle read error. 	 */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tape read error while "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|curfile
operator|.
name|action
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"trying to set up tape\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNKNOWN
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"trying to resynchronize\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|USING
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"restoring %s\n"
argument_list|,
name|curfile
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKIP
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"skipping over inode %d\n"
argument_list|,
name|curfile
operator|.
name|ino
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|yflag
operator|&&
operator|!
name|reply
argument_list|(
literal|"continue"
argument_list|)
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|ntrec
operator|*
name|TP_BSIZE
expr_stmt|;
name|bzero
argument_list|(
name|tbf
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|rmtseek
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|lseek
argument_list|(
name|mt
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
operator|==
operator|(
name|long
operator|)
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
name|perror
argument_list|(
literal|"continuation failed"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Handle end of tape. 	 */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|pipein
condition|)
block|{
name|newvol
operator|=
name|volno
operator|+
literal|1
expr_stmt|;
name|volno
operator|=
literal|0
expr_stmt|;
name|numtrec
operator|=
literal|0
expr_stmt|;
name|getvol
argument_list|(
name|newvol
argument_list|)
expr_stmt|;
name|readtape
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rd
operator|%
name|TP_BSIZE
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"partial block read: %d should be %d\n"
argument_list|,
name|rd
argument_list|,
name|ntrec
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|endoftapemark
argument_list|,
operator|&
name|tbf
index|[
name|rd
index|]
argument_list|,
operator|(
name|long
operator|)
name|TP_BSIZE
argument_list|)
expr_stmt|;
block|}
name|bct
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|tbf
index|[
operator|(
name|bct
operator|++
operator|*
name|TP_BSIZE
operator|)
index|]
argument_list|,
name|b
argument_list|,
operator|(
name|long
operator|)
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|blksread
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|findtapeblksize
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntrec
condition|;
name|i
operator|++
control|)
operator|(
operator|(
expr|struct
name|s_spcl
operator|*
operator|)
operator|&
name|tbf
index|[
name|i
operator|*
name|TP_BSIZE
index|]
operator|)
operator|->
name|c_magic
operator|=
literal|0
expr_stmt|;
name|bct
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RRESTORE
name|i
operator|=
name|rmtread
argument_list|(
name|tbf
argument_list|,
name|ntrec
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
else|#
directive|else
name|i
operator|=
name|read
argument_list|(
name|mt
argument_list|,
name|tbf
argument_list|,
name|ntrec
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Tape read error"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|%
name|TP_BSIZE
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tape block size (%d) %s (%d)\n"
argument_list|,
name|i
argument_list|,
literal|"is not a multiple of dump block size"
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ntrec
operator|=
name|i
operator|/
name|TP_BSIZE
expr_stmt|;
name|numtrec
operator|=
name|ntrec
expr_stmt|;
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"Tape block size is %d\n"
argument_list|,
name|ntrec
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|flsht
argument_list|()
end_macro

begin_block
block|{
name|bct
operator|=
name|ntrec
operator|+
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|closemt
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|mt
operator|<
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|RRESTORE
name|rmtclose
argument_list|()
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|close
argument_list|(
name|mt
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|checkvol
argument_list|(
argument|b
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|s_spcl
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|b
operator|->
name|c_volume
operator|!=
name|t
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_macro
name|readhdr
argument_list|(
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|s_spcl
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|gethead
argument_list|(
name|b
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"readhdr fails at %d blocks\n"
argument_list|,
name|blksread
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * read the tape into buf, then return whether or  * or not it is a header block.  */
end_comment

begin_macro
name|gethead
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|s_spcl
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|i
decl_stmt|;
union|union
name|u_ospcl
block|{
name|char
name|dummy
index|[
name|TP_BSIZE
index|]
decl_stmt|;
struct|struct
name|s_ospcl
block|{
name|long
name|c_type
decl_stmt|;
name|long
name|c_date
decl_stmt|;
name|long
name|c_ddate
decl_stmt|;
name|long
name|c_volume
decl_stmt|;
name|long
name|c_tapea
decl_stmt|;
name|u_short
name|c_inumber
decl_stmt|;
name|long
name|c_magic
decl_stmt|;
name|long
name|c_checksum
decl_stmt|;
struct|struct
name|odinode
block|{
name|unsigned
name|short
name|odi_mode
decl_stmt|;
name|u_short
name|odi_nlink
decl_stmt|;
name|u_short
name|odi_uid
decl_stmt|;
name|u_short
name|odi_gid
decl_stmt|;
name|long
name|odi_size
decl_stmt|;
name|long
name|odi_rdev
decl_stmt|;
name|char
name|odi_addr
index|[
literal|36
index|]
decl_stmt|;
name|long
name|odi_atime
decl_stmt|;
name|long
name|odi_mtime
decl_stmt|;
name|long
name|odi_ctime
decl_stmt|;
block|}
name|c_dinode
struct|;
name|long
name|c_count
decl_stmt|;
name|char
name|c_addr
index|[
literal|256
index|]
decl_stmt|;
block|}
name|s_ospcl
struct|;
block|}
name|u_ospcl
union|;
if|if
condition|(
operator|!
name|cvtflag
condition|)
block|{
name|readtape
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|c_magic
operator|!=
name|NFS_MAGIC
condition|)
block|{
if|if
condition|(
name|swabl
argument_list|(
name|buf
operator|->
name|c_magic
argument_list|)
operator|!=
name|NFS_MAGIC
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
if|if
condition|(
operator|!
name|Bcvt
condition|)
block|{
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"Note: Doing Byte swapping\n"
argument_list|)
expr_stmt|;
name|Bcvt
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|checksum
argument_list|(
operator|(
name|int
operator|*
operator|)
name|buf
argument_list|)
operator|==
name|FAIL
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
if|if
condition|(
name|Bcvt
condition|)
name|swabst
argument_list|(
literal|"8l4s31l"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|good
goto|;
block|}
name|readtape
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|u_ospcl
operator|.
name|s_ospcl
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|long
operator|)
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|buf
operator|->
name|c_type
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_type
expr_stmt|;
name|buf
operator|->
name|c_date
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_date
expr_stmt|;
name|buf
operator|->
name|c_ddate
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_ddate
expr_stmt|;
name|buf
operator|->
name|c_volume
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_volume
expr_stmt|;
name|buf
operator|->
name|c_tapea
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_tapea
expr_stmt|;
name|buf
operator|->
name|c_inumber
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_inumber
expr_stmt|;
name|buf
operator|->
name|c_checksum
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_checksum
expr_stmt|;
name|buf
operator|->
name|c_magic
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_magic
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_mode
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_mode
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_nlink
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_nlink
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_uid
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_uid
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_gid
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_gid
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_size
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_size
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_rdev
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_rdev
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_atime
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_atime
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_mtime
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_mtime
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_ctime
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_ctime
expr_stmt|;
name|buf
operator|->
name|c_count
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_count
expr_stmt|;
name|bcopy
argument_list|(
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_addr
argument_list|,
name|buf
operator|->
name|c_addr
argument_list|,
operator|(
name|long
operator|)
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_magic
operator|!=
name|OFS_MAGIC
operator|||
name|checksum
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|u_ospcl
operator|.
name|s_ospcl
operator|)
argument_list|)
operator|==
name|FAIL
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
name|buf
operator|->
name|c_magic
operator|=
name|NFS_MAGIC
expr_stmt|;
name|good
label|:
if|if
condition|(
name|buf
operator|->
name|c_dinode
operator|.
name|di_size
operator|==
literal|0
operator|&&
operator|(
name|buf
operator|->
name|c_dinode
operator|.
name|di_mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
operator|&&
name|Qcvt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|buf
operator|->
name|c_dinode
operator|.
name|di_qsize
operator|.
name|val
index|[
literal|0
index|]
operator|||
name|buf
operator|->
name|c_dinode
operator|.
name|di_qsize
operator|.
name|val
index|[
literal|1
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"Note: Doing Quad swapping\n"
argument_list|)
expr_stmt|;
name|Qcvt
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Qcvt
condition|)
block|{
name|i
operator|=
name|buf
operator|->
name|c_dinode
operator|.
name|di_qsize
operator|.
name|val
index|[
literal|1
index|]
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_qsize
operator|.
name|val
index|[
literal|1
index|]
operator|=
name|buf
operator|->
name|c_dinode
operator|.
name|di_qsize
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_qsize
operator|.
name|val
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
block|}
switch|switch
condition|(
name|buf
operator|->
name|c_type
condition|)
block|{
case|case
name|TS_CLRI
case|:
case|case
name|TS_BITS
case|:
comment|/* 		 * Have to patch up missing information in bit map headers 		 */
name|buf
operator|->
name|c_inumber
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_size
operator|=
name|buf
operator|->
name|c_count
operator|*
name|TP_BSIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buf
operator|->
name|c_count
condition|;
name|i
operator|++
control|)
name|buf
operator|->
name|c_addr
index|[
name|i
index|]
operator|++
expr_stmt|;
break|break;
case|case
name|TS_TAPE
case|:
case|case
name|TS_END
case|:
name|buf
operator|->
name|c_inumber
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TS_INODE
case|:
case|case
name|TS_ADDR
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"gethead: unknown inode type %d\n"
argument_list|,
name|buf
operator|->
name|c_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dflag
condition|)
name|accthdr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Check that a header is where it belongs and predict the next header  */
end_comment

begin_macro
name|accthdr
argument_list|(
argument|header
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|s_spcl
modifier|*
name|header
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|ino_t
name|previno
init|=
literal|0x7fffffff
decl_stmt|;
specifier|static
name|int
name|prevtype
decl_stmt|;
specifier|static
name|long
name|predict
decl_stmt|;
name|long
name|blks
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|header
operator|->
name|c_type
operator|==
name|TS_TAPE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Volume header\n"
argument_list|)
expr_stmt|;
name|previno
operator|=
literal|0x7fffffff
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|previno
operator|==
literal|0x7fffffff
condition|)
goto|goto
name|newcalc
goto|;
switch|switch
condition|(
name|prevtype
condition|)
block|{
case|case
name|TS_BITS
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Dump mask header"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TS_CLRI
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Remove mask header"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TS_INODE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File header, ino %d"
argument_list|,
name|previno
argument_list|)
expr_stmt|;
break|break;
case|case
name|TS_ADDR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File continuation header, ino %d"
argument_list|,
name|previno
argument_list|)
expr_stmt|;
break|break;
case|case
name|TS_END
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"End of tape header"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|predict
operator|!=
name|blksread
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"; predicted %d blocks, got %d blocks"
argument_list|,
name|predict
argument_list|,
name|blksread
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|newcalc
label|:
name|blks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|c_type
operator|!=
name|TS_END
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header
operator|->
name|c_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|header
operator|->
name|c_addr
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|blks
operator|++
expr_stmt|;
name|predict
operator|=
name|blks
expr_stmt|;
name|blksread
operator|=
literal|0
expr_stmt|;
name|prevtype
operator|=
name|header
operator|->
name|c_type
expr_stmt|;
name|previno
operator|=
name|header
operator|->
name|c_inumber
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Find an inode header.  * Complain if had to skip, and complain is set.  */
end_comment

begin_macro
name|findinode
argument_list|(
argument|header
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|s_spcl
modifier|*
name|header
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|long
name|skipcnt
init|=
literal|0
decl_stmt|;
name|long
name|i
decl_stmt|;
name|char
name|buf
index|[
name|TP_BSIZE
index|]
decl_stmt|;
name|curfile
operator|.
name|name
operator|=
literal|"<name unknown>"
expr_stmt|;
name|curfile
operator|.
name|action
operator|=
name|UNKNOWN
expr_stmt|;
name|curfile
operator|.
name|dip
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|NIL
expr_stmt|;
name|curfile
operator|.
name|ino
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ishead
argument_list|(
name|header
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|skipcnt
operator|++
expr_stmt|;
while|while
condition|(
name|gethead
argument_list|(
name|header
argument_list|)
operator|==
name|FAIL
operator|||
name|header
operator|->
name|c_date
operator|!=
name|dumpdate
condition|)
name|skipcnt
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|checktype
argument_list|(
name|header
argument_list|,
name|TS_ADDR
argument_list|)
operator|==
name|GOOD
condition|)
block|{
comment|/* 			 * Skip up to the beginning of the next record 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header
operator|->
name|c_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|header
operator|->
name|c_addr
index|[
name|i
index|]
condition|)
name|readtape
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gethead
argument_list|(
name|header
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|checktype
argument_list|(
name|header
argument_list|,
name|TS_INODE
argument_list|)
operator|==
name|GOOD
condition|)
block|{
name|curfile
operator|.
name|dip
operator|=
operator|&
name|header
operator|->
name|c_dinode
expr_stmt|;
name|curfile
operator|.
name|ino
operator|=
name|header
operator|->
name|c_inumber
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|checktype
argument_list|(
name|header
argument_list|,
name|TS_END
argument_list|)
operator|==
name|GOOD
condition|)
block|{
name|curfile
operator|.
name|ino
operator|=
name|maxino
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|checktype
argument_list|(
name|header
argument_list|,
name|TS_CLRI
argument_list|)
operator|==
name|GOOD
condition|)
block|{
name|curfile
operator|.
name|name
operator|=
literal|"<file removal list>"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|checktype
argument_list|(
name|header
argument_list|,
name|TS_BITS
argument_list|)
operator|==
name|GOOD
condition|)
block|{
name|curfile
operator|.
name|name
operator|=
literal|"<file dump list>"
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|gethead
argument_list|(
name|header
argument_list|)
operator|==
name|FAIL
condition|)
name|skipcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|skipcnt
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"resync restore, skipped %d blocks\n"
argument_list|,
name|skipcnt
argument_list|)
expr_stmt|;
name|skipcnt
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * return whether or not the buffer contains a header block  */
end_comment

begin_macro
name|ishead
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|s_spcl
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|buf
operator|->
name|c_magic
operator|!=
name|NFS_MAGIC
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_macro
name|checktype
argument_list|(
argument|b
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|s_spcl
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|b
operator|->
name|c_type
operator|!=
name|t
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|checksum
argument_list|(
name|b
argument_list|)
specifier|register
name|int
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|u_spcl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|Bcvt
condition|)
block|{
do|do
name|i
operator|+=
operator|*
name|b
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|j
condition|)
do|;
block|}
else|else
block|{
comment|/* What happens if we want to read restore tapes 			for a 16bit int machine??? */
do|do
name|i
operator|+=
name|swabl
argument_list|(
operator|*
name|b
operator|++
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|j
condition|)
do|;
block|}
if|if
condition|(
name|i
operator|!=
name|CHECKSUM
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Checksum error %o, inode %d file %s\n"
argument_list|,
name|i
argument_list|,
name|curfile
operator|.
name|ino
argument_list|,
name|curfile
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|RRESTORE
end_ifdef

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|msg
argument_list|(
argument|cp
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|cp
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|RRESTORE
end_endif

begin_function
name|u_char
modifier|*
name|swabshort
parameter_list|(
name|sp
parameter_list|,
name|n
parameter_list|)
specifier|register
name|u_char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|sp
index|[
literal|0
index|]
expr_stmt|;
name|sp
index|[
literal|0
index|]
operator|=
name|sp
index|[
literal|1
index|]
expr_stmt|;
name|sp
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
block|}
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
name|u_char
modifier|*
name|swablong
parameter_list|(
name|sp
parameter_list|,
name|n
parameter_list|)
specifier|register
name|u_char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|sp
index|[
literal|0
index|]
expr_stmt|;
name|sp
index|[
literal|0
index|]
operator|=
name|sp
index|[
literal|3
index|]
expr_stmt|;
name|sp
index|[
literal|3
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|sp
index|[
literal|2
index|]
expr_stmt|;
name|sp
index|[
literal|2
index|]
operator|=
name|sp
index|[
literal|1
index|]
expr_stmt|;
name|sp
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|sp
operator|+=
literal|4
expr_stmt|;
block|}
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|swabst
argument_list|(
name|cp
argument_list|,
name|sp
argument_list|)
specifier|register
name|u_char
operator|*
name|cp
operator|,
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|u_char
name|c
decl_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|n
operator|=
operator|(
name|n
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
case|case
literal|'w'
case|:
case|case
literal|'h'
case|:
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|swabshort
argument_list|(
name|sp
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|swablong
argument_list|(
name|sp
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Any other character, like 'b' counts as byte. */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|sp
operator|+=
name|n
expr_stmt|;
break|break;
block|}
name|cp
operator|++
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_function
name|u_long
name|swabl
parameter_list|(
name|x
parameter_list|)
name|u_long
name|x
decl_stmt|;
block|{
name|swabst
argument_list|(
literal|"l"
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

end_unit

