begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)tape.c	8.3 (Berkeley) 4/1/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<protocols/dumprestore.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"restore.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_decl_stmt
specifier|static
name|long
name|fssize
init|=
name|MAXBSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mt
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipein
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|magtape
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|blkcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|numtrec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tapebuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|union
name|u_spcl
name|endoftapemark
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|blksread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* blocks read since last header */
end_comment

begin_decl_stmt
specifier|static
name|long
name|tpblksread
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TP_BSIZE blocks read */
end_comment

begin_decl_stmt
specifier|static
name|long
name|tapesread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|restart
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gettingfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* restart has a valid frame */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|host
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ofile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|lnkbuf
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pathlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|oldinofmt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* old inode format conversion required */
end_comment

begin_decl_stmt
name|int
name|Bcvt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Swap Bytes (for CCI or sun) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Qcvt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Swap quads (for sun) */
end_comment

begin_define
define|#
directive|define
name|FLUSHTAPEBUF
parameter_list|()
value|blkcnt = ntrec + 1
end_define

begin_decl_stmt
specifier|static
name|void
name|accthdr
name|__P
argument_list|(
operator|(
expr|struct
name|s_spcl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|checksum
name|__P
argument_list|(
operator|(
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|findinode
name|__P
argument_list|(
operator|(
expr|struct
name|s_spcl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|findtapeblksize
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gethead
name|__P
argument_list|(
operator|(
expr|struct
name|s_spcl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|readtape
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setdumpnum
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|swabl
name|__P
argument_list|(
operator|(
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|swablong
name|__P
argument_list|(
operator|(
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|swabshort
name|__P
argument_list|(
operator|(
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|terminateinput
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtrfile
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtrlnkfile
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtrlnkskip
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtrmap
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtrmapskip
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xtrskip
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set up an input source  */
end_comment

begin_function
name|void
name|setinput
parameter_list|(
name|source
parameter_list|)
name|char
modifier|*
name|source
decl_stmt|;
block|{
name|FLUSHTAPEBUF
argument_list|()
expr_stmt|;
if|if
condition|(
name|bflag
condition|)
name|newtapebuf
argument_list|(
name|ntrec
argument_list|)
expr_stmt|;
else|else
name|newtapebuf
argument_list|(
name|NTREC
operator|>
name|HIGHDENSITYTREC
condition|?
name|NTREC
else|:
name|HIGHDENSITYTREC
argument_list|)
expr_stmt|;
name|terminal
operator|=
name|stdin
expr_stmt|;
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|index
argument_list|(
name|source
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|host
operator|=
name|source
expr_stmt|;
name|source
operator|=
name|index
argument_list|(
name|host
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|source
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rmthost
argument_list|(
name|host
argument_list|)
operator|==
literal|0
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|source
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Since input is coming from a pipe we must establish 		 * our own connection to the terminal. 		 */
name|terminal
operator|=
name|fopen
argument_list|(
name|_PATH_TTY
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|terminal
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot open %s: %s\n"
argument_list|,
name|_PATH_TTY
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|terminal
operator|=
name|fopen
argument_list|(
name|_PATH_DEVNULL
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|terminal
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot open %s: %s\n"
argument_list|,
name|_PATH_DEVNULL
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|pipein
operator|++
expr_stmt|;
block|}
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* no longer need or want root privileges */
name|magtape
operator|=
name|strdup
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|magtape
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot allocate space for magtape buffer\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|newtapebuf
parameter_list|(
name|size
parameter_list|)
name|long
name|size
decl_stmt|;
block|{
specifier|static
name|tapebufsize
operator|=
operator|-
literal|1
expr_stmt|;
name|ntrec
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|tapebufsize
condition|)
return|return;
if|if
condition|(
name|tapebuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tapebuf
argument_list|)
expr_stmt|;
name|tapebuf
operator|=
name|malloc
argument_list|(
name|size
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tapebuf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot allocate space for tape buffer\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tapebufsize
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify that the tape drive can be accessed and  * that it actually is a dump tape.  */
end_comment

begin_function
name|void
name|setup
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"Verify tape and initialize maps\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|host
condition|)
name|mt
operator|=
name|rmtopen
argument_list|(
name|magtape
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|pipein
condition|)
name|mt
operator|=
literal|0
expr_stmt|;
else|else
name|mt
operator|=
name|open
argument_list|(
name|magtape
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mt
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|magtape
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|volno
operator|=
literal|1
expr_stmt|;
name|setdumpnum
argument_list|()
expr_stmt|;
name|FLUSHTAPEBUF
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pipein
operator|&&
operator|!
name|bflag
condition|)
name|findtapeblksize
argument_list|()
expr_stmt|;
if|if
condition|(
name|gethead
argument_list|(
operator|&
name|spcl
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|blkcnt
operator|--
expr_stmt|;
comment|/* push back this block */
name|blksread
operator|--
expr_stmt|;
name|tpblksread
operator|--
expr_stmt|;
name|cvtflag
operator|++
expr_stmt|;
if|if
condition|(
name|gethead
argument_list|(
operator|&
name|spcl
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tape is not a dump tape\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Converting to new file system format.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pipein
condition|)
block|{
name|endoftapemark
operator|.
name|s_spcl
operator|.
name|c_magic
operator|=
name|cvtflag
condition|?
name|OFS_MAGIC
else|:
name|NFS_MAGIC
expr_stmt|;
name|endoftapemark
operator|.
name|s_spcl
operator|.
name|c_type
operator|=
name|TS_END
expr_stmt|;
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|endoftapemark
expr_stmt|;
name|j
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|u_spcl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
name|i
operator|+=
operator|*
name|ip
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|j
condition|)
do|;
name|endoftapemark
operator|.
name|s_spcl
operator|.
name|c_checksum
operator|=
name|CHECKSUM
operator|-
name|i
expr_stmt|;
block|}
if|if
condition|(
name|vflag
operator|||
name|command
operator|==
literal|'t'
condition|)
name|printdumpinfo
argument_list|()
expr_stmt|;
name|dumptime
operator|=
name|spcl
operator|.
name|c_ddate
expr_stmt|;
name|dumpdate
operator|=
name|spcl
operator|.
name|c_date
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot stat .: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stbuf
operator|.
name|st_blksize
operator|>
literal|0
operator|&&
name|stbuf
operator|.
name|st_blksize
operator|<=
name|MAXBSIZE
condition|)
name|fssize
operator|=
name|stbuf
operator|.
name|st_blksize
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|fssize
operator|-
literal|1
operator|)
operator|&
name|fssize
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad block size %d\n"
argument_list|,
name|fssize
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spcl
operator|.
name|c_volume
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tape is not volume 1 of the dump\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gethead
argument_list|(
operator|&
name|spcl
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"header read failed at %d blocks\n"
argument_list|,
name|blksread
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"no header after volume mark!\n"
argument_list|)
expr_stmt|;
block|}
name|findinode
argument_list|(
operator|&
name|spcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|spcl
operator|.
name|c_type
operator|!=
name|TS_CLRI
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot find file removal list\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|maxino
operator|=
operator|(
name|spcl
operator|.
name|c_count
operator|*
name|TP_BSIZE
operator|*
name|NBBY
operator|)
operator|+
literal|1
expr_stmt|;
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"maxino = %d\n"
argument_list|,
name|maxino
argument_list|)
expr_stmt|;
name|map
operator|=
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|howmany
argument_list|(
name|maxino
argument_list|,
name|NBBY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"no memory for file removal list\n"
argument_list|)
expr_stmt|;
name|clrimap
operator|=
name|map
expr_stmt|;
name|curfile
operator|.
name|action
operator|=
name|USING
expr_stmt|;
name|getfile
argument_list|(
name|xtrmap
argument_list|,
name|xtrmapskip
argument_list|)
expr_stmt|;
if|if
condition|(
name|spcl
operator|.
name|c_type
operator|!=
name|TS_BITS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot find file dump list\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|map
operator|=
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|howmany
argument_list|(
name|maxino
argument_list|,
name|NBBY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|panic
argument_list|(
literal|"no memory for file dump list\n"
argument_list|)
expr_stmt|;
name|dumpmap
operator|=
name|map
expr_stmt|;
name|curfile
operator|.
name|action
operator|=
name|USING
expr_stmt|;
name|getfile
argument_list|(
name|xtrmap
argument_list|,
name|xtrmapskip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prompt user to load a new dump volume.  * "Nextvol" is the next suggested volume to use.  * This suggested volume is enforced when doing full  * or incremental restores, but can be overrridden by  * the user when only extracting a subset of the files.  */
end_comment

begin_function
name|void
name|getvol
parameter_list|(
name|nextvol
parameter_list|)
name|long
name|nextvol
decl_stmt|;
block|{
name|long
name|newvol
decl_stmt|,
name|savecnt
decl_stmt|,
name|wantnext
decl_stmt|,
name|i
decl_stmt|;
name|union
name|u_spcl
name|tmpspcl
decl_stmt|;
define|#
directive|define
name|tmpbuf
value|tmpspcl.s_spcl
name|char
name|buf
index|[
name|TP_BSIZE
index|]
decl_stmt|;
if|if
condition|(
name|nextvol
operator|==
literal|1
condition|)
block|{
name|tapesread
operator|=
literal|0
expr_stmt|;
name|gettingfile
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pipein
condition|)
block|{
if|if
condition|(
name|nextvol
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"Changing volumes on pipe input?\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volno
operator|==
literal|1
condition|)
return|return;
goto|goto
name|gethdr
goto|;
block|}
name|savecnt
operator|=
name|blksread
expr_stmt|;
name|again
label|:
if|if
condition|(
name|pipein
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* pipes do not get a second chance */
if|if
condition|(
name|command
operator|==
literal|'R'
operator|||
name|command
operator|==
literal|'r'
operator|||
name|curfile
operator|.
name|action
operator|!=
name|SKIP
condition|)
block|{
name|newvol
operator|=
name|nextvol
expr_stmt|;
name|wantnext
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|newvol
operator|=
literal|0
expr_stmt|;
name|wantnext
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|newvol
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|tapesread
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%s%s%s%s"
argument_list|,
literal|"You have not read any tapes yet.\n"
argument_list|,
literal|"Unless you know which volume your"
argument_list|,
literal|" file(s) are on you should start\n"
argument_list|,
literal|"with the last volume and work"
argument_list|,
literal|" towards the first.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You have read volumes"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tapesread
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%d"
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Specify next volume #: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|terminal
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|feof
argument_list|(
name|terminal
argument_list|)
operator|&&
name|buf
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
do|;
if|if
condition|(
name|feof
argument_list|(
name|terminal
argument_list|)
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|newvol
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvol
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Volume numbers are positive numerics\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newvol
operator|==
name|volno
condition|)
block|{
name|tapesread
operator||=
literal|1
operator|<<
name|volno
expr_stmt|;
return|return;
block|}
name|closemt
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Mount tape volume %d\n"
argument_list|,
name|newvol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Enter ``none'' if there are no more tapes\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"otherwise enter tape name (default: %s) "
argument_list|,
name|magtape
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|terminal
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|terminal
argument_list|)
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"none\n"
argument_list|)
condition|)
block|{
name|terminateinput
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|magtape
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|magtape
index|[
name|strlen
argument_list|(
name|magtape
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|host
condition|)
name|mt
operator|=
name|rmtopen
argument_list|(
name|magtape
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|mt
operator|=
name|open
argument_list|(
name|magtape
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mt
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open %s\n"
argument_list|,
name|magtape
argument_list|)
expr_stmt|;
name|volno
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|gethdr
label|:
name|volno
operator|=
name|newvol
expr_stmt|;
name|setdumpnum
argument_list|()
expr_stmt|;
name|FLUSHTAPEBUF
argument_list|()
expr_stmt|;
if|if
condition|(
name|gethead
argument_list|(
operator|&
name|tmpbuf
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"header read failed at %d blocks\n"
argument_list|,
name|blksread
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tape is not dump tape\n"
argument_list|)
expr_stmt|;
name|volno
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|tmpbuf
operator|.
name|c_volume
operator|!=
name|volno
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Wrong volume (%d)\n"
argument_list|,
name|tmpbuf
operator|.
name|c_volume
argument_list|)
expr_stmt|;
name|volno
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|tmpbuf
operator|.
name|c_date
operator|!=
name|dumpdate
operator|||
name|tmpbuf
operator|.
name|c_ddate
operator|!=
name|dumptime
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Wrong dump date\n\tgot: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|tmpbuf
operator|.
name|c_date
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\twanted: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|dumpdate
argument_list|)
argument_list|)
expr_stmt|;
name|volno
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|tapesread
operator||=
literal|1
operator|<<
name|volno
expr_stmt|;
name|blksread
operator|=
name|savecnt
expr_stmt|;
comment|/*  	 * If continuing from the previous volume, skip over any  	 * blocks read already at the end of the previous volume.  	 *  	 * If coming to this volume at random, skip to the beginning  	 * of the next record.  	 */
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"read %ld recs, tape starts with %ld\n"
argument_list|,
name|tpblksread
argument_list|,
name|tmpbuf
operator|.
name|c_firstrec
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpbuf
operator|.
name|c_type
operator|==
name|TS_TAPE
operator|&&
operator|(
name|tmpbuf
operator|.
name|c_flags
operator|&
name|DR_NEWHEADER
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|wantnext
condition|)
block|{
name|tpblksread
operator|=
name|tmpbuf
operator|.
name|c_firstrec
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tmpbuf
operator|.
name|c_count
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|readtape
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmpbuf
operator|.
name|c_firstrec
operator|>
literal|0
operator|&&
name|tmpbuf
operator|.
name|c_firstrec
operator|<
name|tpblksread
operator|-
literal|1
condition|)
block|{
comment|/* 			 * -1 since we've read the volume header 			 */
name|i
operator|=
name|tpblksread
operator|-
name|tmpbuf
operator|.
name|c_firstrec
operator|-
literal|1
expr_stmt|;
name|dprintf
argument_list|(
name|stderr
argument_list|,
literal|"Skipping %d duplicate record%s.\n"
argument_list|,
name|i
argument_list|,
name|i
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|readtape
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|curfile
operator|.
name|action
operator|==
name|USING
condition|)
block|{
if|if
condition|(
name|volno
operator|==
literal|1
condition|)
name|panic
argument_list|(
literal|"active file into volume 1\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Skip up to the beginning of the next record 	 */
if|if
condition|(
name|tmpbuf
operator|.
name|c_type
operator|==
name|TS_TAPE
operator|&&
operator|(
name|tmpbuf
operator|.
name|c_flags
operator|&
name|DR_NEWHEADER
operator|)
condition|)
for|for
control|(
name|i
operator|=
name|tmpbuf
operator|.
name|c_count
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|readtape
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gethead
argument_list|(
operator|&
name|spcl
argument_list|)
expr_stmt|;
name|findinode
argument_list|(
operator|&
name|spcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettingfile
condition|)
block|{
name|gettingfile
operator|=
literal|0
expr_stmt|;
name|longjmp
argument_list|(
name|restart
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle unexpected EOF.  */
end_comment

begin_function
specifier|static
name|void
name|terminateinput
parameter_list|()
block|{
if|if
condition|(
name|gettingfile
operator|&&
name|curfile
operator|.
name|action
operator|==
name|USING
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: %s %s\n"
argument_list|,
literal|"End-of-input encountered while extracting"
argument_list|,
name|curfile
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|curfile
operator|.
name|name
operator|=
literal|"<name unknown>"
expr_stmt|;
name|curfile
operator|.
name|action
operator|=
name|UNKNOWN
expr_stmt|;
name|curfile
operator|.
name|dip
operator|=
name|NULL
expr_stmt|;
name|curfile
operator|.
name|ino
operator|=
name|maxino
expr_stmt|;
if|if
condition|(
name|gettingfile
condition|)
block|{
name|gettingfile
operator|=
literal|0
expr_stmt|;
name|longjmp
argument_list|(
name|restart
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * handle multiple dumps per tape by skipping forward to the  * appropriate one.  */
end_comment

begin_function
specifier|static
name|void
name|setdumpnum
parameter_list|()
block|{
name|struct
name|mtop
name|tcom
decl_stmt|;
if|if
condition|(
name|dumpnum
operator|==
literal|1
operator|||
name|volno
operator|!=
literal|1
condition|)
return|return;
if|if
condition|(
name|pipein
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot have multiple dumps on pipe input\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tcom
operator|.
name|mt_op
operator|=
name|MTFSF
expr_stmt|;
name|tcom
operator|.
name|mt_count
operator|=
name|dumpnum
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|host
condition|)
name|rmtioctl
argument_list|(
name|MTFSF
argument_list|,
name|dumpnum
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|mt
argument_list|,
operator|(
name|int
operator|)
name|MTIOCTOP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tcom
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ioctl MTFSF: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printdumpinfo
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Dump   date: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|spcl
operator|.
name|c_date
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Dumped from: %s"
argument_list|,
operator|(
name|spcl
operator|.
name|c_ddate
operator|==
literal|0
operator|)
condition|?
literal|"the epoch\n"
else|:
name|ctime
argument_list|(
operator|&
name|spcl
operator|.
name|c_ddate
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spcl
operator|.
name|c_host
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Level %d dump of %s on %s:%s\n"
argument_list|,
name|spcl
operator|.
name|c_level
argument_list|,
name|spcl
operator|.
name|c_filesys
argument_list|,
name|spcl
operator|.
name|c_host
argument_list|,
name|spcl
operator|.
name|c_dev
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Label: %s\n"
argument_list|,
name|spcl
operator|.
name|c_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|extractfile
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|mode
decl_stmt|;
name|struct
name|timeval
name|timep
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|entry
modifier|*
name|ep
decl_stmt|;
name|curfile
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|curfile
operator|.
name|action
operator|=
name|USING
expr_stmt|;
name|timep
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|curfile
operator|.
name|dip
operator|->
name|di_atime
operator|.
name|tv_sec
expr_stmt|;
name|timep
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|curfile
operator|.
name|dip
operator|->
name|di_atime
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
name|timep
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|curfile
operator|.
name|dip
operator|->
name|di_mtime
operator|.
name|tv_sec
expr_stmt|;
name|timep
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
name|curfile
operator|.
name|dip
operator|->
name|di_mtime
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
name|mode
operator|=
name|curfile
operator|.
name|dip
operator|->
name|di_mode
expr_stmt|;
switch|switch
condition|(
name|mode
operator|&
name|IFMT
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown file mode 0%o\n"
argument_list|,
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
case|case
name|IFSOCK
case|:
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"skipped socket %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
case|case
name|IFDIR
case|:
if|if
condition|(
name|mflag
condition|)
block|{
name|ep
operator|=
name|lookupname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
operator|||
name|ep
operator|->
name|e_flags
operator|&
name|EXTRACT
condition|)
name|panic
argument_list|(
literal|"unextracted directory %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"extract file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|genliteraldir
argument_list|(
name|name
argument_list|,
name|curfile
operator|.
name|ino
argument_list|)
operator|)
return|;
case|case
name|IFLNK
case|:
name|lnkbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pathlen
operator|=
literal|0
expr_stmt|;
name|getfile
argument_list|(
name|xtrlnkfile
argument_list|,
name|xtrlnkskip
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathlen
operator|==
literal|0
condition|)
block|{
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s: zero length symbolic link (ignored)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
return|return
operator|(
name|linkit
argument_list|(
name|lnkbuf
argument_list|,
name|name
argument_list|,
name|SYMLINK
argument_list|)
operator|)
return|;
case|case
name|IFIFO
case|:
if|if
condition|(
name|mkfifo
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot create FIFO: %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|chown
argument_list|(
name|name
argument_list|,
name|curfile
operator|.
name|dip
operator|->
name|di_uid
argument_list|,
name|curfile
operator|.
name|dip
operator|->
name|di_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
name|utimes
argument_list|(
name|name
argument_list|,
name|timep
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
case|case
name|IFCHR
case|:
case|case
name|IFBLK
case|:
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"extract special file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Nflag
condition|)
block|{
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
if|if
condition|(
name|mknod
argument_list|(
name|name
argument_list|,
name|mode
argument_list|,
operator|(
name|int
operator|)
name|curfile
operator|.
name|dip
operator|->
name|di_rdev
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot create special file: %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|chown
argument_list|(
name|name
argument_list|,
name|curfile
operator|.
name|dip
operator|->
name|di_uid
argument_list|,
name|curfile
operator|.
name|dip
operator|->
name|di_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
name|utimes
argument_list|(
name|name
argument_list|,
name|timep
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
case|case
name|IFREG
case|:
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"extract file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Nflag
condition|)
block|{
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ofile
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot create file: %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|skipfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fchown
argument_list|(
name|ofile
argument_list|,
name|curfile
operator|.
name|dip
operator|->
name|di_uid
argument_list|,
name|curfile
operator|.
name|dip
operator|->
name|di_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fchmod
argument_list|(
name|ofile
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|getfile
argument_list|(
name|xtrfile
argument_list|,
name|xtrskip
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
name|utimes
argument_list|(
name|name
argument_list|,
name|timep
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * skip over bit maps on the tape  */
end_comment

begin_function
name|void
name|skipmaps
parameter_list|()
block|{
while|while
condition|(
name|spcl
operator|.
name|c_type
operator|==
name|TS_BITS
operator|||
name|spcl
operator|.
name|c_type
operator|==
name|TS_CLRI
condition|)
name|skipfile
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * skip over a file on the tape  */
end_comment

begin_function
name|void
name|skipfile
parameter_list|()
block|{
name|curfile
operator|.
name|action
operator|=
name|SKIP
expr_stmt|;
name|getfile
argument_list|(
name|xtrnull
argument_list|,
name|xtrnull
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Extract a file from the tape.  * When an allocated block is found it is passed to the fill function;  * when an unallocated block (hole) is found, a zeroed buffer is passed  * to the skip function.  */
end_comment

begin_function_decl
name|void
name|getfile
parameter_list|(
name|fill
parameter_list|,
name|skip
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*fill
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*skip
argument_list|)
end_macro

begin_expr_stmt
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|curblk
init|=
literal|0
decl_stmt|;
name|long
name|size
init|=
name|spcl
operator|.
name|c_dinode
operator|.
name|di_size
decl_stmt|;
specifier|static
name|char
name|clearedbuf
index|[
name|MAXBSIZE
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXBSIZE
operator|/
name|TP_BSIZE
index|]
index|[
name|TP_BSIZE
index|]
decl_stmt|;
name|char
name|junk
index|[
name|TP_BSIZE
index|]
decl_stmt|;
if|if
condition|(
name|spcl
operator|.
name|c_type
operator|==
name|TS_END
condition|)
name|panic
argument_list|(
literal|"ran off end of tape\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spcl
operator|.
name|c_magic
operator|!=
name|NFS_MAGIC
condition|)
name|panic
argument_list|(
literal|"not at beginning of a file\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gettingfile
operator|&&
name|setjmp
argument_list|(
name|restart
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|gettingfile
operator|++
expr_stmt|;
name|loop
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spcl
operator|.
name|c_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|spcl
operator|.
name|c_addr
index|[
name|i
index|]
condition|)
block|{
name|readtape
argument_list|(
operator|&
name|buf
index|[
name|curblk
operator|++
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|curblk
operator|==
name|fssize
operator|/
name|TP_BSIZE
condition|)
block|{
call|(
modifier|*
name|fill
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|size
operator|>
name|TP_BSIZE
condition|?
call|(
name|long
call|)
argument_list|(
name|fssize
argument_list|)
else|:
operator|(
name|curblk
operator|-
literal|1
operator|)
operator|*
name|TP_BSIZE
operator|+
name|size
argument_list|)
expr_stmt|;
name|curblk
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|curblk
operator|>
literal|0
condition|)
block|{
call|(
modifier|*
name|fill
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|size
operator|>
name|TP_BSIZE
condition|?
call|(
name|long
call|)
argument_list|(
name|curblk
operator|*
name|TP_BSIZE
argument_list|)
else|:
operator|(
name|curblk
operator|-
literal|1
operator|)
operator|*
name|TP_BSIZE
operator|+
name|size
argument_list|)
expr_stmt|;
name|curblk
operator|=
literal|0
expr_stmt|;
block|}
call|(
modifier|*
name|skip
call|)
argument_list|(
name|clearedbuf
argument_list|,
name|size
operator|>
name|TP_BSIZE
condition|?
operator|(
name|long
operator|)
name|TP_BSIZE
else|:
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size
operator|-=
name|TP_BSIZE
operator|)
operator|<=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|spcl
operator|.
name|c_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|spcl
operator|.
name|c_addr
index|[
name|i
index|]
condition|)
name|readtape
argument_list|(
name|junk
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|gethead
argument_list|(
operator|&
name|spcl
argument_list|)
operator|==
name|GOOD
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|spcl
operator|.
name|c_type
operator|==
name|TS_ADDR
condition|)
goto|goto
name|loop
goto|;
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"Missing address (header) block for %s at %d blocks\n"
argument_list|,
name|curfile
operator|.
name|name
argument_list|,
name|blksread
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curblk
operator|>
literal|0
condition|)
call|(
modifier|*
name|fill
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|curblk
operator|*
name|TP_BSIZE
operator|)
operator|+
name|size
argument_list|)
expr_stmt|;
name|findinode
argument_list|(
operator|&
name|spcl
argument_list|)
expr_stmt|;
name|gettingfile
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Write out the next block of a file.  */
end_comment

begin_function
specifier|static
name|void
name|xtrfile
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
if|if
condition|(
name|Nflag
condition|)
return|return;
if|if
condition|(
name|write
argument_list|(
name|ofile
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"write error extracting inode %d, name %s\nwrite: %s\n"
argument_list|,
name|curfile
operator|.
name|ino
argument_list|,
name|curfile
operator|.
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Skip over a hole in a file.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|xtrskip
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
if|if
condition|(
name|lseek
argument_list|(
name|ofile
argument_list|,
name|size
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"seek error extracting inode %d, name %s\nlseek: %s\n"
argument_list|,
name|curfile
operator|.
name|ino
argument_list|,
name|curfile
operator|.
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Collect the next block of a symbolic link.  */
end_comment

begin_function
specifier|static
name|void
name|xtrlnkfile
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|pathlen
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|pathlen
operator|>
name|MAXPATHLEN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"symbolic link name: %s->%s%s; too long %d\n"
argument_list|,
name|curfile
operator|.
name|name
argument_list|,
name|lnkbuf
argument_list|,
name|buf
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|lnkbuf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Skip over a hole in a symbolic link (should never happen).  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|xtrlnkskip
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unallocated block in symbolic link %s\n"
argument_list|,
name|curfile
operator|.
name|name
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Collect the next block of a bit map.  */
end_comment

begin_function
specifier|static
name|void
name|xtrmap
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|bcopy
argument_list|(
name|buf
argument_list|,
name|map
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|map
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Skip over a hole in a bit map (should never happen).  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|xtrmapskip
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"hole in map\n"
argument_list|)
expr_stmt|;
name|map
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Noop, when an extraction function is not needed.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|xtrnull
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
return|return;
block|}
end_function

begin_comment
comment|/*  * Read TP_BSIZE blocks from the input.  * Handle read errors, and end of media.  */
end_comment

begin_function
specifier|static
name|void
name|readtape
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|long
name|rd
decl_stmt|,
name|newvol
decl_stmt|,
name|i
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|seek_failed
decl_stmt|;
if|if
condition|(
name|blkcnt
operator|<
name|numtrec
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|tapebuf
index|[
operator|(
name|blkcnt
operator|++
operator|*
name|TP_BSIZE
operator|)
index|]
argument_list|,
name|buf
argument_list|,
operator|(
name|long
operator|)
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|blksread
operator|++
expr_stmt|;
name|tpblksread
operator|++
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntrec
condition|;
name|i
operator|++
control|)
operator|(
operator|(
expr|struct
name|s_spcl
operator|*
operator|)
operator|&
name|tapebuf
index|[
name|i
operator|*
name|TP_BSIZE
index|]
operator|)
operator|->
name|c_magic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|numtrec
operator|==
literal|0
condition|)
name|numtrec
operator|=
name|ntrec
expr_stmt|;
name|cnt
operator|=
name|ntrec
operator|*
name|TP_BSIZE
expr_stmt|;
name|rd
operator|=
literal|0
expr_stmt|;
name|getmore
label|:
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|host
condition|)
name|i
operator|=
name|rmtread
argument_list|(
operator|&
name|tapebuf
index|[
name|rd
index|]
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|i
operator|=
name|read
argument_list|(
name|mt
argument_list|,
operator|&
name|tapebuf
index|[
name|rd
index|]
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* 	 * Check for mid-tape short read error. 	 * If found, skip rest of buffer and start with the next. 	 */
if|if
condition|(
operator|!
name|pipein
operator|&&
name|numtrec
operator|<
name|ntrec
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|dprintf
argument_list|(
name|stdout
argument_list|,
literal|"mid-media short read error.\n"
argument_list|)
expr_stmt|;
name|numtrec
operator|=
name|ntrec
expr_stmt|;
block|}
comment|/* 	 * Handle partial block read. 	 */
if|if
condition|(
name|pipein
operator|&&
name|i
operator|==
literal|0
operator|&&
name|rd
operator|>
literal|0
condition|)
name|i
operator|=
name|rd
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|i
operator|!=
name|ntrec
operator|*
name|TP_BSIZE
condition|)
block|{
if|if
condition|(
name|pipein
condition|)
block|{
name|rd
operator|+=
name|i
expr_stmt|;
name|cnt
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
goto|goto
name|getmore
goto|;
name|i
operator|=
name|rd
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Short read. Process the blocks read. 			 */
if|if
condition|(
name|i
operator|%
name|TP_BSIZE
operator|!=
literal|0
condition|)
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"partial block read: %d should be %d\n"
argument_list|,
name|i
argument_list|,
name|ntrec
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|numtrec
operator|=
name|i
operator|/
name|TP_BSIZE
expr_stmt|;
block|}
block|}
comment|/* 	 * Handle read error. 	 */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tape read error while "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|curfile
operator|.
name|action
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"trying to set up tape\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNKNOWN
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"trying to resynchronize\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|USING
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"restoring %s\n"
argument_list|,
name|curfile
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|SKIP
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"skipping over inode %d\n"
argument_list|,
name|curfile
operator|.
name|ino
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|yflag
operator|&&
operator|!
name|reply
argument_list|(
literal|"continue"
argument_list|)
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|ntrec
operator|*
name|TP_BSIZE
expr_stmt|;
name|bzero
argument_list|(
name|tapebuf
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|host
condition|)
name|seek_failed
operator|=
operator|(
name|rmtseek
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
name|seek_failed
operator|=
operator|(
name|lseek
argument_list|(
name|mt
argument_list|,
name|i
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|seek_failed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"continuation failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Handle end of tape. 	 */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"End-of-tape encountered\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pipein
condition|)
block|{
name|newvol
operator|=
name|volno
operator|+
literal|1
expr_stmt|;
name|volno
operator|=
literal|0
expr_stmt|;
name|numtrec
operator|=
literal|0
expr_stmt|;
name|getvol
argument_list|(
name|newvol
argument_list|)
expr_stmt|;
name|readtape
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rd
operator|%
name|TP_BSIZE
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"partial block read: %d should be %d\n"
argument_list|,
name|rd
argument_list|,
name|ntrec
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|terminateinput
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|endoftapemark
argument_list|,
operator|&
name|tapebuf
index|[
name|rd
index|]
argument_list|,
operator|(
name|long
operator|)
name|TP_BSIZE
argument_list|)
expr_stmt|;
block|}
name|blkcnt
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|tapebuf
index|[
operator|(
name|blkcnt
operator|++
operator|*
name|TP_BSIZE
operator|)
index|]
argument_list|,
name|buf
argument_list|,
operator|(
name|long
operator|)
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|blksread
operator|++
expr_stmt|;
name|tpblksread
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|findtapeblksize
parameter_list|()
block|{
specifier|register
name|long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntrec
condition|;
name|i
operator|++
control|)
operator|(
operator|(
expr|struct
name|s_spcl
operator|*
operator|)
operator|&
name|tapebuf
index|[
name|i
operator|*
name|TP_BSIZE
index|]
operator|)
operator|->
name|c_magic
operator|=
literal|0
expr_stmt|;
name|blkcnt
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|host
condition|)
name|i
operator|=
name|rmtread
argument_list|(
name|tapebuf
argument_list|,
name|ntrec
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|i
operator|=
name|read
argument_list|(
name|mt
argument_list|,
name|tapebuf
argument_list|,
name|ntrec
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tape read error: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|%
name|TP_BSIZE
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tape block size (%d) %s (%d)\n"
argument_list|,
name|i
argument_list|,
literal|"is not a multiple of dump block size"
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ntrec
operator|=
name|i
operator|/
name|TP_BSIZE
expr_stmt|;
name|numtrec
operator|=
name|ntrec
expr_stmt|;
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"Tape block size is %d\n"
argument_list|,
name|ntrec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|closemt
parameter_list|()
block|{
if|if
condition|(
name|mt
operator|<
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|RRESTORE
if|if
condition|(
name|host
condition|)
name|rmtclose
argument_list|()
expr_stmt|;
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|mt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the next block from the tape.  * Check to see if it is one of several vintage headers.  * If it is an old style header, convert it to a new style header.  * If it is not any valid header, return an error.  */
end_comment

begin_function
specifier|static
name|int
name|gethead
parameter_list|(
name|buf
parameter_list|)
name|struct
name|s_spcl
modifier|*
name|buf
decl_stmt|;
block|{
name|long
name|i
decl_stmt|;
union|union
block|{
name|quad_t
name|qval
decl_stmt|;
name|long
name|val
index|[
literal|2
index|]
decl_stmt|;
block|}
name|qcvt
union|;
union|union
name|u_ospcl
block|{
name|char
name|dummy
index|[
name|TP_BSIZE
index|]
decl_stmt|;
struct|struct
name|s_ospcl
block|{
name|long
name|c_type
decl_stmt|;
name|long
name|c_date
decl_stmt|;
name|long
name|c_ddate
decl_stmt|;
name|long
name|c_volume
decl_stmt|;
name|long
name|c_tapea
decl_stmt|;
name|u_short
name|c_inumber
decl_stmt|;
name|long
name|c_magic
decl_stmt|;
name|long
name|c_checksum
decl_stmt|;
struct|struct
name|odinode
block|{
name|unsigned
name|short
name|odi_mode
decl_stmt|;
name|u_short
name|odi_nlink
decl_stmt|;
name|u_short
name|odi_uid
decl_stmt|;
name|u_short
name|odi_gid
decl_stmt|;
name|long
name|odi_size
decl_stmt|;
name|long
name|odi_rdev
decl_stmt|;
name|char
name|odi_addr
index|[
literal|36
index|]
decl_stmt|;
name|long
name|odi_atime
decl_stmt|;
name|long
name|odi_mtime
decl_stmt|;
name|long
name|odi_ctime
decl_stmt|;
block|}
name|c_dinode
struct|;
name|long
name|c_count
decl_stmt|;
name|char
name|c_addr
index|[
literal|256
index|]
decl_stmt|;
block|}
name|s_ospcl
struct|;
block|}
name|u_ospcl
union|;
if|if
condition|(
operator|!
name|cvtflag
condition|)
block|{
name|readtape
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|c_magic
operator|!=
name|NFS_MAGIC
condition|)
block|{
if|if
condition|(
name|swabl
argument_list|(
name|buf
operator|->
name|c_magic
argument_list|)
operator|!=
name|NFS_MAGIC
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
if|if
condition|(
operator|!
name|Bcvt
condition|)
block|{
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"Note: Doing Byte swapping\n"
argument_list|)
expr_stmt|;
name|Bcvt
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|checksum
argument_list|(
operator|(
name|int
operator|*
operator|)
name|buf
argument_list|)
operator|==
name|FAIL
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
if|if
condition|(
name|Bcvt
condition|)
block|{
name|swabst
argument_list|(
operator|(
name|u_char
operator|*
operator|)
literal|"8l4s31l"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|swabst
argument_list|(
operator|(
name|u_char
operator|*
operator|)
literal|"l"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|buf
operator|->
name|c_level
argument_list|)
expr_stmt|;
name|swabst
argument_list|(
operator|(
name|u_char
operator|*
operator|)
literal|"2l"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|buf
operator|->
name|c_flags
argument_list|)
expr_stmt|;
block|}
goto|goto
name|good
goto|;
block|}
name|readtape
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|u_ospcl
operator|.
name|s_ospcl
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|long
operator|)
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|buf
operator|->
name|c_type
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_type
expr_stmt|;
name|buf
operator|->
name|c_date
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_date
expr_stmt|;
name|buf
operator|->
name|c_ddate
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_ddate
expr_stmt|;
name|buf
operator|->
name|c_volume
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_volume
expr_stmt|;
name|buf
operator|->
name|c_tapea
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_tapea
expr_stmt|;
name|buf
operator|->
name|c_inumber
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_inumber
expr_stmt|;
name|buf
operator|->
name|c_checksum
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_checksum
expr_stmt|;
name|buf
operator|->
name|c_magic
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_magic
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_mode
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_mode
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_nlink
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_nlink
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_uid
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_uid
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_gid
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_gid
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_size
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_size
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_rdev
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_rdev
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_atime
operator|.
name|tv_sec
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_atime
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_mtime
operator|.
name|tv_sec
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_mtime
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_ctime
operator|.
name|tv_sec
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_dinode
operator|.
name|odi_ctime
expr_stmt|;
name|buf
operator|->
name|c_count
operator|=
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_count
expr_stmt|;
name|bcopy
argument_list|(
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_addr
argument_list|,
name|buf
operator|->
name|c_addr
argument_list|,
operator|(
name|long
operator|)
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|u_ospcl
operator|.
name|s_ospcl
operator|.
name|c_magic
operator|!=
name|OFS_MAGIC
operator|||
name|checksum
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|u_ospcl
operator|.
name|s_ospcl
operator|)
argument_list|)
operator|==
name|FAIL
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
name|buf
operator|->
name|c_magic
operator|=
name|NFS_MAGIC
expr_stmt|;
name|good
label|:
if|if
condition|(
operator|(
name|buf
operator|->
name|c_dinode
operator|.
name|di_size
operator|==
literal|0
operator|||
name|buf
operator|->
name|c_dinode
operator|.
name|di_size
operator|>
literal|0xfffffff
operator|)
operator|&&
operator|(
name|buf
operator|->
name|c_dinode
operator|.
name|di_mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
operator|&&
name|Qcvt
operator|==
literal|0
condition|)
block|{
name|qcvt
operator|.
name|qval
operator|=
name|buf
operator|->
name|c_dinode
operator|.
name|di_size
expr_stmt|;
if|if
condition|(
name|qcvt
operator|.
name|val
index|[
literal|0
index|]
operator|||
name|qcvt
operator|.
name|val
index|[
literal|1
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"Note: Doing Quad swapping\n"
argument_list|)
expr_stmt|;
name|Qcvt
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Qcvt
condition|)
block|{
name|qcvt
operator|.
name|qval
operator|=
name|buf
operator|->
name|c_dinode
operator|.
name|di_size
expr_stmt|;
name|i
operator|=
name|qcvt
operator|.
name|val
index|[
literal|1
index|]
expr_stmt|;
name|qcvt
operator|.
name|val
index|[
literal|1
index|]
operator|=
name|qcvt
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
name|qcvt
operator|.
name|val
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_size
operator|=
name|qcvt
operator|.
name|qval
expr_stmt|;
block|}
switch|switch
condition|(
name|buf
operator|->
name|c_type
condition|)
block|{
case|case
name|TS_CLRI
case|:
case|case
name|TS_BITS
case|:
comment|/* 		 * Have to patch up missing information in bit map headers 		 */
name|buf
operator|->
name|c_inumber
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_size
operator|=
name|buf
operator|->
name|c_count
operator|*
name|TP_BSIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buf
operator|->
name|c_count
condition|;
name|i
operator|++
control|)
name|buf
operator|->
name|c_addr
index|[
name|i
index|]
operator|++
expr_stmt|;
break|break;
case|case
name|TS_TAPE
case|:
if|if
condition|(
operator|(
name|buf
operator|->
name|c_flags
operator|&
name|DR_NEWINODEFMT
operator|)
operator|==
literal|0
condition|)
name|oldinofmt
operator|=
literal|1
expr_stmt|;
comment|/* fall through */
case|case
name|TS_END
case|:
name|buf
operator|->
name|c_inumber
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TS_INODE
case|:
case|case
name|TS_ADDR
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"gethead: unknown inode type %d\n"
argument_list|,
name|buf
operator|->
name|c_type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * If we are restoring a filesystem with old format inodes, 	 * copy the uid/gid to the new location. 	 */
if|if
condition|(
name|oldinofmt
condition|)
block|{
name|buf
operator|->
name|c_dinode
operator|.
name|di_uid
operator|=
name|buf
operator|->
name|c_dinode
operator|.
name|di_ouid
expr_stmt|;
name|buf
operator|->
name|c_dinode
operator|.
name|di_gid
operator|=
name|buf
operator|->
name|c_dinode
operator|.
name|di_ogid
expr_stmt|;
block|}
if|if
condition|(
name|dflag
condition|)
name|accthdr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check that a header is where it belongs and predict the next header  */
end_comment

begin_function
specifier|static
name|void
name|accthdr
parameter_list|(
name|header
parameter_list|)
name|struct
name|s_spcl
modifier|*
name|header
decl_stmt|;
block|{
specifier|static
name|ino_t
name|previno
init|=
literal|0x7fffffff
decl_stmt|;
specifier|static
name|int
name|prevtype
decl_stmt|;
specifier|static
name|long
name|predict
decl_stmt|;
name|long
name|blks
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|header
operator|->
name|c_type
operator|==
name|TS_TAPE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Volume header (%s inode format) "
argument_list|,
name|oldinofmt
condition|?
literal|"old"
else|:
literal|"new"
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|c_firstrec
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"begins with record %d"
argument_list|,
name|header
operator|->
name|c_firstrec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|previno
operator|=
literal|0x7fffffff
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|previno
operator|==
literal|0x7fffffff
condition|)
goto|goto
name|newcalc
goto|;
switch|switch
condition|(
name|prevtype
condition|)
block|{
case|case
name|TS_BITS
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Dump mask header"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TS_CLRI
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Remove mask header"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TS_INODE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File header, ino %d"
argument_list|,
name|previno
argument_list|)
expr_stmt|;
break|break;
case|case
name|TS_ADDR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File continuation header, ino %d"
argument_list|,
name|previno
argument_list|)
expr_stmt|;
break|break;
case|case
name|TS_END
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"End of tape header"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|predict
operator|!=
name|blksread
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"; predicted %d blocks, got %d blocks"
argument_list|,
name|predict
argument_list|,
name|blksread
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|newcalc
label|:
name|blks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|c_type
operator|!=
name|TS_END
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header
operator|->
name|c_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|header
operator|->
name|c_addr
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|blks
operator|++
expr_stmt|;
name|predict
operator|=
name|blks
expr_stmt|;
name|blksread
operator|=
literal|0
expr_stmt|;
name|prevtype
operator|=
name|header
operator|->
name|c_type
expr_stmt|;
name|previno
operator|=
name|header
operator|->
name|c_inumber
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find an inode header.  * Complain if had to skip, and complain is set.  */
end_comment

begin_function
specifier|static
name|void
name|findinode
parameter_list|(
name|header
parameter_list|)
name|struct
name|s_spcl
modifier|*
name|header
decl_stmt|;
block|{
specifier|static
name|long
name|skipcnt
init|=
literal|0
decl_stmt|;
name|long
name|i
decl_stmt|;
name|char
name|buf
index|[
name|TP_BSIZE
index|]
decl_stmt|;
name|curfile
operator|.
name|name
operator|=
literal|"<name unknown>"
expr_stmt|;
name|curfile
operator|.
name|action
operator|=
name|UNKNOWN
expr_stmt|;
name|curfile
operator|.
name|dip
operator|=
name|NULL
expr_stmt|;
name|curfile
operator|.
name|ino
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|header
operator|->
name|c_magic
operator|!=
name|NFS_MAGIC
condition|)
block|{
name|skipcnt
operator|++
expr_stmt|;
while|while
condition|(
name|gethead
argument_list|(
name|header
argument_list|)
operator|==
name|FAIL
operator|||
name|header
operator|->
name|c_date
operator|!=
name|dumpdate
condition|)
name|skipcnt
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|header
operator|->
name|c_type
condition|)
block|{
case|case
name|TS_ADDR
case|:
comment|/* 			 * Skip up to the beginning of the next record 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header
operator|->
name|c_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|header
operator|->
name|c_addr
index|[
name|i
index|]
condition|)
name|readtape
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|gethead
argument_list|(
name|header
argument_list|)
operator|==
name|FAIL
operator|||
name|header
operator|->
name|c_date
operator|!=
name|dumpdate
condition|)
name|skipcnt
operator|++
expr_stmt|;
break|break;
case|case
name|TS_INODE
case|:
name|curfile
operator|.
name|dip
operator|=
operator|&
name|header
operator|->
name|c_dinode
expr_stmt|;
name|curfile
operator|.
name|ino
operator|=
name|header
operator|->
name|c_inumber
expr_stmt|;
break|break;
case|case
name|TS_END
case|:
name|curfile
operator|.
name|ino
operator|=
name|maxino
expr_stmt|;
break|break;
case|case
name|TS_CLRI
case|:
name|curfile
operator|.
name|name
operator|=
literal|"<file removal list>"
expr_stmt|;
break|break;
case|case
name|TS_BITS
case|:
name|curfile
operator|.
name|name
operator|=
literal|"<file dump list>"
expr_stmt|;
break|break;
case|case
name|TS_TAPE
case|:
name|panic
argument_list|(
literal|"unexpected tape header\n"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
name|panic
argument_list|(
literal|"unknown tape header type %d\n"
argument_list|,
name|spcl
operator|.
name|c_type
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
do|while
condition|(
name|header
operator|->
name|c_type
operator|==
name|TS_ADDR
condition|)
do|;
if|if
condition|(
name|skipcnt
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"resync restore, skipped %d blocks\n"
argument_list|,
name|skipcnt
argument_list|)
expr_stmt|;
name|skipcnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|checksum
parameter_list|(
name|buf
parameter_list|)
specifier|register
name|int
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|u_spcl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|Bcvt
condition|)
block|{
do|do
name|i
operator|+=
operator|*
name|buf
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|j
condition|)
do|;
block|}
else|else
block|{
comment|/* What happens if we want to read restore tapes 			for a 16bit int machine??? */
do|do
name|i
operator|+=
name|swabl
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|j
condition|)
do|;
block|}
if|if
condition|(
name|i
operator|!=
name|CHECKSUM
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Checksum error %o, inode %d file %s\n"
argument_list|,
name|i
argument_list|,
name|curfile
operator|.
name|ino
argument_list|,
name|curfile
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|RRESTORE
end_ifdef

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
if|#
directive|if
name|__STDC__
name|msg
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|msg
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RRESTORE */
end_comment

begin_function
specifier|static
name|u_char
modifier|*
name|swabshort
parameter_list|(
name|sp
parameter_list|,
name|n
parameter_list|)
specifier|register
name|u_char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|sp
index|[
literal|0
index|]
expr_stmt|;
name|sp
index|[
literal|0
index|]
operator|=
name|sp
index|[
literal|1
index|]
expr_stmt|;
name|sp
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
block|}
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_char
modifier|*
name|swablong
parameter_list|(
name|sp
parameter_list|,
name|n
parameter_list|)
specifier|register
name|u_char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|sp
index|[
literal|0
index|]
expr_stmt|;
name|sp
index|[
literal|0
index|]
operator|=
name|sp
index|[
literal|3
index|]
expr_stmt|;
name|sp
index|[
literal|3
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|sp
index|[
literal|2
index|]
expr_stmt|;
name|sp
index|[
literal|2
index|]
operator|=
name|sp
index|[
literal|1
index|]
expr_stmt|;
name|sp
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|sp
operator|+=
literal|4
expr_stmt|;
block|}
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|swabst
parameter_list|(
name|cp
parameter_list|,
name|sp
parameter_list|)
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|,
decl|*
name|sp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|n
operator|=
operator|(
name|n
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
case|case
literal|'w'
case|:
case|case
literal|'h'
case|:
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|swabshort
argument_list|(
name|sp
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|swablong
argument_list|(
name|sp
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Any other character, like 'b' counts as byte. */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|sp
operator|+=
name|n
expr_stmt|;
break|break;
block|}
name|cp
operator|++
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|u_long
name|swabl
parameter_list|(
name|x
parameter_list|)
name|u_long
name|x
decl_stmt|;
block|{
name|swabst
argument_list|(
operator|(
name|u_char
operator|*
operator|)
literal|"l"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

end_unit

