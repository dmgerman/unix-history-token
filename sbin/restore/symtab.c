begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)symtab.c	8.3 (Berkeley) 4/28/95";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * These routines maintain the symbol table which tracks the state  * of the filesystem being restored. They provide lookup by either  * name or inode number. They also provide for creation, deletion,  * and renaming of entries. Because of the dynamic nature of pathnames,  * names should not be saved, but always constructed just before they  * are needed, by calling "myname".  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"restore.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_comment
comment|/*  * The following variables define the inode symbol table.  * The primary hash table is dynamically allocated based on  * the number of inodes in the filesystem (maxino), scaled by  * HASHFACTOR. The variable "entry" points to the hash table;  * the variable "entrytblsize" indicates its size (in entries).  */
end_comment

begin_define
define|#
directive|define
name|HASHFACTOR
value|5
end_define

begin_decl_stmt
specifier|static
name|struct
name|entry
modifier|*
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|entrytblsize
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|addino
parameter_list|(
name|ino_t
parameter_list|,
name|struct
name|entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|entry
modifier|*
name|lookupparent
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|removeentry
parameter_list|(
name|struct
name|entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Look up an entry by inode number  */
end_comment

begin_function
name|struct
name|entry
modifier|*
name|lookupino
parameter_list|(
name|ino_t
name|inum
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|inum
operator|<
name|WINO
operator|||
name|inum
operator|>=
name|maxino
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|ep
operator|=
name|entry
index|[
name|inum
operator|%
name|entrytblsize
index|]
init|;
name|ep
operator|!=
name|NULL
condition|;
name|ep
operator|=
name|ep
operator|->
name|e_next
control|)
if|if
condition|(
name|ep
operator|->
name|e_ino
operator|==
name|inum
condition|)
return|return
operator|(
name|ep
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an entry into the entry table  */
end_comment

begin_function
specifier|static
name|void
name|addino
parameter_list|(
name|ino_t
name|inum
parameter_list|,
name|struct
name|entry
modifier|*
name|np
parameter_list|)
block|{
name|struct
name|entry
modifier|*
modifier|*
name|epp
decl_stmt|;
if|if
condition|(
name|inum
operator|<
name|WINO
operator|||
name|inum
operator|>=
name|maxino
condition|)
name|panic
argument_list|(
literal|"addino: out of range %d\n"
argument_list|,
name|inum
argument_list|)
expr_stmt|;
name|epp
operator|=
operator|&
name|entry
index|[
name|inum
operator|%
name|entrytblsize
index|]
expr_stmt|;
name|np
operator|->
name|e_ino
operator|=
name|inum
expr_stmt|;
name|np
operator|->
name|e_next
operator|=
operator|*
name|epp
expr_stmt|;
operator|*
name|epp
operator|=
name|np
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
for|for
control|(
name|np
operator|=
name|np
operator|->
name|e_next
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|e_next
control|)
if|if
condition|(
name|np
operator|->
name|e_ino
operator|==
name|inum
condition|)
name|badentry
argument_list|(
name|np
argument_list|,
literal|"duplicate inum"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delete an entry from the entry table  */
end_comment

begin_function
name|void
name|deleteino
parameter_list|(
name|ino_t
name|inum
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|next
decl_stmt|;
name|struct
name|entry
modifier|*
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
name|inum
operator|<
name|WINO
operator|||
name|inum
operator|>=
name|maxino
condition|)
name|panic
argument_list|(
literal|"deleteino: out of range %d\n"
argument_list|,
name|inum
argument_list|)
expr_stmt|;
name|prev
operator|=
operator|&
name|entry
index|[
name|inum
operator|%
name|entrytblsize
index|]
expr_stmt|;
for|for
control|(
name|next
operator|=
operator|*
name|prev
init|;
name|next
operator|!=
name|NULL
condition|;
name|next
operator|=
name|next
operator|->
name|e_next
control|)
block|{
if|if
condition|(
name|next
operator|->
name|e_ino
operator|==
name|inum
condition|)
block|{
name|next
operator|->
name|e_ino
operator|=
literal|0
expr_stmt|;
operator|*
name|prev
operator|=
name|next
operator|->
name|e_next
expr_stmt|;
return|return;
block|}
name|prev
operator|=
operator|&
name|next
operator|->
name|e_next
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"deleteino: %d not found\n"
argument_list|,
name|inum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up an entry by name  */
end_comment

begin_function
name|struct
name|entry
modifier|*
name|lookupname
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|np
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|cp
operator|=
name|name
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|lookupino
argument_list|(
name|ROOTINO
argument_list|)
init|;
name|ep
operator|!=
name|NULL
condition|;
name|ep
operator|=
name|ep
operator|->
name|e_entries
control|)
block|{
for|for
control|(
name|np
operator|=
name|buf
init|;
operator|*
name|cp
operator|!=
literal|'/'
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
name|np
operator|<
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
index|]
condition|;
control|)
operator|*
name|np
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|np
operator|==
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
index|]
condition|)
break|break;
operator|*
name|np
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
name|ep
operator|!=
name|NULL
condition|;
name|ep
operator|=
name|ep
operator|->
name|e_sibling
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ep
operator|->
name|e_name
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ep
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up the parent of a pathname  */
end_comment

begin_function
specifier|static
name|struct
name|entry
modifier|*
name|lookupparent
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|tailindex
decl_stmt|;
name|tailindex
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tailindex
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|tailindex
operator|=
literal|'\0'
expr_stmt|;
name|ep
operator|=
name|lookupname
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|tailindex
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ep
operator|->
name|e_type
operator|!=
name|NODE
condition|)
name|panic
argument_list|(
literal|"%s is not a directory\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine the current pathname of a node or leaf  */
end_comment

begin_function
name|char
modifier|*
name|myname
parameter_list|(
name|struct
name|entry
modifier|*
name|ep
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
specifier|static
name|char
name|namebuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
for|for
control|(
name|cp
operator|=
operator|&
name|namebuf
index|[
name|MAXPATHLEN
operator|-
literal|2
index|]
init|;
name|cp
operator|>
operator|&
name|namebuf
index|[
name|ep
operator|->
name|e_namlen
index|]
condition|;
control|)
block|{
name|cp
operator|-=
name|ep
operator|->
name|e_namlen
expr_stmt|;
name|memmove
argument_list|(
name|cp
argument_list|,
name|ep
operator|->
name|e_name
argument_list|,
operator|(
name|long
operator|)
name|ep
operator|->
name|e_namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|lookupino
argument_list|(
name|ROOTINO
argument_list|)
condition|)
return|return
operator|(
name|cp
operator|)
return|;
operator|*
operator|(
operator|--
name|cp
operator|)
operator|=
literal|'/'
expr_stmt|;
name|ep
operator|=
name|ep
operator|->
name|e_parent
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"%s: pathname too long\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unused symbol table entries are linked together on a free list  * headed by the following pointer.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|entry
modifier|*
name|freelist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * add an entry to the symbol table  */
end_comment

begin_function
name|struct
name|entry
modifier|*
name|addentry
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|ino_t
name|inum
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|np
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|freelist
operator|!=
name|NULL
condition|)
block|{
name|np
operator|=
name|freelist
expr_stmt|;
name|freelist
operator|=
name|np
operator|->
name|e_next
expr_stmt|;
name|memset
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|np
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"no memory to extend symbol table\n"
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|e_type
operator|=
name|type
operator|&
operator|~
name|LINK
expr_stmt|;
name|ep
operator|=
name|lookupparent
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|inum
operator|!=
name|ROOTINO
operator|||
name|lookupino
argument_list|(
name|ROOTINO
argument_list|)
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"bad name to addentry %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|np
operator|->
name|e_name
operator|=
name|savename
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|np
operator|->
name|e_namlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|np
operator|->
name|e_parent
operator|=
name|np
expr_stmt|;
name|addino
argument_list|(
name|ROOTINO
argument_list|,
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
name|np
operator|)
return|;
block|}
name|np
operator|->
name|e_name
operator|=
name|savename
argument_list|(
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|np
operator|->
name|e_namlen
operator|=
name|strlen
argument_list|(
name|np
operator|->
name|e_name
argument_list|)
expr_stmt|;
name|np
operator|->
name|e_parent
operator|=
name|ep
expr_stmt|;
name|np
operator|->
name|e_sibling
operator|=
name|ep
operator|->
name|e_entries
expr_stmt|;
name|ep
operator|->
name|e_entries
operator|=
name|np
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|LINK
condition|)
block|{
name|ep
operator|=
name|lookupino
argument_list|(
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"link to non-existent name\n"
argument_list|)
expr_stmt|;
name|np
operator|->
name|e_ino
operator|=
name|inum
expr_stmt|;
name|np
operator|->
name|e_links
operator|=
name|ep
operator|->
name|e_links
expr_stmt|;
name|ep
operator|->
name|e_links
operator|=
name|np
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inum
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lookupino
argument_list|(
name|inum
argument_list|)
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"duplicate entry\n"
argument_list|)
expr_stmt|;
name|addino
argument_list|(
name|inum
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * delete an entry from the symbol table  */
end_comment

begin_function
name|void
name|freeentry
parameter_list|(
name|struct
name|entry
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|np
decl_stmt|;
name|ino_t
name|inum
decl_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_flags
operator|!=
name|REMOVED
condition|)
name|badentry
argument_list|(
name|ep
argument_list|,
literal|"not marked REMOVED"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_type
operator|==
name|NODE
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|e_links
operator|!=
name|NULL
condition|)
name|badentry
argument_list|(
name|ep
argument_list|,
literal|"freeing referenced directory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_entries
operator|!=
name|NULL
condition|)
name|badentry
argument_list|(
name|ep
argument_list|,
literal|"freeing non-empty directory"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|e_ino
operator|!=
literal|0
condition|)
block|{
name|np
operator|=
name|lookupino
argument_list|(
name|ep
operator|->
name|e_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
name|badentry
argument_list|(
name|ep
argument_list|,
literal|"lookupino failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|ep
condition|)
block|{
name|inum
operator|=
name|ep
operator|->
name|e_ino
expr_stmt|;
name|deleteino
argument_list|(
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_links
operator|!=
name|NULL
condition|)
name|addino
argument_list|(
name|inum
argument_list|,
name|ep
operator|->
name|e_links
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|e_links
control|)
block|{
if|if
condition|(
name|np
operator|->
name|e_links
operator|==
name|ep
condition|)
block|{
name|np
operator|->
name|e_links
operator|=
name|ep
operator|->
name|e_links
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
name|badentry
argument_list|(
name|ep
argument_list|,
literal|"link not found"
argument_list|)
expr_stmt|;
block|}
block|}
name|removeentry
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|freename
argument_list|(
name|ep
operator|->
name|e_name
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_next
operator|=
name|freelist
expr_stmt|;
name|freelist
operator|=
name|ep
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Relocate an entry in the tree structure  */
end_comment

begin_function
name|void
name|moveentry
parameter_list|(
name|struct
name|entry
modifier|*
name|ep
parameter_list|,
name|char
modifier|*
name|newname
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|np
operator|=
name|lookupparent
argument_list|(
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
name|badentry
argument_list|(
name|ep
argument_list|,
literal|"cannot move ROOT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|!=
name|ep
operator|->
name|e_parent
condition|)
block|{
name|removeentry
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_parent
operator|=
name|np
expr_stmt|;
name|ep
operator|->
name|e_sibling
operator|=
name|np
operator|->
name|e_entries
expr_stmt|;
name|np
operator|->
name|e_entries
operator|=
name|ep
expr_stmt|;
block|}
name|cp
operator|=
name|strrchr
argument_list|(
name|newname
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|freename
argument_list|(
name|ep
operator|->
name|e_name
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_name
operator|=
name|savename
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_namlen
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|gentempname
argument_list|(
name|ep
argument_list|)
argument_list|,
name|ep
operator|->
name|e_name
argument_list|)
operator|==
literal|0
condition|)
name|ep
operator|->
name|e_flags
operator||=
name|TMPNAME
expr_stmt|;
else|else
name|ep
operator|->
name|e_flags
operator|&=
operator|~
name|TMPNAME
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove an entry in the tree structure  */
end_comment

begin_function
specifier|static
name|void
name|removeentry
parameter_list|(
name|struct
name|entry
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|np
decl_stmt|;
name|np
operator|=
name|ep
operator|->
name|e_parent
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|e_entries
operator|==
name|ep
condition|)
block|{
name|np
operator|->
name|e_entries
operator|=
name|ep
operator|->
name|e_sibling
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|np
operator|=
name|np
operator|->
name|e_entries
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|e_sibling
control|)
block|{
if|if
condition|(
name|np
operator|->
name|e_sibling
operator|==
name|ep
condition|)
block|{
name|np
operator|->
name|e_sibling
operator|=
name|ep
operator|->
name|e_sibling
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
name|badentry
argument_list|(
name|ep
argument_list|,
literal|"cannot find entry in parent list"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Table of unused string entries, sorted by length.  *  * Entries are allocated in STRTBLINCR sized pieces so that names  * of similar lengths can use the same entry. The value of STRTBLINCR  * is chosen so that every entry has at least enough space to hold  * a "struct strtbl" header. Thus every entry can be linked onto an  * appropriate free list.  *  * NB. The macro "allocsize" below assumes that "struct strhdr"  *     has a size that is a power of two.  */
end_comment

begin_struct
struct|struct
name|strhdr
block|{
name|struct
name|strhdr
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|STRTBLINCR
value|(sizeof(struct strhdr))
end_define

begin_define
define|#
directive|define
name|allocsize
parameter_list|(
name|size
parameter_list|)
value|(((size) + 1 + STRTBLINCR - 1)& ~(STRTBLINCR - 1))
end_define

begin_decl_stmt
specifier|static
name|struct
name|strhdr
name|strtblhdr
index|[
name|allocsize
argument_list|(
name|NAME_MAX
argument_list|)
operator|/
name|STRTBLINCR
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate space for a name. It first looks to see if it already  * has an appropriate sized entry, and if not allocates a new one.  */
end_comment

begin_function
name|char
modifier|*
name|savename
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|strhdr
modifier|*
name|np
decl_stmt|;
name|long
name|len
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"bad name\n"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|np
operator|=
name|strtblhdr
index|[
name|len
operator|/
name|STRTBLINCR
index|]
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|np
operator|!=
name|NULL
condition|)
block|{
name|strtblhdr
index|[
name|len
operator|/
name|STRTBLINCR
index|]
operator|.
name|next
operator|=
name|np
operator|->
name|next
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|np
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|allocsize
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"no space for string table\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free space for a name. The resulting entry is linked onto the  * appropriate free list.  */
end_comment

begin_function
name|void
name|freename
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|strhdr
modifier|*
name|tp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|tp
operator|=
operator|&
name|strtblhdr
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|/
name|STRTBLINCR
index|]
expr_stmt|;
name|np
operator|=
operator|(
expr|struct
name|strhdr
operator|*
operator|)
name|name
expr_stmt|;
name|np
operator|->
name|next
operator|=
name|tp
operator|->
name|next
expr_stmt|;
name|tp
operator|->
name|next
operator|=
name|np
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Useful quantities placed at the end of a dumped symbol table.  */
end_comment

begin_struct
struct|struct
name|symtableheader
block|{
name|int32_t
name|volno
decl_stmt|;
name|int32_t
name|stringsize
decl_stmt|;
name|int32_t
name|entrytblsize
decl_stmt|;
name|time_t
name|dumptime
decl_stmt|;
name|time_t
name|dumpdate
decl_stmt|;
name|ino_t
name|maxino
decl_stmt|;
name|int32_t
name|ntrec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * dump a snapshot of the symbol table  */
end_comment

begin_function
name|void
name|dumpsymtable
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|long
name|checkpt
parameter_list|)
block|{
name|struct
name|entry
modifier|*
name|ep
decl_stmt|,
modifier|*
name|tep
decl_stmt|;
name|ino_t
name|i
decl_stmt|;
name|struct
name|entry
name|temp
decl_stmt|,
modifier|*
name|tentry
decl_stmt|;
name|long
name|mynum
init|=
literal|1
decl_stmt|,
name|stroff
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|struct
name|symtableheader
name|hdr
decl_stmt|;
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"Check pointing the restore\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Nflag
condition|)
return|return;
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fopen: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"cannot create save file %s for symbol table\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|clearerr
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * Assign indices to each entry 	 * Write out the string entries 	 */
for|for
control|(
name|i
operator|=
name|WINO
init|;
name|i
operator|<=
name|maxino
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|ep
operator|=
name|lookupino
argument_list|(
name|i
argument_list|)
init|;
name|ep
operator|!=
name|NULL
condition|;
name|ep
operator|=
name|ep
operator|->
name|e_links
control|)
block|{
name|ep
operator|->
name|e_index
operator|=
name|mynum
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|ep
operator|->
name|e_name
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|allocsize
argument_list|(
name|ep
operator|->
name|e_namlen
argument_list|)
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Convert pointers to indexes, and output 	 */
name|tep
operator|=
operator|&
name|temp
expr_stmt|;
name|stroff
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|WINO
init|;
name|i
operator|<=
name|maxino
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|ep
operator|=
name|lookupino
argument_list|(
name|i
argument_list|)
init|;
name|ep
operator|!=
name|NULL
condition|;
name|ep
operator|=
name|ep
operator|->
name|e_links
control|)
block|{
name|memmove
argument_list|(
name|tep
argument_list|,
name|ep
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|tep
operator|->
name|e_name
operator|=
operator|(
name|char
operator|*
operator|)
name|stroff
expr_stmt|;
name|stroff
operator|+=
name|allocsize
argument_list|(
name|ep
operator|->
name|e_namlen
argument_list|)
expr_stmt|;
name|tep
operator|->
name|e_parent
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|)
name|ep
operator|->
name|e_parent
operator|->
name|e_index
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_links
operator|!=
name|NULL
condition|)
name|tep
operator|->
name|e_links
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|)
name|ep
operator|->
name|e_links
operator|->
name|e_index
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_sibling
operator|!=
name|NULL
condition|)
name|tep
operator|->
name|e_sibling
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|)
name|ep
operator|->
name|e_sibling
operator|->
name|e_index
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_entries
operator|!=
name|NULL
condition|)
name|tep
operator|->
name|e_entries
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|)
name|ep
operator|->
name|e_entries
operator|->
name|e_index
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_next
operator|!=
name|NULL
condition|)
name|tep
operator|->
name|e_next
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|)
name|ep
operator|->
name|e_next
operator|->
name|e_index
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tep
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|entry
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Convert entry pointers to indexes, and output 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entrytblsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|entry
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|tentry
operator|=
name|NULL
expr_stmt|;
else|else
name|tentry
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|)
name|entry
index|[
name|i
index|]
operator|->
name|e_index
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tentry
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|entry
operator|*
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
name|hdr
operator|.
name|volno
operator|=
name|checkpt
expr_stmt|;
name|hdr
operator|.
name|maxino
operator|=
name|maxino
expr_stmt|;
name|hdr
operator|.
name|entrytblsize
operator|=
name|entrytblsize
expr_stmt|;
name|hdr
operator|.
name|stringsize
operator|=
name|stroff
expr_stmt|;
name|hdr
operator|.
name|dumptime
operator|=
name|dumptime
expr_stmt|;
name|hdr
operator|.
name|dumpdate
operator|=
name|dumpdate
expr_stmt|;
name|hdr
operator|.
name|ntrec
operator|=
name|ntrec
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symtableheader
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fwrite: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"output error to file %s writing symbol table\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a symbol table from a file  */
end_comment

begin_function
name|void
name|initsymtable
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|char
modifier|*
name|base
decl_stmt|;
name|long
name|tblsize
decl_stmt|;
name|struct
name|entry
modifier|*
name|ep
decl_stmt|;
name|struct
name|entry
modifier|*
name|baseep
decl_stmt|,
modifier|*
name|lep
decl_stmt|;
name|struct
name|symtableheader
name|hdr
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|long
name|i
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|vprintf
argument_list|(
name|stdout
argument_list|,
literal|"Initialize symbol table.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
name|entrytblsize
operator|=
name|maxino
operator|/
name|HASHFACTOR
expr_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|entrytblsize
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
name|NULL
condition|)
name|panic
argument_list|(
literal|"no memory for entry table\n"
argument_list|)
expr_stmt|;
name|ep
operator|=
name|addentry
argument_list|(
literal|"."
argument_list|,
name|ROOTINO
argument_list|,
name|NODE
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_flags
operator||=
name|NEW
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"open: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"cannot open symbol table file %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"stat: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"cannot stat symbol table file %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|tblsize
operator|=
name|stbuf
operator|.
name|st_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|symtableheader
argument_list|)
expr_stmt|;
name|base
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|tblsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"cannot allocate space for symbol table\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|base
argument_list|,
operator|(
name|int
operator|)
name|tblsize
argument_list|)
operator|<
literal|0
operator|||
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symtableheader
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"read: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"cannot read symbol table file %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|command
condition|)
block|{
case|case
literal|'r'
case|:
comment|/* 		 * For normal continuation, insure that we are using 		 * the next incremental tape 		 */
if|if
condition|(
name|hdr
operator|.
name|dumpdate
operator|!=
name|dumptime
condition|)
block|{
if|if
condition|(
name|hdr
operator|.
name|dumpdate
operator|<
name|dumptime
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Incremental tape too low\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Incremental tape too high\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'R'
case|:
comment|/* 		 * For restart, insure that we are using the same tape 		 */
name|curfile
operator|.
name|action
operator|=
name|SKIP
expr_stmt|;
name|dumptime
operator|=
name|hdr
operator|.
name|dumptime
expr_stmt|;
name|dumpdate
operator|=
name|hdr
operator|.
name|dumpdate
expr_stmt|;
if|if
condition|(
operator|!
name|bflag
condition|)
name|newtapebuf
argument_list|(
name|hdr
operator|.
name|ntrec
argument_list|)
expr_stmt|;
name|getvol
argument_list|(
name|hdr
operator|.
name|volno
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"initsymtable called from command %c\n"
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
block|}
name|maxino
operator|=
name|hdr
operator|.
name|maxino
expr_stmt|;
name|entrytblsize
operator|=
name|hdr
operator|.
name|entrytblsize
expr_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
operator|(
name|base
operator|+
name|tblsize
operator|-
operator|(
name|entrytblsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|entry
operator|*
argument_list|)
operator|)
operator|)
expr_stmt|;
name|baseep
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|)
operator|(
name|base
operator|+
name|hdr
operator|.
name|stringsize
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|entry
argument_list|)
operator|)
expr_stmt|;
name|lep
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|)
name|entry
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entrytblsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|entry
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|entry
index|[
name|i
index|]
operator|=
operator|&
name|baseep
index|[
operator|(
name|long
operator|)
name|entry
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
for|for
control|(
name|ep
operator|=
operator|&
name|baseep
index|[
literal|1
index|]
init|;
name|ep
operator|<
name|lep
condition|;
name|ep
operator|++
control|)
block|{
name|ep
operator|->
name|e_name
operator|=
name|base
operator|+
operator|(
name|long
operator|)
name|ep
operator|->
name|e_name
expr_stmt|;
name|ep
operator|->
name|e_parent
operator|=
operator|&
name|baseep
index|[
operator|(
name|long
operator|)
name|ep
operator|->
name|e_parent
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_sibling
operator|!=
name|NULL
condition|)
name|ep
operator|->
name|e_sibling
operator|=
operator|&
name|baseep
index|[
operator|(
name|long
operator|)
name|ep
operator|->
name|e_sibling
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_links
operator|!=
name|NULL
condition|)
name|ep
operator|->
name|e_links
operator|=
operator|&
name|baseep
index|[
operator|(
name|long
operator|)
name|ep
operator|->
name|e_links
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_entries
operator|!=
name|NULL
condition|)
name|ep
operator|->
name|e_entries
operator|=
operator|&
name|baseep
index|[
operator|(
name|long
operator|)
name|ep
operator|->
name|e_entries
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_next
operator|!=
name|NULL
condition|)
name|ep
operator|->
name|e_next
operator|=
operator|&
name|baseep
index|[
operator|(
name|long
operator|)
name|ep
operator|->
name|e_next
index|]
expr_stmt|;
block|}
block|}
end_function

end_unit

