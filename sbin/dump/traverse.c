begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980, 1988, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)traverse.c	8.7 (Berkeley) 6/15/95";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dir.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|<protocols/dumprestore.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<timeconv.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"dump.h"
end_include

begin_union
union|union
name|dinode
block|{
name|struct
name|ufs1_dinode
name|dp1
decl_stmt|;
name|struct
name|ufs2_dinode
name|dp2
decl_stmt|;
block|}
union|;
end_union

begin_define
define|#
directive|define
name|DIP
parameter_list|(
name|dp
parameter_list|,
name|field
parameter_list|)
define|\
value|((sblock->fs_magic == FS_UFS1_MAGIC) ? \ 	(dp)->dp1.field : (dp)->dp2.field)
end_define

begin_define
define|#
directive|define
name|DIP_SET
parameter_list|(
name|dp
parameter_list|,
name|field
parameter_list|,
name|val
parameter_list|)
value|do {\ 	if (sblock->fs_magic == FS_UFS1_MAGIC) \ 		(dp)->dp1.field = (val); \ 	else \ 		(dp)->dp2.field = (val); \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|HASDUMPEDFILE
value|0x1
end_define

begin_define
define|#
directive|define
name|HASSUBDIRS
value|0x2
end_define

begin_function_decl
specifier|static
name|int
name|dirindir
parameter_list|(
name|ino_t
name|ino
parameter_list|,
name|ufs2_daddr_t
name|blkno
parameter_list|,
name|int
name|level
parameter_list|,
name|long
modifier|*
name|size
parameter_list|,
name|long
modifier|*
name|tapesize
parameter_list|,
name|int
name|nodump
parameter_list|,
name|ino_t
name|maxino
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dmpindir
parameter_list|(
name|union
name|dinode
modifier|*
name|dp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|ufs2_daddr_t
name|blk
parameter_list|,
name|int
name|level
parameter_list|,
name|off_t
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ufs1_blksout
parameter_list|(
name|ufs1_daddr_t
modifier|*
name|blkp
parameter_list|,
name|int
name|frags
parameter_list|,
name|ino_t
name|ino
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ufs2_blksout
parameter_list|(
name|union
name|dinode
modifier|*
name|dp
parameter_list|,
name|ufs2_daddr_t
modifier|*
name|blkp
parameter_list|,
name|int
name|frags
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|int
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|appendextdata
parameter_list|(
name|union
name|dinode
modifier|*
name|dp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|writeextdata
parameter_list|(
name|union
name|dinode
modifier|*
name|dp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|int
name|added
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|searchdir
parameter_list|(
name|ino_t
name|ino
parameter_list|,
name|ufs2_daddr_t
name|blkno
parameter_list|,
name|long
name|size
parameter_list|,
name|long
name|filesize
parameter_list|,
name|long
modifier|*
name|tapesize
parameter_list|,
name|int
name|nodump
parameter_list|,
name|ino_t
name|maxino
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|blockest
parameter_list|(
name|union
name|dinode
modifier|*
name|dp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * This is an estimation of the number of TP_BSIZE blocks in the file.  * It estimates the number of blocks in files with holes by assuming  * that all of the blocks accounted for by di_blocks are data blocks  * (when some of the blocks are usually used for indirect pointers);  * hence the estimate may be high.  */
end_comment

begin_function
specifier|static
name|long
name|blockest
parameter_list|(
name|union
name|dinode
modifier|*
name|dp
parameter_list|)
block|{
name|long
name|blkest
decl_stmt|,
name|sizeest
decl_stmt|;
comment|/* 	 * dp->di_size is the size of the file in bytes. 	 * dp->di_blocks stores the number of sectors actually in the file. 	 * If there are more sectors than the size would indicate, this just 	 *	means that there are indirect blocks in the file or unused 	 *	sectors in the last file block; we can safely ignore these 	 *	(blkest = sizeest below). 	 * If the file is bigger than the number of sectors would indicate, 	 *	then the file has holes in it.	In this case we must use the 	 *	block count to estimate the number of data blocks used, but 	 *	we use the actual size for estimating the number of indirect 	 *	dump blocks (sizeest vs. blkest in the indirect block 	 *	calculation). 	 */
if|if
condition|(
operator|(
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_flags
argument_list|)
operator|&
name|SF_SNAPSHOT
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|blkest
operator|=
name|howmany
argument_list|(
name|dbtob
argument_list|(
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_blocks
argument_list|)
argument_list|)
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|sizeest
operator|=
name|howmany
argument_list|(
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_size
argument_list|)
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkest
operator|>
name|sizeest
condition|)
name|blkest
operator|=
name|sizeest
expr_stmt|;
if|if
condition|(
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_size
argument_list|)
operator|>
name|sblock
operator|->
name|fs_bsize
operator|*
name|NDADDR
condition|)
block|{
comment|/* calculate the number of indirect blocks on the dump tape */
name|blkest
operator|+=
name|howmany
argument_list|(
name|sizeest
operator|-
name|NDADDR
operator|*
name|sblock
operator|->
name|fs_bsize
operator|/
name|TP_BSIZE
argument_list|,
name|TP_NINDIR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|blkest
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Auxiliary macro to pick up files changed since previous dump. */
end_comment

begin_define
define|#
directive|define
name|CHANGEDSINCE
parameter_list|(
name|dp
parameter_list|,
name|t
parameter_list|)
define|\
value|(DIP(dp, di_mtime)>= (t) || DIP(dp, di_ctime)>= (t))
end_define

begin_comment
comment|/* The WANTTODUMP macro decides whether a file should be dumped. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UF_NODUMP
end_ifdef

begin_define
define|#
directive|define
name|WANTTODUMP
parameter_list|(
name|dp
parameter_list|)
define|\
value|(CHANGEDSINCE(dp, spcl.c_ddate)&& \ 	 (nonodump || (DIP(dp, di_flags)& UF_NODUMP) != UF_NODUMP))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WANTTODUMP
parameter_list|(
name|dp
parameter_list|)
value|CHANGEDSINCE(dp, spcl.c_ddate)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Dump pass 1.  *  * Walk the inode list for a file system to find all allocated inodes  * that have been modified since the previous dump time. Also, find all  * the directories in the file system.  */
end_comment

begin_function
name|int
name|mapfiles
parameter_list|(
name|ino_t
name|maxino
parameter_list|,
name|long
modifier|*
name|tapesize
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|cg
decl_stmt|,
name|mode
decl_stmt|,
name|inosused
decl_stmt|;
name|int
name|anydirskipped
init|=
literal|0
decl_stmt|;
name|union
name|dinode
modifier|*
name|dp
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|cgp
operator|=
name|malloc
argument_list|(
name|sblock
operator|->
name|fs_cgsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|quit
argument_list|(
literal|"mapfiles: cannot allocate memory.\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|cg
operator|=
literal|0
init|;
name|cg
operator|<
name|sblock
operator|->
name|fs_ncg
condition|;
name|cg
operator|++
control|)
block|{
name|ino
operator|=
name|cg
operator|*
name|sblock
operator|->
name|fs_ipg
expr_stmt|;
name|bread
argument_list|(
name|fsbtodb
argument_list|(
name|sblock
argument_list|,
name|cgtod
argument_list|(
name|sblock
argument_list|,
name|cg
argument_list|)
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cgp
argument_list|,
name|sblock
operator|->
name|fs_cgsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|->
name|fs_magic
operator|==
name|FS_UFS2_MAGIC
condition|)
name|inosused
operator|=
name|cgp
operator|->
name|cg_initediblk
expr_stmt|;
else|else
name|inosused
operator|=
name|sblock
operator|->
name|fs_ipg
expr_stmt|;
comment|/* 		 * If we are using soft updates, then we can trust the 		 * cylinder group inode allocation maps to tell us which 		 * inodes are allocated. We will scan the used inode map 		 * to find the inodes that are really in use, and then 		 * read only those inodes in from disk. 		 */
if|if
condition|(
name|sblock
operator|->
name|fs_flags
operator|&
name|FS_DOSOFTDEP
condition|)
block|{
if|if
condition|(
operator|!
name|cg_chkmagic
argument_list|(
name|cgp
argument_list|)
condition|)
name|quit
argument_list|(
literal|"mapfiles: cg %d: bad magic number\n"
argument_list|,
name|cg
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|cg_inosused
argument_list|(
name|cgp
argument_list|)
index|[
operator|(
name|inosused
operator|-
literal|1
operator|)
operator|/
name|CHAR_BIT
index|]
expr_stmt|;
for|for
control|(
init|;
name|inosused
operator|>
literal|0
condition|;
name|inosused
operator|-=
name|CHAR_BIT
operator|,
name|cp
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|1
operator|<<
operator|(
name|CHAR_BIT
operator|-
literal|1
operator|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|&
name|i
condition|)
break|break;
name|inosused
operator|--
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|inosused
operator|<=
literal|0
condition|)
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inosused
condition|;
name|i
operator|++
operator|,
name|ino
operator|++
control|)
block|{
if|if
condition|(
name|ino
operator|<
name|ROOTINO
operator|||
operator|(
name|dp
operator|=
name|getino
argument_list|(
name|ino
argument_list|,
operator|&
name|mode
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|mode
operator|&
name|IFMT
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ino
operator|>=
name|maxino
condition|)
block|{
name|msg
argument_list|(
literal|"Skipping inode %d>= maxino %d\n"
argument_list|,
name|ino
argument_list|,
name|maxino
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Everything must go in usedinomap so that a check 			 * for "in dumpdirmap but not in usedinomap" to detect 			 * dirs with nodump set has a chance of succeeding 			 * (this is used in mapdirs()). 			 */
name|SETINO
argument_list|(
name|ino
argument_list|,
name|usedinomap
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|IFDIR
condition|)
name|SETINO
argument_list|(
name|ino
argument_list|,
name|dumpdirmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|WANTTODUMP
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|SETINO
argument_list|(
name|ino
argument_list|,
name|dumpinomap
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|IFREG
operator|&&
name|mode
operator|!=
name|IFDIR
operator|&&
name|mode
operator|!=
name|IFLNK
condition|)
operator|*
name|tapesize
operator|+=
literal|1
expr_stmt|;
else|else
operator|*
name|tapesize
operator|+=
name|blockest
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mode
operator|==
name|IFDIR
condition|)
block|{
if|if
condition|(
operator|!
name|nonodump
operator|&&
operator|(
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_flags
argument_list|)
operator|&
name|UF_NODUMP
operator|)
condition|)
name|CLRINO
argument_list|(
name|ino
argument_list|,
name|usedinomap
argument_list|)
expr_stmt|;
name|anydirskipped
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Restore gets very upset if the root is not dumped, 	 * so ensure that it always is dumped. 	 */
name|SETINO
argument_list|(
name|ROOTINO
argument_list|,
name|dumpinomap
argument_list|)
expr_stmt|;
return|return
operator|(
name|anydirskipped
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump pass 2.  *  * Scan each directory on the file system to see if it has any modified  * files in it. If it does, and has not already been added to the dump  * list (because it was itself modified), then add it. If a directory  * has not been modified itself, contains no modified files and has no  * subdirectories, then it can be deleted from the dump list and from  * the list of directories. By deleting it from the list of directories,  * its parent may now qualify for the same treatment on this or a later  * pass using this algorithm.  */
end_comment

begin_function
name|int
name|mapdirs
parameter_list|(
name|ino_t
name|maxino
parameter_list|,
name|long
modifier|*
name|tapesize
parameter_list|)
block|{
name|union
name|dinode
modifier|*
name|dp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|isdir
decl_stmt|,
name|nodump
decl_stmt|;
name|char
modifier|*
name|map
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|union
name|dinode
name|di
decl_stmt|;
name|long
name|filesize
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|change
init|=
literal|0
decl_stmt|;
name|isdir
operator|=
literal|0
expr_stmt|;
comment|/* XXX just to get gcc to shut up */
for|for
control|(
name|map
operator|=
name|dumpdirmap
operator|,
name|ino
operator|=
literal|1
init|;
name|ino
operator|<
name|maxino
condition|;
name|ino
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ino
operator|-
literal|1
operator|)
operator|%
name|CHAR_BIT
operator|)
operator|==
literal|0
condition|)
comment|/* map is offset by 1 */
name|isdir
operator|=
operator|*
name|map
operator|++
expr_stmt|;
else|else
name|isdir
operator|>>=
literal|1
expr_stmt|;
comment|/* 		 * If a directory has been removed from usedinomap, it 		 * either has the nodump flag set, or has inherited 		 * it.  Although a directory can't be in dumpinomap if 		 * it isn't in usedinomap, we have to go through it to 		 * propagate the nodump flag. 		 */
name|nodump
operator|=
operator|!
name|nonodump
operator|&&
operator|(
name|TSTINO
argument_list|(
name|ino
argument_list|,
name|usedinomap
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|isdir
operator|&
literal|1
operator|)
operator|==
literal|0
operator|||
operator|(
name|TSTINO
argument_list|(
name|ino
argument_list|,
name|dumpinomap
argument_list|)
operator|&&
operator|!
name|nodump
operator|)
condition|)
continue|continue;
name|dp
operator|=
name|getino
argument_list|(
name|ino
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
comment|/* 		 * inode buf may change in searchdir(). 		 */
if|if
condition|(
name|sblock
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|di
operator|.
name|dp1
operator|=
name|dp
operator|->
name|dp1
expr_stmt|;
else|else
name|di
operator|.
name|dp2
operator|=
name|dp
operator|->
name|dp2
expr_stmt|;
name|filesize
operator|=
name|DIP
argument_list|(
operator|&
name|di
argument_list|,
name|di_size
argument_list|)
expr_stmt|;
for|for
control|(
name|ret
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|filesize
operator|>
literal|0
operator|&&
name|i
operator|<
name|NDADDR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DIP
argument_list|(
operator|&
name|di
argument_list|,
name|di_db
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator||=
name|searchdir
argument_list|(
name|ino
argument_list|,
name|DIP
argument_list|(
operator|&
name|di
argument_list|,
name|di_db
index|[
name|i
index|]
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|sblksize
argument_list|(
name|sblock
argument_list|,
name|DIP
argument_list|(
operator|&
name|di
argument_list|,
name|di_size
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|,
name|filesize
argument_list|,
name|tapesize
argument_list|,
name|nodump
argument_list|,
name|maxino
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&
name|HASDUMPEDFILE
condition|)
name|filesize
operator|=
literal|0
expr_stmt|;
else|else
name|filesize
operator|-=
name|sblock
operator|->
name|fs_bsize
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|filesize
operator|>
literal|0
operator|&&
name|i
operator|<
name|NIADDR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DIP
argument_list|(
operator|&
name|di
argument_list|,
name|di_ib
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|ret
operator||=
name|dirindir
argument_list|(
name|ino
argument_list|,
name|DIP
argument_list|(
operator|&
name|di
argument_list|,
name|di_ib
index|[
name|i
index|]
argument_list|)
argument_list|,
name|i
argument_list|,
operator|&
name|filesize
argument_list|,
name|tapesize
argument_list|,
name|nodump
argument_list|,
name|maxino
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|&
name|HASDUMPEDFILE
condition|)
block|{
name|SETINO
argument_list|(
name|ino
argument_list|,
name|dumpinomap
argument_list|)
expr_stmt|;
operator|*
name|tapesize
operator|+=
name|blockest
argument_list|(
operator|&
name|di
argument_list|)
expr_stmt|;
name|change
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nodump
condition|)
block|{
if|if
condition|(
name|ret
operator|&
name|HASSUBDIRS
condition|)
name|change
operator|=
literal|1
expr_stmt|;
comment|/* subdirs inherit nodump */
name|CLRINO
argument_list|(
name|ino
argument_list|,
name|dumpdirmap
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ret
operator|&
name|HASSUBDIRS
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|TSTINO
argument_list|(
name|ino
argument_list|,
name|dumpinomap
argument_list|)
condition|)
block|{
name|CLRINO
argument_list|(
name|ino
argument_list|,
name|dumpdirmap
argument_list|)
expr_stmt|;
name|change
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|change
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read indirect blocks, and pass the data blocks to be searched  * as directories. Quit as soon as any entry is found that will  * require the directory to be dumped.  */
end_comment

begin_function
specifier|static
name|int
name|dirindir
parameter_list|(
name|ino_t
name|ino
parameter_list|,
name|ufs2_daddr_t
name|blkno
parameter_list|,
name|int
name|ind_level
parameter_list|,
name|long
modifier|*
name|filesize
parameter_list|,
name|long
modifier|*
name|tapesize
parameter_list|,
name|int
name|nodump
parameter_list|,
name|ino_t
name|maxino
parameter_list|)
block|{
union|union
block|{
name|ufs1_daddr_t
name|ufs1
index|[
name|MAXBSIZE
operator|/
sizeof|sizeof
argument_list|(
name|ufs1_daddr_t
argument_list|)
index|]
decl_stmt|;
name|ufs2_daddr_t
name|ufs2
index|[
name|MAXBSIZE
operator|/
sizeof|sizeof
argument_list|(
name|ufs2_daddr_t
argument_list|)
index|]
decl_stmt|;
block|}
name|idblk
union|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bread
argument_list|(
name|fsbtodb
argument_list|(
name|sblock
argument_list|,
name|blkno
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|idblk
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind_level
operator|<=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|filesize
operator|>
literal|0
operator|&&
name|i
operator|<
name|NINDIR
argument_list|(
name|sblock
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sblock
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|blkno
operator|=
name|idblk
operator|.
name|ufs1
index|[
name|i
index|]
expr_stmt|;
else|else
name|blkno
operator|=
name|idblk
operator|.
name|ufs2
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|blkno
operator|!=
literal|0
condition|)
name|ret
operator||=
name|searchdir
argument_list|(
name|ino
argument_list|,
name|blkno
argument_list|,
name|sblock
operator|->
name|fs_bsize
argument_list|,
operator|*
name|filesize
argument_list|,
name|tapesize
argument_list|,
name|nodump
argument_list|,
name|maxino
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&
name|HASDUMPEDFILE
condition|)
operator|*
name|filesize
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|filesize
operator|-=
name|sblock
operator|->
name|fs_bsize
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|ind_level
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|filesize
operator|>
literal|0
operator|&&
name|i
operator|<
name|NINDIR
argument_list|(
name|sblock
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sblock
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|blkno
operator|=
name|idblk
operator|.
name|ufs1
index|[
name|i
index|]
expr_stmt|;
else|else
name|blkno
operator|=
name|idblk
operator|.
name|ufs2
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|blkno
operator|!=
literal|0
condition|)
name|ret
operator||=
name|dirindir
argument_list|(
name|ino
argument_list|,
name|blkno
argument_list|,
name|ind_level
argument_list|,
name|filesize
argument_list|,
name|tapesize
argument_list|,
name|nodump
argument_list|,
name|maxino
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scan a disk block containing directory information looking to see if  * any of the entries are on the dump list and to see if the directory  * contains any subdirectories.  */
end_comment

begin_function
specifier|static
name|int
name|searchdir
parameter_list|(
name|ino_t
name|ino
parameter_list|,
name|ufs2_daddr_t
name|blkno
parameter_list|,
name|long
name|size
parameter_list|,
name|long
name|filesize
parameter_list|,
name|long
modifier|*
name|tapesize
parameter_list|,
name|int
name|nodump
parameter_list|,
name|ino_t
name|maxino
parameter_list|)
block|{
name|int
name|mode
decl_stmt|;
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|union
name|dinode
modifier|*
name|ip
decl_stmt|;
name|long
name|loc
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
specifier|static
name|caddr_t
name|dblk
decl_stmt|;
if|if
condition|(
name|dblk
operator|==
name|NULL
operator|&&
operator|(
name|dblk
operator|=
name|malloc
argument_list|(
name|sblock
operator|->
name|fs_bsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|quit
argument_list|(
literal|"searchdir: cannot allocate indirect memory.\n"
argument_list|)
expr_stmt|;
name|bread
argument_list|(
name|fsbtodb
argument_list|(
name|sblock
argument_list|,
name|blkno
argument_list|)
argument_list|,
name|dblk
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|filesize
operator|<
name|size
condition|)
name|size
operator|=
name|filesize
expr_stmt|;
for|for
control|(
name|loc
operator|=
literal|0
init|;
name|loc
operator|<
name|size
condition|;
control|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
name|dblk
operator|+
name|loc
operator|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_reclen
operator|==
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"corrupted directory, inumber %d\n"
argument_list|,
name|ino
argument_list|)
expr_stmt|;
break|break;
block|}
name|loc
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|>=
name|maxino
condition|)
block|{
name|msg
argument_list|(
literal|"corrupted directory entry, d_ino %d>= %d\n"
argument_list|,
name|dp
operator|->
name|d_ino
argument_list|,
name|maxino
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
block|}
if|if
condition|(
name|nodump
condition|)
block|{
name|ip
operator|=
name|getino
argument_list|(
name|dp
operator|->
name|d_ino
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TSTINO
argument_list|(
name|dp
operator|->
name|d_ino
argument_list|,
name|dumpinomap
argument_list|)
condition|)
block|{
name|CLRINO
argument_list|(
name|dp
operator|->
name|d_ino
argument_list|,
name|dumpinomap
argument_list|)
expr_stmt|;
operator|*
name|tapesize
operator|-=
name|blockest
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Add back to dumpdirmap and remove from usedinomap 			 * to propagate nodump. 			 */
if|if
condition|(
name|mode
operator|==
name|IFDIR
condition|)
block|{
name|SETINO
argument_list|(
name|dp
operator|->
name|d_ino
argument_list|,
name|dumpdirmap
argument_list|)
expr_stmt|;
name|CLRINO
argument_list|(
name|dp
operator|->
name|d_ino
argument_list|,
name|usedinomap
argument_list|)
expr_stmt|;
name|ret
operator||=
name|HASSUBDIRS
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TSTINO
argument_list|(
name|dp
operator|->
name|d_ino
argument_list|,
name|dumpinomap
argument_list|)
condition|)
block|{
name|ret
operator||=
name|HASDUMPEDFILE
expr_stmt|;
if|if
condition|(
name|ret
operator|&
name|HASSUBDIRS
condition|)
break|break;
block|}
if|if
condition|(
name|TSTINO
argument_list|(
name|dp
operator|->
name|d_ino
argument_list|,
name|dumpdirmap
argument_list|)
condition|)
block|{
name|ret
operator||=
name|HASSUBDIRS
expr_stmt|;
if|if
condition|(
name|ret
operator|&
name|HASDUMPEDFILE
condition|)
break|break;
block|}
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump passes 3 and 4.  *  * Dump the contents of an inode to tape.  */
end_comment

begin_function
name|void
name|dumpino
parameter_list|(
name|union
name|dinode
modifier|*
name|dp
parameter_list|,
name|ino_t
name|ino
parameter_list|)
block|{
name|int
name|ind_level
decl_stmt|,
name|cnt
decl_stmt|,
name|last
decl_stmt|,
name|added
decl_stmt|;
name|off_t
name|size
decl_stmt|;
name|char
name|buf
index|[
name|TP_BSIZE
index|]
decl_stmt|;
if|if
condition|(
name|newtape
condition|)
block|{
name|newtape
operator|=
literal|0
expr_stmt|;
name|dumpmap
argument_list|(
name|dumpinomap
argument_list|,
name|TS_BITS
argument_list|,
name|ino
argument_list|)
expr_stmt|;
block|}
name|CLRINO
argument_list|(
name|ino
argument_list|,
name|dumpinomap
argument_list|)
expr_stmt|;
comment|/* 	 * Zero out the size of a snapshot so that it will be dumped 	 * as a zero length file. 	 */
if|if
condition|(
operator|(
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_flags
argument_list|)
operator|&
name|SF_SNAPSHOT
operator|)
operator|!=
literal|0
condition|)
block|{
name|DIP_SET
argument_list|(
name|dp
argument_list|,
name|di_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DIP_SET
argument_list|(
name|dp
argument_list|,
name|di_flags
argument_list|,
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_flags
argument_list|)
operator|&
operator|~
name|SF_SNAPSHOT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sblock
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
block|{
name|spcl
operator|.
name|c_mode
operator|=
name|dp
operator|->
name|dp1
operator|.
name|di_mode
expr_stmt|;
name|spcl
operator|.
name|c_size
operator|=
name|dp
operator|->
name|dp1
operator|.
name|di_size
expr_stmt|;
name|spcl
operator|.
name|c_extsize
operator|=
literal|0
expr_stmt|;
name|spcl
operator|.
name|c_atime
operator|=
name|_time32_to_time
argument_list|(
name|dp
operator|->
name|dp1
operator|.
name|di_atime
argument_list|)
expr_stmt|;
name|spcl
operator|.
name|c_atimensec
operator|=
name|dp
operator|->
name|dp1
operator|.
name|di_atimensec
expr_stmt|;
name|spcl
operator|.
name|c_mtime
operator|=
name|_time32_to_time
argument_list|(
name|dp
operator|->
name|dp1
operator|.
name|di_mtime
argument_list|)
expr_stmt|;
name|spcl
operator|.
name|c_mtimensec
operator|=
name|dp
operator|->
name|dp1
operator|.
name|di_mtimensec
expr_stmt|;
name|spcl
operator|.
name|c_birthtime
operator|=
literal|0
expr_stmt|;
name|spcl
operator|.
name|c_birthtimensec
operator|=
literal|0
expr_stmt|;
name|spcl
operator|.
name|c_rdev
operator|=
name|dp
operator|->
name|dp1
operator|.
name|di_rdev
expr_stmt|;
name|spcl
operator|.
name|c_file_flags
operator|=
name|dp
operator|->
name|dp1
operator|.
name|di_flags
expr_stmt|;
name|spcl
operator|.
name|c_uid
operator|=
name|dp
operator|->
name|dp1
operator|.
name|di_uid
expr_stmt|;
name|spcl
operator|.
name|c_gid
operator|=
name|dp
operator|->
name|dp1
operator|.
name|di_gid
expr_stmt|;
block|}
else|else
block|{
name|spcl
operator|.
name|c_mode
operator|=
name|dp
operator|->
name|dp2
operator|.
name|di_mode
expr_stmt|;
name|spcl
operator|.
name|c_size
operator|=
name|dp
operator|->
name|dp2
operator|.
name|di_size
expr_stmt|;
name|spcl
operator|.
name|c_extsize
operator|=
name|dp
operator|->
name|dp2
operator|.
name|di_extsize
expr_stmt|;
name|spcl
operator|.
name|c_atime
operator|=
name|_time64_to_time
argument_list|(
name|dp
operator|->
name|dp2
operator|.
name|di_atime
argument_list|)
expr_stmt|;
name|spcl
operator|.
name|c_atimensec
operator|=
name|dp
operator|->
name|dp2
operator|.
name|di_atimensec
expr_stmt|;
name|spcl
operator|.
name|c_mtime
operator|=
name|_time64_to_time
argument_list|(
name|dp
operator|->
name|dp2
operator|.
name|di_mtime
argument_list|)
expr_stmt|;
name|spcl
operator|.
name|c_mtimensec
operator|=
name|dp
operator|->
name|dp2
operator|.
name|di_mtimensec
expr_stmt|;
name|spcl
operator|.
name|c_birthtime
operator|=
name|_time64_to_time
argument_list|(
name|dp
operator|->
name|dp2
operator|.
name|di_birthtime
argument_list|)
expr_stmt|;
name|spcl
operator|.
name|c_birthtimensec
operator|=
name|dp
operator|->
name|dp2
operator|.
name|di_birthnsec
expr_stmt|;
name|spcl
operator|.
name|c_rdev
operator|=
name|dp
operator|->
name|dp2
operator|.
name|di_rdev
expr_stmt|;
name|spcl
operator|.
name|c_file_flags
operator|=
name|dp
operator|->
name|dp2
operator|.
name|di_flags
expr_stmt|;
name|spcl
operator|.
name|c_uid
operator|=
name|dp
operator|->
name|dp2
operator|.
name|di_uid
expr_stmt|;
name|spcl
operator|.
name|c_gid
operator|=
name|dp
operator|->
name|dp2
operator|.
name|di_gid
expr_stmt|;
block|}
name|spcl
operator|.
name|c_type
operator|=
name|TS_INODE
expr_stmt|;
name|spcl
operator|.
name|c_count
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_mode
argument_list|)
operator|&
name|S_IFMT
condition|)
block|{
case|case
literal|0
case|:
comment|/* 		 * Freed inode. 		 */
return|return;
case|case
name|S_IFLNK
case|:
comment|/* 		 * Check for short symbolic link. 		 */
if|if
condition|(
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_size
argument_list|)
operator|>
literal|0
operator|&&
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_size
argument_list|)
operator|<
name|sblock
operator|->
name|fs_maxsymlinklen
condition|)
block|{
name|spcl
operator|.
name|c_addr
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|spcl
operator|.
name|c_count
operator|=
literal|1
expr_stmt|;
name|added
operator|=
name|appendextdata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|writeheader
argument_list|(
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|memmove
argument_list|(
name|buf
argument_list|,
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|dp1
operator|.
name|di_db
argument_list|,
operator|(
name|u_long
operator|)
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_size
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|memmove
argument_list|(
name|buf
argument_list|,
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|dp2
operator|.
name|di_db
argument_list|,
operator|(
name|u_long
operator|)
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_size
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_size
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|writerec
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writeextdata
argument_list|(
name|dp
argument_list|,
name|ino
argument_list|,
name|added
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FALLTHROUGH */
case|case
name|S_IFDIR
case|:
case|case
name|S_IFREG
case|:
if|if
condition|(
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_size
argument_list|)
operator|>
literal|0
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|S_IFIFO
case|:
case|case
name|S_IFSOCK
case|:
case|case
name|S_IFCHR
case|:
case|case
name|S_IFBLK
case|:
name|added
operator|=
name|appendextdata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|writeheader
argument_list|(
name|ino
argument_list|)
expr_stmt|;
name|writeextdata
argument_list|(
name|dp
argument_list|,
name|ino
argument_list|,
name|added
argument_list|)
expr_stmt|;
return|return;
default|default:
name|msg
argument_list|(
literal|"Warning: undefined file type 0%o\n"
argument_list|,
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_mode
argument_list|)
operator|&
name|IFMT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_size
argument_list|)
operator|>
name|NDADDR
operator|*
name|sblock
operator|->
name|fs_bsize
condition|)
block|{
name|cnt
operator|=
name|NDADDR
operator|*
name|sblock
operator|->
name|fs_frag
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|=
name|howmany
argument_list|(
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_size
argument_list|)
argument_list|,
name|sblock
operator|->
name|fs_fsize
argument_list|)
expr_stmt|;
name|last
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sblock
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|ufs1_blksout
argument_list|(
operator|&
name|dp
operator|->
name|dp1
operator|.
name|di_db
index|[
literal|0
index|]
argument_list|,
name|cnt
argument_list|,
name|ino
argument_list|)
expr_stmt|;
else|else
name|ufs2_blksout
argument_list|(
name|dp
argument_list|,
operator|&
name|dp
operator|->
name|dp2
operator|.
name|di_db
index|[
literal|0
index|]
argument_list|,
name|cnt
argument_list|,
name|ino
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|=
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_size
argument_list|)
operator|-
name|NDADDR
operator|*
name|sblock
operator|->
name|fs_bsize
operator|)
operator|<=
literal|0
condition|)
return|return;
for|for
control|(
name|ind_level
operator|=
literal|0
init|;
name|ind_level
operator|<
name|NIADDR
condition|;
name|ind_level
operator|++
control|)
block|{
name|dmpindir
argument_list|(
name|dp
argument_list|,
name|ino
argument_list|,
name|DIP
argument_list|(
name|dp
argument_list|,
name|di_ib
index|[
name|ind_level
index|]
argument_list|)
argument_list|,
name|ind_level
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Read indirect blocks, and pass the data blocks to be dumped.  */
end_comment

begin_function
specifier|static
name|void
name|dmpindir
parameter_list|(
name|union
name|dinode
modifier|*
name|dp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|ufs2_daddr_t
name|blk
parameter_list|,
name|int
name|ind_level
parameter_list|,
name|off_t
modifier|*
name|size
parameter_list|)
block|{
union|union
block|{
name|ufs1_daddr_t
name|ufs1
index|[
name|MAXBSIZE
operator|/
sizeof|sizeof
argument_list|(
name|ufs1_daddr_t
argument_list|)
index|]
decl_stmt|;
name|ufs2_daddr_t
name|ufs2
index|[
name|MAXBSIZE
operator|/
sizeof|sizeof
argument_list|(
name|ufs2_daddr_t
argument_list|)
index|]
decl_stmt|;
block|}
name|idblk
union|;
name|int
name|i
decl_stmt|,
name|cnt
decl_stmt|,
name|last
decl_stmt|;
if|if
condition|(
name|blk
operator|!=
literal|0
condition|)
name|bread
argument_list|(
name|fsbtodb
argument_list|(
name|sblock
argument_list|,
name|blk
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|idblk
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
operator|&
name|idblk
argument_list|,
literal|0
argument_list|,
name|sblock
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind_level
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|size
operator|>
name|NINDIR
argument_list|(
name|sblock
argument_list|)
operator|*
name|sblock
operator|->
name|fs_bsize
condition|)
block|{
name|cnt
operator|=
name|NINDIR
argument_list|(
name|sblock
argument_list|)
operator|*
name|sblock
operator|->
name|fs_frag
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|=
name|howmany
argument_list|(
operator|*
name|size
argument_list|,
name|sblock
operator|->
name|fs_fsize
argument_list|)
expr_stmt|;
name|last
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|size
operator|-=
name|NINDIR
argument_list|(
name|sblock
argument_list|)
operator|*
name|sblock
operator|->
name|fs_bsize
expr_stmt|;
if|if
condition|(
name|sblock
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|ufs1_blksout
argument_list|(
name|idblk
operator|.
name|ufs1
argument_list|,
name|cnt
argument_list|,
name|ino
argument_list|)
expr_stmt|;
else|else
name|ufs2_blksout
argument_list|(
name|dp
argument_list|,
name|idblk
operator|.
name|ufs2
argument_list|,
name|cnt
argument_list|,
name|ino
argument_list|,
name|last
argument_list|)
expr_stmt|;
return|return;
block|}
name|ind_level
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NINDIR
argument_list|(
name|sblock
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sblock
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
name|dmpindir
argument_list|(
name|dp
argument_list|,
name|ino
argument_list|,
name|idblk
operator|.
name|ufs1
index|[
name|i
index|]
argument_list|,
name|ind_level
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|dmpindir
argument_list|(
name|dp
argument_list|,
name|ino
argument_list|,
name|idblk
operator|.
name|ufs2
index|[
name|i
index|]
argument_list|,
name|ind_level
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|size
operator|<=
literal|0
condition|)
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Collect up the data into tape record sized buffers and output them.  */
end_comment

begin_function
specifier|static
name|void
name|ufs1_blksout
parameter_list|(
name|ufs1_daddr_t
modifier|*
name|blkp
parameter_list|,
name|int
name|frags
parameter_list|,
name|ino_t
name|ino
parameter_list|)
block|{
name|ufs1_daddr_t
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|count
decl_stmt|,
name|blks
decl_stmt|,
name|tbperdb
decl_stmt|;
name|blks
operator|=
name|howmany
argument_list|(
name|frags
operator|*
name|sblock
operator|->
name|fs_fsize
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|tbperdb
operator|=
name|sblock
operator|->
name|fs_bsize
operator|>>
name|tp_bshift
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blks
condition|;
name|i
operator|+=
name|TP_NINDIR
control|)
block|{
if|if
condition|(
name|i
operator|+
name|TP_NINDIR
operator|>
name|blks
condition|)
name|count
operator|=
name|blks
expr_stmt|;
else|else
name|count
operator|=
name|i
operator|+
name|TP_NINDIR
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|blkp
index|[
name|j
operator|/
name|tbperdb
index|]
operator|!=
literal|0
condition|)
name|spcl
operator|.
name|c_addr
index|[
name|j
operator|-
name|i
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|spcl
operator|.
name|c_addr
index|[
name|j
operator|-
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|spcl
operator|.
name|c_count
operator|=
name|count
operator|-
name|i
expr_stmt|;
name|writeheader
argument_list|(
name|ino
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|&
name|blkp
index|[
name|i
operator|/
name|tbperdb
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|+=
name|tbperdb
operator|,
name|bp
operator|++
control|)
if|if
condition|(
operator|*
name|bp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|j
operator|+
name|tbperdb
operator|<=
name|count
condition|)
name|dumpblock
argument_list|(
operator|*
name|bp
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
else|else
name|dumpblock
argument_list|(
operator|*
name|bp
argument_list|,
operator|(
name|count
operator|-
name|j
operator|)
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
block|}
name|spcl
operator|.
name|c_type
operator|=
name|TS_ADDR
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Collect up the data into tape record sized buffers and output them.  */
end_comment

begin_function
specifier|static
name|void
name|ufs2_blksout
parameter_list|(
name|union
name|dinode
modifier|*
name|dp
parameter_list|,
name|ufs2_daddr_t
modifier|*
name|blkp
parameter_list|,
name|int
name|frags
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|ufs2_daddr_t
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|count
decl_stmt|,
name|resid
decl_stmt|,
name|blks
decl_stmt|,
name|tbperdb
decl_stmt|,
name|added
decl_stmt|;
specifier|static
name|int
name|writingextdata
init|=
literal|0
decl_stmt|;
comment|/* 	 * Calculate the number of TP_BSIZE blocks to be dumped. 	 * For filesystems with a fragment size bigger than TP_BSIZE, 	 * only part of the final fragment may need to be dumped. 	 */
name|blks
operator|=
name|howmany
argument_list|(
name|frags
operator|*
name|sblock
operator|->
name|fs_fsize
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
block|{
name|resid
operator|=
name|howmany
argument_list|(
name|fragoff
argument_list|(
name|sblock
argument_list|,
name|dp
operator|->
name|dp2
operator|.
name|di_size
argument_list|)
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|resid
operator|>
literal|0
condition|)
name|blks
operator|-=
name|howmany
argument_list|(
name|sblock
operator|->
name|fs_fsize
argument_list|,
name|TP_BSIZE
argument_list|)
operator|-
name|resid
expr_stmt|;
block|}
name|tbperdb
operator|=
name|sblock
operator|->
name|fs_bsize
operator|>>
name|tp_bshift
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blks
condition|;
name|i
operator|+=
name|TP_NINDIR
control|)
block|{
if|if
condition|(
name|i
operator|+
name|TP_NINDIR
operator|>
name|blks
condition|)
name|count
operator|=
name|blks
expr_stmt|;
else|else
name|count
operator|=
name|i
operator|+
name|TP_NINDIR
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|blkp
index|[
name|j
operator|/
name|tbperdb
index|]
operator|!=
literal|0
condition|)
name|spcl
operator|.
name|c_addr
index|[
name|j
operator|-
name|i
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|spcl
operator|.
name|c_addr
index|[
name|j
operator|-
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|spcl
operator|.
name|c_count
operator|=
name|count
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|last
operator|&&
name|count
operator|==
name|blks
operator|&&
operator|!
name|writingextdata
condition|)
name|added
operator|=
name|appendextdata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|writeheader
argument_list|(
name|ino
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|&
name|blkp
index|[
name|i
operator|/
name|tbperdb
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|+=
name|tbperdb
operator|,
name|bp
operator|++
control|)
if|if
condition|(
operator|*
name|bp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|j
operator|+
name|tbperdb
operator|<=
name|count
condition|)
name|dumpblock
argument_list|(
operator|*
name|bp
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
else|else
name|dumpblock
argument_list|(
operator|*
name|bp
argument_list|,
operator|(
name|count
operator|-
name|j
operator|)
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
block|}
name|spcl
operator|.
name|c_type
operator|=
name|TS_ADDR
expr_stmt|;
name|spcl
operator|.
name|c_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|last
operator|&&
name|count
operator|==
name|blks
operator|&&
operator|!
name|writingextdata
condition|)
block|{
name|writingextdata
operator|=
literal|1
expr_stmt|;
name|writeextdata
argument_list|(
name|dp
argument_list|,
name|ino
argument_list|,
name|added
argument_list|)
expr_stmt|;
name|writingextdata
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * If there is room in the current block for the extended attributes  * as well as the file data, update the header to reflect the added  * attribute data at the end. Attributes are placed at the end so that  * old versions of restore will correctly restore the file and simply  * discard the extra data at the end that it does not understand.  * The attribute data is dumped following the file data by the  * writeextdata() function (below).  */
end_comment

begin_function
specifier|static
name|int
name|appendextdata
parameter_list|(
name|union
name|dinode
modifier|*
name|dp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|blks
decl_stmt|,
name|tbperdb
decl_stmt|;
comment|/* 	 * If no extended attributes, there is nothing to do. 	 */
if|if
condition|(
name|spcl
operator|.
name|c_extsize
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If there is not enough room at the end of this block 	 * to add the extended attributes, then rather than putting 	 * part of them here, we simply push them entirely into a 	 * new block rather than putting some here and some later. 	 */
if|if
condition|(
name|spcl
operator|.
name|c_extsize
operator|>
name|NXADDR
operator|*
name|sblock
operator|->
name|fs_bsize
condition|)
name|blks
operator|=
name|howmany
argument_list|(
name|NXADDR
operator|*
name|sblock
operator|->
name|fs_bsize
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
else|else
name|blks
operator|=
name|howmany
argument_list|(
name|spcl
operator|.
name|c_extsize
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|spcl
operator|.
name|c_count
operator|+
name|blks
operator|>
name|TP_NINDIR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Update the block map in the header to indicate the added 	 * extended attribute. They will be appended after the file 	 * data by the writeextdata() routine. 	 */
name|tbperdb
operator|=
name|sblock
operator|->
name|fs_bsize
operator|>>
name|tp_bshift
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blks
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|&
name|dp
operator|->
name|dp2
operator|.
name|di_extb
index|[
name|i
operator|/
name|tbperdb
index|]
operator|!=
literal|0
condition|)
name|spcl
operator|.
name|c_addr
index|[
name|spcl
operator|.
name|c_count
operator|+
name|i
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|spcl
operator|.
name|c_addr
index|[
name|spcl
operator|.
name|c_count
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|spcl
operator|.
name|c_count
operator|+=
name|blks
expr_stmt|;
return|return
operator|(
name|blks
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump the extended attribute data. If there was room in the file  * header, then all we need to do is output the data blocks. If there  * was not room in the file header, then an additional TS_ADDR header  * is created to hold the attribute data.  */
end_comment

begin_function
specifier|static
name|void
name|writeextdata
parameter_list|(
name|union
name|dinode
modifier|*
name|dp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|int
name|added
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|frags
decl_stmt|,
name|blks
decl_stmt|,
name|tbperdb
decl_stmt|,
name|last
decl_stmt|;
name|ufs2_daddr_t
modifier|*
name|bp
decl_stmt|;
name|off_t
name|size
decl_stmt|;
comment|/* 	 * If no extended attributes, there is nothing to do. 	 */
if|if
condition|(
name|spcl
operator|.
name|c_extsize
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * If there was no room in the file block for the attributes, 	 * dump them out in a new block, otherwise just dump the data. 	 */
if|if
condition|(
name|added
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|spcl
operator|.
name|c_extsize
operator|>
name|NXADDR
operator|*
name|sblock
operator|->
name|fs_bsize
condition|)
block|{
name|frags
operator|=
name|NXADDR
operator|*
name|sblock
operator|->
name|fs_frag
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|frags
operator|=
name|howmany
argument_list|(
name|spcl
operator|.
name|c_extsize
argument_list|,
name|sblock
operator|->
name|fs_fsize
argument_list|)
expr_stmt|;
name|last
operator|=
literal|1
expr_stmt|;
block|}
name|ufs2_blksout
argument_list|(
name|dp
argument_list|,
operator|&
name|dp
operator|->
name|dp2
operator|.
name|di_extb
index|[
literal|0
index|]
argument_list|,
name|frags
argument_list|,
name|ino
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|spcl
operator|.
name|c_extsize
operator|>
name|NXADDR
operator|*
name|sblock
operator|->
name|fs_bsize
condition|)
name|blks
operator|=
name|howmany
argument_list|(
name|NXADDR
operator|*
name|sblock
operator|->
name|fs_bsize
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
else|else
name|blks
operator|=
name|howmany
argument_list|(
name|spcl
operator|.
name|c_extsize
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|tbperdb
operator|=
name|sblock
operator|->
name|fs_bsize
operator|>>
name|tp_bshift
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blks
condition|;
name|i
operator|+=
name|tbperdb
control|)
block|{
name|bp
operator|=
operator|&
name|dp
operator|->
name|dp2
operator|.
name|di_extb
index|[
name|i
operator|/
name|tbperdb
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|+
name|tbperdb
operator|<=
name|blks
condition|)
name|dumpblock
argument_list|(
operator|*
name|bp
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
else|else
name|dumpblock
argument_list|(
operator|*
name|bp
argument_list|,
operator|(
name|blks
operator|-
name|i
operator|)
operator|*
name|TP_BSIZE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If an indirect block is added for extended attributes, then 	 * di_exti below should be changed to the structure element 	 * that references the extended attribute indirect block. This 	 * definition is here only to make it compile without complaint. 	 */
define|#
directive|define
name|di_exti
value|di_spare[0]
comment|/* 	 * If the extended attributes fall into an indirect block, 	 * dump it as well. 	 */
if|if
condition|(
operator|(
name|size
operator|=
name|spcl
operator|.
name|c_extsize
operator|-
name|NXADDR
operator|*
name|sblock
operator|->
name|fs_bsize
operator|)
operator|>
literal|0
condition|)
name|dmpindir
argument_list|(
name|dp
argument_list|,
name|ino
argument_list|,
name|dp
operator|->
name|dp2
operator|.
name|di_exti
argument_list|,
literal|0
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump a map to the tape.  */
end_comment

begin_function
name|void
name|dumpmap
parameter_list|(
name|char
modifier|*
name|map
parameter_list|,
name|int
name|type
parameter_list|,
name|ino_t
name|ino
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|spcl
operator|.
name|c_type
operator|=
name|type
expr_stmt|;
name|spcl
operator|.
name|c_count
operator|=
name|howmany
argument_list|(
name|mapsize
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|TP_BSIZE
argument_list|)
expr_stmt|;
name|writeheader
argument_list|(
name|ino
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cp
operator|=
name|map
init|;
name|i
operator|<
name|spcl
operator|.
name|c_count
condition|;
name|i
operator|++
operator|,
name|cp
operator|+=
name|TP_BSIZE
control|)
name|writerec
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a header record to the dump tape.  */
end_comment

begin_function
name|void
name|writeheader
parameter_list|(
name|ino_t
name|ino
parameter_list|)
block|{
name|int32_t
name|sum
decl_stmt|,
name|cnt
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|spcl
operator|.
name|c_inumber
operator|=
name|ino
expr_stmt|;
name|spcl
operator|.
name|c_magic
operator|=
name|FS_UFS2_MAGIC
expr_stmt|;
name|spcl
operator|.
name|c_checksum
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|spcl
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
name|cnt
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|u_spcl
argument_list|)
operator|/
operator|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|cnt
operator|>=
literal|0
condition|)
block|{
name|sum
operator|+=
operator|*
name|lp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|lp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|lp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|lp
operator|++
expr_stmt|;
block|}
name|spcl
operator|.
name|c_checksum
operator|=
name|CHECKSUM
operator|-
name|sum
expr_stmt|;
name|writerec
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|spcl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|union
name|dinode
modifier|*
name|getino
parameter_list|(
name|ino_t
name|inum
parameter_list|,
name|int
modifier|*
name|modep
parameter_list|)
block|{
specifier|static
name|ino_t
name|minino
decl_stmt|,
name|maxino
decl_stmt|;
specifier|static
name|caddr_t
name|inoblock
decl_stmt|;
name|struct
name|ufs1_dinode
modifier|*
name|dp1
decl_stmt|;
name|struct
name|ufs2_dinode
modifier|*
name|dp2
decl_stmt|;
if|if
condition|(
name|inoblock
operator|==
name|NULL
operator|&&
operator|(
name|inoblock
operator|=
name|malloc
argument_list|(
name|sblock
operator|->
name|fs_bsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|quit
argument_list|(
literal|"cannot allocate inode memory.\n"
argument_list|)
expr_stmt|;
name|curino
operator|=
name|inum
expr_stmt|;
if|if
condition|(
name|inum
operator|>=
name|minino
operator|&&
name|inum
operator|<
name|maxino
condition|)
goto|goto
name|gotit
goto|;
name|bread
argument_list|(
name|fsbtodb
argument_list|(
name|sblock
argument_list|,
name|ino_to_fsba
argument_list|(
name|sblock
argument_list|,
name|inum
argument_list|)
argument_list|)
argument_list|,
name|inoblock
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|minino
operator|=
name|inum
operator|-
operator|(
name|inum
operator|%
name|INOPB
argument_list|(
name|sblock
argument_list|)
operator|)
expr_stmt|;
name|maxino
operator|=
name|minino
operator|+
name|INOPB
argument_list|(
name|sblock
argument_list|)
expr_stmt|;
name|gotit
label|:
if|if
condition|(
name|sblock
operator|->
name|fs_magic
operator|==
name|FS_UFS1_MAGIC
condition|)
block|{
name|dp1
operator|=
operator|&
operator|(
operator|(
expr|struct
name|ufs1_dinode
operator|*
operator|)
name|inoblock
operator|)
index|[
name|inum
operator|-
name|minino
index|]
expr_stmt|;
operator|*
name|modep
operator|=
operator|(
name|dp1
operator|->
name|di_mode
operator|&
name|IFMT
operator|)
expr_stmt|;
return|return
operator|(
operator|(
expr|union
name|dinode
operator|*
operator|)
name|dp1
operator|)
return|;
block|}
name|dp2
operator|=
operator|&
operator|(
operator|(
expr|struct
name|ufs2_dinode
operator|*
operator|)
name|inoblock
operator|)
index|[
name|inum
operator|-
name|minino
index|]
expr_stmt|;
operator|*
name|modep
operator|=
operator|(
name|dp2
operator|->
name|di_mode
operator|&
name|IFMT
operator|)
expr_stmt|;
return|return
operator|(
operator|(
expr|union
name|dinode
operator|*
operator|)
name|dp2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a chunk of data from the disk.  * Try to recover from hard errors by reading in sector sized pieces.  * Error recovery is attempted at most BREADEMAX times before seeking  * consent from the operator to continue.  */
end_comment

begin_decl_stmt
name|int
name|breaderrors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BREADEMAX
value|32
end_define

begin_function
name|void
name|bread
parameter_list|(
name|ufs2_daddr_t
name|blkno
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|secsize
decl_stmt|,
name|bytes
decl_stmt|,
name|resid
decl_stmt|,
name|xfer
decl_stmt|,
name|base
decl_stmt|,
name|cnt
decl_stmt|,
name|i
decl_stmt|;
specifier|static
name|char
modifier|*
name|tmpbuf
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|loop
label|:
name|offset
operator|=
name|blkno
operator|<<
name|dev_bshift
expr_stmt|;
name|secsize
operator|=
name|sblock
operator|->
name|fs_fsize
expr_stmt|;
name|base
operator|=
name|offset
operator|%
name|secsize
expr_stmt|;
name|resid
operator|=
name|size
operator|%
name|secsize
expr_stmt|;
comment|/* 	 * If the transfer request starts or ends on a non-sector 	 * boundary, we must read the entire sector and copy out 	 * just the part that we need. 	 */
if|if
condition|(
name|base
operator|==
literal|0
operator|&&
name|resid
operator|==
literal|0
condition|)
block|{
name|cnt
operator|=
name|cread
argument_list|(
name|diskfd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
name|size
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
name|tmpbuf
operator|==
name|NULL
operator|&&
operator|(
name|tmpbuf
operator|=
name|malloc
argument_list|(
name|secsize
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|quit
argument_list|(
literal|"buffer malloc failed\n"
argument_list|)
expr_stmt|;
name|xfer
operator|=
literal|0
expr_stmt|;
name|bytes
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|base
operator|!=
literal|0
condition|)
block|{
name|cnt
operator|=
name|cread
argument_list|(
name|diskfd
argument_list|,
name|tmpbuf
argument_list|,
name|secsize
argument_list|,
name|offset
operator|-
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
name|secsize
condition|)
goto|goto
name|bad
goto|;
name|xfer
operator|=
name|secsize
operator|-
name|base
expr_stmt|;
name|offset
operator|+=
name|xfer
expr_stmt|;
name|bytes
operator|-=
name|xfer
expr_stmt|;
name|resid
operator|=
name|bytes
operator|%
name|secsize
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|tmpbuf
index|[
name|base
index|]
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|>=
name|secsize
condition|)
block|{
name|cnt
operator|=
name|cread
argument_list|(
name|diskfd
argument_list|,
operator|&
name|buf
index|[
name|xfer
index|]
argument_list|,
name|bytes
operator|-
name|resid
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
name|bytes
operator|-
name|resid
condition|)
goto|goto
name|bad
goto|;
name|xfer
operator|+=
name|cnt
expr_stmt|;
name|offset
operator|+=
name|cnt
expr_stmt|;
block|}
if|if
condition|(
name|resid
operator|==
literal|0
condition|)
return|return;
name|cnt
operator|=
name|cread
argument_list|(
name|diskfd
argument_list|,
name|tmpbuf
argument_list|,
name|secsize
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
name|secsize
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|buf
index|[
name|xfer
index|]
argument_list|,
name|tmpbuf
argument_list|,
name|resid
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|bad
label|:
if|if
condition|(
name|blkno
operator|+
operator|(
name|size
operator|/
name|dev_bsize
operator|)
operator|>
name|fsbtodb
argument_list|(
name|sblock
argument_list|,
name|sblock
operator|->
name|fs_size
argument_list|)
condition|)
block|{
comment|/* 		 * Trying to read the final fragment. 		 * 		 * NB - dump only works in TP_BSIZE blocks, hence 		 * rounds `dev_bsize' fragments up to TP_BSIZE pieces. 		 * It should be smarter about not actually trying to 		 * read more than it can get, but for the time being 		 * we punt and scale back the read only when it gets 		 * us into trouble. (mkm 9/25/83) 		 */
name|size
operator|-=
name|dev_bsize
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|cnt
operator|==
operator|-
literal|1
condition|)
name|msg
argument_list|(
literal|"read error from %s: %s: [block %jd]: count=%d\n"
argument_list|,
name|disk
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|blkno
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|msg
argument_list|(
literal|"short read error from %s: [block %jd]: count=%d, got=%d\n"
argument_list|,
name|disk
argument_list|,
operator|(
name|intmax_t
operator|)
name|blkno
argument_list|,
name|size
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|breaderrors
operator|>
name|BREADEMAX
condition|)
block|{
name|msg
argument_list|(
literal|"More than %d block read errors from %s\n"
argument_list|,
name|BREADEMAX
argument_list|,
name|disk
argument_list|)
expr_stmt|;
name|broadcast
argument_list|(
literal|"DUMP IS AILING!\n"
argument_list|)
expr_stmt|;
name|msg
argument_list|(
literal|"This is an unrecoverable error.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Do you want to attempt to continue?"
argument_list|)
condition|)
block|{
name|dumpabort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|else
name|breaderrors
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Zero buffer, then try to read each sector of buffer separately, 	 * and bypass the cache. 	 */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
name|dev_bsize
operator|,
name|buf
operator|+=
name|dev_bsize
operator|,
name|blkno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cnt
operator|=
name|pread
argument_list|(
name|diskfd
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|dev_bsize
argument_list|,
operator|(
operator|(
name|off_t
operator|)
name|blkno
operator|<<
name|dev_bshift
operator|)
argument_list|)
operator|)
operator|==
name|dev_bsize
condition|)
continue|continue;
if|if
condition|(
name|cnt
operator|==
operator|-
literal|1
condition|)
block|{
name|msg
argument_list|(
literal|"read error from %s: %s: [sector %jd]: count=%ld\n"
argument_list|,
name|disk
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|blkno
argument_list|,
name|dev_bsize
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|msg
argument_list|(
literal|"short read from %s: [sector %jd]: count=%ld, got=%d\n"
argument_list|,
name|disk
argument_list|,
operator|(
name|intmax_t
operator|)
name|blkno
argument_list|,
name|dev_bsize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

