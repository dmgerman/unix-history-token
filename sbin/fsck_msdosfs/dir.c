begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997 Wolfgang Solfrank  * Copyright (c) 1995 Martin Husemann  * Some structure declaration borrowed from Paul Popelka  * (paulp@uts.amdahl.com), see /sys/msdosfs/ for reference.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Martin Husemann  *	and Wolfgang Solfrank.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: dir.c,v 1.14 1998/08/25 19:18:15 ross Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|"ext.h"
end_include

begin_include
include|#
directive|include
file|"fsutil.h"
end_include

begin_define
define|#
directive|define
name|SLOT_EMPTY
value|0x00
end_define

begin_comment
comment|/* slot has never been used */
end_comment

begin_define
define|#
directive|define
name|SLOT_E5
value|0x05
end_define

begin_comment
comment|/* the real value is 0xe5 */
end_comment

begin_define
define|#
directive|define
name|SLOT_DELETED
value|0xe5
end_define

begin_comment
comment|/* file in this slot deleted */
end_comment

begin_define
define|#
directive|define
name|ATTR_NORMAL
value|0x00
end_define

begin_comment
comment|/* normal file */
end_comment

begin_define
define|#
directive|define
name|ATTR_READONLY
value|0x01
end_define

begin_comment
comment|/* file is readonly */
end_comment

begin_define
define|#
directive|define
name|ATTR_HIDDEN
value|0x02
end_define

begin_comment
comment|/* file is hidden */
end_comment

begin_define
define|#
directive|define
name|ATTR_SYSTEM
value|0x04
end_define

begin_comment
comment|/* file is a system file */
end_comment

begin_define
define|#
directive|define
name|ATTR_VOLUME
value|0x08
end_define

begin_comment
comment|/* entry is a volume label */
end_comment

begin_define
define|#
directive|define
name|ATTR_DIRECTORY
value|0x10
end_define

begin_comment
comment|/* entry is a directory name */
end_comment

begin_define
define|#
directive|define
name|ATTR_ARCHIVE
value|0x20
end_define

begin_comment
comment|/* file is new or modified */
end_comment

begin_define
define|#
directive|define
name|ATTR_WIN95
value|0x0f
end_define

begin_comment
comment|/* long name record */
end_comment

begin_comment
comment|/*  * This is the format of the contents of the deTime field in the direntry  * structure.  * We don't use bitfields because we don't know how compilers for  * arbitrary machines will lay them out.  */
end_comment

begin_define
define|#
directive|define
name|DT_2SECONDS_MASK
value|0x1F
end_define

begin_comment
comment|/* seconds divided by 2 */
end_comment

begin_define
define|#
directive|define
name|DT_2SECONDS_SHIFT
value|0
end_define

begin_define
define|#
directive|define
name|DT_MINUTES_MASK
value|0x7E0
end_define

begin_comment
comment|/* minutes */
end_comment

begin_define
define|#
directive|define
name|DT_MINUTES_SHIFT
value|5
end_define

begin_define
define|#
directive|define
name|DT_HOURS_MASK
value|0xF800
end_define

begin_comment
comment|/* hours */
end_comment

begin_define
define|#
directive|define
name|DT_HOURS_SHIFT
value|11
end_define

begin_comment
comment|/*  * This is the format of the contents of the deDate field in the direntry  * structure.  */
end_comment

begin_define
define|#
directive|define
name|DD_DAY_MASK
value|0x1F
end_define

begin_comment
comment|/* day of month */
end_comment

begin_define
define|#
directive|define
name|DD_DAY_SHIFT
value|0
end_define

begin_define
define|#
directive|define
name|DD_MONTH_MASK
value|0x1E0
end_define

begin_comment
comment|/* month */
end_comment

begin_define
define|#
directive|define
name|DD_MONTH_SHIFT
value|5
end_define

begin_define
define|#
directive|define
name|DD_YEAR_MASK
value|0xFE00
end_define

begin_comment
comment|/* year - 1980 */
end_comment

begin_define
define|#
directive|define
name|DD_YEAR_SHIFT
value|9
end_define

begin_comment
comment|/* dir.c */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dosDirEntry
modifier|*
name|newDosDirEntry
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|freeDosDirEntry
name|__P
argument_list|(
operator|(
expr|struct
name|dosDirEntry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dirTodoNode
modifier|*
name|newDirTodo
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|freeDirTodo
name|__P
argument_list|(
operator|(
expr|struct
name|dirTodoNode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fullpath
name|__P
argument_list|(
operator|(
expr|struct
name|dosDirEntry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|calcShortSum
name|__P
argument_list|(
operator|(
name|u_char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|delete
name|__P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|bootblock
operator|*
operator|,
expr|struct
name|fatEntry
operator|*
operator|,
name|cl_t
operator|,
name|int
operator|,
name|cl_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|removede
name|__P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|bootblock
operator|*
operator|,
expr|struct
name|fatEntry
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_char
operator|*
operator|,
name|cl_t
operator|,
name|cl_t
operator|,
name|cl_t
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|checksize
name|__P
argument_list|(
operator|(
expr|struct
name|bootblock
operator|*
operator|,
expr|struct
name|fatEntry
operator|*
operator|,
name|u_char
operator|*
operator|,
expr|struct
name|dosDirEntry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readDosDirSection
name|__P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|bootblock
operator|*
operator|,
expr|struct
name|fatEntry
operator|*
operator|,
expr|struct
name|dosDirEntry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Manage free dosDirEntry structures.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dosDirEntry
modifier|*
name|freede
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|dosDirEntry
modifier|*
name|newDosDirEntry
parameter_list|()
block|{
name|struct
name|dosDirEntry
modifier|*
name|de
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|de
operator|=
name|freede
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|de
operator|=
operator|(
expr|struct
name|dosDirEntry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|de
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
else|else
name|freede
operator|=
name|de
operator|->
name|next
expr_stmt|;
return|return
name|de
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|freeDosDirEntry
parameter_list|(
name|de
parameter_list|)
name|struct
name|dosDirEntry
modifier|*
name|de
decl_stmt|;
block|{
name|de
operator|->
name|next
operator|=
name|freede
expr_stmt|;
name|freede
operator|=
name|de
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The same for dirTodoNode structures.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dirTodoNode
modifier|*
name|freedt
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|dirTodoNode
modifier|*
name|newDirTodo
parameter_list|()
block|{
name|struct
name|dirTodoNode
modifier|*
name|dt
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dt
operator|=
name|freedt
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dt
operator|=
operator|(
expr|struct
name|dirTodoNode
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|dt
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
else|else
name|freedt
operator|=
name|dt
operator|->
name|next
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|freeDirTodo
parameter_list|(
name|dt
parameter_list|)
name|struct
name|dirTodoNode
modifier|*
name|dt
decl_stmt|;
block|{
name|dt
operator|->
name|next
operator|=
name|freedt
expr_stmt|;
name|freedt
operator|=
name|dt
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The stack of unread directories  */
end_comment

begin_decl_stmt
name|struct
name|dirTodoNode
modifier|*
name|pendingDirectories
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return the full pathname for a directory entry.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fullpath
parameter_list|(
name|dir
parameter_list|)
name|struct
name|dosDirEntry
modifier|*
name|dir
decl_stmt|;
block|{
specifier|static
name|char
name|namebuf
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|int
name|nl
decl_stmt|;
name|cp
operator|=
name|namebuf
operator|+
sizeof|sizeof
name|namebuf
operator|-
literal|1
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
name|np
operator|=
name|dir
operator|->
name|lname
index|[
literal|0
index|]
condition|?
name|dir
operator|->
name|lname
else|:
name|dir
operator|->
name|name
expr_stmt|;
name|nl
operator|=
name|strlen
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|-=
name|nl
operator|)
operator|<=
name|namebuf
operator|+
literal|1
condition|)
break|break;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|np
argument_list|,
name|nl
argument_list|)
expr_stmt|;
operator|*
operator|--
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|dir
operator|=
name|dir
operator|->
name|parent
operator|)
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|dir
condition|)
operator|*
operator|--
name|cp
operator|=
literal|'?'
expr_stmt|;
else|else
name|cp
operator|++
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate a checksum over an 8.3 alias name  */
end_comment

begin_function
specifier|static
name|u_char
name|calcShortSum
parameter_list|(
name|p
parameter_list|)
name|u_char
modifier|*
name|p
decl_stmt|;
block|{
name|u_char
name|sum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|11
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|=
operator|(
name|sum
operator|<<
literal|7
operator|)
operator||
operator|(
name|sum
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* rotate right */
name|sum
operator|+=
name|p
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function

begin_comment
comment|/*  * Global variables temporarily used during a directory scan  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|longName
index|[
name|DOSLONGNAMELEN
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|buffer
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|delbuf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dosDirEntry
modifier|*
name|rootDir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dosDirEntry
modifier|*
name|lostDir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Init internal state for a new directory scan.  */
end_comment

begin_function
name|int
name|resetDosDirSection
parameter_list|(
name|boot
parameter_list|,
name|fat
parameter_list|)
name|struct
name|bootblock
modifier|*
name|boot
decl_stmt|;
name|struct
name|fatEntry
modifier|*
name|fat
decl_stmt|;
block|{
name|int
name|b1
decl_stmt|,
name|b2
decl_stmt|;
name|cl_t
name|cl
decl_stmt|;
name|int
name|ret
init|=
name|FSOK
decl_stmt|;
name|b1
operator|=
name|boot
operator|->
name|RootDirEnts
operator|*
literal|32
expr_stmt|;
name|b2
operator|=
name|boot
operator|->
name|SecPerClust
operator|*
name|boot
operator|->
name|BytesPerSec
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|buffer
operator|=
name|malloc
argument_list|(
name|b1
operator|>
name|b2
condition|?
name|b1
else|:
name|b2
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|delbuf
operator|=
name|malloc
argument_list|(
name|b2
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|rootDir
operator|=
name|newDosDirEntry
argument_list|()
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"No space for directory"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
name|memset
argument_list|(
name|rootDir
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|rootDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|boot
operator|->
name|flags
operator|&
name|FAT32
condition|)
block|{
if|if
condition|(
name|boot
operator|->
name|RootCl
operator|<
name|CLUST_FIRST
operator|||
name|boot
operator|->
name|RootCl
operator|>=
name|boot
operator|->
name|NumClusters
condition|)
block|{
name|pfatal
argument_list|(
literal|"Root directory starts with cluster out of range(%u)"
argument_list|,
name|boot
operator|->
name|RootCl
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
name|cl
operator|=
name|fat
index|[
name|boot
operator|->
name|RootCl
index|]
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|cl
operator|<
name|CLUST_FIRST
operator|||
operator|(
name|cl
operator|>=
name|CLUST_RSRVD
operator|&&
name|cl
operator|<
name|CLUST_EOFS
operator|)
operator|||
name|fat
index|[
name|boot
operator|->
name|RootCl
index|]
operator|.
name|head
operator|!=
name|boot
operator|->
name|RootCl
condition|)
block|{
if|if
condition|(
name|cl
operator|==
name|CLUST_FREE
condition|)
name|pwarn
argument_list|(
literal|"Root directory starts with free cluster\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cl
operator|>=
name|CLUST_RSRVD
condition|)
name|pwarn
argument_list|(
literal|"Root directory starts with cluster marked %s\n"
argument_list|,
name|rsrvdcltype
argument_list|(
name|cl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|pfatal
argument_list|(
literal|"Root directory doesn't start a cluster chain"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
if|if
condition|(
name|ask
argument_list|(
literal|1
argument_list|,
literal|"Fix"
argument_list|)
condition|)
block|{
name|fat
index|[
name|boot
operator|->
name|RootCl
index|]
operator|.
name|next
operator|=
name|CLUST_FREE
expr_stmt|;
name|ret
operator|=
name|FSFATMOD
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|FSFATAL
expr_stmt|;
block|}
name|fat
index|[
name|boot
operator|->
name|RootCl
index|]
operator|.
name|flags
operator||=
name|FAT_USED
expr_stmt|;
name|rootDir
operator|->
name|head
operator|=
name|boot
operator|->
name|RootCl
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Cleanup after a directory scan  */
end_comment

begin_function
name|void
name|finishDosDirSection
parameter_list|()
block|{
name|struct
name|dirTodoNode
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|dosDirEntry
modifier|*
name|d
decl_stmt|,
modifier|*
name|nd
decl_stmt|;
for|for
control|(
name|p
operator|=
name|pendingDirectories
init|;
name|p
condition|;
name|p
operator|=
name|np
control|)
block|{
name|np
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|freeDirTodo
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|pendingDirectories
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|d
operator|=
name|rootDir
init|;
name|d
condition|;
name|d
operator|=
name|nd
control|)
block|{
if|if
condition|(
operator|(
name|nd
operator|=
name|d
operator|->
name|child
operator|)
operator|!=
name|NULL
condition|)
block|{
name|d
operator|->
name|child
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|nd
operator|=
name|d
operator|->
name|next
operator|)
condition|)
name|nd
operator|=
name|d
operator|->
name|parent
expr_stmt|;
name|freeDosDirEntry
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|rootDir
operator|=
name|lostDir
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|delbuf
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|NULL
expr_stmt|;
name|delbuf
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delete directory entries between startcl, startoff and endcl, endoff.  */
end_comment

begin_function
specifier|static
name|int
name|delete
parameter_list|(
name|f
parameter_list|,
name|boot
parameter_list|,
name|fat
parameter_list|,
name|startcl
parameter_list|,
name|startoff
parameter_list|,
name|endcl
parameter_list|,
name|endoff
parameter_list|,
name|notlast
parameter_list|)
name|int
name|f
decl_stmt|;
name|struct
name|bootblock
modifier|*
name|boot
decl_stmt|;
name|struct
name|fatEntry
modifier|*
name|fat
decl_stmt|;
name|cl_t
name|startcl
decl_stmt|;
name|int
name|startoff
decl_stmt|;
name|cl_t
name|endcl
decl_stmt|;
name|int
name|endoff
decl_stmt|;
name|int
name|notlast
decl_stmt|;
block|{
name|u_char
modifier|*
name|s
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|int
name|clsz
init|=
name|boot
operator|->
name|SecPerClust
operator|*
name|boot
operator|->
name|BytesPerSec
decl_stmt|;
name|s
operator|=
name|delbuf
operator|+
name|startoff
expr_stmt|;
name|e
operator|=
name|delbuf
operator|+
name|clsz
expr_stmt|;
while|while
condition|(
name|startcl
operator|>=
name|CLUST_FIRST
operator|&&
name|startcl
operator|<
name|boot
operator|->
name|NumClusters
condition|)
block|{
if|if
condition|(
name|startcl
operator|==
name|endcl
condition|)
block|{
if|if
condition|(
name|notlast
condition|)
break|break;
name|e
operator|=
name|delbuf
operator|+
name|endoff
expr_stmt|;
block|}
name|off
operator|=
name|startcl
operator|*
name|boot
operator|->
name|SecPerClust
operator|+
name|boot
operator|->
name|ClusterOffset
expr_stmt|;
name|off
operator|*=
name|boot
operator|->
name|BytesPerSec
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|f
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|off
operator|||
name|read
argument_list|(
name|f
argument_list|,
name|delbuf
argument_list|,
name|clsz
argument_list|)
operator|!=
name|clsz
condition|)
block|{
name|perror
argument_list|(
literal|"Unable to read directory"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
while|while
condition|(
name|s
operator|<
name|e
condition|)
block|{
operator|*
name|s
operator|=
name|SLOT_DELETED
expr_stmt|;
name|s
operator|+=
literal|32
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|f
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|off
operator|||
name|write
argument_list|(
name|f
argument_list|,
name|delbuf
argument_list|,
name|clsz
argument_list|)
operator|!=
name|clsz
condition|)
block|{
name|perror
argument_list|(
literal|"Unable to write directory"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
if|if
condition|(
name|startcl
operator|==
name|endcl
condition|)
break|break;
name|startcl
operator|=
name|fat
index|[
name|startcl
index|]
operator|.
name|next
expr_stmt|;
name|s
operator|=
name|delbuf
expr_stmt|;
block|}
return|return
name|FSOK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|removede
parameter_list|(
name|f
parameter_list|,
name|boot
parameter_list|,
name|fat
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|startcl
parameter_list|,
name|endcl
parameter_list|,
name|curcl
parameter_list|,
name|path
parameter_list|,
name|type
parameter_list|)
name|int
name|f
decl_stmt|;
name|struct
name|bootblock
modifier|*
name|boot
decl_stmt|;
name|struct
name|fatEntry
modifier|*
name|fat
decl_stmt|;
name|u_char
modifier|*
name|start
decl_stmt|;
name|u_char
modifier|*
name|end
decl_stmt|;
name|cl_t
name|startcl
decl_stmt|;
name|cl_t
name|endcl
decl_stmt|;
name|cl_t
name|curcl
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0
case|:
name|pwarn
argument_list|(
literal|"Invalid long filename entry for %s\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|pwarn
argument_list|(
literal|"Invalid long filename entry at end of directory %s\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pwarn
argument_list|(
literal|"Invalid long filename entry for volume label\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ask
argument_list|(
literal|0
argument_list|,
literal|"Remove"
argument_list|)
condition|)
block|{
if|if
condition|(
name|startcl
operator|!=
name|curcl
condition|)
block|{
if|if
condition|(
name|delete
argument_list|(
name|f
argument_list|,
name|boot
argument_list|,
name|fat
argument_list|,
name|startcl
argument_list|,
name|start
operator|-
name|buffer
argument_list|,
name|endcl
argument_list|,
name|end
operator|-
name|buffer
argument_list|,
name|endcl
operator|==
name|curcl
argument_list|)
operator|==
name|FSFATAL
condition|)
return|return
name|FSFATAL
return|;
name|start
operator|=
name|buffer
expr_stmt|;
block|}
if|if
condition|(
name|endcl
operator|==
name|curcl
condition|)
for|for
control|(
init|;
name|start
operator|<
name|end
condition|;
name|start
operator|+=
literal|32
control|)
operator|*
name|start
operator|=
name|SLOT_DELETED
expr_stmt|;
return|return
name|FSDIRMOD
return|;
block|}
return|return
name|FSERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Check an in-memory file entry  */
end_comment

begin_function
specifier|static
name|int
name|checksize
parameter_list|(
name|boot
parameter_list|,
name|fat
parameter_list|,
name|p
parameter_list|,
name|dir
parameter_list|)
name|struct
name|bootblock
modifier|*
name|boot
decl_stmt|;
name|struct
name|fatEntry
modifier|*
name|fat
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|struct
name|dosDirEntry
modifier|*
name|dir
decl_stmt|;
block|{
comment|/* 	 * Check size on ordinary files 	 */
name|int32_t
name|physicalSize
decl_stmt|;
if|if
condition|(
name|dir
operator|->
name|head
operator|==
name|CLUST_FREE
condition|)
name|physicalSize
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dir
operator|->
name|head
operator|<
name|CLUST_FIRST
operator|||
name|dir
operator|->
name|head
operator|>=
name|boot
operator|->
name|NumClusters
condition|)
return|return
name|FSERROR
return|;
name|physicalSize
operator|=
name|fat
index|[
name|dir
operator|->
name|head
index|]
operator|.
name|length
operator|*
name|boot
operator|->
name|ClusterSize
expr_stmt|;
block|}
if|if
condition|(
name|physicalSize
operator|<
name|dir
operator|->
name|size
condition|)
block|{
name|pwarn
argument_list|(
literal|"size of %s is %u, should at most be %u\n"
argument_list|,
name|fullpath
argument_list|(
name|dir
argument_list|)
argument_list|,
name|dir
operator|->
name|size
argument_list|,
name|physicalSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|1
argument_list|,
literal|"Truncate"
argument_list|)
condition|)
block|{
name|dir
operator|->
name|size
operator|=
name|physicalSize
expr_stmt|;
name|p
index|[
literal|28
index|]
operator|=
operator|(
name|u_char
operator|)
name|physicalSize
expr_stmt|;
name|p
index|[
literal|29
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|physicalSize
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|p
index|[
literal|30
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|physicalSize
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|p
index|[
literal|31
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|physicalSize
operator|>>
literal|24
argument_list|)
expr_stmt|;
return|return
name|FSDIRMOD
return|;
block|}
else|else
return|return
name|FSERROR
return|;
block|}
elseif|else
if|if
condition|(
name|physicalSize
operator|-
name|dir
operator|->
name|size
operator|>=
name|boot
operator|->
name|ClusterSize
condition|)
block|{
name|pwarn
argument_list|(
literal|"%s has too many clusters allocated\n"
argument_list|,
name|fullpath
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|1
argument_list|,
literal|"Drop superfluous clusters"
argument_list|)
condition|)
block|{
name|cl_t
name|cl
decl_stmt|;
name|u_int32_t
name|sz
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cl
operator|=
name|dir
operator|->
name|head
init|;
operator|(
name|sz
operator|+=
name|boot
operator|->
name|ClusterSize
operator|)
operator|<
name|dir
operator|->
name|size
condition|;
control|)
name|cl
operator|=
name|fat
index|[
name|cl
index|]
operator|.
name|next
expr_stmt|;
name|clearchain
argument_list|(
name|boot
argument_list|,
name|fat
argument_list|,
name|fat
index|[
name|cl
index|]
operator|.
name|next
argument_list|)
expr_stmt|;
name|fat
index|[
name|cl
index|]
operator|.
name|next
operator|=
name|CLUST_EOF
expr_stmt|;
return|return
name|FSFATMOD
return|;
block|}
else|else
return|return
name|FSERROR
return|;
block|}
return|return
name|FSOK
return|;
block|}
end_function

begin_comment
comment|/*  * Read a directory and  *   - resolve long name records  *   - enter file and directory records into the parent's list  *   - push directories onto the todo-stack  */
end_comment

begin_function
specifier|static
name|int
name|readDosDirSection
parameter_list|(
name|f
parameter_list|,
name|boot
parameter_list|,
name|fat
parameter_list|,
name|dir
parameter_list|)
name|int
name|f
decl_stmt|;
name|struct
name|bootblock
modifier|*
name|boot
decl_stmt|;
name|struct
name|fatEntry
modifier|*
name|fat
decl_stmt|;
name|struct
name|dosDirEntry
modifier|*
name|dir
decl_stmt|;
block|{
name|struct
name|dosDirEntry
name|dirent
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|,
modifier|*
name|vallfn
decl_stmt|,
modifier|*
name|invlfn
decl_stmt|,
modifier|*
name|empty
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|last
decl_stmt|;
name|cl_t
name|cl
decl_stmt|,
name|valcl
init|=
operator|~
literal|0
decl_stmt|,
name|invcl
init|=
operator|~
literal|0
decl_stmt|,
name|empcl
init|=
operator|~
literal|0
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|u_int
name|lidx
init|=
literal|0
decl_stmt|;
name|int
name|shortSum
decl_stmt|;
name|int
name|mod
init|=
name|FSOK
decl_stmt|;
define|#
directive|define
name|THISMOD
value|0x8000
comment|/* Only used within this routine */
name|cl
operator|=
name|dir
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|parent
operator|&&
operator|(
name|cl
operator|<
name|CLUST_FIRST
operator|||
name|cl
operator|>=
name|boot
operator|->
name|NumClusters
operator|)
condition|)
block|{
comment|/* 		 * Already handled somewhere else. 		 */
return|return
name|FSOK
return|;
block|}
name|shortSum
operator|=
operator|-
literal|1
expr_stmt|;
name|vallfn
operator|=
name|invlfn
operator|=
name|empty
operator|=
name|NULL
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|boot
operator|->
name|flags
operator|&
name|FAT32
operator|)
operator|&&
operator|!
name|dir
operator|->
name|parent
condition|)
block|{
name|last
operator|=
name|boot
operator|->
name|RootDirEnts
operator|*
literal|32
expr_stmt|;
name|off
operator|=
name|boot
operator|->
name|ResSectors
operator|+
name|boot
operator|->
name|FATs
operator|*
name|boot
operator|->
name|FATsecs
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|boot
operator|->
name|SecPerClust
operator|*
name|boot
operator|->
name|BytesPerSec
expr_stmt|;
name|off
operator|=
name|cl
operator|*
name|boot
operator|->
name|SecPerClust
operator|+
name|boot
operator|->
name|ClusterOffset
expr_stmt|;
block|}
name|off
operator|*=
name|boot
operator|->
name|BytesPerSec
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|f
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|off
operator|||
name|read
argument_list|(
name|f
argument_list|,
name|buffer
argument_list|,
name|last
argument_list|)
operator|!=
name|last
condition|)
block|{
name|perror
argument_list|(
literal|"Unable to read directory"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
name|last
operator|/=
literal|32
expr_stmt|;
comment|/* 		 * Check `.' and `..' entries here?			XXX 		 */
for|for
control|(
name|p
operator|=
name|buffer
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|32
control|)
block|{
if|if
condition|(
name|dir
operator|->
name|fsckflags
operator|&
name|DIREMPWARN
condition|)
block|{
operator|*
name|p
operator|=
name|SLOT_EMPTY
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|p
operator|==
name|SLOT_EMPTY
operator|||
operator|*
name|p
operator|==
name|SLOT_DELETED
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|SLOT_EMPTY
condition|)
block|{
name|dir
operator|->
name|fsckflags
operator||=
name|DIREMPTY
expr_stmt|;
name|empty
operator|=
name|p
expr_stmt|;
name|empcl
operator|=
name|cl
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|dir
operator|->
name|fsckflags
operator|&
name|DIREMPTY
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dir
operator|->
name|fsckflags
operator|&
name|DIREMPWARN
operator|)
condition|)
block|{
name|pwarn
argument_list|(
literal|"%s has entries after end of directory\n"
argument_list|,
name|fullpath
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|1
argument_list|,
literal|"Extend"
argument_list|)
condition|)
block|{
name|u_char
modifier|*
name|q
decl_stmt|;
name|dir
operator|->
name|fsckflags
operator|&=
operator|~
name|DIREMPTY
expr_stmt|;
if|if
condition|(
name|delete
argument_list|(
name|f
argument_list|,
name|boot
argument_list|,
name|fat
argument_list|,
name|empcl
argument_list|,
name|empty
operator|-
name|buffer
argument_list|,
name|cl
argument_list|,
name|p
operator|-
name|buffer
argument_list|,
literal|1
argument_list|)
operator|==
name|FSFATAL
condition|)
return|return
name|FSFATAL
return|;
name|q
operator|=
name|empcl
operator|==
name|cl
condition|?
name|empty
else|:
name|buffer
expr_stmt|;
for|for
control|(
init|;
name|q
operator|<
name|p
condition|;
name|q
operator|+=
literal|32
control|)
operator|*
name|q
operator|=
name|SLOT_DELETED
expr_stmt|;
name|mod
operator||=
name|THISMOD
operator||
name|FSDIRMOD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ask
argument_list|(
literal|0
argument_list|,
literal|"Truncate"
argument_list|)
condition|)
name|dir
operator|->
name|fsckflags
operator||=
name|DIREMPWARN
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|->
name|fsckflags
operator|&
name|DIREMPWARN
condition|)
block|{
operator|*
name|p
operator|=
name|SLOT_DELETED
expr_stmt|;
name|mod
operator||=
name|THISMOD
operator||
name|FSDIRMOD
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|dir
operator|->
name|fsckflags
operator|&
name|DIREMPTY
condition|)
name|mod
operator||=
name|FSERROR
expr_stmt|;
name|empty
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|11
index|]
operator|==
name|ATTR_WIN95
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|&
name|LRFIRST
condition|)
block|{
if|if
condition|(
name|shortSum
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|invlfn
condition|)
block|{
name|invlfn
operator|=
name|vallfn
expr_stmt|;
name|invcl
operator|=
name|valcl
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
name|longName
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|longName
argument_list|)
expr_stmt|;
name|shortSum
operator|=
name|p
index|[
literal|13
index|]
expr_stmt|;
name|vallfn
operator|=
name|p
expr_stmt|;
name|valcl
operator|=
name|cl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shortSum
operator|!=
name|p
index|[
literal|13
index|]
operator|||
name|lidx
operator|!=
operator|(
operator|*
name|p
operator|&
name|LRNOMASK
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|invlfn
condition|)
block|{
name|invlfn
operator|=
name|vallfn
expr_stmt|;
name|invcl
operator|=
name|valcl
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|invlfn
condition|)
block|{
name|invlfn
operator|=
name|p
expr_stmt|;
name|invcl
operator|=
name|cl
expr_stmt|;
block|}
name|vallfn
operator|=
name|NULL
expr_stmt|;
block|}
name|lidx
operator|=
operator|*
name|p
operator|&
name|LRNOMASK
expr_stmt|;
name|t
operator|=
name|longName
operator|+
operator|--
name|lidx
operator|*
literal|13
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
literal|11
operator|&&
name|t
operator|<
name|longName
operator|+
sizeof|sizeof
argument_list|(
name|longName
argument_list|)
condition|;
name|k
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|!
name|p
index|[
name|k
index|]
operator|&&
operator|!
name|p
index|[
name|k
operator|+
literal|1
index|]
condition|)
break|break;
operator|*
name|t
operator|++
operator|=
name|p
index|[
name|k
index|]
expr_stmt|;
comment|/* 					 * Warn about those unusable chars in msdosfs here?	XXX 					 */
if|if
condition|(
name|p
index|[
name|k
operator|+
literal|1
index|]
condition|)
name|t
index|[
operator|-
literal|1
index|]
operator|=
literal|'?'
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|>=
literal|11
condition|)
for|for
control|(
name|k
operator|=
literal|14
init|;
name|k
operator|<
literal|26
operator|&&
name|t
operator|<
name|longName
operator|+
sizeof|sizeof
argument_list|(
name|longName
argument_list|)
condition|;
name|k
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|!
name|p
index|[
name|k
index|]
operator|&&
operator|!
name|p
index|[
name|k
operator|+
literal|1
index|]
condition|)
break|break;
operator|*
name|t
operator|++
operator|=
name|p
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|p
index|[
name|k
operator|+
literal|1
index|]
condition|)
name|t
index|[
operator|-
literal|1
index|]
operator|=
literal|'?'
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|>=
literal|26
condition|)
for|for
control|(
name|k
operator|=
literal|28
init|;
name|k
operator|<
literal|32
operator|&&
name|t
operator|<
name|longName
operator|+
sizeof|sizeof
argument_list|(
name|longName
argument_list|)
condition|;
name|k
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|!
name|p
index|[
name|k
index|]
operator|&&
operator|!
name|p
index|[
name|k
operator|+
literal|1
index|]
condition|)
break|break;
operator|*
name|t
operator|++
operator|=
name|p
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|p
index|[
name|k
operator|+
literal|1
index|]
condition|)
name|t
index|[
operator|-
literal|1
index|]
operator|=
literal|'?'
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|>=
name|longName
operator|+
sizeof|sizeof
argument_list|(
name|longName
argument_list|)
condition|)
block|{
name|pwarn
argument_list|(
literal|"long filename too long\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|invlfn
condition|)
block|{
name|invlfn
operator|=
name|vallfn
expr_stmt|;
name|invcl
operator|=
name|valcl
expr_stmt|;
block|}
name|vallfn
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|26
index|]
operator||
operator|(
name|p
index|[
literal|27
index|]
operator|<<
literal|8
operator|)
condition|)
block|{
name|pwarn
argument_list|(
literal|"long filename record cluster start != 0\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|invlfn
condition|)
block|{
name|invlfn
operator|=
name|vallfn
expr_stmt|;
name|invcl
operator|=
name|cl
expr_stmt|;
block|}
name|vallfn
operator|=
name|NULL
expr_stmt|;
block|}
continue|continue;
comment|/* long records don't carry further 						 * information */
block|}
comment|/* 			 * This is a standard msdosfs directory entry. 			 */
name|memset
argument_list|(
operator|&
name|dirent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|dirent
argument_list|)
expr_stmt|;
comment|/* 			 * it's a short name record, but we need to know 			 * more, so get the flags first. 			 */
name|dirent
operator|.
name|flags
operator|=
name|p
index|[
literal|11
index|]
expr_stmt|;
comment|/* 			 * Translate from 850 to ISO here		XXX 			 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|dirent
operator|.
name|name
index|[
name|j
index|]
operator|=
name|p
index|[
name|j
index|]
expr_stmt|;
name|dirent
operator|.
name|name
index|[
literal|8
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|7
init|;
name|k
operator|>=
literal|0
operator|&&
name|dirent
operator|.
name|name
index|[
name|k
index|]
operator|==
literal|' '
condition|;
name|k
operator|--
control|)
name|dirent
operator|.
name|name
index|[
name|k
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dirent
operator|.
name|name
index|[
name|k
index|]
operator|!=
literal|'\0'
condition|)
name|k
operator|++
expr_stmt|;
if|if
condition|(
name|dirent
operator|.
name|name
index|[
literal|0
index|]
operator|==
name|SLOT_E5
condition|)
name|dirent
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|0xe5
expr_stmt|;
if|if
condition|(
name|dirent
operator|.
name|flags
operator|&
name|ATTR_VOLUME
condition|)
block|{
if|if
condition|(
name|vallfn
operator|||
name|invlfn
condition|)
block|{
name|mod
operator||=
name|removede
argument_list|(
name|f
argument_list|,
name|boot
argument_list|,
name|fat
argument_list|,
name|invlfn
condition|?
name|invlfn
else|:
name|vallfn
argument_list|,
name|p
argument_list|,
name|invlfn
condition|?
name|invcl
else|:
name|valcl
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|fullpath
argument_list|(
name|dir
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|vallfn
operator|=
name|NULL
expr_stmt|;
name|invlfn
operator|=
name|NULL
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|p
index|[
literal|8
index|]
operator|!=
literal|' '
condition|)
name|dirent
operator|.
name|name
index|[
name|k
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
name|dirent
operator|.
name|name
index|[
name|k
operator|++
index|]
operator|=
name|p
index|[
name|j
operator|+
literal|8
index|]
expr_stmt|;
name|dirent
operator|.
name|name
index|[
name|k
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|k
operator|--
init|;
name|k
operator|>=
literal|0
operator|&&
name|dirent
operator|.
name|name
index|[
name|k
index|]
operator|==
literal|' '
condition|;
name|k
operator|--
control|)
name|dirent
operator|.
name|name
index|[
name|k
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|vallfn
operator|&&
name|shortSum
operator|!=
name|calcShortSum
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|invlfn
condition|)
block|{
name|invlfn
operator|=
name|vallfn
expr_stmt|;
name|invcl
operator|=
name|valcl
expr_stmt|;
block|}
name|vallfn
operator|=
name|NULL
expr_stmt|;
block|}
name|dirent
operator|.
name|head
operator|=
name|p
index|[
literal|26
index|]
operator||
operator|(
name|p
index|[
literal|27
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|boot
operator|->
name|ClustMask
operator|==
name|CLUST32_MASK
condition|)
name|dirent
operator|.
name|head
operator||=
operator|(
name|p
index|[
literal|20
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
index|[
literal|21
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|dirent
operator|.
name|size
operator|=
name|p
index|[
literal|28
index|]
operator||
operator|(
name|p
index|[
literal|29
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|p
index|[
literal|30
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
index|[
literal|31
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
if|if
condition|(
name|vallfn
condition|)
block|{
name|strcpy
argument_list|(
name|dirent
operator|.
name|lname
argument_list|,
name|longName
argument_list|)
expr_stmt|;
name|longName
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|shortSum
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|dirent
operator|.
name|parent
operator|=
name|dir
expr_stmt|;
name|dirent
operator|.
name|next
operator|=
name|dir
operator|->
name|child
expr_stmt|;
if|if
condition|(
name|invlfn
condition|)
block|{
name|mod
operator||=
name|k
operator|=
name|removede
argument_list|(
name|f
argument_list|,
name|boot
argument_list|,
name|fat
argument_list|,
name|invlfn
argument_list|,
name|vallfn
condition|?
name|vallfn
else|:
name|p
argument_list|,
name|invcl
argument_list|,
name|vallfn
condition|?
name|valcl
else|:
name|cl
argument_list|,
name|cl
argument_list|,
name|fullpath
argument_list|(
operator|&
name|dirent
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod
operator|&
name|FSFATAL
condition|)
return|return
name|FSFATAL
return|;
if|if
condition|(
name|vallfn
condition|?
operator|(
name|valcl
operator|==
name|cl
operator|&&
name|vallfn
operator|!=
name|buffer
operator|)
else|:
name|p
operator|!=
name|buffer
condition|)
if|if
condition|(
name|k
operator|&
name|FSDIRMOD
condition|)
name|mod
operator||=
name|THISMOD
expr_stmt|;
block|}
name|vallfn
operator|=
name|NULL
expr_stmt|;
comment|/* not used any longer */
name|invlfn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dirent
operator|.
name|size
operator|==
literal|0
operator|&&
operator|!
operator|(
name|dirent
operator|.
name|flags
operator|&
name|ATTR_DIRECTORY
operator|)
condition|)
block|{
if|if
condition|(
name|dirent
operator|.
name|head
operator|!=
literal|0
condition|)
block|{
name|pwarn
argument_list|(
literal|"%s has clusters, but size 0\n"
argument_list|,
name|fullpath
argument_list|(
operator|&
name|dirent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|1
argument_list|,
literal|"Drop allocated clusters"
argument_list|)
condition|)
block|{
name|p
index|[
literal|26
index|]
operator|=
name|p
index|[
literal|27
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|boot
operator|->
name|ClustMask
operator|==
name|CLUST32_MASK
condition|)
name|p
index|[
literal|20
index|]
operator|=
name|p
index|[
literal|21
index|]
operator|=
literal|0
expr_stmt|;
name|clearchain
argument_list|(
name|boot
argument_list|,
name|fat
argument_list|,
name|dirent
operator|.
name|head
argument_list|)
expr_stmt|;
name|dirent
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|mod
operator||=
name|THISMOD
operator||
name|FSDIRMOD
operator||
name|FSFATMOD
expr_stmt|;
block|}
else|else
name|mod
operator||=
name|FSERROR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dirent
operator|.
name|head
operator|==
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|dirent
operator|.
name|name
argument_list|,
literal|".."
argument_list|)
operator|&&
name|dir
operator|->
name|parent
comment|/* XXX */
operator|&&
operator|!
name|dir
operator|->
name|parent
operator|->
name|parent
condition|)
block|{
comment|/* 				 *  Do nothing, the parent is the root 				 */
block|}
elseif|else
if|if
condition|(
name|dirent
operator|.
name|head
operator|<
name|CLUST_FIRST
operator|||
name|dirent
operator|.
name|head
operator|>=
name|boot
operator|->
name|NumClusters
operator|||
name|fat
index|[
name|dirent
operator|.
name|head
index|]
operator|.
name|next
operator|==
name|CLUST_FREE
operator|||
operator|(
name|fat
index|[
name|dirent
operator|.
name|head
index|]
operator|.
name|next
operator|>=
name|CLUST_RSRVD
operator|&&
name|fat
index|[
name|dirent
operator|.
name|head
index|]
operator|.
name|next
operator|<
name|CLUST_EOFS
operator|)
operator|||
name|fat
index|[
name|dirent
operator|.
name|head
index|]
operator|.
name|head
operator|!=
name|dirent
operator|.
name|head
condition|)
block|{
if|if
condition|(
name|dirent
operator|.
name|head
operator|==
literal|0
condition|)
name|pwarn
argument_list|(
literal|"%s has no clusters\n"
argument_list|,
name|fullpath
argument_list|(
operator|&
name|dirent
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dirent
operator|.
name|head
operator|<
name|CLUST_FIRST
operator|||
name|dirent
operator|.
name|head
operator|>=
name|boot
operator|->
name|NumClusters
condition|)
name|pwarn
argument_list|(
literal|"%s starts with cluster out of range(%u)\n"
argument_list|,
name|fullpath
argument_list|(
operator|&
name|dirent
argument_list|)
argument_list|,
name|dirent
operator|.
name|head
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fat
index|[
name|dirent
operator|.
name|head
index|]
operator|.
name|next
operator|==
name|CLUST_FREE
condition|)
name|pwarn
argument_list|(
literal|"%s starts with free cluster\n"
argument_list|,
name|fullpath
argument_list|(
operator|&
name|dirent
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fat
index|[
name|dirent
operator|.
name|head
index|]
operator|.
name|next
operator|>=
name|CLUST_RSRVD
condition|)
name|pwarn
argument_list|(
literal|"%s starts with cluster marked %s\n"
argument_list|,
name|fullpath
argument_list|(
operator|&
name|dirent
argument_list|)
argument_list|,
name|rsrvdcltype
argument_list|(
name|fat
index|[
name|dirent
operator|.
name|head
index|]
operator|.
name|next
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pwarn
argument_list|(
literal|"%s doesn't start a cluster chain\n"
argument_list|,
name|fullpath
argument_list|(
operator|&
name|dirent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent
operator|.
name|flags
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
if|if
condition|(
name|ask
argument_list|(
literal|0
argument_list|,
literal|"Remove"
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
name|SLOT_DELETED
expr_stmt|;
name|mod
operator||=
name|THISMOD
operator||
name|FSDIRMOD
expr_stmt|;
block|}
else|else
name|mod
operator||=
name|FSERROR
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|ask
argument_list|(
literal|1
argument_list|,
literal|"Truncate"
argument_list|)
condition|)
block|{
name|p
index|[
literal|28
index|]
operator|=
name|p
index|[
literal|29
index|]
operator|=
name|p
index|[
literal|30
index|]
operator|=
name|p
index|[
literal|31
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|26
index|]
operator|=
name|p
index|[
literal|27
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|boot
operator|->
name|ClustMask
operator|==
name|CLUST32_MASK
condition|)
name|p
index|[
literal|20
index|]
operator|=
name|p
index|[
literal|21
index|]
operator|=
literal|0
expr_stmt|;
name|dirent
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|mod
operator||=
name|THISMOD
operator||
name|FSDIRMOD
expr_stmt|;
block|}
else|else
name|mod
operator||=
name|FSERROR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dirent
operator|.
name|head
operator|>=
name|CLUST_FIRST
operator|&&
name|dirent
operator|.
name|head
operator|<
name|boot
operator|->
name|NumClusters
condition|)
name|fat
index|[
name|dirent
operator|.
name|head
index|]
operator|.
name|flags
operator||=
name|FAT_USED
expr_stmt|;
if|if
condition|(
name|dirent
operator|.
name|flags
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
comment|/* 				 * gather more info for directories 				 */
name|struct
name|dirTodoNode
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|dirent
operator|.
name|size
condition|)
block|{
name|pwarn
argument_list|(
literal|"Directory %s has size != 0\n"
argument_list|,
name|fullpath
argument_list|(
operator|&
name|dirent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|1
argument_list|,
literal|"Correct"
argument_list|)
condition|)
block|{
name|p
index|[
literal|28
index|]
operator|=
name|p
index|[
literal|29
index|]
operator|=
name|p
index|[
literal|30
index|]
operator|=
name|p
index|[
literal|31
index|]
operator|=
literal|0
expr_stmt|;
name|dirent
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|mod
operator||=
name|THISMOD
operator||
name|FSDIRMOD
expr_stmt|;
block|}
else|else
name|mod
operator||=
name|FSERROR
expr_stmt|;
block|}
comment|/* 				 * handle `.' and `..' specially 				 */
if|if
condition|(
name|strcmp
argument_list|(
name|dirent
operator|.
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dirent
operator|.
name|head
operator|!=
name|dir
operator|->
name|head
condition|)
block|{
name|pwarn
argument_list|(
literal|"`.' entry in %s has incorrect start cluster\n"
argument_list|,
name|fullpath
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|1
argument_list|,
literal|"Correct"
argument_list|)
condition|)
block|{
name|dirent
operator|.
name|head
operator|=
name|dir
operator|->
name|head
expr_stmt|;
name|p
index|[
literal|26
index|]
operator|=
operator|(
name|u_char
operator|)
name|dirent
operator|.
name|head
expr_stmt|;
name|p
index|[
literal|27
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|dirent
operator|.
name|head
operator|>>
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|boot
operator|->
name|ClustMask
operator|==
name|CLUST32_MASK
condition|)
block|{
name|p
index|[
literal|20
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|dirent
operator|.
name|head
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|p
index|[
literal|21
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|dirent
operator|.
name|head
operator|>>
literal|24
argument_list|)
expr_stmt|;
block|}
name|mod
operator||=
name|THISMOD
operator||
name|FSDIRMOD
expr_stmt|;
block|}
else|else
name|mod
operator||=
name|FSERROR
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|dirent
operator|.
name|name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dir
operator|->
name|parent
condition|)
block|{
comment|/* XXX */
if|if
condition|(
operator|!
name|dir
operator|->
name|parent
operator|->
name|parent
condition|)
block|{
if|if
condition|(
name|dirent
operator|.
name|head
condition|)
block|{
name|pwarn
argument_list|(
literal|"`..' entry in %s has non-zero start cluster\n"
argument_list|,
name|fullpath
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|1
argument_list|,
literal|"Correct"
argument_list|)
condition|)
block|{
name|dirent
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|26
index|]
operator|=
name|p
index|[
literal|27
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|boot
operator|->
name|ClustMask
operator|==
name|CLUST32_MASK
condition|)
name|p
index|[
literal|20
index|]
operator|=
name|p
index|[
literal|21
index|]
operator|=
literal|0
expr_stmt|;
name|mod
operator||=
name|THISMOD
operator||
name|FSDIRMOD
expr_stmt|;
block|}
else|else
name|mod
operator||=
name|FSERROR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dirent
operator|.
name|head
operator|!=
name|dir
operator|->
name|parent
operator|->
name|head
condition|)
block|{
name|pwarn
argument_list|(
literal|"`..' entry in %s has incorrect start cluster\n"
argument_list|,
name|fullpath
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|1
argument_list|,
literal|"Correct"
argument_list|)
condition|)
block|{
name|dirent
operator|.
name|head
operator|=
name|dir
operator|->
name|parent
operator|->
name|head
expr_stmt|;
name|p
index|[
literal|26
index|]
operator|=
operator|(
name|u_char
operator|)
name|dirent
operator|.
name|head
expr_stmt|;
name|p
index|[
literal|27
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|dirent
operator|.
name|head
operator|>>
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|boot
operator|->
name|ClustMask
operator|==
name|CLUST32_MASK
condition|)
block|{
name|p
index|[
literal|20
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|dirent
operator|.
name|head
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|p
index|[
literal|21
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|dirent
operator|.
name|head
operator|>>
literal|24
argument_list|)
expr_stmt|;
block|}
name|mod
operator||=
name|THISMOD
operator||
name|FSDIRMOD
expr_stmt|;
block|}
else|else
name|mod
operator||=
name|FSERROR
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* create directory tree node */
if|if
condition|(
operator|!
operator|(
name|d
operator|=
name|newDosDirEntry
argument_list|()
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"No space for directory"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
name|memcpy
argument_list|(
name|d
argument_list|,
operator|&
name|dirent
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dosDirEntry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* link it into the tree */
name|dir
operator|->
name|child
operator|=
name|d
expr_stmt|;
comment|/* Enter this directory into the todo list */
if|if
condition|(
operator|!
operator|(
name|n
operator|=
name|newDirTodo
argument_list|()
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"No space for todo list"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
name|n
operator|->
name|next
operator|=
name|pendingDirectories
expr_stmt|;
name|n
operator|->
name|dir
operator|=
name|d
expr_stmt|;
name|pendingDirectories
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|mod
operator||=
name|k
operator|=
name|checksize
argument_list|(
name|boot
argument_list|,
name|fat
argument_list|,
name|p
argument_list|,
operator|&
name|dirent
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|&
name|FSDIRMOD
condition|)
name|mod
operator||=
name|THISMOD
expr_stmt|;
block|}
name|boot
operator|->
name|NumFiles
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mod
operator|&
name|THISMOD
condition|)
block|{
name|last
operator|*=
literal|32
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|f
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|off
operator|||
name|write
argument_list|(
name|f
argument_list|,
name|buffer
argument_list|,
name|last
argument_list|)
operator|!=
name|last
condition|)
block|{
name|perror
argument_list|(
literal|"Unable to write directory"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
name|mod
operator|&=
operator|~
name|THISMOD
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|cl
operator|=
name|fat
index|[
name|cl
index|]
operator|.
name|next
operator|)
operator|>=
name|CLUST_FIRST
operator|&&
name|cl
operator|<
name|boot
operator|->
name|NumClusters
condition|)
do|;
if|if
condition|(
name|invlfn
operator|||
name|vallfn
condition|)
name|mod
operator||=
name|removede
argument_list|(
name|f
argument_list|,
name|boot
argument_list|,
name|fat
argument_list|,
name|invlfn
condition|?
name|invlfn
else|:
name|vallfn
argument_list|,
name|p
argument_list|,
name|invlfn
condition|?
name|invcl
else|:
name|valcl
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|fullpath
argument_list|(
name|dir
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|mod
operator|&
operator|~
name|THISMOD
return|;
block|}
end_function

begin_function
name|int
name|handleDirTree
parameter_list|(
name|dosfs
parameter_list|,
name|boot
parameter_list|,
name|fat
parameter_list|)
name|int
name|dosfs
decl_stmt|;
name|struct
name|bootblock
modifier|*
name|boot
decl_stmt|;
name|struct
name|fatEntry
modifier|*
name|fat
decl_stmt|;
block|{
name|int
name|mod
decl_stmt|;
name|mod
operator|=
name|readDosDirSection
argument_list|(
name|dosfs
argument_list|,
name|boot
argument_list|,
name|fat
argument_list|,
name|rootDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod
operator|&
name|FSFATAL
condition|)
return|return
name|FSFATAL
return|;
comment|/* 	 * process the directory todo list 	 */
while|while
condition|(
name|pendingDirectories
condition|)
block|{
name|struct
name|dosDirEntry
modifier|*
name|dir
init|=
name|pendingDirectories
operator|->
name|dir
decl_stmt|;
name|struct
name|dirTodoNode
modifier|*
name|n
init|=
name|pendingDirectories
operator|->
name|next
decl_stmt|;
comment|/* 		 * remove TODO entry now, the list might change during 		 * directory reads 		 */
name|freeDirTodo
argument_list|(
name|pendingDirectories
argument_list|)
expr_stmt|;
name|pendingDirectories
operator|=
name|n
expr_stmt|;
comment|/* 		 * handle subdirectory 		 */
name|mod
operator||=
name|readDosDirSection
argument_list|(
name|dosfs
argument_list|,
name|boot
argument_list|,
name|fat
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod
operator|&
name|FSFATAL
condition|)
return|return
name|FSFATAL
return|;
block|}
return|return
name|mod
return|;
block|}
end_function

begin_comment
comment|/*  * Try to reconnect a FAT chain into dir  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|lfbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cl_t
name|lfcl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|off_t
name|lfoff
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|reconnect
parameter_list|(
name|dosfs
parameter_list|,
name|boot
parameter_list|,
name|fat
parameter_list|,
name|head
parameter_list|)
name|int
name|dosfs
decl_stmt|;
name|struct
name|bootblock
modifier|*
name|boot
decl_stmt|;
name|struct
name|fatEntry
modifier|*
name|fat
decl_stmt|;
name|cl_t
name|head
decl_stmt|;
block|{
name|struct
name|dosDirEntry
name|d
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|ask
argument_list|(
literal|1
argument_list|,
literal|"Reconnect"
argument_list|)
condition|)
return|return
name|FSERROR
return|;
if|if
condition|(
operator|!
name|lostDir
condition|)
block|{
for|for
control|(
name|lostDir
operator|=
name|rootDir
operator|->
name|child
init|;
name|lostDir
condition|;
name|lostDir
operator|=
name|lostDir
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|lostDir
operator|->
name|name
argument_list|,
name|LOSTDIR
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|lostDir
condition|)
block|{
comment|/* Create LOSTDIR?		XXX */
name|pwarn
argument_list|(
literal|"No %s directory\n"
argument_list|,
name|LOSTDIR
argument_list|)
expr_stmt|;
return|return
name|FSERROR
return|;
block|}
block|}
if|if
condition|(
operator|!
name|lfbuf
condition|)
block|{
name|lfbuf
operator|=
name|malloc
argument_list|(
name|boot
operator|->
name|ClusterSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lfbuf
condition|)
block|{
name|perror
argument_list|(
literal|"No space for buffer"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
name|p
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|p
operator|=
name|lfbuf
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|p
condition|)
for|for
control|(
init|;
name|p
operator|<
name|lfbuf
operator|+
name|boot
operator|->
name|ClusterSize
condition|;
name|p
operator|+=
literal|32
control|)
if|if
condition|(
operator|*
name|p
operator|==
name|SLOT_EMPTY
operator|||
operator|*
name|p
operator|==
name|SLOT_DELETED
condition|)
break|break;
if|if
condition|(
name|p
operator|&&
name|p
operator|<
name|lfbuf
operator|+
name|boot
operator|->
name|ClusterSize
condition|)
break|break;
name|lfcl
operator|=
name|p
condition|?
name|fat
index|[
name|lfcl
index|]
operator|.
name|next
else|:
name|lostDir
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|lfcl
operator|<
name|CLUST_FIRST
operator|||
name|lfcl
operator|>=
name|boot
operator|->
name|NumClusters
condition|)
block|{
comment|/* Extend LOSTDIR?				XXX */
name|pwarn
argument_list|(
literal|"No space in %s\n"
argument_list|,
name|LOSTDIR
argument_list|)
expr_stmt|;
return|return
name|FSERROR
return|;
block|}
name|lfoff
operator|=
name|lfcl
operator|*
name|boot
operator|->
name|ClusterSize
operator|+
name|boot
operator|->
name|ClusterOffset
operator|*
name|boot
operator|->
name|BytesPerSec
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|dosfs
argument_list|,
name|lfoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|lfoff
operator|||
name|read
argument_list|(
name|dosfs
argument_list|,
name|lfbuf
argument_list|,
name|boot
operator|->
name|ClusterSize
argument_list|)
operator|!=
name|boot
operator|->
name|ClusterSize
condition|)
block|{
name|perror
argument_list|(
literal|"could not read LOST.DIR"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
name|p
operator|=
name|lfbuf
expr_stmt|;
block|}
name|boot
operator|->
name|NumFiles
operator|++
expr_stmt|;
comment|/* Ensure uniqueness of entry here!				XXX */
name|memset
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|d
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|d
operator|.
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|.
name|name
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|d
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|head
operator|=
name|head
expr_stmt|;
name|d
operator|.
name|size
operator|=
name|fat
index|[
name|head
index|]
operator|.
name|length
operator|*
name|boot
operator|->
name|ClusterSize
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|d
operator|.
name|name
argument_list|,
name|strlen
argument_list|(
name|d
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|p
index|[
literal|26
index|]
operator|=
operator|(
name|u_char
operator|)
name|d
operator|.
name|head
expr_stmt|;
name|p
index|[
literal|27
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|d
operator|.
name|head
operator|>>
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|boot
operator|->
name|ClustMask
operator|==
name|CLUST32_MASK
condition|)
block|{
name|p
index|[
literal|20
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|d
operator|.
name|head
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|p
index|[
literal|21
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|d
operator|.
name|head
operator|>>
literal|24
argument_list|)
expr_stmt|;
block|}
name|p
index|[
literal|28
index|]
operator|=
operator|(
name|u_char
operator|)
name|d
operator|.
name|size
expr_stmt|;
name|p
index|[
literal|29
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|d
operator|.
name|size
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|p
index|[
literal|30
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|d
operator|.
name|size
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|p
index|[
literal|31
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|d
operator|.
name|size
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|fat
index|[
name|head
index|]
operator|.
name|flags
operator||=
name|FAT_USED
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|dosfs
argument_list|,
name|lfoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|lfoff
operator|||
name|write
argument_list|(
name|dosfs
argument_list|,
name|lfbuf
argument_list|,
name|boot
operator|->
name|ClusterSize
argument_list|)
operator|!=
name|boot
operator|->
name|ClusterSize
condition|)
block|{
name|perror
argument_list|(
literal|"could not write LOST.DIR"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
return|return
name|FSDIRMOD
return|;
block|}
end_function

begin_function
name|void
name|finishlf
parameter_list|()
block|{
if|if
condition|(
name|lfbuf
condition|)
name|free
argument_list|(
name|lfbuf
argument_list|)
expr_stmt|;
name|lfbuf
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

