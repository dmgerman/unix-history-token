begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997 Wolfgang Solfrank  * Copyright (c) 1995 Martin Husemann  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Martin Husemann  *	and Wolfgang Solfrank.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: fat.c,v 1.12 2000/10/10 20:24:52 is Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"ext.h"
end_include

begin_include
include|#
directive|include
file|"fsutil.h"
end_include

begin_function_decl
specifier|static
name|int
name|checkclnum
parameter_list|(
name|struct
name|bootblock
modifier|*
parameter_list|,
name|int
parameter_list|,
name|cl_t
parameter_list|,
name|cl_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|clustdiffer
parameter_list|(
name|cl_t
parameter_list|,
name|cl_t
modifier|*
parameter_list|,
name|cl_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tryclear
parameter_list|(
name|struct
name|bootblock
modifier|*
parameter_list|,
name|struct
name|fatEntry
modifier|*
parameter_list|,
name|cl_t
parameter_list|,
name|cl_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_readfat
parameter_list|(
name|int
parameter_list|,
name|struct
name|bootblock
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Check a cluster number for valid value  */
end_comment

begin_function
specifier|static
name|int
name|checkclnum
parameter_list|(
name|struct
name|bootblock
modifier|*
name|boot
parameter_list|,
name|int
name|fat
parameter_list|,
name|cl_t
name|cl
parameter_list|,
name|cl_t
modifier|*
name|next
parameter_list|)
block|{
if|if
condition|(
operator|*
name|next
operator|>=
operator|(
name|CLUST_RSRVD
operator|&
name|boot
operator|->
name|ClustMask
operator|)
condition|)
operator|*
name|next
operator||=
operator|~
name|boot
operator|->
name|ClustMask
expr_stmt|;
if|if
condition|(
operator|*
name|next
operator|==
name|CLUST_FREE
condition|)
block|{
name|boot
operator|->
name|NumFree
operator|++
expr_stmt|;
return|return
name|FSOK
return|;
block|}
if|if
condition|(
operator|*
name|next
operator|==
name|CLUST_BAD
condition|)
block|{
name|boot
operator|->
name|NumBad
operator|++
expr_stmt|;
return|return
name|FSOK
return|;
block|}
if|if
condition|(
operator|*
name|next
operator|<
name|CLUST_FIRST
operator|||
operator|(
operator|*
name|next
operator|>=
name|boot
operator|->
name|NumClusters
operator|&&
operator|*
name|next
operator|<
name|CLUST_EOFS
operator|)
condition|)
block|{
name|pwarn
argument_list|(
literal|"Cluster %u in FAT %d continues with %s cluster number %u\n"
argument_list|,
name|cl
argument_list|,
name|fat
argument_list|,
operator|*
name|next
operator|<
name|CLUST_RSRVD
condition|?
literal|"out of range"
else|:
literal|"reserved"
argument_list|,
operator|*
name|next
operator|&
name|boot
operator|->
name|ClustMask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|0
argument_list|,
literal|"Truncate"
argument_list|)
condition|)
block|{
operator|*
name|next
operator|=
name|CLUST_EOF
expr_stmt|;
return|return
name|FSFATMOD
return|;
block|}
return|return
name|FSERROR
return|;
block|}
return|return
name|FSOK
return|;
block|}
end_function

begin_comment
comment|/*  * Read a FAT from disk. Returns 1 if successful, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|_readfat
parameter_list|(
name|int
name|fs
parameter_list|,
name|struct
name|bootblock
modifier|*
name|boot
parameter_list|,
name|int
name|no
parameter_list|,
name|u_char
modifier|*
modifier|*
name|buffer
parameter_list|)
block|{
name|off_t
name|off
decl_stmt|;
operator|*
name|buffer
operator|=
name|malloc
argument_list|(
name|boot
operator|->
name|FATsecs
operator|*
name|boot
operator|->
name|BytesPerSec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"No space for FAT"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|off
operator|=
name|boot
operator|->
name|ResSectors
operator|+
name|no
operator|*
name|boot
operator|->
name|FATsecs
expr_stmt|;
name|off
operator|*=
name|boot
operator|->
name|BytesPerSec
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fs
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|off
condition|)
block|{
name|perror
argument_list|(
literal|"Unable to read FAT"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fs
argument_list|,
operator|*
name|buffer
argument_list|,
name|boot
operator|->
name|FATsecs
operator|*
name|boot
operator|->
name|BytesPerSec
argument_list|)
operator|!=
name|boot
operator|->
name|FATsecs
operator|*
name|boot
operator|->
name|BytesPerSec
condition|)
block|{
name|perror
argument_list|(
literal|"Unable to read FAT"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
literal|1
return|;
name|err
label|:
name|free
argument_list|(
operator|*
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Read a FAT and decode it into internal format  */
end_comment

begin_function
name|int
name|readfat
parameter_list|(
name|int
name|fs
parameter_list|,
name|struct
name|bootblock
modifier|*
name|boot
parameter_list|,
name|int
name|no
parameter_list|,
name|struct
name|fatEntry
modifier|*
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|fatEntry
modifier|*
name|fat
decl_stmt|;
name|u_char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|cl_t
name|cl
decl_stmt|;
name|int
name|ret
init|=
name|FSOK
decl_stmt|;
name|boot
operator|->
name|NumFree
operator|=
name|boot
operator|->
name|NumBad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|_readfat
argument_list|(
name|fs
argument_list|,
name|boot
argument_list|,
name|no
argument_list|,
operator|&
name|buffer
argument_list|)
condition|)
return|return
name|FSFATAL
return|;
name|fat
operator|=
name|calloc
argument_list|(
name|boot
operator|->
name|NumClusters
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fatEntry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fat
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"No space for FAT"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|!=
name|boot
operator|->
name|Media
operator|||
name|buffer
index|[
literal|1
index|]
operator|!=
literal|0xff
operator|||
name|buffer
index|[
literal|2
index|]
operator|!=
literal|0xff
operator|||
operator|(
name|boot
operator|->
name|ClustMask
operator|==
name|CLUST16_MASK
operator|&&
name|buffer
index|[
literal|3
index|]
operator|!=
literal|0xff
operator|)
operator|||
operator|(
name|boot
operator|->
name|ClustMask
operator|==
name|CLUST32_MASK
operator|&&
operator|(
operator|(
name|buffer
index|[
literal|3
index|]
operator|&
literal|0x0f
operator|)
operator|!=
literal|0x0f
operator|||
name|buffer
index|[
literal|4
index|]
operator|!=
literal|0xff
operator|||
name|buffer
index|[
literal|5
index|]
operator|!=
literal|0xff
operator|||
name|buffer
index|[
literal|6
index|]
operator|!=
literal|0xff
operator|||
operator|(
name|buffer
index|[
literal|7
index|]
operator|&
literal|0x0f
operator|)
operator|!=
literal|0x0f
operator|)
operator|)
condition|)
block|{
comment|/* Windows 95 OSR2 (and possibly any later) changes 		 * the FAT signature to 0xXXffff7f for FAT16 and to 		 * 0xXXffff0fffffff07 for FAT32 upon boot, to know that the 		 * filesystem is dirty if it doesn't reboot cleanly. 		 * Check this special condition before errorring out. 		 */
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|==
name|boot
operator|->
name|Media
operator|&&
name|buffer
index|[
literal|1
index|]
operator|==
literal|0xff
operator|&&
name|buffer
index|[
literal|2
index|]
operator|==
literal|0xff
operator|&&
operator|(
operator|(
name|boot
operator|->
name|ClustMask
operator|==
name|CLUST16_MASK
operator|&&
name|buffer
index|[
literal|3
index|]
operator|==
literal|0x7f
operator|)
operator|||
operator|(
name|boot
operator|->
name|ClustMask
operator|==
name|CLUST32_MASK
operator|&&
name|buffer
index|[
literal|3
index|]
operator|==
literal|0x0f
operator|&&
name|buffer
index|[
literal|4
index|]
operator|==
literal|0xff
operator|&&
name|buffer
index|[
literal|5
index|]
operator|==
literal|0xff
operator|&&
name|buffer
index|[
literal|6
index|]
operator|==
literal|0xff
operator|&&
name|buffer
index|[
literal|7
index|]
operator|==
literal|0x07
operator|)
operator|)
condition|)
name|ret
operator||=
name|FSDIRTY
expr_stmt|;
else|else
block|{
comment|/* just some odd byte sequence in FAT */
switch|switch
condition|(
name|boot
operator|->
name|ClustMask
condition|)
block|{
case|case
name|CLUST32_MASK
case|:
name|pwarn
argument_list|(
literal|"%s (%02x%02x%02x%02x%02x%02x%02x%02x)\n"
argument_list|,
literal|"FAT starts with odd byte sequence"
argument_list|,
name|buffer
index|[
literal|0
index|]
argument_list|,
name|buffer
index|[
literal|1
index|]
argument_list|,
name|buffer
index|[
literal|2
index|]
argument_list|,
name|buffer
index|[
literal|3
index|]
argument_list|,
name|buffer
index|[
literal|4
index|]
argument_list|,
name|buffer
index|[
literal|5
index|]
argument_list|,
name|buffer
index|[
literal|6
index|]
argument_list|,
name|buffer
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLUST16_MASK
case|:
name|pwarn
argument_list|(
literal|"%s (%02x%02x%02x%02x)\n"
argument_list|,
literal|"FAT starts with odd byte sequence"
argument_list|,
name|buffer
index|[
literal|0
index|]
argument_list|,
name|buffer
index|[
literal|1
index|]
argument_list|,
name|buffer
index|[
literal|2
index|]
argument_list|,
name|buffer
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pwarn
argument_list|(
literal|"%s (%02x%02x%02x)\n"
argument_list|,
literal|"FAT starts with odd byte sequence"
argument_list|,
name|buffer
index|[
literal|0
index|]
argument_list|,
name|buffer
index|[
literal|1
index|]
argument_list|,
name|buffer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ask
argument_list|(
literal|1
argument_list|,
literal|"Correct"
argument_list|)
condition|)
name|ret
operator||=
name|FSFIXFAT
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|boot
operator|->
name|ClustMask
condition|)
block|{
case|case
name|CLUST32_MASK
case|:
name|p
operator|=
name|buffer
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|CLUST16_MASK
case|:
name|p
operator|=
name|buffer
operator|+
literal|4
expr_stmt|;
break|break;
default|default:
name|p
operator|=
name|buffer
operator|+
literal|3
expr_stmt|;
break|break;
block|}
for|for
control|(
name|cl
operator|=
name|CLUST_FIRST
init|;
name|cl
operator|<
name|boot
operator|->
name|NumClusters
condition|;
control|)
block|{
switch|switch
condition|(
name|boot
operator|->
name|ClustMask
condition|)
block|{
case|case
name|CLUST32_MASK
case|:
name|fat
index|[
name|cl
index|]
operator|.
name|next
operator|=
name|p
index|[
literal|0
index|]
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|p
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|fat
index|[
name|cl
index|]
operator|.
name|next
operator|&=
name|boot
operator|->
name|ClustMask
expr_stmt|;
name|ret
operator||=
name|checkclnum
argument_list|(
name|boot
argument_list|,
name|no
argument_list|,
name|cl
argument_list|,
operator|&
name|fat
index|[
name|cl
index|]
operator|.
name|next
argument_list|)
expr_stmt|;
name|cl
operator|++
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|CLUST16_MASK
case|:
name|fat
index|[
name|cl
index|]
operator|.
name|next
operator|=
name|p
index|[
literal|0
index|]
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|ret
operator||=
name|checkclnum
argument_list|(
name|boot
argument_list|,
name|no
argument_list|,
name|cl
argument_list|,
operator|&
name|fat
index|[
name|cl
index|]
operator|.
name|next
argument_list|)
expr_stmt|;
name|cl
operator|++
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|fat
index|[
name|cl
index|]
operator|.
name|next
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|)
operator|&
literal|0x0fff
expr_stmt|;
name|ret
operator||=
name|checkclnum
argument_list|(
name|boot
argument_list|,
name|no
argument_list|,
name|cl
argument_list|,
operator|&
name|fat
index|[
name|cl
index|]
operator|.
name|next
argument_list|)
expr_stmt|;
name|cl
operator|++
expr_stmt|;
if|if
condition|(
name|cl
operator|>=
name|boot
operator|->
name|NumClusters
condition|)
break|break;
name|fat
index|[
name|cl
index|]
operator|.
name|next
operator|=
operator|(
operator|(
name|p
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|+
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|4
operator|)
operator|)
operator|&
literal|0x0fff
expr_stmt|;
name|ret
operator||=
name|checkclnum
argument_list|(
name|boot
argument_list|,
name|no
argument_list|,
name|cl
argument_list|,
operator|&
name|fat
index|[
name|cl
index|]
operator|.
name|next
argument_list|)
expr_stmt|;
name|cl
operator|++
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
operator|*
name|fp
operator|=
name|fat
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Get type of reserved cluster  */
end_comment

begin_function
name|char
modifier|*
name|rsrvdcltype
parameter_list|(
name|cl_t
name|cl
parameter_list|)
block|{
if|if
condition|(
name|cl
operator|==
name|CLUST_FREE
condition|)
return|return
literal|"free"
return|;
if|if
condition|(
name|cl
operator|<
name|CLUST_BAD
condition|)
return|return
literal|"reserved"
return|;
if|if
condition|(
name|cl
operator|>
name|CLUST_BAD
condition|)
return|return
literal|"as EOF"
return|;
return|return
literal|"bad"
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|clustdiffer
parameter_list|(
name|cl_t
name|cl
parameter_list|,
name|cl_t
modifier|*
name|cp1
parameter_list|,
name|cl_t
modifier|*
name|cp2
parameter_list|,
name|int
name|fatnum
parameter_list|)
block|{
if|if
condition|(
operator|*
name|cp1
operator|==
name|CLUST_FREE
operator|||
operator|*
name|cp1
operator|>=
name|CLUST_RSRVD
condition|)
block|{
if|if
condition|(
operator|*
name|cp2
operator|==
name|CLUST_FREE
operator|||
operator|*
name|cp2
operator|>=
name|CLUST_RSRVD
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp1
operator|!=
name|CLUST_FREE
operator|&&
operator|*
name|cp1
operator|<
name|CLUST_BAD
operator|&&
operator|*
name|cp2
operator|!=
name|CLUST_FREE
operator|&&
operator|*
name|cp2
operator|<
name|CLUST_BAD
operator|)
operator|||
operator|(
operator|*
name|cp1
operator|>
name|CLUST_BAD
operator|&&
operator|*
name|cp2
operator|>
name|CLUST_BAD
operator|)
condition|)
block|{
name|pwarn
argument_list|(
literal|"Cluster %u is marked %s with different indicators, "
argument_list|,
name|cl
argument_list|,
name|rsrvdcltype
argument_list|(
operator|*
name|cp1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|1
argument_list|,
literal|"fix"
argument_list|)
condition|)
block|{
operator|*
name|cp2
operator|=
operator|*
name|cp1
expr_stmt|;
return|return
name|FSFATMOD
return|;
block|}
return|return
name|FSFATAL
return|;
block|}
name|pwarn
argument_list|(
literal|"Cluster %u is marked %s in FAT 0, %s in FAT %d\n"
argument_list|,
name|cl
argument_list|,
name|rsrvdcltype
argument_list|(
operator|*
name|cp1
argument_list|)
argument_list|,
name|rsrvdcltype
argument_list|(
operator|*
name|cp2
argument_list|)
argument_list|,
name|fatnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|0
argument_list|,
literal|"use FAT 0's entry"
argument_list|)
condition|)
block|{
operator|*
name|cp2
operator|=
operator|*
name|cp1
expr_stmt|;
return|return
name|FSFATMOD
return|;
block|}
if|if
condition|(
name|ask
argument_list|(
literal|0
argument_list|,
literal|"use FAT %d's entry"
argument_list|,
name|fatnum
argument_list|)
condition|)
block|{
operator|*
name|cp1
operator|=
operator|*
name|cp2
expr_stmt|;
return|return
name|FSFATMOD
return|;
block|}
return|return
name|FSFATAL
return|;
block|}
name|pwarn
argument_list|(
literal|"Cluster %u is marked %s in FAT 0, but continues with cluster %u in FAT %d\n"
argument_list|,
name|cl
argument_list|,
name|rsrvdcltype
argument_list|(
operator|*
name|cp1
argument_list|)
argument_list|,
operator|*
name|cp2
argument_list|,
name|fatnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|0
argument_list|,
literal|"Use continuation from FAT %d"
argument_list|,
name|fatnum
argument_list|)
condition|)
block|{
operator|*
name|cp1
operator|=
operator|*
name|cp2
expr_stmt|;
return|return
name|FSFATMOD
return|;
block|}
if|if
condition|(
name|ask
argument_list|(
literal|0
argument_list|,
literal|"Use mark from FAT 0"
argument_list|)
condition|)
block|{
operator|*
name|cp2
operator|=
operator|*
name|cp1
expr_stmt|;
return|return
name|FSFATMOD
return|;
block|}
return|return
name|FSFATAL
return|;
block|}
if|if
condition|(
operator|*
name|cp2
operator|==
name|CLUST_FREE
operator|||
operator|*
name|cp2
operator|>=
name|CLUST_RSRVD
condition|)
block|{
name|pwarn
argument_list|(
literal|"Cluster %u continues with cluster %u in FAT 0, but is marked %s in FAT %d\n"
argument_list|,
name|cl
argument_list|,
operator|*
name|cp1
argument_list|,
name|rsrvdcltype
argument_list|(
operator|*
name|cp2
argument_list|)
argument_list|,
name|fatnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|0
argument_list|,
literal|"Use continuation from FAT 0"
argument_list|)
condition|)
block|{
operator|*
name|cp2
operator|=
operator|*
name|cp1
expr_stmt|;
return|return
name|FSFATMOD
return|;
block|}
if|if
condition|(
name|ask
argument_list|(
literal|0
argument_list|,
literal|"Use mark from FAT %d"
argument_list|,
name|fatnum
argument_list|)
condition|)
block|{
operator|*
name|cp1
operator|=
operator|*
name|cp2
expr_stmt|;
return|return
name|FSFATMOD
return|;
block|}
return|return
name|FSERROR
return|;
block|}
name|pwarn
argument_list|(
literal|"Cluster %u continues with cluster %u in FAT 0, but with cluster %u in FAT %d\n"
argument_list|,
name|cl
argument_list|,
operator|*
name|cp1
argument_list|,
operator|*
name|cp2
argument_list|,
name|fatnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|0
argument_list|,
literal|"Use continuation from FAT 0"
argument_list|)
condition|)
block|{
operator|*
name|cp2
operator|=
operator|*
name|cp1
expr_stmt|;
return|return
name|FSFATMOD
return|;
block|}
if|if
condition|(
name|ask
argument_list|(
literal|0
argument_list|,
literal|"Use continuation from FAT %d"
argument_list|,
name|fatnum
argument_list|)
condition|)
block|{
operator|*
name|cp1
operator|=
operator|*
name|cp2
expr_stmt|;
return|return
name|FSFATMOD
return|;
block|}
return|return
name|FSERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two FAT copies in memory. Resolve any conflicts and merge them  * into the first one.  */
end_comment

begin_function
name|int
name|comparefat
parameter_list|(
name|struct
name|bootblock
modifier|*
name|boot
parameter_list|,
name|struct
name|fatEntry
modifier|*
name|first
parameter_list|,
name|struct
name|fatEntry
modifier|*
name|second
parameter_list|,
name|int
name|fatnum
parameter_list|)
block|{
name|cl_t
name|cl
decl_stmt|;
name|int
name|ret
init|=
name|FSOK
decl_stmt|;
for|for
control|(
name|cl
operator|=
name|CLUST_FIRST
init|;
name|cl
operator|<
name|boot
operator|->
name|NumClusters
condition|;
name|cl
operator|++
control|)
if|if
condition|(
name|first
index|[
name|cl
index|]
operator|.
name|next
operator|!=
name|second
index|[
name|cl
index|]
operator|.
name|next
condition|)
name|ret
operator||=
name|clustdiffer
argument_list|(
name|cl
argument_list|,
operator|&
name|first
index|[
name|cl
index|]
operator|.
name|next
argument_list|,
operator|&
name|second
index|[
name|cl
index|]
operator|.
name|next
argument_list|,
name|fatnum
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|clearchain
parameter_list|(
name|struct
name|bootblock
modifier|*
name|boot
parameter_list|,
name|struct
name|fatEntry
modifier|*
name|fat
parameter_list|,
name|cl_t
name|head
parameter_list|)
block|{
name|cl_t
name|p
decl_stmt|,
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|head
init|;
name|p
operator|>=
name|CLUST_FIRST
operator|&&
name|p
operator|<
name|boot
operator|->
name|NumClusters
condition|;
name|p
operator|=
name|q
control|)
block|{
if|if
condition|(
name|fat
index|[
name|p
index|]
operator|.
name|head
operator|!=
name|head
condition|)
break|break;
name|q
operator|=
name|fat
index|[
name|p
index|]
operator|.
name|next
expr_stmt|;
name|fat
index|[
name|p
index|]
operator|.
name|next
operator|=
name|fat
index|[
name|p
index|]
operator|.
name|head
operator|=
name|CLUST_FREE
expr_stmt|;
name|fat
index|[
name|p
index|]
operator|.
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|tryclear
parameter_list|(
name|struct
name|bootblock
modifier|*
name|boot
parameter_list|,
name|struct
name|fatEntry
modifier|*
name|fat
parameter_list|,
name|cl_t
name|head
parameter_list|,
name|cl_t
modifier|*
name|trunc
parameter_list|)
block|{
if|if
condition|(
name|ask
argument_list|(
literal|0
argument_list|,
literal|"Clear chain starting at %u"
argument_list|,
name|head
argument_list|)
condition|)
block|{
name|clearchain
argument_list|(
name|boot
argument_list|,
name|fat
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return
name|FSFATMOD
return|;
block|}
elseif|else
if|if
condition|(
name|ask
argument_list|(
literal|0
argument_list|,
literal|"Truncate"
argument_list|)
condition|)
block|{
operator|*
name|trunc
operator|=
name|CLUST_EOF
expr_stmt|;
return|return
name|FSFATMOD
return|;
block|}
else|else
return|return
name|FSERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Check a complete FAT in-memory for crosslinks  */
end_comment

begin_function
name|int
name|checkfat
parameter_list|(
name|struct
name|bootblock
modifier|*
name|boot
parameter_list|,
name|struct
name|fatEntry
modifier|*
name|fat
parameter_list|)
block|{
name|cl_t
name|head
decl_stmt|,
name|p
decl_stmt|,
name|h
decl_stmt|,
name|n
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|conf
decl_stmt|;
comment|/* 	 * pass 1: figure out the cluster chains. 	 */
for|for
control|(
name|head
operator|=
name|CLUST_FIRST
init|;
name|head
operator|<
name|boot
operator|->
name|NumClusters
condition|;
name|head
operator|++
control|)
block|{
comment|/* find next untravelled chain */
if|if
condition|(
name|fat
index|[
name|head
index|]
operator|.
name|head
operator|!=
literal|0
comment|/* cluster already belongs to some chain */
operator|||
name|fat
index|[
name|head
index|]
operator|.
name|next
operator|==
name|CLUST_FREE
operator|||
name|fat
index|[
name|head
index|]
operator|.
name|next
operator|==
name|CLUST_BAD
condition|)
continue|continue;
comment|/* skip it. */
comment|/* follow the chain and mark all clusters on the way */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|p
operator|=
name|head
init|;
name|p
operator|>=
name|CLUST_FIRST
operator|&&
name|p
operator|<
name|boot
operator|->
name|NumClusters
condition|;
name|p
operator|=
name|fat
index|[
name|p
index|]
operator|.
name|next
control|)
block|{
name|fat
index|[
name|p
index|]
operator|.
name|head
operator|=
name|head
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
comment|/* the head record gets the length */
name|fat
index|[
name|head
index|]
operator|.
name|length
operator|=
name|fat
index|[
name|head
index|]
operator|.
name|next
operator|==
name|CLUST_FREE
condition|?
literal|0
else|:
name|len
expr_stmt|;
block|}
comment|/* 	 * pass 2: check for crosslinked chains (we couldn't do this in pass 1 because 	 * we didn't know the real start of the chain then - would have treated partial 	 * chains as interlinked with their main chain) 	 */
for|for
control|(
name|head
operator|=
name|CLUST_FIRST
init|;
name|head
operator|<
name|boot
operator|->
name|NumClusters
condition|;
name|head
operator|++
control|)
block|{
comment|/* find next untravelled chain */
if|if
condition|(
name|fat
index|[
name|head
index|]
operator|.
name|head
operator|!=
name|head
condition|)
continue|continue;
comment|/* follow the chain to its end (hopefully) */
for|for
control|(
name|p
operator|=
name|head
init|;
operator|(
name|n
operator|=
name|fat
index|[
name|p
index|]
operator|.
name|next
operator|)
operator|>=
name|CLUST_FIRST
operator|&&
name|n
operator|<
name|boot
operator|->
name|NumClusters
condition|;
name|p
operator|=
name|n
control|)
if|if
condition|(
name|fat
index|[
name|n
index|]
operator|.
name|head
operator|!=
name|head
condition|)
break|break;
if|if
condition|(
name|n
operator|>=
name|CLUST_EOFS
condition|)
continue|continue;
if|if
condition|(
name|n
operator|==
name|CLUST_FREE
operator|||
name|n
operator|>=
name|CLUST_RSRVD
condition|)
block|{
name|pwarn
argument_list|(
literal|"Cluster chain starting at %u ends with cluster marked %s\n"
argument_list|,
name|head
argument_list|,
name|rsrvdcltype
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator||=
name|tryclear
argument_list|(
name|boot
argument_list|,
name|fat
argument_list|,
name|head
argument_list|,
operator|&
name|fat
index|[
name|p
index|]
operator|.
name|next
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|n
operator|<
name|CLUST_FIRST
operator|||
name|n
operator|>=
name|boot
operator|->
name|NumClusters
condition|)
block|{
name|pwarn
argument_list|(
literal|"Cluster chain starting at %u ends with cluster out of range (%u)\n"
argument_list|,
name|head
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ret
operator||=
name|tryclear
argument_list|(
name|boot
argument_list|,
name|fat
argument_list|,
name|head
argument_list|,
operator|&
name|fat
index|[
name|p
index|]
operator|.
name|next
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pwarn
argument_list|(
literal|"Cluster chains starting at %u and %u are linked at cluster %u\n"
argument_list|,
name|head
argument_list|,
name|fat
index|[
name|n
index|]
operator|.
name|head
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|conf
operator|=
name|tryclear
argument_list|(
name|boot
argument_list|,
name|fat
argument_list|,
name|head
argument_list|,
operator|&
name|fat
index|[
name|p
index|]
operator|.
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|0
argument_list|,
literal|"Clear chain starting at %u"
argument_list|,
name|h
operator|=
name|fat
index|[
name|n
index|]
operator|.
name|head
argument_list|)
condition|)
block|{
if|if
condition|(
name|conf
operator|==
name|FSERROR
condition|)
block|{
comment|/* 				 * Transfer the common chain to the one not cleared above. 				 */
for|for
control|(
name|p
operator|=
name|n
init|;
name|p
operator|>=
name|CLUST_FIRST
operator|&&
name|p
operator|<
name|boot
operator|->
name|NumClusters
condition|;
name|p
operator|=
name|fat
index|[
name|p
index|]
operator|.
name|next
control|)
block|{
if|if
condition|(
name|h
operator|!=
name|fat
index|[
name|p
index|]
operator|.
name|head
condition|)
block|{
comment|/* 						 * Have to reexamine this chain. 						 */
name|head
operator|--
expr_stmt|;
break|break;
block|}
name|fat
index|[
name|p
index|]
operator|.
name|head
operator|=
name|head
expr_stmt|;
block|}
block|}
name|clearchain
argument_list|(
name|boot
argument_list|,
name|fat
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|conf
operator||=
name|FSFATMOD
expr_stmt|;
block|}
name|ret
operator||=
name|conf
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Write out FATs encoding them from the internal format  */
end_comment

begin_function
name|int
name|writefat
parameter_list|(
name|int
name|fs
parameter_list|,
name|struct
name|bootblock
modifier|*
name|boot
parameter_list|,
name|struct
name|fatEntry
modifier|*
name|fat
parameter_list|,
name|int
name|correct_fat
parameter_list|)
block|{
name|u_char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|cl_t
name|cl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int32_t
name|fatsz
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|int
name|ret
init|=
name|FSOK
decl_stmt|;
name|buffer
operator|=
name|malloc
argument_list|(
name|fatsz
operator|=
name|boot
operator|->
name|FATsecs
operator|*
name|boot
operator|->
name|BytesPerSec
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"No space for FAT"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|fatsz
argument_list|)
expr_stmt|;
name|boot
operator|->
name|NumFree
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|correct_fat
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|(
name|u_char
operator|)
name|boot
operator|->
name|Media
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0xff
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0xff
expr_stmt|;
switch|switch
condition|(
name|boot
operator|->
name|ClustMask
condition|)
block|{
case|case
name|CLUST16_MASK
case|:
operator|*
name|p
operator|++
operator|=
literal|0xff
expr_stmt|;
break|break;
case|case
name|CLUST32_MASK
case|:
operator|*
name|p
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0xff
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0xff
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0xff
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x0f
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* use same FAT signature as the old FAT has */
name|int
name|count
decl_stmt|;
name|u_char
modifier|*
name|old_fat
decl_stmt|;
switch|switch
condition|(
name|boot
operator|->
name|ClustMask
condition|)
block|{
case|case
name|CLUST32_MASK
case|:
name|count
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|CLUST16_MASK
case|:
name|count
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|count
operator|=
literal|3
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|_readfat
argument_list|(
name|fs
argument_list|,
name|boot
argument_list|,
name|boot
operator|->
name|ValidFat
operator|>=
literal|0
condition|?
name|boot
operator|->
name|ValidFat
else|:
literal|0
argument_list|,
operator|&
name|old_fat
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|old_fat
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|old_fat
argument_list|)
expr_stmt|;
name|p
operator|+=
name|count
expr_stmt|;
block|}
for|for
control|(
name|cl
operator|=
name|CLUST_FIRST
init|;
name|cl
operator|<
name|boot
operator|->
name|NumClusters
condition|;
name|cl
operator|++
control|)
block|{
switch|switch
condition|(
name|boot
operator|->
name|ClustMask
condition|)
block|{
case|case
name|CLUST32_MASK
case|:
if|if
condition|(
name|fat
index|[
name|cl
index|]
operator|.
name|next
operator|==
name|CLUST_FREE
condition|)
name|boot
operator|->
name|NumFree
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|u_char
operator|)
name|fat
index|[
name|cl
index|]
operator|.
name|next
expr_stmt|;
operator|*
name|p
operator|++
operator|=
call|(
name|u_char
call|)
argument_list|(
name|fat
index|[
name|cl
index|]
operator|.
name|next
operator|>>
literal|8
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
call|(
name|u_char
call|)
argument_list|(
name|fat
index|[
name|cl
index|]
operator|.
name|next
operator|>>
literal|16
argument_list|)
expr_stmt|;
operator|*
name|p
operator|&=
literal|0xf0
expr_stmt|;
operator|*
name|p
operator|++
operator||=
operator|(
name|fat
index|[
name|cl
index|]
operator|.
name|next
operator|>>
literal|24
operator|)
operator|&
literal|0x0f
expr_stmt|;
break|break;
case|case
name|CLUST16_MASK
case|:
if|if
condition|(
name|fat
index|[
name|cl
index|]
operator|.
name|next
operator|==
name|CLUST_FREE
condition|)
name|boot
operator|->
name|NumFree
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|u_char
operator|)
name|fat
index|[
name|cl
index|]
operator|.
name|next
expr_stmt|;
operator|*
name|p
operator|++
operator|=
call|(
name|u_char
call|)
argument_list|(
name|fat
index|[
name|cl
index|]
operator|.
name|next
operator|>>
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|fat
index|[
name|cl
index|]
operator|.
name|next
operator|==
name|CLUST_FREE
condition|)
name|boot
operator|->
name|NumFree
operator|++
expr_stmt|;
if|if
condition|(
name|cl
operator|+
literal|1
operator|<
name|boot
operator|->
name|NumClusters
operator|&&
name|fat
index|[
name|cl
operator|+
literal|1
index|]
operator|.
name|next
operator|==
name|CLUST_FREE
condition|)
name|boot
operator|->
name|NumFree
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|u_char
operator|)
name|fat
index|[
name|cl
index|]
operator|.
name|next
expr_stmt|;
operator|*
name|p
operator|++
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|fat
index|[
name|cl
index|]
operator|.
name|next
operator|>>
literal|8
operator|)
operator|&
literal|0xf
argument_list|)
operator||
call|(
name|u_char
call|)
argument_list|(
name|fat
index|[
name|cl
operator|+
literal|1
index|]
operator|.
name|next
operator|<<
literal|4
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
call|(
name|u_char
call|)
argument_list|(
name|fat
index|[
operator|++
name|cl
index|]
operator|.
name|next
operator|>>
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|boot
operator|->
name|FATs
condition|;
name|i
operator|++
control|)
block|{
name|off
operator|=
name|boot
operator|->
name|ResSectors
operator|+
name|i
operator|*
name|boot
operator|->
name|FATsecs
expr_stmt|;
name|off
operator|*=
name|boot
operator|->
name|BytesPerSec
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fs
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|off
operator|||
name|write
argument_list|(
name|fs
argument_list|,
name|buffer
argument_list|,
name|fatsz
argument_list|)
operator|!=
name|fatsz
condition|)
block|{
name|perror
argument_list|(
literal|"Unable to write FAT"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FSFATAL
expr_stmt|;
comment|/* Return immediately?		XXX */
block|}
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Check a complete in-memory FAT for lost cluster chains  */
end_comment

begin_function
name|int
name|checklost
parameter_list|(
name|int
name|dosfs
parameter_list|,
name|struct
name|bootblock
modifier|*
name|boot
parameter_list|,
name|struct
name|fatEntry
modifier|*
name|fat
parameter_list|)
block|{
name|cl_t
name|head
decl_stmt|;
name|int
name|mod
init|=
name|FSOK
decl_stmt|;
name|int
name|ret
decl_stmt|;
for|for
control|(
name|head
operator|=
name|CLUST_FIRST
init|;
name|head
operator|<
name|boot
operator|->
name|NumClusters
condition|;
name|head
operator|++
control|)
block|{
comment|/* find next untravelled chain */
if|if
condition|(
name|fat
index|[
name|head
index|]
operator|.
name|head
operator|!=
name|head
operator|||
name|fat
index|[
name|head
index|]
operator|.
name|next
operator|==
name|CLUST_FREE
operator|||
operator|(
name|fat
index|[
name|head
index|]
operator|.
name|next
operator|>=
name|CLUST_RSRVD
operator|&&
name|fat
index|[
name|head
index|]
operator|.
name|next
operator|<
name|CLUST_EOFS
operator|)
operator|||
operator|(
name|fat
index|[
name|head
index|]
operator|.
name|flags
operator|&
name|FAT_USED
operator|)
condition|)
continue|continue;
name|pwarn
argument_list|(
literal|"Lost cluster chain at cluster %u\n%d Cluster(s) lost\n"
argument_list|,
name|head
argument_list|,
name|fat
index|[
name|head
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|mod
operator||=
name|ret
operator|=
name|reconnect
argument_list|(
name|dosfs
argument_list|,
name|boot
argument_list|,
name|fat
argument_list|,
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod
operator|&
name|FSFATAL
condition|)
break|break;
if|if
condition|(
name|ret
operator|==
name|FSERROR
operator|&&
name|ask
argument_list|(
literal|0
argument_list|,
literal|"Clear"
argument_list|)
condition|)
block|{
name|clearchain
argument_list|(
name|boot
argument_list|,
name|fat
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|mod
operator||=
name|FSFATMOD
expr_stmt|;
block|}
block|}
name|finishlf
argument_list|()
expr_stmt|;
if|if
condition|(
name|boot
operator|->
name|FSInfo
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|boot
operator|->
name|FSFree
operator|!=
name|boot
operator|->
name|NumFree
condition|)
block|{
name|pwarn
argument_list|(
literal|"Free space in FSInfo block (%d) not correct (%d)\n"
argument_list|,
name|boot
operator|->
name|FSFree
argument_list|,
name|boot
operator|->
name|NumFree
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|1
argument_list|,
literal|"fix"
argument_list|)
condition|)
block|{
name|boot
operator|->
name|FSFree
operator|=
name|boot
operator|->
name|NumFree
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|boot
operator|->
name|NumFree
operator|&&
name|fat
index|[
name|boot
operator|->
name|FSNext
index|]
operator|.
name|next
operator|!=
name|CLUST_FREE
condition|)
block|{
name|pwarn
argument_list|(
literal|"Next free cluster in FSInfo block (%u) not free\n"
argument_list|,
name|boot
operator|->
name|FSNext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|1
argument_list|,
literal|"fix"
argument_list|)
condition|)
for|for
control|(
name|head
operator|=
name|CLUST_FIRST
init|;
name|head
operator|<
name|boot
operator|->
name|NumClusters
condition|;
name|head
operator|++
control|)
if|if
condition|(
name|fat
index|[
name|head
index|]
operator|.
name|next
operator|==
name|CLUST_FREE
condition|)
block|{
name|boot
operator|->
name|FSNext
operator|=
name|head
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ret
condition|)
name|mod
operator||=
name|writefsinfo
argument_list|(
name|dosfs
argument_list|,
name|boot
argument_list|)
expr_stmt|;
block|}
return|return
name|mod
return|;
block|}
end_function

end_unit

