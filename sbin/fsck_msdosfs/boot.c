begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1995, 1997 Wolfgang Solfrank  * Copyright (c) 1995 Martin Husemann  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: boot.c,v 1.11 2006/06/05 16:51:18 christos Exp "
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"ext.h"
end_include

begin_include
include|#
directive|include
file|"fsutil.h"
end_include

begin_function
name|int
name|readboot
parameter_list|(
name|int
name|dosfs
parameter_list|,
name|struct
name|bootblock
modifier|*
name|boot
parameter_list|)
block|{
name|u_char
name|block
index|[
name|DOSBOOTBLOCKSIZE
index|]
decl_stmt|;
name|u_char
name|fsinfo
index|[
literal|2
operator|*
name|DOSBOOTBLOCKSIZE
index|]
decl_stmt|;
name|u_char
name|backup
index|[
name|DOSBOOTBLOCKSIZE
index|]
decl_stmt|;
name|int
name|ret
init|=
name|FSOK
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|read
argument_list|(
name|dosfs
argument_list|,
name|block
argument_list|,
sizeof|sizeof
name|block
argument_list|)
operator|!=
sizeof|sizeof
name|block
condition|)
block|{
name|perr
argument_list|(
literal|"could not read boot block"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
if|if
condition|(
name|block
index|[
literal|510
index|]
operator|!=
literal|0x55
operator|||
name|block
index|[
literal|511
index|]
operator|!=
literal|0xaa
condition|)
block|{
name|pfatal
argument_list|(
literal|"Invalid signature in boot block: %02x%02x"
argument_list|,
name|block
index|[
literal|511
index|]
argument_list|,
name|block
index|[
literal|510
index|]
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
name|memset
argument_list|(
name|boot
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|boot
argument_list|)
expr_stmt|;
name|boot
operator|->
name|ValidFat
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* decode bios parameter block */
name|boot
operator|->
name|bpbBytesPerSec
operator|=
name|block
index|[
literal|11
index|]
operator|+
operator|(
name|block
index|[
literal|12
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|boot
operator|->
name|bpbSecPerClust
operator|=
name|block
index|[
literal|13
index|]
expr_stmt|;
name|boot
operator|->
name|bpbResSectors
operator|=
name|block
index|[
literal|14
index|]
operator|+
operator|(
name|block
index|[
literal|15
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|boot
operator|->
name|bpbFATs
operator|=
name|block
index|[
literal|16
index|]
expr_stmt|;
name|boot
operator|->
name|bpbRootDirEnts
operator|=
name|block
index|[
literal|17
index|]
operator|+
operator|(
name|block
index|[
literal|18
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|boot
operator|->
name|bpbSectors
operator|=
name|block
index|[
literal|19
index|]
operator|+
operator|(
name|block
index|[
literal|20
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|boot
operator|->
name|bpbMedia
operator|=
name|block
index|[
literal|21
index|]
expr_stmt|;
name|boot
operator|->
name|bpbFATsmall
operator|=
name|block
index|[
literal|22
index|]
operator|+
operator|(
name|block
index|[
literal|23
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|boot
operator|->
name|SecPerTrack
operator|=
name|block
index|[
literal|24
index|]
operator|+
operator|(
name|block
index|[
literal|25
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|boot
operator|->
name|bpbHeads
operator|=
name|block
index|[
literal|26
index|]
operator|+
operator|(
name|block
index|[
literal|27
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|boot
operator|->
name|bpbHiddenSecs
operator|=
name|block
index|[
literal|28
index|]
operator|+
operator|(
name|block
index|[
literal|29
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|block
index|[
literal|30
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|block
index|[
literal|31
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|boot
operator|->
name|bpbHugeSectors
operator|=
name|block
index|[
literal|32
index|]
operator|+
operator|(
name|block
index|[
literal|33
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|block
index|[
literal|34
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|block
index|[
literal|35
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|boot
operator|->
name|FATsecs
operator|=
name|boot
operator|->
name|bpbFATsmall
expr_stmt|;
if|if
condition|(
operator|!
name|boot
operator|->
name|bpbRootDirEnts
condition|)
name|boot
operator|->
name|flags
operator||=
name|FAT32
expr_stmt|;
if|if
condition|(
name|boot
operator|->
name|flags
operator|&
name|FAT32
condition|)
block|{
name|boot
operator|->
name|FATsecs
operator|=
name|block
index|[
literal|36
index|]
operator|+
operator|(
name|block
index|[
literal|37
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|block
index|[
literal|38
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|block
index|[
literal|39
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
if|if
condition|(
name|block
index|[
literal|40
index|]
operator|&
literal|0x80
condition|)
name|boot
operator|->
name|ValidFat
operator|=
name|block
index|[
literal|40
index|]
operator|&
literal|0x0f
expr_stmt|;
comment|/* check version number: */
if|if
condition|(
name|block
index|[
literal|42
index|]
operator|||
name|block
index|[
literal|43
index|]
condition|)
block|{
comment|/* Correct?				XXX */
name|pfatal
argument_list|(
literal|"Unknown file system version: %x.%x"
argument_list|,
name|block
index|[
literal|43
index|]
argument_list|,
name|block
index|[
literal|42
index|]
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
name|boot
operator|->
name|bpbRootClust
operator|=
name|block
index|[
literal|44
index|]
operator|+
operator|(
name|block
index|[
literal|45
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|block
index|[
literal|46
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|block
index|[
literal|47
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|boot
operator|->
name|bpbFSInfo
operator|=
name|block
index|[
literal|48
index|]
operator|+
operator|(
name|block
index|[
literal|49
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|boot
operator|->
name|bpbBackup
operator|=
name|block
index|[
literal|50
index|]
operator|+
operator|(
name|block
index|[
literal|51
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|dosfs
argument_list|,
name|boot
operator|->
name|bpbFSInfo
operator|*
name|boot
operator|->
name|bpbBytesPerSec
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|boot
operator|->
name|bpbFSInfo
operator|*
name|boot
operator|->
name|bpbBytesPerSec
operator|||
name|read
argument_list|(
name|dosfs
argument_list|,
name|fsinfo
argument_list|,
sizeof|sizeof
name|fsinfo
argument_list|)
operator|!=
sizeof|sizeof
name|fsinfo
condition|)
block|{
name|perr
argument_list|(
literal|"could not read fsinfo block"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|fsinfo
argument_list|,
literal|"RRaA"
argument_list|,
literal|4
argument_list|)
operator|||
name|memcmp
argument_list|(
name|fsinfo
operator|+
literal|0x1e4
argument_list|,
literal|"rrAa"
argument_list|,
literal|4
argument_list|)
operator|||
name|fsinfo
index|[
literal|0x1fc
index|]
operator|||
name|fsinfo
index|[
literal|0x1fd
index|]
operator|||
name|fsinfo
index|[
literal|0x1fe
index|]
operator|!=
literal|0x55
operator|||
name|fsinfo
index|[
literal|0x1ff
index|]
operator|!=
literal|0xaa
operator|||
name|fsinfo
index|[
literal|0x3fc
index|]
operator|||
name|fsinfo
index|[
literal|0x3fd
index|]
operator|||
name|fsinfo
index|[
literal|0x3fe
index|]
operator|!=
literal|0x55
operator|||
name|fsinfo
index|[
literal|0x3ff
index|]
operator|!=
literal|0xaa
condition|)
block|{
name|pwarn
argument_list|(
literal|"Invalid signature in fsinfo block\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|0
argument_list|,
literal|"Fix"
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|fsinfo
argument_list|,
literal|"RRaA"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fsinfo
operator|+
literal|0x1e4
argument_list|,
literal|"rrAa"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fsinfo
index|[
literal|0x1fc
index|]
operator|=
name|fsinfo
index|[
literal|0x1fd
index|]
operator|=
literal|0
expr_stmt|;
name|fsinfo
index|[
literal|0x1fe
index|]
operator|=
literal|0x55
expr_stmt|;
name|fsinfo
index|[
literal|0x1ff
index|]
operator|=
literal|0xaa
expr_stmt|;
name|fsinfo
index|[
literal|0x3fc
index|]
operator|=
name|fsinfo
index|[
literal|0x3fd
index|]
operator|=
literal|0
expr_stmt|;
name|fsinfo
index|[
literal|0x3fe
index|]
operator|=
literal|0x55
expr_stmt|;
name|fsinfo
index|[
literal|0x3ff
index|]
operator|=
literal|0xaa
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|dosfs
argument_list|,
name|boot
operator|->
name|bpbFSInfo
operator|*
name|boot
operator|->
name|bpbBytesPerSec
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|boot
operator|->
name|bpbFSInfo
operator|*
name|boot
operator|->
name|bpbBytesPerSec
operator|||
name|write
argument_list|(
name|dosfs
argument_list|,
name|fsinfo
argument_list|,
sizeof|sizeof
name|fsinfo
argument_list|)
operator|!=
sizeof|sizeof
name|fsinfo
condition|)
block|{
name|perr
argument_list|(
literal|"Unable to write bpbFSInfo"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
name|ret
operator|=
name|FSBOOTMOD
expr_stmt|;
block|}
else|else
name|boot
operator|->
name|bpbFSInfo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|boot
operator|->
name|bpbFSInfo
condition|)
block|{
name|boot
operator|->
name|FSFree
operator|=
name|fsinfo
index|[
literal|0x1e8
index|]
operator|+
operator|(
name|fsinfo
index|[
literal|0x1e9
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|fsinfo
index|[
literal|0x1ea
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|fsinfo
index|[
literal|0x1eb
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|boot
operator|->
name|FSNext
operator|=
name|fsinfo
index|[
literal|0x1ec
index|]
operator|+
operator|(
name|fsinfo
index|[
literal|0x1ed
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|fsinfo
index|[
literal|0x1ee
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|fsinfo
index|[
literal|0x1ef
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|dosfs
argument_list|,
name|boot
operator|->
name|bpbBackup
operator|*
name|boot
operator|->
name|bpbBytesPerSec
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|boot
operator|->
name|bpbBackup
operator|*
name|boot
operator|->
name|bpbBytesPerSec
operator|||
name|read
argument_list|(
name|dosfs
argument_list|,
name|backup
argument_list|,
sizeof|sizeof
name|backup
argument_list|)
operator|!=
sizeof|sizeof
name|backup
condition|)
block|{
name|perr
argument_list|(
literal|"could not read backup bootblock"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
name|backup
index|[
literal|65
index|]
operator|=
name|block
index|[
literal|65
index|]
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|memcmp
argument_list|(
name|block
operator|+
literal|11
argument_list|,
name|backup
operator|+
literal|11
argument_list|,
literal|79
argument_list|)
condition|)
block|{
comment|/* 			 * XXX We require a reference that explains 			 * that these bytes need to match, or should 			 * drop the check.  gdt@NetBSD has observed 			 * filesystems that work fine under Windows XP 			 * and NetBSD that do not match, so the 			 * requirement is suspect.  For now, just 			 * print out useful information and continue. 			 */
name|pfatal
argument_list|(
literal|"backup (block %d) mismatch with primary bootblock:\n"
argument_list|,
name|boot
operator|->
name|bpbBackup
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|11
init|;
name|i
operator|<
literal|11
operator|+
literal|90
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|block
index|[
name|i
index|]
operator|!=
name|backup
index|[
name|i
index|]
condition|)
name|pfatal
argument_list|(
literal|"\ti=%d\tprimary 0x%02x\tbackup 0x%02x\n"
argument_list|,
name|i
argument_list|,
name|block
index|[
name|i
index|]
argument_list|,
name|backup
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check backup bpbFSInfo?					XXX */
block|}
name|boot
operator|->
name|ClusterOffset
operator|=
operator|(
name|boot
operator|->
name|bpbRootDirEnts
operator|*
literal|32
operator|+
name|boot
operator|->
name|bpbBytesPerSec
operator|-
literal|1
operator|)
operator|/
name|boot
operator|->
name|bpbBytesPerSec
operator|+
name|boot
operator|->
name|bpbResSectors
operator|+
name|boot
operator|->
name|bpbFATs
operator|*
name|boot
operator|->
name|FATsecs
operator|-
name|CLUST_FIRST
operator|*
name|boot
operator|->
name|bpbSecPerClust
expr_stmt|;
if|if
condition|(
name|boot
operator|->
name|bpbBytesPerSec
operator|%
name|DOSBOOTBLOCKSIZE_REAL
operator|!=
literal|0
condition|)
block|{
name|pfatal
argument_list|(
literal|"Invalid sector size: %u"
argument_list|,
name|boot
operator|->
name|bpbBytesPerSec
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
if|if
condition|(
name|boot
operator|->
name|bpbSecPerClust
operator|==
literal|0
condition|)
block|{
name|pfatal
argument_list|(
literal|"Invalid cluster size: %u"
argument_list|,
name|boot
operator|->
name|bpbSecPerClust
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
if|if
condition|(
name|boot
operator|->
name|bpbSectors
condition|)
block|{
name|boot
operator|->
name|bpbHugeSectors
operator|=
literal|0
expr_stmt|;
name|boot
operator|->
name|NumSectors
operator|=
name|boot
operator|->
name|bpbSectors
expr_stmt|;
block|}
else|else
name|boot
operator|->
name|NumSectors
operator|=
name|boot
operator|->
name|bpbHugeSectors
expr_stmt|;
name|boot
operator|->
name|NumClusters
operator|=
operator|(
name|boot
operator|->
name|NumSectors
operator|-
name|boot
operator|->
name|ClusterOffset
operator|)
operator|/
name|boot
operator|->
name|bpbSecPerClust
expr_stmt|;
if|if
condition|(
name|boot
operator|->
name|flags
operator|&
name|FAT32
condition|)
name|boot
operator|->
name|ClustMask
operator|=
name|CLUST32_MASK
expr_stmt|;
elseif|else
if|if
condition|(
name|boot
operator|->
name|NumClusters
operator|<
operator|(
name|CLUST_RSRVD
operator|&
name|CLUST12_MASK
operator|)
condition|)
name|boot
operator|->
name|ClustMask
operator|=
name|CLUST12_MASK
expr_stmt|;
elseif|else
if|if
condition|(
name|boot
operator|->
name|NumClusters
operator|<
operator|(
name|CLUST_RSRVD
operator|&
name|CLUST16_MASK
operator|)
condition|)
name|boot
operator|->
name|ClustMask
operator|=
name|CLUST16_MASK
expr_stmt|;
else|else
block|{
name|pfatal
argument_list|(
literal|"Filesystem too big (%u clusters) for non-FAT32 partition"
argument_list|,
name|boot
operator|->
name|NumClusters
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
switch|switch
condition|(
name|boot
operator|->
name|ClustMask
condition|)
block|{
case|case
name|CLUST32_MASK
case|:
name|boot
operator|->
name|NumFatEntries
operator|=
operator|(
name|boot
operator|->
name|FATsecs
operator|*
name|boot
operator|->
name|bpbBytesPerSec
operator|)
operator|/
literal|4
expr_stmt|;
break|break;
case|case
name|CLUST16_MASK
case|:
name|boot
operator|->
name|NumFatEntries
operator|=
operator|(
name|boot
operator|->
name|FATsecs
operator|*
name|boot
operator|->
name|bpbBytesPerSec
operator|)
operator|/
literal|2
expr_stmt|;
break|break;
default|default:
name|boot
operator|->
name|NumFatEntries
operator|=
operator|(
name|boot
operator|->
name|FATsecs
operator|*
name|boot
operator|->
name|bpbBytesPerSec
operator|*
literal|2
operator|)
operator|/
literal|3
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|boot
operator|->
name|NumFatEntries
operator|<
name|boot
operator|->
name|NumClusters
operator|-
name|CLUST_FIRST
condition|)
block|{
name|pfatal
argument_list|(
literal|"FAT size too small, %u entries won't fit into %u sectors\n"
argument_list|,
name|boot
operator|->
name|NumClusters
argument_list|,
name|boot
operator|->
name|FATsecs
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
name|boot
operator|->
name|ClusterSize
operator|=
name|boot
operator|->
name|bpbBytesPerSec
operator|*
name|boot
operator|->
name|bpbSecPerClust
expr_stmt|;
name|boot
operator|->
name|NumFiles
operator|=
literal|1
expr_stmt|;
name|boot
operator|->
name|NumFree
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|writefsinfo
parameter_list|(
name|int
name|dosfs
parameter_list|,
name|struct
name|bootblock
modifier|*
name|boot
parameter_list|)
block|{
name|u_char
name|fsinfo
index|[
literal|2
operator|*
name|DOSBOOTBLOCKSIZE
index|]
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|dosfs
argument_list|,
name|boot
operator|->
name|bpbFSInfo
operator|*
name|boot
operator|->
name|bpbBytesPerSec
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|boot
operator|->
name|bpbFSInfo
operator|*
name|boot
operator|->
name|bpbBytesPerSec
operator|||
name|read
argument_list|(
name|dosfs
argument_list|,
name|fsinfo
argument_list|,
sizeof|sizeof
name|fsinfo
argument_list|)
operator|!=
sizeof|sizeof
name|fsinfo
condition|)
block|{
name|perr
argument_list|(
literal|"could not read fsinfo block"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
name|fsinfo
index|[
literal|0x1e8
index|]
operator|=
operator|(
name|u_char
operator|)
name|boot
operator|->
name|FSFree
expr_stmt|;
name|fsinfo
index|[
literal|0x1e9
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|boot
operator|->
name|FSFree
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|fsinfo
index|[
literal|0x1ea
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|boot
operator|->
name|FSFree
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|fsinfo
index|[
literal|0x1eb
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|boot
operator|->
name|FSFree
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|fsinfo
index|[
literal|0x1ec
index|]
operator|=
operator|(
name|u_char
operator|)
name|boot
operator|->
name|FSNext
expr_stmt|;
name|fsinfo
index|[
literal|0x1ed
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|boot
operator|->
name|FSNext
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|fsinfo
index|[
literal|0x1ee
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|boot
operator|->
name|FSNext
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|fsinfo
index|[
literal|0x1ef
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|boot
operator|->
name|FSNext
operator|>>
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|dosfs
argument_list|,
name|boot
operator|->
name|bpbFSInfo
operator|*
name|boot
operator|->
name|bpbBytesPerSec
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|boot
operator|->
name|bpbFSInfo
operator|*
name|boot
operator|->
name|bpbBytesPerSec
operator|||
name|write
argument_list|(
name|dosfs
argument_list|,
name|fsinfo
argument_list|,
sizeof|sizeof
name|fsinfo
argument_list|)
operator|!=
sizeof|sizeof
name|fsinfo
condition|)
block|{
name|perr
argument_list|(
literal|"Unable to write bpbFSInfo"
argument_list|)
expr_stmt|;
return|return
name|FSFATAL
return|;
block|}
comment|/* 	 * Technically, we should return FSBOOTMOD here. 	 * 	 * However, since Win95 OSR2 (the first M$ OS that has 	 * support for FAT32) doesn't maintain the FSINFO block 	 * correctly, it has to be fixed pretty often. 	 * 	 * Therefor, we handle the FSINFO block only informally, 	 * fixing it if necessary, but otherwise ignoring the 	 * fact that it was incorrect. 	 */
return|return
literal|0
return|;
block|}
end_function

end_unit

