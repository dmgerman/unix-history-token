begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * User configuration and display program  * --------------------------------------  *  * Main routine  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sigmgr.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libatm.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"atm.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Usage string  */
end_comment

begin_define
define|#
directive|define
name|USAGE_STR
value|"Interface management subcommands:\n\     attach<intf><protocol>\n\     detach<intf>\n\     set mac<intf><MAC/ESI address>\n\     set netif<intf><prefix><n>\n\     set prefix<intf><NSAP prefix>\n\     show config<intf>]\n\     show interface<intf>]\n\     show netif<netif>]\n\     show stats interface<intf> phy | dev | atm | aal0 | aal4 |\n\         aal5 | driver]\n\ \n\ VC management subcommands:\n\     add<intf><vpi><vci><aal><encaps><owner> ...\n\     delete pvc<intf><vpi><vci>\n\     delete svc<intf><vpi><vci>\n\     show stats vcc<intf> [vpi [vci]]]\n\     show vcc<intf> [<vpi> [<vci>] | SVC | PVC]]\n\ \n\ IP management subcommands:\n\     add ar<netif>]<IP addr><ATM addr>\n\     add pvc<intf><vpi><vci><aal><encaps> IP<netif><IP addr> |\n\         dynamic\n\     delete arp<netif>]<IP addr>\n\     set arpserver<netif><server><IP prefix> ...\n\     show arp<host>]\n\     show arpserver<netif>]\n\     show ipvcc<IP addr> |<netif>]\n\ \n\ Miscellaneous subcommands:\n\     help\n\     show version\n"
end_define

begin_comment
comment|/*  * Local definitions  */
end_comment

begin_decl_stmt
name|struct
name|cmd
name|add_subcmd
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd
name|dlt_subcmd
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd
name|set_subcmd
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd
name|show_subcmd
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd
name|stats_subcmd
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd
name|cmds
index|[]
init|=
block|{
block|{
literal|"add"
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|add_subcmd
block|}
block|,
block|{
literal|"attach"
block|,
literal|2
block|,
literal|2
block|,
name|attach
block|,
literal|"<intf><protocol>"
block|}
block|,
block|{
literal|"delete"
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|dlt_subcmd
block|}
block|,
block|{
literal|"detach"
block|,
literal|1
block|,
literal|1
block|,
name|detach
block|,
literal|"<intf>"
block|}
block|,
block|{
literal|"set"
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|set_subcmd
block|}
block|,
block|{
literal|"show"
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|show_subcmd
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
literal|99
block|,
name|help
block|,
literal|""
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd
name|add_subcmd
index|[]
init|=
block|{
block|{
literal|"arp"
block|,
literal|2
block|,
literal|3
block|,
name|arp_add
block|,
literal|"[<netif>]<IP addr><ATM addr>"
block|}
block|,
block|{
literal|"pvc"
block|,
literal|6
block|,
literal|12
block|,
name|pvc_add
block|,
literal|"<intf><vpi><vci><aal><encaps><owner> ..."
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd
name|dlt_subcmd
index|[]
init|=
block|{
block|{
literal|"arp"
block|,
literal|1
block|,
literal|2
block|,
name|arp_dlt
block|,
literal|"[<netif>]<IP addr>"
block|}
block|,
block|{
literal|"pvc"
block|,
literal|3
block|,
literal|3
block|,
name|pvc_dlt
block|,
literal|"<intf><vpi><vci>"
block|}
block|,
block|{
literal|"svc"
block|,
literal|3
block|,
literal|3
block|,
name|svc_dlt
block|,
literal|"<intf><vpi><vci>"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd
name|set_subcmd
index|[]
init|=
block|{
block|{
literal|"arpserver"
block|,
literal|2
block|,
literal|18
block|,
name|set_arpserver
block|,
literal|"<netif><server>"
block|}
block|,
block|{
literal|"mac"
block|,
literal|2
block|,
literal|2
block|,
name|set_macaddr
block|,
literal|"<intf><MAC/ESI address>"
block|}
block|,
block|{
literal|"netif"
block|,
literal|3
block|,
literal|3
block|,
name|set_netif
block|,
literal|"<intf><prefix><n>"
block|}
block|,
block|{
literal|"prefix"
block|,
literal|2
block|,
literal|2
block|,
name|set_prefix
block|,
literal|"<intf><NSAP prefix>"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd
name|show_subcmd
index|[]
init|=
block|{
block|{
literal|"arp"
block|,
literal|0
block|,
literal|1
block|,
name|show_arp
block|,
literal|"[<host>]"
block|}
block|,
block|{
literal|"arpserver"
block|,
literal|0
block|,
literal|1
block|,
name|show_arpserv
block|,
literal|"[<netif>]"
block|}
block|,
block|{
literal|"config"
block|,
literal|0
block|,
literal|1
block|,
name|show_config
block|,
literal|"[<intf>]"
block|}
block|,
block|{
literal|"interface"
block|,
literal|0
block|,
literal|1
block|,
name|show_intf
block|,
literal|"[<intf>]"
block|}
block|,
block|{
literal|"ipvcc"
block|,
literal|0
block|,
literal|3
block|,
name|show_ip_vcc
block|,
literal|"[<IP addr> |<netif>]"
block|}
block|,
block|{
literal|"netif"
block|,
literal|0
block|,
literal|1
block|,
name|show_netif
block|,
literal|"[<netif>]"
block|}
block|,
block|{
literal|"stats"
block|,
literal|0
block|,
literal|3
block|,
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|stats_subcmd
block|}
block|,
block|{
literal|"vcc"
block|,
literal|0
block|,
literal|3
block|,
name|show_vcc
block|,
literal|"[<intf>] [<vpi> [<vci>] | SVC | PVC]"
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
name|show_version
block|,
literal|""
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd
name|stats_subcmd
index|[]
init|=
block|{
block|{
literal|"interface"
block|,
literal|0
block|,
literal|2
block|,
name|show_intf_stats
block|,
literal|"[<intf> [cfg | phy | dev | atm | aal0 | aal4 | aal5 | driver]]"
block|}
block|,
block|{
literal|"vcc"
block|,
literal|0
block|,
literal|3
block|,
name|show_vcc_stats
block|,
literal|"[<intf> [vpi [vci]]]"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Supported signalling protocols  */
end_comment

begin_decl_stmt
name|struct
name|proto
name|protos
index|[]
init|=
block|{
block|{
literal|"SIGPVC"
block|,
name|ATM_SIG_PVC
block|}
block|,
block|{
literal|"SPANS"
block|,
name|ATM_SIG_SPANS
block|}
block|,
block|{
literal|"UNI30"
block|,
name|ATM_SIG_UNI30
block|}
block|,
block|{
literal|"UNI31"
block|,
name|ATM_SIG_UNI31
block|}
block|,
block|{
literal|"UNI40"
block|,
name|ATM_SIG_UNI40
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Supported VCC owners  */
end_comment

begin_decl_stmt
name|struct
name|owner
name|owners
index|[]
init|=
block|{
block|{
literal|"IP"
block|,
name|ENDPT_IP
block|,
name|ip_pvcadd
block|}
block|,
block|{
literal|"SPANS"
block|,
name|ENDPT_SPANS_SIG
block|,
literal|0
block|}
block|,
block|{
literal|"SPANS CLS"
block|,
name|ENDPT_SPANS_CLS
block|,
literal|0
block|}
block|,
block|{
literal|"UNI SIG"
block|,
name|ENDPT_UNI_SIG
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Supported AAL parameters  */
end_comment

begin_decl_stmt
name|struct
name|aal
name|aals
index|[]
init|=
block|{
block|{
literal|"Null"
block|,
name|ATM_AAL0
block|}
block|,
block|{
literal|"AAL0"
block|,
name|ATM_AAL0
block|}
block|,
block|{
literal|"AAL1"
block|,
name|ATM_AAL1
block|}
block|,
block|{
literal|"AAL2"
block|,
name|ATM_AAL2
block|}
block|,
block|{
literal|"AAL4"
block|,
name|ATM_AAL3_4
block|}
block|,
block|{
literal|"AAL3"
block|,
name|ATM_AAL3_4
block|}
block|,
block|{
literal|"AAL3/4"
block|,
name|ATM_AAL3_4
block|}
block|,
block|{
literal|"AAL5"
block|,
name|ATM_AAL5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Supported VCC encapsulations  */
end_comment

begin_decl_stmt
name|struct
name|encaps
name|encaps
index|[]
init|=
block|{
block|{
literal|"Null"
block|,
name|ATM_ENC_NULL
block|}
block|,
block|{
literal|"None"
block|,
name|ATM_ENC_NULL
block|}
block|,
block|{
literal|"LLC/SNAP"
block|,
name|ATM_ENC_LLC
block|}
block|,
block|{
literal|"LLC"
block|,
name|ATM_ENC_LLC
block|}
block|,
block|{
literal|"SNAP"
block|,
name|ATM_ENC_LLC
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|prefix
index|[
literal|128
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * Save program name, ignoring any path components 	 */
if|if
condition|(
operator|(
name|prog
operator|=
operator|(
name|char
operator|*
operator|)
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|prog
operator|++
expr_stmt|;
else|else
name|prog
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|usage
argument_list|(
name|cmds
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* 	 * Validate and process command 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|do_cmd
argument_list|(
name|cmds
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|usage
argument_list|(
name|cmds
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Validate and process user command  *   * Arguments:  *	descp	pointer to command description array  *	argc	number of arguments left in command  *	argv	pointer to argument strings  *  * Returns:  *	none  *  */
end_comment

begin_function
name|int
name|do_cmd
parameter_list|(
name|descp
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|struct
name|cmd
modifier|*
name|descp
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|cmd
modifier|*
name|cmdp
init|=
literal|0
decl_stmt|;
comment|/* 	 * Make sure we have paramaters to process 	 */
if|if
condition|(
operator|!
name|argc
condition|)
block|{
name|usage
argument_list|(
name|cmds
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Figure out what command user wants 	 */
for|for
control|(
init|;
name|descp
operator|->
name|name
condition|;
name|descp
operator|++
control|)
block|{
comment|/* 		 * Use an exact match if there is one 		 */
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|descp
operator|->
name|name
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|cmdp
operator|=
name|descp
expr_stmt|;
break|break;
block|}
comment|/* 		 * Look for a match on the first part of keyword 		 */
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|descp
operator|->
name|name
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|cmdp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Ambiguous parameter \"%s\"\n"
argument_list|,
name|prog
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cmdp
operator|=
name|descp
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|cmdp
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* 	 * See if this command has subcommands 	 */
if|if
condition|(
name|cmdp
operator|->
name|func
operator|==
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|prefix
argument_list|,
name|cmdp
operator|->
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|prefix
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
return|return
operator|(
name|do_cmd
argument_list|(
operator|(
expr|struct
name|cmd
operator|*
operator|)
name|cmdp
operator|->
name|help
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Minimal validation 	 */
if|if
condition|(
operator|(
name|argc
operator|<
name|cmdp
operator|->
name|minp
operator|)
operator|||
operator|(
name|argc
operator|>
name|cmdp
operator|->
name|maxp
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Invalid number of arguments\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tformat is: %s%s %s\n"
argument_list|,
name|prefix
argument_list|,
name|cmdp
operator|->
name|name
argument_list|,
name|cmdp
operator|->
name|help
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Process command 	 */
call|(
modifier|*
name|cmdp
operator|->
name|func
call|)
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|cmdp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print command usage information  *   * Arguments:  *	cmdp	pointer to command description   * 	pref	pointer current command prefix   *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|usage
parameter_list|(
name|cmdp
parameter_list|,
name|pref
parameter_list|)
name|struct
name|cmd
modifier|*
name|cmdp
decl_stmt|;
name|char
modifier|*
name|pref
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s command [arg] [arg]...\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|USAGE_STR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process interface attach command  *   * Command format:   *	atm attach<interface_name><protocol_name>  *  * Arguments:  *	argc	number of arguments to command  *	argv	pointer to argument strings  *	cmdp	pointer to command description   *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|attach
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|cmdp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|struct
name|cmd
modifier|*
name|cmdp
decl_stmt|;
block|{
name|struct
name|atmcfgreq
name|aar
decl_stmt|;
name|struct
name|proto
modifier|*
name|prp
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Validate interface name 	 */
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|aar
operator|.
name|acr_att_intf
argument_list|)
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Illegal interface name\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find/validate requested signalling protocol 	 */
for|for
control|(
name|prp
operator|=
name|protos
init|;
name|prp
operator|->
name|p_name
condition|;
name|prp
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|prp
operator|->
name|p_name
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|prp
operator|->
name|p_name
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unknown signalling protocol\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Build ioctl request 	 */
name|aar
operator|.
name|acr_opcode
operator|=
name|AIOCS_CFG_ATT
expr_stmt|;
name|strncpy
argument_list|(
name|aar
operator|.
name|acr_att_intf
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|aar
operator|.
name|acr_att_intf
argument_list|)
argument_list|)
expr_stmt|;
name|aar
operator|.
name|acr_att_proto
operator|=
name|prp
operator|->
name|p_id
expr_stmt|;
comment|/* 	 * Tell the kernel to do the attach 	 */
name|s
operator|=
name|socket
argument_list|(
name|AF_ATM
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|sock_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|AIOCCFG
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|aar
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|prog
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINVAL
case|:
case|case
name|EOPNOTSUPP
case|:
case|case
name|EPROTONOSUPPORT
case|:
name|perror
argument_list|(
literal|"Internal error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOMEM
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Kernel memory exhausted\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EEXIST
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Signalling manager already attached to %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENETDOWN
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ATM network is inoperable\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPERM
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Must be super user to use attach subcommand\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENXIO
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s is not an ATM device\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETOOMANYREFS
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s has too few or too many network interfaces\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|perror
argument_list|(
literal|"Ioctl (AIOCCFG) attach"
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process interface detach command  *   * Command format:   *	atm detach<interface_name>  *  * Arguments:  *	argc	number of arguments to command  *	argv	pointer to argument strings  *	cmdp	pointer to command description   *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|detach
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|cmdp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|struct
name|cmd
modifier|*
name|cmdp
decl_stmt|;
block|{
name|struct
name|atmcfgreq
name|adr
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Validate interface name 	 */
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|adr
operator|.
name|acr_det_intf
argument_list|)
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Illegal interface name\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Build ioctl request 	 */
name|adr
operator|.
name|acr_opcode
operator|=
name|AIOCS_CFG_DET
expr_stmt|;
name|strncpy
argument_list|(
name|adr
operator|.
name|acr_det_intf
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|adr
operator|.
name|acr_det_intf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the kernel to do the detach 	 */
name|s
operator|=
name|socket
argument_list|(
name|AF_ATM
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|sock_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|AIOCCFG
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|adr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|prog
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EALREADY
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Signalling manager already detaching from %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
name|perror
argument_list|(
literal|"Internal error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPERM
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Must be super user to use detach subcommand\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|perror
argument_list|(
literal|"ioctl (AIOCCFG) detach"
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process PVC add command  *   * Command format:   *	atm add PVC<interface_name><vpi><vci><aal><encaps>  *<owner_name>  *  * Arguments:  *	argc	number of arguments to command  *	argv	pointer to argument strings  *	cmdp	pointer to command description   *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|pvc_add
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|cmdp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|struct
name|cmd
modifier|*
name|cmdp
decl_stmt|;
block|{
name|struct
name|atmaddreq
name|apr
decl_stmt|;
name|struct
name|atminfreq
name|air
decl_stmt|;
name|struct
name|air_int_rsp
modifier|*
name|int_info
decl_stmt|;
name|struct
name|owner
modifier|*
name|owp
decl_stmt|;
name|struct
name|aal
modifier|*
name|alp
decl_stmt|;
name|struct
name|encaps
modifier|*
name|enp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|long
name|v
decl_stmt|;
name|int
name|buf_len
decl_stmt|,
name|s
decl_stmt|;
comment|/* 	 * Initialize opcode and flags 	 */
name|apr
operator|.
name|aar_opcode
operator|=
name|AIOCS_ADD_PVC
expr_stmt|;
name|apr
operator|.
name|aar_pvc_flags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Validate interface name and issue an information 	 * request IOCTL for the interface 	 */
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|apr
operator|.
name|aar_pvc_intf
argument_list|)
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Illegal interface name\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|UM_ZERO
argument_list|(
name|air
operator|.
name|air_int_intf
argument_list|,
sizeof|sizeof
argument_list|(
name|air
operator|.
name|air_int_intf
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|air
operator|.
name|air_int_intf
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|buf_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|air_int_rsp
argument_list|)
expr_stmt|;
name|air
operator|.
name|air_opcode
operator|=
name|AIOCS_INF_INT
expr_stmt|;
name|buf_len
operator|=
name|do_info_ioctl
argument_list|(
operator|&
name|air
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_len
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|prog
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOPROTOOPT
case|:
case|case
name|EOPNOTSUPP
case|:
name|perror
argument_list|(
literal|"Internal error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENXIO
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s is not an ATM device\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|perror
argument_list|(
literal|"ioctl (AIOCINFO)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|int_info
operator|=
operator|(
expr|struct
name|air_int_rsp
operator|*
operator|)
name|air
operator|.
name|air_buf_addr
expr_stmt|;
name|strcpy
argument_list|(
name|apr
operator|.
name|aar_pvc_intf
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* 	 * Validate vpi/vci values 	 */
name|v
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
operator|||
operator|(
name|v
operator|<
literal|0
operator|)
operator|||
operator|(
name|v
operator|>=
literal|1
operator|<<
literal|8
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Invalid VPI value\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|apr
operator|.
name|aar_pvc_vpi
operator|=
operator|(
name|u_short
operator|)
name|v
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|v
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
operator|||
operator|(
name|v
operator|<
name|MIN_VCI
operator|)
operator|||
operator|(
name|v
operator|>=
literal|1
operator|<<
literal|16
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Invalid VCI value\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|apr
operator|.
name|aar_pvc_vci
operator|=
operator|(
name|u_short
operator|)
name|v
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* 	 * Validate requested PVC AAL 	 */
for|for
control|(
name|alp
operator|=
name|aals
init|;
name|alp
operator|->
name|a_name
condition|;
name|alp
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|alp
operator|->
name|a_name
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|alp
operator|->
name|a_name
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Invalid PVC AAL\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|apr
operator|.
name|aar_pvc_aal
operator|=
name|alp
operator|->
name|a_id
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* 	 * Validate requested PVC encapsulation 	 */
for|for
control|(
name|enp
operator|=
name|encaps
init|;
name|enp
operator|->
name|e_name
condition|;
name|enp
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|enp
operator|->
name|e_name
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|enp
operator|->
name|e_name
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Invalid PVC encapsulation\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|apr
operator|.
name|aar_pvc_encaps
operator|=
name|enp
operator|->
name|e_id
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* 	 * Validate requested PVC owner 	 */
for|for
control|(
name|owp
operator|=
name|owners
init|;
name|owp
operator|->
name|o_name
condition|;
name|owp
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|owp
operator|->
name|o_name
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|owp
operator|->
name|o_name
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unknown PVC owner\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|apr
operator|.
name|aar_pvc_sap
operator|=
name|owp
operator|->
name|o_sap
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* 	 * Perform service user processing 	 */
if|if
condition|(
name|owp
operator|->
name|o_pvcadd
condition|)
block|{
call|(
modifier|*
name|owp
operator|->
name|o_pvcadd
call|)
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|cmdp
argument_list|,
operator|&
name|apr
argument_list|,
name|int_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unsupported PVC owner\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Tell the kernel to add the PVC 	 */
name|s
operator|=
name|socket
argument_list|(
name|AF_ATM
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|sock_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|AIOCADD
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|apr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|prog
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EPROTONOSUPPORT
case|:
case|case
name|ENOPROTOOPT
case|:
name|perror
argument_list|(
literal|"Internal error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid parameter\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EEXIST
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PVC already exists\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENETDOWN
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ATM network is inoperable\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOMEM
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Kernel memory exhausted\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPERM
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Must be super user to use add subcommand\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERANGE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid VPI or VCI value\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|perror
argument_list|(
literal|"ioctl (AIOCADD) add PVC"
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process ARP add command  *   * Command formats:   *	atm add arp [<netif>]<IP addr><ATM addr>  *  * Arguments:  *	argc	number of arguments to command  *	argv	pointer to argument strings  *	cmdp	pointer to command description   *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|arp_add
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|cmdp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|struct
name|cmd
modifier|*
name|cmdp
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|atmaddreq
name|apr
decl_stmt|;
name|Atm_addr
name|host_atm
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
union|union
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
block|}
name|host_ip
union|;
comment|/* 	 * Initialize add request structure 	 */
name|UM_ZERO
argument_list|(
operator|&
name|apr
argument_list|,
sizeof|sizeof
argument_list|(
name|apr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get network interface name if one is present 	 */
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
name|check_netif_name
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|apr
operator|.
name|aar_arp_intf
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
comment|/*          * Get IP address of specified host name          */
name|UM_ZERO
argument_list|(
operator|&
name|host_ip
argument_list|,
sizeof|sizeof
argument_list|(
name|host_ip
argument_list|)
argument_list|)
expr_stmt|;
name|host_ip
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|=
name|get_ip_addr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|host_ip
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* 	 * Get specified ATM address 	 */
name|len
operator|=
name|get_hex_atm_addr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|host_atm
operator|.
name|address
argument_list|,
sizeof|sizeof
argument_list|(
name|Atm_addr_nsap
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|Atm_addr_nsap
argument_list|)
case|:
name|host_atm
operator|.
name|address_format
operator|=
name|T_ATM_ENDSYS_ADDR
expr_stmt|;
name|host_atm
operator|.
name|address_length
operator|=
sizeof|sizeof
argument_list|(
name|Atm_addr_nsap
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|Atm_addr_spans
argument_list|)
case|:
name|host_atm
operator|.
name|address_format
operator|=
name|T_ATM_SPANS_ADDR
expr_stmt|;
name|host_atm
operator|.
name|address_length
operator|=
sizeof|sizeof
argument_list|(
name|Atm_addr_spans
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Invalid ATM address\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Build IOCTL request 	 */
name|apr
operator|.
name|aar_opcode
operator|=
name|AIOCS_ADD_ARP
expr_stmt|;
name|apr
operator|.
name|aar_arp_dst
operator|=
name|host_ip
operator|.
name|sa
expr_stmt|;
name|ATM_ADDR_COPY
argument_list|(
operator|&
name|host_atm
argument_list|,
operator|&
name|apr
operator|.
name|aar_arp_addr
argument_list|)
expr_stmt|;
name|apr
operator|.
name|aar_arp_origin
operator|=
name|ARP_ORIG_PERM
expr_stmt|;
comment|/* 	 * Tell the kernel to add the ARP table entry 	 */
name|s
operator|=
name|socket
argument_list|(
name|AF_ATM
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|sock_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|AIOCADD
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|apr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|prog
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINVAL
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid parameter\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPERM
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Must be super user to use add subcommand\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EADDRNOTAVAIL
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IP address not valid for interface\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|perror
argument_list|(
literal|"ioctl (AIOCADD) add"
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process PVC delete command  *   * Command formats:   *	atm delete pvc<interface_name><vpi><vci>  *  * Arguments:  *	argc	number of arguments to command  *	argv	pointer to argument strings  *	cmdp	pointer to command description   *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|pvc_dlt
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|cmdp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|struct
name|cmd
modifier|*
name|cmdp
decl_stmt|;
block|{
name|struct
name|atmdelreq
name|apr
decl_stmt|;
comment|/* 	 * Set opcode 	 */
name|apr
operator|.
name|adr_opcode
operator|=
name|AIOCS_DEL_PVC
expr_stmt|;
comment|/* 	 * Complete request by calling subroutine 	 */
name|vcc_dlt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|cmdp
argument_list|,
operator|&
name|apr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process SVC delete command  *   * Command formats:   *	atm delete svc<interface_name><vpi><vci>  *  * Arguments:  *	argc	number of arguments to command  *	argv	pointer to argument strings  *	cmdp	pointer to command description   *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|svc_dlt
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|cmdp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|struct
name|cmd
modifier|*
name|cmdp
decl_stmt|;
block|{
name|struct
name|atmdelreq
name|apr
decl_stmt|;
comment|/* 	 * Set opcode 	 */
name|apr
operator|.
name|adr_opcode
operator|=
name|AIOCS_DEL_SVC
expr_stmt|;
comment|/* 	 * Complete request by calling subroutine 	 */
name|vcc_dlt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|cmdp
argument_list|,
operator|&
name|apr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete an SVC or PVC delete command  *   * Arguments:  *	argc	number of arguments to command  *	argv	pointer to argument strings  *	cmdp	pointer to command description   *	apr	pointer to ATM delete IOCTL structure  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|vcc_dlt
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|cmdp
parameter_list|,
name|apr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|struct
name|cmd
modifier|*
name|cmdp
decl_stmt|;
name|struct
name|atmdelreq
modifier|*
name|apr
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|long
name|v
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Validate interface name 	 */
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|apr
operator|->
name|adr_pvc_intf
argument_list|)
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Illegal interface name\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|apr
operator|->
name|adr_pvc_intf
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* 	 * Validate vpi/vci values 	 */
name|v
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
operator|||
operator|(
name|v
operator|<
literal|0
operator|)
operator|||
operator|(
name|v
operator|>=
literal|1
operator|<<
literal|8
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Invalid VPI value\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|apr
operator|->
name|adr_pvc_vpi
operator|=
operator|(
name|u_short
operator|)
name|v
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|v
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
operator|||
operator|(
name|v
operator|<
name|MIN_VCI
operator|)
operator|||
operator|(
name|v
operator|>=
literal|1
operator|<<
literal|16
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Invalid VCI value\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|apr
operator|->
name|adr_pvc_vci
operator|=
operator|(
name|u_short
operator|)
name|v
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* 	 * Tell the kernel to delete the VCC 	 */
name|s
operator|=
name|socket
argument_list|(
name|AF_ATM
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|sock_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|AIOCDEL
argument_list|,
operator|(
name|caddr_t
operator|)
name|apr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|prog
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINVAL
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid parameter\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOENT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"VCC not found\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EALREADY
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"VCC already being closed\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENXIO
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s is not an ATM device\n"
argument_list|,
name|apr
operator|->
name|adr_pvc_intf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPERM
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Must be super user to use delete subcommand\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|perror
argument_list|(
literal|"ioctl (AIOCDEL) delete"
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process ARP delete command  *   * Command formats:   *	atm delete arp<IP addr>  *  * Arguments:  *	argc	number of arguments to command  *	argv	pointer to argument strings  *	cmdp	pointer to command description   *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|arp_dlt
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|cmdp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|struct
name|cmd
modifier|*
name|cmdp
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|struct
name|atmdelreq
name|apr
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
union|union
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
block|}
name|host_addr
union|;
comment|/* 	 * Set opcode 	 */
name|UM_ZERO
argument_list|(
operator|&
name|apr
argument_list|,
sizeof|sizeof
argument_list|(
name|apr
argument_list|)
argument_list|)
expr_stmt|;
name|apr
operator|.
name|adr_opcode
operator|=
name|AIOCS_DEL_ARP
expr_stmt|;
comment|/* 	 * Get network interface name if one is present 	 */
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|check_netif_name
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|apr
operator|.
name|adr_arp_intf
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
comment|/*          * Get IP address of specified host name          */
name|UM_ZERO
argument_list|(
operator|&
name|host_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|host_addr
argument_list|)
argument_list|)
expr_stmt|;
name|host_addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|=
name|get_ip_addr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|host_addr
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|apr
operator|.
name|adr_arp_dst
operator|=
name|host_addr
operator|.
name|sa
expr_stmt|;
comment|/* 	 * Tell the kernel to delete the ARP table entry 	 */
name|s
operator|=
name|socket
argument_list|(
name|AF_ATM
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|sock_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|AIOCDEL
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|apr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|prog
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINVAL
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid parameter\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPERM
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Must be super user to use delete subcommand\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|perror
argument_list|(
literal|"ioctl (AIOCDEL) delete"
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process help command  *   * Arguments:  *	argc	number of arguments to command  *	argv	pointer to argument strings  *	cmdp	pointer to command description   *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|help
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|cmdp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|struct
name|cmd
modifier|*
name|cmdp
decl_stmt|;
block|{
name|usage
argument_list|(
name|cmds
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

