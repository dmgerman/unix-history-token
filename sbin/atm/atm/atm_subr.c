begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * User configuration and display program  * --------------------------------------  *  * General subroutines  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libatm.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"atm.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Table entry definition  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|tbl_ent
typedef|;
end_typedef

begin_comment
comment|/*  * Table to translate vendor codes to ASCII  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|tbl_ent
name|vendors
index|[]
init|=
block|{
block|{
name|VENDOR_UNKNOWN
block|,
literal|"Unknown"
block|}
block|,
block|{
name|VENDOR_FORE
block|,
literal|"Fore"
block|}
block|,
block|{
name|VENDOR_ENI
block|,
literal|"ENI"
block|}
block|,
block|{
name|VENDOR_IDT
block|,
literal|"IDT"
block|}
block|,
block|{
name|VENDOR_PROSUM
block|,
literal|"ProSum"
block|}
block|,
block|{
name|VENDOR_NETGRAPH
block|,
literal|"Netgraph"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table to translate adapter codes to ASCII  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|tbl_ent
name|adapter_types
index|[]
init|=
block|{
block|{
name|DEV_UNKNOWN
block|,
literal|"Unknown"
block|}
block|,
block|{
name|DEV_FORE_SBA200E
block|,
literal|"SBA-200E"
block|}
block|,
block|{
name|DEV_FORE_SBA200
block|,
literal|"SBA-200"
block|}
block|,
block|{
name|DEV_FORE_PCA200E
block|,
literal|"PCA-200E"
block|}
block|,
block|{
name|DEV_FORE_ESA200E
block|,
literal|"ESA-200E"
block|}
block|,
block|{
name|DEV_ENI_155P
block|,
literal|"ENI-155p"
block|}
block|,
block|{
name|DEV_IDT_155
block|,
literal|"IDT"
block|}
block|,
block|{
name|DEV_PROATM_25
block|,
literal|"PROATM-25"
block|}
block|,
block|{
name|DEV_PROATM_155
block|,
literal|"PROATM-155"
block|}
block|,
block|{
name|DEV_VATMPIF
block|,
literal|"VATMPIF"
block|}
block|,
block|{
name|DEV_FORE_LE25
block|,
literal|"ForeLE-25"
block|}
block|,
block|{
name|DEV_FORE_LE155
block|,
literal|"ForeLE-155"
block|}
block|,
block|{
name|DEV_IDT_25
block|,
literal|"NICStAR-25"
block|}
block|,
block|{
name|DEV_IDTABR_25
block|,
literal|"IDT77252-25"
block|}
block|,
block|{
name|DEV_IDTABR_155
block|,
literal|"IDT77252-155"
block|}
block|,
block|{
name|DEV_FORE_HE155
block|,
literal|"ForeHE-155"
block|}
block|,
block|{
name|DEV_FORE_HE622
block|,
literal|"ForeHE-622"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table to translate medium types to ASCII  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|tbl_ent
name|media_types
index|[]
init|=
block|{
block|{
name|MEDIA_UNKNOWN
block|,
literal|"Unknown"
block|}
block|,
block|{
name|MEDIA_TAXI_100
block|,
literal|"100 Mbps 4B/5B"
block|}
block|,
block|{
name|MEDIA_TAXI_140
block|,
literal|"140 Mbps 4B/5B"
block|}
block|,
block|{
name|MEDIA_OC3C
block|,
literal|"OC-3c"
block|}
block|,
block|{
name|MEDIA_OC12C
block|,
literal|"OC-12c"
block|}
block|,
block|{
name|MEDIA_UTP155
block|,
literal|"155 Mbps UTP"
block|}
block|,
block|{
name|MEDIA_UTP25
block|,
literal|"25.6 Mbps UTP"
block|}
block|,
block|{
name|MEDIA_VIRTUAL
block|,
literal|"Virtual Link"
block|}
block|,
block|{
name|MEDIA_DSL
block|,
literal|"xDSL"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table to translate bus types to ASCII  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|tbl_ent
name|bus_types
index|[]
init|=
block|{
block|{
name|BUS_UNKNOWN
block|,
literal|"Unknown"
block|}
block|,
block|{
name|BUS_SBUS_B16
block|,
literal|"SBus"
block|}
block|,
block|{
name|BUS_SBUS_B32
block|,
literal|"SBus"
block|}
block|,
block|{
name|BUS_PCI
block|,
literal|"PCI"
block|}
block|,
block|{
name|BUS_EISA
block|,
literal|"EISA"
block|}
block|,
block|{
name|BUS_USB
block|,
literal|"USB"
block|}
block|,
block|{
name|BUS_VIRTUAL
block|,
literal|"Virtual"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get interface vendor name  *  * Return a character string with a vendor name, given a vendor code.  *   * Arguments:  *	vendor	vendor ID  *  * Returns:  *	char *	pointer to a string with the vendor name  *  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_vendor
parameter_list|(
name|int
name|vendor
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vendors
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vendors
index|[
name|i
index|]
operator|.
name|type
operator|==
name|vendor
condition|)
return|return
operator|(
name|vendors
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
block|}
return|return
operator|(
literal|"-"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get adapter type  *  * Arguments:  *	dev	adapter code  *  * Returns:  *	char *	pointer to a string with the adapter type  *  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_adapter
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|adapter_types
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|adapter_types
index|[
name|i
index|]
operator|.
name|type
operator|==
name|dev
condition|)
return|return
operator|(
name|adapter_types
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
block|}
return|return
operator|(
literal|"-"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get communication medium type  *  * Arguments:  *	media	medium code  *  * Returns:  *	char *	pointer to a string with the name of the medium  *  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_media_type
parameter_list|(
name|int
name|media
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|media_types
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|media_types
index|[
name|i
index|]
operator|.
name|type
operator|==
name|media
condition|)
return|return
operator|(
name|media_types
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
block|}
return|return
operator|(
literal|"-"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get bus type  *  * Arguments:  *	bus	bus type code  *  * Returns:  *	char *	pointer to a string with the bus type  *  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_bus_type
parameter_list|(
name|int
name|bus
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bus_types
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_types
index|[
name|i
index|]
operator|.
name|type
operator|==
name|bus
condition|)
return|return
operator|(
name|bus_types
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
block|}
return|return
operator|(
literal|"-"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get adapter ID  *  * Get a string giving the adapter's vendor and type.  *  * Arguments:  *	intf	interface name  *  * Returns:  *	char *	pointer to a string identifying the adapter  *  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_adapter_name
parameter_list|(
specifier|const
name|char
modifier|*
name|intf
parameter_list|)
block|{
name|int
name|buf_len
decl_stmt|;
name|struct
name|atminfreq
name|air
decl_stmt|;
name|struct
name|air_cfg_rsp
modifier|*
name|cfg
decl_stmt|;
specifier|static
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
comment|/* 	 * Initialize 	 */
name|bzero
argument_list|(
operator|&
name|air
argument_list|,
sizeof|sizeof
argument_list|(
name|air
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get configuration information from the kernel 	 */
name|air
operator|.
name|air_opcode
operator|=
name|AIOCS_INF_CFG
expr_stmt|;
name|strcpy
argument_list|(
name|air
operator|.
name|air_cfg_intf
argument_list|,
name|intf
argument_list|)
expr_stmt|;
name|buf_len
operator|=
name|do_info_ioctl
argument_list|(
operator|&
name|air
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|air_cfg_rsp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|buf_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|air_cfg_rsp
argument_list|)
condition|)
return|return
operator|(
literal|"-"
operator|)
return|;
name|cfg
operator|=
operator|(
expr|struct
name|air_cfg_rsp
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|air
operator|.
name|air_buf_addr
expr_stmt|;
comment|/* 	 * Build a string describing the adapter 	 */
name|strcpy
argument_list|(
name|name
argument_list|,
name|get_vendor
argument_list|(
name|cfg
operator|->
name|acp_vendor
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|get_adapter
argument_list|(
name|cfg
operator|->
name|acp_device
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Format a MAC address into a string  *   * Arguments:  *	addr	pointer to a MAC address  *  * Returns:  *		the address of a string representing the MAC address  *  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|format_mac_addr
parameter_list|(
specifier|const
name|Mac_addr
modifier|*
name|addr
parameter_list|)
block|{
specifier|static
name|char
name|str
index|[
literal|256
index|]
decl_stmt|;
comment|/* 	 * Check for null pointer 	 */
if|if
condition|(
operator|!
name|addr
condition|)
return|return
operator|(
literal|"-"
operator|)
return|;
comment|/* 	 * Clear the returned string 	 */
name|bzero
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Format the address 	 */
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%02x:%02x:%02x:%02x:%02x:%02x"
argument_list|,
name|addr
operator|->
name|ma_data
index|[
literal|0
index|]
argument_list|,
name|addr
operator|->
name|ma_data
index|[
literal|1
index|]
argument_list|,
name|addr
operator|->
name|ma_data
index|[
literal|2
index|]
argument_list|,
name|addr
operator|->
name|ma_data
index|[
literal|3
index|]
argument_list|,
name|addr
operator|->
name|ma_data
index|[
literal|4
index|]
argument_list|,
name|addr
operator|->
name|ma_data
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse an IP prefix designation in the form nnn.nnn.nnn.nnn/mm  *  * Arguments:  *	cp	pointer to prefix designation string  *	op	pointer to a pair of in_addrs for the result  *  * Returns:  *	0	success  *	-1	prefix was invalid  *  */
end_comment

begin_function
name|int
name|parse_ip_prefix
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
name|struct
name|in_addr
modifier|*
name|op
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|mp
decl_stmt|;
name|struct
name|in_addr
name|ip_addr
decl_stmt|;
specifier|static
name|u_long
name|masks
index|[
literal|33
index|]
init|=
block|{
literal|0x0
block|,
literal|0x80000000
block|,
literal|0xc0000000
block|,
literal|0xe0000000
block|,
literal|0xf0000000
block|,
literal|0xf8000000
block|,
literal|0xfc000000
block|,
literal|0xfe000000
block|,
literal|0xff000000
block|,
literal|0xff800000
block|,
literal|0xffc00000
block|,
literal|0xffe00000
block|,
literal|0xfff00000
block|,
literal|0xfff80000
block|,
literal|0xfffc0000
block|,
literal|0xfffe0000
block|,
literal|0xffff0000
block|,
literal|0xffff8000
block|,
literal|0xffffc000
block|,
literal|0xffffe000
block|,
literal|0xfffff000
block|,
literal|0xfffff800
block|,
literal|0xfffffc00
block|,
literal|0xfffffe00
block|,
literal|0xffffff00
block|,
literal|0xffffff80
block|,
literal|0xffffffc0
block|,
literal|0xffffffe0
block|,
literal|0xfffffff0
block|,
literal|0xfffffff8
block|,
literal|0xfffffffc
block|,
literal|0xfffffffe
block|,
literal|0xffffffff
block|}
decl_stmt|;
comment|/* 	 * Find the slash that marks the start of the mask 	 */
name|mp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
operator|*
name|mp
operator|=
literal|'\0'
expr_stmt|;
name|mp
operator|++
expr_stmt|;
block|}
comment|/* 	 * Convert the IP-address part of the prefix 	 */
name|ip_addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip_addr
operator|.
name|s_addr
operator|==
name|INADDR_NONE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Set the default mask length 	 */
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|ntohl
argument_list|(
name|ip_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
name|len
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|ntohl
argument_list|(
name|ip_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
name|len
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_CLASSC
argument_list|(
name|ntohl
argument_list|(
name|ip_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
name|len
operator|=
literal|24
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Get the mask length 	 */
if|if
condition|(
name|mp
condition|)
block|{
name|len
operator|=
name|atoi
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|1
operator|||
name|len
operator|>
literal|32
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Select the mask and copy the IP address into the 	 * result buffer, ANDing it with the mask 	 */
name|op
index|[
literal|1
index|]
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|masks
index|[
name|len
index|]
argument_list|)
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|.
name|s_addr
operator|=
name|ip_addr
operator|.
name|s_addr
operator|&
name|op
index|[
literal|1
index|]
operator|.
name|s_addr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compress a list of IP network prefixes  *  * Arguments:  *	ipp	pointer to list of IP address/mask pairs  *	ipc	length of list  *  * Returns:  *	length of compressed list  *  */
end_comment

begin_function
name|int
name|compress_prefix_list
parameter_list|(
name|struct
name|in_addr
modifier|*
name|ipp
parameter_list|,
name|int
name|ilen
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|ip1
decl_stmt|,
modifier|*
name|ip2
decl_stmt|,
modifier|*
name|m1
decl_stmt|,
modifier|*
name|m2
decl_stmt|;
comment|/* 	 * Figure out how many pairs there are 	 */
name|n
operator|=
name|ilen
operator|/
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|*
literal|2
operator|)
expr_stmt|;
comment|/* 	 * Check each pair of address/mask pairs to make sure 	 * none contains the other 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|ip1
operator|=
operator|&
name|ipp
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
name|m1
operator|=
operator|&
name|ipp
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
comment|/* 		 * If we've already eliminated this address, 		 * skip the checks 		 */
if|if
condition|(
name|ip1
operator|->
name|s_addr
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Try all possible second members of the pair 		 */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|ip2
operator|=
operator|&
name|ipp
index|[
name|j
operator|*
literal|2
index|]
expr_stmt|;
name|m2
operator|=
operator|&
name|ipp
index|[
name|j
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
comment|/* 			 * If we've already eliminated the second 			 * address, just skip the checks 			 */
if|if
condition|(
name|ip2
operator|->
name|s_addr
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * Compare the address/mask pairs 			 */
if|if
condition|(
name|m1
operator|->
name|s_addr
operator|==
name|m2
operator|->
name|s_addr
condition|)
block|{
comment|/* 				 * Masks are equal 				 */
if|if
condition|(
name|ip1
operator|->
name|s_addr
operator|==
name|ip2
operator|->
name|s_addr
condition|)
block|{
name|ip2
operator|->
name|s_addr
operator|=
literal|0
expr_stmt|;
name|m2
operator|->
name|s_addr
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ntohl
argument_list|(
name|m1
operator|->
name|s_addr
argument_list|)
operator|<
name|ntohl
argument_list|(
name|m2
operator|->
name|s_addr
argument_list|)
condition|)
block|{
comment|/* 				 * m1 is shorter 				 */
if|if
condition|(
operator|(
name|ip2
operator|->
name|s_addr
operator|&
name|m1
operator|->
name|s_addr
operator|)
operator|==
name|ip1
operator|->
name|s_addr
condition|)
block|{
name|ip2
operator|->
name|s_addr
operator|=
literal|0
expr_stmt|;
name|m2
operator|->
name|s_addr
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * m1 is longer 				 */
if|if
condition|(
operator|(
name|ip1
operator|->
name|s_addr
operator|&
name|m2
operator|->
name|s_addr
operator|)
operator|==
name|ip2
operator|->
name|s_addr
condition|)
block|{
name|ip1
operator|->
name|s_addr
operator|=
literal|0
expr_stmt|;
name|m1
operator|->
name|s_addr
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* 	 * Now pull up the list, eliminating zeroed entries 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|ip1
operator|=
operator|&
name|ipp
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
name|m1
operator|=
operator|&
name|ipp
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
name|ip2
operator|=
operator|&
name|ipp
index|[
name|j
operator|*
literal|2
index|]
expr_stmt|;
name|m2
operator|=
operator|&
name|ipp
index|[
name|j
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ip1
operator|->
name|s_addr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|j
condition|)
block|{
operator|*
name|ip2
operator|=
operator|*
name|ip1
expr_stmt|;
operator|*
name|m2
operator|=
operator|*
name|m1
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|j
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|*
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make sure a user-supplied parameter is a valid network interface  * name  *  * When a socket call fails, print an error message and exit  *   * Arguments:  *	nif	pointer to network interface name  *  * Returns:  *	none	exits if name is not valid  *  */
end_comment

begin_function
name|void
name|check_netif_name
parameter_list|(
specifier|const
name|char
modifier|*
name|nif
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
comment|/* 	 * Look up the name in the kernel 	 */
name|rc
operator|=
name|verify_nif_name
argument_list|(
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|nif
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* 	 * Check the result 	 */
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Name is OK 		 */
return|return;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Name is not valid 		 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Invalid network interface name %s\n"
argument_list|,
name|prog
argument_list|,
name|nif
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Error performing IOCTL 		 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|prog
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOPROTOOPT
case|:
case|case
name|EOPNOTSUPP
case|:
name|perror
argument_list|(
literal|"Internal error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENXIO
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s is not an ATM device\n"
argument_list|,
name|nif
argument_list|)
expr_stmt|;
break|break;
default|default:
name|perror
argument_list|(
literal|"ioctl (AIOCINFO)"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Socket error handler  *  * When a socket call fails, print an error message and exit  *   * Arguments:  *	err	an errno describing the error  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|sock_error
parameter_list|(
name|int
name|err
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|prog
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|EPROTONOSUPPORT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ATM protocol support not loaded\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

