begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * User utilities  * --------------  *  * Download (pre)processed microcode into Fore Series-200 host adapter  * Interact with i960 uart on Fore Series-200 host adapter  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_aali.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_slave.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
end_if

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BSD */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|u_char
name|pca200e_microcode
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pca200e_microcode_size
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_define
define|#
directive|define
name|DEV_NAME
value|"/dev/sbus%d"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sun */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|DEV_NAME
value|"/dev/kmem"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_define
define|#
directive|define
name|MAX_CHECK
value|60
end_define

begin_decl_stmt
name|int
name|comm_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cc_t
name|vmin
decl_stmt|,
name|vtime
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
end_if

begin_decl_stmt
name|struct
name|termios
name|sgtty
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TCSETA
value|TIOCSETA
end_define

begin_define
define|#
directive|define
name|TCGETA
value|TIOCGETA
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|termio
name|sgtty
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BSD */
end_comment

begin_decl_stmt
name|int
name|endian
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|reset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|line
index|[
literal|132
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lineptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Mon960
modifier|*
name|Uart
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|delay
parameter_list|(
name|cnt
parameter_list|)
name|int
name|cnt
decl_stmt|;
block|{
name|usleep
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|long
name|CP_READ
parameter_list|(
name|val
parameter_list|)
name|unsigned
name|long
name|val
decl_stmt|;
block|{
if|if
condition|(
name|endian
condition|)
return|return
operator|(
name|ntohl
argument_list|(
name|val
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|CP_WRITE
parameter_list|(
name|val
parameter_list|)
name|unsigned
name|long
name|val
decl_stmt|;
block|{
if|if
condition|(
name|endian
condition|)
return|return
operator|(
name|htonl
argument_list|(
name|val
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print an error message and exit.  *  * Arguments:  *	none  *  * Returns:  *	none  */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a byte for the uart and if printing, display it.  *  * Arguments:  *	prn				Are we displaying characters  *  * Returns:  *	c				Character from uart  */
end_comment

begin_function
name|char
name|getbyte
parameter_list|(
name|prn
parameter_list|)
name|int
name|prn
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|CP_READ
argument_list|(
name|Uart
operator|->
name|mon_xmithost
argument_list|)
operator|&
name|UART_VALID
operator|)
condition|)
name|delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|CP_READ
argument_list|(
name|Uart
operator|->
name|mon_xmithost
argument_list|)
operator|&
name|UART_DATAMASK
operator|)
expr_stmt|;
name|Uart
operator|->
name|mon_xmithost
operator|=
name|CP_WRITE
argument_list|(
name|UART_READY
argument_list|)
expr_stmt|;
comment|/* 	 * We need to introduce a delay in here or things tend to hang... 	 */
name|delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineptr
operator|>=
sizeof|sizeof
argument_list|(
name|line
argument_list|)
condition|)
name|lineptr
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Save character into line 	 */
name|line
index|[
name|lineptr
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\r'
operator|)
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Loop getting characters from uart into static string until eol. If printing,  * display the line retrieved.  *  * Arguments:  *	prn				Are we displaying characters  *  * Returns:  *	none				Line in global string 'line[]'  */
end_comment

begin_function
name|void
name|getline
parameter_list|(
name|prn
parameter_list|)
name|int
name|prn
decl_stmt|;
block|{
name|char
name|c
init|=
literal|'\0'
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'>'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\r'
condition|)
block|{
name|c
operator|=
name|getbyte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|>=
sizeof|sizeof
argument_list|(
name|line
argument_list|)
condition|)
block|{
if|if
condition|(
name|prn
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Terminate line 	 */
name|line
index|[
name|lineptr
index|]
operator|=
literal|0
expr_stmt|;
name|lineptr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a byte to the i960  *  * Arguments:  *	c				Character to send  *  * Returns:  *	none  */
end_comment

begin_function
name|void
name|xmit_byte
parameter_list|(
name|c
parameter_list|,
name|dn
parameter_list|)
name|unsigned
name|char
name|c
decl_stmt|;
name|int
name|dn
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
while|while
condition|(
name|CP_READ
argument_list|(
name|Uart
operator|->
name|mon_xmitmon
argument_list|)
operator|!=
name|UART_READY
condition|)
block|{
if|if
condition|(
name|CP_READ
argument_list|(
name|Uart
operator|->
name|mon_xmithost
argument_list|)
operator|&
name|UART_VALID
condition|)
name|getbyte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dn
condition|)
name|delay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
operator|(
name|c
operator||
name|UART_VALID
operator|)
expr_stmt|;
name|Uart
operator|->
name|mon_xmitmon
operator|=
name|CP_WRITE
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transmit a line to the i960. Eol must be included as part of text to transmit.  *  * Arguments:  *	line			Character string to transmit  *	len			len of string. This allows us to include NULL's  *					in the string/block to be transmitted.  *  * Returns:  *	none  */
end_comment

begin_function
name|void
name|xmit_to_i960
parameter_list|(
name|line
parameter_list|,
name|len
parameter_list|,
name|dn
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|dn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|xmit_byte
argument_list|(
name|line
index|[
name|i
index|]
argument_list|,
name|dn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send autobaud sequence to i960 monitor  *  * Arguments:  *	none  *  * Returns:  *	none  */
end_comment

begin_function
name|void
name|autobaud
parameter_list|()
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"Mon960"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|xmit_to_i960
argument_list|(
literal|"\r\n\r\n\r\n\r\n"
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset tty to initial state  *  * Arguments:  *	ret		error code for exit()  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|finish
parameter_list|(
name|ret
parameter_list|)
block|{
name|sgtty
operator|.
name|c_lflag
operator||=
operator|(
name|ICANON
operator||
name|ECHO
operator|)
expr_stmt|;
name|sgtty
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
name|vmin
expr_stmt|;
name|sgtty
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
name|vtime
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|sgtty
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Utility to strip off any leading path information from a filename  *  * Arguments:  *	path		pathname to strip  *  * Returns:  *	fname		striped filename  *  */
end_comment

begin_function
name|char
modifier|*
name|basename
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
operator|(
name|fname
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|fname
operator|++
expr_stmt|;
else|else
name|fname
operator|=
name|path
expr_stmt|;
return|return
operator|(
name|fname
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ASCII constants  */
end_comment

begin_define
define|#
directive|define
name|SOH
value|001
end_define

begin_define
define|#
directive|define
name|STX
value|002
end_define

begin_define
define|#
directive|define
name|ETX
value|003
end_define

begin_define
define|#
directive|define
name|EOT
value|004
end_define

begin_define
define|#
directive|define
name|ENQ
value|005
end_define

begin_define
define|#
directive|define
name|ACK
value|006
end_define

begin_define
define|#
directive|define
name|LF
value|012
end_define

begin_define
define|#
directive|define
name|CR
value|015
end_define

begin_define
define|#
directive|define
name|NAK
value|025
end_define

begin_define
define|#
directive|define
name|SYN
value|026
end_define

begin_define
define|#
directive|define
name|CAN
value|030
end_define

begin_define
define|#
directive|define
name|ESC
value|033
end_define

begin_define
define|#
directive|define
name|NAKMAX
value|2
end_define

begin_define
define|#
directive|define
name|ERRORMAX
value|10
end_define

begin_define
define|#
directive|define
name|RETRYMAX
value|5
end_define

begin_define
define|#
directive|define
name|CRCCHR
value|'C'
end_define

begin_define
define|#
directive|define
name|CTRLZ
value|032
end_define

begin_define
define|#
directive|define
name|BUFSIZE
value|128
end_define

begin_define
define|#
directive|define
name|W
value|16
end_define

begin_define
define|#
directive|define
name|B
value|8
end_define

begin_comment
comment|/*  * crctab - CRC-16 constant array...  *     from Usenet contribution by Mark G. Mendel, Network Systems Corp.  *     (ihnp4!umn-cs!hyper!mark)  */
end_comment

begin_decl_stmt
name|unsigned
name|short
name|crctab
index|[
literal|1
operator|<<
name|B
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x1021
block|,
literal|0x2042
block|,
literal|0x3063
block|,
literal|0x4084
block|,
literal|0x50a5
block|,
literal|0x60c6
block|,
literal|0x70e7
block|,
literal|0x8108
block|,
literal|0x9129
block|,
literal|0xa14a
block|,
literal|0xb16b
block|,
literal|0xc18c
block|,
literal|0xd1ad
block|,
literal|0xe1ce
block|,
literal|0xf1ef
block|,
literal|0x1231
block|,
literal|0x0210
block|,
literal|0x3273
block|,
literal|0x2252
block|,
literal|0x52b5
block|,
literal|0x4294
block|,
literal|0x72f7
block|,
literal|0x62d6
block|,
literal|0x9339
block|,
literal|0x8318
block|,
literal|0xb37b
block|,
literal|0xa35a
block|,
literal|0xd3bd
block|,
literal|0xc39c
block|,
literal|0xf3ff
block|,
literal|0xe3de
block|,
literal|0x2462
block|,
literal|0x3443
block|,
literal|0x0420
block|,
literal|0x1401
block|,
literal|0x64e6
block|,
literal|0x74c7
block|,
literal|0x44a4
block|,
literal|0x5485
block|,
literal|0xa56a
block|,
literal|0xb54b
block|,
literal|0x8528
block|,
literal|0x9509
block|,
literal|0xe5ee
block|,
literal|0xf5cf
block|,
literal|0xc5ac
block|,
literal|0xd58d
block|,
literal|0x3653
block|,
literal|0x2672
block|,
literal|0x1611
block|,
literal|0x0630
block|,
literal|0x76d7
block|,
literal|0x66f6
block|,
literal|0x5695
block|,
literal|0x46b4
block|,
literal|0xb75b
block|,
literal|0xa77a
block|,
literal|0x9719
block|,
literal|0x8738
block|,
literal|0xf7df
block|,
literal|0xe7fe
block|,
literal|0xd79d
block|,
literal|0xc7bc
block|,
literal|0x48c4
block|,
literal|0x58e5
block|,
literal|0x6886
block|,
literal|0x78a7
block|,
literal|0x0840
block|,
literal|0x1861
block|,
literal|0x2802
block|,
literal|0x3823
block|,
literal|0xc9cc
block|,
literal|0xd9ed
block|,
literal|0xe98e
block|,
literal|0xf9af
block|,
literal|0x8948
block|,
literal|0x9969
block|,
literal|0xa90a
block|,
literal|0xb92b
block|,
literal|0x5af5
block|,
literal|0x4ad4
block|,
literal|0x7ab7
block|,
literal|0x6a96
block|,
literal|0x1a71
block|,
literal|0x0a50
block|,
literal|0x3a33
block|,
literal|0x2a12
block|,
literal|0xdbfd
block|,
literal|0xcbdc
block|,
literal|0xfbbf
block|,
literal|0xeb9e
block|,
literal|0x9b79
block|,
literal|0x8b58
block|,
literal|0xbb3b
block|,
literal|0xab1a
block|,
literal|0x6ca6
block|,
literal|0x7c87
block|,
literal|0x4ce4
block|,
literal|0x5cc5
block|,
literal|0x2c22
block|,
literal|0x3c03
block|,
literal|0x0c60
block|,
literal|0x1c41
block|,
literal|0xedae
block|,
literal|0xfd8f
block|,
literal|0xcdec
block|,
literal|0xddcd
block|,
literal|0xad2a
block|,
literal|0xbd0b
block|,
literal|0x8d68
block|,
literal|0x9d49
block|,
literal|0x7e97
block|,
literal|0x6eb6
block|,
literal|0x5ed5
block|,
literal|0x4ef4
block|,
literal|0x3e13
block|,
literal|0x2e32
block|,
literal|0x1e51
block|,
literal|0x0e70
block|,
literal|0xff9f
block|,
literal|0xefbe
block|,
literal|0xdfdd
block|,
literal|0xcffc
block|,
literal|0xbf1b
block|,
literal|0xaf3a
block|,
literal|0x9f59
block|,
literal|0x8f78
block|,
literal|0x9188
block|,
literal|0x81a9
block|,
literal|0xb1ca
block|,
literal|0xa1eb
block|,
literal|0xd10c
block|,
literal|0xc12d
block|,
literal|0xf14e
block|,
literal|0xe16f
block|,
literal|0x1080
block|,
literal|0x00a1
block|,
literal|0x30c2
block|,
literal|0x20e3
block|,
literal|0x5004
block|,
literal|0x4025
block|,
literal|0x7046
block|,
literal|0x6067
block|,
literal|0x83b9
block|,
literal|0x9398
block|,
literal|0xa3fb
block|,
literal|0xb3da
block|,
literal|0xc33d
block|,
literal|0xd31c
block|,
literal|0xe37f
block|,
literal|0xf35e
block|,
literal|0x02b1
block|,
literal|0x1290
block|,
literal|0x22f3
block|,
literal|0x32d2
block|,
literal|0x4235
block|,
literal|0x5214
block|,
literal|0x6277
block|,
literal|0x7256
block|,
literal|0xb5ea
block|,
literal|0xa5cb
block|,
literal|0x95a8
block|,
literal|0x8589
block|,
literal|0xf56e
block|,
literal|0xe54f
block|,
literal|0xd52c
block|,
literal|0xc50d
block|,
literal|0x34e2
block|,
literal|0x24c3
block|,
literal|0x14a0
block|,
literal|0x0481
block|,
literal|0x7466
block|,
literal|0x6447
block|,
literal|0x5424
block|,
literal|0x4405
block|,
literal|0xa7db
block|,
literal|0xb7fa
block|,
literal|0x8799
block|,
literal|0x97b8
block|,
literal|0xe75f
block|,
literal|0xf77e
block|,
literal|0xc71d
block|,
literal|0xd73c
block|,
literal|0x26d3
block|,
literal|0x36f2
block|,
literal|0x0691
block|,
literal|0x16b0
block|,
literal|0x6657
block|,
literal|0x7676
block|,
literal|0x4615
block|,
literal|0x5634
block|,
literal|0xd94c
block|,
literal|0xc96d
block|,
literal|0xf90e
block|,
literal|0xe92f
block|,
literal|0x99c8
block|,
literal|0x89e9
block|,
literal|0xb98a
block|,
literal|0xa9ab
block|,
literal|0x5844
block|,
literal|0x4865
block|,
literal|0x7806
block|,
literal|0x6827
block|,
literal|0x18c0
block|,
literal|0x08e1
block|,
literal|0x3882
block|,
literal|0x28a3
block|,
literal|0xcb7d
block|,
literal|0xdb5c
block|,
literal|0xeb3f
block|,
literal|0xfb1e
block|,
literal|0x8bf9
block|,
literal|0x9bd8
block|,
literal|0xabbb
block|,
literal|0xbb9a
block|,
literal|0x4a75
block|,
literal|0x5a54
block|,
literal|0x6a37
block|,
literal|0x7a16
block|,
literal|0x0af1
block|,
literal|0x1ad0
block|,
literal|0x2ab3
block|,
literal|0x3a92
block|,
literal|0xfd2e
block|,
literal|0xed0f
block|,
literal|0xdd6c
block|,
literal|0xcd4d
block|,
literal|0xbdaa
block|,
literal|0xad8b
block|,
literal|0x9de8
block|,
literal|0x8dc9
block|,
literal|0x7c26
block|,
literal|0x6c07
block|,
literal|0x5c64
block|,
literal|0x4c45
block|,
literal|0x3ca2
block|,
literal|0x2c83
block|,
literal|0x1ce0
block|,
literal|0x0cc1
block|,
literal|0xef1f
block|,
literal|0xff3e
block|,
literal|0xcf5d
block|,
literal|0xdf7c
block|,
literal|0xaf9b
block|,
literal|0xbfba
block|,
literal|0x8fd9
block|,
literal|0x9ff8
block|,
literal|0x6e17
block|,
literal|0x7e36
block|,
literal|0x4e55
block|,
literal|0x5e74
block|,
literal|0x2e93
block|,
literal|0x3eb2
block|,
literal|0x0ed1
block|,
literal|0x1ef0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Hacked up xmodem protocol. Transmits the file 'filename' down to the i960  * using the xmodem protocol.  *  * Arguments:  *	filename			name of file to transmit  *  * Returns:  *	0				file transmitted  *	-1				unable to send file  */
end_comment

begin_function
name|int
name|xmitfile
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|int
name|numsect
decl_stmt|;
name|int
name|sectnum
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|sendresp
decl_stmt|;
name|int
name|crcmode
init|=
literal|0
decl_stmt|;
name|int
name|attempts
init|=
literal|0
decl_stmt|;
name|int
name|errors
decl_stmt|;
name|int
name|sendfin
decl_stmt|;
name|int
name|extrachr
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZE
operator|+
literal|6
index|]
decl_stmt|;
name|char
name|blockbuf
index|[
name|BUFSIZE
operator|+
literal|6
index|]
decl_stmt|;
name|int
name|bufcntr
decl_stmt|;
name|int
name|bbufcntr
decl_stmt|;
name|int
name|bufsize
init|=
name|BUFSIZE
decl_stmt|;
name|int
name|checksum
decl_stmt|;
comment|/* 	 * Try opening file 	 */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|stb
argument_list|)
expr_stmt|;
comment|/* 	 * Determine number of 128 bytes sectors to transmit 	 */
name|numsect
operator|=
operator|(
name|stb
operator|.
name|st_size
operator|/
literal|128
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Downloading %d sectors from %s\n"
argument_list|,
name|numsect
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* 	 * Send DO'wnload' command to i960 	 */
name|xmit_to_i960
argument_list|(
literal|"do\r\n"
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for response from i960 indicating download in progress 	 */
while|while
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"Downloading"
argument_list|,
literal|11
argument_list|)
operator|!=
literal|0
condition|)
name|getline
argument_list|(
name|verbose
argument_list|)
expr_stmt|;
comment|/* 	 * Get startup character from i960 	 */
do|do
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getbyte
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
name|NAK
operator|&&
name|c
operator|!=
name|CRCCHR
condition|)
if|if
condition|(
operator|++
name|attempts
operator|>
name|NAKMAX
condition|)
name|error
argument_list|(
literal|"Remote system not responding"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|CRCCHR
condition|)
name|crcmode
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
name|NAK
operator|&&
name|c
operator|!=
name|CRCCHR
condition|)
do|;
name|sectnum
operator|=
literal|1
expr_stmt|;
name|attempts
operator|=
name|errors
operator|=
name|sendfin
operator|=
name|extrachr
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Loop over each sector to be sent 	 */
do|do
block|{
if|if
condition|(
name|extrachr
operator|>=
literal|128
condition|)
block|{
name|extrachr
operator|=
literal|0
expr_stmt|;
name|numsect
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sectnum
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Read a sectors worth of data from the file into 			 * an internal buffer. 			 */
for|for
control|(
name|bufcntr
operator|=
literal|0
init|;
name|bufcntr
operator|<
name|bufsize
condition|;
control|)
block|{
name|int
name|n
decl_stmt|;
comment|/* 				 * Check for EOF 				 */
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|sendfin
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|bufcntr
condition|)
break|break;
name|buf
index|[
name|bufcntr
operator|++
index|]
operator|=
name|CTRLZ
expr_stmt|;
continue|continue;
block|}
name|buf
index|[
name|bufcntr
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bufcntr
condition|)
break|break;
block|}
comment|/* 		 * Fill in xmodem protocol values. Block size and sector number 		 */
name|bbufcntr
operator|=
literal|0
expr_stmt|;
name|blockbuf
index|[
name|bbufcntr
operator|++
index|]
operator|=
operator|(
name|bufsize
operator|==
literal|1024
operator|)
condition|?
name|STX
else|:
name|SOH
expr_stmt|;
name|blockbuf
index|[
name|bbufcntr
operator|++
index|]
operator|=
name|sectnum
expr_stmt|;
name|blockbuf
index|[
name|bbufcntr
operator|++
index|]
operator|=
operator|~
name|sectnum
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Loop over the internal buffer computing the checksum of the 		 * sector 		 */
for|for
control|(
name|bufcntr
operator|=
literal|0
init|;
name|bufcntr
operator|<
name|bufsize
condition|;
name|bufcntr
operator|++
control|)
block|{
name|blockbuf
index|[
name|bbufcntr
operator|++
index|]
operator|=
name|buf
index|[
name|bufcntr
index|]
expr_stmt|;
if|if
condition|(
name|crcmode
condition|)
name|checksum
operator|=
operator|(
name|checksum
operator|<<
name|B
operator|)
operator|^
name|crctab
index|[
operator|(
name|checksum
operator|>>
operator|(
name|W
operator|-
name|B
operator|)
operator|)
operator|^
name|buf
index|[
name|bufcntr
index|]
index|]
expr_stmt|;
else|else
name|checksum
operator|=
operator|(
operator|(
name|checksum
operator|+
name|buf
index|[
name|bufcntr
index|]
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
comment|/* 		 * Place the checksum at the end of the transmit buffer 		 */
if|if
condition|(
name|crcmode
condition|)
block|{
name|checksum
operator|&=
literal|0xffff
expr_stmt|;
name|blockbuf
index|[
name|bbufcntr
operator|++
index|]
operator|=
operator|(
operator|(
name|checksum
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|blockbuf
index|[
name|bbufcntr
operator|++
index|]
operator|=
operator|(
name|checksum
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
else|else
name|blockbuf
index|[
name|bbufcntr
operator|++
index|]
operator|=
name|checksum
expr_stmt|;
name|attempts
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Make several attempts to send the data to the i960 		 */
do|do
block|{
comment|/* 			 * Transmit the sector + protocol to the i960 			 */
name|xmit_to_i960
argument_list|(
name|blockbuf
argument_list|,
name|bbufcntr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * Inform user where we're at 			 */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Sector %3d %3dk\r"
argument_list|,
name|sectnum
argument_list|,
operator|(
name|sectnum
operator|*
name|bufsize
operator|)
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|attempts
operator|++
expr_stmt|;
comment|/* 			 * Get response from i960 			 */
name|sendresp
operator|=
name|getbyte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * If i960 didn't like the sector 			 */
if|if
condition|(
name|sendresp
operator|!=
name|ACK
condition|)
block|{
name|errors
operator|++
expr_stmt|;
comment|/* 				 * Are we supposed to cancel the transfer? 				 */
if|if
condition|(
operator|(
name|sendresp
operator|&
literal|0x7f
operator|)
operator|==
name|CAN
condition|)
if|if
condition|(
name|getbyte
argument_list|(
literal|0
argument_list|)
operator|==
name|CAN
condition|)
name|error
argument_list|(
literal|"Send canceled at user's request"
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|sendresp
operator|!=
name|ACK
operator|)
operator|&&
operator|(
name|attempts
operator|<
name|RETRYMAX
operator|)
operator|&&
operator|(
name|errors
operator|<
name|ERRORMAX
operator|)
condition|)
do|;
comment|/* 		 * Next sector 		 */
name|sectnum
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|sendfin
operator|&&
operator|(
name|attempts
operator|<
name|RETRYMAX
operator|)
operator|&&
operator|(
name|errors
operator|<
name|ERRORMAX
operator|)
condition|)
do|;
comment|/* 	 * Did we expire all our allows attempts? 	 */
if|if
condition|(
name|attempts
operator|>=
name|RETRYMAX
condition|)
block|{
name|xmit_byte
argument_list|(
name|CAN
argument_list|,
literal|1
argument_list|)
operator|,
name|xmit_byte
argument_list|(
name|CAN
argument_list|,
literal|1
argument_list|)
operator|,
name|xmit_byte
argument_list|(
name|CAN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Remote system not responding"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check for too many transmission errors 	 */
if|if
condition|(
name|errors
operator|>=
name|ERRORMAX
condition|)
block|{
name|xmit_byte
argument_list|(
name|CAN
argument_list|,
literal|1
argument_list|)
operator|,
name|xmit_byte
argument_list|(
name|CAN
argument_list|,
literal|1
argument_list|)
operator|,
name|xmit_byte
argument_list|(
name|CAN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Too many errors in transmission"
argument_list|)
expr_stmt|;
block|}
name|attempts
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Indicate the transfer is complete 	 */
name|xmit_byte
argument_list|(
name|EOT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Wait until i960 acknowledges us 	 */
while|while
condition|(
operator|(
name|c
operator|=
name|getbyte
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
name|ACK
operator|&&
operator|(
operator|++
name|attempts
operator|<
name|RETRYMAX
operator|)
condition|)
name|xmit_byte
argument_list|(
name|EOT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|attempts
operator|>=
name|RETRYMAX
condition|)
name|error
argument_list|(
literal|"Remote system not responding on completion"
argument_list|)
expr_stmt|;
comment|/* 	 * After download, we'll see a few more command  	 * prompts as the CP does its stuff. Ignore them. 	 */
while|while
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"=>"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
name|getline
argument_list|(
name|verbose
argument_list|)
expr_stmt|;
while|while
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"=>"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
name|getline
argument_list|(
name|verbose
argument_list|)
expr_stmt|;
while|while
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"=>"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
name|getline
argument_list|(
name|verbose
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the i960 to start executing the downloaded code 	 */
name|xmit_to_i960
argument_list|(
literal|"go\r\n"
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Get the messages the CP will spit out 	 * after the GO command. 	 */
name|getline
argument_list|(
name|verbose
argument_list|)
expr_stmt|;
name|getline
argument_list|(
name|verbose
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|loadmicrocode
parameter_list|(
name|ucode
parameter_list|,
name|size
parameter_list|,
name|ram
parameter_list|)
name|u_char
modifier|*
name|ucode
decl_stmt|;
name|int
name|size
decl_stmt|;
name|u_char
modifier|*
name|ram
decl_stmt|;
block|{
struct|struct
block|{
name|u_long
name|Id
decl_stmt|;
name|u_long
name|fver
decl_stmt|;
name|u_long
name|start
decl_stmt|;
name|u_long
name|entry
decl_stmt|;
block|}
name|binhdr
struct|;
ifdef|#
directive|ifdef
name|sun
union|union
block|{
name|u_long
name|w
decl_stmt|;
name|char
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|w1
union|,
name|w2
union|;
endif|#
directive|endif
name|int
name|n
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|bufp
decl_stmt|;
name|u_long
modifier|*
name|lp
decl_stmt|;
comment|/* 	 * Check that we understand this header 	 */
name|memcpy
argument_list|(
operator|&
name|binhdr
argument_list|,
name|ucode
argument_list|,
sizeof|sizeof
argument_list|(
name|binhdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|binhdr
operator|.
name|Id
argument_list|,
literal|"fore"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unrecognized format in micorcode file."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|sun
comment|/* 	 * We always swap the SunOS microcode file... 	 */
name|endian
operator|=
literal|1
expr_stmt|;
comment|/* 	 * We need to swap the header start/entry words... 	 */
name|w1
operator|.
name|w
operator|=
name|binhdr
operator|.
name|start
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|;
name|n
operator|++
control|)
name|w2
operator|.
name|c
index|[
literal|3
operator|-
name|n
index|]
operator|=
name|w1
operator|.
name|c
index|[
name|n
index|]
expr_stmt|;
name|binhdr
operator|.
name|start
operator|=
name|w2
operator|.
name|w
expr_stmt|;
name|w1
operator|.
name|w
operator|=
name|binhdr
operator|.
name|entry
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|;
name|n
operator|++
control|)
name|w2
operator|.
name|c
index|[
literal|3
operator|-
name|n
index|]
operator|=
name|w1
operator|.
name|c
index|[
name|n
index|]
expr_stmt|;
name|binhdr
operator|.
name|entry
operator|=
name|w2
operator|.
name|w
expr_stmt|;
endif|#
directive|endif
comment|/* sun */
comment|/* 	 * Set pointer to RAM load location 	 */
name|bufp
operator|=
operator|(
name|ram
operator|+
name|binhdr
operator|.
name|start
operator|)
expr_stmt|;
comment|/* 	 * Load file 	 */
if|if
condition|(
name|endian
condition|)
block|{
name|int
name|i
decl_stmt|;
name|lp
operator|=
operator|(
name|u_long
operator|*
operator|)
name|ucode
expr_stmt|;
comment|/* Swap buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|;
name|i
operator|++
control|)
ifndef|#
directive|ifndef
name|sun
name|lp
index|[
name|i
index|]
operator|=
name|CP_WRITE
argument_list|(
name|lp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|int
name|j
decl_stmt|;
name|w1
operator|.
name|w
operator|=
name|lp
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
name|w2
operator|.
name|c
index|[
literal|3
operator|-
name|j
index|]
operator|=
name|w1
operator|.
name|c
index|[
name|j
index|]
expr_stmt|;
name|lp
index|[
name|i
index|]
operator|=
name|w2
operator|.
name|w
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ucode
argument_list|,
name|bufp
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* 	 * With .bin extension, we need to specify start address on 'go' 	 * command. 	 */
block|{
name|char
name|cmd
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"go %lx\r\n"
argument_list|,
name|binhdr
operator|.
name|entry
argument_list|)
expr_stmt|;
name|xmit_to_i960
argument_list|(
name|cmd
argument_list|,
name|strlen
argument_list|(
name|cmd
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
name|cmd
argument_list|,
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|-
literal|3
argument_list|)
operator|!=
literal|0
condition|)
name|getline
argument_list|(
name|verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sendbinfile
parameter_list|(
name|fname
parameter_list|,
name|ram
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|u_char
modifier|*
name|ram
decl_stmt|;
block|{
struct|struct
block|{
name|u_long
name|Id
decl_stmt|;
name|u_long
name|fver
decl_stmt|;
name|u_long
name|start
decl_stmt|;
name|u_long
name|entry
decl_stmt|;
block|}
name|binhdr
struct|;
ifdef|#
directive|ifdef
name|sun
union|union
block|{
name|u_long
name|w
decl_stmt|;
name|char
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|w1
union|,
name|w2
union|;
endif|#
directive|endif
name|int
name|fd
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|bufp
decl_stmt|;
name|long
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
comment|/* 	 * Try opening file 	 */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Read the .bin header from the file 	 */
if|if
condition|(
operator|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|binhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|binhdr
argument_list|)
argument_list|)
operator|)
operator|!=
sizeof|sizeof
argument_list|(
name|binhdr
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Check that we understand this header 	 */
if|if
condition|(
name|strncmp
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|binhdr
operator|.
name|Id
argument_list|,
literal|"fore"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unrecognized format in micorcode file."
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|sun
comment|/* 	 * We always swap the SunOS microcode file... 	 */
name|endian
operator|=
literal|1
expr_stmt|;
comment|/* 	 * We need to swap the header start/entry words... 	 */
name|w1
operator|.
name|w
operator|=
name|binhdr
operator|.
name|start
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|;
name|n
operator|++
control|)
name|w2
operator|.
name|c
index|[
literal|3
operator|-
name|n
index|]
operator|=
name|w1
operator|.
name|c
index|[
name|n
index|]
expr_stmt|;
name|binhdr
operator|.
name|start
operator|=
name|w2
operator|.
name|w
expr_stmt|;
name|w1
operator|.
name|w
operator|=
name|binhdr
operator|.
name|entry
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|;
name|n
operator|++
control|)
name|w2
operator|.
name|c
index|[
literal|3
operator|-
name|n
index|]
operator|=
name|w1
operator|.
name|c
index|[
name|n
index|]
expr_stmt|;
name|binhdr
operator|.
name|entry
operator|=
name|w2
operator|.
name|w
expr_stmt|;
endif|#
directive|endif
comment|/* sun */
comment|/* 	 * Rewind the file 	 */
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Set pointer to RAM load location 	 */
name|bufp
operator|=
operator|(
name|ram
operator|+
name|binhdr
operator|.
name|start
operator|)
expr_stmt|;
comment|/* 	 * Load file 	 */
if|if
condition|(
name|endian
condition|)
block|{
comment|/* 		 * Need to swap longs - copy file into temp buffer 		 */
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Swap buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|;
name|i
operator|++
control|)
ifndef|#
directive|ifndef
name|sun
name|buffer
index|[
name|i
index|]
operator|=
name|CP_WRITE
argument_list|(
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|int
name|j
decl_stmt|;
name|w1
operator|.
name|w
operator|=
name|buffer
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
name|w2
operator|.
name|c
index|[
literal|3
operator|-
name|j
index|]
operator|=
name|w1
operator|.
name|c
index|[
name|j
index|]
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|=
name|w2
operator|.
name|w
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 			 * Copy swapped buffer into CP RAM 			 */
name|cnt
operator|++
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|buffer
argument_list|,
name|bufp
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%d\r"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|n
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|bufp
argument_list|,
literal|128
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%d\r"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|n
expr_stmt|;
block|}
block|}
comment|/* 	 * With .bin extension, we need to specify start address on 'go' 	 * command. 	 */
block|{
name|char
name|cmd
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"go %lx\r\n"
argument_list|,
name|binhdr
operator|.
name|entry
argument_list|)
expr_stmt|;
name|xmit_to_i960
argument_list|(
name|cmd
argument_list|,
name|strlen
argument_list|(
name|cmd
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
name|cmd
argument_list|,
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|-
literal|3
argument_list|)
operator|!=
literal|0
condition|)
name|getline
argument_list|(
name|verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Program to download previously processed microcode to series-200 host adapter  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
comment|/* mmap for Uart */
name|u_char
modifier|*
name|ram
decl_stmt|;
comment|/* pointer to RAM */
name|Mon960
modifier|*
name|Mon
decl_stmt|;
comment|/* Uart */
name|Aali
modifier|*
name|aap
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|int
name|binary
init|=
literal|0
decl_stmt|;
comment|/* Send binary file */
name|caddr_t
name|buf
decl_stmt|;
comment|/* Ioctl buffer */
name|char
name|bus_dev
index|[
literal|80
index|]
decl_stmt|;
comment|/* Bus device to mmap on */
name|struct
name|atminfreq
name|req
decl_stmt|;
name|struct
name|air_cfg_rsp
modifier|*
name|air
decl_stmt|;
comment|/* Config info response structure */
name|int
name|buf_len
decl_stmt|;
comment|/* Size of ioctl buffer */
name|char
modifier|*
name|devname
init|=
literal|"\0"
decl_stmt|;
comment|/* Device to download */
name|char
modifier|*
name|dirname
init|=
name|NULL
decl_stmt|;
comment|/* Directory path to objd files */
name|char
modifier|*
name|objfile
init|=
name|NULL
decl_stmt|;
comment|/* Command line object filename */
name|u_char
modifier|*
name|ucode
init|=
name|NULL
decl_stmt|;
comment|/* Pointer to microcode */
name|int
name|ucode_size
init|=
literal|0
decl_stmt|;
comment|/* Length of microcode */
name|char
modifier|*
name|sndfile
init|=
name|NULL
decl_stmt|;
comment|/* Object filename to download */
name|char
name|filename
index|[
literal|64
index|]
decl_stmt|;
comment|/* Constructed object filename */
name|char
name|base
index|[
literal|64
index|]
decl_stmt|;
comment|/* sba200/sba200e/pca200e basename */
name|int
name|ext
init|=
literal|0
decl_stmt|;
comment|/* 0 == bin 1 == objd */
name|struct
name|stat
name|sbuf
decl_stmt|;
comment|/* Used to find if .bin or .objd */
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|progname
operator|=
operator|(
name|char
operator|*
operator|)
name|basename
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|comm_mode
operator|=
name|strcmp
argument_list|(
name|progname
argument_list|,
literal|"fore_comm"
argument_list|)
operator|==
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"i:d:f:berv"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|binary
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|endian
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|devname
operator|=
operator|(
name|char
operator|*
operator|)
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|objfile
operator|=
operator|(
name|char
operator|*
operator|)
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|reset
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|printf
argument_list|(
literal|"usage: %s [-v] [-i intf] [-d dirname] [-f objfile]\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Unbuffer stdout 	 */
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|AF_ATM
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Cannot create ATM socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Over allocate memory for returned data. This allows 	 * space for IOCTL reply info as well as config info. 	 */
name|buf_len
operator|=
literal|4
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|air_cfg_rsp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
name|buf_len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"Cannot allocate memory for reply"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill in request paramaters 	 */
name|req
operator|.
name|air_opcode
operator|=
name|AIOCS_INF_CFG
expr_stmt|;
name|req
operator|.
name|air_buf_addr
operator|=
name|buf
expr_stmt|;
name|req
operator|.
name|air_buf_len
operator|=
name|buf_len
expr_stmt|;
comment|/* 	 * Copy interface name into ioctl request 	 */
name|strcpy
argument_list|(
name|req
operator|.
name|air_cfg_intf
argument_list|,
name|devname
argument_list|)
expr_stmt|;
comment|/* 	 * Issue ioctl 	 */
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|AIOCINFO
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|req
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl (AIOCSINFO)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reset buffer pointer 	 */
name|req
operator|.
name|air_buf_addr
operator|=
name|buf
expr_stmt|;
comment|/* 	 * Close socket 	 */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * Loop through all attached adapters 	 */
for|for
control|(
init|;
name|req
operator|.
name|air_buf_len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|air_cfg_rsp
argument_list|)
condition|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|air_cfg_rsp
argument_list|)
operator|,
name|req
operator|.
name|air_buf_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|air_cfg_rsp
argument_list|)
control|)
block|{
comment|/* 		 * Point to vendor info 		 */
name|air
operator|=
operator|(
expr|struct
name|air_cfg_rsp
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|air
operator|->
name|acp_vendor
operator|==
name|VENDOR_FORE
condition|)
block|{
comment|/* 			 * Create /dev name 			 */
ifdef|#
directive|ifdef
name|sun
name|sprintf
argument_list|(
name|bus_dev
argument_list|,
name|DEV_NAME
argument_list|,
name|air
operator|->
name|acp_busslot
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|bus_dev
argument_list|,
name|DEV_NAME
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Setup signal handlers 			 */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* 			 * If comm_mode, setup terminal for single char I/O 			 */
if|if
condition|(
name|comm_mode
condition|)
block|{
name|tty
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|sgtty
argument_list|)
expr_stmt|;
name|sgtty
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|ECHO
operator|)
expr_stmt|;
name|vmin
operator|=
name|sgtty
operator|.
name|c_cc
index|[
name|VMIN
index|]
expr_stmt|;
name|vtime
operator|=
name|sgtty
operator|.
name|c_cc
index|[
name|VTIME
index|]
expr_stmt|;
name|sgtty
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|0
expr_stmt|;
name|sgtty
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|sgtty
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Open bus for memory access 			 */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|bus_dev
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"open bus_dev"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s download failed (%s)\n"
argument_list|,
name|air
operator|->
name|acp_intf
argument_list|,
name|bus_dev
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Map in the RAM memory to get access to the Uart 			 */
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/*XXX*/
name|ram
operator|=
operator|(
name|u_char
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
argument|PCA200E_MMAP_SIZE
argument_list|,
else|#
directive|else
argument|ram = (u_char *) mmap(
literal|0
argument|, air->acp_ramsize,
endif|#
directive|endif
argument|PROT_READ | PROT_WRITE, MAP_SHARED, 				fd, air->acp_ram); 			if (ram == (u_char *)-
literal|1
argument|) { 				perror (
literal|"mmap ram"
argument|); 				fprintf(stderr,
literal|"%s download failed\n"
argument|, 					air->acp_intf); 				(void) close(fd); 				continue; 			} 			Mon = (Mon960 *)(ram + MON960_BASE); 			Uart = (Mon960 *)&(Mon->mon_xmitmon);
comment|/* 			 * Determine endianess 			 */
argument|switch ( Mon->mon_bstat ) { 			case BOOT_COLDSTART: 			case BOOT_MONREADY: 			case BOOT_FAILTEST: 			case BOOT_RUNNING: 				break;  			default: 				switch (ntohl(Mon->mon_bstat)) { 				case BOOT_COLDSTART: 				case BOOT_MONREADY: 				case BOOT_FAILTEST: 				case BOOT_RUNNING: 					endian++; 					break;  				default: 					fprintf(stderr,
literal|"%s unknown status\n"
argument|, 						air->acp_intf); 					(void) close(fd); 					continue; 				} 				break; 			}
ifdef|#
directive|ifdef
name|__FreeBSD__
argument|if (reset) { 				u_int	*hcr = (u_int *)(ram + PCA200E_HCR_OFFSET); 				PCA200E_HCR_INIT(*hcr, PCA200E_RESET_BD); 				delay(
literal|10000
argument|); 				PCA200E_HCR_CLR(*hcr, PCA200E_RESET_BD); 				delay(
literal|10000
argument|); 			}
endif|#
directive|endif
argument|if ( comm_mode ) { 			    static struct timeval timeout = {
literal|0
argument_list|,
literal|0
argument|}; 			    int	esc_seen =
literal|0
argument|;
comment|/* 			     * We want to talk with the i960 monitor 			     */
comment|/* 			     * Loop forever accepting characters 			     */
argument|for ( ; ; ) { 				fd_set	fdr; 				int	ns;
comment|/* 				 * Check for data from the terminal 				 */
argument|FD_ZERO (&fdr ); 				FD_SET ( fileno(stdin),&fdr );  				if ( ( ns = select ( FD_SETSIZE,&fdr, NULL, NULL,&timeout ) )<
literal|0
argument|) { 						perror (
literal|"select"
argument|); 						finish( -
literal|1
argument|); 				}  				if ( ns ) { 					int	c; 					int	nr;  					nr = read ( fileno(stdin),&c,
literal|1
argument|); 					c&=
literal|0xff
argument|; 					if ( !esc_seen ) { 					    if ( c ==
literal|27
argument|) 						esc_seen++; 					    else 						xmit_byte ( c,
literal|0
argument|); 					} else { 					    if ( c ==
literal|27
argument|)  						finish( -
literal|1
argument|); 					    else { 						xmit_byte (
literal|27
argument|,
literal|0
argument|); 						esc_seen =
literal|0
argument|; 					    } 					    xmit_byte ( c,
literal|0
argument|); 					} 				}
comment|/* 				 * Check for data from the i960 				 */
argument|if ( CP_READ(Uart->mon_xmithost)& UART_VALID ) { 					c = getbyte(
literal|0
argument|); 					putchar ( c ); 				} 				if ( strcmp ( line,
literal|"Mon960"
argument|)  ==
literal|0
argument|) 					autobaud();  			    } 			} else {
comment|/* 			     * Make sure the driver is loaded and that the CP 			     * is ready for commands 			     */
argument|if ( CP_READ(Mon->mon_bstat) == BOOT_RUNNING ) 			    { 				fprintf ( stderr,
literal|"%s is up and running - no download allowed.\n"
argument|, 					air->acp_intf ); 				(void) close(fd); 				continue; 			    } 		 			    if ( CP_READ(Mon->mon_bstat) != BOOT_MONREADY ) 			    { 				fprintf ( stderr,
literal|"%s is not ready for downloading.\n"
argument|,  					air->acp_intf ); 				(void) close(fd); 				continue; 			    }
comment|/* 			     * Indicate who we're downloading 			     */
argument|if ( verbose ) 				printf (
literal|"Downloading code for %s\n"
argument|, 					air->acp_intf );
comment|/* 			     * Look for the i960 monitor message.  			     * We should see this after a board reset. 			     */
argument|while ( strncmp ( line,
literal|"Mon960"
argument|,
literal|6
argument|) !=
literal|0
argument|&&  				strncmp ( line,
literal|"=>"
argument|,
literal|2
argument|) !=
literal|0
argument|) 				getline( verbose );
comment|/* Verbose */
comment|/* 			     * Autobaud fakery 			     */
argument|if ( strncmp ( line,
literal|"Mon960"
argument|,
literal|6
argument|) ==
literal|0
argument|) { 				xmit_to_i960 (
literal|"\r\n\r\n\r\n\r\n"
argument|,
literal|8
argument|,
literal|0
argument|); 				delay (
literal|10000
argument|); 			    }
comment|/* 			     * Keep reading until we get a command prompt 			     */
argument|while ( strncmp ( line,
literal|"=>"
argument|,
literal|2
argument|) !=
literal|0
argument|) 				getline( verbose );
comment|/* Verbose */
comment|/* 			     * Choose the correct microcode file based on the 			     * adapter type the card claims to be. 			     */
argument|switch ( air->acp_device ) 			    { 			    case DEV_FORE_SBA200: 				sprintf ( base,
literal|"sba200"
argument|); 				break;  			    case DEV_FORE_SBA200E: 				sprintf ( base,
literal|"sba200e"
argument|); 				break;  			    case DEV_FORE_PCA200E: 				sprintf ( base,
literal|"pca200e"
argument|); 				break;   			    default: 				err =
literal|1
argument|; 				fprintf(stderr,
literal|"Unknown adapter type: %d\n"
argument|,  					air->acp_device ); 			    }  			    sndfile = NULL;  			    if ( objfile == NULL ) { 				switch ( air->acp_device ) { 				case DEV_FORE_SBA200: 				case DEV_FORE_SBA200E: 				    sprintf ( filename,
literal|"%s.bin%d"
argument|, base, 					air->acp_bustype ); 				    if ( stat ( filename,&sbuf ) == -
literal|1
argument|) { 					sprintf ( filename,
literal|"%s/%s.bin%d"
argument|, 					    dirname, base, 						air->acp_bustype ); 					if ( stat ( filename,&sbuf ) == -
literal|1
argument|) { 					    ext =
literal|1
argument|; 					    sprintf ( filename,
literal|"%s.objd%d"
argument|, 						base, air->acp_bustype ); 					    if ( stat(filename,&sbuf) == -
literal|1
argument|) { 						sprintf ( filename,
literal|"%s/%s.objd%d"
argument|, dirname, 							base, 							    air->acp_bustype ); 						if ( stat ( filename,&sbuf ) != -
literal|1
argument|) 						    sndfile = filename; 					    } else 						sndfile = filename; 					} else 					    sndfile = filename; 				    } else 					sndfile = filename; 				    break; 				case DEV_FORE_PCA200E:
comment|/* Use compiled in microcode */
argument|ucode = pca200e_microcode; 				    ucode_size = pca200e_microcode_size; 				    break; 				default: 				    break; 			        } 			    } else 				sndfile = objfile;  			    if ( ext&& !binary ) 				err = xmitfile ( sndfile ); 			    else if (sndfile != NULL)  				err = sendbinfile ( sndfile, ram ); 			    else  				err = loadmicrocode( ucode, ucode_size, ram );  			    if ( err ) { 				fprintf(stderr,
literal|"%s download failed\n"
argument|, 					air->acp_intf); 				(void) close(fd); 				continue; 			    }
comment|/* 			     * Download completed - wait around a while for 			     * the driver to initialize the adapter 			     */
argument|aap = (Aali *)(ram + CP_READ(Mon->mon_appl)); 			     for (i =
literal|0
argument|; i< MAX_CHECK; i++, sleep(
literal|1
argument|)) { 				u_long	hb1
argument_list|,
argument|hb2;  				if (CP_READ(Mon->mon_bstat) != BOOT_RUNNING) 					continue;  				hb1 = CP_READ(aap->aali_heartbeat); 				delay(
literal|1
argument|); 				hb2 = CP_READ(aap->aali_heartbeat); 				if (hb1< hb2) 					break; 			     } 			}  			close ( fd ); 		} 	}
comment|/* 	 * Exit 	 */
argument|exit (
literal|0
argument|);  }
end_function

end_unit

