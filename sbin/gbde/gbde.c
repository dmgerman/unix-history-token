begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Poul-Henning Kamp  * Copyright (c) 2002 Networks Associates Technology, Inc.  * All rights reserved.  *  * This software was developed for the FreeBSD Project by Poul-Henning Kamp  * and NAI Labs, the Security Research Division of Network Associates, Inc.  * under DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the  * DARPA CHATS research program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  * XXX: Future stuff  *  * Replace the template file options (-i& -f) with command-line variables  * "-v property=foo"  *  * Introduce -e, extra entropy source (XOR with /dev/random)  *  * Introduce -E, alternate entropy source (instead of /dev/random)  *  * Introduce -i take IV from keyboard or  *  * Introduce -I take IV from file/cmd  *  * Introduce -m/-M store encrypted+encoded masterkey in file  *  * Introduce -k/-K get pass-phrase part from file/cmd  *  * Introduce -d add more dest-devices to worklist.  *  * Add key-option: selfdestruct bit.  *  * New/changed verbs:  *	"onetime"	attach with onetime nonstored locksector  *	"key"/"unkey" to blast memory copy of key without orphaning  *	"nuke" blow away everything attached, crash/halt/power-off if possible.  *	"blast" destroy all copies of the masterkey  *	"destroy" destroy one copy of the masterkey  *	"backup"/"restore" of masterkey sectors.  *  * Make all verbs work on both attached/detached devices.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<md5.h>
end_include

begin_include
include|#
directive|include
file|<readpassphrase.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|<libgeom.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<crypto/rijndael/rijndael-api-fst.h>
end_include

begin_include
include|#
directive|include
file|<crypto/sha2/sha2.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_define
define|#
directive|define
name|GBDEMOD
value|"geom_bde"
end_define

begin_define
define|#
directive|define
name|KASSERT
parameter_list|(
name|foo
parameter_list|,
name|bar
parameter_list|)
value|do { if(!(foo)) { warn bar ; exit (1); } } while (0)
end_define

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/bde/g_bde.h>
end_include

begin_decl_stmt
specifier|extern
specifier|const
name|char
name|template
index|[]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void g_hexdump(void *ptr, int length) { 	int i, j, k; 	unsigned char *cp;  	cp = ptr; 	for (i = 0; i< length; i+= 16) { 		printf("%04x  ", i); 		for (j = 0; j< 16; j++) { 			k = i + j; 			if (k< length) 				printf(" %02x", cp[k]); 			else 				printf("   "); 		} 		printf("  |"); 		for (j = 0; j< 16; j++) { 			k = i + j; 			if (k>= length) 				printf(" "); 			else if (cp[k]>= ' '&& cp[k]<= '~') 				printf("%c", cp[k]); 			else 				printf("."); 		} 		printf("|\n"); 	} }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|__dead2
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: gbde attach destination [-k keyfile] [-l lockfile] [-p pass-phrase]\n"
literal|"       gbde detach destination\n"
literal|"       gbde init destination [-i] [-f filename] [-K new-keyfile]\n"
literal|"            [-L new-lockfile] [-P new-pass-phrase]\n"
literal|"       gbde setkey destination [-n key]\n"
literal|"            [-k keyfile] [-l lockfile] [-p pass-phrase]\n"
literal|"            [-K new-keyfile] [-L new-lockfile] [-P new-pass-phrase]\n"
literal|"       gbde nuke destination [-n key]\n"
literal|"            [-k keyfile] [-l lockfile] [-p pass-phrase]\n"
literal|"       gbde destroy destination [-k keyfile] [-l lockfile] [-p pass-phrase]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|g_read_data
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|off_t
name|length
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|;
name|off_t
name|o2
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|cp
expr_stmt|;
name|o2
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|o2
operator|!=
name|offset
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"lseek"
argument_list|)
expr_stmt|;
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|length
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"read"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|NULL
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|random_bits
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
specifier|static
name|int
name|fdr
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fdr
operator|<
literal|0
condition|)
block|{
name|fdr
operator|=
name|open
argument_list|(
literal|"/dev/urandom"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdr
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"/dev/urandom"
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|read
argument_list|(
name|fdr
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|int
operator|)
name|len
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"read from /dev/urandom"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX: not nice */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|sha2
index|[
name|SHA512_DIGEST_LENGTH
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|reset_passphrase
parameter_list|(
name|struct
name|g_bde_softc
modifier|*
name|sc
parameter_list|)
block|{
name|memcpy
argument_list|(
name|sc
operator|->
name|sha2
argument_list|,
name|sha2
argument_list|,
name|SHA512_DIGEST_LENGTH
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_passphrase
parameter_list|(
name|struct
name|g_bde_softc
modifier|*
name|sc
parameter_list|,
name|int
name|sure
parameter_list|,
specifier|const
name|char
modifier|*
name|input
parameter_list|,
specifier|const
name|char
modifier|*
name|keyfile
parameter_list|)
block|{
name|char
name|buf1
index|[
name|BUFSIZ
operator|+
name|SHA512_DIGEST_LENGTH
index|]
decl_stmt|;
name|char
name|buf2
index|[
name|BUFSIZ
operator|+
name|SHA512_DIGEST_LENGTH
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|kfd
decl_stmt|,
name|klen
decl_stmt|,
name|bpos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|keyfile
operator|!=
name|NULL
condition|)
block|{
comment|/* Read up to BUFSIZ bytes from keyfile */
name|kfd
operator|=
name|open
argument_list|(
name|keyfile
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|kfd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|keyfile
argument_list|)
expr_stmt|;
name|klen
operator|=
name|read
argument_list|(
name|kfd
argument_list|,
name|buf1
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|klen
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|keyfile
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|kfd
argument_list|)
expr_stmt|;
comment|/* Prepend the passphrase with the hash of the key read */
name|g_bde_hash_pass
argument_list|(
name|sc
argument_list|,
name|buf1
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf1
argument_list|,
name|sc
operator|->
name|sha2
argument_list|,
name|SHA512_DIGEST_LENGTH
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf2
argument_list|,
name|sc
operator|->
name|sha2
argument_list|,
name|SHA512_DIGEST_LENGTH
argument_list|)
expr_stmt|;
name|bpos
operator|=
name|SHA512_DIGEST_LENGTH
expr_stmt|;
block|}
if|if
condition|(
name|input
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|input
argument_list|)
operator|>=
name|BUFSIZ
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Passphrase too long"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf1
operator|+
name|bpos
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|g_bde_hash_pass
argument_list|(
name|sc
argument_list|,
name|buf1
argument_list|,
name|strlen
argument_list|(
name|buf1
operator|+
name|bpos
argument_list|)
operator|+
name|bpos
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sha2
argument_list|,
name|sc
operator|->
name|sha2
argument_list|,
name|SHA512_DIGEST_LENGTH
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|p
operator|=
name|readpassphrase
argument_list|(
name|sure
condition|?
literal|"Enter new passphrase:"
else|:
literal|"Enter passphrase: "
argument_list|,
name|buf1
operator|+
name|bpos
argument_list|,
sizeof|sizeof
name|buf1
operator|-
name|bpos
argument_list|,
name|RPP_ECHO_OFF
operator||
name|RPP_REQUIRE_TTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"readpassphrase"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sure
condition|)
block|{
name|p
operator|=
name|readpassphrase
argument_list|(
literal|"Reenter new passphrase: "
argument_list|,
name|buf2
operator|+
name|bpos
argument_list|,
sizeof|sizeof
name|buf2
operator|-
name|bpos
argument_list|,
name|RPP_ECHO_OFF
operator||
name|RPP_REQUIRE_TTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"readpassphrase"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf1
operator|+
name|bpos
argument_list|,
name|buf2
operator|+
name|bpos
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"They didn't match.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|strlen
argument_list|(
name|buf1
operator|+
name|bpos
argument_list|)
operator|<
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"Too short passphrase.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|g_bde_hash_pass
argument_list|(
name|sc
argument_list|,
name|buf1
argument_list|,
name|strlen
argument_list|(
name|buf1
operator|+
name|bpos
argument_list|)
operator|+
name|bpos
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sha2
argument_list|,
name|sc
operator|->
name|sha2
argument_list|,
name|SHA512_DIGEST_LENGTH
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|encrypt_sector
parameter_list|(
name|void
modifier|*
name|d
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|klen
parameter_list|,
name|void
modifier|*
name|key
parameter_list|)
block|{
name|keyInstance
name|ki
decl_stmt|;
name|cipherInstance
name|ci
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|rijndael_cipherInit
argument_list|(
operator|&
name|ci
argument_list|,
name|MODE_CBC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"rijndael_cipherInit=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|rijndael_makeKey
argument_list|(
operator|&
name|ki
argument_list|,
name|DIR_ENCRYPT
argument_list|,
name|klen
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"rijndael_makeKeY=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|rijndael_blockEncrypt
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|ki
argument_list|,
name|d
argument_list|,
name|len
operator|*
literal|8
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"rijndael_blockEncrypt=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cmd_attach
parameter_list|(
specifier|const
name|struct
name|g_bde_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|lfile
parameter_list|)
block|{
name|int
name|ffd
decl_stmt|;
name|u_char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|gctl_req
modifier|*
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|r
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"create geom"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"BDE"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"provider"
argument_list|,
operator|-
literal|1
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"pass"
argument_list|,
name|SHA512_DIGEST_LENGTH
argument_list|,
name|sc
operator|->
name|sha2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lfile
operator|!=
name|NULL
condition|)
block|{
name|ffd
operator|=
name|open
argument_list|(
name|lfile
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|lfile
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|ffd
argument_list|,
name|buf
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"key"
argument_list|,
literal|16
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ffd
argument_list|)
expr_stmt|;
block|}
comment|/* gctl_dump(r, stdout); */
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Attach to %s failed: %s"
argument_list|,
name|dest
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cmd_detach
parameter_list|(
specifier|const
name|char
modifier|*
name|dest
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|r
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"destroy geom"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"BDE"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s.bde"
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"geom"
argument_list|,
operator|-
literal|1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* gctl_dump(r, stdout); */
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Detach of %s failed: %s"
argument_list|,
name|dest
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cmd_open
parameter_list|(
name|struct
name|g_bde_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dfd
parameter_list|,
specifier|const
name|char
modifier|*
name|l_opt
parameter_list|,
name|u_int
modifier|*
name|nkey
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|ffd
decl_stmt|;
name|u_char
name|keyloc
index|[
literal|16
index|]
decl_stmt|;
name|u_int
name|sectorsize
decl_stmt|;
name|off_t
name|mediasize
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|error
operator|=
name|ioctl
argument_list|(
name|dfd
argument_list|,
name|DIOCGSECTORSIZE
argument_list|,
operator|&
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|sectorsize
operator|=
literal|512
expr_stmt|;
name|error
operator|=
name|ioctl
argument_list|(
name|dfd
argument_list|,
name|DIOCGMEDIASIZE
argument_list|,
operator|&
name|mediasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
name|fstat
argument_list|(
name|dfd
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|mediasize
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
else|else
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|mediasize
operator|=
operator|(
name|off_t
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|l_opt
operator|!=
name|NULL
condition|)
block|{
name|ffd
operator|=
name|open
argument_list|(
name|l_opt
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|l_opt
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|ffd
argument_list|,
name|keyloc
argument_list|,
sizeof|sizeof
name|keyloc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ffd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|keyloc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|keyloc
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|g_bde_decrypt_lock
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sha2
argument_list|,
name|keyloc
argument_list|,
name|mediasize
argument_list|,
name|sectorsize
argument_list|,
name|nkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Lock was destroyed."
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ESRCH
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Lock was nuked."
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOTDIR
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Lock not found"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Error %d decrypting lock"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkey
condition|)
name|printf
argument_list|(
literal|"Opened with key %u\n"
argument_list|,
operator|*
name|nkey
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|cmd_nuke
parameter_list|(
name|struct
name|g_bde_key
modifier|*
name|gl
parameter_list|,
name|int
name|dfd
parameter_list|,
name|int
name|key
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
modifier|*
name|sbuf
decl_stmt|;
name|off_t
name|offset
decl_stmt|,
name|offset2
decl_stmt|;
name|sbuf
operator|=
name|malloc
argument_list|(
name|gl
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sbuf
argument_list|,
literal|0
argument_list|,
name|gl
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|gl
operator|->
name|lsector
index|[
name|key
index|]
operator|&
operator|~
operator|(
name|gl
operator|->
name|sectorsize
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|offset2
operator|=
name|lseek
argument_list|(
name|dfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset2
operator|!=
name|offset
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"lseek"
argument_list|)
expr_stmt|;
name|i
operator|=
name|write
argument_list|(
name|dfd
argument_list|,
name|sbuf
argument_list|,
name|gl
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|int
operator|)
name|gl
operator|->
name|sectorsize
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Nuked key %d\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cmd_write
parameter_list|(
name|struct
name|g_bde_key
modifier|*
name|gl
parameter_list|,
name|struct
name|g_bde_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dfd
parameter_list|,
name|int
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|l_opt
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ffd
decl_stmt|;
name|uint64_t
name|off
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|keyloc
index|[
literal|16
index|]
decl_stmt|;
name|u_char
modifier|*
name|sbuf
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|off_t
name|offset
decl_stmt|,
name|offset2
decl_stmt|;
name|sbuf
operator|=
name|malloc
argument_list|(
name|gl
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
comment|/* 	 * Find the byte-offset in the lock sector where we will put the lock 	 * data structure.  We can put it any random place as long as the 	 * structure fits. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|random_bits
argument_list|(
name|off
argument_list|,
sizeof|sizeof
name|off
argument_list|)
expr_stmt|;
name|off
index|[
literal|0
index|]
operator|&=
operator|(
name|gl
operator|->
name|sectorsize
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|off
index|[
literal|0
index|]
operator|+
name|G_BDE_LOCKSIZE
operator|>
name|gl
operator|->
name|sectorsize
condition|)
continue|continue;
break|break;
block|}
comment|/* Add the sector offset in bytes */
name|off
index|[
literal|0
index|]
operator|+=
operator|(
name|gl
operator|->
name|lsector
index|[
name|key
index|]
operator|&
operator|~
operator|(
name|gl
operator|->
name|sectorsize
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|gl
operator|->
name|lsector
index|[
name|key
index|]
operator|=
name|off
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|=
name|g_bde_keyloc_encrypt
argument_list|(
name|sc
operator|->
name|sha2
argument_list|,
name|off
index|[
literal|0
index|]
argument_list|,
name|off
index|[
literal|1
index|]
argument_list|,
name|keyloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"g_bde_keyloc_encrypt()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_opt
operator|!=
name|NULL
condition|)
block|{
name|ffd
operator|=
name|open
argument_list|(
name|l_opt
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|l_opt
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|ffd
argument_list|,
name|keyloc
argument_list|,
sizeof|sizeof
name|keyloc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ffd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gl
operator|->
name|flags
operator|&
name|GBDE_F_SECT0
condition|)
block|{
name|offset2
operator|=
name|lseek
argument_list|(
name|dfd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset2
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"lseek"
argument_list|)
expr_stmt|;
name|i
operator|=
name|read
argument_list|(
name|dfd
argument_list|,
name|sbuf
argument_list|,
name|gl
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|int
operator|)
name|gl
operator|->
name|sectorsize
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"read"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sbuf
operator|+
name|key
operator|*
literal|16
argument_list|,
name|keyloc
argument_list|,
sizeof|sizeof
name|keyloc
argument_list|)
expr_stmt|;
name|offset2
operator|=
name|lseek
argument_list|(
name|dfd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset2
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"lseek"
argument_list|)
expr_stmt|;
name|i
operator|=
name|write
argument_list|(
name|dfd
argument_list|,
name|sbuf
argument_list|,
name|gl
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|int
operator|)
name|gl
operator|->
name|sectorsize
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"No -L option and no space in sector 0 for lockfile"
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate a sectorbuffer and fill it with random junk */
if|if
condition|(
name|sbuf
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|random_bits
argument_list|(
name|sbuf
argument_list|,
name|gl
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
comment|/* Fill random bits in the spare field */
name|random_bits
argument_list|(
name|gl
operator|->
name|spare
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
operator|->
name|spare
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Encode the structure where we want it */
name|q
operator|=
name|sbuf
operator|+
operator|(
name|off
index|[
literal|0
index|]
operator|%
name|gl
operator|->
name|sectorsize
operator|)
expr_stmt|;
name|i
operator|=
name|g_bde_encode_lock
argument_list|(
name|sc
operator|->
name|sha2
argument_list|,
name|gl
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"programming error encoding lock"
argument_list|)
expr_stmt|;
name|encrypt_sector
argument_list|(
name|q
argument_list|,
name|G_BDE_LOCKSIZE
argument_list|,
literal|256
argument_list|,
name|sc
operator|->
name|sha2
operator|+
literal|16
argument_list|)
expr_stmt|;
name|offset
operator|=
name|gl
operator|->
name|lsector
index|[
name|key
index|]
operator|&
operator|~
operator|(
name|gl
operator|->
name|sectorsize
operator|-
literal|1
operator|)
expr_stmt|;
name|offset2
operator|=
name|lseek
argument_list|(
name|dfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset2
operator|!=
name|offset
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"lseek"
argument_list|)
expr_stmt|;
name|i
operator|=
name|write
argument_list|(
name|dfd
argument_list|,
name|sbuf
argument_list|,
name|gl
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|int
operator|)
name|gl
operator|->
name|sectorsize
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sbuf
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("Wrote key %d at %jd\n", key, (intmax_t)offset); 	printf("s0 = %jd\n", (intmax_t)gl->sector0); 	printf("sN = %jd\n", (intmax_t)gl->sectorN); 	printf("l[0] = %jd\n", (intmax_t)gl->lsector[0]); 	printf("l[1] = %jd\n", (intmax_t)gl->lsector[1]); 	printf("l[2] = %jd\n", (intmax_t)gl->lsector[2]); 	printf("l[3] = %jd\n", (intmax_t)gl->lsector[3]); 	printf("k = %jd\n", (intmax_t)gl->keyoffset); 	printf("ss = %jd\n", (intmax_t)gl->sectorsize);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|cmd_destroy
parameter_list|(
name|struct
name|g_bde_key
modifier|*
name|gl
parameter_list|,
name|int
name|nkey
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|gl
operator|->
name|sector0
argument_list|,
sizeof|sizeof
name|gl
operator|->
name|sector0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|gl
operator|->
name|sectorN
argument_list|,
sizeof|sizeof
name|gl
operator|->
name|sectorN
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|gl
operator|->
name|keyoffset
argument_list|,
sizeof|sizeof
name|gl
operator|->
name|keyoffset
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|gl
operator|->
name|flags
argument_list|,
sizeof|sizeof
name|gl
operator|->
name|flags
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|gl
operator|->
name|mkey
argument_list|,
sizeof|sizeof
name|gl
operator|->
name|mkey
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|G_BDE_MAXKEYS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|nkey
condition|)
name|gl
operator|->
name|lsector
index|[
name|i
index|]
operator|=
operator|~
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sorthelp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|uint64_t
modifier|*
name|oa
decl_stmt|,
modifier|*
name|ob
decl_stmt|;
name|oa
operator|=
name|a
expr_stmt|;
name|ob
operator|=
name|b
expr_stmt|;
if|if
condition|(
operator|*
name|oa
operator|>
operator|*
name|ob
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|*
name|oa
operator|<
operator|*
name|ob
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cmd_init
parameter_list|(
name|struct
name|g_bde_key
modifier|*
name|gl
parameter_list|,
name|int
name|dfd
parameter_list|,
specifier|const
name|char
modifier|*
name|f_opt
parameter_list|,
name|int
name|i_opt
parameter_list|,
specifier|const
name|char
modifier|*
name|l_opt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|sector_size
decl_stmt|;
name|uint64_t
name|first_sector
decl_stmt|;
name|uint64_t
name|last_sector
decl_stmt|;
name|uint64_t
name|total_sectors
decl_stmt|;
name|off_t
name|off
decl_stmt|,
name|off2
decl_stmt|;
name|unsigned
name|nkeys
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
name|cbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|unsigned
name|u
decl_stmt|,
name|u2
decl_stmt|;
name|uint64_t
name|o
decl_stmt|;
name|properties
name|params
decl_stmt|;
name|bzero
argument_list|(
name|gl
argument_list|,
sizeof|sizeof
expr|*
name|gl
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_opt
operator|!=
name|NULL
condition|)
block|{
name|i
operator|=
name|open
argument_list|(
name|f_opt
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|f_opt
argument_list|)
expr_stmt|;
name|params
operator|=
name|properties_read
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i_opt
condition|)
block|{
comment|/* XXX: Polish */
name|asprintf
argument_list|(
operator|&
name|q
argument_list|,
literal|"%stemp.XXXXXXXXXX"
argument_list|,
name|_PATH_TMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
name|i
operator|=
name|mkstemp
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|i
argument_list|,
name|template
argument_list|,
name|strlen
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
literal|"vi"
expr_stmt|;
if|if
condition|(
name|snprintf
argument_list|(
name|cbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|cbuf
argument_list|)
argument_list|,
literal|"%s %s\n"
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
operator|>=
operator|(
name|ssize_t
operator|)
sizeof|sizeof
argument_list|(
name|cbuf
argument_list|)
condition|)
block|{
name|unlink
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"EDITOR is too long"
argument_list|)
expr_stmt|;
block|}
name|system
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
name|i
operator|=
name|open
argument_list|(
name|q
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|f_opt
argument_list|)
expr_stmt|;
name|params
operator|=
name|properties_read
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX: Hack */
name|i
operator|=
name|open
argument_list|(
name|_PATH_DEVNULL
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|_PATH_DEVNULL
argument_list|)
expr_stmt|;
name|params
operator|=
name|properties_read
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/*<sector_size> */
name|p
operator|=
name|property_find
argument_list|(
name|params
argument_list|,
literal|"sector_size"
argument_list|)
expr_stmt|;
name|i
operator|=
name|ioctl
argument_list|(
name|dfd
argument_list|,
name|DIOCGSECTORSIZE
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|sector_size
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|*
name|q
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"sector_size not a proper number"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|sector_size
operator|=
name|u
expr_stmt|;
block|}
else|else
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Missing sector_size property"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sector_size
operator|&
operator|(
name|sector_size
operator|-
literal|1
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"sector_size not a power of 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sector_size
operator|<
literal|512
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"sector_size is smaller than 512"
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|sector_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Failed to malloc sector buffer"
argument_list|)
expr_stmt|;
name|gl
operator|->
name|sectorsize
operator|=
name|sector_size
expr_stmt|;
name|i
operator|=
name|ioctl
argument_list|(
name|dfd
argument_list|,
name|DIOCGMEDIASIZE
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|first_sector
operator|=
literal|0
expr_stmt|;
name|total_sectors
operator|=
name|off
operator|/
name|sector_size
expr_stmt|;
name|last_sector
operator|=
name|total_sectors
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|first_sector
operator|=
literal|0
expr_stmt|;
name|last_sector
operator|=
literal|0
expr_stmt|;
name|total_sectors
operator|=
literal|0
expr_stmt|;
block|}
comment|/*<first_sector> */
name|p
operator|=
name|property_find
argument_list|(
name|params
argument_list|,
literal|"first_sector"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|first_sector
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|*
name|q
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"first_sector not a proper number"
argument_list|)
expr_stmt|;
block|}
comment|/*<last_sector> */
name|p
operator|=
name|property_find
argument_list|(
name|params
argument_list|,
literal|"last_sector"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|last_sector
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|*
name|q
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"last_sector not a proper number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_sector
operator|<=
name|first_sector
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"last_sector not larger than first_sector"
argument_list|)
expr_stmt|;
name|total_sectors
operator|=
name|last_sector
operator|+
literal|1
expr_stmt|;
block|}
comment|/*<total_sectors> */
name|p
operator|=
name|property_find
argument_list|(
name|params
argument_list|,
literal|"total_sectors"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|total_sectors
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|*
name|q
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"total_sectors not a proper number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_sector
operator|==
literal|0
condition|)
name|last_sector
operator|=
name|first_sector
operator|+
name|total_sectors
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l_opt
operator|==
name|NULL
operator|&&
name|first_sector
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"No -L new-lockfile argument and first_sector != 0"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|l_opt
operator|==
name|NULL
condition|)
block|{
name|first_sector
operator|++
expr_stmt|;
name|total_sectors
operator|--
expr_stmt|;
name|gl
operator|->
name|flags
operator||=
name|GBDE_F_SECT0
expr_stmt|;
block|}
name|gl
operator|->
name|sector0
operator|=
name|first_sector
operator|*
name|gl
operator|->
name|sectorsize
expr_stmt|;
if|if
condition|(
name|total_sectors
operator|!=
operator|(
name|last_sector
operator|-
name|first_sector
operator|)
operator|+
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"total_sectors disagree with first_sector and last_sector"
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_sectors
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"missing last_sector or total_sectors"
argument_list|)
expr_stmt|;
name|gl
operator|->
name|sectorN
operator|=
operator|(
name|last_sector
operator|+
literal|1
operator|)
operator|*
name|gl
operator|->
name|sectorsize
expr_stmt|;
comment|/* Find a random keyoffset */
name|random_bits
argument_list|(
operator|&
name|o
argument_list|,
sizeof|sizeof
name|o
argument_list|)
expr_stmt|;
name|o
operator|%=
operator|(
name|gl
operator|->
name|sectorN
operator|-
name|gl
operator|->
name|sector0
operator|)
expr_stmt|;
name|o
operator|&=
operator|~
operator|(
name|gl
operator|->
name|sectorsize
operator|-
literal|1
operator|)
expr_stmt|;
name|gl
operator|->
name|keyoffset
operator|=
name|o
expr_stmt|;
comment|/*<number_of_keys> */
name|p
operator|=
name|property_find
argument_list|(
name|params
argument_list|,
literal|"number_of_keys"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|nkeys
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|*
name|q
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"number_of_keys not a proper number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkeys
operator|<
literal|1
operator|||
name|nkeys
operator|>
name|G_BDE_MAXKEYS
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"number_of_keys out of range"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nkeys
operator|=
literal|4
expr_stmt|;
block|}
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|nkeys
condition|;
name|u
operator|++
control|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
do|do
block|{
name|random_bits
argument_list|(
operator|&
name|o
argument_list|,
sizeof|sizeof
name|o
argument_list|)
expr_stmt|;
name|o
operator|%=
name|gl
operator|->
name|sectorN
expr_stmt|;
name|o
operator|&=
operator|~
operator|(
name|gl
operator|->
name|sectorsize
operator|-
literal|1
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|o
operator|<
name|gl
operator|->
name|sector0
condition|)
do|;
for|for
control|(
name|u2
operator|=
literal|0
init|;
name|u2
operator|<
name|u
condition|;
name|u2
operator|++
control|)
if|if
condition|(
name|o
operator|==
name|gl
operator|->
name|lsector
index|[
name|u2
index|]
condition|)
break|break;
if|if
condition|(
name|u2
operator|<
name|u
condition|)
continue|continue;
break|break;
block|}
name|gl
operator|->
name|lsector
index|[
name|u
index|]
operator|=
name|o
expr_stmt|;
block|}
for|for
control|(
init|;
name|u
operator|<
name|G_BDE_MAXKEYS
condition|;
name|u
operator|++
control|)
block|{
do|do
name|random_bits
argument_list|(
operator|&
name|o
argument_list|,
sizeof|sizeof
name|o
argument_list|)
expr_stmt|;
do|while
condition|(
name|o
operator|<
name|gl
operator|->
name|sectorN
condition|)
do|;
name|gl
operator|->
name|lsector
index|[
name|u
index|]
operator|=
name|o
expr_stmt|;
block|}
name|qsort
argument_list|(
name|gl
operator|->
name|lsector
argument_list|,
name|G_BDE_MAXKEYS
argument_list|,
sizeof|sizeof
name|gl
operator|->
name|lsector
index|[
literal|0
index|]
argument_list|,
name|sorthelp
argument_list|)
expr_stmt|;
comment|/* Flush sector zero if we use it for lockfile data */
if|if
condition|(
name|gl
operator|->
name|flags
operator|&
name|GBDE_F_SECT0
condition|)
block|{
name|off2
operator|=
name|lseek
argument_list|(
name|dfd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|off2
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"lseek(2) to sector 0"
argument_list|)
expr_stmt|;
name|random_bits
argument_list|(
name|buf
argument_list|,
name|sector_size
argument_list|)
expr_stmt|;
name|i
operator|=
name|write
argument_list|(
name|dfd
argument_list|,
name|buf
argument_list|,
name|sector_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|int
operator|)
name|sector_size
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write sector 0"
argument_list|)
expr_stmt|;
block|}
comment|/*<random_flush> */
name|p
operator|=
name|property_find
argument_list|(
name|params
argument_list|,
literal|"random_flush"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|off
operator|=
name|first_sector
operator|*
name|sector_size
expr_stmt|;
name|off2
operator|=
name|lseek
argument_list|(
name|dfd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|off2
operator|!=
name|off
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"lseek(2) to first_sector"
argument_list|)
expr_stmt|;
name|off2
operator|=
name|last_sector
operator|*
name|sector_size
expr_stmt|;
while|while
condition|(
name|off
operator|<=
name|off2
condition|)
block|{
name|random_bits
argument_list|(
name|buf
argument_list|,
name|sector_size
argument_list|)
expr_stmt|;
name|i
operator|=
name|write
argument_list|(
name|dfd
argument_list|,
name|buf
argument_list|,
name|sector_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|int
operator|)
name|sector_size
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write to $device_name"
argument_list|)
expr_stmt|;
name|off
operator|+=
name|sector_size
expr_stmt|;
block|}
block|}
name|random_bits
argument_list|(
name|gl
operator|->
name|mkey
argument_list|,
sizeof|sizeof
name|gl
operator|->
name|mkey
argument_list|)
expr_stmt|;
name|random_bits
argument_list|(
name|gl
operator|->
name|salt
argument_list|,
sizeof|sizeof
name|gl
operator|->
name|salt
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_enum
specifier|static
enum|enum
name|action
block|{
name|ACT_HUH
block|,
name|ACT_ATTACH
block|,
name|ACT_DETACH
block|,
name|ACT_INIT
block|,
name|ACT_SETKEY
block|,
name|ACT_DESTROY
block|,
name|ACT_NUKE
block|}
name|action
enum|;
end_enum

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|opts
decl_stmt|;
specifier|const
name|char
modifier|*
name|k_opt
decl_stmt|,
modifier|*
name|K_opt
decl_stmt|;
specifier|const
name|char
modifier|*
name|l_opt
decl_stmt|,
modifier|*
name|L_opt
decl_stmt|;
specifier|const
name|char
modifier|*
name|p_opt
decl_stmt|,
modifier|*
name|P_opt
decl_stmt|;
specifier|const
name|char
modifier|*
name|f_opt
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
name|int
name|i_opt
decl_stmt|,
name|n_opt
decl_stmt|,
name|ch
decl_stmt|,
name|dfd
decl_stmt|,
name|doopen
decl_stmt|;
name|u_int
name|nkey
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|g_bde_key
modifier|*
name|gl
decl_stmt|;
name|struct
name|g_bde_softc
name|sc
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|modfind
argument_list|(
literal|"g_bde"
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* need to load the gbde module */
if|if
condition|(
name|kldload
argument_list|(
name|GBDEMOD
argument_list|)
operator|<
literal|0
operator|||
name|modfind
argument_list|(
literal|"g_bde"
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|GBDEMOD
literal|": Kernel module not available"
argument_list|)
expr_stmt|;
block|}
name|doopen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"attach"
argument_list|)
condition|)
block|{
name|action
operator|=
name|ACT_ATTACH
expr_stmt|;
name|opts
operator|=
literal|"k:l:p:"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"detach"
argument_list|)
condition|)
block|{
name|action
operator|=
name|ACT_DETACH
expr_stmt|;
name|opts
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"init"
argument_list|)
condition|)
block|{
name|action
operator|=
name|ACT_INIT
expr_stmt|;
name|doopen
operator|=
literal|1
expr_stmt|;
name|opts
operator|=
literal|"f:iK:L:P:"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"setkey"
argument_list|)
condition|)
block|{
name|action
operator|=
name|ACT_SETKEY
expr_stmt|;
name|doopen
operator|=
literal|1
expr_stmt|;
name|opts
operator|=
literal|"k:K:l:L:n:p:P:"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"destroy"
argument_list|)
condition|)
block|{
name|action
operator|=
name|ACT_DESTROY
expr_stmt|;
name|doopen
operator|=
literal|1
expr_stmt|;
name|opts
operator|=
literal|"k:l:p:"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"nuke"
argument_list|)
condition|)
block|{
name|action
operator|=
name|ACT_NUKE
expr_stmt|;
name|doopen
operator|=
literal|1
expr_stmt|;
name|opts
operator|=
literal|"k:l:n:p:"
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|dest
operator|=
name|strdup
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|p_opt
operator|=
name|NULL
expr_stmt|;
name|P_opt
operator|=
name|NULL
expr_stmt|;
name|k_opt
operator|=
name|NULL
expr_stmt|;
name|K_opt
operator|=
name|NULL
expr_stmt|;
name|l_opt
operator|=
name|NULL
expr_stmt|;
name|L_opt
operator|=
name|NULL
expr_stmt|;
name|f_opt
operator|=
name|NULL
expr_stmt|;
name|n_opt
operator|=
literal|0
expr_stmt|;
name|i_opt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|opts
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'f'
case|:
name|f_opt
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|i_opt
operator|=
operator|!
name|i_opt
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|k_opt
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|K_opt
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|l_opt
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|L_opt
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|n_opt
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|optarg
operator|||
operator|*
name|q
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-n argument not numeric"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_opt
operator|<
operator|-
literal|1
operator|||
name|n_opt
operator|>
name|G_BDE_MAXKEYS
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-n argument out of range"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|p_opt
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|P_opt
operator|=
name|optarg
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|doopen
condition|)
block|{
name|dfd
operator|=
name|open
argument_list|(
name|dest
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfd
operator|<
literal|0
operator|&&
name|dest
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
if|if
condition|(
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|dest
argument_list|)
operator|>=
operator|(
name|ssize_t
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|errno
operator|=
name|ENAMETOOLONG
expr_stmt|;
else|else
name|dfd
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dfd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|dest
argument_list|,
name|_PATH_DEV
argument_list|,
name|strlen
argument_list|(
name|_PATH_DEV
argument_list|)
argument_list|)
condition|)
name|strcpy
argument_list|(
name|dest
argument_list|,
name|dest
operator|+
name|strlen
argument_list|(
name|_PATH_DEV
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|sc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|.
name|consumer
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dfd
expr_stmt|;
name|gl
operator|=
operator|&
name|sc
operator|.
name|key
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|ACT_ATTACH
case|:
name|setup_passphrase
argument_list|(
operator|&
name|sc
argument_list|,
literal|0
argument_list|,
name|p_opt
argument_list|,
name|k_opt
argument_list|)
expr_stmt|;
name|cmd_attach
argument_list|(
operator|&
name|sc
argument_list|,
name|dest
argument_list|,
name|l_opt
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACT_DETACH
case|:
name|cmd_detach
argument_list|(
name|dest
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACT_INIT
case|:
name|cmd_init
argument_list|(
name|gl
argument_list|,
name|dfd
argument_list|,
name|f_opt
argument_list|,
name|i_opt
argument_list|,
name|L_opt
argument_list|)
expr_stmt|;
name|setup_passphrase
argument_list|(
operator|&
name|sc
argument_list|,
literal|1
argument_list|,
name|P_opt
argument_list|,
name|K_opt
argument_list|)
expr_stmt|;
name|cmd_write
argument_list|(
name|gl
argument_list|,
operator|&
name|sc
argument_list|,
name|dfd
argument_list|,
literal|0
argument_list|,
name|L_opt
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACT_SETKEY
case|:
name|setup_passphrase
argument_list|(
operator|&
name|sc
argument_list|,
literal|0
argument_list|,
name|p_opt
argument_list|,
name|k_opt
argument_list|)
expr_stmt|;
name|cmd_open
argument_list|(
operator|&
name|sc
argument_list|,
name|dfd
argument_list|,
name|l_opt
argument_list|,
operator|&
name|nkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_opt
operator|==
literal|0
condition|)
name|n_opt
operator|=
name|nkey
operator|+
literal|1
expr_stmt|;
name|setup_passphrase
argument_list|(
operator|&
name|sc
argument_list|,
literal|1
argument_list|,
name|P_opt
argument_list|,
name|K_opt
argument_list|)
expr_stmt|;
name|cmd_write
argument_list|(
name|gl
argument_list|,
operator|&
name|sc
argument_list|,
name|dfd
argument_list|,
name|n_opt
operator|-
literal|1
argument_list|,
name|L_opt
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACT_DESTROY
case|:
name|setup_passphrase
argument_list|(
operator|&
name|sc
argument_list|,
literal|0
argument_list|,
name|p_opt
argument_list|,
name|k_opt
argument_list|)
expr_stmt|;
name|cmd_open
argument_list|(
operator|&
name|sc
argument_list|,
name|dfd
argument_list|,
name|l_opt
argument_list|,
operator|&
name|nkey
argument_list|)
expr_stmt|;
name|cmd_destroy
argument_list|(
name|gl
argument_list|,
name|nkey
argument_list|)
expr_stmt|;
name|reset_passphrase
argument_list|(
operator|&
name|sc
argument_list|)
expr_stmt|;
name|cmd_write
argument_list|(
name|gl
argument_list|,
operator|&
name|sc
argument_list|,
name|dfd
argument_list|,
name|nkey
argument_list|,
name|l_opt
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACT_NUKE
case|:
name|setup_passphrase
argument_list|(
operator|&
name|sc
argument_list|,
literal|0
argument_list|,
name|p_opt
argument_list|,
name|k_opt
argument_list|)
expr_stmt|;
name|cmd_open
argument_list|(
operator|&
name|sc
argument_list|,
name|dfd
argument_list|,
name|l_opt
argument_list|,
operator|&
name|nkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_opt
operator|==
literal|0
condition|)
name|n_opt
operator|=
name|nkey
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|n_opt
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|G_BDE_MAXKEYS
condition|;
name|i
operator|++
control|)
name|cmd_nuke
argument_list|(
name|gl
argument_list|,
name|dfd
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmd_nuke
argument_list|(
name|gl
argument_list|,
name|dfd
argument_list|,
name|n_opt
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

