begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: rf_configure.c,v 1.13 2001/01/27 19:32:47 oster Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/***************************************************************  *  * rf_configure.c -- code related to configuring the raidframe system  *  * configuration is complicated by the fact that we want the same  * driver to work both in the kernel and at user level.  In the  * kernel, we can't read the configuration file, so we configure  * by running a user-level program that reads the config file,  * creates a data structure describing the configuration and  * passes it into the kernel via an ioctl.  Since we want the config  * code to be common between the two versions of the driver, we  * configure using the same two-step process when running at  * user level.  Of course, at user level, the config structure is  * passed directly to the config routine, rather than via ioctl.  *  * This file is not compiled into the kernel, so we have no  * need for KERNEL ifdefs.  *  **************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raidframe.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_decluster.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_configure.h>
end_include

begin_comment
comment|/*  * XXX we include this here so we don't need to drag rf_debugMem.c into  * the picture...  This is userland, afterall...  */
end_comment

begin_comment
comment|/*  * XXX sucky hack to override the defn. of RF_Malloc as given in  * rf_debugMem.c...  but I *really* don't want (nor need) to link with  * that file here in userland..  GO  */
end_comment

begin_undef
undef|#
directive|undef
name|RF_Malloc
end_undef

begin_define
define|#
directive|define
name|RF_Malloc
parameter_list|(
name|_p_
parameter_list|,
name|_size_
parameter_list|,
name|_cast_
parameter_list|)
define|\
value|{ \      _p_ = _cast_ malloc((u_long)_size_); \      bzero((char *)_p_, _size_); \   }
end_define

begin_decl_stmt
name|int
name|distSpareYes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|distSpareNo
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The mapsw[] table below contains all the various RAID types that might be supported by the kernel.  The actual supported types are found in sys/dev/raidframe/rf_layout.c. */
end_comment

begin_decl_stmt
specifier|static
name|RF_LayoutSW_t
name|mapsw
index|[]
init|=
block|{
comment|/* parity declustering */
block|{
literal|'T'
block|,
literal|"Parity declustering"
block|,
name|rf_MakeLayoutSpecificDeclustered
block|,
operator|&
name|distSpareNo
block|}
block|,
comment|/* parity declustering with distributed sparing */
block|{
literal|'D'
block|,
literal|"Distributed sparing parity declustering"
block|,
name|rf_MakeLayoutSpecificDeclustered
block|,
operator|&
name|distSpareYes
block|}
block|,
comment|/* declustered P+Q */
block|{
literal|'Q'
block|,
literal|"Declustered P+Q"
block|,
name|rf_MakeLayoutSpecificDeclustered
block|,
operator|&
name|distSpareNo
block|}
block|,
comment|/* RAID 5 with rotated sparing */
block|{
literal|'R'
block|,
literal|"RAID Level 5 rotated sparing"
block|,
name|rf_MakeLayoutSpecificNULL
block|,
name|NULL
block|}
block|,
comment|/* Chained Declustering */
block|{
literal|'C'
block|,
literal|"Chained Declustering"
block|,
name|rf_MakeLayoutSpecificNULL
block|,
name|NULL
block|}
block|,
comment|/* Interleaved Declustering */
block|{
literal|'I'
block|,
literal|"Interleaved Declustering"
block|,
name|rf_MakeLayoutSpecificNULL
block|,
name|NULL
block|}
block|,
comment|/* RAID level 0 */
block|{
literal|'0'
block|,
literal|"RAID Level 0"
block|,
name|rf_MakeLayoutSpecificNULL
block|,
name|NULL
block|}
block|,
comment|/* RAID level 1 */
block|{
literal|'1'
block|,
literal|"RAID Level 1"
block|,
name|rf_MakeLayoutSpecificNULL
block|,
name|NULL
block|}
block|,
comment|/* RAID level 4 */
block|{
literal|'4'
block|,
literal|"RAID Level 4"
block|,
name|rf_MakeLayoutSpecificNULL
block|,
name|NULL
block|}
block|,
comment|/* RAID level 5 */
block|{
literal|'5'
block|,
literal|"RAID Level 5"
block|,
name|rf_MakeLayoutSpecificNULL
block|,
name|NULL
block|}
block|,
comment|/* Evenodd */
block|{
literal|'E'
block|,
literal|"EvenOdd"
block|,
name|rf_MakeLayoutSpecificNULL
block|,
name|NULL
block|}
block|,
comment|/* Declustered Evenodd */
block|{
literal|'e'
block|,
literal|"Declustered EvenOdd"
block|,
name|rf_MakeLayoutSpecificDeclustered
block|,
operator|&
name|distSpareNo
block|}
block|,
comment|/* parity logging */
block|{
literal|'L'
block|,
literal|"Parity logging"
block|,
name|rf_MakeLayoutSpecificNULL
block|,
name|NULL
block|}
block|,
comment|/* end-of-list marker */
block|{
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|RF_LayoutSW_t
modifier|*
name|rf_GetLayout
parameter_list|(
name|RF_ParityConfig_t
name|parityConfig
parameter_list|)
block|{
name|RF_LayoutSW_t
modifier|*
name|p
decl_stmt|;
comment|/* look up the specific layout */
for|for
control|(
name|p
operator|=
operator|&
name|mapsw
index|[
literal|0
index|]
init|;
name|p
operator|->
name|parityConfig
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|parityConfig
operator|==
name|parityConfig
condition|)
break|break;
if|if
condition|(
operator|!
name|p
operator|->
name|parityConfig
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|RF_ASSERT
argument_list|(
name|p
operator|->
name|parityConfig
operator|==
name|parityConfig
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|rf_search_file_for_start_of
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rf_get_next_nonblank_line
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|errmsg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * called from user level to read the configuration file and create  * a configuration control structure.  This is used in the user-level  * version of the driver, and in the user-level program that configures  * the system via ioctl.  */
end_comment

begin_function
name|int
name|rf_MakeConfig
parameter_list|(
name|configname
parameter_list|,
name|cfgPtr
parameter_list|)
name|char
modifier|*
name|configname
decl_stmt|;
name|RF_Config_t
modifier|*
name|cfgPtr
decl_stmt|;
block|{
name|int
name|numscanned
decl_stmt|,
name|val
decl_stmt|,
name|r
decl_stmt|,
name|c
decl_stmt|,
name|retcode
decl_stmt|,
name|aa
decl_stmt|,
name|bb
decl_stmt|,
name|cc
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
name|buf1
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|RF_LayoutSW_t
modifier|*
name|lp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cfgPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_Config_t
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|configname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"Can't open config file %s\n"
argument_list|,
name|configname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_search_file_for_start_of
argument_list|(
literal|"array"
argument_list|,
name|buf
argument_list|,
literal|256
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"Unable to find start of \"array\" params in config file %s\n"
argument_list|,
name|configname
argument_list|)
expr_stmt|;
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rf_get_next_nonblank_line
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|,
name|fp
argument_list|,
literal|"Config file error (\"array\" section):  unable to get numRow and numCol\n"
argument_list|)
expr_stmt|;
comment|/*          * wackiness with aa, bb, cc to get around size problems on          * different platforms          */
name|numscanned
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%d %d %d"
argument_list|,
operator|&
name|aa
argument_list|,
operator|&
name|bb
argument_list|,
operator|&
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|numscanned
operator|!=
literal|3
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Config file error (\"array\" section):  unable to get numRow, numCol, numSpare\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cfgPtr
operator|->
name|numRow
operator|=
operator|(
name|RF_RowCol_t
operator|)
name|aa
expr_stmt|;
name|cfgPtr
operator|->
name|numCol
operator|=
operator|(
name|RF_RowCol_t
operator|)
name|bb
expr_stmt|;
name|cfgPtr
operator|->
name|numSpare
operator|=
operator|(
name|RF_RowCol_t
operator|)
name|cc
expr_stmt|;
comment|/* debug section is optional */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|RF_MAXDBGV
condition|;
name|c
operator|++
control|)
name|cfgPtr
operator|->
name|debugVars
index|[
name|c
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rf_search_file_for_start_of
argument_list|(
literal|"debug"
argument_list|,
name|buf
argument_list|,
literal|256
argument_list|,
name|fp
argument_list|)
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|RF_MAXDBGV
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|rf_get_next_nonblank_line
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
name|cp
operator|=
name|rf_find_non_white
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"START"
argument_list|,
name|strlen
argument_list|(
literal|"START"
argument_list|)
argument_list|)
condition|)
break|break;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|cfgPtr
operator|->
name|debugVars
index|[
name|c
index|]
index|[
literal|0
index|]
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cfgPtr
operator|->
name|diskQueueType
argument_list|,
literal|"fifo"
argument_list|)
expr_stmt|;
name|cfgPtr
operator|->
name|maxOutstandingDiskReqs
operator|=
literal|1
expr_stmt|;
comment|/* scan the file for the block related to disk queues */
if|if
condition|(
name|rf_search_file_for_start_of
argument_list|(
literal|"queue"
argument_list|,
name|buf
argument_list|,
literal|256
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|RF_ERRORMSG2
argument_list|(
literal|"[No disk queue discipline specified in config file %s.  Using %s.]\n"
argument_list|,
name|configname
argument_list|,
name|cfgPtr
operator|->
name|diskQueueType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rf_get_next_nonblank_line
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|RF_ERRORMSG2
argument_list|(
literal|"[No disk queue discipline specified in config file %s.  Using %s.]\n"
argument_list|,
name|configname
argument_list|,
name|cfgPtr
operator|->
name|diskQueueType
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* the queue specifier line contains two entries: 1st char of first 	 * word specifies queue to be used 2nd word specifies max num reqs 	 * that can be outstanding on the disk itself (typically 1) */
if|if
condition|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s %d"
argument_list|,
name|buf1
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"Can't determine queue type and/or max outstanding reqs from line: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|RF_ERRORMSG2
argument_list|(
literal|"Using %s-%d\n"
argument_list|,
name|cfgPtr
operator|->
name|diskQueueType
argument_list|,
name|cfgPtr
operator|->
name|maxOutstandingDiskReqs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|ch
decl_stmt|;
name|bcopy
argument_list|(
name|buf1
argument_list|,
name|cfgPtr
operator|->
name|diskQueueType
argument_list|,
name|RF_MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|cfgPtr
operator|->
name|diskQueueType
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|buf1
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
name|buf1
init|;
operator|*
name|ch
condition|;
name|ch
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ch
operator|==
literal|' '
condition|)
block|{
operator|*
name|ch
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
name|cfgPtr
operator|->
name|maxOutstandingDiskReqs
operator|=
name|val
expr_stmt|;
block|}
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_search_file_for_start_of
argument_list|(
literal|"disks"
argument_list|,
name|buf
argument_list|,
literal|256
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"Can't find \"disks\" section in config file %s\n"
argument_list|,
name|configname
argument_list|)
expr_stmt|;
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|cfgPtr
operator|->
name|numRow
condition|;
name|r
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|cfgPtr
operator|->
name|numCol
condition|;
name|c
operator|++
control|)
block|{
name|int
name|devfd
decl_stmt|;
name|char
name|bfr
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|bfr1
decl_stmt|;
if|if
condition|(
name|rf_get_next_nonblank_line
argument_list|(
operator|&
name|bfr
index|[
literal|0
index|]
argument_list|,
literal|256
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|RF_ERRORMSG2
argument_list|(
literal|"Config file error: unable to get device file for disk at row %d col %d\n"
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Get rid of the newline at the end of the string */
if|if
condition|(
operator|(
name|bfr1
operator|=
name|strchr
argument_list|(
operator|&
name|bfr
index|[
literal|0
index|]
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|bfr1
operator|=
name|NULL
expr_stmt|;
comment|/* Make sure the device exists */
if|if
condition|(
operator|(
name|devfd
operator|=
name|open
argument_list|(
operator|&
name|bfr
index|[
literal|0
index|]
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|RF_ERRORMSG2
argument_list|(
literal|"Config file error: device %s, %s\n"
argument_list|,
operator|&
name|bfr
index|[
literal|0
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|close
argument_list|(
name|devfd
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|cfgPtr
operator|->
name|devnames
index|[
name|r
index|]
index|[
name|c
index|]
index|[
literal|0
index|]
argument_list|,
operator|&
name|bfr
index|[
literal|0
index|]
argument_list|,
literal|50
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* "spare" section is optional */
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_search_file_for_start_of
argument_list|(
literal|"spare"
argument_list|,
name|buf
argument_list|,
literal|256
argument_list|,
name|fp
argument_list|)
condition|)
name|cfgPtr
operator|->
name|numSpare
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|cfgPtr
operator|->
name|numSpare
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|rf_get_next_nonblank_line
argument_list|(
operator|&
name|cfgPtr
operator|->
name|spare_names
index|[
name|c
index|]
index|[
literal|0
index|]
argument_list|,
literal|256
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"Config file error: unable to get device file for spare disk %d\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* scan the file for the block related to layout */
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_search_file_for_start_of
argument_list|(
literal|"layout"
argument_list|,
name|buf
argument_list|,
literal|256
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"Can't find \"layout\" section in configuration file %s\n"
argument_list|,
name|configname
argument_list|)
expr_stmt|;
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|rf_get_next_nonblank_line
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Config file error (\"layout\" section): unable to find common layout param line\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|c
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%d %d %d %c"
argument_list|,
operator|&
name|aa
argument_list|,
operator|&
name|bb
argument_list|,
operator|&
name|cc
argument_list|,
operator|&
name|cfgPtr
operator|->
name|parityConfig
argument_list|)
expr_stmt|;
name|cfgPtr
operator|->
name|sectPerSU
operator|=
operator|(
name|RF_SectorNum_t
operator|)
name|aa
expr_stmt|;
name|cfgPtr
operator|->
name|SUsPerPU
operator|=
operator|(
name|RF_StripeNum_t
operator|)
name|bb
expr_stmt|;
name|cfgPtr
operator|->
name|SUsPerRU
operator|=
operator|(
name|RF_StripeNum_t
operator|)
name|cc
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|4
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Unable to scan common layout line\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|lp
operator|=
name|rf_GetLayout
argument_list|(
name|cfgPtr
operator|->
name|parityConfig
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"Unknown parity config '%c'\n"
argument_list|,
name|cfgPtr
operator|->
name|parityConfig
argument_list|)
expr_stmt|;
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|retcode
operator|=
name|lp
operator|->
name|MakeLayoutSpecific
argument_list|(
name|fp
argument_list|,
name|cfgPtr
argument_list|,
name|lp
operator|->
name|makeLayoutSpecificArg
argument_list|)
expr_stmt|;
name|out
label|:
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|<
literal|0
condition|)
name|retcode
operator|=
name|errno
operator|=
name|EINVAL
expr_stmt|;
else|else
name|errno
operator|=
name|retcode
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* used in architectures such as RAID0 where there is no layout-specific  * information to be passed into the configuration code.  */
end_comment

begin_function
name|int
name|rf_MakeLayoutSpecificNULL
parameter_list|(
name|fp
parameter_list|,
name|cfgPtr
parameter_list|,
name|ignored
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|RF_Config_t
modifier|*
name|cfgPtr
decl_stmt|;
name|void
modifier|*
name|ignored
decl_stmt|;
block|{
name|cfgPtr
operator|->
name|layoutSpecificSize
operator|=
literal|0
expr_stmt|;
name|cfgPtr
operator|->
name|layoutSpecific
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_MakeLayoutSpecificDeclustered
parameter_list|(
name|configfp
parameter_list|,
name|cfgPtr
parameter_list|,
name|arg
parameter_list|)
name|FILE
modifier|*
name|configfp
decl_stmt|;
name|RF_Config_t
modifier|*
name|cfgPtr
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|b
decl_stmt|,
name|v
decl_stmt|,
name|k
decl_stmt|,
name|r
decl_stmt|,
name|lambda
decl_stmt|,
name|norotate
decl_stmt|,
name|i
decl_stmt|,
name|val
decl_stmt|,
name|distSpare
decl_stmt|;
name|char
modifier|*
name|cfgBuf
decl_stmt|,
modifier|*
name|bdfile
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|smname
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
name|smbuf
index|[
literal|256
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|distSpare
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
expr_stmt|;
comment|/* get the block design file name */
if|if
condition|(
name|rf_get_next_nonblank_line
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|,
name|configfp
argument_list|,
literal|"Can't find block design file name in config file\n"
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bdfile
operator|=
name|rf_find_non_white
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdfile
index|[
name|strlen
argument_list|(
name|bdfile
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* strip newline char */
name|bdfile
index|[
name|strlen
argument_list|(
name|bdfile
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* open bd file, check validity of configuration */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|bdfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"RAID: config error: Can't open layout table file %s\n"
argument_list|,
name|bdfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"RAID: config error: Can't read layout from layout table file %s\n"
argument_list|,
name|bdfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|i
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%u %u %u %u %u %u"
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|v
argument_list|,
operator|&
name|k
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|lambda
argument_list|,
operator|&
name|norotate
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|5
condition|)
name|norotate
operator|=
literal|0
expr_stmt|;
comment|/* no-rotate flag is optional */
elseif|else
if|if
condition|(
name|i
operator|!=
literal|6
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Unable to parse header line in block design file\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* set the sparemap directory.  In the in-kernel version, there's a 	 * daemon that's responsible for finding the sparemaps */
if|if
condition|(
name|distSpare
condition|)
block|{
if|if
condition|(
name|rf_get_next_nonblank_line
argument_list|(
name|smbuf
argument_list|,
literal|256
argument_list|,
name|configfp
argument_list|,
literal|"Can't find sparemap file name in config file\n"
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|smname
operator|=
name|rf_find_non_white
argument_list|(
name|smbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|smname
index|[
name|strlen
argument_list|(
name|smname
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* strip newline char */
name|smname
index|[
name|strlen
argument_list|(
name|smname
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
else|else
block|{
name|smbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|smname
operator|=
name|smbuf
expr_stmt|;
block|}
comment|/* allocate a buffer to hold the configuration info */
name|cfgPtr
operator|->
name|layoutSpecificSize
operator|=
name|RF_SPAREMAP_NAME_LEN
operator|+
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
name|b
operator|*
name|k
expr_stmt|;
comment|/* can't use RF_Malloc here b/c debugMem module not yet init'd */
name|cfgBuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|cfgPtr
operator|->
name|layoutSpecificSize
argument_list|)
expr_stmt|;
name|cfgPtr
operator|->
name|layoutSpecific
operator|=
operator|(
name|void
operator|*
operator|)
name|cfgBuf
expr_stmt|;
name|p
operator|=
name|cfgBuf
expr_stmt|;
comment|/* install name of sparemap file */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|smname
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|smname
index|[
name|i
index|]
expr_stmt|;
comment|/* pad with zeros */
while|while
condition|(
name|i
operator|<
name|RF_SPAREMAP_NAME_LEN
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/*          * fill in the buffer with the block design parameters          * and then the block design itself          */
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|p
operator|)
operator|=
name|b
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|p
operator|)
operator|=
name|v
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|p
operator|)
operator|=
name|k
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|p
operator|)
operator|=
name|r
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|p
operator|)
operator|=
name|lambda
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|p
operator|)
operator|=
name|norotate
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
while|while
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|1
condition|)
operator|*
name|p
operator|++
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|-
name|cfgBuf
operator|!=
name|cfgPtr
operator|->
name|layoutSpecificSize
condition|)
block|{
name|RF_ERRORMSG2
argument_list|(
literal|"Size mismatch creating layout specific data: is %d sb %d bytes\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|cfgBuf
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
name|b
operator|*
name|k
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * utilities  *  ***************************************************************************/
end_comment

begin_comment
comment|/* finds a non-white character in the line */
end_comment

begin_function
name|char
modifier|*
name|rf_find_non_white
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* finds a white character in the line */
end_comment

begin_function
name|char
modifier|*
name|rf_find_white
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * searches a file for a line that says "START string", where string is  * specified as a parameter  */
end_comment

begin_function
specifier|static
name|int
name|rf_search_file_for_start_of
parameter_list|(
name|string
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|fp
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|=
name|rf_find_non_white
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"START"
argument_list|,
name|strlen
argument_list|(
literal|"START"
argument_list|)
argument_list|)
condition|)
block|{
name|p
operator|=
name|rf_find_white
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|rf_find_non_white
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* reads from file fp into buf until it finds an interesting line */
end_comment

begin_function
name|int
name|rf_get_next_nonblank_line
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|,
name|fp
parameter_list|,
name|errmsg
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|rf_find_non_white
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
literal|'#'
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|errmsg
condition|)
name|RF_ERRORMSG1
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocates an array for the spare table, and initializes it from a file.  * In the user-level version, this is called when recon is initiated.  * When/if I move recon into the kernel, there'll be a daemon that does  * an ioctl into raidframe which will block until a spare table is needed.  * When it returns, it will read a spare table from the file system,  * pass it into the kernel via a different ioctl, and then block again  * on the original ioctl.  *  * This is specific to the declustered layout, but doesn't belong in  * rf_decluster.c because it uses stuff that can't be compiled into  * the kernel, and it needs to be compiled into the user-level sparemap daemon.  *  */
end_comment

begin_function
name|void
modifier|*
name|rf_ReadSpareTable
parameter_list|(
name|req
parameter_list|,
name|fname
parameter_list|)
name|RF_SparetWait_t
modifier|*
name|req
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|numFound
decl_stmt|,
name|linecount
decl_stmt|,
name|tableNum
decl_stmt|,
name|tupleNum
decl_stmt|,
name|spareDisk
decl_stmt|,
name|spareBlkOffset
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
name|targString
index|[
literal|100
index|]
decl_stmt|,
name|errString
index|[
literal|100
index|]
decl_stmt|;
name|RF_SpareTableEntry_t
modifier|*
modifier|*
name|table
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* allocate and initialize the table */
name|RF_Malloc
argument_list|(
name|table
argument_list|,
name|req
operator|->
name|TablesPerSpareRegion
operator|*
sizeof|sizeof
argument_list|(
name|RF_SpareTableEntry_t
operator|*
argument_list|)
argument_list|,
operator|(
name|RF_SpareTableEntry_t
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|req
operator|->
name|TablesPerSpareRegion
condition|;
name|i
operator|++
control|)
block|{
name|RF_Malloc
argument_list|(
name|table
index|[
name|i
index|]
argument_list|,
name|req
operator|->
name|BlocksPerTable
operator|*
sizeof|sizeof
argument_list|(
name|RF_SpareTableEntry_t
argument_list|)
argument_list|,
operator|(
name|RF_SpareTableEntry_t
operator|*
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|req
operator|->
name|BlocksPerTable
condition|;
name|j
operator|++
control|)
name|table
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|spareDisk
operator|=
name|table
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|spareBlockOffsetInSUs
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 2.  open sparemap file, sanity check */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rf_ReadSpareTable:  Can't open sparemap file %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|rf_get_next_nonblank_line
argument_list|(
name|buf
argument_list|,
literal|1024
argument_list|,
name|fp
argument_list|,
literal|"Invalid sparemap file:  can't find header line\n"
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|targString
argument_list|,
literal|"fdisk %d\n"
argument_list|,
name|req
operator|->
name|fcol
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errString
argument_list|,
literal|"Invalid sparemap file:  can't find \"fdisk %d\" line\n"
argument_list|,
name|req
operator|->
name|fcol
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|rf_get_next_nonblank_line
argument_list|(
name|buf
argument_list|,
literal|1024
argument_list|,
name|fp
argument_list|,
name|errString
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
name|targString
argument_list|,
name|strlen
argument_list|(
name|targString
argument_list|)
argument_list|)
condition|)
break|break;
block|}
comment|/* no more blank lines or comments allowed now */
name|linecount
operator|=
name|req
operator|->
name|TablesPerSpareRegion
operator|*
name|req
operator|->
name|TableDepthInPUs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|linecount
condition|;
name|i
operator|++
control|)
block|{
name|numFound
operator|=
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|" %d %d %d %d"
argument_list|,
operator|&
name|tableNum
argument_list|,
operator|&
name|tupleNum
argument_list|,
operator|&
name|spareDisk
argument_list|,
operator|&
name|spareBlkOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|numFound
operator|!=
literal|4
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sparemap file prematurely exhausted after %d of %d lines\n"
argument_list|,
name|i
argument_list|,
name|linecount
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|RF_ASSERT
argument_list|(
name|tableNum
operator|>=
literal|0
operator|&&
name|tableNum
operator|<
name|req
operator|->
name|TablesPerSpareRegion
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|tupleNum
operator|>=
literal|0
operator|&&
name|tupleNum
operator|<
name|req
operator|->
name|BlocksPerTable
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|spareDisk
operator|>=
literal|0
operator|&&
name|spareDisk
operator|<
name|req
operator|->
name|C
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|spareBlkOffset
operator|>=
literal|0
operator|&&
name|spareBlkOffset
operator|<
name|req
operator|->
name|SpareSpaceDepthPerRegionInSUs
operator|/
name|req
operator|->
name|SUsPerPU
argument_list|)
expr_stmt|;
name|table
index|[
name|tableNum
index|]
index|[
name|tupleNum
index|]
operator|.
name|spareDisk
operator|=
name|spareDisk
expr_stmt|;
name|table
index|[
name|tableNum
index|]
index|[
name|tupleNum
index|]
operator|.
name|spareBlockOffsetInSUs
operator|=
name|spareBlkOffset
operator|*
name|req
operator|->
name|SUsPerPU
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|table
operator|)
return|;
block|}
end_function

end_unit

