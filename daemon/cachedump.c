begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * daemon/cachedump.c - dump the cache to text format.  *  * Copyright (c) 2008, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains functions to read and write the cache(s)  * to text format.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_include
include|#
directive|include
file|"daemon/cachedump.h"
end_include

begin_include
include|#
directive|include
file|"daemon/remote.h"
end_include

begin_include
include|#
directive|include
file|"daemon/worker.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/dns.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/infra.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iterator.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_delegpt.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_utils.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_fwd.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_hints.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_include
include|#
directive|include
file|"ldns/wire2str.h"
end_include

begin_include
include|#
directive|include
file|"ldns/str2wire.h"
end_include

begin_comment
comment|/** dump one rrset zonefile line */
end_comment

begin_function
specifier|static
name|int
name|dump_rrset_line
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|time_t
name|now
parameter_list|,
name|size_t
name|i
parameter_list|)
block|{
name|char
name|s
index|[
literal|65535
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|packed_rr_to_string
argument_list|(
name|k
argument_list|,
name|i
argument_list|,
name|now
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"BADRR\n"
argument_list|)
return|;
block|}
return|return
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** dump rrset key and data info */
end_comment

begin_function
specifier|static
name|int
name|dump_rrset
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|struct
name|packed_rrset_data
modifier|*
name|d
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* rd lock held by caller */
if|if
condition|(
operator|!
name|k
operator|||
operator|!
name|d
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|d
operator|->
name|ttl
operator|<
name|now
condition|)
return|return
literal|1
return|;
comment|/* expired */
comment|/* meta line */
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|";rrset%s "
name|ARG_LL
literal|"d %u %u %d %d\n"
argument_list|,
operator|(
name|k
operator|->
name|rk
operator|.
name|flags
operator|&
name|PACKED_RRSET_NSEC_AT_APEX
operator|)
condition|?
literal|" nsec_apex"
else|:
literal|""
argument_list|,
call|(
name|long
name|long
call|)
argument_list|(
name|d
operator|->
name|ttl
operator|-
name|now
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|d
operator|->
name|count
argument_list|,
operator|(
name|unsigned
operator|)
name|d
operator|->
name|rrsig_count
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|trust
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|security
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|count
operator|+
name|d
operator|->
name|rrsig_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dump_rrset_line
argument_list|(
name|ssl
argument_list|,
name|k
argument_list|,
name|now
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** dump lruhash rrset cache */
end_comment

begin_function
specifier|static
name|int
name|dump_rrset_lruhash
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|lruhash
modifier|*
name|h
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|e
decl_stmt|;
comment|/* lruhash already locked by caller */
comment|/* walk in order of lru; best first */
for|for
control|(
name|e
operator|=
name|h
operator|->
name|lru_start
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|lru_next
control|)
block|{
name|lock_rw_rdlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dump_rrset
argument_list|(
name|ssl
argument_list|,
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|)
name|e
operator|->
name|key
argument_list|,
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|e
operator|->
name|data
argument_list|,
name|now
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** dump rrset cache */
end_comment

begin_function
specifier|static
name|int
name|dump_rrset_cache
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|struct
name|rrset_cache
modifier|*
name|r
init|=
name|worker
operator|->
name|env
operator|.
name|rrset_cache
decl_stmt|;
name|size_t
name|slab
decl_stmt|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"START_RRSET_CACHE\n"
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|slab
operator|=
literal|0
init|;
name|slab
operator|<
name|r
operator|->
name|table
operator|.
name|size
condition|;
name|slab
operator|++
control|)
block|{
name|lock_quick_lock
argument_list|(
operator|&
name|r
operator|->
name|table
operator|.
name|array
index|[
name|slab
index|]
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dump_rrset_lruhash
argument_list|(
name|ssl
argument_list|,
name|r
operator|->
name|table
operator|.
name|array
index|[
name|slab
index|]
argument_list|,
operator|*
name|worker
operator|->
name|env
operator|.
name|now
argument_list|)
condition|)
block|{
name|lock_quick_unlock
argument_list|(
operator|&
name|r
operator|->
name|table
operator|.
name|array
index|[
name|slab
index|]
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lock_quick_unlock
argument_list|(
operator|&
name|r
operator|->
name|table
operator|.
name|array
index|[
name|slab
index|]
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"END_RRSET_CACHE\n"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** dump message to rrset reference */
end_comment

begin_function
specifier|static
name|int
name|dump_msg_ref
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|)
block|{
name|char
modifier|*
name|nm
decl_stmt|,
modifier|*
name|tp
decl_stmt|,
modifier|*
name|cl
decl_stmt|;
name|nm
operator|=
name|sldns_wire2str_dname
argument_list|(
name|k
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|k
operator|->
name|rk
operator|.
name|dname_len
argument_list|)
expr_stmt|;
name|tp
operator|=
name|sldns_wire2str_type
argument_list|(
name|ntohs
argument_list|(
name|k
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|cl
operator|=
name|sldns_wire2str_class
argument_list|(
name|ntohs
argument_list|(
name|k
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nm
operator|||
operator|!
name|cl
operator|||
operator|!
name|tp
condition|)
block|{
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"BADREF\n"
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s %s %s %d\n"
argument_list|,
name|nm
argument_list|,
name|cl
argument_list|,
name|tp
argument_list|,
operator|(
name|int
operator|)
name|k
operator|->
name|rk
operator|.
name|flags
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** dump message entry */
end_comment

begin_function
specifier|static
name|int
name|dump_msg
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|query_info
modifier|*
name|k
parameter_list|,
name|struct
name|reply_info
modifier|*
name|d
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|,
modifier|*
name|tp
decl_stmt|,
modifier|*
name|cl
decl_stmt|;
if|if
condition|(
operator|!
name|k
operator|||
operator|!
name|d
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|d
operator|->
name|ttl
operator|<
name|now
condition|)
return|return
literal|1
return|;
comment|/* expired */
name|nm
operator|=
name|sldns_wire2str_dname
argument_list|(
name|k
operator|->
name|qname
argument_list|,
name|k
operator|->
name|qname_len
argument_list|)
expr_stmt|;
name|tp
operator|=
name|sldns_wire2str_type
argument_list|(
name|k
operator|->
name|qtype
argument_list|)
expr_stmt|;
name|cl
operator|=
name|sldns_wire2str_class
argument_list|(
name|k
operator|->
name|qclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nm
operator|||
operator|!
name|tp
operator|||
operator|!
name|cl
condition|)
block|{
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* skip this entry */
block|}
if|if
condition|(
operator|!
name|rrset_array_lock
argument_list|(
name|d
operator|->
name|ref
argument_list|,
name|d
operator|->
name|rrset_count
argument_list|,
name|now
argument_list|)
condition|)
block|{
comment|/* rrsets have timed out or do not exist */
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* skip this entry */
block|}
comment|/* meta line */
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"msg %s %s %s %d %d "
name|ARG_LL
literal|"d %d %u %u %u\n"
argument_list|,
name|nm
argument_list|,
name|cl
argument_list|,
name|tp
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|flags
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|qdcount
argument_list|,
call|(
name|long
name|long
call|)
argument_list|(
name|d
operator|->
name|ttl
operator|-
name|now
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|security
argument_list|,
operator|(
name|unsigned
operator|)
name|d
operator|->
name|an_numrrsets
argument_list|,
operator|(
name|unsigned
operator|)
name|d
operator|->
name|ns_numrrsets
argument_list|,
operator|(
name|unsigned
operator|)
name|d
operator|->
name|ar_numrrsets
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
name|rrset_array_unlock
argument_list|(
name|d
operator|->
name|ref
argument_list|,
name|d
operator|->
name|rrset_count
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dump_msg_ref
argument_list|(
name|ssl
argument_list|,
name|d
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|rrset_array_unlock
argument_list|(
name|d
operator|->
name|ref
argument_list|,
name|d
operator|->
name|rrset_count
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|rrset_array_unlock
argument_list|(
name|d
operator|->
name|ref
argument_list|,
name|d
operator|->
name|rrset_count
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** copy msg to worker pad */
end_comment

begin_function
specifier|static
name|int
name|copy_msg
parameter_list|(
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|lruhash_entry
modifier|*
name|e
parameter_list|,
name|struct
name|query_info
modifier|*
modifier|*
name|k
parameter_list|,
name|struct
name|reply_info
modifier|*
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|reply_info
modifier|*
name|rep
init|=
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|e
operator|->
name|data
decl_stmt|;
operator|*
name|d
operator|=
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|regional_alloc_init
argument_list|(
name|region
argument_list|,
name|e
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reply_info
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rrset_ref
argument_list|)
operator|*
operator|(
name|rep
operator|->
name|rrset_count
operator|-
literal|1
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
operator|*
argument_list|)
operator|*
name|rep
operator|->
name|rrset_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|d
condition|)
return|return
literal|0
return|;
operator|(
operator|*
name|d
operator|)
operator|->
name|rrsets
operator|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
operator|&
operator|(
operator|(
operator|*
name|d
operator|)
operator|->
name|ref
index|[
literal|0
index|]
operator|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rrset_ref
argument_list|)
operator|*
name|rep
operator|->
name|rrset_count
operator|)
expr_stmt|;
operator|*
name|k
operator|=
operator|(
expr|struct
name|query_info
operator|*
operator|)
name|regional_alloc_init
argument_list|(
name|region
argument_list|,
name|e
operator|->
name|key
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|query_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|k
condition|)
return|return
literal|0
return|;
operator|(
operator|*
name|k
operator|)
operator|->
name|qname
operator|=
name|regional_alloc_init
argument_list|(
name|region
argument_list|,
operator|(
operator|*
name|k
operator|)
operator|->
name|qname
argument_list|,
operator|(
operator|*
name|k
operator|)
operator|->
name|qname_len
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|k
operator|)
operator|->
name|qname
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/** dump lruhash msg cache */
end_comment

begin_function
specifier|static
name|int
name|dump_msg_lruhash
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|struct
name|lruhash
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|query_info
modifier|*
name|k
decl_stmt|;
name|struct
name|reply_info
modifier|*
name|d
decl_stmt|;
comment|/* lruhash already locked by caller */
comment|/* walk in order of lru; best first */
for|for
control|(
name|e
operator|=
name|h
operator|->
name|lru_start
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|lru_next
control|)
block|{
name|regional_free_all
argument_list|(
name|worker
operator|->
name|scratchpad
argument_list|)
expr_stmt|;
name|lock_rw_rdlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* make copy of rrset in worker buffer */
if|if
condition|(
operator|!
name|copy_msg
argument_list|(
name|worker
operator|->
name|scratchpad
argument_list|,
name|e
argument_list|,
operator|&
name|k
argument_list|,
operator|&
name|d
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* release lock so we can lookup the rrset references  		 * in the rrset cache */
if|if
condition|(
operator|!
name|dump_msg
argument_list|(
name|ssl
argument_list|,
name|k
argument_list|,
name|d
argument_list|,
operator|*
name|worker
operator|->
name|env
operator|.
name|now
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** dump msg cache */
end_comment

begin_function
specifier|static
name|int
name|dump_msg_cache
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|struct
name|slabhash
modifier|*
name|sh
init|=
name|worker
operator|->
name|env
operator|.
name|msg_cache
decl_stmt|;
name|size_t
name|slab
decl_stmt|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"START_MSG_CACHE\n"
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|slab
operator|=
literal|0
init|;
name|slab
operator|<
name|sh
operator|->
name|size
condition|;
name|slab
operator|++
control|)
block|{
name|lock_quick_lock
argument_list|(
operator|&
name|sh
operator|->
name|array
index|[
name|slab
index|]
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dump_msg_lruhash
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|sh
operator|->
name|array
index|[
name|slab
index|]
argument_list|)
condition|)
block|{
name|lock_quick_unlock
argument_list|(
operator|&
name|sh
operator|->
name|array
index|[
name|slab
index|]
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lock_quick_unlock
argument_list|(
operator|&
name|sh
operator|->
name|array
index|[
name|slab
index|]
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"END_MSG_CACHE\n"
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|dump_cache
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dump_rrset_cache
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|dump_msg_cache
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"EOF\n"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** read a line from ssl into buffer */
end_comment

begin_function
specifier|static
name|int
name|ssl_read_buf
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|ssl_read_line
argument_list|(
name|ssl
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|sldns_buffer_capacity
argument_list|(
name|buf
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** check fixed text on line */
end_comment

begin_function
specifier|static
name|int
name|read_fixed
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ssl_read_buf
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|str
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/** load an RR into rrset */
end_comment

begin_function
specifier|static
name|int
name|load_rr
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rk
parameter_list|,
name|struct
name|packed_rrset_data
modifier|*
name|d
parameter_list|,
name|unsigned
name|int
name|i
parameter_list|,
name|int
name|is_rrsig
parameter_list|,
name|int
modifier|*
name|go_on
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
name|uint8_t
name|rr
index|[
name|LDNS_RR_BUF_SIZE
index|]
decl_stmt|;
name|size_t
name|rr_len
init|=
sizeof|sizeof
argument_list|(
name|rr
argument_list|)
decl_stmt|,
name|dname_len
init|=
literal|0
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* read the line */
if|if
condition|(
operator|!
name|ssl_read_buf
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"BADRR\n"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|go_on
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|status
operator|=
name|sldns_str2wire_rr_buf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
name|rr
argument_list|,
operator|&
name|rr_len
argument_list|,
operator|&
name|dname_len
argument_list|,
literal|3600
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|log_warn
argument_list|(
literal|"error cannot parse rr: %s: %s"
argument_list|,
name|sldns_get_errorstr_parse
argument_list|(
name|status
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|is_rrsig
operator|&&
name|sldns_wirerr_get_type
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
operator|!=
name|LDNS_RR_TYPE_RRSIG
condition|)
block|{
name|log_warn
argument_list|(
literal|"error expected rrsig but got %s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* convert ldns rr into packed_rr */
name|d
operator|->
name|rr_ttl
index|[
name|i
index|]
operator|=
operator|(
name|time_t
operator|)
name|sldns_wirerr_get_ttl
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
operator|+
name|now
expr_stmt|;
name|sldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|d
operator|->
name|rr_len
index|[
name|i
index|]
operator|=
name|sldns_wirerr_get_rdatalen
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
operator|+
literal|2
expr_stmt|;
name|d
operator|->
name|rr_data
index|[
name|i
index|]
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|regional_alloc_init
argument_list|(
name|region
argument_list|,
name|sldns_wirerr_get_rdatawl
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
argument_list|,
name|d
operator|->
name|rr_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|rr_data
index|[
name|i
index|]
condition|)
block|{
name|log_warn
argument_list|(
literal|"error out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* if first entry, fill the key structure */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|rk
operator|->
name|rk
operator|.
name|type
operator|=
name|htons
argument_list|(
name|sldns_wirerr_get_type
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
argument_list|)
expr_stmt|;
name|rk
operator|->
name|rk
operator|.
name|rrset_class
operator|=
name|htons
argument_list|(
name|sldns_wirerr_get_class
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
argument_list|)
expr_stmt|;
name|rk
operator|->
name|rk
operator|.
name|dname_len
operator|=
name|dname_len
expr_stmt|;
name|rk
operator|->
name|rk
operator|.
name|dname
operator|=
name|regional_alloc_init
argument_list|(
name|region
argument_list|,
name|rr
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rk
operator|->
name|rk
operator|.
name|dname
condition|)
block|{
name|log_warn
argument_list|(
literal|"error out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** move entry into cache */
end_comment

begin_function
specifier|static
name|int
name|move_into_cache
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|struct
name|packed_rrset_data
modifier|*
name|d
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|ak
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|ad
decl_stmt|;
name|size_t
name|s
decl_stmt|,
name|i
decl_stmt|,
name|num
init|=
name|d
operator|->
name|count
operator|+
name|d
operator|->
name|rrsig_count
decl_stmt|;
name|struct
name|rrset_ref
name|ref
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|ak
operator|=
name|alloc_special_obtain
argument_list|(
operator|&
name|worker
operator|->
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ak
condition|)
block|{
name|log_warn
argument_list|(
literal|"error out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ak
operator|->
name|entry
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|ak
operator|->
name|rk
operator|=
name|k
operator|->
name|rk
expr_stmt|;
name|ak
operator|->
name|entry
operator|.
name|hash
operator|=
name|rrset_key_hash
argument_list|(
operator|&
name|k
operator|->
name|rk
argument_list|)
expr_stmt|;
name|ak
operator|->
name|rk
operator|.
name|dname
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|memdup
argument_list|(
name|k
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|k
operator|->
name|rk
operator|.
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ak
operator|->
name|rk
operator|.
name|dname
condition|)
block|{
name|log_warn
argument_list|(
literal|"error out of memory"
argument_list|)
expr_stmt|;
name|ub_packed_rrset_parsedelete
argument_list|(
name|ak
argument_list|,
operator|&
name|worker
operator|->
name|alloc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ad
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
operator|)
operator|*
name|num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|s
operator|+=
name|d
operator|->
name|rr_len
index|[
name|i
index|]
expr_stmt|;
name|ad
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|malloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ad
condition|)
block|{
name|log_warn
argument_list|(
literal|"error out of memory"
argument_list|)
expr_stmt|;
name|ub_packed_rrset_parsedelete
argument_list|(
name|ak
argument_list|,
operator|&
name|worker
operator|->
name|alloc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|ad
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
name|d
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ad
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ad
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
operator|&
name|d
operator|->
name|rr_len
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
name|num
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
name|num
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
operator|&
name|d
operator|->
name|rr_data
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
operator|*
name|num
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
operator|*
name|num
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
operator|&
name|d
operator|->
name|rr_ttl
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
operator|*
name|num
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
operator|*
name|num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|memmove
argument_list|(
name|p
argument_list|,
name|d
operator|->
name|rr_data
index|[
name|i
index|]
argument_list|,
name|d
operator|->
name|rr_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
name|d
operator|->
name|rr_len
index|[
name|i
index|]
expr_stmt|;
block|}
name|packed_rrset_ptr_fixup
argument_list|(
name|ad
argument_list|)
expr_stmt|;
name|ak
operator|->
name|entry
operator|.
name|data
operator|=
name|ad
expr_stmt|;
name|ref
operator|.
name|key
operator|=
name|ak
expr_stmt|;
name|ref
operator|.
name|id
operator|=
name|ak
operator|->
name|id
expr_stmt|;
operator|(
name|void
operator|)
name|rrset_cache_update
argument_list|(
name|worker
operator|->
name|env
operator|.
name|rrset_cache
argument_list|,
operator|&
name|ref
argument_list|,
operator|&
name|worker
operator|->
name|alloc
argument_list|,
operator|*
name|worker
operator|->
name|env
operator|.
name|now
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** load an rrset entry */
end_comment

begin_function
specifier|static
name|int
name|load_rrset
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|struct
name|regional
modifier|*
name|region
init|=
name|worker
operator|->
name|scratchpad
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|rk
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
decl_stmt|;
name|unsigned
name|int
name|rr_count
decl_stmt|,
name|rrsig_count
decl_stmt|,
name|trust
decl_stmt|,
name|security
decl_stmt|;
name|long
name|long
name|ttl
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|go_on
init|=
literal|1
decl_stmt|;
name|regional_free_all
argument_list|(
name|region
argument_list|)
expr_stmt|;
name|rk
operator|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|)
name|regional_alloc_zero
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rk
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|regional_alloc_zero
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rk
operator|||
operator|!
name|d
condition|)
block|{
name|log_warn
argument_list|(
literal|"error out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|";rrset"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_warn
argument_list|(
literal|"error expected ';rrset' but got %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|+=
literal|6
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|" nsec_apex"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|10
expr_stmt|;
name|rk
operator|->
name|rk
operator|.
name|flags
operator||=
name|PACKED_RRSET_NSEC_AT_APEX
expr_stmt|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
name|s
argument_list|,
literal|" "
name|ARG_LL
literal|"d %u %u %u %u"
argument_list|,
operator|&
name|ttl
argument_list|,
operator|&
name|rr_count
argument_list|,
operator|&
name|rrsig_count
argument_list|,
operator|&
name|trust
argument_list|,
operator|&
name|security
argument_list|)
operator|!=
literal|5
condition|)
block|{
name|log_warn
argument_list|(
literal|"error bad rrset spec %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|rr_count
operator|==
literal|0
operator|&&
name|rrsig_count
operator|==
literal|0
condition|)
block|{
name|log_warn
argument_list|(
literal|"bad rrset without contents"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|d
operator|->
name|count
operator|=
operator|(
name|size_t
operator|)
name|rr_count
expr_stmt|;
name|d
operator|->
name|rrsig_count
operator|=
operator|(
name|size_t
operator|)
name|rrsig_count
expr_stmt|;
name|d
operator|->
name|security
operator|=
operator|(
expr|enum
name|sec_status
operator|)
name|security
expr_stmt|;
name|d
operator|->
name|trust
operator|=
operator|(
expr|enum
name|rrset_trust
operator|)
name|trust
expr_stmt|;
name|d
operator|->
name|ttl
operator|=
operator|(
name|time_t
operator|)
name|ttl
operator|+
operator|*
name|worker
operator|->
name|env
operator|.
name|now
expr_stmt|;
name|d
operator|->
name|rr_len
operator|=
name|regional_alloc_zero
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
operator|(
name|d
operator|->
name|count
operator|+
name|d
operator|->
name|rrsig_count
operator|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|rr_ttl
operator|=
name|regional_alloc_zero
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
operator|*
operator|(
name|d
operator|->
name|count
operator|+
name|d
operator|->
name|rrsig_count
operator|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|rr_data
operator|=
name|regional_alloc_zero
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
operator|*
argument_list|)
operator|*
operator|(
name|d
operator|->
name|count
operator|+
name|d
operator|->
name|rrsig_count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|rr_len
operator|||
operator|!
name|d
operator|->
name|rr_ttl
operator|||
operator|!
name|d
operator|->
name|rr_data
condition|)
block|{
name|log_warn
argument_list|(
literal|"error out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* read the rr's themselves */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rr_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|load_rr
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|,
name|region
argument_list|,
name|rk
argument_list|,
name|d
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
operator|&
name|go_on
argument_list|,
operator|*
name|worker
operator|->
name|env
operator|.
name|now
argument_list|)
condition|)
block|{
name|log_warn
argument_list|(
literal|"could not read rr %u"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rrsig_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|load_rr
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|,
name|region
argument_list|,
name|rk
argument_list|,
name|d
argument_list|,
name|i
operator|+
name|rr_count
argument_list|,
literal|1
argument_list|,
operator|&
name|go_on
argument_list|,
operator|*
name|worker
operator|->
name|env
operator|.
name|now
argument_list|)
condition|)
block|{
name|log_warn
argument_list|(
literal|"could not read rrsig %u"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
name|go_on
condition|)
block|{
comment|/* skip this entry */
return|return
literal|1
return|;
block|}
return|return
name|move_into_cache
argument_list|(
name|rk
argument_list|,
name|d
argument_list|,
name|worker
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** load rrset cache */
end_comment

begin_function
specifier|static
name|int
name|load_rrset_cache
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|sldns_buffer
modifier|*
name|buf
init|=
name|worker
operator|->
name|env
operator|.
name|scratch_buffer
decl_stmt|;
if|if
condition|(
operator|!
name|read_fixed
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|,
literal|"START_RRSET_CACHE"
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|ssl_read_buf
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|)
operator|&&
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"END_RRSET_CACHE"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|load_rrset
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|,
name|worker
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** read qinfo from next three words */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|load_qinfo
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|)
block|{
comment|/* s is part of the buf */
name|char
modifier|*
name|s
init|=
name|str
decl_stmt|;
name|uint8_t
name|rr
index|[
name|LDNS_RR_BUF_SIZE
index|]
decl_stmt|;
name|size_t
name|rr_len
init|=
sizeof|sizeof
argument_list|(
name|rr
argument_list|)
decl_stmt|,
name|dname_len
init|=
literal|0
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* skip three words */
name|s
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|s
operator|=
name|strchr
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|s
operator|=
name|strchr
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|log_warn
argument_list|(
literal|"error line too short, %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|s
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|++
expr_stmt|;
comment|/* parse them */
name|status
operator|=
name|sldns_str2wire_rr_question_buf
argument_list|(
name|str
argument_list|,
name|rr
argument_list|,
operator|&
name|rr_len
argument_list|,
operator|&
name|dname_len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|log_warn
argument_list|(
literal|"error cannot parse: %s %s"
argument_list|,
name|sldns_get_errorstr_parse
argument_list|(
name|status
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|qinfo
operator|->
name|qtype
operator|=
name|sldns_wirerr_get_type
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|qclass
operator|=
name|sldns_wirerr_get_class
argument_list|(
name|rr
argument_list|,
name|rr_len
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
name|qinfo
operator|->
name|qname_len
operator|=
name|dname_len
expr_stmt|;
name|qinfo
operator|->
name|qname
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|regional_alloc_init
argument_list|(
name|region
argument_list|,
name|rr
argument_list|,
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qinfo
operator|->
name|qname
condition|)
block|{
name|log_warn
argument_list|(
literal|"error out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/** load a msg rrset reference */
end_comment

begin_function
specifier|static
name|int
name|load_ref
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
modifier|*
name|rrset
parameter_list|,
name|int
modifier|*
name|go_on
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|struct
name|query_info
name|qinfo
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
decl_stmt|;
comment|/* read line */
if|if
condition|(
operator|!
name|ssl_read_buf
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"BADREF"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|go_on
operator|=
literal|0
expr_stmt|;
comment|/* its bad, skip it and skip message */
return|return
literal|1
return|;
block|}
name|s
operator|=
name|load_qinfo
argument_list|(
name|s
argument_list|,
operator|&
name|qinfo
argument_list|,
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
name|s
argument_list|,
literal|" %u"
argument_list|,
operator|&
name|flags
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|log_warn
argument_list|(
literal|"error cannot parse flags: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* lookup in cache */
name|k
operator|=
name|rrset_cache_lookup
argument_list|(
name|worker
operator|->
name|env
operator|.
name|rrset_cache
argument_list|,
name|qinfo
operator|.
name|qname
argument_list|,
name|qinfo
operator|.
name|qname_len
argument_list|,
name|qinfo
operator|.
name|qtype
argument_list|,
name|qinfo
operator|.
name|qclass
argument_list|,
operator|(
name|uint32_t
operator|)
name|flags
argument_list|,
operator|*
name|worker
operator|->
name|env
operator|.
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|k
condition|)
block|{
comment|/* not found or expired */
operator|*
name|go_on
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* store in result */
operator|*
name|rrset
operator|=
name|packed_rrset_copy_region
argument_list|(
name|k
argument_list|,
name|region
argument_list|,
operator|*
name|worker
operator|->
name|env
operator|.
name|now
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|k
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|rrset
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/** load a msg entry */
end_comment

begin_function
specifier|static
name|int
name|load_msg
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|struct
name|regional
modifier|*
name|region
init|=
name|worker
operator|->
name|scratchpad
decl_stmt|;
name|struct
name|query_info
name|qinf
decl_stmt|;
name|struct
name|reply_info
name|rep
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|,
name|qdcount
decl_stmt|,
name|security
decl_stmt|,
name|an
decl_stmt|,
name|ns
decl_stmt|,
name|ar
decl_stmt|;
name|long
name|long
name|ttl
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|go_on
init|=
literal|1
decl_stmt|;
name|regional_free_all
argument_list|(
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"msg "
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_warn
argument_list|(
literal|"error expected msg but got %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|s
operator|+=
literal|4
expr_stmt|;
name|s
operator|=
name|load_qinfo
argument_list|(
name|s
argument_list|,
operator|&
name|qinf
argument_list|,
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* read remainder of line */
if|if
condition|(
name|sscanf
argument_list|(
name|s
argument_list|,
literal|" %u %u "
name|ARG_LL
literal|"d %u %u %u %u"
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|qdcount
argument_list|,
operator|&
name|ttl
argument_list|,
operator|&
name|security
argument_list|,
operator|&
name|an
argument_list|,
operator|&
name|ns
argument_list|,
operator|&
name|ar
argument_list|)
operator|!=
literal|7
condition|)
block|{
name|log_warn
argument_list|(
literal|"error cannot parse numbers: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rep
operator|.
name|flags
operator|=
operator|(
name|uint16_t
operator|)
name|flags
expr_stmt|;
name|rep
operator|.
name|qdcount
operator|=
operator|(
name|uint16_t
operator|)
name|qdcount
expr_stmt|;
name|rep
operator|.
name|ttl
operator|=
operator|(
name|time_t
operator|)
name|ttl
expr_stmt|;
name|rep
operator|.
name|prefetch_ttl
operator|=
name|PREFETCH_TTL_CALC
argument_list|(
name|rep
operator|.
name|ttl
argument_list|)
expr_stmt|;
name|rep
operator|.
name|security
operator|=
operator|(
expr|enum
name|sec_status
operator|)
name|security
expr_stmt|;
name|rep
operator|.
name|an_numrrsets
operator|=
operator|(
name|size_t
operator|)
name|an
expr_stmt|;
name|rep
operator|.
name|ns_numrrsets
operator|=
operator|(
name|size_t
operator|)
name|ns
expr_stmt|;
name|rep
operator|.
name|ar_numrrsets
operator|=
operator|(
name|size_t
operator|)
name|ar
expr_stmt|;
name|rep
operator|.
name|rrset_count
operator|=
operator|(
name|size_t
operator|)
name|an
operator|+
operator|(
name|size_t
operator|)
name|ns
operator|+
operator|(
name|size_t
operator|)
name|ar
expr_stmt|;
name|rep
operator|.
name|rrsets
operator|=
operator|(
expr|struct
name|ub_packed_rrset_key
operator|*
operator|*
operator|)
name|regional_alloc_zero
argument_list|(
name|region
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
operator|*
argument_list|)
operator|*
name|rep
operator|.
name|rrset_count
argument_list|)
expr_stmt|;
comment|/* fill repinfo with references */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep
operator|.
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|load_ref
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|,
name|worker
argument_list|,
name|region
argument_list|,
operator|&
name|rep
operator|.
name|rrsets
index|[
name|i
index|]
argument_list|,
operator|&
name|go_on
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
name|go_on
condition|)
return|return
literal|1
return|;
comment|/* skip this one, not all references satisfied */
if|if
condition|(
operator|!
name|dns_cache_store
argument_list|(
operator|&
name|worker
operator|->
name|env
argument_list|,
operator|&
name|qinf
argument_list|,
operator|&
name|rep
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|log_warn
argument_list|(
literal|"error out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** load msg cache */
end_comment

begin_function
specifier|static
name|int
name|load_msg_cache
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|sldns_buffer
modifier|*
name|buf
init|=
name|worker
operator|->
name|env
operator|.
name|scratch_buffer
decl_stmt|;
if|if
condition|(
operator|!
name|read_fixed
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|,
literal|"START_MSG_CACHE"
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|ssl_read_buf
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|)
operator|&&
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"END_MSG_CACHE"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|load_msg
argument_list|(
name|ssl
argument_list|,
name|buf
argument_list|,
name|worker
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|load_cache
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|load_rrset_cache
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|load_msg_cache
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|read_fixed
argument_list|(
name|ssl
argument_list|,
name|worker
operator|->
name|env
operator|.
name|scratch_buffer
argument_list|,
literal|"EOF"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** print details on a delegation point */
end_comment

begin_function
specifier|static
name|void
name|print_dp_details
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|)
block|{
name|char
name|buf
index|[
literal|257
index|]
decl_stmt|;
name|struct
name|delegpt_addr
modifier|*
name|a
decl_stmt|;
name|int
name|lame
decl_stmt|,
name|dlame
decl_stmt|,
name|rlame
decl_stmt|,
name|rto
decl_stmt|,
name|edns_vs
decl_stmt|,
name|to
decl_stmt|,
name|delay
decl_stmt|,
name|tA
init|=
literal|0
decl_stmt|,
name|tAAAA
init|=
literal|0
decl_stmt|,
name|tother
init|=
literal|0
decl_stmt|;
name|long
name|long
name|entry_ttl
decl_stmt|;
name|struct
name|rtt_info
name|ri
decl_stmt|;
name|uint8_t
name|edns_lame_known
decl_stmt|;
for|for
control|(
name|a
operator|=
name|dp
operator|->
name|target_list
init|;
name|a
condition|;
name|a
operator|=
name|a
operator|->
name|next_target
control|)
block|{
name|addr_to_str
argument_list|(
operator|&
name|a
operator|->
name|addr
argument_list|,
name|a
operator|->
name|addrlen
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%-16s\t"
argument_list|,
name|buf
argument_list|)
condition|)
return|return;
if|if
condition|(
name|a
operator|->
name|bogus
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"Address is BOGUS. "
argument_list|)
condition|)
return|return;
block|}
comment|/* lookup in infra cache */
name|delay
operator|=
literal|0
expr_stmt|;
name|entry_ttl
operator|=
name|infra_get_host_rto
argument_list|(
name|worker
operator|->
name|env
operator|.
name|infra_cache
argument_list|,
operator|&
name|a
operator|->
name|addr
argument_list|,
name|a
operator|->
name|addrlen
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelen
argument_list|,
operator|&
name|ri
argument_list|,
operator|&
name|delay
argument_list|,
operator|*
name|worker
operator|->
name|env
operator|.
name|now
argument_list|,
operator|&
name|tA
argument_list|,
operator|&
name|tAAAA
argument_list|,
operator|&
name|tother
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry_ttl
operator|==
operator|-
literal|2
operator|&&
name|ri
operator|.
name|rto
operator|>=
name|USEFUL_SERVER_TOP_TIMEOUT
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"expired, rto %d msec, tA %d "
literal|"tAAAA %d tother %d.\n"
argument_list|,
name|ri
operator|.
name|rto
argument_list|,
name|tA
argument_list|,
name|tAAAA
argument_list|,
name|tother
argument_list|)
condition|)
return|return;
continue|continue;
block|}
if|if
condition|(
name|entry_ttl
operator|==
operator|-
literal|1
operator|||
name|entry_ttl
operator|==
operator|-
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"not in infra cache.\n"
argument_list|)
condition|)
return|return;
continue|continue;
comment|/* skip stuff not in infra cache */
block|}
comment|/* uses type_A because most often looked up, but other 		 * lameness won't be reported then */
if|if
condition|(
operator|!
name|infra_get_lame_rtt
argument_list|(
name|worker
operator|->
name|env
operator|.
name|infra_cache
argument_list|,
operator|&
name|a
operator|->
name|addr
argument_list|,
name|a
operator|->
name|addrlen
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelen
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
operator|&
name|lame
argument_list|,
operator|&
name|dlame
argument_list|,
operator|&
name|rlame
argument_list|,
operator|&
name|rto
argument_list|,
operator|*
name|worker
operator|->
name|env
operator|.
name|now
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"not in infra cache.\n"
argument_list|)
condition|)
return|return;
continue|continue;
comment|/* skip stuff not in infra cache */
block|}
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"%s%s%s%srto %d msec, ttl "
name|ARG_LL
literal|"d, "
literal|"ping %d var %d rtt %d, tA %d, tAAAA %d, tother %d"
argument_list|,
name|lame
condition|?
literal|"LAME "
else|:
literal|""
argument_list|,
name|dlame
condition|?
literal|"NoDNSSEC "
else|:
literal|""
argument_list|,
name|a
operator|->
name|lame
condition|?
literal|"AddrWasParentSide "
else|:
literal|""
argument_list|,
name|rlame
condition|?
literal|"NoAuthButRecursive "
else|:
literal|""
argument_list|,
name|rto
argument_list|,
name|entry_ttl
argument_list|,
name|ri
operator|.
name|srtt
argument_list|,
name|ri
operator|.
name|rttvar
argument_list|,
name|rtt_notimeout
argument_list|(
operator|&
name|ri
argument_list|)
argument_list|,
name|tA
argument_list|,
name|tAAAA
argument_list|,
name|tother
argument_list|)
condition|)
return|return;
if|if
condition|(
name|delay
condition|)
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|", probedelay %d"
argument_list|,
name|delay
argument_list|)
condition|)
return|return;
if|if
condition|(
name|infra_host
argument_list|(
name|worker
operator|->
name|env
operator|.
name|infra_cache
argument_list|,
operator|&
name|a
operator|->
name|addr
argument_list|,
name|a
operator|->
name|addrlen
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelen
argument_list|,
operator|*
name|worker
operator|->
name|env
operator|.
name|now
argument_list|,
operator|&
name|edns_vs
argument_list|,
operator|&
name|edns_lame_known
argument_list|,
operator|&
name|to
argument_list|)
condition|)
block|{
if|if
condition|(
name|edns_vs
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|", noEDNS%s."
argument_list|,
name|edns_lame_known
condition|?
literal|" probed"
else|:
literal|" assumed"
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|", EDNS %d%s."
argument_list|,
name|edns_vs
argument_list|,
name|edns_lame_known
condition|?
literal|" probed"
else|:
literal|" assumed"
argument_list|)
condition|)
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"\n"
argument_list|)
condition|)
return|return;
block|}
block|}
end_function

begin_comment
comment|/** print main dp info */
end_comment

begin_function
specifier|static
name|void
name|print_dp_main
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|,
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|n_ns
decl_stmt|,
name|n_miss
decl_stmt|,
name|n_addr
decl_stmt|,
name|n_res
decl_stmt|,
name|n_avail
decl_stmt|;
comment|/* print the dp */
if|if
condition|(
name|msg
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg
operator|->
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
init|=
name|msg
operator|->
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|k
operator|->
name|entry
operator|.
name|data
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|security
operator|==
name|sec_status_bogus
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"Address is BOGUS:\n"
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
operator|!
name|dump_rrset
argument_list|(
name|ssl
argument_list|,
name|k
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
block|}
name|delegpt_count_ns
argument_list|(
name|dp
argument_list|,
operator|&
name|n_ns
argument_list|,
operator|&
name|n_miss
argument_list|)
expr_stmt|;
name|delegpt_count_addr
argument_list|(
name|dp
argument_list|,
operator|&
name|n_addr
argument_list|,
operator|&
name|n_res
argument_list|,
operator|&
name|n_avail
argument_list|)
expr_stmt|;
comment|/* since dp has not been used by iterator, all are available*/
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"Delegation with %d names, of which %d "
literal|"can be examined to query further addresses.\n"
literal|"%sIt provides %d IP addresses.\n"
argument_list|,
operator|(
name|int
operator|)
name|n_ns
argument_list|,
operator|(
name|int
operator|)
name|n_miss
argument_list|,
operator|(
name|dp
operator|->
name|bogus
condition|?
literal|"It is BOGUS. "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|int
operator|)
name|n_addr
argument_list|)
condition|)
return|return;
block|}
end_function

begin_function
name|int
name|print_deleg_lookup
parameter_list|(
name|SSL
modifier|*
name|ssl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|,
name|int
name|ATTR_UNUSED
parameter_list|(
name|nmlabs
parameter_list|)
parameter_list|)
block|{
comment|/* deep links into the iterator module */
name|struct
name|delegpt
modifier|*
name|dp
decl_stmt|;
name|struct
name|dns_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|regional
modifier|*
name|region
init|=
name|worker
operator|->
name|scratchpad
decl_stmt|;
name|char
name|b
index|[
literal|260
index|]
decl_stmt|;
name|struct
name|query_info
name|qinfo
decl_stmt|;
name|struct
name|iter_hints_stub
modifier|*
name|stub
decl_stmt|;
name|regional_free_all
argument_list|(
name|region
argument_list|)
expr_stmt|;
name|qinfo
operator|.
name|qname
operator|=
name|nm
expr_stmt|;
name|qinfo
operator|.
name|qname_len
operator|=
name|nmlen
expr_stmt|;
name|qinfo
operator|.
name|qtype
operator|=
name|LDNS_RR_TYPE_A
expr_stmt|;
name|qinfo
operator|.
name|qclass
operator|=
name|LDNS_RR_CLASS_IN
expr_stmt|;
name|dname_str
argument_list|(
name|nm
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"The following name servers are used for lookup "
literal|"of %s\n"
argument_list|,
name|b
argument_list|)
condition|)
return|return
literal|0
return|;
name|dp
operator|=
name|forwards_lookup
argument_list|(
name|worker
operator|->
name|env
operator|.
name|fwds
argument_list|,
name|nm
argument_list|,
name|qinfo
operator|.
name|qclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"forwarding request:\n"
argument_list|)
condition|)
return|return
literal|0
return|;
name|print_dp_main
argument_list|(
name|ssl
argument_list|,
name|dp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|print_dp_details
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|dp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|dp
operator|=
name|dns_cache_find_delegation
argument_list|(
operator|&
name|worker
operator|->
name|env
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|qinfo
operator|.
name|qtype
argument_list|,
name|qinfo
operator|.
name|qclass
argument_list|,
name|region
argument_list|,
operator|&
name|msg
argument_list|,
operator|*
name|worker
operator|->
name|env
operator|.
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
block|{
return|return
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"no delegation from "
literal|"cache; goes to configured roots\n"
argument_list|)
return|;
block|}
comment|/* go up? */
if|if
condition|(
name|iter_dp_is_useless
argument_list|(
operator|&
name|qinfo
argument_list|,
name|BIT_RD
argument_list|,
name|dp
argument_list|)
condition|)
block|{
name|print_dp_main
argument_list|(
name|ssl
argument_list|,
name|dp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|print_dp_details
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"cache delegation was "
literal|"useless (no IP addresses)\n"
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dname_is_root
argument_list|(
name|nm
argument_list|)
condition|)
block|{
comment|/* goes to root config */
return|return
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"no delegation from "
literal|"cache; goes to configured roots\n"
argument_list|)
return|;
block|}
else|else
block|{
comment|/* useless, goes up */
name|nm
operator|=
name|dp
operator|->
name|name
expr_stmt|;
name|nmlen
operator|=
name|dp
operator|->
name|namelen
expr_stmt|;
name|dname_remove_label
argument_list|(
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|)
expr_stmt|;
name|dname_str
argument_list|(
name|nm
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"going up, lookup %s\n"
argument_list|,
name|b
argument_list|)
condition|)
return|return
literal|0
return|;
continue|continue;
block|}
block|}
name|stub
operator|=
name|hints_lookup_stub
argument_list|(
name|worker
operator|->
name|env
operator|.
name|hints
argument_list|,
name|nm
argument_list|,
name|qinfo
operator|.
name|qclass
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub
condition|)
block|{
if|if
condition|(
name|stub
operator|->
name|noprime
condition|)
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"The noprime stub servers "
literal|"are used:\n"
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ssl_printf
argument_list|(
name|ssl
argument_list|,
literal|"The stub is primed "
literal|"with servers:\n"
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|print_dp_main
argument_list|(
name|ssl
argument_list|,
name|stub
operator|->
name|dp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|print_dp_details
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|stub
operator|->
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_dp_main
argument_list|(
name|ssl
argument_list|,
name|dp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|print_dp_details
argument_list|(
name|ssl
argument_list|,
name|worker
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

