begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * daemon/worker.c - worker that handles a pending list of requests.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file implements the worker that handles callbacks on events, for  * pending requests.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/random.h"
end_include

begin_include
include|#
directive|include
file|"daemon/worker.h"
end_include

begin_include
include|#
directive|include
file|"daemon/daemon.h"
end_include

begin_include
include|#
directive|include
file|"daemon/remote.h"
end_include

begin_include
include|#
directive|include
file|"daemon/acl_list.h"
end_include

begin_include
include|#
directive|include
file|"util/netevent.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/storage/slabhash.h"
end_include

begin_include
include|#
directive|include
file|"services/listen_dnsport.h"
end_include

begin_include
include|#
directive|include
file|"services/outside_network.h"
end_include

begin_include
include|#
directive|include
file|"services/outbound_list.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/infra.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/dns.h"
end_include

begin_include
include|#
directive|include
file|"services/mesh.h"
end_include

begin_include
include|#
directive|include
file|"services/localzone.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgparse.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgencode.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/fptr_wlist.h"
end_include

begin_include
include|#
directive|include
file|"util/tube.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_fwd.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_hints.h"
end_include

begin_include
include|#
directive|include
file|"validator/autotrust.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_anchor.h"
end_include

begin_include
include|#
directive|include
file|"libunbound/context.h"
end_include

begin_include
include|#
directive|include
file|"libunbound/libworker.h"
end_include

begin_include
include|#
directive|include
file|"sldns/sbuffer.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETDB_H
end_ifdef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|UB_ON_WINDOWS
end_ifdef

begin_include
include|#
directive|include
file|"winrc/win_svc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** Size of an UDP datagram */
end_comment

begin_define
define|#
directive|define
name|NORMAL_UDP_SIZE
value|512
end_define

begin_comment
comment|/* bytes */
end_comment

begin_comment
comment|/** ratelimit for error responses */
end_comment

begin_define
define|#
directive|define
name|ERROR_RATELIMIT
value|100
end_define

begin_comment
comment|/* qps */
end_comment

begin_comment
comment|/**   * seconds to add to prefetch leeway.  This is a TTL that expires old rrsets  * earlier than they should in order to put the new update into the cache.  * This additional value is to make sure that if not all TTLs are equal in  * the message to be updated(and replaced), that rrsets with up to this much  * extra TTL are also replaced.  This means that the resulting new message  * will have (most likely) this TTL at least, avoiding very small 'split  * second' TTLs due to operators choosing relative primes for TTLs (or so).  * Also has to be at least one to break ties (and overwrite cached entry).  */
end_comment

begin_define
define|#
directive|define
name|PREFETCH_EXPIRY_ADD
value|60
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|UNBOUND_ALLOC_STATS
end_ifdef

begin_comment
comment|/** measure memory leakage */
end_comment

begin_function
specifier|static
name|void
name|debug_memleak
parameter_list|(
name|size_t
name|accounted
parameter_list|,
name|size_t
name|heap
parameter_list|,
name|size_t
name|total_alloc
parameter_list|,
name|size_t
name|total_free
parameter_list|)
block|{
specifier|static
name|int
name|init
init|=
literal|0
decl_stmt|;
specifier|static
name|size_t
name|base_heap
decl_stmt|,
name|base_accounted
decl_stmt|,
name|base_alloc
decl_stmt|,
name|base_free
decl_stmt|;
name|size_t
name|base_af
decl_stmt|,
name|cur_af
decl_stmt|,
name|grow_af
decl_stmt|,
name|grow_acc
decl_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
block|{
name|init
operator|=
literal|1
expr_stmt|;
name|base_heap
operator|=
name|heap
expr_stmt|;
name|base_accounted
operator|=
name|accounted
expr_stmt|;
name|base_alloc
operator|=
name|total_alloc
expr_stmt|;
name|base_free
operator|=
name|total_free
expr_stmt|;
block|}
name|base_af
operator|=
name|base_alloc
operator|-
name|base_free
expr_stmt|;
name|cur_af
operator|=
name|total_alloc
operator|-
name|total_free
expr_stmt|;
name|grow_af
operator|=
name|cur_af
operator|-
name|base_af
expr_stmt|;
name|grow_acc
operator|=
name|accounted
operator|-
name|base_accounted
expr_stmt|;
name|log_info
argument_list|(
literal|"Leakage: %d leaked. growth: %u use, %u acc, %u heap"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|grow_af
operator|-
name|grow_acc
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|grow_af
argument_list|,
operator|(
name|unsigned
operator|)
name|grow_acc
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|heap
operator|-
name|base_heap
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** give debug heap size indication */
end_comment

begin_function
specifier|static
name|void
name|debug_total_mem
parameter_list|(
name|size_t
name|calctotal
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SBRK
specifier|extern
name|void
modifier|*
name|unbound_start_brk
decl_stmt|;
specifier|extern
name|size_t
name|unbound_mem_alloc
decl_stmt|,
name|unbound_mem_freed
decl_stmt|;
name|void
modifier|*
name|cur
init|=
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|total
init|=
name|cur
operator|-
name|unbound_start_brk
decl_stmt|;
name|log_info
argument_list|(
literal|"Total heap memory estimate: %u  total-alloc: %u  "
literal|"total-free: %u"
argument_list|,
operator|(
name|unsigned
operator|)
name|total
argument_list|,
operator|(
name|unsigned
operator|)
name|unbound_mem_alloc
argument_list|,
operator|(
name|unsigned
operator|)
name|unbound_mem_freed
argument_list|)
expr_stmt|;
name|debug_memleak
argument_list|(
name|calctotal
argument_list|,
operator|(
name|size_t
operator|)
name|total
argument_list|,
name|unbound_mem_alloc
argument_list|,
name|unbound_mem_freed
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|calctotal
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SBRK */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNBOUND_ALLOC_STATS */
end_comment

begin_comment
comment|/** Report on memory usage by this thread and global */
end_comment

begin_decl_stmt
specifier|static
name|void
name|worker_mem_report
argument_list|(
expr|struct
name|worker
operator|*
name|ATTR_UNUSED
argument_list|(
name|worker
argument_list|)
argument_list|,
expr|struct
name|serviced_query
operator|*
name|ATTR_UNUSED
argument_list|(
name|cur_serv
argument_list|)
argument_list|)
block|{
ifdef|#
directive|ifdef
name|UNBOUND_ALLOC_STATS
comment|/* debug func in validator module */
name|size_t
name|total
decl_stmt|,
name|front
decl_stmt|,
name|back
decl_stmt|,
name|mesh
decl_stmt|,
name|msg
decl_stmt|,
name|rrset
decl_stmt|,
name|infra
decl_stmt|,
name|ac
decl_stmt|,
name|superac
decl_stmt|;
name|size_t
name|me
decl_stmt|,
name|iter
decl_stmt|,
name|val
decl_stmt|,
name|anch
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|verbosity
operator|<
name|VERB_ALGO
condition|)
return|return;
name|front
operator|=
name|listen_get_mem
argument_list|(
name|worker
operator|->
name|front
argument_list|)
expr_stmt|;
name|back
operator|=
name|outnet_get_mem
argument_list|(
name|worker
operator|->
name|back
argument_list|)
expr_stmt|;
name|msg
operator|=
name|slabhash_get_mem
argument_list|(
name|worker
operator|->
name|env
operator|.
name|msg_cache
argument_list|)
expr_stmt|;
name|rrset
operator|=
name|slabhash_get_mem
argument_list|(
operator|&
name|worker
operator|->
name|env
operator|.
name|rrset_cache
operator|->
name|table
argument_list|)
expr_stmt|;
name|infra
operator|=
name|infra_get_mem
argument_list|(
name|worker
operator|->
name|env
operator|.
name|infra_cache
argument_list|)
expr_stmt|;
name|mesh
operator|=
name|mesh_get_mem
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
argument_list|)
expr_stmt|;
name|ac
operator|=
name|alloc_get_mem
argument_list|(
operator|&
name|worker
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|superac
operator|=
name|alloc_get_mem
argument_list|(
operator|&
name|worker
operator|->
name|daemon
operator|->
name|superalloc
argument_list|)
expr_stmt|;
name|anch
operator|=
name|anchors_get_mem
argument_list|(
name|worker
operator|->
name|env
operator|.
name|anchors
argument_list|)
expr_stmt|;
name|iter
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|worker
operator|->
name|env
operator|.
name|mesh
operator|->
name|mods
operator|.
name|num
condition|;
name|i
operator|++
control|)
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_mod_get_mem
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|i
index|]
operator|->
name|get_mem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|i
index|]
operator|->
name|name
argument_list|,
literal|"validator"
argument_list|)
operator|==
literal|0
condition|)
name|val
operator|+=
operator|(
operator|*
name|worker
operator|->
name|env
operator|.
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|i
index|]
operator|->
name|get_mem
operator|)
operator|(
operator|&
name|worker
operator|->
name|env
operator|,
name|i
operator|)
expr_stmt|;
else|else
name|iter
operator|+=
operator|(
operator|*
name|worker
operator|->
name|env
operator|.
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|i
index|]
operator|->
name|get_mem
operator|)
operator|(
operator|&
name|worker
operator|->
name|env
operator|,
name|i
operator|)
expr_stmt|;
block|}
name|me
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|worker
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|worker
operator|->
name|base
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|worker
operator|->
name|comsig
argument_list|)
operator|+
name|comm_point_get_mem
argument_list|(
name|worker
operator|->
name|cmd_com
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|worker
operator|->
name|rndstate
argument_list|)
operator|+
name|regional_get_mem
argument_list|(
name|worker
operator|->
name|scratchpad
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|worker
operator|->
name|env
operator|.
name|scratch_buffer
argument_list|)
operator|+
name|sldns_buffer_capacity
argument_list|(
name|worker
operator|->
name|env
operator|.
name|scratch_buffer
argument_list|)
operator|+
name|forwards_get_mem
argument_list|(
name|worker
operator|->
name|env
operator|.
name|fwds
argument_list|)
operator|+
name|hints_get_mem
argument_list|(
name|worker
operator|->
name|env
operator|.
name|hints
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker
operator|->
name|thread_num
operator|==
literal|0
condition|)
name|me
operator|+=
name|acl_list_get_mem
argument_list|(
name|worker
operator|->
name|daemon
operator|->
name|acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_serv
condition|)
block|{
name|me
operator|+=
name|serviced_get_mem
argument_list|(
name|cur_serv
argument_list|)
expr_stmt|;
block|}
name|total
operator|=
name|front
operator|+
name|back
operator|+
name|mesh
operator|+
name|msg
operator|+
name|rrset
operator|+
name|infra
operator|+
name|iter
operator|+
name|val
operator|+
name|ac
operator|+
name|superac
operator|+
name|me
expr_stmt|;
name|log_info
argument_list|(
literal|"Memory conditions: %u front=%u back=%u mesh=%u msg=%u "
literal|"rrset=%u infra=%u iter=%u val=%u anchors=%u "
literal|"alloccache=%u globalalloccache=%u me=%u"
argument_list|,
operator|(
name|unsigned
operator|)
name|total
argument_list|,
operator|(
name|unsigned
operator|)
name|front
argument_list|,
operator|(
name|unsigned
operator|)
name|back
argument_list|,
operator|(
name|unsigned
operator|)
name|mesh
argument_list|,
operator|(
name|unsigned
operator|)
name|msg
argument_list|,
operator|(
name|unsigned
operator|)
name|rrset
argument_list|,
operator|(
name|unsigned
operator|)
name|infra
argument_list|,
operator|(
name|unsigned
operator|)
name|iter
argument_list|,
operator|(
name|unsigned
operator|)
name|val
argument_list|,
operator|(
name|unsigned
operator|)
name|anch
argument_list|,
operator|(
name|unsigned
operator|)
name|ac
argument_list|,
operator|(
name|unsigned
operator|)
name|superac
argument_list|,
operator|(
name|unsigned
operator|)
name|me
argument_list|)
expr_stmt|;
name|debug_total_mem
argument_list|(
name|total
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no UNBOUND_ALLOC_STATS */
name|size_t
name|val
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|verbosity
operator|<
name|VERB_QUERY
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|worker
operator|->
name|env
operator|.
name|mesh
operator|->
name|mods
operator|.
name|num
condition|;
name|i
operator|++
control|)
block|{
name|fptr_ok
argument_list|(
name|fptr_whitelist_mod_get_mem
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|i
index|]
operator|->
name|get_mem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|i
index|]
operator|->
name|name
argument_list|,
literal|"validator"
argument_list|)
operator|==
literal|0
condition|)
name|val
operator|+=
operator|(
operator|*
name|worker
operator|->
name|env
operator|.
name|mesh
operator|->
name|mods
operator|.
name|mod
index|[
name|i
index|]
operator|->
name|get_mem
operator|)
operator|(
operator|&
name|worker
operator|->
name|env
operator|,
name|i
operator|)
expr_stmt|;
block|}
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"cache memory msg=%u rrset=%u infra=%u val=%u"
argument_list|,
operator|(
name|unsigned
operator|)
name|slabhash_get_mem
argument_list|(
name|worker
operator|->
name|env
operator|.
name|msg_cache
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|slabhash_get_mem
argument_list|(
operator|&
name|worker
operator|->
name|env
operator|.
name|rrset_cache
operator|->
name|table
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|infra_get_mem
argument_list|(
name|worker
operator|->
name|env
operator|.
name|infra_cache
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNBOUND_ALLOC_STATS */
block|}
end_decl_stmt

begin_function
name|void
name|worker_send_cmd
parameter_list|(
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|enum
name|worker_commands
name|cmd
parameter_list|)
block|{
name|uint32_t
name|c
init|=
operator|(
name|uint32_t
operator|)
name|htonl
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tube_write_msg
argument_list|(
name|worker
operator|->
name|cmd
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"worker send cmd %d failed"
argument_list|,
operator|(
name|int
operator|)
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|worker_handle_reply
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|error
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|reply_info
parameter_list|)
block|{
name|struct
name|module_qstate
modifier|*
name|q
init|=
operator|(
expr|struct
name|module_qstate
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|worker
modifier|*
name|worker
init|=
name|q
operator|->
name|env
operator|->
name|worker
decl_stmt|;
name|struct
name|outbound_entry
name|e
decl_stmt|;
name|e
operator|.
name|qstate
operator|=
name|q
expr_stmt|;
name|e
operator|.
name|qsent
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mesh_report_reply
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
argument_list|,
operator|&
name|e
argument_list|,
name|reply_info
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|worker_mem_report
argument_list|(
name|worker
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* sanity check. */
if|if
condition|(
operator|!
name|LDNS_QR_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|||
name|LDNS_OPCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|!=
name|LDNS_PACKET_QUERY
operator|||
name|LDNS_QDCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
block|{
comment|/* error becomes timeout for the module as if this reply 		 * never arrived. */
name|mesh_report_reply
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
argument_list|,
operator|&
name|e
argument_list|,
name|reply_info
argument_list|,
name|NETEVENT_TIMEOUT
argument_list|)
expr_stmt|;
name|worker_mem_report
argument_list|(
name|worker
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mesh_report_reply
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
argument_list|,
operator|&
name|e
argument_list|,
name|reply_info
argument_list|,
name|NETEVENT_NOERROR
argument_list|)
expr_stmt|;
name|worker_mem_report
argument_list|(
name|worker
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|worker_handle_service_reply
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|error
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|reply_info
parameter_list|)
block|{
name|struct
name|outbound_entry
modifier|*
name|e
init|=
operator|(
expr|struct
name|outbound_entry
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|worker
modifier|*
name|worker
init|=
name|e
operator|->
name|qstate
operator|->
name|env
operator|->
name|worker
decl_stmt|;
name|struct
name|serviced_query
modifier|*
name|sq
init|=
name|e
operator|->
name|qsent
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"worker svcd callback for qstate %p"
argument_list|,
name|e
operator|->
name|qstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mesh_report_reply
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
argument_list|,
name|e
argument_list|,
name|reply_info
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|worker_mem_report
argument_list|(
name|worker
argument_list|,
name|sq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* sanity check. */
if|if
condition|(
operator|!
name|LDNS_QR_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|||
name|LDNS_OPCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|!=
name|LDNS_PACKET_QUERY
operator|||
name|LDNS_QDCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
block|{
comment|/* error becomes timeout for the module as if this reply 		 * never arrived. */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"worker: bad reply handled as timeout"
argument_list|)
expr_stmt|;
name|mesh_report_reply
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
argument_list|,
name|e
argument_list|,
name|reply_info
argument_list|,
name|NETEVENT_TIMEOUT
argument_list|)
expr_stmt|;
name|worker_mem_report
argument_list|(
name|worker
argument_list|,
name|sq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mesh_report_reply
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
argument_list|,
name|e
argument_list|,
name|reply_info
argument_list|,
name|NETEVENT_NOERROR
argument_list|)
expr_stmt|;
name|worker_mem_report
argument_list|(
name|worker
argument_list|,
name|sq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** ratelimit error replies  * @param worker: the worker struct with ratelimit counter  * @param err: error code that would be wanted.  * @return value of err if okay, or -1 if it should be discarded instead.  */
end_comment

begin_function
specifier|static
name|int
name|worker_err_ratelimit
parameter_list|(
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|int
name|err
parameter_list|)
block|{
if|if
condition|(
name|worker
operator|->
name|err_limit_time
operator|==
operator|*
name|worker
operator|->
name|env
operator|.
name|now
condition|)
block|{
comment|/* see if limit is exceeded for this second */
if|if
condition|(
name|worker
operator|->
name|err_limit_count
operator|++
operator|>
name|ERROR_RATELIMIT
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|/* new second, new limits */
name|worker
operator|->
name|err_limit_time
operator|=
operator|*
name|worker
operator|->
name|env
operator|.
name|now
expr_stmt|;
name|worker
operator|->
name|err_limit_count
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/** check request sanity.  * @param pkt: the wire packet to examine for sanity.  * @param worker: parameters for checking.  * @return error code, 0 OK, or -1 discard. */
end_comment

begin_function
specifier|static
name|int
name|worker_check_request
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
if|if
condition|(
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
operator|<
name|LDNS_HEADER_SIZE
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"request too short, discarded"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|sldns_buffer_limit
argument_list|(
name|pkt
argument_list|)
operator|>
name|NORMAL_UDP_SIZE
operator|&&
name|worker
operator|->
name|daemon
operator|->
name|cfg
operator|->
name|harden_large_queries
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"request too large, discarded"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|LDNS_QR_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"request has QR bit on, discarded"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|LDNS_TC_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
condition|)
block|{
name|LDNS_TC_CLR
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"request bad, has TC bit on"
argument_list|)
expr_stmt|;
return|return
name|worker_err_ratelimit
argument_list|(
name|worker
argument_list|,
name|LDNS_RCODE_FORMERR
argument_list|)
return|;
block|}
if|if
condition|(
name|LDNS_OPCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
operator|!=
name|LDNS_PACKET_QUERY
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"request unknown opcode %d"
argument_list|,
name|LDNS_OPCODE_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|worker_err_ratelimit
argument_list|(
name|worker
argument_list|,
name|LDNS_RCODE_NOTIMPL
argument_list|)
return|;
block|}
if|if
condition|(
name|LDNS_QDCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"request wrong nr qd=%d"
argument_list|,
name|LDNS_QDCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|worker_err_ratelimit
argument_list|(
name|worker
argument_list|,
name|LDNS_RCODE_FORMERR
argument_list|)
return|;
block|}
if|if
condition|(
name|LDNS_ANCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"request wrong nr an=%d"
argument_list|,
name|LDNS_ANCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|worker_err_ratelimit
argument_list|(
name|worker
argument_list|,
name|LDNS_RCODE_FORMERR
argument_list|)
return|;
block|}
if|if
condition|(
name|LDNS_NSCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"request wrong nr ns=%d"
argument_list|,
name|LDNS_NSCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|worker_err_ratelimit
argument_list|(
name|worker
argument_list|,
name|LDNS_RCODE_FORMERR
argument_list|)
return|;
block|}
if|if
condition|(
name|LDNS_ARCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"request wrong nr ar=%d"
argument_list|,
name|LDNS_ARCOUNT
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|worker_err_ratelimit
argument_list|(
name|worker
argument_list|,
name|LDNS_RCODE_FORMERR
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|void
name|worker_handle_control_cmd
argument_list|(
expr|struct
name|tube
operator|*
name|ATTR_UNUSED
argument_list|(
name|tube
argument_list|)
argument_list|,
name|uint8_t
operator|*
name|msg
argument_list|,
name|size_t
name|len
argument_list|,
name|int
name|error
argument_list|,
name|void
operator|*
name|arg
argument_list|)
block|{
name|struct
name|worker
modifier|*
name|worker
init|=
operator|(
expr|struct
name|worker
operator|*
operator|)
name|arg
decl_stmt|;
name|enum
name|worker_commands
name|cmd
decl_stmt|;
if|if
condition|(
name|error
operator|!=
name|NETEVENT_NOERROR
condition|)
block|{
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NETEVENT_CLOSED
condition|)
name|comm_base_exit
argument_list|(
name|worker
operator|->
name|base
argument_list|)
expr_stmt|;
else|else
name|log_info
argument_list|(
literal|"control event: %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"bad control msg length %d"
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|=
name|sldns_read_uint32
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|worker_cmd_quit
case|:
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"got control cmd quit"
argument_list|)
expr_stmt|;
name|comm_base_exit
argument_list|(
name|worker
operator|->
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|worker_cmd_stats
case|:
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"got control cmd stats"
argument_list|)
expr_stmt|;
name|server_stats_reply
argument_list|(
name|worker
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|worker_cmd_stats_noreset
case|:
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"got control cmd stats_noreset"
argument_list|)
expr_stmt|;
name|server_stats_reply
argument_list|(
name|worker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|worker_cmd_remote
case|:
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"got control cmd remote"
argument_list|)
expr_stmt|;
name|daemon_remote_exec
argument_list|(
name|worker
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_err
argument_list|(
literal|"bad command %d"
argument_list|,
operator|(
name|int
operator|)
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_decl_stmt

begin_comment
comment|/** check if a delegation is secure */
end_comment

begin_function
specifier|static
name|enum
name|sec_status
name|check_delegation_secure
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
comment|/* return smallest security status */
name|size_t
name|i
decl_stmt|;
name|enum
name|sec_status
name|sec
init|=
name|sec_status_secure
decl_stmt|;
name|enum
name|sec_status
name|s
decl_stmt|;
name|size_t
name|num
init|=
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
decl_stmt|;
comment|/* check if answer and authority are OK */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
operator|)
operator|->
name|security
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|sec
condition|)
name|sec
operator|=
name|s
expr_stmt|;
block|}
comment|/* in additional, only unchecked triggers revalidation */
for|for
control|(
name|i
operator|=
name|num
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
operator|)
operator|->
name|security
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|sec_status_unchecked
condition|)
return|return
name|s
return|;
block|}
return|return
name|sec
return|;
block|}
end_function

begin_comment
comment|/** remove nonsecure from a delegation referral additional section */
end_comment

begin_function
specifier|static
name|void
name|deleg_remove_nonsecure_additional
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
comment|/* we can simply edit it, since we are working in the scratch region */
name|size_t
name|i
decl_stmt|;
name|enum
name|sec_status
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|rrset_count
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
operator|)
operator|->
name|security
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|sec_status_secure
condition|)
block|{
name|memmove
argument_list|(
name|rep
operator|->
name|rrsets
operator|+
name|i
argument_list|,
name|rep
operator|->
name|rrsets
operator|+
name|i
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ub_packed_rrset_key
operator|*
argument_list|)
operator|*
operator|(
name|rep
operator|->
name|rrset_count
operator|-
name|i
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|ar_numrrsets
operator|--
expr_stmt|;
name|rep
operator|->
name|rrset_count
operator|--
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** answer nonrecursive query from the cache */
end_comment

begin_function
specifier|static
name|int
name|answer_norec_from_cache
parameter_list|(
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|uint16_t
name|id
parameter_list|,
name|uint16_t
name|flags
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|repinfo
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|)
block|{
comment|/* for a nonrecursive query return either: 	 * 	o an error (servfail; we try to avoid this) 	 * 	o a delegation (closest we have; this routine tries that) 	 * 	o the answer (checked by answer_from_cache)  	 * 	 * So, grab a delegation from the rrset cache.  	 * Then check if it needs validation, if so, this routine fails, 	 * so that iterator can prime and validator can verify rrsets. 	 */
name|uint16_t
name|udpsize
init|=
name|edns
operator|->
name|udp_size
decl_stmt|;
name|int
name|secure
init|=
literal|0
decl_stmt|;
name|time_t
name|timenow
init|=
operator|*
name|worker
operator|->
name|env
operator|.
name|now
decl_stmt|;
name|int
name|must_validate
init|=
operator|(
operator|!
operator|(
name|flags
operator|&
name|BIT_CD
operator|)
operator|||
name|worker
operator|->
name|env
operator|.
name|cfg
operator|->
name|ignore_cd
operator|)
operator|&&
name|worker
operator|->
name|env
operator|.
name|need_to_validate
decl_stmt|;
name|struct
name|dns_msg
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|struct
name|delegpt
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|dns_cache_find_delegation
argument_list|(
operator|&
name|worker
operator|->
name|env
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
name|qinfo
operator|->
name|qtype
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|,
name|worker
operator|->
name|scratchpad
argument_list|,
operator|&
name|msg
argument_list|,
name|timenow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
block|{
comment|/* no delegation, need to reprime */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|must_validate
condition|)
block|{
switch|switch
condition|(
name|check_delegation_secure
argument_list|(
name|msg
operator|->
name|rep
argument_list|)
condition|)
block|{
case|case
name|sec_status_unchecked
case|:
comment|/* some rrsets have not been verified yet, go and  			 * let validator do that */
return|return
literal|0
return|;
case|case
name|sec_status_bogus
case|:
comment|/* some rrsets are bogus, reply servfail */
name|edns
operator|->
name|edns_version
operator|=
name|EDNS_ADVERTISED_VERSION
expr_stmt|;
name|edns
operator|->
name|udp_size
operator|=
name|EDNS_ADVERTISED_SIZE
expr_stmt|;
name|edns
operator|->
name|ext_rcode
operator|=
literal|0
expr_stmt|;
name|edns
operator|->
name|bits
operator|&=
name|EDNS_DO
expr_stmt|;
if|if
condition|(
operator|!
name|edns_opt_inplace_reply
argument_list|(
name|edns
argument_list|,
name|worker
operator|->
name|scratchpad
argument_list|)
condition|)
return|return
literal|0
return|;
name|error_encode
argument_list|(
name|repinfo
operator|->
name|c
operator|->
name|buffer
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|,
operator|&
name|msg
operator|->
name|qinfo
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|edns
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker
operator|->
name|stats
operator|.
name|extended
condition|)
block|{
name|worker
operator|->
name|stats
operator|.
name|ans_bogus
operator|++
expr_stmt|;
name|worker
operator|->
name|stats
operator|.
name|ans_rcode
index|[
name|LDNS_RCODE_SERVFAIL
index|]
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
case|case
name|sec_status_secure
case|:
comment|/* all rrsets are secure */
comment|/* remove non-secure rrsets from the add. section*/
if|if
condition|(
name|worker
operator|->
name|env
operator|.
name|cfg
operator|->
name|val_clean_additional
condition|)
name|deleg_remove_nonsecure_additional
argument_list|(
name|msg
operator|->
name|rep
argument_list|)
expr_stmt|;
name|secure
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|sec_status_indeterminate
case|:
case|case
name|sec_status_insecure
case|:
default|default:
comment|/* not secure */
name|secure
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* return this delegation from the cache */
name|edns
operator|->
name|edns_version
operator|=
name|EDNS_ADVERTISED_VERSION
expr_stmt|;
name|edns
operator|->
name|udp_size
operator|=
name|EDNS_ADVERTISED_SIZE
expr_stmt|;
name|edns
operator|->
name|ext_rcode
operator|=
literal|0
expr_stmt|;
name|edns
operator|->
name|bits
operator|&=
name|EDNS_DO
expr_stmt|;
if|if
condition|(
operator|!
name|edns_opt_inplace_reply
argument_list|(
name|edns
argument_list|,
name|worker
operator|->
name|scratchpad
argument_list|)
condition|)
return|return
literal|0
return|;
name|msg
operator|->
name|rep
operator|->
name|flags
operator||=
name|BIT_QR
operator||
name|BIT_RA
expr_stmt|;
if|if
condition|(
operator|!
name|reply_info_answer_encode
argument_list|(
operator|&
name|msg
operator|->
name|qinfo
argument_list|,
name|msg
operator|->
name|rep
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|repinfo
operator|->
name|c
operator|->
name|buffer
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|worker
operator|->
name|scratchpad
argument_list|,
name|udpsize
argument_list|,
name|edns
argument_list|,
call|(
name|int
call|)
argument_list|(
name|edns
operator|->
name|bits
operator|&
name|EDNS_DO
argument_list|)
argument_list|,
name|secure
argument_list|)
condition|)
block|{
name|error_encode
argument_list|(
name|repinfo
operator|->
name|c
operator|->
name|buffer
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|,
operator|&
name|msg
operator|->
name|qinfo
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|edns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|worker
operator|->
name|stats
operator|.
name|extended
condition|)
block|{
if|if
condition|(
name|secure
condition|)
name|worker
operator|->
name|stats
operator|.
name|ans_secure
operator|++
expr_stmt|;
name|server_stats_insrcode
argument_list|(
operator|&
name|worker
operator|->
name|stats
argument_list|,
name|repinfo
operator|->
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** answer query from the cache */
end_comment

begin_function
specifier|static
name|int
name|answer_from_cache
parameter_list|(
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|uint16_t
name|id
parameter_list|,
name|uint16_t
name|flags
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|repinfo
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|)
block|{
name|time_t
name|timenow
init|=
operator|*
name|worker
operator|->
name|env
operator|.
name|now
decl_stmt|;
name|uint16_t
name|udpsize
init|=
name|edns
operator|->
name|udp_size
decl_stmt|;
name|int
name|secure
decl_stmt|;
name|int
name|must_validate
init|=
operator|(
operator|!
operator|(
name|flags
operator|&
name|BIT_CD
operator|)
operator|||
name|worker
operator|->
name|env
operator|.
name|cfg
operator|->
name|ignore_cd
operator|)
operator|&&
name|worker
operator|->
name|env
operator|.
name|need_to_validate
decl_stmt|;
comment|/* see if it is possible */
if|if
condition|(
name|rep
operator|->
name|ttl
operator|<
name|timenow
condition|)
block|{
comment|/* the rrsets may have been updated in the meantime. 		 * we will refetch the message format from the 		 * authoritative server  		 */
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|rrset_array_lock
argument_list|(
name|rep
operator|->
name|ref
argument_list|,
name|rep
operator|->
name|rrset_count
argument_list|,
name|timenow
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* locked and ids and ttls are OK. */
comment|/* check CNAME chain (if any) */
if|if
condition|(
name|rep
operator|->
name|an_numrrsets
operator|>
literal|0
operator|&&
operator|(
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
operator|->
name|rk
operator|.
name|type
operator|==
name|htons
argument_list|(
name|LDNS_RR_TYPE_CNAME
argument_list|)
operator|||
name|rep
operator|->
name|rrsets
index|[
literal|0
index|]
operator|->
name|rk
operator|.
name|type
operator|==
name|htons
argument_list|(
name|LDNS_RR_TYPE_DNAME
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|reply_check_cname_chain
argument_list|(
name|qinfo
argument_list|,
name|rep
argument_list|)
condition|)
block|{
comment|/* cname chain invalid, redo iterator steps */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Cache reply: cname chain broken"
argument_list|)
expr_stmt|;
name|bail_out
label|:
name|rrset_array_unlock_touch
argument_list|(
name|worker
operator|->
name|env
operator|.
name|rrset_cache
argument_list|,
name|worker
operator|->
name|scratchpad
argument_list|,
name|rep
operator|->
name|ref
argument_list|,
name|rep
operator|->
name|rrset_count
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* check security status of the cached answer */
if|if
condition|(
name|rep
operator|->
name|security
operator|==
name|sec_status_bogus
operator|&&
name|must_validate
condition|)
block|{
comment|/* BAD cached */
name|edns
operator|->
name|edns_version
operator|=
name|EDNS_ADVERTISED_VERSION
expr_stmt|;
name|edns
operator|->
name|udp_size
operator|=
name|EDNS_ADVERTISED_SIZE
expr_stmt|;
name|edns
operator|->
name|ext_rcode
operator|=
literal|0
expr_stmt|;
name|edns
operator|->
name|bits
operator|&=
name|EDNS_DO
expr_stmt|;
if|if
condition|(
operator|!
name|edns_opt_inplace_reply
argument_list|(
name|edns
argument_list|,
name|worker
operator|->
name|scratchpad
argument_list|)
condition|)
return|return
literal|0
return|;
name|error_encode
argument_list|(
name|repinfo
operator|->
name|c
operator|->
name|buffer
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|,
name|qinfo
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|edns
argument_list|)
expr_stmt|;
name|rrset_array_unlock_touch
argument_list|(
name|worker
operator|->
name|env
operator|.
name|rrset_cache
argument_list|,
name|worker
operator|->
name|scratchpad
argument_list|,
name|rep
operator|->
name|ref
argument_list|,
name|rep
operator|->
name|rrset_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker
operator|->
name|stats
operator|.
name|extended
condition|)
block|{
name|worker
operator|->
name|stats
operator|.
name|ans_bogus
operator|++
expr_stmt|;
name|worker
operator|->
name|stats
operator|.
name|ans_rcode
index|[
name|LDNS_RCODE_SERVFAIL
index|]
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rep
operator|->
name|security
operator|==
name|sec_status_unchecked
operator|&&
name|must_validate
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Cache reply: unchecked entry needs "
literal|"validation"
argument_list|)
expr_stmt|;
goto|goto
name|bail_out
goto|;
comment|/* need to validate cache entry first */
block|}
elseif|else
if|if
condition|(
name|rep
operator|->
name|security
operator|==
name|sec_status_secure
condition|)
block|{
if|if
condition|(
name|reply_all_rrsets_secure
argument_list|(
name|rep
argument_list|)
condition|)
name|secure
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|must_validate
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"Cache reply: secure entry"
literal|" changed status"
argument_list|)
expr_stmt|;
goto|goto
name|bail_out
goto|;
comment|/* rrset changed, re-verify */
block|}
name|secure
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|secure
operator|=
literal|0
expr_stmt|;
name|edns
operator|->
name|edns_version
operator|=
name|EDNS_ADVERTISED_VERSION
expr_stmt|;
name|edns
operator|->
name|udp_size
operator|=
name|EDNS_ADVERTISED_SIZE
expr_stmt|;
name|edns
operator|->
name|ext_rcode
operator|=
literal|0
expr_stmt|;
name|edns
operator|->
name|bits
operator|&=
name|EDNS_DO
expr_stmt|;
if|if
condition|(
operator|!
name|edns_opt_inplace_reply
argument_list|(
name|edns
argument_list|,
name|worker
operator|->
name|scratchpad
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|reply_info_answer_encode
argument_list|(
name|qinfo
argument_list|,
name|rep
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|repinfo
operator|->
name|c
operator|->
name|buffer
argument_list|,
name|timenow
argument_list|,
literal|1
argument_list|,
name|worker
operator|->
name|scratchpad
argument_list|,
name|udpsize
argument_list|,
name|edns
argument_list|,
call|(
name|int
call|)
argument_list|(
name|edns
operator|->
name|bits
operator|&
name|EDNS_DO
argument_list|)
argument_list|,
name|secure
argument_list|)
condition|)
block|{
name|error_encode
argument_list|(
name|repinfo
operator|->
name|c
operator|->
name|buffer
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|,
name|qinfo
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|edns
argument_list|)
expr_stmt|;
block|}
comment|/* cannot send the reply right now, because blocking network syscall 	 * is bad while holding locks. */
name|rrset_array_unlock_touch
argument_list|(
name|worker
operator|->
name|env
operator|.
name|rrset_cache
argument_list|,
name|worker
operator|->
name|scratchpad
argument_list|,
name|rep
operator|->
name|ref
argument_list|,
name|rep
operator|->
name|rrset_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker
operator|->
name|stats
operator|.
name|extended
condition|)
block|{
if|if
condition|(
name|secure
condition|)
name|worker
operator|->
name|stats
operator|.
name|ans_secure
operator|++
expr_stmt|;
name|server_stats_insrcode
argument_list|(
operator|&
name|worker
operator|->
name|stats
argument_list|,
name|repinfo
operator|->
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
comment|/* go and return this buffer to the client */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** Reply to client and perform prefetch to keep cache up to date */
end_comment

begin_function
specifier|static
name|void
name|reply_and_prefetch
parameter_list|(
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|uint16_t
name|flags
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|repinfo
parameter_list|,
name|time_t
name|leeway
parameter_list|)
block|{
comment|/* first send answer to client to keep its latency  	 * as small as a cachereply */
name|comm_point_send_reply
argument_list|(
name|repinfo
argument_list|)
expr_stmt|;
name|server_stats_prefetch
argument_list|(
operator|&
name|worker
operator|->
name|stats
argument_list|,
name|worker
argument_list|)
expr_stmt|;
comment|/* create the prefetch in the mesh as a normal lookup without 	 * client addrs waiting, which has the cache blacklisted (to bypass 	 * the cache and go to the network for the data). */
comment|/* this (potentially) runs the mesh for the new query */
name|mesh_new_prefetch
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
argument_list|,
name|qinfo
argument_list|,
name|flags
argument_list|,
name|leeway
operator|+
name|PREFETCH_EXPIRY_ADD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Fill CH class answer into buffer. Keeps query.  * @param pkt: buffer  * @param str: string to put into text record (<255).  * @param edns: edns reply information.  * @param worker: worker with scratch region.  */
end_comment

begin_function
specifier|static
name|void
name|chaos_replystr
parameter_list|(
name|sldns_buffer
modifier|*
name|pkt
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|rd
init|=
name|LDNS_RD_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|cd
init|=
name|LDNS_CD_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|255
condition|)
name|len
operator|=
literal|255
expr_stmt|;
comment|/* cap size of TXT record */
name|sldns_buffer_clear
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|sldns_buffer_skip
argument_list|(
name|pkt
argument_list|,
operator|(
name|ssize_t
operator|)
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* skip id */
name|sldns_buffer_write_u16
argument_list|(
name|pkt
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|BIT_QR
operator||
name|BIT_RA
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
condition|)
name|LDNS_RD_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
condition|)
name|LDNS_CD_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|pkt
argument_list|)
argument_list|)
expr_stmt|;
name|sldns_buffer_write_u16
argument_list|(
name|pkt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* qdcount */
name|sldns_buffer_write_u16
argument_list|(
name|pkt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ancount */
name|sldns_buffer_write_u16
argument_list|(
name|pkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* nscount */
name|sldns_buffer_write_u16
argument_list|(
name|pkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* arcount */
operator|(
name|void
operator|)
name|query_dname_len
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* skip qname */
name|sldns_buffer_skip
argument_list|(
name|pkt
argument_list|,
operator|(
name|ssize_t
operator|)
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* skip qtype */
name|sldns_buffer_skip
argument_list|(
name|pkt
argument_list|,
operator|(
name|ssize_t
operator|)
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* skip qclass */
name|sldns_buffer_write_u16
argument_list|(
name|pkt
argument_list|,
literal|0xc00c
argument_list|)
expr_stmt|;
comment|/* compr ptr to query */
name|sldns_buffer_write_u16
argument_list|(
name|pkt
argument_list|,
name|LDNS_RR_TYPE_TXT
argument_list|)
expr_stmt|;
name|sldns_buffer_write_u16
argument_list|(
name|pkt
argument_list|,
name|LDNS_RR_CLASS_CH
argument_list|)
expr_stmt|;
name|sldns_buffer_write_u32
argument_list|(
name|pkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* TTL */
name|sldns_buffer_write_u16
argument_list|(
name|pkt
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
name|sldns_buffer_write_u8
argument_list|(
name|pkt
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sldns_buffer_write
argument_list|(
name|pkt
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sldns_buffer_flip
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|edns
operator|->
name|edns_version
operator|=
name|EDNS_ADVERTISED_VERSION
expr_stmt|;
name|edns
operator|->
name|udp_size
operator|=
name|EDNS_ADVERTISED_SIZE
expr_stmt|;
name|edns
operator|->
name|bits
operator|&=
name|EDNS_DO
expr_stmt|;
if|if
condition|(
operator|!
name|edns_opt_inplace_reply
argument_list|(
name|edns
argument_list|,
name|worker
operator|->
name|scratchpad
argument_list|)
condition|)
name|edns
operator|->
name|opt_list
operator|=
name|NULL
expr_stmt|;
name|attach_edns_record
argument_list|(
name|pkt
argument_list|,
name|edns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Answer CH class queries.  * @param w: worker  * @param qinfo: query info. Pointer into packet buffer.  * @param edns: edns info from query.  * @param pkt: packet buffer.  * @return: true if a reply is to be sent.  */
end_comment

begin_function
specifier|static
name|int
name|answer_chaos
parameter_list|(
name|struct
name|worker
modifier|*
name|w
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|edns_data
modifier|*
name|edns
parameter_list|,
name|sldns_buffer
modifier|*
name|pkt
parameter_list|)
block|{
name|struct
name|config_file
modifier|*
name|cfg
init|=
name|w
operator|->
name|env
operator|.
name|cfg
decl_stmt|;
if|if
condition|(
name|qinfo
operator|->
name|qtype
operator|!=
name|LDNS_RR_TYPE_ANY
operator|&&
name|qinfo
operator|->
name|qtype
operator|!=
name|LDNS_RR_TYPE_TXT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|query_dname_compare
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
literal|"\002id\006server"
argument_list|)
operator|==
literal|0
operator|||
name|query_dname_compare
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
literal|"\010hostname\004bind"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cfg
operator|->
name|hide_identity
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cfg
operator|->
name|identity
operator|==
name|NULL
operator|||
name|cfg
operator|->
name|identity
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
name|MAXHOSTNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|buf
argument_list|,
name|MAXHOSTNAMELEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|buf
index|[
name|MAXHOSTNAMELEN
index|]
operator|=
literal|0
expr_stmt|;
name|chaos_replystr
argument_list|(
name|pkt
argument_list|,
name|buf
argument_list|,
name|edns
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_err
argument_list|(
literal|"gethostname: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|chaos_replystr
argument_list|(
name|pkt
argument_list|,
literal|"no hostname"
argument_list|,
name|edns
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|chaos_replystr
argument_list|(
name|pkt
argument_list|,
name|cfg
operator|->
name|identity
argument_list|,
name|edns
argument_list|,
name|w
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|query_dname_compare
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
literal|"\007version\006server"
argument_list|)
operator|==
literal|0
operator|||
name|query_dname_compare
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
literal|"\007version\004bind"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cfg
operator|->
name|hide_version
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cfg
operator|->
name|version
operator|==
name|NULL
operator|||
name|cfg
operator|->
name|version
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|chaos_replystr
argument_list|(
name|pkt
argument_list|,
name|PACKAGE_STRING
argument_list|,
name|edns
argument_list|,
name|w
argument_list|)
expr_stmt|;
else|else
name|chaos_replystr
argument_list|(
name|pkt
argument_list|,
name|cfg
operator|->
name|version
argument_list|,
name|edns
argument_list|,
name|w
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|deny_refuse
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|enum
name|acl_access
name|acl
parameter_list|,
name|enum
name|acl_access
name|deny
parameter_list|,
name|enum
name|acl_access
name|refuse
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|repinfo
parameter_list|)
block|{
if|if
condition|(
name|acl
operator|==
name|deny
condition|)
block|{
name|comm_point_drop_reply
argument_list|(
name|repinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker
operator|->
name|stats
operator|.
name|extended
condition|)
name|worker
operator|->
name|stats
operator|.
name|unwanted_queries
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|acl
operator|==
name|refuse
condition|)
block|{
name|log_addr
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"refused query from"
argument_list|,
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|log_buf
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"refuse"
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker
operator|->
name|stats
operator|.
name|extended
condition|)
name|worker
operator|->
name|stats
operator|.
name|unwanted_queries
operator|++
expr_stmt|;
if|if
condition|(
name|worker_check_request
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|worker
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|comm_point_drop_reply
argument_list|(
name|repinfo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* discard this */
block|}
name|sldns_buffer_set_limit
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|LDNS_HEADER_SIZE
argument_list|)
expr_stmt|;
name|sldns_buffer_write_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|4
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
literal|"\0\0\0\0\0\0\0\0"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|LDNS_QR_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|LDNS_RCODE_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
name|LDNS_RCODE_REFUSED
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|deny_refuse_all
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|enum
name|acl_access
name|acl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|repinfo
parameter_list|)
block|{
return|return
name|deny_refuse
argument_list|(
name|c
argument_list|,
name|acl
argument_list|,
name|acl_deny
argument_list|,
name|acl_refuse
argument_list|,
name|worker
argument_list|,
name|repinfo
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|deny_refuse_non_local
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|enum
name|acl_access
name|acl
parameter_list|,
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|repinfo
parameter_list|)
block|{
return|return
name|deny_refuse
argument_list|(
name|c
argument_list|,
name|acl
argument_list|,
name|acl_deny_non_local
argument_list|,
name|acl_refuse_non_local
argument_list|,
name|worker
argument_list|,
name|repinfo
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|worker_handle_request
parameter_list|(
name|struct
name|comm_point
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|error
parameter_list|,
name|struct
name|comm_reply
modifier|*
name|repinfo
parameter_list|)
block|{
name|struct
name|worker
modifier|*
name|worker
init|=
operator|(
expr|struct
name|worker
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|hashvalue_t
name|h
decl_stmt|;
name|struct
name|lruhash_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|query_info
name|qinfo
decl_stmt|;
name|struct
name|edns_data
name|edns
decl_stmt|;
name|enum
name|acl_access
name|acl
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|error
operator|!=
name|NETEVENT_NOERROR
condition|)
block|{
comment|/* some bad tcp query DNS formats give these error calls */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"handle request called with err=%d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|USE_DNSTAP
if|if
condition|(
name|worker
operator|->
name|dtenv
operator|.
name|log_client_query_messages
condition|)
name|dt_msg_send_client_query
argument_list|(
operator|&
name|worker
operator|->
name|dtenv
argument_list|,
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|c
operator|->
name|type
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|acl
operator|=
name|acl_list_lookup
argument_list|(
name|worker
operator|->
name|daemon
operator|->
name|acl
argument_list|,
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|deny_refuse_all
argument_list|(
name|c
argument_list|,
name|acl
argument_list|,
name|worker
argument_list|,
name|repinfo
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
goto|goto
name|send_reply
goto|;
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|worker_check_request
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|worker
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"worker check request: bad query."
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
name|VERB_CLIENT
argument_list|,
literal|"from"
argument_list|,
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
block|{
name|LDNS_QR_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|LDNS_RCODE_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|comm_point_drop_reply
argument_list|(
name|repinfo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|worker
operator|->
name|stats
operator|.
name|num_queries
operator|++
expr_stmt|;
comment|/* see if query is in the cache */
if|if
condition|(
operator|!
name|query_info_parse
argument_list|(
operator|&
name|qinfo
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"worker parse request: formerror."
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
name|VERB_CLIENT
argument_list|,
literal|"from"
argument_list|,
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker_err_ratelimit
argument_list|(
name|worker
argument_list|,
name|LDNS_RCODE_FORMERR
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|comm_point_drop_reply
argument_list|(
name|repinfo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sldns_buffer_rewind
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|LDNS_QR_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|LDNS_RCODE_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
name|LDNS_RCODE_FORMERR
argument_list|)
expr_stmt|;
name|server_stats_insrcode
argument_list|(
operator|&
name|worker
operator|->
name|stats
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
goto|goto
name|send_reply
goto|;
block|}
if|if
condition|(
name|worker
operator|->
name|env
operator|.
name|cfg
operator|->
name|log_queries
condition|)
block|{
name|char
name|ip
index|[
literal|128
index|]
decl_stmt|;
name|addr_to_str
argument_list|(
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|,
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|log_nametypeclass
argument_list|(
literal|0
argument_list|,
name|ip
argument_list|,
name|qinfo
operator|.
name|qname
argument_list|,
name|qinfo
operator|.
name|qtype
argument_list|,
name|qinfo
operator|.
name|qclass
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_AXFR
operator|||
name|qinfo
operator|.
name|qtype
operator|==
name|LDNS_RR_TYPE_IXFR
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"worker request: refused zone transfer."
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
name|VERB_CLIENT
argument_list|,
literal|"from"
argument_list|,
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|sldns_buffer_rewind
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|LDNS_QR_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|LDNS_RCODE_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
name|LDNS_RCODE_REFUSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker
operator|->
name|stats
operator|.
name|extended
condition|)
block|{
name|worker
operator|->
name|stats
operator|.
name|qtype
index|[
name|qinfo
operator|.
name|qtype
index|]
operator|++
expr_stmt|;
name|server_stats_insrcode
argument_list|(
operator|&
name|worker
operator|->
name|stats
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
goto|goto
name|send_reply
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|parse_edns_from_pkt
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
operator|&
name|edns
argument_list|,
name|worker
operator|->
name|scratchpad
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|edns_data
name|reply_edns
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"worker parse edns: formerror."
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
name|VERB_CLIENT
argument_list|,
literal|"from"
argument_list|,
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|reply_edns
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reply_edns
argument_list|)
argument_list|)
expr_stmt|;
name|reply_edns
operator|.
name|edns_present
operator|=
literal|1
expr_stmt|;
name|reply_edns
operator|.
name|udp_size
operator|=
name|EDNS_ADVERTISED_SIZE
expr_stmt|;
name|LDNS_RCODE_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|error_encode
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|ret
argument_list|,
operator|&
name|qinfo
argument_list|,
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
name|sldns_buffer_read_u16_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|reply_edns
argument_list|)
expr_stmt|;
name|regional_free_all
argument_list|(
name|worker
operator|->
name|scratchpad
argument_list|)
expr_stmt|;
name|server_stats_insrcode
argument_list|(
operator|&
name|worker
operator|->
name|stats
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
goto|goto
name|send_reply
goto|;
block|}
if|if
condition|(
name|edns
operator|.
name|edns_present
operator|&&
name|edns
operator|.
name|edns_version
operator|!=
literal|0
condition|)
block|{
name|edns
operator|.
name|ext_rcode
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|EDNS_RCODE_BADVERS
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|edns
operator|.
name|edns_version
operator|=
name|EDNS_ADVERTISED_VERSION
expr_stmt|;
name|edns
operator|.
name|udp_size
operator|=
name|EDNS_ADVERTISED_SIZE
expr_stmt|;
name|edns
operator|.
name|bits
operator|&=
name|EDNS_DO
expr_stmt|;
name|edns
operator|.
name|opt_list
operator|=
name|NULL
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"query with bad edns version."
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
name|VERB_CLIENT
argument_list|,
literal|"from"
argument_list|,
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|error_encode
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|EDNS_RCODE_BADVERS
operator|&
literal|0xf
argument_list|,
operator|&
name|qinfo
argument_list|,
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
name|sldns_buffer_read_u16_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|2
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|attach_edns_record
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
operator|&
name|edns
argument_list|)
expr_stmt|;
name|regional_free_all
argument_list|(
name|worker
operator|->
name|scratchpad
argument_list|)
expr_stmt|;
goto|goto
name|send_reply
goto|;
block|}
if|if
condition|(
name|edns
operator|.
name|edns_present
operator|&&
name|edns
operator|.
name|udp_size
operator|<
name|NORMAL_UDP_SIZE
operator|&&
name|worker
operator|->
name|daemon
operator|->
name|cfg
operator|->
name|harden_short_bufsize
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"worker request: EDNS bufsize %d ignored"
argument_list|,
operator|(
name|int
operator|)
name|edns
operator|.
name|udp_size
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
name|VERB_CLIENT
argument_list|,
literal|"from"
argument_list|,
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|edns
operator|.
name|udp_size
operator|=
name|NORMAL_UDP_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|edns
operator|.
name|udp_size
operator|>
name|worker
operator|->
name|daemon
operator|->
name|cfg
operator|->
name|max_udp_size
operator|&&
name|c
operator|->
name|type
operator|==
name|comm_udp
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"worker request: max UDP reply size modified"
literal|" (%d to max-udp-size)"
argument_list|,
operator|(
name|int
operator|)
name|edns
operator|.
name|udp_size
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
name|VERB_CLIENT
argument_list|,
literal|"from"
argument_list|,
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|edns
operator|.
name|udp_size
operator|=
name|worker
operator|->
name|daemon
operator|->
name|cfg
operator|->
name|max_udp_size
expr_stmt|;
block|}
if|if
condition|(
name|edns
operator|.
name|udp_size
operator|<
name|LDNS_HEADER_SIZE
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"worker request: edns is too small."
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
name|VERB_CLIENT
argument_list|,
literal|"from"
argument_list|,
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|)
expr_stmt|;
name|LDNS_QR_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|LDNS_TC_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|LDNS_RCODE_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
name|LDNS_RCODE_SERVFAIL
argument_list|)
expr_stmt|;
name|sldns_buffer_set_position
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|LDNS_HEADER_SIZE
argument_list|)
expr_stmt|;
name|sldns_buffer_write_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|4
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
literal|"\0\0\0\0\0\0\0\0"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|sldns_buffer_flip
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|regional_free_all
argument_list|(
name|worker
operator|->
name|scratchpad
argument_list|)
expr_stmt|;
goto|goto
name|send_reply
goto|;
block|}
if|if
condition|(
name|worker
operator|->
name|stats
operator|.
name|extended
condition|)
name|server_stats_insquery
argument_list|(
operator|&
name|worker
operator|->
name|stats
argument_list|,
name|c
argument_list|,
name|qinfo
operator|.
name|qtype
argument_list|,
name|qinfo
operator|.
name|qclass
argument_list|,
operator|&
name|edns
argument_list|,
name|repinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|comm_udp
condition|)
name|edns
operator|.
name|udp_size
operator|=
literal|65535
expr_stmt|;
comment|/* max size for TCP replies */
if|if
condition|(
name|qinfo
operator|.
name|qclass
operator|==
name|LDNS_RR_CLASS_CH
operator|&&
name|answer_chaos
argument_list|(
name|worker
argument_list|,
operator|&
name|qinfo
argument_list|,
operator|&
name|edns
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|server_stats_insrcode
argument_list|(
operator|&
name|worker
operator|->
name|stats
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|regional_free_all
argument_list|(
name|worker
operator|->
name|scratchpad
argument_list|)
expr_stmt|;
goto|goto
name|send_reply
goto|;
block|}
if|if
condition|(
name|local_zones_answer
argument_list|(
name|worker
operator|->
name|daemon
operator|->
name|local_zones
argument_list|,
operator|&
name|qinfo
argument_list|,
operator|&
name|edns
argument_list|,
name|c
operator|->
name|buffer
argument_list|,
name|worker
operator|->
name|scratchpad
argument_list|,
name|repinfo
argument_list|)
condition|)
block|{
name|regional_free_all
argument_list|(
name|worker
operator|->
name|scratchpad
argument_list|)
expr_stmt|;
if|if
condition|(
name|sldns_buffer_limit
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|comm_point_drop_reply
argument_list|(
name|repinfo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|server_stats_insrcode
argument_list|(
operator|&
name|worker
operator|->
name|stats
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
goto|goto
name|send_reply
goto|;
block|}
comment|/* We've looked in our local zones. If the answer isn't there, we 	 * might need to bail out based on ACLs now. */
if|if
condition|(
operator|(
name|ret
operator|=
name|deny_refuse_non_local
argument_list|(
name|c
argument_list|,
name|acl
argument_list|,
name|worker
argument_list|,
name|repinfo
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|regional_free_all
argument_list|(
name|worker
operator|->
name|scratchpad
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
goto|goto
name|send_reply
goto|;
return|return
name|ret
return|;
block|}
comment|/* If this request does not have the recursion bit set, verify 	 * ACLs allow the snooping. */
if|if
condition|(
operator|!
operator|(
name|LDNS_RD_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
operator|)
operator|&&
name|acl
operator|!=
name|acl_allow_snoop
condition|)
block|{
name|sldns_buffer_set_limit
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
name|LDNS_HEADER_SIZE
argument_list|)
expr_stmt|;
name|sldns_buffer_write_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|4
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
literal|"\0\0\0\0\0\0\0\0"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|LDNS_QR_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|LDNS_RCODE_SET
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
name|LDNS_RCODE_REFUSED
argument_list|)
expr_stmt|;
name|sldns_buffer_flip
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|regional_free_all
argument_list|(
name|worker
operator|->
name|scratchpad
argument_list|)
expr_stmt|;
name|server_stats_insrcode
argument_list|(
operator|&
name|worker
operator|->
name|stats
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|log_addr
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"refused nonrec (cache snoop) query from"
argument_list|,
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|)
expr_stmt|;
goto|goto
name|send_reply
goto|;
block|}
name|h
operator|=
name|query_info_hash
argument_list|(
operator|&
name|qinfo
argument_list|,
name|sldns_buffer_read_u16_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|slabhash_lookup
argument_list|(
name|worker
operator|->
name|env
operator|.
name|msg_cache
argument_list|,
name|h
argument_list|,
operator|&
name|qinfo
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
comment|/* answer from cache - we have acquired a readlock on it */
if|if
condition|(
name|answer_from_cache
argument_list|(
name|worker
argument_list|,
operator|&
name|qinfo
argument_list|,
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|e
operator|->
name|data
argument_list|,
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
name|sldns_buffer_read_u16_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|2
argument_list|)
argument_list|,
name|repinfo
argument_list|,
operator|&
name|edns
argument_list|)
condition|)
block|{
comment|/* prefetch it if the prefetch TTL expired */
if|if
condition|(
name|worker
operator|->
name|env
operator|.
name|cfg
operator|->
name|prefetch
operator|&&
operator|*
name|worker
operator|->
name|env
operator|.
name|now
operator|>=
operator|(
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|e
operator|->
name|data
operator|)
operator|->
name|prefetch_ttl
condition|)
block|{
name|time_t
name|leeway
init|=
operator|(
operator|(
expr|struct
name|reply_info
operator|*
operator|)
name|e
operator|->
name|data
operator|)
operator|->
name|ttl
operator|-
operator|*
name|worker
operator|->
name|env
operator|.
name|now
decl_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
name|reply_and_prefetch
argument_list|(
name|worker
argument_list|,
operator|&
name|qinfo
argument_list|,
name|sldns_buffer_read_u16_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|2
argument_list|)
argument_list|,
name|repinfo
argument_list|,
name|leeway
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|regional_free_all
argument_list|(
name|worker
operator|->
name|scratchpad
argument_list|)
expr_stmt|;
goto|goto
name|send_reply_rc
goto|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
name|regional_free_all
argument_list|(
name|worker
operator|->
name|scratchpad
argument_list|)
expr_stmt|;
goto|goto
name|send_reply
goto|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"answer from the cache failed"
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|LDNS_RD_WIRE
argument_list|(
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|answer_norec_from_cache
argument_list|(
name|worker
argument_list|,
operator|&
name|qinfo
argument_list|,
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|,
name|sldns_buffer_read_u16_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|2
argument_list|)
argument_list|,
name|repinfo
argument_list|,
operator|&
name|edns
argument_list|)
condition|)
block|{
name|regional_free_all
argument_list|(
name|worker
operator|->
name|scratchpad
argument_list|)
expr_stmt|;
goto|goto
name|send_reply
goto|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"answer norec from cache -- "
literal|"need to validate or not primed"
argument_list|)
expr_stmt|;
block|}
name|sldns_buffer_rewind
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|server_stats_querymiss
argument_list|(
operator|&
name|worker
operator|->
name|stats
argument_list|,
name|worker
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
name|VERB_CLIENT
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|comm_udp
condition|)
name|log_addr
argument_list|(
name|VERB_CLIENT
argument_list|,
literal|"udp request from"
argument_list|,
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|)
expr_stmt|;
else|else
name|log_addr
argument_list|(
name|VERB_CLIENT
argument_list|,
literal|"tcp request from"
argument_list|,
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|repinfo
operator|->
name|addrlen
argument_list|)
expr_stmt|;
block|}
comment|/* grab a work request structure for this new request */
name|mesh_new_client
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
argument_list|,
operator|&
name|qinfo
argument_list|,
name|sldns_buffer_read_u16_at
argument_list|(
name|c
operator|->
name|buffer
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|edns
argument_list|,
name|repinfo
argument_list|,
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|c
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|regional_free_all
argument_list|(
name|worker
operator|->
name|scratchpad
argument_list|)
expr_stmt|;
name|worker_mem_report
argument_list|(
name|worker
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|send_reply
label|:
name|rc
operator|=
literal|1
expr_stmt|;
name|send_reply_rc
label|:
ifdef|#
directive|ifdef
name|USE_DNSTAP
if|if
condition|(
name|worker
operator|->
name|dtenv
operator|.
name|log_client_response_messages
condition|)
name|dt_msg_send_client_response
argument_list|(
operator|&
name|worker
operator|->
name|dtenv
argument_list|,
operator|&
name|repinfo
operator|->
name|addr
argument_list|,
name|c
operator|->
name|type
argument_list|,
name|c
operator|->
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|worker_sighandler
parameter_list|(
name|int
name|sig
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* note that log, print, syscalls here give race conditions.  	 * And cause hangups if the log-lock is held by the application. */
name|struct
name|worker
modifier|*
name|worker
init|=
operator|(
expr|struct
name|worker
operator|*
operator|)
name|arg
decl_stmt|;
switch|switch
condition|(
name|sig
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGHUP
case|case
name|SIGHUP
case|:
name|comm_base_exit
argument_list|(
name|worker
operator|->
name|base
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIGINT
case|:
name|worker
operator|->
name|need_to_exit
operator|=
literal|1
expr_stmt|;
name|comm_base_exit
argument_list|(
name|worker
operator|->
name|base
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SIGQUIT
case|case
name|SIGQUIT
case|:
name|worker
operator|->
name|need_to_exit
operator|=
literal|1
expr_stmt|;
name|comm_base_exit
argument_list|(
name|worker
operator|->
name|base
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIGTERM
case|:
name|worker
operator|->
name|need_to_exit
operator|=
literal|1
expr_stmt|;
name|comm_base_exit
argument_list|(
name|worker
operator|->
name|base
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* unknown signal, ignored */
break|break;
block|}
block|}
end_function

begin_comment
comment|/** restart statistics timer for worker, if enabled */
end_comment

begin_function
specifier|static
name|void
name|worker_restart_timer
parameter_list|(
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
if|if
condition|(
name|worker
operator|->
name|env
operator|.
name|cfg
operator|->
name|stat_interval
operator|>
literal|0
condition|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|tv
operator|.
name|tv_sec
operator|=
name|worker
operator|->
name|env
operator|.
name|cfg
operator|->
name|stat_interval
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|comm_timer_set
argument_list|(
name|worker
operator|->
name|stat_timer
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|worker_stat_timer_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|worker
modifier|*
name|worker
init|=
operator|(
expr|struct
name|worker
operator|*
operator|)
name|arg
decl_stmt|;
name|server_stats_log
argument_list|(
operator|&
name|worker
operator|->
name|stats
argument_list|,
name|worker
argument_list|,
name|worker
operator|->
name|thread_num
argument_list|)
expr_stmt|;
name|mesh_stats
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
argument_list|,
literal|"mesh has"
argument_list|)
expr_stmt|;
name|worker_mem_report
argument_list|(
name|worker
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|worker
operator|->
name|daemon
operator|->
name|cfg
operator|->
name|stat_cumulative
condition|)
block|{
name|worker_stats_clear
argument_list|(
name|worker
argument_list|)
expr_stmt|;
block|}
comment|/* start next timer */
name|worker_restart_timer
argument_list|(
name|worker
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|worker_probe_timer_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|worker
modifier|*
name|worker
init|=
operator|(
expr|struct
name|worker
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
ifndef|#
directive|ifndef
name|S_SPLINT_S
name|tv
operator|.
name|tv_sec
operator|=
operator|(
name|time_t
operator|)
name|autr_probe_timer
argument_list|(
operator|&
name|worker
operator|->
name|env
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|!=
literal|0
condition|)
name|comm_timer_set
argument_list|(
name|worker
operator|->
name|env
operator|.
name|probe_timer
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|worker
modifier|*
name|worker_create
parameter_list|(
name|struct
name|daemon
modifier|*
name|daemon
parameter_list|,
name|int
name|id
parameter_list|,
name|int
modifier|*
name|ports
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|int
name|seed
decl_stmt|;
name|struct
name|worker
modifier|*
name|worker
init|=
operator|(
expr|struct
name|worker
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|worker
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|worker
condition|)
return|return
name|NULL
return|;
name|worker
operator|->
name|numports
operator|=
name|n
expr_stmt|;
name|worker
operator|->
name|ports
operator|=
operator|(
name|int
operator|*
operator|)
name|memdup
argument_list|(
name|ports
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|worker
operator|->
name|ports
condition|)
block|{
name|free
argument_list|(
name|worker
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|worker
operator|->
name|daemon
operator|=
name|daemon
expr_stmt|;
name|worker
operator|->
name|thread_num
operator|=
name|id
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|worker
operator|->
name|cmd
operator|=
name|tube_create
argument_list|()
operator|)
condition|)
block|{
name|free
argument_list|(
name|worker
operator|->
name|ports
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|worker
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* create random state here to avoid locking trouble in RAND_bytes */
name|seed
operator|=
operator|(
name|unsigned
name|int
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
operator|^
operator|(
name|unsigned
name|int
operator|)
name|getpid
argument_list|()
operator|^
operator|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|worker
operator|->
name|thread_num
operator|)
operator|<<
literal|17
operator|)
expr_stmt|;
comment|/* shift thread_num so it does not match out pid bits */
if|if
condition|(
operator|!
operator|(
name|worker
operator|->
name|rndstate
operator|=
name|ub_initstate
argument_list|(
name|seed
argument_list|,
name|daemon
operator|->
name|rand
argument_list|)
operator|)
condition|)
block|{
name|seed
operator|=
literal|0
expr_stmt|;
name|log_err
argument_list|(
literal|"could not init random numbers."
argument_list|)
expr_stmt|;
name|tube_delete
argument_list|(
name|worker
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|worker
operator|->
name|ports
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|worker
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|seed
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_DNSTAP
if|if
condition|(
name|daemon
operator|->
name|cfg
operator|->
name|dnstap
condition|)
block|{
name|log_assert
argument_list|(
name|daemon
operator|->
name|dtenv
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|worker
operator|->
name|dtenv
argument_list|,
name|daemon
operator|->
name|dtenv
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dt_env
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dt_init
argument_list|(
operator|&
name|worker
operator|->
name|dtenv
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"dt_init failed"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|worker
return|;
block|}
end_function

begin_function
name|int
name|worker_init
parameter_list|(
name|struct
name|worker
modifier|*
name|worker
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|,
name|struct
name|listen_port
modifier|*
name|ports
parameter_list|,
name|int
name|do_sigs
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_DNSTAP
name|struct
name|dt_env
modifier|*
name|dtenv
init|=
operator|&
name|worker
operator|->
name|dtenv
decl_stmt|;
else|#
directive|else
name|void
modifier|*
name|dtenv
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|worker
operator|->
name|need_to_exit
operator|=
literal|0
expr_stmt|;
name|worker
operator|->
name|base
operator|=
name|comm_base_create
argument_list|(
name|do_sigs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|worker
operator|->
name|base
condition|)
block|{
name|log_err
argument_list|(
literal|"could not create event handling base"
argument_list|)
expr_stmt|;
name|worker_delete
argument_list|(
name|worker
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|comm_base_set_slow_accept_handlers
argument_list|(
name|worker
operator|->
name|base
argument_list|,
operator|&
name|worker_stop_accept
argument_list|,
operator|&
name|worker_start_accept
argument_list|,
name|worker
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_sigs
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGHUP
name|ub_thread_sig_unblock
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ub_thread_sig_unblock
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|ub_thread_sig_unblock
argument_list|(
name|SIGQUIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ub_thread_sig_unblock
argument_list|(
name|SIGTERM
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LIBEVENT_SIGNAL_PROBLEM
name|worker
operator|->
name|comsig
operator|=
name|comm_signal_create
argument_list|(
name|worker
operator|->
name|base
argument_list|,
name|worker_sighandler
argument_list|,
name|worker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|worker
operator|->
name|comsig
ifdef|#
directive|ifdef
name|SIGHUP
operator|||
operator|!
name|comm_signal_bind
argument_list|(
name|worker
operator|->
name|comsig
argument_list|,
name|SIGHUP
argument_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
operator|||
operator|!
name|comm_signal_bind
argument_list|(
name|worker
operator|->
name|comsig
argument_list|,
name|SIGQUIT
argument_list|)
endif|#
directive|endif
operator|||
operator|!
name|comm_signal_bind
argument_list|(
name|worker
operator|->
name|comsig
argument_list|,
name|SIGTERM
argument_list|)
operator|||
operator|!
name|comm_signal_bind
argument_list|(
name|worker
operator|->
name|comsig
argument_list|,
name|SIGINT
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"could not create signal handlers"
argument_list|)
expr_stmt|;
name|worker_delete
argument_list|(
name|worker
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* LIBEVENT_SIGNAL_PROBLEM */
if|if
condition|(
operator|!
name|daemon_remote_open_accept
argument_list|(
name|worker
operator|->
name|daemon
operator|->
name|rc
argument_list|,
name|worker
operator|->
name|daemon
operator|->
name|rc_ports
argument_list|,
name|worker
argument_list|)
condition|)
block|{
name|worker_delete
argument_list|(
name|worker
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|UB_ON_WINDOWS
name|wsvc_setup_worker
argument_list|(
name|worker
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UB_ON_WINDOWS */
block|}
else|else
block|{
comment|/* !do_sigs */
name|worker
operator|->
name|comsig
operator|=
name|NULL
expr_stmt|;
block|}
name|worker
operator|->
name|front
operator|=
name|listen_create
argument_list|(
name|worker
operator|->
name|base
argument_list|,
name|ports
argument_list|,
name|cfg
operator|->
name|msg_buffer_size
argument_list|,
operator|(
name|int
operator|)
name|cfg
operator|->
name|incoming_num_tcp
argument_list|,
name|worker
operator|->
name|daemon
operator|->
name|listen_sslctx
argument_list|,
name|dtenv
argument_list|,
name|worker_handle_request
argument_list|,
name|worker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|worker
operator|->
name|front
condition|)
block|{
name|log_err
argument_list|(
literal|"could not create listening sockets"
argument_list|)
expr_stmt|;
name|worker_delete
argument_list|(
name|worker
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|worker
operator|->
name|back
operator|=
name|outside_network_create
argument_list|(
name|worker
operator|->
name|base
argument_list|,
name|cfg
operator|->
name|msg_buffer_size
argument_list|,
operator|(
name|size_t
operator|)
name|cfg
operator|->
name|outgoing_num_ports
argument_list|,
name|cfg
operator|->
name|out_ifs
argument_list|,
name|cfg
operator|->
name|num_out_ifs
argument_list|,
name|cfg
operator|->
name|do_ip4
argument_list|,
name|cfg
operator|->
name|do_ip6
argument_list|,
name|cfg
operator|->
name|do_tcp
condition|?
name|cfg
operator|->
name|outgoing_num_tcp
else|:
literal|0
argument_list|,
name|worker
operator|->
name|daemon
operator|->
name|env
operator|->
name|infra_cache
argument_list|,
name|worker
operator|->
name|rndstate
argument_list|,
name|cfg
operator|->
name|use_caps_bits_for_id
argument_list|,
name|worker
operator|->
name|ports
argument_list|,
name|worker
operator|->
name|numports
argument_list|,
name|cfg
operator|->
name|unwanted_threshold
argument_list|,
name|cfg
operator|->
name|outgoing_tcp_mss
argument_list|,
operator|&
name|worker_alloc_cleanup
argument_list|,
name|worker
argument_list|,
name|cfg
operator|->
name|do_udp
argument_list|,
name|worker
operator|->
name|daemon
operator|->
name|connect_sslctx
argument_list|,
name|cfg
operator|->
name|delay_close
argument_list|,
name|dtenv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|worker
operator|->
name|back
condition|)
block|{
name|log_err
argument_list|(
literal|"could not create outgoing sockets"
argument_list|)
expr_stmt|;
name|worker_delete
argument_list|(
name|worker
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* start listening to commands */
if|if
condition|(
operator|!
name|tube_setup_bg_listen
argument_list|(
name|worker
operator|->
name|cmd
argument_list|,
name|worker
operator|->
name|base
argument_list|,
operator|&
name|worker_handle_control_cmd
argument_list|,
name|worker
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"could not create control compt."
argument_list|)
expr_stmt|;
name|worker_delete
argument_list|(
name|worker
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|worker
operator|->
name|stat_timer
operator|=
name|comm_timer_create
argument_list|(
name|worker
operator|->
name|base
argument_list|,
name|worker_stat_timer_cb
argument_list|,
name|worker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|worker
operator|->
name|stat_timer
condition|)
block|{
name|log_err
argument_list|(
literal|"could not create statistics timer"
argument_list|)
expr_stmt|;
block|}
comment|/* we use the msg_buffer_size as a good estimate for what the  	 * user wants for memory usage sizes */
name|worker
operator|->
name|scratchpad
operator|=
name|regional_create_custom
argument_list|(
name|cfg
operator|->
name|msg_buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|worker
operator|->
name|scratchpad
condition|)
block|{
name|log_err
argument_list|(
literal|"malloc failure"
argument_list|)
expr_stmt|;
name|worker_delete
argument_list|(
name|worker
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|server_stats_init
argument_list|(
operator|&
name|worker
operator|->
name|stats
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
name|alloc_init
argument_list|(
operator|&
name|worker
operator|->
name|alloc
argument_list|,
operator|&
name|worker
operator|->
name|daemon
operator|->
name|superalloc
argument_list|,
name|worker
operator|->
name|thread_num
argument_list|)
expr_stmt|;
name|alloc_set_id_cleanup
argument_list|(
operator|&
name|worker
operator|->
name|alloc
argument_list|,
operator|&
name|worker_alloc_cleanup
argument_list|,
name|worker
argument_list|)
expr_stmt|;
name|worker
operator|->
name|env
operator|=
operator|*
name|worker
operator|->
name|daemon
operator|->
name|env
expr_stmt|;
name|comm_base_timept
argument_list|(
name|worker
operator|->
name|base
argument_list|,
operator|&
name|worker
operator|->
name|env
operator|.
name|now
argument_list|,
operator|&
name|worker
operator|->
name|env
operator|.
name|now_tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker
operator|->
name|thread_num
operator|==
literal|0
condition|)
name|log_set_time
argument_list|(
name|worker
operator|->
name|env
operator|.
name|now
argument_list|)
expr_stmt|;
name|worker
operator|->
name|env
operator|.
name|worker
operator|=
name|worker
expr_stmt|;
name|worker
operator|->
name|env
operator|.
name|send_query
operator|=
operator|&
name|worker_send_query
expr_stmt|;
name|worker
operator|->
name|env
operator|.
name|alloc
operator|=
operator|&
name|worker
operator|->
name|alloc
expr_stmt|;
name|worker
operator|->
name|env
operator|.
name|rnd
operator|=
name|worker
operator|->
name|rndstate
expr_stmt|;
name|worker
operator|->
name|env
operator|.
name|scratch
operator|=
name|worker
operator|->
name|scratchpad
expr_stmt|;
name|worker
operator|->
name|env
operator|.
name|mesh
operator|=
name|mesh_create
argument_list|(
operator|&
name|worker
operator|->
name|daemon
operator|->
name|mods
argument_list|,
operator|&
name|worker
operator|->
name|env
argument_list|)
expr_stmt|;
name|worker
operator|->
name|env
operator|.
name|detach_subs
operator|=
operator|&
name|mesh_detach_subs
expr_stmt|;
name|worker
operator|->
name|env
operator|.
name|attach_sub
operator|=
operator|&
name|mesh_attach_sub
expr_stmt|;
name|worker
operator|->
name|env
operator|.
name|kill_sub
operator|=
operator|&
name|mesh_state_delete
expr_stmt|;
name|worker
operator|->
name|env
operator|.
name|detect_cycle
operator|=
operator|&
name|mesh_detect_cycle
expr_stmt|;
name|worker
operator|->
name|env
operator|.
name|scratch_buffer
operator|=
name|sldns_buffer_new
argument_list|(
name|cfg
operator|->
name|msg_buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|worker
operator|->
name|env
operator|.
name|fwds
operator|=
name|forwards_create
argument_list|()
operator|)
operator|||
operator|!
name|forwards_apply_cfg
argument_list|(
name|worker
operator|->
name|env
operator|.
name|fwds
argument_list|,
name|cfg
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"Could not set forward zones"
argument_list|)
expr_stmt|;
name|worker_delete
argument_list|(
name|worker
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|worker
operator|->
name|env
operator|.
name|hints
operator|=
name|hints_create
argument_list|()
operator|)
operator|||
operator|!
name|hints_apply_cfg
argument_list|(
name|worker
operator|->
name|env
operator|.
name|hints
argument_list|,
name|cfg
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"Could not set root or stub hints"
argument_list|)
expr_stmt|;
name|worker_delete
argument_list|(
name|worker
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* one probe timer per process -- if we have 5011 anchors */
if|if
condition|(
name|autr_get_num_anchors
argument_list|(
name|worker
operator|->
name|env
operator|.
name|anchors
argument_list|)
operator|>
literal|0
ifndef|#
directive|ifndef
name|THREADS_DISABLED
operator|&&
name|worker
operator|->
name|thread_num
operator|==
literal|0
endif|#
directive|endif
condition|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|worker
operator|->
name|env
operator|.
name|probe_timer
operator|=
name|comm_timer_create
argument_list|(
name|worker
operator|->
name|base
argument_list|,
name|worker_probe_timer_cb
argument_list|,
name|worker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|worker
operator|->
name|env
operator|.
name|probe_timer
condition|)
block|{
name|log_err
argument_list|(
literal|"could not create 5011-probe timer"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* let timer fire, then it can reset itself */
name|comm_timer_set
argument_list|(
name|worker
operator|->
name|env
operator|.
name|probe_timer
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|worker
operator|->
name|env
operator|.
name|mesh
operator|||
operator|!
name|worker
operator|->
name|env
operator|.
name|scratch_buffer
condition|)
block|{
name|worker_delete
argument_list|(
name|worker
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|worker_mem_report
argument_list|(
name|worker
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* if statistics enabled start timer */
if|if
condition|(
name|worker
operator|->
name|env
operator|.
name|cfg
operator|->
name|stat_interval
operator|>
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"set statistics interval %d secs"
argument_list|,
name|worker
operator|->
name|env
operator|.
name|cfg
operator|->
name|stat_interval
argument_list|)
expr_stmt|;
name|worker_restart_timer
argument_list|(
name|worker
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|worker_work
parameter_list|(
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|comm_base_dispatch
argument_list|(
name|worker
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|worker_delete
parameter_list|(
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
if|if
condition|(
operator|!
name|worker
condition|)
return|return;
if|if
condition|(
name|worker
operator|->
name|env
operator|.
name|mesh
operator|&&
name|verbosity
operator|>=
name|VERB_OPS
condition|)
block|{
name|server_stats_log
argument_list|(
operator|&
name|worker
operator|->
name|stats
argument_list|,
name|worker
argument_list|,
name|worker
operator|->
name|thread_num
argument_list|)
expr_stmt|;
name|mesh_stats
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
argument_list|,
literal|"mesh has"
argument_list|)
expr_stmt|;
name|worker_mem_report
argument_list|(
name|worker
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|outside_network_quit_prepare
argument_list|(
name|worker
operator|->
name|back
argument_list|)
expr_stmt|;
name|mesh_delete
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
argument_list|)
expr_stmt|;
name|sldns_buffer_free
argument_list|(
name|worker
operator|->
name|env
operator|.
name|scratch_buffer
argument_list|)
expr_stmt|;
name|forwards_delete
argument_list|(
name|worker
operator|->
name|env
operator|.
name|fwds
argument_list|)
expr_stmt|;
name|hints_delete
argument_list|(
name|worker
operator|->
name|env
operator|.
name|hints
argument_list|)
expr_stmt|;
name|listen_delete
argument_list|(
name|worker
operator|->
name|front
argument_list|)
expr_stmt|;
name|outside_network_delete
argument_list|(
name|worker
operator|->
name|back
argument_list|)
expr_stmt|;
name|comm_signal_delete
argument_list|(
name|worker
operator|->
name|comsig
argument_list|)
expr_stmt|;
name|tube_delete
argument_list|(
name|worker
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|comm_timer_delete
argument_list|(
name|worker
operator|->
name|stat_timer
argument_list|)
expr_stmt|;
name|comm_timer_delete
argument_list|(
name|worker
operator|->
name|env
operator|.
name|probe_timer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|worker
operator|->
name|ports
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker
operator|->
name|thread_num
operator|==
literal|0
condition|)
block|{
name|log_set_time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UB_ON_WINDOWS
name|wsvc_desetup_worker
argument_list|(
name|worker
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UB_ON_WINDOWS */
block|}
name|comm_base_delete
argument_list|(
name|worker
operator|->
name|base
argument_list|)
expr_stmt|;
name|ub_randfree
argument_list|(
name|worker
operator|->
name|rndstate
argument_list|)
expr_stmt|;
name|alloc_clear
argument_list|(
operator|&
name|worker
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|regional_destroy
argument_list|(
name|worker
operator|->
name|scratchpad
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|worker
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|outbound_entry
modifier|*
name|worker_send_query
parameter_list|(
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qnamelen
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|uint16_t
name|flags
parameter_list|,
name|int
name|dnssec
parameter_list|,
name|int
name|want_dnssec
parameter_list|,
name|int
name|nocaps
parameter_list|,
name|struct
name|edns_option
modifier|*
name|opt_list
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|uint8_t
modifier|*
name|zone
parameter_list|,
name|size_t
name|zonelen
parameter_list|,
name|struct
name|module_qstate
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|worker
modifier|*
name|worker
init|=
name|q
operator|->
name|env
operator|->
name|worker
decl_stmt|;
name|struct
name|outbound_entry
modifier|*
name|e
init|=
operator|(
expr|struct
name|outbound_entry
operator|*
operator|)
name|regional_alloc
argument_list|(
name|q
operator|->
name|region
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
name|NULL
return|;
name|e
operator|->
name|qstate
operator|=
name|q
expr_stmt|;
name|e
operator|->
name|qsent
operator|=
name|outnet_serviced_query
argument_list|(
name|worker
operator|->
name|back
argument_list|,
name|qname
argument_list|,
name|qnamelen
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|,
name|flags
argument_list|,
name|dnssec
argument_list|,
name|want_dnssec
argument_list|,
name|nocaps
argument_list|,
name|q
operator|->
name|env
operator|->
name|cfg
operator|->
name|tcp_upstream
argument_list|,
name|q
operator|->
name|env
operator|->
name|cfg
operator|->
name|ssl_upstream
argument_list|,
name|opt_list
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|zone
argument_list|,
name|zonelen
argument_list|,
name|worker_handle_service_reply
argument_list|,
name|e
argument_list|,
name|worker
operator|->
name|back
operator|->
name|udp_buff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|qsent
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|e
return|;
block|}
end_function

begin_function
name|void
name|worker_alloc_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|worker
modifier|*
name|worker
init|=
operator|(
expr|struct
name|worker
operator|*
operator|)
name|arg
decl_stmt|;
name|slabhash_clear
argument_list|(
operator|&
name|worker
operator|->
name|env
operator|.
name|rrset_cache
operator|->
name|table
argument_list|)
expr_stmt|;
name|slabhash_clear
argument_list|(
name|worker
operator|->
name|env
operator|.
name|msg_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|worker_stats_clear
parameter_list|(
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
name|server_stats_init
argument_list|(
operator|&
name|worker
operator|->
name|stats
argument_list|,
name|worker
operator|->
name|env
operator|.
name|cfg
argument_list|)
expr_stmt|;
name|mesh_stats_clear
argument_list|(
name|worker
operator|->
name|env
operator|.
name|mesh
argument_list|)
expr_stmt|;
name|worker
operator|->
name|back
operator|->
name|unwanted_replies
operator|=
literal|0
expr_stmt|;
name|worker
operator|->
name|back
operator|->
name|num_tcp_outgoing
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|worker_start_accept
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|worker
modifier|*
name|worker
init|=
operator|(
expr|struct
name|worker
operator|*
operator|)
name|arg
decl_stmt|;
name|listen_start_accept
argument_list|(
name|worker
operator|->
name|front
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker
operator|->
name|thread_num
operator|==
literal|0
condition|)
name|daemon_remote_start_accept
argument_list|(
name|worker
operator|->
name|daemon
operator|->
name|rc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|worker_stop_accept
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|worker
modifier|*
name|worker
init|=
operator|(
expr|struct
name|worker
operator|*
operator|)
name|arg
decl_stmt|;
name|listen_stop_accept
argument_list|(
name|worker
operator|->
name|front
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker
operator|->
name|thread_num
operator|==
literal|0
condition|)
name|daemon_remote_stop_accept
argument_list|(
name|worker
operator|->
name|daemon
operator|->
name|rc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* --- fake callbacks for fptr_wlist to work --- */
end_comment

begin_decl_stmt
name|struct
name|outbound_entry
modifier|*
name|libworker_send_query
argument_list|(
name|uint8_t
operator|*
name|ATTR_UNUSED
argument_list|(
name|qname
argument_list|)
argument_list|,
name|size_t
name|ATTR_UNUSED
argument_list|(
name|qnamelen
argument_list|)
argument_list|,
name|uint16_t
name|ATTR_UNUSED
argument_list|(
name|qtype
argument_list|)
argument_list|,
name|uint16_t
name|ATTR_UNUSED
argument_list|(
name|qclass
argument_list|)
argument_list|,
name|uint16_t
name|ATTR_UNUSED
argument_list|(
name|flags
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|dnssec
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|want_dnssec
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|nocaps
argument_list|)
argument_list|,
expr|struct
name|edns_option
operator|*
name|ATTR_UNUSED
argument_list|(
name|opt_list
argument_list|)
argument_list|,
expr|struct
name|sockaddr_storage
operator|*
name|ATTR_UNUSED
argument_list|(
name|addr
argument_list|)
argument_list|,
name|socklen_t
name|ATTR_UNUSED
argument_list|(
name|addrlen
argument_list|)
argument_list|,
name|uint8_t
operator|*
name|ATTR_UNUSED
argument_list|(
name|zone
argument_list|)
argument_list|,
name|size_t
name|ATTR_UNUSED
argument_list|(
name|zonelen
argument_list|)
argument_list|,
expr|struct
name|module_qstate
operator|*
name|ATTR_UNUSED
argument_list|(
name|q
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|libworker_handle_reply
argument_list|(
expr|struct
name|comm_point
operator|*
name|ATTR_UNUSED
argument_list|(
name|c
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|error
argument_list|)
argument_list|,
expr|struct
name|comm_reply
operator|*
name|ATTR_UNUSED
argument_list|(
name|reply_info
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
name|libworker_handle_service_reply
argument_list|(
expr|struct
name|comm_point
operator|*
name|ATTR_UNUSED
argument_list|(
name|c
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|error
argument_list|)
argument_list|,
expr|struct
name|comm_reply
operator|*
name|ATTR_UNUSED
argument_list|(
name|reply_info
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|libworker_handle_control_cmd
argument_list|(
expr|struct
name|tube
operator|*
name|ATTR_UNUSED
argument_list|(
name|tube
argument_list|)
argument_list|,
name|uint8_t
operator|*
name|ATTR_UNUSED
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|size_t
name|ATTR_UNUSED
argument_list|(
name|len
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|error
argument_list|)
argument_list|,
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|libworker_fg_done_cb
argument_list|(
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|rcode
argument_list|)
argument_list|,
name|sldns_buffer
operator|*
name|ATTR_UNUSED
argument_list|(
name|buf
argument_list|)
argument_list|,
expr|enum
name|sec_status
name|ATTR_UNUSED
argument_list|(
name|s
argument_list|)
argument_list|,
name|char
operator|*
name|ATTR_UNUSED
argument_list|(
name|why_bogus
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|libworker_bg_done_cb
argument_list|(
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|rcode
argument_list|)
argument_list|,
name|sldns_buffer
operator|*
name|ATTR_UNUSED
argument_list|(
name|buf
argument_list|)
argument_list|,
expr|enum
name|sec_status
name|ATTR_UNUSED
argument_list|(
name|s
argument_list|)
argument_list|,
name|char
operator|*
name|ATTR_UNUSED
argument_list|(
name|why_bogus
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|libworker_event_done_cb
argument_list|(
name|void
operator|*
name|ATTR_UNUSED
argument_list|(
name|arg
argument_list|)
argument_list|,
name|int
name|ATTR_UNUSED
argument_list|(
name|rcode
argument_list|)
argument_list|,
name|sldns_buffer
operator|*
name|ATTR_UNUSED
argument_list|(
name|buf
argument_list|)
argument_list|,
expr|enum
name|sec_status
name|ATTR_UNUSED
argument_list|(
name|s
argument_list|)
argument_list|,
name|char
operator|*
name|ATTR_UNUSED
argument_list|(
name|why_bogus
argument_list|)
argument_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|int
name|context_query_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|a
parameter_list|)
parameter_list|,
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|b
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|order_lock_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|e1
parameter_list|)
parameter_list|,
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|e2
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|codeline_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|a
parameter_list|)
parameter_list|,
specifier|const
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|b
parameter_list|)
parameter_list|)
block|{
name|log_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

