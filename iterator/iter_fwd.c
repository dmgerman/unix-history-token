begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * iterator/iter_fwd.c - iterative resolver module forward zones.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains functions to assist the iterator module.  * Keep track of forward zones and config settings.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_fwd.h"
end_include

begin_include
include|#
directive|include
file|"iterator/iter_delegpt.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"ldns/rrdef.h"
end_include

begin_include
include|#
directive|include
file|"ldns/str2wire.h"
end_include

begin_function
name|int
name|fwd_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|k1
parameter_list|,
specifier|const
name|void
modifier|*
name|k2
parameter_list|)
block|{
name|int
name|m
decl_stmt|;
name|struct
name|iter_forward_zone
modifier|*
name|n1
init|=
operator|(
expr|struct
name|iter_forward_zone
operator|*
operator|)
name|k1
decl_stmt|;
name|struct
name|iter_forward_zone
modifier|*
name|n2
init|=
operator|(
expr|struct
name|iter_forward_zone
operator|*
operator|)
name|k2
decl_stmt|;
if|if
condition|(
name|n1
operator|->
name|dclass
operator|!=
name|n2
operator|->
name|dclass
condition|)
block|{
if|if
condition|(
name|n1
operator|->
name|dclass
operator|<
name|n2
operator|->
name|dclass
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
return|return
name|dname_lab_cmp
argument_list|(
name|n1
operator|->
name|name
argument_list|,
name|n1
operator|->
name|namelabs
argument_list|,
name|n2
operator|->
name|name
argument_list|,
name|n2
operator|->
name|namelabs
argument_list|,
operator|&
name|m
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|iter_forwards
modifier|*
name|forwards_create
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|iter_forwards
modifier|*
name|fwd
init|=
operator|(
expr|struct
name|iter_forwards
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iter_forwards
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fwd
condition|)
return|return
name|NULL
return|;
return|return
name|fwd
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwd_zone_free
parameter_list|(
name|struct
name|iter_forward_zone
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
operator|!
name|n
condition|)
return|return;
name|delegpt_free_mlc
argument_list|(
name|n
operator|->
name|dp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delfwdnode
parameter_list|(
name|rbnode_t
modifier|*
name|n
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|struct
name|iter_forward_zone
modifier|*
name|node
init|=
operator|(
expr|struct
name|iter_forward_zone
operator|*
operator|)
name|n
decl_stmt|;
name|fwd_zone_free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fwd_del_tree
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|)
block|{
if|if
condition|(
name|fwd
operator|->
name|tree
condition|)
name|traverse_postorder
argument_list|(
name|fwd
operator|->
name|tree
argument_list|,
operator|&
name|delfwdnode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fwd
operator|->
name|tree
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|forwards_delete
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fwd
condition|)
return|return;
name|fwd_del_tree
argument_list|(
name|fwd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fwd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** insert info into forward structure */
end_comment

begin_function
specifier|static
name|int
name|forwards_insert_data
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|,
name|uint16_t
name|c
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nmlen
parameter_list|,
name|int
name|nmlabs
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|iter_forward_zone
modifier|*
name|node
init|=
operator|(
expr|struct
name|iter_forward_zone
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iter_forward_zone
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
name|delegpt_free_mlc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|node
operator|->
name|node
operator|.
name|key
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|dclass
operator|=
name|c
expr_stmt|;
name|node
operator|->
name|name
operator|=
name|memdup
argument_list|(
name|nm
argument_list|,
name|nmlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|name
condition|)
block|{
name|delegpt_free_mlc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|node
operator|->
name|namelen
operator|=
name|nmlen
expr_stmt|;
name|node
operator|->
name|namelabs
operator|=
name|nmlabs
expr_stmt|;
name|node
operator|->
name|dp
operator|=
name|dp
expr_stmt|;
if|if
condition|(
operator|!
name|rbtree_insert
argument_list|(
name|fwd
operator|->
name|tree
argument_list|,
operator|&
name|node
operator|->
name|node
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|257
index|]
decl_stmt|;
name|dname_str
argument_list|(
name|nm
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"duplicate forward zone %s ignored."
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|delegpt_free_mlc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** insert new info into forward structure given dp */
end_comment

begin_function
specifier|static
name|int
name|forwards_insert
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|,
name|uint16_t
name|c
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|)
block|{
return|return
name|forwards_insert_data
argument_list|(
name|fwd
argument_list|,
name|c
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|dp
operator|->
name|namelen
argument_list|,
name|dp
operator|->
name|namelabs
argument_list|,
name|dp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** initialise parent pointers in the tree */
end_comment

begin_function
specifier|static
name|void
name|fwd_init_parents
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|)
block|{
name|struct
name|iter_forward_zone
modifier|*
name|node
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|m
decl_stmt|;
name|RBTREE_FOR
argument_list|(
argument|node
argument_list|,
argument|struct iter_forward_zone*
argument_list|,
argument|fwd->tree
argument_list|)
block|{
name|node
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|prev
operator|||
name|prev
operator|->
name|dclass
operator|!=
name|node
operator|->
name|dclass
condition|)
block|{
name|prev
operator|=
name|node
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|dname_lab_cmp
argument_list|(
name|prev
operator|->
name|name
argument_list|,
name|prev
operator|->
name|namelabs
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|node
operator|->
name|namelabs
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
comment|/* we know prev is smaller */
comment|/* sort order like: . com. bla.com. zwb.com. net. */
comment|/* find the previous, or parent-parent-parent */
for|for
control|(
name|p
operator|=
name|prev
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|parent
control|)
comment|/* looking for name with few labels, a parent */
if|if
condition|(
name|p
operator|->
name|namelabs
operator|<=
name|m
condition|)
block|{
comment|/* ==: since prev matched m, this is closest*/
comment|/*<: prev matches more, but is not a parent, 				 * this one is a (grand)parent */
name|node
operator|->
name|parent
operator|=
name|p
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|node
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** set zone name */
end_comment

begin_function
specifier|static
name|struct
name|delegpt
modifier|*
name|read_fwds_name
parameter_list|(
name|struct
name|config_stub
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|delegpt
modifier|*
name|dp
decl_stmt|;
name|uint8_t
modifier|*
name|dname
decl_stmt|;
name|size_t
name|dname_len
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|name
condition|)
block|{
name|log_err
argument_list|(
literal|"forward zone without a name (use name \".\" to forward everything)"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dname
operator|=
name|sldns_str2wire_dname
argument_list|(
name|s
operator|->
name|name
argument_list|,
operator|&
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dname
condition|)
block|{
name|log_err
argument_list|(
literal|"cannot parse forward zone name %s"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|dp
operator|=
name|delegpt_create_mlc
argument_list|(
name|dname
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|dname
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|free
argument_list|(
name|dname
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
end_function

begin_comment
comment|/** set fwd host names */
end_comment

begin_function
specifier|static
name|int
name|read_fwds_host
parameter_list|(
name|struct
name|config_stub
modifier|*
name|s
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|config_strlist
modifier|*
name|p
decl_stmt|;
name|uint8_t
modifier|*
name|dname
decl_stmt|;
name|size_t
name|dname_len
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
operator|->
name|hosts
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|log_assert
argument_list|(
name|p
operator|->
name|str
argument_list|)
expr_stmt|;
name|dname
operator|=
name|sldns_str2wire_dname
argument_list|(
name|p
operator|->
name|str
argument_list|,
operator|&
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dname
condition|)
block|{
name|log_err
argument_list|(
literal|"cannot parse forward %s server name: '%s'"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|p
operator|->
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|delegpt_add_ns_mlc
argument_list|(
name|dp
argument_list|,
name|dname
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|dname
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|dname
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** set fwd server addresses */
end_comment

begin_function
specifier|static
name|int
name|read_fwds_addr
parameter_list|(
name|struct
name|config_stub
modifier|*
name|s
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|config_strlist
modifier|*
name|p
decl_stmt|;
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|socklen_t
name|addrlen
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
operator|->
name|addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|log_assert
argument_list|(
name|p
operator|->
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extstrtoaddr
argument_list|(
name|p
operator|->
name|str
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"cannot parse forward %s ip address: '%s'"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|p
operator|->
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|delegpt_add_addr_mlc
argument_list|(
name|dp
argument_list|,
operator|&
name|addr
argument_list|,
name|addrlen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** read forwards config */
end_comment

begin_function
specifier|static
name|int
name|read_forwards
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|config_stub
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|cfg
operator|->
name|forwards
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|delegpt
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dp
operator|=
name|read_fwds_name
argument_list|(
name|s
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|read_fwds_host
argument_list|(
name|s
argument_list|,
name|dp
argument_list|)
operator|||
operator|!
name|read_fwds_addr
argument_list|(
name|s
argument_list|,
name|dp
argument_list|)
condition|)
block|{
name|delegpt_free_mlc
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* set flag that parent side NS information is included. 		 * Asking a (higher up) server on the internet is not useful */
comment|/* the flag is turned off for 'forward-first' so that the 		 * last resort will ask for parent-side NS record and thus 		 * fallback to the internet name servers on a failure */
name|dp
operator|->
name|has_parent_side_NS
operator|=
operator|(
name|uint8_t
operator|)
operator|!
name|s
operator|->
name|isfirst
expr_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"Forward zone server list:"
argument_list|)
expr_stmt|;
name|delegpt_log
argument_list|(
name|VERB_QUERY
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|forwards_insert
argument_list|(
name|fwd
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|dp
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** insert a stub hole (if necessary) for stub name */
end_comment

begin_function
specifier|static
name|int
name|fwd_add_stub_hole
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|,
name|uint16_t
name|c
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|)
block|{
name|struct
name|iter_forward_zone
name|key
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
name|c
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|nm
expr_stmt|;
name|key
operator|.
name|namelabs
operator|=
name|dname_count_size_labels
argument_list|(
name|key
operator|.
name|name
argument_list|,
operator|&
name|key
operator|.
name|namelen
argument_list|)
expr_stmt|;
return|return
name|forwards_insert_data
argument_list|(
name|fwd
argument_list|,
name|key
operator|.
name|dclass
argument_list|,
name|key
operator|.
name|name
argument_list|,
name|key
operator|.
name|namelen
argument_list|,
name|key
operator|.
name|namelabs
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** make NULL entries for stubs */
end_comment

begin_function
specifier|static
name|int
name|make_stub_holes
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|config_stub
modifier|*
name|s
decl_stmt|;
name|uint8_t
modifier|*
name|dname
decl_stmt|;
name|size_t
name|dname_len
decl_stmt|;
for|for
control|(
name|s
operator|=
name|cfg
operator|->
name|stubs
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|dname
operator|=
name|sldns_str2wire_dname
argument_list|(
name|s
operator|->
name|name
argument_list|,
operator|&
name|dname_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dname
condition|)
block|{
name|log_err
argument_list|(
literal|"cannot parse stub name '%s'"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|fwd_add_stub_hole
argument_list|(
name|fwd
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|dname
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|dname
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|dname
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|forwards_apply_cfg
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|fwd_del_tree
argument_list|(
name|fwd
argument_list|)
expr_stmt|;
name|fwd
operator|->
name|tree
operator|=
name|rbtree_create
argument_list|(
name|fwd_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fwd
operator|->
name|tree
condition|)
return|return
literal|0
return|;
comment|/* read forward zones */
if|if
condition|(
operator|!
name|read_forwards
argument_list|(
name|fwd
argument_list|,
name|cfg
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|make_stub_holes
argument_list|(
name|fwd
argument_list|,
name|cfg
argument_list|)
condition|)
return|return
literal|0
return|;
name|fwd_init_parents
argument_list|(
name|fwd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|delegpt
modifier|*
name|forwards_find
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|uint16_t
name|qclass
parameter_list|)
block|{
name|rbnode_t
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|struct
name|iter_forward_zone
name|key
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
name|qclass
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|qname
expr_stmt|;
name|key
operator|.
name|namelabs
operator|=
name|dname_count_size_labels
argument_list|(
name|qname
argument_list|,
operator|&
name|key
operator|.
name|namelen
argument_list|)
expr_stmt|;
name|res
operator|=
name|rbtree_search
argument_list|(
name|fwd
operator|->
name|tree
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
return|return
operator|(
operator|(
expr|struct
name|iter_forward_zone
operator|*
operator|)
name|res
operator|)
operator|->
name|dp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|delegpt
modifier|*
name|forwards_lookup
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|uint16_t
name|qclass
parameter_list|)
block|{
comment|/* lookup the forward zone in the tree */
name|rbnode_t
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|struct
name|iter_forward_zone
modifier|*
name|result
decl_stmt|;
name|struct
name|iter_forward_zone
name|key
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
name|qclass
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|qname
expr_stmt|;
name|key
operator|.
name|namelabs
operator|=
name|dname_count_size_labels
argument_list|(
name|qname
argument_list|,
operator|&
name|key
operator|.
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtree_find_less_equal
argument_list|(
name|fwd
operator|->
name|tree
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|res
argument_list|)
condition|)
block|{
comment|/* exact */
name|result
operator|=
operator|(
expr|struct
name|iter_forward_zone
operator|*
operator|)
name|res
expr_stmt|;
block|}
else|else
block|{
comment|/* smaller element (or no element) */
name|int
name|m
decl_stmt|;
name|result
operator|=
operator|(
expr|struct
name|iter_forward_zone
operator|*
operator|)
name|res
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|||
name|result
operator|->
name|dclass
operator|!=
name|qclass
condition|)
return|return
name|NULL
return|;
comment|/* count number of labels matched */
operator|(
name|void
operator|)
name|dname_lab_cmp
argument_list|(
name|result
operator|->
name|name
argument_list|,
name|result
operator|->
name|namelabs
argument_list|,
name|key
operator|.
name|name
argument_list|,
name|key
operator|.
name|namelabs
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
condition|)
block|{
comment|/* go up until qname is subdomain of stub */
if|if
condition|(
name|result
operator|->
name|namelabs
operator|<=
name|m
condition|)
break|break;
name|result
operator|=
name|result
operator|->
name|parent
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
condition|)
return|return
name|result
operator|->
name|dp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|delegpt
modifier|*
name|forwards_lookup_root
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|,
name|uint16_t
name|qclass
parameter_list|)
block|{
name|uint8_t
name|root
init|=
literal|0
decl_stmt|;
return|return
name|forwards_lookup
argument_list|(
name|fwd
argument_list|,
operator|&
name|root
argument_list|,
name|qclass
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|forwards_next_root
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|,
name|uint16_t
modifier|*
name|dclass
parameter_list|)
block|{
name|struct
name|iter_forward_zone
name|key
decl_stmt|;
name|rbnode_t
modifier|*
name|n
decl_stmt|;
name|struct
name|iter_forward_zone
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|dclass
operator|==
literal|0
condition|)
block|{
comment|/* first root item is first item in tree */
name|n
operator|=
name|rbtree_first
argument_list|(
name|fwd
operator|->
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|RBTREE_NULL
condition|)
return|return
literal|0
return|;
name|p
operator|=
operator|(
expr|struct
name|iter_forward_zone
operator|*
operator|)
name|n
expr_stmt|;
if|if
condition|(
name|dname_is_root
argument_list|(
name|p
operator|->
name|name
argument_list|)
condition|)
block|{
operator|*
name|dclass
operator|=
name|p
operator|->
name|dclass
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* root not first item? search for higher items */
operator|*
name|dclass
operator|=
name|p
operator|->
name|dclass
operator|+
literal|1
expr_stmt|;
return|return
name|forwards_next_root
argument_list|(
name|fwd
argument_list|,
name|dclass
argument_list|)
return|;
block|}
comment|/* find class n in tree, we may get a direct hit, or if we don't 	 * this is the last item of the previous class so rbtree_next() takes 	 * us to the next root (if any) */
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|name
operator|=
operator|(
name|uint8_t
operator|*
operator|)
literal|"\000"
expr_stmt|;
name|key
operator|.
name|namelen
operator|=
literal|1
expr_stmt|;
name|key
operator|.
name|namelabs
operator|=
literal|0
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
operator|*
name|dclass
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rbtree_find_less_equal
argument_list|(
name|fwd
operator|->
name|tree
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|n
argument_list|)
condition|)
block|{
comment|/* exact */
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* smaller element */
if|if
condition|(
operator|!
name|n
operator|||
name|n
operator|==
name|RBTREE_NULL
condition|)
return|return
literal|0
return|;
comment|/* nothing found */
name|n
operator|=
name|rbtree_next
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|RBTREE_NULL
condition|)
return|return
literal|0
return|;
comment|/* no higher */
name|p
operator|=
operator|(
expr|struct
name|iter_forward_zone
operator|*
operator|)
name|n
expr_stmt|;
if|if
condition|(
name|dname_is_root
argument_list|(
name|p
operator|->
name|name
argument_list|)
condition|)
block|{
operator|*
name|dclass
operator|=
name|p
operator|->
name|dclass
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* not a root node, return next higher item */
operator|*
name|dclass
operator|=
name|p
operator|->
name|dclass
operator|+
literal|1
expr_stmt|;
return|return
name|forwards_next_root
argument_list|(
name|fwd
argument_list|,
name|dclass
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|size_t
name|forwards_get_mem
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|)
block|{
name|struct
name|iter_forward_zone
modifier|*
name|p
decl_stmt|;
name|size_t
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|fwd
condition|)
return|return
literal|0
return|;
name|s
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|fwd
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|fwd
operator|->
name|tree
argument_list|)
expr_stmt|;
name|RBTREE_FOR
argument_list|(
argument|p
argument_list|,
argument|struct iter_forward_zone*
argument_list|,
argument|fwd->tree
argument_list|)
block|{
name|s
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|+
name|p
operator|->
name|namelen
operator|+
name|delegpt_get_mem
argument_list|(
name|p
operator|->
name|dp
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|iter_forward_zone
modifier|*
name|fwd_zone_find
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|,
name|uint16_t
name|c
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|)
block|{
name|struct
name|iter_forward_zone
name|key
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
name|c
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|nm
expr_stmt|;
name|key
operator|.
name|namelabs
operator|=
name|dname_count_size_labels
argument_list|(
name|nm
argument_list|,
operator|&
name|key
operator|.
name|namelen
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|iter_forward_zone
operator|*
operator|)
name|rbtree_search
argument_list|(
name|fwd
operator|->
name|tree
argument_list|,
operator|&
name|key
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|forwards_add_zone
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|,
name|uint16_t
name|c
parameter_list|,
name|struct
name|delegpt
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|iter_forward_zone
modifier|*
name|z
decl_stmt|;
if|if
condition|(
operator|(
name|z
operator|=
name|fwd_zone_find
argument_list|(
name|fwd
argument_list|,
name|c
argument_list|,
name|dp
operator|->
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
name|fwd
operator|->
name|tree
argument_list|,
operator|&
name|z
operator|->
name|node
argument_list|)
expr_stmt|;
name|fwd_zone_free
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|forwards_insert
argument_list|(
name|fwd
argument_list|,
name|c
argument_list|,
name|dp
argument_list|)
condition|)
return|return
literal|0
return|;
name|fwd_init_parents
argument_list|(
name|fwd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|forwards_delete_zone
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|,
name|uint16_t
name|c
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|)
block|{
name|struct
name|iter_forward_zone
modifier|*
name|z
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|z
operator|=
name|fwd_zone_find
argument_list|(
name|fwd
argument_list|,
name|c
argument_list|,
name|nm
argument_list|)
operator|)
condition|)
return|return;
comment|/* nothing to do */
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
name|fwd
operator|->
name|tree
argument_list|,
operator|&
name|z
operator|->
name|node
argument_list|)
expr_stmt|;
name|fwd_zone_free
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|fwd_init_parents
argument_list|(
name|fwd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|forwards_add_stub_hole
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|,
name|uint16_t
name|c
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fwd_add_stub_hole
argument_list|(
name|fwd
argument_list|,
name|c
argument_list|,
name|nm
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|fwd_init_parents
argument_list|(
name|fwd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|forwards_delete_stub_hole
parameter_list|(
name|struct
name|iter_forwards
modifier|*
name|fwd
parameter_list|,
name|uint16_t
name|c
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|)
block|{
name|struct
name|iter_forward_zone
modifier|*
name|z
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|z
operator|=
name|fwd_zone_find
argument_list|(
name|fwd
argument_list|,
name|c
argument_list|,
name|nm
argument_list|)
operator|)
condition|)
return|return;
comment|/* nothing to do */
if|if
condition|(
name|z
operator|->
name|dp
operator|!=
name|NULL
condition|)
return|return;
comment|/* not a stub hole */
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
name|fwd
operator|->
name|tree
argument_list|,
operator|&
name|z
operator|->
name|node
argument_list|)
expr_stmt|;
name|fwd_zone_free
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|fwd_init_parents
argument_list|(
name|fwd
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

