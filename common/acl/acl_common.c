begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<acl/acl_common.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<acl_common.h>
end_include

begin_define
define|#
directive|define
name|ASSERT
value|assert
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ACE_POSIX_SUPPORTED_BITS
value|(ACE_READ_DATA | \     ACE_WRITE_DATA | ACE_APPEND_DATA | ACE_EXECUTE | \     ACE_READ_ATTRIBUTES | ACE_READ_ACL | ACE_WRITE_ACL)
end_define

begin_define
define|#
directive|define
name|ACL_SYNCHRONIZE_SET_DENY
value|0x0000001
end_define

begin_define
define|#
directive|define
name|ACL_SYNCHRONIZE_SET_ALLOW
value|0x0000002
end_define

begin_define
define|#
directive|define
name|ACL_SYNCHRONIZE_ERR_DENY
value|0x0000004
end_define

begin_define
define|#
directive|define
name|ACL_SYNCHRONIZE_ERR_ALLOW
value|0x0000008
end_define

begin_define
define|#
directive|define
name|ACL_WRITE_OWNER_SET_DENY
value|0x0000010
end_define

begin_define
define|#
directive|define
name|ACL_WRITE_OWNER_SET_ALLOW
value|0x0000020
end_define

begin_define
define|#
directive|define
name|ACL_WRITE_OWNER_ERR_DENY
value|0x0000040
end_define

begin_define
define|#
directive|define
name|ACL_WRITE_OWNER_ERR_ALLOW
value|0x0000080
end_define

begin_define
define|#
directive|define
name|ACL_DELETE_SET_DENY
value|0x0000100
end_define

begin_define
define|#
directive|define
name|ACL_DELETE_SET_ALLOW
value|0x0000200
end_define

begin_define
define|#
directive|define
name|ACL_DELETE_ERR_DENY
value|0x0000400
end_define

begin_define
define|#
directive|define
name|ACL_DELETE_ERR_ALLOW
value|0x0000800
end_define

begin_define
define|#
directive|define
name|ACL_WRITE_ATTRS_OWNER_SET_DENY
value|0x0001000
end_define

begin_define
define|#
directive|define
name|ACL_WRITE_ATTRS_OWNER_SET_ALLOW
value|0x0002000
end_define

begin_define
define|#
directive|define
name|ACL_WRITE_ATTRS_OWNER_ERR_DENY
value|0x0004000
end_define

begin_define
define|#
directive|define
name|ACL_WRITE_ATTRS_OWNER_ERR_ALLOW
value|0x0008000
end_define

begin_define
define|#
directive|define
name|ACL_WRITE_ATTRS_WRITER_SET_DENY
value|0x0010000
end_define

begin_define
define|#
directive|define
name|ACL_WRITE_ATTRS_WRITER_SET_ALLOW
value|0x0020000
end_define

begin_define
define|#
directive|define
name|ACL_WRITE_ATTRS_WRITER_ERR_DENY
value|0x0040000
end_define

begin_define
define|#
directive|define
name|ACL_WRITE_ATTRS_WRITER_ERR_ALLOW
value|0x0080000
end_define

begin_define
define|#
directive|define
name|ACL_WRITE_NAMED_WRITER_SET_DENY
value|0x0100000
end_define

begin_define
define|#
directive|define
name|ACL_WRITE_NAMED_WRITER_SET_ALLOW
value|0x0200000
end_define

begin_define
define|#
directive|define
name|ACL_WRITE_NAMED_WRITER_ERR_DENY
value|0x0400000
end_define

begin_define
define|#
directive|define
name|ACL_WRITE_NAMED_WRITER_ERR_ALLOW
value|0x0800000
end_define

begin_define
define|#
directive|define
name|ACL_READ_NAMED_READER_SET_DENY
value|0x1000000
end_define

begin_define
define|#
directive|define
name|ACL_READ_NAMED_READER_SET_ALLOW
value|0x2000000
end_define

begin_define
define|#
directive|define
name|ACL_READ_NAMED_READER_ERR_DENY
value|0x4000000
end_define

begin_define
define|#
directive|define
name|ACL_READ_NAMED_READER_ERR_ALLOW
value|0x8000000
end_define

begin_define
define|#
directive|define
name|ACE_VALID_MASK_BITS
value|(\     ACE_READ_DATA | \     ACE_LIST_DIRECTORY | \     ACE_WRITE_DATA | \     ACE_ADD_FILE | \     ACE_APPEND_DATA | \     ACE_ADD_SUBDIRECTORY | \     ACE_READ_NAMED_ATTRS | \     ACE_WRITE_NAMED_ATTRS | \     ACE_EXECUTE | \     ACE_DELETE_CHILD | \     ACE_READ_ATTRIBUTES | \     ACE_WRITE_ATTRIBUTES | \     ACE_DELETE | \     ACE_READ_ACL | \     ACE_WRITE_ACL | \     ACE_WRITE_OWNER | \     ACE_SYNCHRONIZE)
end_define

begin_define
define|#
directive|define
name|ACE_MASK_UNDEFINED
value|0x80000000
end_define

begin_define
define|#
directive|define
name|ACE_VALID_FLAG_BITS
value|(ACE_FILE_INHERIT_ACE | \     ACE_DIRECTORY_INHERIT_ACE | \     ACE_NO_PROPAGATE_INHERIT_ACE | ACE_INHERIT_ONLY_ACE | \     ACE_SUCCESSFUL_ACCESS_ACE_FLAG | ACE_FAILED_ACCESS_ACE_FLAG | \     ACE_IDENTIFIER_GROUP | ACE_OWNER | ACE_GROUP | ACE_EVERYONE)
end_define

begin_comment
comment|/*  * ACL conversion helpers  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|ace_unused
block|,
name|ace_user_obj
block|,
name|ace_user
block|,
name|ace_group
block|,
comment|/* includes GROUP and GROUP_OBJ */
name|ace_other_obj
block|}
name|ace_to_aent_state_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|acevals
block|{
name|uid_t
name|key
decl_stmt|;
name|avl_node_t
name|avl
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|uint32_t
name|allowed
decl_stmt|;
name|uint32_t
name|denied
decl_stmt|;
name|int
name|aent_type
decl_stmt|;
block|}
name|acevals_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ace_list
block|{
name|acevals_t
name|user_obj
decl_stmt|;
name|avl_tree_t
name|user
decl_stmt|;
name|int
name|numusers
decl_stmt|;
name|acevals_t
name|group_obj
decl_stmt|;
name|avl_tree_t
name|group
decl_stmt|;
name|int
name|numgroups
decl_stmt|;
name|acevals_t
name|other_obj
decl_stmt|;
name|uint32_t
name|acl_mask
decl_stmt|;
name|int
name|hasmask
decl_stmt|;
name|int
name|dfacl_flag
decl_stmt|;
name|ace_to_aent_state_t
name|state
decl_stmt|;
name|int
name|seen
decl_stmt|;
comment|/* bitmask of all aclent_t a_type values seen */
block|}
name|ace_list_t
typedef|;
end_typedef

begin_comment
comment|/*  * Generic shellsort, from K&R (1st ed, p 58.), somewhat modified.  * v = Ptr to array/vector of objs  * n = # objs in the array  * s = size of each obj (must be multiples of a word size)  * f = ptr to function to compare two objs  *	returns (-1 = less than, 0 = equal, 1 = greater than  */
end_comment

begin_function
name|void
name|ksort
parameter_list|(
name|caddr_t
name|v
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|s
parameter_list|,
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
parameter_list|)
block|{
name|int
name|g
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ii
decl_stmt|;
name|unsigned
name|int
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|unsigned
name|int
name|tmp
decl_stmt|;
comment|/* No work to do */
if|if
condition|(
name|v
operator|==
name|NULL
operator|||
name|n
operator|<=
literal|1
condition|)
return|return;
comment|/* Sanity check on arguments */
name|ASSERT
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|v
operator|&
literal|0x3
operator|)
operator|==
literal|0
operator|&&
operator|(
name|s
operator|&
literal|0x3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|s
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|g
operator|=
name|n
operator|/
literal|2
init|;
name|g
operator|>
literal|0
condition|;
name|g
operator|/=
literal|2
control|)
block|{
for|for
control|(
name|i
operator|=
name|g
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|-
name|g
init|;
name|j
operator|>=
literal|0
operator|&&
call|(
modifier|*
name|f
call|)
argument_list|(
name|v
operator|+
name|j
operator|*
name|s
argument_list|,
name|v
operator|+
operator|(
name|j
operator|+
name|g
operator|)
operator|*
name|s
argument_list|)
operator|==
literal|1
condition|;
name|j
operator|-=
name|g
control|)
block|{
name|p1
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|v
operator|+
name|j
operator|*
name|s
operator|)
expr_stmt|;
name|p2
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|v
operator|+
operator|(
name|j
operator|+
name|g
operator|)
operator|*
name|s
operator|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|s
operator|/
literal|4
condition|;
name|ii
operator|++
control|)
block|{
name|tmp
operator|=
operator|*
name|p1
expr_stmt|;
operator|*
name|p1
operator|++
operator|=
operator|*
name|p2
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Compare two acls, all fields.  Returns:  * -1 (less than)  *  0 (equal)  * +1 (greater than)  */
end_comment

begin_function
name|int
name|cmp2acls
parameter_list|(
name|void
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
block|{
name|aclent_t
modifier|*
name|x
init|=
operator|(
name|aclent_t
operator|*
operator|)
name|a
decl_stmt|;
name|aclent_t
modifier|*
name|y
init|=
operator|(
name|aclent_t
operator|*
operator|)
name|b
decl_stmt|;
comment|/* Compare types */
if|if
condition|(
name|x
operator|->
name|a_type
operator|<
name|y
operator|->
name|a_type
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|x
operator|->
name|a_type
operator|>
name|y
operator|->
name|a_type
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Equal types; compare id's */
if|if
condition|(
name|x
operator|->
name|a_id
operator|<
name|y
operator|->
name|a_id
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|x
operator|->
name|a_id
operator|>
name|y
operator|->
name|a_id
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Equal ids; compare perms */
if|if
condition|(
name|x
operator|->
name|a_perm
operator|<
name|y
operator|->
name|a_perm
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|x
operator|->
name|a_perm
operator|>
name|y
operator|->
name|a_perm
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Totally equal */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|cacl_realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|new_size
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|void
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|kmem_alloc
argument_list|(
name|new_size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|ptr
argument_list|,
operator|(
name|size
operator|<
name|new_size
operator|)
condition|?
name|size
else|:
name|new_size
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmp
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|realloc
argument_list|(
name|ptr
argument_list|,
name|new_size
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|cacl_malloc
parameter_list|(
name|void
modifier|*
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|*
name|ptr
operator|=
name|kmem_zalloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
operator|*
name|ptr
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|errno
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|cacl_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|kmem_free
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|acl_t
modifier|*
name|acl_alloc
parameter_list|(
name|enum
name|acl_type
name|type
parameter_list|)
block|{
name|acl_t
modifier|*
name|aclp
decl_stmt|;
if|if
condition|(
name|cacl_malloc
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|aclp
argument_list|,
sizeof|sizeof
argument_list|(
name|acl_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|aclp
operator|->
name|acl_aclp
operator|=
name|NULL
expr_stmt|;
name|aclp
operator|->
name|acl_cnt
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ACE_T
case|:
name|aclp
operator|->
name|acl_type
operator|=
name|ACE_T
expr_stmt|;
name|aclp
operator|->
name|acl_entry_size
operator|=
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACLENT_T
case|:
name|aclp
operator|->
name|acl_type
operator|=
name|ACLENT_T
expr_stmt|;
name|aclp
operator|->
name|acl_entry_size
operator|=
sizeof|sizeof
argument_list|(
name|aclent_t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|aclp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|aclp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free acl_t structure  */
end_comment

begin_function
name|void
name|acl_free
parameter_list|(
name|acl_t
modifier|*
name|aclp
parameter_list|)
block|{
name|int
name|acl_size
decl_stmt|;
if|if
condition|(
name|aclp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|aclp
operator|->
name|acl_aclp
condition|)
block|{
name|acl_size
operator|=
name|aclp
operator|->
name|acl_cnt
operator|*
name|aclp
operator|->
name|acl_entry_size
expr_stmt|;
name|cacl_free
argument_list|(
name|aclp
operator|->
name|acl_aclp
argument_list|,
name|acl_size
argument_list|)
expr_stmt|;
block|}
name|cacl_free
argument_list|(
name|aclp
argument_list|,
sizeof|sizeof
argument_list|(
name|acl_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|access_mask_set
parameter_list|(
name|int
name|haswriteperm
parameter_list|,
name|int
name|hasreadperm
parameter_list|,
name|int
name|isowner
parameter_list|,
name|int
name|isallow
parameter_list|)
block|{
name|uint32_t
name|access_mask
init|=
literal|0
decl_stmt|;
name|int
name|acl_produce
decl_stmt|;
name|int
name|synchronize_set
init|=
literal|0
decl_stmt|,
name|write_owner_set
init|=
literal|0
decl_stmt|;
name|int
name|delete_set
init|=
literal|0
decl_stmt|,
name|write_attrs_set
init|=
literal|0
decl_stmt|;
name|int
name|read_named_set
init|=
literal|0
decl_stmt|,
name|write_named_set
init|=
literal|0
decl_stmt|;
name|acl_produce
operator|=
operator|(
name|ACL_SYNCHRONIZE_SET_ALLOW
operator||
name|ACL_WRITE_ATTRS_OWNER_SET_ALLOW
operator||
name|ACL_WRITE_ATTRS_WRITER_SET_DENY
operator|)
expr_stmt|;
if|if
condition|(
name|isallow
condition|)
block|{
name|synchronize_set
operator|=
name|ACL_SYNCHRONIZE_SET_ALLOW
expr_stmt|;
name|write_owner_set
operator|=
name|ACL_WRITE_OWNER_SET_ALLOW
expr_stmt|;
name|delete_set
operator|=
name|ACL_DELETE_SET_ALLOW
expr_stmt|;
if|if
condition|(
name|hasreadperm
condition|)
name|read_named_set
operator|=
name|ACL_READ_NAMED_READER_SET_ALLOW
expr_stmt|;
if|if
condition|(
name|haswriteperm
condition|)
name|write_named_set
operator|=
name|ACL_WRITE_NAMED_WRITER_SET_ALLOW
expr_stmt|;
if|if
condition|(
name|isowner
condition|)
name|write_attrs_set
operator|=
name|ACL_WRITE_ATTRS_OWNER_SET_ALLOW
expr_stmt|;
elseif|else
if|if
condition|(
name|haswriteperm
condition|)
name|write_attrs_set
operator|=
name|ACL_WRITE_ATTRS_WRITER_SET_ALLOW
expr_stmt|;
block|}
else|else
block|{
name|synchronize_set
operator|=
name|ACL_SYNCHRONIZE_SET_DENY
expr_stmt|;
name|write_owner_set
operator|=
name|ACL_WRITE_OWNER_SET_DENY
expr_stmt|;
name|delete_set
operator|=
name|ACL_DELETE_SET_DENY
expr_stmt|;
if|if
condition|(
name|hasreadperm
condition|)
name|read_named_set
operator|=
name|ACL_READ_NAMED_READER_SET_DENY
expr_stmt|;
if|if
condition|(
name|haswriteperm
condition|)
name|write_named_set
operator|=
name|ACL_WRITE_NAMED_WRITER_SET_DENY
expr_stmt|;
if|if
condition|(
name|isowner
condition|)
name|write_attrs_set
operator|=
name|ACL_WRITE_ATTRS_OWNER_SET_DENY
expr_stmt|;
elseif|else
if|if
condition|(
name|haswriteperm
condition|)
name|write_attrs_set
operator|=
name|ACL_WRITE_ATTRS_WRITER_SET_DENY
expr_stmt|;
else|else
comment|/* 			 * If the entity is not the owner and does not 			 * have write permissions ACE_WRITE_ATTRIBUTES will 			 * always go in the DENY ACE. 			 */
name|access_mask
operator||=
name|ACE_WRITE_ATTRIBUTES
expr_stmt|;
block|}
if|if
condition|(
name|acl_produce
operator|&
name|synchronize_set
condition|)
name|access_mask
operator||=
name|ACE_SYNCHRONIZE
expr_stmt|;
if|if
condition|(
name|acl_produce
operator|&
name|write_owner_set
condition|)
name|access_mask
operator||=
name|ACE_WRITE_OWNER
expr_stmt|;
if|if
condition|(
name|acl_produce
operator|&
name|delete_set
condition|)
name|access_mask
operator||=
name|ACE_DELETE
expr_stmt|;
if|if
condition|(
name|acl_produce
operator|&
name|write_attrs_set
condition|)
name|access_mask
operator||=
name|ACE_WRITE_ATTRIBUTES
expr_stmt|;
if|if
condition|(
name|acl_produce
operator|&
name|read_named_set
condition|)
name|access_mask
operator||=
name|ACE_READ_NAMED_ATTRS
expr_stmt|;
if|if
condition|(
name|acl_produce
operator|&
name|write_named_set
condition|)
name|access_mask
operator||=
name|ACE_WRITE_NAMED_ATTRS
expr_stmt|;
return|return
operator|(
name|access_mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an mode_t, convert it into an access_mask as used  * by nfsace, assuming aclent_t -> nfsace semantics.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|mode_to_ace_access
parameter_list|(
name|mode_t
name|mode
parameter_list|,
name|int
name|isdir
parameter_list|,
name|int
name|isowner
parameter_list|,
name|int
name|isallow
parameter_list|)
block|{
name|uint32_t
name|access
init|=
literal|0
decl_stmt|;
name|int
name|haswriteperm
init|=
literal|0
decl_stmt|;
name|int
name|hasreadperm
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isallow
condition|)
block|{
name|haswriteperm
operator|=
operator|(
name|mode
operator|&
name|S_IWOTH
operator|)
expr_stmt|;
name|hasreadperm
operator|=
operator|(
name|mode
operator|&
name|S_IROTH
operator|)
expr_stmt|;
block|}
else|else
block|{
name|haswriteperm
operator|=
operator|!
operator|(
name|mode
operator|&
name|S_IWOTH
operator|)
expr_stmt|;
name|hasreadperm
operator|=
operator|!
operator|(
name|mode
operator|&
name|S_IROTH
operator|)
expr_stmt|;
block|}
comment|/* 	 * The following call takes care of correctly setting the following 	 * mask bits in the access_mask: 	 * ACE_SYNCHRONIZE, ACE_WRITE_OWNER, ACE_DELETE, 	 * ACE_WRITE_ATTRIBUTES, ACE_WRITE_NAMED_ATTRS, ACE_READ_NAMED_ATTRS 	 */
name|access
operator|=
name|access_mask_set
argument_list|(
name|haswriteperm
argument_list|,
name|hasreadperm
argument_list|,
name|isowner
argument_list|,
name|isallow
argument_list|)
expr_stmt|;
if|if
condition|(
name|isallow
condition|)
block|{
name|access
operator||=
name|ACE_READ_ACL
operator||
name|ACE_READ_ATTRIBUTES
expr_stmt|;
if|if
condition|(
name|isowner
condition|)
name|access
operator||=
name|ACE_WRITE_ACL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isowner
condition|)
name|access
operator||=
name|ACE_WRITE_ACL
expr_stmt|;
block|}
comment|/* read */
if|if
condition|(
name|mode
operator|&
name|S_IROTH
condition|)
block|{
name|access
operator||=
name|ACE_READ_DATA
expr_stmt|;
block|}
comment|/* write */
if|if
condition|(
name|mode
operator|&
name|S_IWOTH
condition|)
block|{
name|access
operator||=
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
expr_stmt|;
if|if
condition|(
name|isdir
condition|)
name|access
operator||=
name|ACE_DELETE_CHILD
expr_stmt|;
block|}
comment|/* exec */
if|if
condition|(
name|mode
operator|&
literal|01
condition|)
block|{
name|access
operator||=
name|ACE_EXECUTE
expr_stmt|;
block|}
return|return
operator|(
name|access
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an nfsace (presumably an ALLOW entry), make a  * corresponding DENY entry at the address given.  */
end_comment

begin_function
specifier|static
name|void
name|ace_make_deny
parameter_list|(
name|ace_t
modifier|*
name|allow
parameter_list|,
name|ace_t
modifier|*
name|deny
parameter_list|,
name|int
name|isdir
parameter_list|,
name|int
name|isowner
parameter_list|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|deny
argument_list|,
name|allow
argument_list|,
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
argument_list|)
expr_stmt|;
name|deny
operator|->
name|a_who
operator|=
name|allow
operator|->
name|a_who
expr_stmt|;
name|deny
operator|->
name|a_type
operator|=
name|ACE_ACCESS_DENIED_ACE_TYPE
expr_stmt|;
name|deny
operator|->
name|a_access_mask
operator|^=
name|ACE_POSIX_SUPPORTED_BITS
expr_stmt|;
if|if
condition|(
name|isdir
condition|)
name|deny
operator|->
name|a_access_mask
operator|^=
name|ACE_DELETE_CHILD
expr_stmt|;
name|deny
operator|->
name|a_access_mask
operator|&=
operator|~
operator|(
name|ACE_SYNCHRONIZE
operator||
name|ACE_WRITE_OWNER
operator||
name|ACE_DELETE
operator||
name|ACE_WRITE_ATTRIBUTES
operator||
name|ACE_READ_NAMED_ATTRS
operator||
name|ACE_WRITE_NAMED_ATTRS
operator|)
expr_stmt|;
name|deny
operator|->
name|a_access_mask
operator||=
name|access_mask_set
argument_list|(
operator|(
name|allow
operator|->
name|a_access_mask
operator|&
name|ACE_WRITE_DATA
operator|)
argument_list|,
operator|(
name|allow
operator|->
name|a_access_mask
operator|&
name|ACE_READ_DATA
operator|)
argument_list|,
name|isowner
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make an initial pass over an array of aclent_t's.  Gather  * information such as an ACL_MASK (if any), number of users,  * number of groups, and whether the array needs to be sorted.  */
end_comment

begin_function
specifier|static
name|int
name|ln_aent_preprocess
parameter_list|(
name|aclent_t
modifier|*
name|aclent
parameter_list|,
name|int
name|n
parameter_list|,
name|int
modifier|*
name|hasmask
parameter_list|,
name|mode_t
modifier|*
name|mask
parameter_list|,
name|int
modifier|*
name|numuser
parameter_list|,
name|int
modifier|*
name|numgroup
parameter_list|,
name|int
modifier|*
name|needsort
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|curtype
init|=
literal|0
decl_stmt|;
operator|*
name|hasmask
operator|=
literal|0
expr_stmt|;
operator|*
name|mask
operator|=
literal|07
expr_stmt|;
operator|*
name|needsort
operator|=
literal|0
expr_stmt|;
operator|*
name|numuser
operator|=
literal|0
expr_stmt|;
operator|*
name|numgroup
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|<
name|curtype
condition|)
operator|*
name|needsort
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|>
name|curtype
condition|)
name|curtype
operator|=
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
expr_stmt|;
if|if
condition|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|&
name|USER
condition|)
operator|(
operator|*
name|numuser
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|&
operator|(
name|GROUP
operator||
name|GROUP_OBJ
operator|)
condition|)
operator|(
operator|*
name|numgroup
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|&
name|CLASS_OBJ
condition|)
block|{
if|if
condition|(
operator|*
name|hasmask
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
operator|*
name|hasmask
operator|=
literal|1
expr_stmt|;
operator|*
name|mask
operator|=
name|aclent
index|[
name|i
index|]
operator|.
name|a_perm
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|!
operator|*
name|hasmask
operator|)
operator|&&
operator|(
operator|*
name|numuser
operator|+
operator|*
name|numgroup
operator|>
literal|1
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert an array of aclent_t into an array of nfsace entries,  * following POSIX draft -> nfsv4 conversion semantics as outlined in  * the IETF draft.  */
end_comment

begin_function
specifier|static
name|int
name|ln_aent_to_ace
parameter_list|(
name|aclent_t
modifier|*
name|aclent
parameter_list|,
name|int
name|n
parameter_list|,
name|ace_t
modifier|*
modifier|*
name|acepp
parameter_list|,
name|int
modifier|*
name|rescount
parameter_list|,
name|int
name|isdir
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mode_t
name|mask
decl_stmt|;
name|int
name|numuser
decl_stmt|,
name|numgroup
decl_stmt|,
name|needsort
decl_stmt|;
name|int
name|resultsize
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|groupi
init|=
literal|0
decl_stmt|,
name|skip
decl_stmt|;
name|ace_t
modifier|*
name|acep
decl_stmt|,
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|int
name|hasmask
decl_stmt|;
name|error
operator|=
name|ln_aent_preprocess
argument_list|(
name|aclent
argument_list|,
name|n
argument_list|,
operator|&
name|hasmask
argument_list|,
operator|&
name|mask
argument_list|,
operator|&
name|numuser
argument_list|,
operator|&
name|numgroup
argument_list|,
operator|&
name|needsort
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* allow + deny for each aclent */
name|resultsize
operator|=
name|n
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|hasmask
condition|)
block|{
comment|/* 		 * stick extra deny on the group_obj and on each 		 * user|group for the mask (the group_obj was added 		 * into the count for numgroup) 		 */
name|resultsize
operator|+=
name|numuser
operator|+
name|numgroup
expr_stmt|;
comment|/* ... and don't count the mask itself */
name|resultsize
operator|-=
literal|2
expr_stmt|;
block|}
comment|/* sort the source if necessary */
if|if
condition|(
name|needsort
condition|)
name|ksort
argument_list|(
operator|(
name|caddr_t
operator|)
name|aclent
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|aclent_t
argument_list|)
argument_list|,
name|cmp2acls
argument_list|)
expr_stmt|;
if|if
condition|(
name|cacl_malloc
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|result
argument_list|,
name|resultsize
operator|*
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|acep
operator|=
name|result
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * don't process CLASS_OBJ (mask); mask was grabbed in 		 * ln_aent_preprocess() 		 */
if|if
condition|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|&
name|CLASS_OBJ
condition|)
continue|continue;
comment|/* If we need an ACL_MASK emulator, prepend it now */
if|if
condition|(
operator|(
name|hasmask
operator|)
operator|&&
operator|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|&
operator|(
name|USER
operator||
name|GROUP
operator||
name|GROUP_OBJ
operator|)
operator|)
condition|)
block|{
name|acep
operator|->
name|a_type
operator|=
name|ACE_ACCESS_DENIED_ACE_TYPE
expr_stmt|;
name|acep
operator|->
name|a_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|&
name|GROUP_OBJ
condition|)
block|{
name|acep
operator|->
name|a_who
operator|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
expr_stmt|;
name|acep
operator|->
name|a_flags
operator||=
operator|(
name|ACE_IDENTIFIER_GROUP
operator||
name|ACE_GROUP
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|&
name|USER
condition|)
block|{
name|acep
operator|->
name|a_who
operator|=
name|aclent
index|[
name|i
index|]
operator|.
name|a_id
expr_stmt|;
block|}
else|else
block|{
name|acep
operator|->
name|a_who
operator|=
name|aclent
index|[
name|i
index|]
operator|.
name|a_id
expr_stmt|;
name|acep
operator|->
name|a_flags
operator||=
name|ACE_IDENTIFIER_GROUP
expr_stmt|;
block|}
if|if
condition|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|&
name|ACL_DEFAULT
condition|)
block|{
name|acep
operator|->
name|a_flags
operator||=
name|ACE_INHERIT_ONLY_ACE
operator||
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
expr_stmt|;
block|}
comment|/* 			 * Set the access mask for the prepended deny 			 * ace.  To do this, we invert the mask (found 			 * in ln_aent_preprocess()) then convert it to an 			 * DENY ace access_mask. 			 */
name|acep
operator|->
name|a_access_mask
operator|=
name|mode_to_ace_access
argument_list|(
operator|(
name|mask
operator|^
literal|07
operator|)
argument_list|,
name|isdir
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|acep
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* handle a_perm -> access_mask */
name|acep
operator|->
name|a_access_mask
operator|=
name|mode_to_ace_access
argument_list|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_perm
argument_list|,
name|isdir
argument_list|,
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|&
name|USER_OBJ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* emulate a default aclent */
if|if
condition|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|&
name|ACL_DEFAULT
condition|)
block|{
name|acep
operator|->
name|a_flags
operator||=
name|ACE_INHERIT_ONLY_ACE
operator||
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
expr_stmt|;
block|}
comment|/* 		 * handle a_perm and a_id 		 * 		 * this must be done last, since it involves the 		 * corresponding deny aces, which are handled 		 * differently for each different a_type. 		 */
if|if
condition|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|&
name|USER_OBJ
condition|)
block|{
name|acep
operator|->
name|a_who
operator|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
expr_stmt|;
name|acep
operator|->
name|a_flags
operator||=
name|ACE_OWNER
expr_stmt|;
name|ace_make_deny
argument_list|(
name|acep
argument_list|,
name|acep
operator|+
literal|1
argument_list|,
name|isdir
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|acep
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|&
name|USER
condition|)
block|{
name|acep
operator|->
name|a_who
operator|=
name|aclent
index|[
name|i
index|]
operator|.
name|a_id
expr_stmt|;
name|ace_make_deny
argument_list|(
name|acep
argument_list|,
name|acep
operator|+
literal|1
argument_list|,
name|isdir
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|acep
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|&
operator|(
name|GROUP_OBJ
operator||
name|GROUP
operator|)
condition|)
block|{
if|if
condition|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|&
name|GROUP_OBJ
condition|)
block|{
name|acep
operator|->
name|a_who
operator|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
expr_stmt|;
name|acep
operator|->
name|a_flags
operator||=
name|ACE_GROUP
expr_stmt|;
block|}
else|else
block|{
name|acep
operator|->
name|a_who
operator|=
name|aclent
index|[
name|i
index|]
operator|.
name|a_id
expr_stmt|;
block|}
name|acep
operator|->
name|a_flags
operator||=
name|ACE_IDENTIFIER_GROUP
expr_stmt|;
comment|/* 			 * Set the corresponding deny for the group ace. 			 * 			 * The deny aces go after all of the groups, unlike 			 * everything else, where they immediately follow 			 * the allow ace. 			 * 			 * We calculate "skip", the number of slots to 			 * skip ahead for the deny ace, here. 			 * 			 * The pattern is: 			 * MD1 A1 MD2 A2 MD3 A3 D1 D2 D3 			 * thus, skip is 			 * (2 * numgroup) - 1 - groupi 			 * (2 * numgroup) to account for MD + A 			 * - 1 to account for the fact that we're on the 			 * access (A), not the mask (MD) 			 * - groupi to account for the fact that we have 			 * passed up groupi number of MD's. 			 */
name|skip
operator|=
operator|(
literal|2
operator|*
name|numgroup
operator|)
operator|-
literal|1
operator|-
name|groupi
expr_stmt|;
name|ace_make_deny
argument_list|(
name|acep
argument_list|,
name|acep
operator|+
name|skip
argument_list|,
name|isdir
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* 			 * If we just did the last group, skip acep past 			 * all of the denies; else, just move ahead one. 			 */
if|if
condition|(
operator|++
name|groupi
operator|>=
name|numgroup
condition|)
name|acep
operator|+=
name|numgroup
operator|+
literal|1
expr_stmt|;
else|else
name|acep
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aclent
index|[
name|i
index|]
operator|.
name|a_type
operator|&
name|OTHER_OBJ
condition|)
block|{
name|acep
operator|->
name|a_who
operator|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
expr_stmt|;
name|acep
operator|->
name|a_flags
operator||=
name|ACE_EVERYONE
expr_stmt|;
name|ace_make_deny
argument_list|(
name|acep
argument_list|,
name|acep
operator|+
literal|1
argument_list|,
name|isdir
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|acep
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
operator|*
name|acepp
operator|=
name|result
expr_stmt|;
operator|*
name|rescount
operator|=
name|resultsize
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|result
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|resultsize
operator|>
literal|0
operator|)
condition|)
block|{
name|cacl_free
argument_list|(
name|result
argument_list|,
name|resultsize
operator|*
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|convert_aent_to_ace
parameter_list|(
name|aclent_t
modifier|*
name|aclentp
parameter_list|,
name|int
name|aclcnt
parameter_list|,
name|int
name|isdir
parameter_list|,
name|ace_t
modifier|*
modifier|*
name|retacep
parameter_list|,
name|int
modifier|*
name|retacecnt
parameter_list|)
block|{
name|ace_t
modifier|*
name|acep
decl_stmt|;
name|ace_t
modifier|*
name|dfacep
decl_stmt|;
name|int
name|acecnt
init|=
literal|0
decl_stmt|;
name|int
name|dfacecnt
init|=
literal|0
decl_stmt|;
name|int
name|dfaclstart
init|=
literal|0
decl_stmt|;
name|int
name|dfaclcnt
init|=
literal|0
decl_stmt|;
name|aclent_t
modifier|*
name|aclp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|acesz
decl_stmt|,
name|dfacesz
decl_stmt|;
name|ksort
argument_list|(
operator|(
name|caddr_t
operator|)
name|aclentp
argument_list|,
name|aclcnt
argument_list|,
sizeof|sizeof
argument_list|(
name|aclent_t
argument_list|)
argument_list|,
name|cmp2acls
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|aclp
operator|=
name|aclentp
init|;
name|i
operator|<
name|aclcnt
condition|;
name|aclp
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|aclp
operator|->
name|a_type
operator|&
name|ACL_DEFAULT
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|aclcnt
condition|)
block|{
name|dfaclstart
operator|=
name|i
expr_stmt|;
name|dfaclcnt
operator|=
name|aclcnt
operator|-
name|i
expr_stmt|;
block|}
if|if
condition|(
name|dfaclcnt
operator|&&
name|isdir
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|ln_aent_to_ace
argument_list|(
name|aclentp
argument_list|,
name|i
argument_list|,
operator|&
name|acep
argument_list|,
operator|&
name|acecnt
argument_list|,
name|isdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|dfaclcnt
condition|)
block|{
name|error
operator|=
name|ln_aent_to_ace
argument_list|(
operator|&
name|aclentp
index|[
name|dfaclstart
index|]
argument_list|,
name|dfaclcnt
argument_list|,
operator|&
name|dfacep
argument_list|,
operator|&
name|dfacecnt
argument_list|,
name|isdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|acep
condition|)
block|{
name|cacl_free
argument_list|(
name|acep
argument_list|,
name|acecnt
operator|*
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|dfacecnt
operator|!=
literal|0
condition|)
block|{
name|acesz
operator|=
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
operator|*
name|acecnt
expr_stmt|;
name|dfacesz
operator|=
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
operator|*
name|dfacecnt
expr_stmt|;
name|acep
operator|=
name|cacl_realloc
argument_list|(
name|acep
argument_list|,
name|acesz
argument_list|,
name|acesz
operator|+
name|dfacesz
argument_list|)
expr_stmt|;
if|if
condition|(
name|acep
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|dfaclcnt
condition|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|acep
operator|+
name|acecnt
argument_list|,
name|dfacep
argument_list|,
name|dfacesz
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dfaclcnt
condition|)
name|cacl_free
argument_list|(
name|dfacep
argument_list|,
name|dfacecnt
operator|*
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|retacecnt
operator|=
name|acecnt
operator|+
name|dfacecnt
expr_stmt|;
operator|*
name|retacep
operator|=
name|acep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ace_mask_to_mode
parameter_list|(
name|uint32_t
name|mask
parameter_list|,
name|o_mode_t
modifier|*
name|modep
parameter_list|,
name|int
name|isdir
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|o_mode_t
name|mode
init|=
literal|0
decl_stmt|;
name|uint32_t
name|bits
decl_stmt|,
name|wantbits
decl_stmt|;
comment|/* read */
if|if
condition|(
name|mask
operator|&
name|ACE_READ_DATA
condition|)
name|mode
operator||=
name|S_IROTH
expr_stmt|;
comment|/* write */
name|wantbits
operator|=
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
operator|)
expr_stmt|;
if|if
condition|(
name|isdir
condition|)
name|wantbits
operator||=
name|ACE_DELETE_CHILD
expr_stmt|;
name|bits
operator|=
name|mask
operator|&
name|wantbits
expr_stmt|;
if|if
condition|(
name|bits
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bits
operator|!=
name|wantbits
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mode
operator||=
name|S_IWOTH
expr_stmt|;
block|}
comment|/* exec */
if|if
condition|(
name|mask
operator|&
name|ACE_EXECUTE
condition|)
block|{
name|mode
operator||=
name|S_IXOTH
expr_stmt|;
block|}
operator|*
name|modep
operator|=
name|mode
expr_stmt|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acevals_init
parameter_list|(
name|acevals_t
modifier|*
name|vals
parameter_list|,
name|uid_t
name|key
parameter_list|)
block|{
name|bzero
argument_list|(
name|vals
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vals
argument_list|)
argument_list|)
expr_stmt|;
name|vals
operator|->
name|allowed
operator|=
name|ACE_MASK_UNDEFINED
expr_stmt|;
name|vals
operator|->
name|denied
operator|=
name|ACE_MASK_UNDEFINED
expr_stmt|;
name|vals
operator|->
name|mask
operator|=
name|ACE_MASK_UNDEFINED
expr_stmt|;
name|vals
operator|->
name|key
operator|=
name|key
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ace_list_init
parameter_list|(
name|ace_list_t
modifier|*
name|al
parameter_list|,
name|int
name|dfacl_flag
parameter_list|)
block|{
name|acevals_init
argument_list|(
operator|&
name|al
operator|->
name|user_obj
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|acevals_init
argument_list|(
operator|&
name|al
operator|->
name|group_obj
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|acevals_init
argument_list|(
operator|&
name|al
operator|->
name|other_obj
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|al
operator|->
name|numusers
operator|=
literal|0
expr_stmt|;
name|al
operator|->
name|numgroups
operator|=
literal|0
expr_stmt|;
name|al
operator|->
name|acl_mask
operator|=
literal|0
expr_stmt|;
name|al
operator|->
name|hasmask
operator|=
literal|0
expr_stmt|;
name|al
operator|->
name|state
operator|=
name|ace_unused
expr_stmt|;
name|al
operator|->
name|seen
operator|=
literal|0
expr_stmt|;
name|al
operator|->
name|dfacl_flag
operator|=
name|dfacl_flag
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find or create an acevals holder for a given id and avl tree.  *  * Note that only one thread will ever touch these avl trees, so  * there is no need for locking.  */
end_comment

begin_function
specifier|static
name|acevals_t
modifier|*
name|acevals_find
parameter_list|(
name|ace_t
modifier|*
name|ace
parameter_list|,
name|avl_tree_t
modifier|*
name|avl
parameter_list|,
name|int
modifier|*
name|num
parameter_list|)
block|{
name|acevals_t
name|key
decl_stmt|,
modifier|*
name|rc
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|key
operator|.
name|key
operator|=
name|ace
operator|->
name|a_who
expr_stmt|;
name|rc
operator|=
name|avl_find
argument_list|(
name|avl
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|NULL
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* this memory is freed by ln_ace_to_aent()->ace_list_free() */
if|if
condition|(
name|cacl_malloc
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|rc
argument_list|,
sizeof|sizeof
argument_list|(
name|acevals_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|acevals_init
argument_list|(
name|rc
argument_list|,
name|ace
operator|->
name|a_who
argument_list|)
expr_stmt|;
name|avl_insert
argument_list|(
name|avl
argument_list|,
name|rc
argument_list|,
name|where
argument_list|)
expr_stmt|;
operator|(
operator|*
name|num
operator|)
operator|++
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|access_mask_check
parameter_list|(
name|ace_t
modifier|*
name|acep
parameter_list|,
name|int
name|mask_bit
parameter_list|,
name|int
name|isowner
parameter_list|)
block|{
name|int
name|set_deny
decl_stmt|,
name|err_deny
decl_stmt|;
name|int
name|set_allow
decl_stmt|,
name|err_allow
decl_stmt|;
name|int
name|acl_consume
decl_stmt|;
name|int
name|haswriteperm
decl_stmt|,
name|hasreadperm
decl_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ACE_ACCESS_DENIED_ACE_TYPE
condition|)
block|{
name|haswriteperm
operator|=
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_WRITE_DATA
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|hasreadperm
operator|=
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_READ_DATA
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
else|else
block|{
name|haswriteperm
operator|=
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_WRITE_DATA
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|hasreadperm
operator|=
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_READ_DATA
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
name|acl_consume
operator|=
operator|(
name|ACL_SYNCHRONIZE_ERR_DENY
operator||
name|ACL_DELETE_ERR_DENY
operator||
name|ACL_WRITE_OWNER_ERR_DENY
operator||
name|ACL_WRITE_OWNER_ERR_ALLOW
operator||
name|ACL_WRITE_ATTRS_OWNER_SET_ALLOW
operator||
name|ACL_WRITE_ATTRS_OWNER_ERR_DENY
operator||
name|ACL_WRITE_ATTRS_WRITER_SET_DENY
operator||
name|ACL_WRITE_ATTRS_WRITER_ERR_ALLOW
operator||
name|ACL_WRITE_NAMED_WRITER_ERR_DENY
operator||
name|ACL_READ_NAMED_READER_ERR_DENY
operator|)
expr_stmt|;
if|if
condition|(
name|mask_bit
operator|==
name|ACE_SYNCHRONIZE
condition|)
block|{
name|set_deny
operator|=
name|ACL_SYNCHRONIZE_SET_DENY
expr_stmt|;
name|err_deny
operator|=
name|ACL_SYNCHRONIZE_ERR_DENY
expr_stmt|;
name|set_allow
operator|=
name|ACL_SYNCHRONIZE_SET_ALLOW
expr_stmt|;
name|err_allow
operator|=
name|ACL_SYNCHRONIZE_ERR_ALLOW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask_bit
operator|==
name|ACE_WRITE_OWNER
condition|)
block|{
name|set_deny
operator|=
name|ACL_WRITE_OWNER_SET_DENY
expr_stmt|;
name|err_deny
operator|=
name|ACL_WRITE_OWNER_ERR_DENY
expr_stmt|;
name|set_allow
operator|=
name|ACL_WRITE_OWNER_SET_ALLOW
expr_stmt|;
name|err_allow
operator|=
name|ACL_WRITE_OWNER_ERR_ALLOW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask_bit
operator|==
name|ACE_DELETE
condition|)
block|{
name|set_deny
operator|=
name|ACL_DELETE_SET_DENY
expr_stmt|;
name|err_deny
operator|=
name|ACL_DELETE_ERR_DENY
expr_stmt|;
name|set_allow
operator|=
name|ACL_DELETE_SET_ALLOW
expr_stmt|;
name|err_allow
operator|=
name|ACL_DELETE_ERR_ALLOW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask_bit
operator|==
name|ACE_WRITE_ATTRIBUTES
condition|)
block|{
if|if
condition|(
name|isowner
condition|)
block|{
name|set_deny
operator|=
name|ACL_WRITE_ATTRS_OWNER_SET_DENY
expr_stmt|;
name|err_deny
operator|=
name|ACL_WRITE_ATTRS_OWNER_ERR_DENY
expr_stmt|;
name|set_allow
operator|=
name|ACL_WRITE_ATTRS_OWNER_SET_ALLOW
expr_stmt|;
name|err_allow
operator|=
name|ACL_WRITE_ATTRS_OWNER_ERR_ALLOW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|haswriteperm
condition|)
block|{
name|set_deny
operator|=
name|ACL_WRITE_ATTRS_WRITER_SET_DENY
expr_stmt|;
name|err_deny
operator|=
name|ACL_WRITE_ATTRS_WRITER_ERR_DENY
expr_stmt|;
name|set_allow
operator|=
name|ACL_WRITE_ATTRS_WRITER_SET_ALLOW
expr_stmt|;
name|err_allow
operator|=
name|ACL_WRITE_ATTRS_WRITER_ERR_ALLOW
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|mask_bit
operator|)
operator|&&
operator|(
name|acep
operator|->
name|a_type
operator|&
name|ACE_ACCESS_ALLOWED_ACE_TYPE
operator|)
condition|)
block|{
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|mask_bit
operator|==
name|ACE_READ_NAMED_ATTRS
condition|)
block|{
if|if
condition|(
operator|!
name|hasreadperm
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|set_deny
operator|=
name|ACL_READ_NAMED_READER_SET_DENY
expr_stmt|;
name|err_deny
operator|=
name|ACL_READ_NAMED_READER_ERR_DENY
expr_stmt|;
name|set_allow
operator|=
name|ACL_READ_NAMED_READER_SET_ALLOW
expr_stmt|;
name|err_allow
operator|=
name|ACL_READ_NAMED_READER_ERR_ALLOW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask_bit
operator|==
name|ACE_WRITE_NAMED_ATTRS
condition|)
block|{
if|if
condition|(
operator|!
name|haswriteperm
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|set_deny
operator|=
name|ACL_WRITE_NAMED_WRITER_SET_DENY
expr_stmt|;
name|err_deny
operator|=
name|ACL_WRITE_NAMED_WRITER_ERR_DENY
expr_stmt|;
name|set_allow
operator|=
name|ACL_WRITE_NAMED_WRITER_SET_ALLOW
expr_stmt|;
name|err_allow
operator|=
name|ACL_WRITE_NAMED_WRITER_ERR_ALLOW
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ACE_ACCESS_DENIED_ACE_TYPE
condition|)
block|{
if|if
condition|(
name|acl_consume
operator|&
name|set_deny
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|mask_bit
operator|)
condition|)
block|{
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|acl_consume
operator|&
name|err_deny
condition|)
block|{
if|if
condition|(
name|acep
operator|->
name|a_access_mask
operator|&
name|mask_bit
condition|)
block|{
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* ACE_ACCESS_ALLOWED_ACE_TYPE */
if|if
condition|(
name|acl_consume
operator|&
name|set_allow
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|mask_bit
operator|)
condition|)
block|{
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|acl_consume
operator|&
name|err_allow
condition|)
block|{
if|if
condition|(
name|acep
operator|->
name|a_access_mask
operator|&
name|mask_bit
condition|)
block|{
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ace_to_aent_legal
parameter_list|(
name|ace_t
modifier|*
name|acep
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|isowner
decl_stmt|;
comment|/* only ALLOW or DENY */
if|if
condition|(
operator|(
name|acep
operator|->
name|a_type
operator|!=
name|ACE_ACCESS_ALLOWED_ACE_TYPE
operator|)
operator|&&
operator|(
name|acep
operator|->
name|a_type
operator|!=
name|ACE_ACCESS_DENIED_ACE_TYPE
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* check for invalid flags */
if|if
condition|(
name|acep
operator|->
name|a_flags
operator|&
operator|~
operator|(
name|ACE_VALID_FLAG_BITS
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* some flags are illegal */
if|if
condition|(
name|acep
operator|->
name|a_flags
operator|&
operator|(
name|ACE_SUCCESSFUL_ACCESS_ACE_FLAG
operator||
name|ACE_FAILED_ACCESS_ACE_FLAG
operator||
name|ACE_NO_PROPAGATE_INHERIT_ACE
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* check for invalid masks */
if|if
condition|(
name|acep
operator|->
name|a_access_mask
operator|&
operator|~
operator|(
name|ACE_VALID_MASK_BITS
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|acep
operator|->
name|a_flags
operator|&
name|ACE_OWNER
operator|)
condition|)
block|{
name|isowner
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|isowner
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|access_mask_check
argument_list|(
name|acep
argument_list|,
name|ACE_SYNCHRONIZE
argument_list|,
name|isowner
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|access_mask_check
argument_list|(
name|acep
argument_list|,
name|ACE_WRITE_OWNER
argument_list|,
name|isowner
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|access_mask_check
argument_list|(
name|acep
argument_list|,
name|ACE_DELETE
argument_list|,
name|isowner
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|access_mask_check
argument_list|(
name|acep
argument_list|,
name|ACE_WRITE_ATTRIBUTES
argument_list|,
name|isowner
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|access_mask_check
argument_list|(
name|acep
argument_list|,
name|ACE_READ_NAMED_ATTRS
argument_list|,
name|isowner
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|access_mask_check
argument_list|(
name|acep
argument_list|,
name|ACE_WRITE_NAMED_ATTRS
argument_list|,
name|isowner
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* more detailed checking of masks */
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ACE_ACCESS_ALLOWED_ACE_TYPE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_READ_ATTRIBUTES
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_WRITE_DATA
operator|)
operator|&&
operator|(
operator|!
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_APPEND_DATA
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
operator|!
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_WRITE_DATA
operator|)
operator|)
operator|&&
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_APPEND_DATA
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* ACL enforcement */
if|if
condition|(
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_READ_ACL
operator|)
operator|&&
operator|(
name|acep
operator|->
name|a_type
operator|!=
name|ACE_ACCESS_ALLOWED_ACE_TYPE
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_WRITE_ACL
condition|)
block|{
if|if
condition|(
operator|(
name|acep
operator|->
name|a_type
operator|==
name|ACE_ACCESS_DENIED_ACE_TYPE
operator|)
operator|&&
operator|(
name|isowner
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|acep
operator|->
name|a_type
operator|==
name|ACE_ACCESS_ALLOWED_ACE_TYPE
operator|)
operator|&&
operator|(
operator|!
name|isowner
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ace_allow_to_mode
parameter_list|(
name|uint32_t
name|mask
parameter_list|,
name|o_mode_t
modifier|*
name|modep
parameter_list|,
name|int
name|isdir
parameter_list|)
block|{
comment|/* ACE_READ_ACL and ACE_READ_ATTRIBUTES must both be set */
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|ACE_READ_ACL
operator||
name|ACE_READ_ATTRIBUTES
operator|)
operator|)
operator|!=
operator|(
name|ACE_READ_ACL
operator||
name|ACE_READ_ATTRIBUTES
operator|)
condition|)
block|{
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
return|return
operator|(
name|ace_mask_to_mode
argument_list|(
name|mask
argument_list|,
name|modep
argument_list|,
name|isdir
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acevals_to_aent
parameter_list|(
name|acevals_t
modifier|*
name|vals
parameter_list|,
name|aclent_t
modifier|*
name|dest
parameter_list|,
name|ace_list_t
modifier|*
name|list
parameter_list|,
name|uid_t
name|owner
parameter_list|,
name|gid_t
name|group
parameter_list|,
name|int
name|isdir
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint32_t
name|flips
init|=
name|ACE_POSIX_SUPPORTED_BITS
decl_stmt|;
if|if
condition|(
name|isdir
condition|)
name|flips
operator||=
name|ACE_DELETE_CHILD
expr_stmt|;
if|if
condition|(
name|vals
operator|->
name|allowed
operator|!=
operator|(
name|vals
operator|->
name|denied
operator|^
name|flips
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|list
operator|->
name|hasmask
operator|)
operator|&&
operator|(
name|list
operator|->
name|acl_mask
operator|!=
name|vals
operator|->
name|mask
operator|)
operator|&&
operator|(
name|vals
operator|->
name|aent_type
operator|&
operator|(
name|USER
operator||
name|GROUP
operator||
name|GROUP_OBJ
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|ace_allow_to_mode
argument_list|(
name|vals
operator|->
name|allowed
argument_list|,
operator|&
name|dest
operator|->
name|a_perm
argument_list|,
name|isdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|dest
operator|->
name|a_type
operator|=
name|vals
operator|->
name|aent_type
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|a_type
operator|&
operator|(
name|USER
operator||
name|GROUP
operator|)
condition|)
block|{
name|dest
operator|->
name|a_id
operator|=
name|vals
operator|->
name|key
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dest
operator|->
name|a_type
operator|&
name|USER_OBJ
condition|)
block|{
name|dest
operator|->
name|a_id
operator|=
name|owner
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dest
operator|->
name|a_type
operator|&
name|GROUP_OBJ
condition|)
block|{
name|dest
operator|->
name|a_id
operator|=
name|group
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dest
operator|->
name|a_type
operator|&
name|OTHER_OBJ
condition|)
block|{
name|dest
operator|->
name|a_id
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ace_list_to_aent
parameter_list|(
name|ace_list_t
modifier|*
name|list
parameter_list|,
name|aclent_t
modifier|*
modifier|*
name|aclentp
parameter_list|,
name|int
modifier|*
name|aclcnt
parameter_list|,
name|uid_t
name|owner
parameter_list|,
name|gid_t
name|group
parameter_list|,
name|int
name|isdir
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|aclent_t
modifier|*
name|aent
decl_stmt|,
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|acevals_t
modifier|*
name|vals
decl_stmt|;
name|int
name|resultcount
decl_stmt|;
if|if
condition|(
operator|(
name|list
operator|->
name|seen
operator|&
operator|(
name|USER_OBJ
operator||
name|GROUP_OBJ
operator||
name|OTHER_OBJ
operator|)
operator|)
operator|!=
operator|(
name|USER_OBJ
operator||
name|GROUP_OBJ
operator||
name|OTHER_OBJ
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
operator|!
name|list
operator|->
name|hasmask
operator|)
operator|&&
operator|(
name|list
operator|->
name|numusers
operator|+
name|list
operator|->
name|numgroups
operator|>
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|resultcount
operator|=
literal|3
operator|+
name|list
operator|->
name|numusers
operator|+
name|list
operator|->
name|numgroups
expr_stmt|;
comment|/* 	 * This must be the same condition as below, when we add the CLASS_OBJ 	 * (aka ACL mask) 	 */
if|if
condition|(
operator|(
name|list
operator|->
name|hasmask
operator|)
operator|||
operator|(
operator|!
name|list
operator|->
name|dfacl_flag
operator|)
condition|)
name|resultcount
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|cacl_malloc
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|result
argument_list|,
name|resultcount
operator|*
sizeof|sizeof
argument_list|(
name|aclent_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|aent
operator|=
name|result
expr_stmt|;
comment|/* USER_OBJ */
if|if
condition|(
operator|!
operator|(
name|list
operator|->
name|user_obj
operator|.
name|aent_type
operator|&
name|USER_OBJ
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|acevals_to_aent
argument_list|(
operator|&
name|list
operator|->
name|user_obj
argument_list|,
name|aent
argument_list|,
name|list
argument_list|,
name|owner
argument_list|,
name|group
argument_list|,
name|isdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
operator|++
name|aent
expr_stmt|;
comment|/* USER */
name|vals
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|vals
operator|=
name|avl_first
argument_list|(
operator|&
name|list
operator|->
name|user
argument_list|)
init|;
name|vals
operator|!=
name|NULL
condition|;
name|vals
operator|=
name|AVL_NEXT
argument_list|(
operator|&
name|list
operator|->
name|user
argument_list|,
name|vals
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|vals
operator|->
name|aent_type
operator|&
name|USER
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|acevals_to_aent
argument_list|(
name|vals
argument_list|,
name|aent
argument_list|,
name|list
argument_list|,
name|owner
argument_list|,
name|group
argument_list|,
name|isdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
operator|++
name|aent
expr_stmt|;
block|}
comment|/* GROUP_OBJ */
if|if
condition|(
operator|!
operator|(
name|list
operator|->
name|group_obj
operator|.
name|aent_type
operator|&
name|GROUP_OBJ
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|acevals_to_aent
argument_list|(
operator|&
name|list
operator|->
name|group_obj
argument_list|,
name|aent
argument_list|,
name|list
argument_list|,
name|owner
argument_list|,
name|group
argument_list|,
name|isdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
operator|++
name|aent
expr_stmt|;
comment|/* GROUP */
name|vals
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|vals
operator|=
name|avl_first
argument_list|(
operator|&
name|list
operator|->
name|group
argument_list|)
init|;
name|vals
operator|!=
name|NULL
condition|;
name|vals
operator|=
name|AVL_NEXT
argument_list|(
operator|&
name|list
operator|->
name|group
argument_list|,
name|vals
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|vals
operator|->
name|aent_type
operator|&
name|GROUP
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|acevals_to_aent
argument_list|(
name|vals
argument_list|,
name|aent
argument_list|,
name|list
argument_list|,
name|owner
argument_list|,
name|group
argument_list|,
name|isdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
operator|++
name|aent
expr_stmt|;
block|}
comment|/* 	 * CLASS_OBJ (aka ACL_MASK) 	 * 	 * An ACL_MASK is not fabricated if the ACL is a default ACL. 	 * This is to follow UFS's behavior. 	 */
if|if
condition|(
operator|(
name|list
operator|->
name|hasmask
operator|)
operator|||
operator|(
operator|!
name|list
operator|->
name|dfacl_flag
operator|)
condition|)
block|{
if|if
condition|(
name|list
operator|->
name|hasmask
condition|)
block|{
name|uint32_t
name|flips
init|=
name|ACE_POSIX_SUPPORTED_BITS
decl_stmt|;
if|if
condition|(
name|isdir
condition|)
name|flips
operator||=
name|ACE_DELETE_CHILD
expr_stmt|;
name|error
operator|=
name|ace_mask_to_mode
argument_list|(
name|list
operator|->
name|acl_mask
operator|^
name|flips
argument_list|,
operator|&
name|aent
operator|->
name|a_perm
argument_list|,
name|isdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* fabricate the ACL_MASK from the group permissions */
name|error
operator|=
name|ace_mask_to_mode
argument_list|(
name|list
operator|->
name|group_obj
operator|.
name|allowed
argument_list|,
operator|&
name|aent
operator|->
name|a_perm
argument_list|,
name|isdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|aent
operator|->
name|a_id
operator|=
literal|0
expr_stmt|;
name|aent
operator|->
name|a_type
operator|=
name|CLASS_OBJ
operator||
name|list
operator|->
name|dfacl_flag
expr_stmt|;
operator|++
name|aent
expr_stmt|;
block|}
comment|/* OTHER_OBJ */
if|if
condition|(
operator|!
operator|(
name|list
operator|->
name|other_obj
operator|.
name|aent_type
operator|&
name|OTHER_OBJ
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|acevals_to_aent
argument_list|(
operator|&
name|list
operator|->
name|other_obj
argument_list|,
name|aent
argument_list|,
name|list
argument_list|,
name|owner
argument_list|,
name|group
argument_list|,
name|isdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
operator|++
name|aent
expr_stmt|;
operator|*
name|aclentp
operator|=
name|result
expr_stmt|;
operator|*
name|aclcnt
operator|=
name|resultcount
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
name|cacl_free
argument_list|(
name|result
argument_list|,
name|resultcount
operator|*
sizeof|sizeof
argument_list|(
name|aclent_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * free all data associated with an ace_list  */
end_comment

begin_function
specifier|static
name|void
name|ace_list_free
parameter_list|(
name|ace_list_t
modifier|*
name|al
parameter_list|)
block|{
name|acevals_t
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
if|if
condition|(
name|al
operator|==
name|NULL
condition|)
return|return;
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|node
operator|=
name|avl_destroy_nodes
argument_list|(
operator|&
name|al
operator|->
name|user
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cacl_free
argument_list|(
name|node
argument_list|,
sizeof|sizeof
argument_list|(
name|acevals_t
argument_list|)
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|node
operator|=
name|avl_destroy_nodes
argument_list|(
operator|&
name|al
operator|->
name|group
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cacl_free
argument_list|(
name|node
argument_list|,
sizeof|sizeof
argument_list|(
name|acevals_t
argument_list|)
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|al
operator|->
name|user
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|al
operator|->
name|group
argument_list|)
expr_stmt|;
comment|/* free the container itself */
name|cacl_free
argument_list|(
name|al
argument_list|,
sizeof|sizeof
argument_list|(
name|ace_list_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|acevals_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
specifier|const
name|acevals_t
modifier|*
name|a
init|=
name|va
decl_stmt|,
modifier|*
name|b
init|=
name|vb
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|key
operator|==
name|b
operator|->
name|key
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|key
operator|>
name|b
operator|->
name|key
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a list of ace_t entries to equivalent regular and default  * aclent_t lists.  Return error (ENOTSUP) when conversion is not possible.  */
end_comment

begin_function
specifier|static
name|int
name|ln_ace_to_aent
parameter_list|(
name|ace_t
modifier|*
name|ace
parameter_list|,
name|int
name|n
parameter_list|,
name|uid_t
name|owner
parameter_list|,
name|gid_t
name|group
parameter_list|,
name|aclent_t
modifier|*
modifier|*
name|aclentp
parameter_list|,
name|int
modifier|*
name|aclcnt
parameter_list|,
name|aclent_t
modifier|*
modifier|*
name|dfaclentp
parameter_list|,
name|int
modifier|*
name|dfaclcnt
parameter_list|,
name|int
name|isdir
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ace_t
modifier|*
name|acep
decl_stmt|;
name|uint32_t
name|bits
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ace_list_t
modifier|*
name|normacl
init|=
name|NULL
decl_stmt|,
modifier|*
name|dfacl
init|=
name|NULL
decl_stmt|,
modifier|*
name|acl
decl_stmt|;
name|acevals_t
modifier|*
name|vals
decl_stmt|;
operator|*
name|aclentp
operator|=
name|NULL
expr_stmt|;
operator|*
name|aclcnt
operator|=
literal|0
expr_stmt|;
operator|*
name|dfaclentp
operator|=
name|NULL
expr_stmt|;
operator|*
name|dfaclcnt
operator|=
literal|0
expr_stmt|;
comment|/* we need at least user_obj, group_obj, and other_obj */
if|if
condition|(
name|n
operator|<
literal|6
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ace
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|cacl_malloc
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|normacl
argument_list|,
sizeof|sizeof
argument_list|(
name|ace_list_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|avl_create
argument_list|(
operator|&
name|normacl
operator|->
name|user
argument_list|,
name|acevals_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|acevals_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|acevals_t
argument_list|,
name|avl
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|normacl
operator|->
name|group
argument_list|,
name|acevals_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|acevals_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|acevals_t
argument_list|,
name|avl
argument_list|)
argument_list|)
expr_stmt|;
name|ace_list_init
argument_list|(
name|normacl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|cacl_malloc
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dfacl
argument_list|,
sizeof|sizeof
argument_list|(
name|ace_list_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|avl_create
argument_list|(
operator|&
name|dfacl
operator|->
name|user
argument_list|,
name|acevals_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|acevals_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|acevals_t
argument_list|,
name|avl
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|dfacl
operator|->
name|group
argument_list|,
name|acevals_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|acevals_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|acevals_t
argument_list|,
name|avl
argument_list|)
argument_list|)
expr_stmt|;
name|ace_list_init
argument_list|(
name|dfacl
argument_list|,
name|ACL_DEFAULT
argument_list|)
expr_stmt|;
comment|/* process every ace_t... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|acep
operator|=
operator|&
name|ace
index|[
name|i
index|]
expr_stmt|;
comment|/* rule out certain cases quickly */
name|error
operator|=
name|ace_to_aent_legal
argument_list|(
name|acep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * Turn off these bits in order to not have to worry about 		 * them when doing the checks for compliments. 		 */
name|acep
operator|->
name|a_access_mask
operator|&=
operator|~
operator|(
name|ACE_WRITE_OWNER
operator||
name|ACE_DELETE
operator||
name|ACE_SYNCHRONIZE
operator||
name|ACE_WRITE_ATTRIBUTES
operator||
name|ACE_READ_NAMED_ATTRS
operator||
name|ACE_WRITE_NAMED_ATTRS
operator|)
expr_stmt|;
comment|/* see if this should be a regular or default acl */
name|bits
operator|=
name|acep
operator|->
name|a_flags
operator|&
operator|(
name|ACE_INHERIT_ONLY_ACE
operator||
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
expr_stmt|;
if|if
condition|(
name|bits
operator|!=
literal|0
condition|)
block|{
comment|/* all or nothing on these inherit bits */
if|if
condition|(
name|bits
operator|!=
operator|(
name|ACE_INHERIT_ONLY_ACE
operator||
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|acl
operator|=
name|dfacl
expr_stmt|;
block|}
else|else
block|{
name|acl
operator|=
name|normacl
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|acep
operator|->
name|a_flags
operator|&
name|ACE_OWNER
operator|)
condition|)
block|{
if|if
condition|(
name|acl
operator|->
name|state
operator|>
name|ace_user_obj
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|acl
operator|->
name|state
operator|=
name|ace_user_obj
expr_stmt|;
name|acl
operator|->
name|seen
operator||=
name|USER_OBJ
expr_stmt|;
name|vals
operator|=
operator|&
name|acl
operator|->
name|user_obj
expr_stmt|;
name|vals
operator|->
name|aent_type
operator|=
name|USER_OBJ
operator||
name|acl
operator|->
name|dfacl_flag
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|acep
operator|->
name|a_flags
operator|&
name|ACE_EVERYONE
operator|)
condition|)
block|{
name|acl
operator|->
name|state
operator|=
name|ace_other_obj
expr_stmt|;
name|acl
operator|->
name|seen
operator||=
name|OTHER_OBJ
expr_stmt|;
name|vals
operator|=
operator|&
name|acl
operator|->
name|other_obj
expr_stmt|;
name|vals
operator|->
name|aent_type
operator|=
name|OTHER_OBJ
operator||
name|acl
operator|->
name|dfacl_flag
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|acep
operator|->
name|a_flags
operator|&
name|ACE_IDENTIFIER_GROUP
condition|)
block|{
if|if
condition|(
name|acl
operator|->
name|state
operator|>
name|ace_group
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|acep
operator|->
name|a_flags
operator|&
name|ACE_GROUP
operator|)
condition|)
block|{
name|acl
operator|->
name|seen
operator||=
name|GROUP_OBJ
expr_stmt|;
name|vals
operator|=
operator|&
name|acl
operator|->
name|group_obj
expr_stmt|;
name|vals
operator|->
name|aent_type
operator|=
name|GROUP_OBJ
operator||
name|acl
operator|->
name|dfacl_flag
expr_stmt|;
block|}
else|else
block|{
name|acl
operator|->
name|seen
operator||=
name|GROUP
expr_stmt|;
name|vals
operator|=
name|acevals_find
argument_list|(
name|acep
argument_list|,
operator|&
name|acl
operator|->
name|group
argument_list|,
operator|&
name|acl
operator|->
name|numgroups
argument_list|)
expr_stmt|;
if|if
condition|(
name|vals
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vals
operator|->
name|aent_type
operator|=
name|GROUP
operator||
name|acl
operator|->
name|dfacl_flag
expr_stmt|;
block|}
name|acl
operator|->
name|state
operator|=
name|ace_group
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|acl
operator|->
name|state
operator|>
name|ace_user
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|acl
operator|->
name|state
operator|=
name|ace_user
expr_stmt|;
name|acl
operator|->
name|seen
operator||=
name|USER
expr_stmt|;
name|vals
operator|=
name|acevals_find
argument_list|(
name|acep
argument_list|,
operator|&
name|acl
operator|->
name|user
argument_list|,
operator|&
name|acl
operator|->
name|numusers
argument_list|)
expr_stmt|;
if|if
condition|(
name|vals
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vals
operator|->
name|aent_type
operator|=
name|USER
operator||
name|acl
operator|->
name|dfacl_flag
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|acl
operator|->
name|state
operator|>
name|ace_unused
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ACE_ACCESS_ALLOWED_ACE_TYPE
condition|)
block|{
comment|/* no more than one allowed per aclent_t */
if|if
condition|(
name|vals
operator|->
name|allowed
operator|!=
name|ACE_MASK_UNDEFINED
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vals
operator|->
name|allowed
operator|=
name|acep
operator|->
name|a_access_mask
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * it's a DENY; if there was a previous DENY, it 			 * must have been an ACL_MASK. 			 */
if|if
condition|(
name|vals
operator|->
name|denied
operator|!=
name|ACE_MASK_UNDEFINED
condition|)
block|{
comment|/* ACL_MASK is for USER and GROUP only */
if|if
condition|(
operator|(
name|acl
operator|->
name|state
operator|!=
name|ace_user
operator|)
operator|&&
operator|(
name|acl
operator|->
name|state
operator|!=
name|ace_group
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|acl
operator|->
name|hasmask
condition|)
block|{
name|acl
operator|->
name|hasmask
operator|=
literal|1
expr_stmt|;
name|acl
operator|->
name|acl_mask
operator|=
name|vals
operator|->
name|denied
expr_stmt|;
comment|/* check for mismatched ACL_MASK emulations */
block|}
elseif|else
if|if
condition|(
name|acl
operator|->
name|acl_mask
operator|!=
name|vals
operator|->
name|denied
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vals
operator|->
name|mask
operator|=
name|vals
operator|->
name|denied
expr_stmt|;
block|}
name|vals
operator|->
name|denied
operator|=
name|acep
operator|->
name|a_access_mask
expr_stmt|;
block|}
block|}
comment|/* done collating; produce the aclent_t lists */
if|if
condition|(
name|normacl
operator|->
name|state
operator|!=
name|ace_unused
condition|)
block|{
name|error
operator|=
name|ace_list_to_aent
argument_list|(
name|normacl
argument_list|,
name|aclentp
argument_list|,
name|aclcnt
argument_list|,
name|owner
argument_list|,
name|group
argument_list|,
name|isdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|dfacl
operator|->
name|state
operator|!=
name|ace_unused
condition|)
block|{
name|error
operator|=
name|ace_list_to_aent
argument_list|(
name|dfacl
argument_list|,
name|dfaclentp
argument_list|,
name|dfaclcnt
argument_list|,
name|owner
argument_list|,
name|group
argument_list|,
name|isdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|normacl
operator|!=
name|NULL
condition|)
name|ace_list_free
argument_list|(
name|normacl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfacl
operator|!=
name|NULL
condition|)
name|ace_list_free
argument_list|(
name|dfacl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|convert_ace_to_aent
parameter_list|(
name|ace_t
modifier|*
name|acebufp
parameter_list|,
name|int
name|acecnt
parameter_list|,
name|int
name|isdir
parameter_list|,
name|uid_t
name|owner
parameter_list|,
name|gid_t
name|group
parameter_list|,
name|aclent_t
modifier|*
modifier|*
name|retaclentp
parameter_list|,
name|int
modifier|*
name|retaclcnt
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|aclent_t
modifier|*
name|aclentp
decl_stmt|,
modifier|*
name|dfaclentp
decl_stmt|;
name|int
name|aclcnt
decl_stmt|,
name|dfaclcnt
decl_stmt|;
name|int
name|aclsz
decl_stmt|,
name|dfaclsz
decl_stmt|;
name|error
operator|=
name|ln_ace_to_aent
argument_list|(
name|acebufp
argument_list|,
name|acecnt
argument_list|,
name|owner
argument_list|,
name|group
argument_list|,
operator|&
name|aclentp
argument_list|,
operator|&
name|aclcnt
argument_list|,
operator|&
name|dfaclentp
argument_list|,
operator|&
name|dfaclcnt
argument_list|,
name|isdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|dfaclcnt
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Slap aclentp and dfaclentp into a single array. 		 */
name|aclsz
operator|=
sizeof|sizeof
argument_list|(
name|aclent_t
argument_list|)
operator|*
name|aclcnt
expr_stmt|;
name|dfaclsz
operator|=
sizeof|sizeof
argument_list|(
name|aclent_t
argument_list|)
operator|*
name|dfaclcnt
expr_stmt|;
name|aclentp
operator|=
name|cacl_realloc
argument_list|(
name|aclentp
argument_list|,
name|aclsz
argument_list|,
name|aclsz
operator|+
name|dfaclsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclentp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|aclentp
operator|+
name|aclcnt
argument_list|,
name|dfaclentp
argument_list|,
name|dfaclsz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aclentp
condition|)
block|{
operator|*
name|retaclentp
operator|=
name|aclentp
expr_stmt|;
operator|*
name|retaclcnt
operator|=
name|aclcnt
operator|+
name|dfaclcnt
expr_stmt|;
block|}
if|if
condition|(
name|dfaclentp
condition|)
name|cacl_free
argument_list|(
name|dfaclentp
argument_list|,
name|dfaclsz
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|acl_translate
parameter_list|(
name|acl_t
modifier|*
name|aclp
parameter_list|,
name|int
name|target_flavor
parameter_list|,
name|int
name|isdir
parameter_list|,
name|uid_t
name|owner
parameter_list|,
name|gid_t
name|group
parameter_list|)
block|{
name|int
name|aclcnt
decl_stmt|;
name|void
modifier|*
name|acldata
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * See if we need to translate 	 */
if|if
condition|(
operator|(
name|target_flavor
operator|==
name|_ACL_ACE_ENABLED
operator|&&
name|aclp
operator|->
name|acl_type
operator|==
name|ACE_T
operator|)
operator|||
operator|(
name|target_flavor
operator|==
name|_ACL_ACLENT_ENABLED
operator|&&
name|aclp
operator|->
name|acl_type
operator|==
name|ACLENT_T
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|target_flavor
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|target_flavor
operator|==
name|_ACL_ACE_ENABLED
operator|&&
name|aclp
operator|->
name|acl_type
operator|==
name|ACLENT_T
condition|)
block|{
name|error
operator|=
name|convert_aent_to_ace
argument_list|(
name|aclp
operator|->
name|acl_aclp
argument_list|,
name|aclp
operator|->
name|acl_cnt
argument_list|,
name|isdir
argument_list|,
operator|(
name|ace_t
operator|*
operator|*
operator|)
operator|&
name|acldata
argument_list|,
operator|&
name|aclcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|target_flavor
operator|==
name|_ACL_ACLENT_ENABLED
operator|&&
name|aclp
operator|->
name|acl_type
operator|==
name|ACE_T
condition|)
block|{
name|error
operator|=
name|convert_ace_to_aent
argument_list|(
name|aclp
operator|->
name|acl_aclp
argument_list|,
name|aclp
operator|->
name|acl_cnt
argument_list|,
name|isdir
argument_list|,
name|owner
argument_list|,
name|group
argument_list|,
operator|(
name|aclent_t
operator|*
operator|*
operator|)
operator|&
name|acldata
argument_list|,
operator|&
name|aclcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * replace old acl with newly translated acl 	 */
name|cacl_free
argument_list|(
name|aclp
operator|->
name|acl_aclp
argument_list|,
name|aclp
operator|->
name|acl_cnt
operator|*
name|aclp
operator|->
name|acl_entry_size
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|acl_aclp
operator|=
name|acldata
expr_stmt|;
name|aclp
operator|->
name|acl_cnt
operator|=
name|aclcnt
expr_stmt|;
if|if
condition|(
name|target_flavor
operator|==
name|_ACL_ACE_ENABLED
condition|)
block|{
name|aclp
operator|->
name|acl_type
operator|=
name|ACE_T
expr_stmt|;
name|aclp
operator|->
name|acl_entry_size
operator|=
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aclp
operator|->
name|acl_type
operator|=
name|ACLENT_T
expr_stmt|;
name|aclp
operator|->
name|acl_entry_size
operator|=
sizeof|sizeof
argument_list|(
name|aclent_t
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|out
label|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|errno
operator|=
name|error
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_define
define|#
directive|define
name|SET_ACE
parameter_list|(
name|acl
parameter_list|,
name|index
parameter_list|,
name|who
parameter_list|,
name|mask
parameter_list|,
name|type
parameter_list|,
name|flags
parameter_list|)
value|{ \ 	acl[0][index].a_who = (uint32_t)who; \ 	acl[0][index].a_type = type; \ 	acl[0][index].a_flags = flags; \ 	acl[0][index++].a_access_mask = mask; \ }
end_define

begin_function
name|void
name|acl_trivial_access_masks
parameter_list|(
name|mode_t
name|mode
parameter_list|,
name|uint32_t
modifier|*
name|allow0
parameter_list|,
name|uint32_t
modifier|*
name|deny1
parameter_list|,
name|uint32_t
modifier|*
name|deny2
parameter_list|,
name|uint32_t
modifier|*
name|owner
parameter_list|,
name|uint32_t
modifier|*
name|group
parameter_list|,
name|uint32_t
modifier|*
name|everyone
parameter_list|)
block|{
operator|*
name|deny1
operator|=
operator|*
name|deny2
operator|=
operator|*
name|allow0
operator|=
operator|*
name|group
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|S_IRUSR
operator|)
operator|&&
operator|(
name|mode
operator|&
operator|(
name|S_IRGRP
operator||
name|S_IROTH
operator|)
operator|)
condition|)
operator|*
name|deny1
operator||=
name|ACE_READ_DATA
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|S_IWUSR
operator|)
operator|&&
operator|(
name|mode
operator|&
operator|(
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|)
condition|)
operator|*
name|deny1
operator||=
name|ACE_WRITE_DATA
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|S_IXUSR
operator|)
operator|&&
operator|(
name|mode
operator|&
operator|(
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
operator|)
condition|)
operator|*
name|deny1
operator||=
name|ACE_EXECUTE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|S_IRGRP
operator|)
operator|&&
operator|(
name|mode
operator|&
name|S_IROTH
operator|)
condition|)
operator|*
name|deny2
operator|=
name|ACE_READ_DATA
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|S_IWGRP
operator|)
operator|&&
operator|(
name|mode
operator|&
name|S_IWOTH
operator|)
condition|)
operator|*
name|deny2
operator||=
name|ACE_WRITE_DATA
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|S_IXGRP
operator|)
operator|&&
operator|(
name|mode
operator|&
name|S_IXOTH
operator|)
condition|)
operator|*
name|deny2
operator||=
name|ACE_EXECUTE
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|S_IRUSR
operator|)
operator|&&
operator|(
operator|!
operator|(
name|mode
operator|&
name|S_IRGRP
operator|)
operator|&&
operator|(
name|mode
operator|&
name|S_IROTH
operator|)
operator|)
condition|)
operator|*
name|allow0
operator||=
name|ACE_READ_DATA
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|S_IWUSR
operator|)
operator|&&
operator|(
operator|!
operator|(
name|mode
operator|&
name|S_IWGRP
operator|)
operator|&&
operator|(
name|mode
operator|&
name|S_IWOTH
operator|)
operator|)
condition|)
operator|*
name|allow0
operator||=
name|ACE_WRITE_DATA
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|S_IXUSR
operator|)
operator|&&
operator|(
operator|!
operator|(
name|mode
operator|&
name|S_IXGRP
operator|)
operator|&&
operator|(
name|mode
operator|&
name|S_IXOTH
operator|)
operator|)
condition|)
operator|*
name|allow0
operator||=
name|ACE_EXECUTE
expr_stmt|;
operator|*
name|owner
operator|=
name|ACE_WRITE_ATTRIBUTES
operator||
name|ACE_WRITE_OWNER
operator||
name|ACE_WRITE_ACL
operator||
name|ACE_WRITE_NAMED_ATTRS
operator||
name|ACE_READ_ACL
operator||
name|ACE_READ_ATTRIBUTES
operator||
name|ACE_READ_NAMED_ATTRS
operator||
name|ACE_SYNCHRONIZE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRUSR
condition|)
operator|*
name|owner
operator||=
name|ACE_READ_DATA
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWUSR
condition|)
operator|*
name|owner
operator||=
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXUSR
condition|)
operator|*
name|owner
operator||=
name|ACE_EXECUTE
expr_stmt|;
operator|*
name|group
operator|=
name|ACE_READ_ACL
operator||
name|ACE_READ_ATTRIBUTES
operator||
name|ACE_READ_NAMED_ATTRS
operator||
name|ACE_SYNCHRONIZE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRGRP
condition|)
operator|*
name|group
operator||=
name|ACE_READ_DATA
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWGRP
condition|)
operator|*
name|group
operator||=
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXGRP
condition|)
operator|*
name|group
operator||=
name|ACE_EXECUTE
expr_stmt|;
operator|*
name|everyone
operator|=
name|ACE_READ_ACL
operator||
name|ACE_READ_ATTRIBUTES
operator||
name|ACE_READ_NAMED_ATTRS
operator||
name|ACE_SYNCHRONIZE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IROTH
condition|)
operator|*
name|everyone
operator||=
name|ACE_READ_DATA
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWOTH
condition|)
operator|*
name|everyone
operator||=
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXOTH
condition|)
operator|*
name|everyone
operator||=
name|ACE_EXECUTE
expr_stmt|;
block|}
end_function

begin_function
name|int
name|acl_trivial_create
parameter_list|(
name|mode_t
name|mode
parameter_list|,
name|ace_t
modifier|*
modifier|*
name|acl
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|uint32_t
name|deny1
decl_stmt|,
name|deny2
decl_stmt|;
name|uint32_t
name|allow0
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|,
name|group
decl_stmt|,
name|everyone
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|count
operator|=
literal|3
expr_stmt|;
name|acl_trivial_access_masks
argument_list|(
name|mode
argument_list|,
operator|&
name|allow0
argument_list|,
operator|&
name|deny1
argument_list|,
operator|&
name|deny2
argument_list|,
operator|&
name|owner
argument_list|,
operator|&
name|group
argument_list|,
operator|&
name|everyone
argument_list|)
expr_stmt|;
if|if
condition|(
name|allow0
condition|)
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|deny1
condition|)
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|deny2
condition|)
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|cacl_malloc
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|acl
argument_list|,
operator|*
name|count
operator|*
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|allow0
condition|)
block|{
name|SET_ACE
argument_list|(
name|acl
argument_list|,
name|index
argument_list|,
operator|-
literal|1
argument_list|,
name|allow0
argument_list|,
name|ACE_ACCESS_ALLOWED_ACE_TYPE
argument_list|,
name|ACE_OWNER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deny1
condition|)
block|{
name|SET_ACE
argument_list|(
name|acl
argument_list|,
name|index
argument_list|,
operator|-
literal|1
argument_list|,
name|deny1
argument_list|,
name|ACE_ACCESS_DENIED_ACE_TYPE
argument_list|,
name|ACE_OWNER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deny2
condition|)
block|{
name|SET_ACE
argument_list|(
name|acl
argument_list|,
name|index
argument_list|,
operator|-
literal|1
argument_list|,
name|deny2
argument_list|,
name|ACE_ACCESS_DENIED_ACE_TYPE
argument_list|,
name|ACE_GROUP
operator||
name|ACE_IDENTIFIER_GROUP
argument_list|)
expr_stmt|;
block|}
name|SET_ACE
argument_list|(
name|acl
argument_list|,
name|index
argument_list|,
operator|-
literal|1
argument_list|,
name|owner
argument_list|,
name|ACE_ACCESS_ALLOWED_ACE_TYPE
argument_list|,
name|ACE_OWNER
argument_list|)
expr_stmt|;
name|SET_ACE
argument_list|(
name|acl
argument_list|,
name|index
argument_list|,
operator|-
literal|1
argument_list|,
name|group
argument_list|,
name|ACE_ACCESS_ALLOWED_ACE_TYPE
argument_list|,
name|ACE_IDENTIFIER_GROUP
operator||
name|ACE_GROUP
argument_list|)
expr_stmt|;
name|SET_ACE
argument_list|(
name|acl
argument_list|,
name|index
argument_list|,
operator|-
literal|1
argument_list|,
name|everyone
argument_list|,
name|ACE_ACCESS_ALLOWED_ACE_TYPE
argument_list|,
name|ACE_EVERYONE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ace_trivial:  * determine whether an ace_t acl is trivial  *  * Trivialness implies that the acl is composed of only  * owner, group, everyone entries.  ACL can't  * have read_acl denied, and write_owner/write_acl/write_attributes  * can only be owner@ entry.  */
end_comment

begin_function
name|int
name|ace_trivial_common
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|int
name|aclcnt
parameter_list|,
name|uint64_t
function_decl|(
modifier|*
name|walk
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|int
name|aclcnt
parameter_list|,
name|uint16_t
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
parameter_list|)
block|{
name|uint16_t
name|flags
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|uint16_t
name|type
decl_stmt|;
name|uint64_t
name|cookie
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cookie
operator|=
name|walk
argument_list|(
name|acep
argument_list|,
name|cookie
argument_list|,
name|aclcnt
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|flags
operator|&
name|ACE_TYPE_FLAGS
condition|)
block|{
case|case
name|ACE_OWNER
case|:
case|case
name|ACE_GROUP
operator||
name|ACE_IDENTIFIER_GROUP
case|:
case|case
name|ACE_EVERYONE
case|:
break|break;
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
operator|(
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
operator||
name|ACE_NO_PROPAGATE_INHERIT_ACE
operator||
name|ACE_INHERIT_ONLY_ACE
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 		 * Special check for some special bits 		 * 		 * Don't allow anybody to deny reading basic 		 * attributes or a files ACL. 		 */
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|ACE_READ_ACL
operator||
name|ACE_READ_ATTRIBUTES
operator|)
operator|)
operator|&&
operator|(
name|type
operator|==
name|ACE_ACCESS_DENIED_ACE_TYPE
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 		 * Delete permissions are never set by default 		 */
if|if
condition|(
name|mask
operator|&
operator|(
name|ACE_DELETE
operator||
name|ACE_DELETE_CHILD
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 		 * only allow owner@ to have 		 * write_acl/write_owner/write_attributes/write_xattr/ 		 */
if|if
condition|(
name|type
operator|==
name|ACE_ACCESS_ALLOWED_ACE_TYPE
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|ACE_OWNER
operator|)
operator|&&
operator|(
name|mask
operator|&
operator|(
name|ACE_WRITE_OWNER
operator||
name|ACE_WRITE_ACL
operator||
name|ACE_WRITE_ATTRIBUTES
operator||
name|ACE_WRITE_NAMED_ATTRS
operator|)
operator|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|ace_walk
parameter_list|(
name|void
modifier|*
name|datap
parameter_list|,
name|uint64_t
name|cookie
parameter_list|,
name|int
name|aclcnt
parameter_list|,
name|uint16_t
modifier|*
name|flags
parameter_list|,
name|uint16_t
modifier|*
name|type
parameter_list|,
name|uint32_t
modifier|*
name|mask
parameter_list|)
block|{
name|ace_t
modifier|*
name|acep
init|=
name|datap
decl_stmt|;
if|if
condition|(
name|cookie
operator|>=
name|aclcnt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|flags
operator|=
name|acep
index|[
name|cookie
index|]
operator|.
name|a_flags
expr_stmt|;
operator|*
name|type
operator|=
name|acep
index|[
name|cookie
index|]
operator|.
name|a_type
expr_stmt|;
operator|*
name|mask
operator|=
name|acep
index|[
name|cookie
operator|++
index|]
operator|.
name|a_access_mask
expr_stmt|;
return|return
operator|(
name|cookie
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ace_trivial
parameter_list|(
name|ace_t
modifier|*
name|acep
parameter_list|,
name|int
name|aclcnt
parameter_list|)
block|{
return|return
operator|(
name|ace_trivial_common
argument_list|(
name|acep
argument_list|,
name|aclcnt
argument_list|,
name|ace_walk
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

