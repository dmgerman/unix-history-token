begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1992, 1993, 1994, 1995, 1996  *	Keith Bostic.  All rights reserved.  * Copyright (c) 1995  *	George V. Neville-Neil. All rights reserved.  *  * See the LICENSE file for redistribution information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)api.c	8.26 (Berkeley) 10/14/96"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"../common/common.h"
end_include

begin_decl_stmt
specifier|extern
name|GS
modifier|*
name|__global_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_comment
comment|/*  * api_fscreen --  *	Return a pointer to the screen specified by the screen id  *	or a file name.  *  * PUBLIC: SCR *api_fscreen __P((int, char *));  */
end_comment

begin_function
name|SCR
modifier|*
name|api_fscreen
parameter_list|(
name|id
parameter_list|,
name|name
parameter_list|)
name|int
name|id
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|SCR
modifier|*
name|tsp
decl_stmt|;
name|gp
operator|=
name|__global_list
expr_stmt|;
comment|/* Search the displayed list. */
for|for
control|(
name|tsp
operator|=
name|gp
operator|->
name|dq
operator|.
name|cqh_first
init|;
name|tsp
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|gp
operator|->
name|dq
condition|;
name|tsp
operator|=
name|tsp
operator|->
name|q
operator|.
name|cqe_next
control|)
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|id
operator|==
name|tsp
operator|->
name|id
condition|)
return|return
operator|(
name|tsp
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|tsp
operator|->
name|frp
operator|->
name|name
argument_list|)
condition|)
return|return
operator|(
name|tsp
operator|)
return|;
comment|/* Search the hidden list. */
for|for
control|(
name|tsp
operator|=
name|gp
operator|->
name|hq
operator|.
name|cqh_first
init|;
name|tsp
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|gp
operator|->
name|hq
condition|;
name|tsp
operator|=
name|tsp
operator|->
name|q
operator|.
name|cqe_next
control|)
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|id
operator|==
name|tsp
operator|->
name|id
condition|)
return|return
operator|(
name|tsp
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|tsp
operator|->
name|frp
operator|->
name|name
argument_list|)
condition|)
return|return
operator|(
name|tsp
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * api_aline --  *	Append a line.  *  * PUBLIC: int api_aline __P((SCR *, recno_t, char *, size_t));  */
end_comment

begin_function
name|int
name|api_aline
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|,
name|line
parameter_list|,
name|len
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
return|return
operator|(
name|db_append
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|,
name|lno
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * api_dline --  *	Delete a line.  *  * PUBLIC: int api_dline __P((SCR *, recno_t));  */
end_comment

begin_function
name|int
name|api_dline
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
block|{
return|return
operator|(
name|db_delete
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * api_gline --  *	Get a line.  *  * PUBLIC: int api_gline __P((SCR *, recno_t, char **, size_t *));  */
end_comment

begin_function
name|int
name|api_gline
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|,
name|linepp
parameter_list|,
name|lenp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|char
modifier|*
modifier|*
name|linepp
decl_stmt|;
name|size_t
modifier|*
name|lenp
decl_stmt|;
block|{
name|int
name|isempty
decl_stmt|;
if|if
condition|(
name|db_eget
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|linepp
argument_list|,
name|lenp
argument_list|,
operator|&
name|isempty
argument_list|)
condition|)
block|{
if|if
condition|(
name|isempty
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"209|The file is empty"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * api_iline --  *	Insert a line.  *  * PUBLIC: int api_iline __P((SCR *, recno_t, char *, size_t));  */
end_comment

begin_function
name|int
name|api_iline
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|,
name|line
parameter_list|,
name|len
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
return|return
operator|(
name|db_insert
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * api_lline --  *	Return the line number of the last line in the file.  *  * PUBLIC: int api_lline __P((SCR *, recno_t *));  */
end_comment

begin_function
name|int
name|api_lline
parameter_list|(
name|sp
parameter_list|,
name|lnop
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
modifier|*
name|lnop
decl_stmt|;
block|{
return|return
operator|(
name|db_last
argument_list|(
name|sp
argument_list|,
name|lnop
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * api_sline --  *	Set a line.  *  * PUBLIC: int api_sline __P((SCR *, recno_t, char *, size_t));  */
end_comment

begin_function
name|int
name|api_sline
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|,
name|line
parameter_list|,
name|len
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
return|return
operator|(
name|db_set
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * api_getmark --  *	Get the mark.  *  * PUBLIC: int api_getmark __P((SCR *, int, MARK *));  */
end_comment

begin_function
name|int
name|api_getmark
parameter_list|(
name|sp
parameter_list|,
name|markname
parameter_list|,
name|mp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|markname
decl_stmt|;
name|MARK
modifier|*
name|mp
decl_stmt|;
block|{
return|return
operator|(
name|mark_get
argument_list|(
name|sp
argument_list|,
operator|(
name|ARG_CHAR_T
operator|)
name|markname
argument_list|,
name|mp
argument_list|,
name|M_ERR
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * api_setmark --  *	Set the mark.  *  * PUBLIC: int api_setmark __P((SCR *, int, MARK *));  */
end_comment

begin_function
name|int
name|api_setmark
parameter_list|(
name|sp
parameter_list|,
name|markname
parameter_list|,
name|mp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|markname
decl_stmt|;
name|MARK
modifier|*
name|mp
decl_stmt|;
block|{
return|return
operator|(
name|mark_set
argument_list|(
name|sp
argument_list|,
operator|(
name|ARG_CHAR_T
operator|)
name|markname
argument_list|,
name|mp
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * api_nextmark --  *	Return the first mark if next not set, otherwise return the  *	subsequent mark.  *  * PUBLIC: int api_nextmark __P((SCR *, int, char *));  */
end_comment

begin_function
name|int
name|api_nextmark
parameter_list|(
name|sp
parameter_list|,
name|next
parameter_list|,
name|namep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|next
decl_stmt|;
name|char
modifier|*
name|namep
decl_stmt|;
block|{
name|LMARK
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
name|sp
operator|->
name|ep
operator|->
name|marks
operator|.
name|lh_first
expr_stmt|;
if|if
condition|(
name|next
condition|)
for|for
control|(
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|q
operator|.
name|le_next
control|)
if|if
condition|(
name|mp
operator|->
name|name
operator|==
operator|*
name|namep
condition|)
block|{
name|mp
operator|=
name|mp
operator|->
name|q
operator|.
name|le_next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|namep
operator|=
name|mp
operator|->
name|name
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * api_getcursor --  *	Get the cursor.  *  * PUBLIC: int api_getcursor __P((SCR *, MARK *));  */
end_comment

begin_function
name|int
name|api_getcursor
parameter_list|(
name|sp
parameter_list|,
name|mp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|MARK
modifier|*
name|mp
decl_stmt|;
block|{
name|mp
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|mp
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * api_setcursor --  *	Set the cursor.  *  * PUBLIC: int api_setcursor __P((SCR *, MARK *));  */
end_comment

begin_function
name|int
name|api_setcursor
parameter_list|(
name|sp
parameter_list|,
name|mp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|MARK
modifier|*
name|mp
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|db_get
argument_list|(
name|sp
argument_list|,
name|mp
operator|->
name|lno
argument_list|,
name|DBG_FATAL
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|mp
operator|->
name|cno
operator|<
literal|0
operator|||
name|mp
operator|->
name|cno
operator|>
name|len
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Cursor set to nonexistent column"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Set the cursor. */
name|sp
operator|->
name|lno
operator|=
name|mp
operator|->
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|mp
operator|->
name|cno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * api_emessage --  *	Print an error message.  *  * PUBLIC: void api_emessage __P((SCR *, char *));  */
end_comment

begin_function
name|void
name|api_emessage
parameter_list|(
name|sp
parameter_list|,
name|text
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s"
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * api_imessage --  *	Print an informational message.  *  * PUBLIC: void api_imessage __P((SCR *, char *));  */
end_comment

begin_function
name|void
name|api_imessage
parameter_list|(
name|sp
parameter_list|,
name|text
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"%s"
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * api_edit  *	Create a new screen and return its id   *	or edit a new file in the current screen.  *  * PUBLIC: int api_edit __P((SCR *, char *, SCR **, int));  */
end_comment

begin_function
name|int
name|api_edit
parameter_list|(
name|sp
parameter_list|,
name|file
parameter_list|,
name|spp
parameter_list|,
name|newscreen
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|SCR
modifier|*
modifier|*
name|spp
decl_stmt|;
name|int
name|newscreen
decl_stmt|;
block|{
name|ARGS
modifier|*
name|ap
index|[
literal|2
index|]
decl_stmt|,
name|a
decl_stmt|;
name|EXCMD
name|cmd
decl_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|ex_cinit
argument_list|(
operator|&
name|cmd
argument_list|,
name|C_EDIT
argument_list|,
literal|0
argument_list|,
name|OOBLNO
argument_list|,
name|OOBLNO
argument_list|,
literal|0
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|ex_cadd
argument_list|(
operator|&
name|cmd
argument_list|,
operator|&
name|a
argument_list|,
name|file
argument_list|,
name|strlen
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|ex_cinit
argument_list|(
operator|&
name|cmd
argument_list|,
name|C_EDIT
argument_list|,
literal|0
argument_list|,
name|OOBLNO
argument_list|,
name|OOBLNO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|newscreen
condition|)
name|cmd
operator|.
name|flags
operator||=
name|E_NEWSCREEN
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|cmd
operator|.
name|cmd
operator|->
name|fn
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|spp
operator|=
name|sp
operator|->
name|nextdisp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * api_escreen  *	End a screen.  *  * PUBLIC: int api_escreen __P((SCR *));  */
end_comment

begin_function
name|int
name|api_escreen
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|EXCMD
name|cmd
decl_stmt|;
comment|/* 	 * XXX 	 * If the interpreter exits anything other than the current 	 * screen, vi isn't going to update everything correctly. 	 */
name|ex_cinit
argument_list|(
operator|&
name|cmd
argument_list|,
name|C_QUIT
argument_list|,
literal|0
argument_list|,
name|OOBLNO
argument_list|,
name|OOBLNO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmd
operator|.
name|cmd
operator|->
name|fn
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * api_swscreen --  *    Switch to a new screen.  *  * PUBLIC: int api_swscreen __P((SCR *, SCR *));  */
end_comment

begin_function
name|int
name|api_swscreen
parameter_list|(
name|sp
parameter_list|,
name|new
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|,
decl|*
name|new
decl_stmt|;
end_function

begin_block
block|{
comment|/* 	 * XXX 	 * If the interpreter switches from anything other than the 	 * current screen, vi isn't going to update everything correctly. 	 */
name|sp
operator|->
name|nextdisp
operator|=
name|new
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|SC_SSWITCH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * api_map --  *	Map a key.  *  * PUBLIC: int api_map __P((SCR *, char *, char *, size_t));  */
end_comment

begin_function
name|int
name|api_map
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|,
name|map
parameter_list|,
name|len
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|map
decl_stmt|;
end_function

begin_decl_stmt
name|size_t
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ARGS
modifier|*
name|ap
index|[
literal|3
index|]
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
name|EXCMD
name|cmd
decl_stmt|;
name|ex_cinit
argument_list|(
operator|&
name|cmd
argument_list|,
name|C_MAP
argument_list|,
literal|0
argument_list|,
name|OOBLNO
argument_list|,
name|OOBLNO
argument_list|,
literal|0
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|ex_cadd
argument_list|(
operator|&
name|cmd
argument_list|,
operator|&
name|a
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ex_cadd
argument_list|(
operator|&
name|cmd
argument_list|,
operator|&
name|b
argument_list|,
name|map
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmd
operator|.
name|cmd
operator|->
name|fn
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * api_unmap --  *	Unmap a key.  *  * PUBLIC: int api_unmap __P((SCR *, char *));  */
end_comment

begin_function
name|int
name|api_unmap
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|ARGS
modifier|*
name|ap
index|[
literal|2
index|]
decl_stmt|,
name|a
decl_stmt|;
name|EXCMD
name|cmd
decl_stmt|;
name|ex_cinit
argument_list|(
operator|&
name|cmd
argument_list|,
name|C_UNMAP
argument_list|,
literal|0
argument_list|,
name|OOBLNO
argument_list|,
name|OOBLNO
argument_list|,
literal|0
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|ex_cadd
argument_list|(
operator|&
name|cmd
argument_list|,
operator|&
name|a
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmd
operator|.
name|cmd
operator|->
name|fn
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * api_opts_get --  *	Return a option value as a string, in allocated memory.  *	If the option is of type boolean, boolvalue is (un)set  *	according to the value; otherwise boolvalue is -1.  *  * PUBLIC: int api_opts_get __P((SCR *, char *, char **, int *));  */
end_comment

begin_function
name|int
name|api_opts_get
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|,
name|value
parameter_list|,
name|boolvalue
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
decl|*
modifier|*
name|value
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|boolvalue
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|OPTLIST
specifier|const
modifier|*
name|op
decl_stmt|;
name|int
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|op
operator|=
name|opts_search
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|opts_nomatch
argument_list|(
name|sp
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|offset
operator|=
name|op
operator|-
name|optlist
expr_stmt|;
if|if
condition|(
name|boolvalue
operator|!=
name|NULL
condition|)
operator|*
name|boolvalue
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|type
condition|)
block|{
case|case
name|OPT_0BOOL
case|:
case|case
name|OPT_1BOOL
case|:
name|MALLOC_RET
argument_list|(
name|sp
argument_list|,
operator|*
name|value
argument_list|,
name|char
operator|*
argument_list|,
name|strlen
argument_list|(
name|op
operator|->
name|name
argument_list|)
operator|+
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
operator|*
name|value
argument_list|,
literal|"%s%s"
argument_list|,
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|offset
argument_list|)
condition|?
literal|""
else|:
literal|"no"
argument_list|,
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|boolvalue
operator|!=
name|NULL
condition|)
operator|*
name|boolvalue
operator|=
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NUM
case|:
name|MALLOC_RET
argument_list|(
name|sp
argument_list|,
operator|*
name|value
argument_list|,
name|char
operator|*
argument_list|,
literal|20
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
operator|*
name|value
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|u_long
operator|)
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_STR
case|:
if|if
condition|(
name|O_STR
argument_list|(
name|sp
argument_list|,
name|offset
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|MALLOC_RET
argument_list|(
name|sp
argument_list|,
operator|*
name|value
argument_list|,
name|char
operator|*
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|value
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|MALLOC_RET
argument_list|(
name|sp
argument_list|,
operator|*
name|value
argument_list|,
name|char
operator|*
argument_list|,
name|strlen
argument_list|(
name|O_STR
argument_list|(
name|sp
argument_list|,
name|offset
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
operator|*
name|value
argument_list|,
literal|"%s"
argument_list|,
name|O_STR
argument_list|(
name|sp
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * api_opts_set --  *	Set options.  *  * PUBLIC: int api_opts_set __P((SCR *, char *, char *, u_long, int));  */
end_comment

begin_function
name|int
name|api_opts_set
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|,
name|str_value
parameter_list|,
name|num_value
parameter_list|,
name|bool_value
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|str_value
decl_stmt|;
end_function

begin_decl_stmt
name|u_long
name|num_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bool_value
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ARGS
modifier|*
name|ap
index|[
literal|2
index|]
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
name|OPTLIST
specifier|const
modifier|*
name|op
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|size_t
name|blen
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|(
name|op
operator|=
name|opts_search
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|opts_nomatch
argument_list|(
name|sp
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|op
operator|->
name|type
condition|)
block|{
case|case
name|OPT_0BOOL
case|:
case|case
name|OPT_1BOOL
case|:
name|GET_SPACE_RET
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|a
operator|.
name|len
operator|=
name|snprintf
argument_list|(
name|bp
argument_list|,
literal|64
argument_list|,
literal|"%s%s"
argument_list|,
name|bool_value
condition|?
literal|""
else|:
literal|"no"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_NUM
case|:
name|GET_SPACE_RET
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|a
operator|.
name|len
operator|=
name|snprintf
argument_list|(
name|bp
argument_list|,
literal|64
argument_list|,
literal|"%s=%lu"
argument_list|,
name|name
argument_list|,
name|num_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_STR
case|:
name|GET_SPACE_RET
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|a
operator|.
name|len
operator|=
name|snprintf
argument_list|(
name|bp
argument_list|,
literal|1024
argument_list|,
literal|"%s=%s"
argument_list|,
name|name
argument_list|,
name|str_value
argument_list|)
expr_stmt|;
break|break;
block|}
name|a
operator|.
name|bp
operator|=
name|bp
expr_stmt|;
name|b
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|b
operator|.
name|bp
operator|=
name|NULL
expr_stmt|;
name|ap
index|[
literal|0
index|]
operator|=
operator|&
name|a
expr_stmt|;
name|ap
index|[
literal|1
index|]
operator|=
operator|&
name|b
expr_stmt|;
name|rval
operator|=
name|opts_set
argument_list|(
name|sp
argument_list|,
name|ap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * api_run_str --  *      Execute a string as an ex command.  *  * PUBLIC: int api_run_str __P((SCR *, char *));  */
end_comment

begin_function
name|int
name|api_run_str
parameter_list|(
name|sp
parameter_list|,
name|cmd
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
return|return
operator|(
name|ex_run_str
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|cmd
argument_list|,
name|strlen
argument_list|(
name|cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

