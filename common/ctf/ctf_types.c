begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<ctf_impl.h>
end_include

begin_function
name|ssize_t
name|ctf_get_ctt_size
parameter_list|(
specifier|const
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
specifier|const
name|ctf_type_t
modifier|*
name|tp
parameter_list|,
name|ssize_t
modifier|*
name|sizep
parameter_list|,
name|ssize_t
modifier|*
name|incrementp
parameter_list|)
block|{
name|ssize_t
name|size
decl_stmt|,
name|increment
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_version
operator|>
name|CTF_VERSION_1
operator|&&
name|tp
operator|->
name|ctt_size
operator|==
name|CTF_LSIZE_SENT
condition|)
block|{
name|size
operator|=
name|CTF_TYPE_LSIZE
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|increment
operator|=
sizeof|sizeof
argument_list|(
name|ctf_type_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|tp
operator|->
name|ctt_size
expr_stmt|;
name|increment
operator|=
sizeof|sizeof
argument_list|(
name|ctf_stype_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sizep
condition|)
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|incrementp
condition|)
operator|*
name|incrementp
operator|=
name|increment
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over the members of a STRUCT or UNION.  We pass the name, member  * type, and offset of each member to the specified callback function.  */
end_comment

begin_function
name|int
name|ctf_member_iter
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|ctf_member_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ofp
init|=
name|fp
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
name|ssize_t
name|size
decl_stmt|,
name|increment
decl_stmt|;
name|uint_t
name|kind
decl_stmt|,
name|n
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
operator|(
name|void
operator|)
name|ctf_get_ctt_size
argument_list|(
name|fp
argument_list|,
name|tp
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
name|kind
operator|=
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|CTF_K_STRUCT
operator|&&
name|kind
operator|!=
name|CTF_K_UNION
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_NOTSOU
argument_list|)
operator|)
return|;
if|if
condition|(
name|fp
operator|->
name|ctf_version
operator|==
name|CTF_VERSION_1
operator|||
name|size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
block|{
specifier|const
name|ctf_member_t
modifier|*
name|mp
init|=
operator|(
specifier|const
name|ctf_member_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
decl_stmt|;
for|for
control|(
name|n
operator|=
name|LCTF_INFO_VLEN
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|mp
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|ctf_strptr
argument_list|(
name|fp
argument_list|,
name|mp
operator|->
name|ctm_name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|func
argument_list|(
name|name
argument_list|,
name|mp
operator|->
name|ctm_type
argument_list|,
name|mp
operator|->
name|ctm_offset
argument_list|,
name|arg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
else|else
block|{
specifier|const
name|ctf_lmember_t
modifier|*
name|lmp
init|=
operator|(
specifier|const
name|ctf_lmember_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
decl_stmt|;
for|for
control|(
name|n
operator|=
name|LCTF_INFO_VLEN
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|lmp
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|ctf_strptr
argument_list|(
name|fp
argument_list|,
name|lmp
operator|->
name|ctlm_name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|func
argument_list|(
name|name
argument_list|,
name|lmp
operator|->
name|ctlm_type
argument_list|,
operator|(
name|ulong_t
operator|)
name|CTF_LMEM_OFFSET
argument_list|(
name|lmp
argument_list|)
argument_list|,
name|arg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over the members of an ENUM.  We pass the string name and associated  * integer value of each enum element to the specified callback function.  */
end_comment

begin_function
name|int
name|ctf_enum_iter
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|ctf_enum_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ofp
init|=
name|fp
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
specifier|const
name|ctf_enum_t
modifier|*
name|ep
decl_stmt|;
name|ssize_t
name|increment
decl_stmt|;
name|uint_t
name|n
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
operator|!=
name|CTF_K_ENUM
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_NOTENUM
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|ctf_get_ctt_size
argument_list|(
name|fp
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
name|ep
operator|=
operator|(
specifier|const
name|ctf_enum_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|LCTF_INFO_VLEN
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|ep
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|ctf_strptr
argument_list|(
name|fp
argument_list|,
name|ep
operator|->
name|cte_name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|func
argument_list|(
name|name
argument_list|,
name|ep
operator|->
name|cte_value
argument_list|,
name|arg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over every root (user-visible) type in the given CTF container.  * We pass the type ID of each type to the specified callback function.  */
end_comment

begin_function
name|int
name|ctf_type_iter
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_type_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ctf_id_t
name|id
decl_stmt|,
name|max
init|=
name|fp
operator|->
name|ctf_typemax
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|child
init|=
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_CHILD
operator|)
decl_stmt|;
for|for
control|(
name|id
operator|=
literal|1
init|;
name|id
operator|<=
name|max
condition|;
name|id
operator|++
control|)
block|{
specifier|const
name|ctf_type_t
modifier|*
name|tp
init|=
name|LCTF_INDEX_TO_TYPEPTR
argument_list|(
name|fp
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|CTF_INFO_ISROOT
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
operator|&&
operator|(
name|rc
operator|=
name|func
argument_list|(
name|CTF_INDEX_TO_TYPE
argument_list|(
name|id
argument_list|,
name|child
argument_list|)
argument_list|,
name|arg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Follow a given type through the graph for TYPEDEF, VOLATILE, CONST, and  * RESTRICT nodes until we reach a "base" type node.  This is useful when  * we want to follow a type ID to a node that has members or a size.  To guard  * against infinite loops, we implement simplified cycle detection and check  * each link against itself, the previous node, and the topmost node.  */
end_comment

begin_function
name|ctf_id_t
name|ctf_type_resolve
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
name|ctf_id_t
name|prev
init|=
name|type
decl_stmt|,
name|otype
init|=
name|type
decl_stmt|;
name|ctf_file_t
modifier|*
name|ofp
init|=
name|fp
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
while|while
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
condition|)
block|{
case|case
name|CTF_K_TYPEDEF
case|:
case|case
name|CTF_K_VOLATILE
case|:
case|case
name|CTF_K_CONST
case|:
case|case
name|CTF_K_RESTRICT
case|:
if|if
condition|(
name|tp
operator|->
name|ctt_type
operator|==
name|type
operator|||
name|tp
operator|->
name|ctt_type
operator|==
name|otype
operator|||
name|tp
operator|->
name|ctt_type
operator|==
name|prev
condition|)
block|{
name|ctf_dprintf
argument_list|(
literal|"type %ld cycle detected\n"
argument_list|,
name|otype
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_CORRUPT
argument_list|)
operator|)
return|;
block|}
name|prev
operator|=
name|type
expr_stmt|;
name|type
operator|=
name|tp
operator|->
name|ctt_type
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|type
operator|)
return|;
block|}
block|}
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
block|}
end_function

begin_comment
comment|/*  * Lookup the given type ID and print a string name for it into buf.  Return  * the actual number of bytes (not including \0) needed to format the name.  */
end_comment

begin_function
specifier|static
name|ssize_t
name|ctf_type_qlname
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|qname
parameter_list|)
block|{
name|ctf_decl_t
name|cd
decl_stmt|;
name|ctf_decl_node_t
modifier|*
name|cdp
decl_stmt|;
name|ctf_decl_prec_t
name|prec
decl_stmt|,
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|int
name|ptr
decl_stmt|,
name|arr
decl_stmt|;
name|uint_t
name|k
decl_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
operator|&&
name|type
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* simplify caller code by permitting CTF_ERR */
name|ctf_decl_init
argument_list|(
operator|&
name|cd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ctf_decl_push
argument_list|(
operator|&
name|cd
argument_list|,
name|fp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|.
name|cd_err
operator|!=
literal|0
condition|)
block|{
name|ctf_decl_fini
argument_list|(
operator|&
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|cd
operator|.
name|cd_err
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If the type graph's order conflicts with lexical precedence order 	 * for pointers or arrays, then we need to surround the declarations at 	 * the corresponding lexical precedence with parentheses.  This can 	 * result in either a parenthesized pointer (*) as in int (*)() or 	 * int (*)[], or in a parenthesized pointer and array as in int (*[])(). 	 */
name|ptr
operator|=
name|cd
operator|.
name|cd_order
index|[
name|CTF_PREC_POINTER
index|]
operator|>
name|CTF_PREC_POINTER
expr_stmt|;
name|arr
operator|=
name|cd
operator|.
name|cd_order
index|[
name|CTF_PREC_ARRAY
index|]
operator|>
name|CTF_PREC_ARRAY
expr_stmt|;
name|rp
operator|=
name|arr
condition|?
name|CTF_PREC_ARRAY
else|:
name|ptr
condition|?
name|CTF_PREC_POINTER
else|:
operator|-
literal|1
expr_stmt|;
name|lp
operator|=
name|ptr
condition|?
name|CTF_PREC_POINTER
else|:
name|arr
condition|?
name|CTF_PREC_ARRAY
else|:
operator|-
literal|1
expr_stmt|;
name|k
operator|=
name|CTF_K_POINTER
expr_stmt|;
comment|/* avoid leading whitespace (see below) */
for|for
control|(
name|prec
operator|=
name|CTF_PREC_BASE
init|;
name|prec
operator|<
name|CTF_PREC_MAX
condition|;
name|prec
operator|++
control|)
block|{
for|for
control|(
name|cdp
operator|=
name|ctf_list_next
argument_list|(
operator|&
name|cd
operator|.
name|cd_nodes
index|[
name|prec
index|]
argument_list|)
init|;
name|cdp
operator|!=
name|NULL
condition|;
name|cdp
operator|=
name|ctf_list_next
argument_list|(
name|cdp
argument_list|)
control|)
block|{
name|ctf_file_t
modifier|*
name|rfp
init|=
name|fp
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
init|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|rfp
argument_list|,
name|cdp
operator|->
name|cd_type
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|ctf_strptr
argument_list|(
name|rfp
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|!=
name|CTF_K_POINTER
operator|&&
name|k
operator|!=
name|CTF_K_ARRAY
condition|)
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|prec
condition|)
block|{
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|lp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|cdp
operator|->
name|cd_kind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
case|case
name|CTF_K_FLOAT
case|:
case|case
name|CTF_K_TYPEDEF
case|:
if|if
condition|(
name|qname
operator|!=
name|NULL
condition|)
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"%s`"
argument_list|,
name|qname
argument_list|)
expr_stmt|;
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ARRAY
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"[%u]"
argument_list|,
name|cdp
operator|->
name|cd_n
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_FORWARD
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
if|if
condition|(
name|qname
operator|!=
name|NULL
condition|)
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"%s`"
argument_list|,
name|qname
argument_list|)
expr_stmt|;
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_UNION
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"union "
argument_list|)
expr_stmt|;
if|if
condition|(
name|qname
operator|!=
name|NULL
condition|)
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"%s`"
argument_list|,
name|qname
argument_list|)
expr_stmt|;
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ENUM
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"enum "
argument_list|)
expr_stmt|;
if|if
condition|(
name|qname
operator|!=
name|NULL
condition|)
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"%s`"
argument_list|,
name|qname
argument_list|)
expr_stmt|;
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_VOLATILE
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_CONST
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_RESTRICT
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"restrict"
argument_list|)
expr_stmt|;
break|break;
block|}
name|k
operator|=
name|cdp
operator|->
name|cd_kind
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|==
name|prec
condition|)
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cd
operator|.
name|cd_len
operator|>=
name|len
condition|)
operator|(
name|void
operator|)
name|ctf_set_errno
argument_list|(
name|fp
argument_list|,
name|ECTF_NAMELEN
argument_list|)
expr_stmt|;
name|ctf_decl_fini
argument_list|(
operator|&
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
name|cd
operator|.
name|cd_len
operator|)
return|;
block|}
end_function

begin_function
name|ssize_t
name|ctf_type_lname
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
operator|(
name|ctf_type_qlname
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup the given type ID and print a string name for it into buf.  If buf  * is too small, return NULL: the ECTF_NAMELEN error is set on 'fp' for us.  */
end_comment

begin_function
name|char
modifier|*
name|ctf_type_name
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|ssize_t
name|rv
init|=
name|ctf_type_qlname
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
return|return
operator|(
name|rv
operator|>=
literal|0
operator|&&
name|rv
operator|<
name|len
condition|?
name|buf
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ctf_type_qname
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|qname
parameter_list|)
block|{
name|ssize_t
name|rv
init|=
name|ctf_type_qlname
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|qname
argument_list|)
decl_stmt|;
return|return
operator|(
name|rv
operator|>=
literal|0
operator|&&
name|rv
operator|<
name|len
condition|?
name|buf
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Resolve the type down to a base type node, and then return the size  * of the type storage in bytes.  */
end_comment

begin_function
name|ssize_t
name|ctf_type_size
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
name|ctf_arinfo_t
name|ar
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
switch|switch
condition|(
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
condition|)
block|{
case|case
name|CTF_K_POINTER
case|:
return|return
operator|(
name|fp
operator|->
name|ctf_dmodel
operator|->
name|ctd_pointer
operator|)
return|;
case|case
name|CTF_K_FUNCTION
case|:
return|return
operator|(
literal|0
operator|)
return|;
comment|/* function size is only known by symtab */
case|case
name|CTF_K_ENUM
case|:
return|return
operator|(
name|fp
operator|->
name|ctf_dmodel
operator|->
name|ctd_int
operator|)
return|;
case|case
name|CTF_K_ARRAY
case|:
comment|/* 		 * Array size is not directly returned by stabs data.  Instead, 		 * it defines the element type and requires the user to perform 		 * the multiplication.  If ctf_get_ctt_size() returns zero, the 		 * current version of ctfconvert does not compute member sizes 		 * and we compute the size here on its behalf. 		 */
if|if
condition|(
operator|(
name|size
operator|=
name|ctf_get_ctt_size
argument_list|(
name|fp
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|>
literal|0
condition|)
return|return
operator|(
name|size
operator|)
return|;
if|if
condition|(
name|ctf_array_info
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
operator|&
name|ar
argument_list|)
operator|==
name|CTF_ERR
operator|||
operator|(
name|size
operator|=
name|ctf_type_size
argument_list|(
name|fp
argument_list|,
name|ar
operator|.
name|ctr_contents
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
return|return
operator|(
name|size
operator|*
name|ar
operator|.
name|ctr_nelems
operator|)
return|;
default|default:
return|return
operator|(
name|ctf_get_ctt_size
argument_list|(
name|fp
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Resolve the type down to a base type node, and then return the alignment  * needed for the type storage in bytes.  */
end_comment

begin_function
name|ssize_t
name|ctf_type_align
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
name|ctf_arinfo_t
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
switch|switch
condition|(
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
condition|)
block|{
case|case
name|CTF_K_POINTER
case|:
case|case
name|CTF_K_FUNCTION
case|:
return|return
operator|(
name|fp
operator|->
name|ctf_dmodel
operator|->
name|ctd_pointer
operator|)
return|;
case|case
name|CTF_K_ARRAY
case|:
if|if
condition|(
name|ctf_array_info
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
operator|&
name|r
argument_list|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
return|return
operator|(
name|ctf_type_align
argument_list|(
name|fp
argument_list|,
name|r
operator|.
name|ctr_contents
argument_list|)
operator|)
return|;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
block|{
name|uint_t
name|n
init|=
name|LCTF_INFO_VLEN
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
decl_stmt|;
name|ssize_t
name|size
decl_stmt|,
name|increment
decl_stmt|;
name|size_t
name|align
init|=
literal|0
decl_stmt|;
specifier|const
name|void
modifier|*
name|vmp
decl_stmt|;
operator|(
name|void
operator|)
name|ctf_get_ctt_size
argument_list|(
name|fp
argument_list|,
name|tp
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
name|vmp
operator|=
operator|(
name|uchar_t
operator|*
operator|)
name|tp
operator|+
name|increment
expr_stmt|;
if|if
condition|(
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
operator|==
name|CTF_K_STRUCT
condition|)
name|n
operator|=
name|MIN
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* only use first member for structs */
if|if
condition|(
name|fp
operator|->
name|ctf_version
operator|==
name|CTF_VERSION_1
operator|||
name|size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
block|{
specifier|const
name|ctf_member_t
modifier|*
name|mp
init|=
name|vmp
decl_stmt|;
for|for
control|(
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|mp
operator|++
control|)
block|{
name|ssize_t
name|am
init|=
name|ctf_type_align
argument_list|(
name|fp
argument_list|,
name|mp
operator|->
name|ctm_type
argument_list|)
decl_stmt|;
name|align
operator|=
name|MAX
argument_list|(
name|align
argument_list|,
name|am
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|ctf_lmember_t
modifier|*
name|lmp
init|=
name|vmp
decl_stmt|;
for|for
control|(
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|lmp
operator|++
control|)
block|{
name|ssize_t
name|am
init|=
name|ctf_type_align
argument_list|(
name|fp
argument_list|,
name|lmp
operator|->
name|ctlm_type
argument_list|)
decl_stmt|;
name|align
operator|=
name|MAX
argument_list|(
name|align
argument_list|,
name|am
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|align
operator|)
return|;
block|}
case|case
name|CTF_K_ENUM
case|:
return|return
operator|(
name|fp
operator|->
name|ctf_dmodel
operator|->
name|ctd_int
operator|)
return|;
default|default:
return|return
operator|(
name|ctf_get_ctt_size
argument_list|(
name|fp
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return the kind (CTF_K_* constant) for the specified type ID.  */
end_comment

begin_function
name|int
name|ctf_type_kind
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
return|return
operator|(
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If the type is one that directly references another type (such as POINTER),  * then return the ID of the type to which it refers.  */
end_comment

begin_function
name|ctf_id_t
name|ctf_type_reference
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ofp
init|=
name|fp
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
switch|switch
condition|(
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
condition|)
block|{
case|case
name|CTF_K_POINTER
case|:
case|case
name|CTF_K_TYPEDEF
case|:
case|case
name|CTF_K_VOLATILE
case|:
case|case
name|CTF_K_CONST
case|:
case|case
name|CTF_K_RESTRICT
case|:
return|return
operator|(
name|tp
operator|->
name|ctt_type
operator|)
return|;
default|default:
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_NOTREF
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find a pointer to type by looking in fp->ctf_ptrtab.  If we can't find a  * pointer to the given type, see if we can compute a pointer to the type  * resulting from resolving the type down to its base type and use that  * instead.  This helps with cases where the CTF data includes "struct foo *"  * but not "foo_t *" and the user accesses "foo_t *" in the debugger.  */
end_comment

begin_function
name|ctf_id_t
name|ctf_type_pointer
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ofp
init|=
name|fp
decl_stmt|;
name|ctf_id_t
name|ntype
decl_stmt|;
if|if
condition|(
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fp
argument_list|,
name|type
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
operator|(
name|ntype
operator|=
name|fp
operator|->
name|ctf_ptrtab
index|[
name|CTF_TYPE_TO_INDEX
argument_list|(
name|type
argument_list|)
index|]
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CTF_INDEX_TO_TYPE
argument_list|(
name|ntype
argument_list|,
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_CHILD
operator|)
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_NOTYPE
argument_list|)
operator|)
return|;
if|if
condition|(
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fp
argument_list|,
name|type
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_NOTYPE
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|ntype
operator|=
name|fp
operator|->
name|ctf_ptrtab
index|[
name|CTF_TYPE_TO_INDEX
argument_list|(
name|type
argument_list|)
index|]
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CTF_INDEX_TO_TYPE
argument_list|(
name|ntype
argument_list|,
operator|(
name|fp
operator|->
name|ctf_flags
operator|&
name|LCTF_CHILD
operator|)
argument_list|)
operator|)
return|;
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_NOTYPE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the encoding for the specified INTEGER or FLOAT.  */
end_comment

begin_function
name|int
name|ctf_type_encoding
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|ctf_encoding_t
modifier|*
name|ep
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ofp
init|=
name|fp
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
name|ssize_t
name|increment
decl_stmt|;
name|uint_t
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
operator|(
name|void
operator|)
name|ctf_get_ctt_size
argument_list|(
name|fp
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
name|data
operator|=
operator|*
operator|(
specifier|const
name|uint_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
expr_stmt|;
name|ep
operator|->
name|cte_format
operator|=
name|CTF_INT_ENCODING
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|ep
operator|->
name|cte_offset
operator|=
name|CTF_INT_OFFSET
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|ep
operator|->
name|cte_bits
operator|=
name|CTF_INT_BITS
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FLOAT
case|:
name|data
operator|=
operator|*
operator|(
specifier|const
name|uint_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
expr_stmt|;
name|ep
operator|->
name|cte_format
operator|=
name|CTF_FP_ENCODING
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|ep
operator|->
name|cte_offset
operator|=
name|CTF_FP_OFFSET
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|ep
operator|->
name|cte_bits
operator|=
name|CTF_FP_BITS
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_NOTINTFP
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctf_type_cmp
parameter_list|(
name|ctf_file_t
modifier|*
name|lfp
parameter_list|,
name|ctf_id_t
name|ltype
parameter_list|,
name|ctf_file_t
modifier|*
name|rfp
parameter_list|,
name|ctf_id_t
name|rtype
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
if|if
condition|(
name|ltype
operator|<
name|rtype
condition|)
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ltype
operator|>
name|rtype
condition|)
name|rval
operator|=
literal|1
expr_stmt|;
else|else
name|rval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lfp
operator|==
name|rfp
condition|)
return|return
operator|(
name|rval
operator|)
return|;
if|if
condition|(
name|CTF_TYPE_ISPARENT
argument_list|(
name|ltype
argument_list|)
operator|&&
name|lfp
operator|->
name|ctf_parent
operator|!=
name|NULL
condition|)
name|lfp
operator|=
name|lfp
operator|->
name|ctf_parent
expr_stmt|;
if|if
condition|(
name|CTF_TYPE_ISPARENT
argument_list|(
name|rtype
argument_list|)
operator|&&
name|rfp
operator|->
name|ctf_parent
operator|!=
name|NULL
condition|)
name|rfp
operator|=
name|rfp
operator|->
name|ctf_parent
expr_stmt|;
if|if
condition|(
name|lfp
operator|<
name|rfp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|lfp
operator|>
name|rfp
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a boolean value indicating if two types are compatible integers or  * floating-pointer values.  This function returns true if the two types are  * the same, or if they have the same ASCII name and encoding properties.  * This function could be extended to test for compatibility for other kinds.  */
end_comment

begin_function
name|int
name|ctf_type_compat
parameter_list|(
name|ctf_file_t
modifier|*
name|lfp
parameter_list|,
name|ctf_id_t
name|ltype
parameter_list|,
name|ctf_file_t
modifier|*
name|rfp
parameter_list|,
name|ctf_id_t
name|rtype
parameter_list|)
block|{
specifier|const
name|ctf_type_t
modifier|*
name|ltp
decl_stmt|,
modifier|*
name|rtp
decl_stmt|;
name|ctf_encoding_t
name|le
decl_stmt|,
name|re
decl_stmt|;
name|ctf_arinfo_t
name|la
decl_stmt|,
name|ra
decl_stmt|;
name|uint_t
name|lkind
decl_stmt|,
name|rkind
decl_stmt|;
if|if
condition|(
name|ctf_type_cmp
argument_list|(
name|lfp
argument_list|,
name|ltype
argument_list|,
name|rfp
argument_list|,
name|rtype
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ltype
operator|=
name|ctf_type_resolve
argument_list|(
name|lfp
argument_list|,
name|ltype
argument_list|)
expr_stmt|;
name|lkind
operator|=
name|ctf_type_kind
argument_list|(
name|lfp
argument_list|,
name|ltype
argument_list|)
expr_stmt|;
name|rtype
operator|=
name|ctf_type_resolve
argument_list|(
name|rfp
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
name|rkind
operator|=
name|ctf_type_kind
argument_list|(
name|rfp
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|lkind
operator|!=
name|rkind
operator|||
operator|(
name|ltp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|lfp
argument_list|,
name|ltype
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|rtp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|rfp
argument_list|,
name|rtype
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|ctf_strptr
argument_list|(
name|lfp
argument_list|,
name|ltp
operator|->
name|ctt_name
argument_list|)
argument_list|,
name|ctf_strptr
argument_list|(
name|rfp
argument_list|,
name|rtp
operator|->
name|ctt_name
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|lkind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
case|case
name|CTF_K_FLOAT
case|:
return|return
operator|(
name|ctf_type_encoding
argument_list|(
name|lfp
argument_list|,
name|ltype
argument_list|,
operator|&
name|le
argument_list|)
operator|==
literal|0
operator|&&
name|ctf_type_encoding
argument_list|(
name|rfp
argument_list|,
name|rtype
argument_list|,
operator|&
name|re
argument_list|)
operator|==
literal|0
operator|&&
name|bcmp
argument_list|(
operator|&
name|le
argument_list|,
operator|&
name|re
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_encoding_t
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
return|;
case|case
name|CTF_K_POINTER
case|:
return|return
operator|(
name|ctf_type_compat
argument_list|(
name|lfp
argument_list|,
name|ctf_type_reference
argument_list|(
name|lfp
argument_list|,
name|ltype
argument_list|)
argument_list|,
name|rfp
argument_list|,
name|ctf_type_reference
argument_list|(
name|rfp
argument_list|,
name|rtype
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CTF_K_ARRAY
case|:
return|return
operator|(
name|ctf_array_info
argument_list|(
name|lfp
argument_list|,
name|ltype
argument_list|,
operator|&
name|la
argument_list|)
operator|==
literal|0
operator|&&
name|ctf_array_info
argument_list|(
name|rfp
argument_list|,
name|rtype
argument_list|,
operator|&
name|ra
argument_list|)
operator|==
literal|0
operator|&&
name|la
operator|.
name|ctr_nelems
operator|==
name|ra
operator|.
name|ctr_nelems
operator|&&
name|ctf_type_compat
argument_list|(
name|lfp
argument_list|,
name|la
operator|.
name|ctr_contents
argument_list|,
name|rfp
argument_list|,
name|ra
operator|.
name|ctr_contents
argument_list|)
operator|&&
name|ctf_type_compat
argument_list|(
name|lfp
argument_list|,
name|la
operator|.
name|ctr_index
argument_list|,
name|rfp
argument_list|,
name|ra
operator|.
name|ctr_index
argument_list|)
operator|)
return|;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
return|return
operator|(
name|ctf_type_size
argument_list|(
name|lfp
argument_list|,
name|ltype
argument_list|)
operator|==
name|ctf_type_size
argument_list|(
name|rfp
argument_list|,
name|rtype
argument_list|)
operator|)
return|;
case|case
name|CTF_K_ENUM
case|:
case|case
name|CTF_K_FORWARD
case|:
return|return
operator|(
literal|1
operator|)
return|;
comment|/* no other checks required for these type kinds */
default|default:
return|return
operator|(
literal|0
operator|)
return|;
comment|/* should not get here since we did a resolve */
block|}
block|}
end_function

begin_comment
comment|/*  * Return the type and offset for a given member of a STRUCT or UNION.  */
end_comment

begin_function
name|int
name|ctf_member_info
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ctf_membinfo_t
modifier|*
name|mip
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ofp
init|=
name|fp
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
name|ssize_t
name|size
decl_stmt|,
name|increment
decl_stmt|;
name|uint_t
name|kind
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
operator|(
name|void
operator|)
name|ctf_get_ctt_size
argument_list|(
name|fp
argument_list|,
name|tp
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
name|kind
operator|=
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|CTF_K_STRUCT
operator|&&
name|kind
operator|!=
name|CTF_K_UNION
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_NOTSOU
argument_list|)
operator|)
return|;
if|if
condition|(
name|fp
operator|->
name|ctf_version
operator|==
name|CTF_VERSION_1
operator|||
name|size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
block|{
specifier|const
name|ctf_member_t
modifier|*
name|mp
init|=
operator|(
specifier|const
name|ctf_member_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
decl_stmt|;
for|for
control|(
name|n
operator|=
name|LCTF_INFO_VLEN
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|mp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ctf_strptr
argument_list|(
name|fp
argument_list|,
name|mp
operator|->
name|ctm_name
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mip
operator|->
name|ctm_type
operator|=
name|mp
operator|->
name|ctm_type
expr_stmt|;
name|mip
operator|->
name|ctm_offset
operator|=
name|mp
operator|->
name|ctm_offset
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
specifier|const
name|ctf_lmember_t
modifier|*
name|lmp
init|=
operator|(
specifier|const
name|ctf_lmember_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
decl_stmt|;
for|for
control|(
name|n
operator|=
name|LCTF_INFO_VLEN
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|lmp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ctf_strptr
argument_list|(
name|fp
argument_list|,
name|lmp
operator|->
name|ctlm_name
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mip
operator|->
name|ctm_type
operator|=
name|lmp
operator|->
name|ctlm_type
expr_stmt|;
name|mip
operator|->
name|ctm_offset
operator|=
operator|(
name|ulong_t
operator|)
name|CTF_LMEM_OFFSET
argument_list|(
name|lmp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_NOMEMBNAM
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the array type, index, and size information for the specified ARRAY.  */
end_comment

begin_function
name|int
name|ctf_array_info
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|ctf_arinfo_t
modifier|*
name|arp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ofp
init|=
name|fp
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
specifier|const
name|ctf_array_t
modifier|*
name|ap
decl_stmt|;
name|ssize_t
name|increment
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
operator|!=
name|CTF_K_ARRAY
condition|)
return|return
operator|(
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_NOTARRAY
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|ctf_get_ctt_size
argument_list|(
name|fp
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
name|ap
operator|=
operator|(
specifier|const
name|ctf_array_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
expr_stmt|;
name|arp
operator|->
name|ctr_contents
operator|=
name|ap
operator|->
name|cta_contents
expr_stmt|;
name|arp
operator|->
name|ctr_index
operator|=
name|ap
operator|->
name|cta_index
expr_stmt|;
name|arp
operator|->
name|ctr_nelems
operator|=
name|ap
operator|->
name|cta_nelems
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert the specified value to the corresponding enum member name, if a  * matching name can be found.  Otherwise NULL is returned.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ctf_enum_name
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ofp
init|=
name|fp
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
specifier|const
name|ctf_enum_t
modifier|*
name|ep
decl_stmt|;
name|ssize_t
name|increment
decl_stmt|;
name|uint_t
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
operator|!=
name|CTF_K_ENUM
condition|)
block|{
operator|(
name|void
operator|)
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_NOTENUM
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|ctf_get_ctt_size
argument_list|(
name|fp
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
name|ep
operator|=
operator|(
specifier|const
name|ctf_enum_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|LCTF_INFO_VLEN
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|ep
operator|->
name|cte_value
operator|==
name|value
condition|)
return|return
operator|(
name|ctf_strptr
argument_list|(
name|fp
argument_list|,
name|ep
operator|->
name|cte_name
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_NOENUMNAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert the specified enum tag name to the corresponding value, if a  * matching name can be found.  Otherwise CTF_ERR is returned.  */
end_comment

begin_function
name|int
name|ctf_enum_value
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|valp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ofp
init|=
name|fp
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
specifier|const
name|ctf_enum_t
modifier|*
name|ep
decl_stmt|;
name|ssize_t
name|size
decl_stmt|,
name|increment
decl_stmt|;
name|uint_t
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
operator|!=
name|CTF_K_ENUM
condition|)
block|{
operator|(
name|void
operator|)
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_NOTENUM
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTF_ERR
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|ctf_get_ctt_size
argument_list|(
name|fp
argument_list|,
name|tp
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
name|ep
operator|=
operator|(
specifier|const
name|ctf_enum_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|LCTF_INFO_VLEN
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ctf_strptr
argument_list|(
name|fp
argument_list|,
name|ep
operator|->
name|cte_name
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|valp
operator|!=
name|NULL
condition|)
operator|*
name|valp
operator|=
name|ep
operator|->
name|cte_value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
operator|(
name|void
operator|)
name|ctf_set_errno
argument_list|(
name|ofp
argument_list|,
name|ECTF_NOENUMNAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|CTF_ERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Recursively visit the members of any type.  This function is used as the  * engine for ctf_type_visit, below.  We resolve the input type, recursively  * invoke ourself for each type member if the type is a struct or union, and  * then invoke the callback function on the current type.  If any callback  * returns non-zero, we abort and percolate the error code back up to the top.  */
end_comment

begin_function
specifier|static
name|int
name|ctf_type_rvisit
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|ctf_visit_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ulong_t
name|offset
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|ctf_id_t
name|otype
init|=
name|type
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
name|ssize_t
name|size
decl_stmt|,
name|increment
decl_stmt|;
name|uint_t
name|kind
decl_stmt|,
name|n
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|CTF_ERR
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
operator|(
name|rc
operator|=
name|func
argument_list|(
name|name
argument_list|,
name|otype
argument_list|,
name|offset
argument_list|,
name|depth
argument_list|,
name|arg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|kind
operator|=
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|CTF_K_STRUCT
operator|&&
name|kind
operator|!=
name|CTF_K_UNION
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|ctf_get_ctt_size
argument_list|(
name|fp
argument_list|,
name|tp
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|ctf_version
operator|==
name|CTF_VERSION_1
operator|||
name|size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
block|{
specifier|const
name|ctf_member_t
modifier|*
name|mp
init|=
operator|(
specifier|const
name|ctf_member_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
decl_stmt|;
for|for
control|(
name|n
operator|=
name|LCTF_INFO_VLEN
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|mp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|ctf_type_rvisit
argument_list|(
name|fp
argument_list|,
name|mp
operator|->
name|ctm_type
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|ctf_strptr
argument_list|(
name|fp
argument_list|,
name|mp
operator|->
name|ctm_name
argument_list|)
argument_list|,
name|offset
operator|+
name|mp
operator|->
name|ctm_offset
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
else|else
block|{
specifier|const
name|ctf_lmember_t
modifier|*
name|lmp
init|=
operator|(
specifier|const
name|ctf_lmember_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
decl_stmt|;
for|for
control|(
name|n
operator|=
name|LCTF_INFO_VLEN
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|lmp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|ctf_type_rvisit
argument_list|(
name|fp
argument_list|,
name|lmp
operator|->
name|ctlm_type
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|ctf_strptr
argument_list|(
name|fp
argument_list|,
name|lmp
operator|->
name|ctlm_name
argument_list|)
argument_list|,
name|offset
operator|+
operator|(
name|ulong_t
operator|)
name|CTF_LMEM_OFFSET
argument_list|(
name|lmp
argument_list|)
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Recursively visit the members of any type.  We pass the name, member  * type, and offset of each member to the specified callback function.  */
end_comment

begin_function
name|int
name|ctf_type_visit
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|ctf_visit_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|ctf_type_rvisit
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

