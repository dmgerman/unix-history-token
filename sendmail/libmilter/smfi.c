begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 1999-2007 Sendmail, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: smfi.c,v 8.83 2007/04/23 16:44:39 ca Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<sm/varargs.h>
end_include

begin_include
include|#
directive|include
file|"libmilter.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|smfi_header
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|myisenhsc
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for smfi_set{ml}reply, let's be generous. 256/16 should be sufficient */
end_comment

begin_define
define|#
directive|define
name|MAXREPLYLEN
value|980
end_define

begin_comment
comment|/* max. length of a reply string */
end_comment

begin_define
define|#
directive|define
name|MAXREPLIES
value|32
end_define

begin_comment
comment|/* max. number of reply strings */
end_comment

begin_comment
comment|/* **  SMFI_HEADER -- send a header to the MTA ** **	Parameters: **		ctx -- Opaque context structure **		cmd -- Header modification command **		hdridx -- Header index **		headerf -- Header field name **		headerv -- Header field value ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
specifier|static
name|int
name|smfi_header
parameter_list|(
name|ctx
parameter_list|,
name|cmd
parameter_list|,
name|hdridx
parameter_list|,
name|headerf
parameter_list|,
name|headerv
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|hdridx
decl_stmt|;
name|char
modifier|*
name|headerf
decl_stmt|;
name|char
modifier|*
name|headerv
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|,
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|r
decl_stmt|;
name|mi_int32
name|v
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
if|if
condition|(
name|headerf
operator|==
name|NULL
operator|||
operator|*
name|headerf
operator|==
literal|'\0'
operator|||
name|headerv
operator|==
name|NULL
condition|)
return|return
name|MI_FAILURE
return|;
name|timeout
operator|.
name|tv_sec
operator|=
name|ctx
operator|->
name|ctx_timeout
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|l1
operator|=
name|strlen
argument_list|(
name|headerf
argument_list|)
operator|+
literal|1
expr_stmt|;
name|l2
operator|=
name|strlen
argument_list|(
name|headerv
argument_list|)
operator|+
literal|1
expr_stmt|;
name|len
operator|=
name|l1
operator|+
name|l2
expr_stmt|;
if|if
condition|(
name|hdridx
operator|>=
literal|0
condition|)
name|len
operator|+=
name|MILTER_LEN_BYTES
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|MI_FAILURE
return|;
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdridx
operator|>=
literal|0
condition|)
block|{
name|v
operator|=
name|htonl
argument_list|(
name|hdridx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|&
operator|(
name|buf
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|v
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|MILTER_LEN_BYTES
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
name|headerf
argument_list|,
name|l1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|buf
operator|+
name|offset
operator|+
name|l1
argument_list|,
name|headerv
argument_list|,
name|l2
argument_list|)
expr_stmt|;
name|r
operator|=
name|mi_wr_cmd
argument_list|(
name|ctx
operator|->
name|ctx_sd
argument_list|,
operator|&
name|timeout
argument_list|,
name|cmd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_ADDHEADER -- send a new header to the MTA ** **	Parameters: **		ctx -- Opaque context structure **		headerf -- Header field name **		headerv -- Header field value ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
name|smfi_addheader
parameter_list|(
name|ctx
parameter_list|,
name|headerf
parameter_list|,
name|headerv
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
name|char
modifier|*
name|headerf
decl_stmt|;
name|char
modifier|*
name|headerv
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|mi_sendok
argument_list|(
name|ctx
argument_list|,
name|SMFIF_ADDHDRS
argument_list|)
condition|)
return|return
name|MI_FAILURE
return|;
return|return
name|smfi_header
argument_list|(
name|ctx
argument_list|,
name|SMFIR_ADDHEADER
argument_list|,
operator|-
literal|1
argument_list|,
name|headerf
argument_list|,
name|headerv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_INSHEADER -- send a new header to the MTA (to be inserted) ** **	Parameters: **		ctx -- Opaque context structure **  		hdridx -- index into header list where insertion should occur **		headerf -- Header field name **		headerv -- Header field value ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
name|smfi_insheader
parameter_list|(
name|ctx
parameter_list|,
name|hdridx
parameter_list|,
name|headerf
parameter_list|,
name|headerv
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
name|int
name|hdridx
decl_stmt|;
name|char
modifier|*
name|headerf
decl_stmt|;
name|char
modifier|*
name|headerv
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|mi_sendok
argument_list|(
name|ctx
argument_list|,
name|SMFIF_ADDHDRS
argument_list|)
operator|||
name|hdridx
operator|<
literal|0
condition|)
return|return
name|MI_FAILURE
return|;
return|return
name|smfi_header
argument_list|(
name|ctx
argument_list|,
name|SMFIR_INSHEADER
argument_list|,
name|hdridx
argument_list|,
name|headerf
argument_list|,
name|headerv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_CHGHEADER -- send a changed header to the MTA ** **	Parameters: **		ctx -- Opaque context structure **		headerf -- Header field name **		hdridx -- Header index value **		headerv -- Header field value ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
name|smfi_chgheader
parameter_list|(
name|ctx
parameter_list|,
name|headerf
parameter_list|,
name|hdridx
parameter_list|,
name|headerv
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
name|char
modifier|*
name|headerf
decl_stmt|;
name|mi_int32
name|hdridx
decl_stmt|;
name|char
modifier|*
name|headerv
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|mi_sendok
argument_list|(
name|ctx
argument_list|,
name|SMFIF_CHGHDRS
argument_list|)
operator|||
name|hdridx
operator|<
literal|0
condition|)
return|return
name|MI_FAILURE
return|;
if|if
condition|(
name|headerv
operator|==
name|NULL
condition|)
name|headerv
operator|=
literal|""
expr_stmt|;
return|return
name|smfi_header
argument_list|(
name|ctx
argument_list|,
name|SMFIR_CHGHEADER
argument_list|,
name|hdridx
argument_list|,
name|headerf
argument_list|,
name|headerv
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* **  BUF_CRT_SEND -- construct buffer to send from arguments ** **	Parameters: **		ctx -- Opaque context structure **		cmd -- command **		arg0 -- first argument **		argv -- list of arguments (NULL terminated) ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_endif
unit|static int buf_crt_send __P((SMFICTX *, int cmd, char *, char **));  static int buf_crt_send(ctx, cmd, arg0, argv) 	SMFICTX *ctx; 	int cmd; 	char *arg0; 	char **argv; { 	size_t len, l0, l1, offset; 	int r; 	char *buf, *arg, **argvl; 	struct timeval timeout;  	if (arg0 == NULL || *arg0 == '\0') 		return MI_FAILURE; 	timeout.tv_sec = ctx->ctx_timeout; 	timeout.tv_usec = 0; 	l0 = strlen(arg0) + 1; 	len = l0; 	argvl = argv; 	while (argvl != NULL&& (arg = *argv) != NULL&& *arg != '\0') 	{ 		l1 = strlen(arg) + 1; 		len += l1; 		SM_ASSERT(len> l1); 	}  	buf = malloc(len); 	if (buf == NULL) 		return MI_FAILURE; 	(void) memcpy(buf, arg0, l0); 	offset = l0;  	argvl = argv; 	while (argvl != NULL&& (arg = *argv) != NULL&& *arg != '\0') 	{ 		l1 = strlen(arg) + 1; 		SM_ASSERT(offset< len); 		SM_ASSERT(offset + l1<= len); 		(void) memcpy(buf + offset, arg, l1); 		offset += l1; 		SM_ASSERT(offset> l1); 	}  	r = mi_wr_cmd(ctx->ctx_sd,&timeout, cmd, buf, len); 	free(buf); 	return r; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* **  SEND2 -- construct buffer to send from arguments ** **	Parameters: **		ctx -- Opaque context structure **		cmd -- command **		arg0 -- first argument **		argv -- list of arguments (NULL terminated) ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_decl_stmt
specifier|static
name|int
name|send2
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|,
name|int
name|cmd
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|send2
parameter_list|(
name|ctx
parameter_list|,
name|cmd
parameter_list|,
name|arg0
parameter_list|,
name|arg1
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|char
modifier|*
name|arg0
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|,
name|l0
decl_stmt|,
name|l1
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|r
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
if|if
condition|(
name|arg0
operator|==
name|NULL
operator|||
operator|*
name|arg0
operator|==
literal|'\0'
condition|)
return|return
name|MI_FAILURE
return|;
name|timeout
operator|.
name|tv_sec
operator|=
name|ctx
operator|->
name|ctx_timeout
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|l0
operator|=
name|strlen
argument_list|(
name|arg0
argument_list|)
operator|+
literal|1
expr_stmt|;
name|len
operator|=
name|l0
expr_stmt|;
if|if
condition|(
name|arg1
operator|!=
name|NULL
condition|)
block|{
name|l1
operator|=
name|strlen
argument_list|(
name|arg1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|len
operator|+=
name|l1
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|len
operator|>
name|l1
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|MI_FAILURE
return|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|buf
argument_list|,
name|arg0
argument_list|,
name|l0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|l0
expr_stmt|;
if|if
condition|(
name|arg1
operator|!=
name|NULL
condition|)
block|{
name|l1
operator|=
name|strlen
argument_list|(
name|arg1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|offset
operator|<
name|len
argument_list|)
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|offset
operator|+
name|l1
operator|<=
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
name|arg1
argument_list|,
name|l1
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|l1
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|offset
operator|>
name|l1
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|mi_wr_cmd
argument_list|(
name|ctx
operator|->
name|ctx_sd
argument_list|,
operator|&
name|timeout
argument_list|,
name|cmd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_CHGFROM -- change enveloper sender ("from") address ** **	Parameters: **		ctx -- Opaque context structure **		from -- new envelope sender address ("MAIL From") **		args -- ESMTP arguments ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
name|smfi_chgfrom
parameter_list|(
name|ctx
parameter_list|,
name|from
parameter_list|,
name|args
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
block|{
if|if
condition|(
name|from
operator|==
name|NULL
operator|||
operator|*
name|from
operator|==
literal|'\0'
condition|)
return|return
name|MI_FAILURE
return|;
if|if
condition|(
operator|!
name|mi_sendok
argument_list|(
name|ctx
argument_list|,
name|SMFIF_CHGFROM
argument_list|)
condition|)
return|return
name|MI_FAILURE
return|;
return|return
name|send2
argument_list|(
name|ctx
argument_list|,
name|SMFIR_CHGFROM
argument_list|,
name|from
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_SETSYMLIST -- set list of macros that the MTA should send. ** **	Parameters: **		ctx -- Opaque context structure **		where -- SMTP stage **		macros -- list of macros ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
name|smfi_setsymlist
parameter_list|(
name|ctx
parameter_list|,
name|where
parameter_list|,
name|macros
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
name|int
name|where
decl_stmt|;
name|char
modifier|*
name|macros
decl_stmt|;
block|{
name|SM_ASSERT
argument_list|(
name|ctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|macros
operator|==
name|NULL
operator|||
operator|*
name|macros
operator|==
literal|'\0'
condition|)
return|return
name|MI_FAILURE
return|;
if|if
condition|(
name|where
operator|<
name|SMFIM_FIRST
operator|||
name|where
operator|>
name|SMFIM_LAST
condition|)
return|return
name|MI_FAILURE
return|;
if|if
condition|(
name|where
operator|<
literal|0
operator|||
name|where
operator|>=
name|MAX_MACROS_ENTRIES
condition|)
return|return
name|MI_FAILURE
return|;
if|if
condition|(
name|ctx
operator|->
name|ctx_mac_list
index|[
name|where
index|]
operator|!=
name|NULL
condition|)
return|return
name|MI_FAILURE
return|;
name|ctx
operator|->
name|ctx_mac_list
index|[
name|where
index|]
operator|=
name|strdup
argument_list|(
name|macros
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ctx_mac_list
index|[
name|where
index|]
operator|==
name|NULL
condition|)
return|return
name|MI_FAILURE
return|;
return|return
name|MI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_ADDRCPT_PAR -- send an additional recipient to the MTA ** **	Parameters: **		ctx -- Opaque context structure **		rcpt -- recipient address **		args -- ESMTP arguments ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
name|smfi_addrcpt_par
parameter_list|(
name|ctx
parameter_list|,
name|rcpt
parameter_list|,
name|args
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
name|char
modifier|*
name|rcpt
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
block|{
if|if
condition|(
name|rcpt
operator|==
name|NULL
operator|||
operator|*
name|rcpt
operator|==
literal|'\0'
condition|)
return|return
name|MI_FAILURE
return|;
if|if
condition|(
operator|!
name|mi_sendok
argument_list|(
name|ctx
argument_list|,
name|SMFIF_ADDRCPT_PAR
argument_list|)
condition|)
return|return
name|MI_FAILURE
return|;
return|return
name|send2
argument_list|(
name|ctx
argument_list|,
name|SMFIR_ADDRCPT_PAR
argument_list|,
name|rcpt
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_ADDRCPT -- send an additional recipient to the MTA ** **	Parameters: **		ctx -- Opaque context structure **		rcpt -- recipient address ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
name|smfi_addrcpt
parameter_list|(
name|ctx
parameter_list|,
name|rcpt
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
name|char
modifier|*
name|rcpt
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
if|if
condition|(
name|rcpt
operator|==
name|NULL
operator|||
operator|*
name|rcpt
operator|==
literal|'\0'
condition|)
return|return
name|MI_FAILURE
return|;
if|if
condition|(
operator|!
name|mi_sendok
argument_list|(
name|ctx
argument_list|,
name|SMFIF_ADDRCPT
argument_list|)
condition|)
return|return
name|MI_FAILURE
return|;
name|timeout
operator|.
name|tv_sec
operator|=
name|ctx
operator|->
name|ctx_timeout
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|rcpt
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|mi_wr_cmd
argument_list|(
name|ctx
operator|->
name|ctx_sd
argument_list|,
operator|&
name|timeout
argument_list|,
name|SMFIR_ADDRCPT
argument_list|,
name|rcpt
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_DELRCPT -- send a recipient to be removed to the MTA ** **	Parameters: **		ctx -- Opaque context structure **		rcpt -- recipient address ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
name|smfi_delrcpt
parameter_list|(
name|ctx
parameter_list|,
name|rcpt
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
name|char
modifier|*
name|rcpt
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
if|if
condition|(
name|rcpt
operator|==
name|NULL
operator|||
operator|*
name|rcpt
operator|==
literal|'\0'
condition|)
return|return
name|MI_FAILURE
return|;
if|if
condition|(
operator|!
name|mi_sendok
argument_list|(
name|ctx
argument_list|,
name|SMFIF_DELRCPT
argument_list|)
condition|)
return|return
name|MI_FAILURE
return|;
name|timeout
operator|.
name|tv_sec
operator|=
name|ctx
operator|->
name|ctx_timeout
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|rcpt
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|mi_wr_cmd
argument_list|(
name|ctx
operator|->
name|ctx_sd
argument_list|,
operator|&
name|timeout
argument_list|,
name|SMFIR_DELRCPT
argument_list|,
name|rcpt
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_REPLACEBODY -- send a body chunk to the MTA ** **	Parameters: **		ctx -- Opaque context structure **		bodyp -- body chunk **		bodylen -- length of body chunk ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
name|smfi_replacebody
parameter_list|(
name|ctx
parameter_list|,
name|bodyp
parameter_list|,
name|bodylen
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bodyp
decl_stmt|;
name|int
name|bodylen
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|off
decl_stmt|,
name|r
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
if|if
condition|(
name|bodylen
operator|<
literal|0
operator|||
operator|(
name|bodyp
operator|==
name|NULL
operator|&&
name|bodylen
operator|>
literal|0
operator|)
condition|)
return|return
name|MI_FAILURE
return|;
if|if
condition|(
operator|!
name|mi_sendok
argument_list|(
name|ctx
argument_list|,
name|SMFIF_CHGBODY
argument_list|)
condition|)
return|return
name|MI_FAILURE
return|;
name|timeout
operator|.
name|tv_sec
operator|=
name|ctx
operator|->
name|ctx_timeout
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
comment|/* split body chunk if necessary */
name|off
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|len
operator|=
operator|(
name|bodylen
operator|>=
name|MILTER_CHUNK_SIZE
operator|)
condition|?
name|MILTER_CHUNK_SIZE
else|:
name|bodylen
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|mi_wr_cmd
argument_list|(
name|ctx
operator|->
name|ctx_sd
argument_list|,
operator|&
name|timeout
argument_list|,
name|SMFIR_REPLBODY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|bodyp
operator|+
name|off
operator|)
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
name|MI_SUCCESS
condition|)
return|return
name|r
return|;
name|off
operator|+=
name|len
expr_stmt|;
name|bodylen
operator|-=
name|len
expr_stmt|;
block|}
do|while
condition|(
name|bodylen
operator|>
literal|0
condition|)
do|;
return|return
name|MI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_QUARANTINE -- quarantine an envelope ** **	Parameters: **		ctx -- Opaque context structure **		reason -- why? ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
name|smfi_quarantine
parameter_list|(
name|ctx
parameter_list|,
name|reason
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
name|char
modifier|*
name|reason
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|int
name|r
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
if|if
condition|(
name|reason
operator|==
name|NULL
operator|||
operator|*
name|reason
operator|==
literal|'\0'
condition|)
return|return
name|MI_FAILURE
return|;
if|if
condition|(
operator|!
name|mi_sendok
argument_list|(
name|ctx
argument_list|,
name|SMFIF_QUARANTINE
argument_list|)
condition|)
return|return
name|MI_FAILURE
return|;
name|timeout
operator|.
name|tv_sec
operator|=
name|ctx
operator|->
name|ctx_timeout
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|reason
argument_list|)
operator|+
literal|1
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|MI_FAILURE
return|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|buf
argument_list|,
name|reason
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|r
operator|=
name|mi_wr_cmd
argument_list|(
name|ctx
operator|->
name|ctx_sd
argument_list|,
operator|&
name|timeout
argument_list|,
name|SMFIR_QUARANTINE
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* **  MYISENHSC -- check whether a string contains an enhanced status code ** **	Parameters: **		s -- string with possible enhanced status code. **		delim -- delim for enhanced status code. ** **	Returns: **		0  -- no enhanced status code. **>4 -- length of enhanced status code. ** **	Side Effects: **		none. */
end_comment

begin_function
specifier|static
name|int
name|myisenhsc
parameter_list|(
name|s
parameter_list|,
name|delim
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|delim
decl_stmt|;
block|{
name|int
name|l
decl_stmt|,
name|h
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|s
operator|==
literal|'2'
operator|||
operator|*
name|s
operator|==
literal|'4'
operator|||
operator|*
name|s
operator|==
literal|'5'
operator|)
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
return|return
literal|0
return|;
name|h
operator|=
literal|0
expr_stmt|;
name|l
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|h
operator|<
literal|3
operator|&&
name|isascii
argument_list|(
name|s
index|[
name|l
operator|+
name|h
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|s
index|[
name|l
operator|+
name|h
index|]
argument_list|)
condition|)
operator|++
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|==
literal|0
operator|||
name|s
index|[
name|l
operator|+
name|h
index|]
operator|!=
literal|'.'
condition|)
return|return
literal|0
return|;
name|l
operator|+=
name|h
operator|+
literal|1
expr_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|h
operator|<
literal|3
operator|&&
name|isascii
argument_list|(
name|s
index|[
name|l
operator|+
name|h
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|s
index|[
name|l
operator|+
name|h
index|]
argument_list|)
condition|)
operator|++
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|==
literal|0
operator|||
name|s
index|[
name|l
operator|+
name|h
index|]
operator|!=
name|delim
condition|)
return|return
literal|0
return|;
return|return
name|l
operator|+
name|h
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_SETREPLY -- set the reply code for the next reply to the MTA ** **	Parameters: **		ctx -- Opaque context structure **		rcode -- The three-digit (RFC 821) SMTP reply code. **		xcode -- The extended (RFC 2034) reply code. **		message -- The text part of the SMTP reply. ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
name|smfi_setreply
parameter_list|(
name|ctx
parameter_list|,
name|rcode
parameter_list|,
name|xcode
parameter_list|,
name|message
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
name|char
modifier|*
name|rcode
decl_stmt|;
name|char
modifier|*
name|xcode
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|rcode
operator|==
name|NULL
operator|||
name|ctx
operator|==
name|NULL
condition|)
return|return
name|MI_FAILURE
return|;
comment|/* ###<sp> \0 */
name|len
operator|=
name|strlen
argument_list|(
name|rcode
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|5
condition|)
return|return
name|MI_FAILURE
return|;
if|if
condition|(
operator|(
name|rcode
index|[
literal|0
index|]
operator|!=
literal|'4'
operator|&&
name|rcode
index|[
literal|0
index|]
operator|!=
literal|'5'
operator|)
operator|||
operator|!
name|isascii
argument_list|(
name|rcode
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|rcode
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isascii
argument_list|(
name|rcode
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|rcode
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
name|MI_FAILURE
return|;
if|if
condition|(
name|xcode
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|myisenhsc
argument_list|(
name|xcode
argument_list|,
literal|'\0'
argument_list|)
condition|)
return|return
name|MI_FAILURE
return|;
name|len
operator|+=
name|strlen
argument_list|(
name|xcode
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|ml
decl_stmt|;
comment|/* XXX check also for unprintable chars? */
if|if
condition|(
name|strpbrk
argument_list|(
name|message
argument_list|,
literal|"\r\n"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|MI_FAILURE
return|;
name|ml
operator|=
name|strlen
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|ml
operator|>
name|MAXREPLYLEN
condition|)
return|return
name|MI_FAILURE
return|;
name|len
operator|+=
name|ml
operator|+
literal|1
expr_stmt|;
block|}
name|buf
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|MI_FAILURE
return|;
comment|/* oops */
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|buf
argument_list|,
name|rcode
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|xcode
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|buf
argument_list|,
name|xcode
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|xcode
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|buf
argument_list|,
name|message
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|ctx_reply
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ctx
operator|->
name|ctx_reply
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ctx_reply
operator|=
name|buf
expr_stmt|;
return|return
name|MI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_SETMLREPLY -- set multiline reply code for the next reply to the MTA ** **	Parameters: **		ctx -- Opaque context structure **		rcode -- The three-digit (RFC 821) SMTP reply code. **		xcode -- The extended (RFC 2034) reply code. **		txt, ... -- The text part of the SMTP reply, **			MUST be terminated with NULL. ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
if|#
directive|if
name|SM_VA_STD
name|smfi_setmlreply
parameter_list|(
name|SMFICTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|rcode
parameter_list|,
specifier|const
name|char
modifier|*
name|xcode
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/* SM_VA_STD */
function|smfi_setmlreply
parameter_list|(
name|ctx
parameter_list|,
name|rcode
parameter_list|,
name|xcode
parameter_list|,
name|va_alist
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|rcode
decl_stmt|;
specifier|const
name|char
modifier|*
name|xcode
decl_stmt|;
function|va_dcl
endif|#
directive|endif
comment|/* SM_VA_STD */
block|{
name|size_t
name|len
decl_stmt|;
name|size_t
name|rlen
decl_stmt|;
name|int
name|args
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|txt
decl_stmt|;
specifier|const
name|char
modifier|*
name|xc
decl_stmt|;
name|char
name|repl
index|[
literal|16
index|]
decl_stmt|;
name|SM_VA_LOCAL_DECL
if|if
condition|(
name|rcode
operator|==
name|NULL
operator|||
name|ctx
operator|==
name|NULL
condition|)
return|return
name|MI_FAILURE
return|;
comment|/* ###<sp> */
name|len
operator|=
name|strlen
argument_list|(
name|rcode
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|4
condition|)
return|return
name|MI_FAILURE
return|;
if|if
condition|(
operator|(
name|rcode
index|[
literal|0
index|]
operator|!=
literal|'4'
operator|&&
name|rcode
index|[
literal|0
index|]
operator|!=
literal|'5'
operator|)
operator|||
operator|!
name|isascii
argument_list|(
name|rcode
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|rcode
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isascii
argument_list|(
name|rcode
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|rcode
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
name|MI_FAILURE
return|;
if|if
condition|(
name|xcode
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|myisenhsc
argument_list|(
name|xcode
argument_list|,
literal|'\0'
argument_list|)
condition|)
return|return
name|MI_FAILURE
return|;
name|xc
operator|=
name|xcode
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rcode
index|[
literal|0
index|]
operator|==
literal|'4'
condition|)
name|xc
operator|=
literal|"4.0.0"
expr_stmt|;
else|else
name|xc
operator|=
literal|"5.0.0"
expr_stmt|;
block|}
comment|/* add trailing space */
name|len
operator|+=
name|strlen
argument_list|(
name|xc
argument_list|)
operator|+
literal|1
expr_stmt|;
name|rlen
operator|=
name|len
expr_stmt|;
name|args
operator|=
literal|0
expr_stmt|;
name|SM_VA_START
argument_list|(
name|ap
argument_list|,
name|xcode
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|txt
operator|=
name|SM_VA_ARG
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|tl
decl_stmt|;
name|tl
operator|=
name|strlen
argument_list|(
name|txt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tl
operator|>
name|MAXREPLYLEN
condition|)
break|break;
comment|/* this text, reply codes, \r\n */
name|len
operator|+=
name|tl
operator|+
literal|2
operator|+
name|rlen
expr_stmt|;
if|if
condition|(
operator|++
name|args
operator|>
name|MAXREPLIES
condition|)
break|break;
comment|/* XXX check also for unprintable chars? */
if|if
condition|(
name|strpbrk
argument_list|(
name|txt
argument_list|,
literal|"\r\n"
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
name|SM_VA_END
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|txt
operator|!=
name|NULL
condition|)
return|return
name|MI_FAILURE
return|;
comment|/* trailing '\0' */
operator|++
name|len
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|MI_FAILURE
return|;
comment|/* oops */
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|3
argument_list|,
name|rcode
argument_list|,
name|args
operator|==
literal|1
condition|?
literal|" "
else|:
literal|"-"
argument_list|,
name|xc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|repl
argument_list|,
sizeof|sizeof
name|repl
argument_list|,
literal|4
argument_list|,
name|rcode
argument_list|,
name|args
operator|==
literal|1
condition|?
literal|" "
else|:
literal|"-"
argument_list|,
name|xc
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|SM_VA_START
argument_list|(
name|ap
argument_list|,
name|xcode
argument_list|)
expr_stmt|;
name|txt
operator|=
name|SM_VA_ARG
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|txt
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcat2
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|,
name|txt
argument_list|,
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|txt
operator|=
name|SM_VA_ARG
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|--
name|args
operator|<=
literal|1
condition|)
name|repl
index|[
literal|3
index|]
operator|=
literal|' '
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcat2
argument_list|(
name|buf
argument_list|,
literal|"\r\n"
argument_list|,
name|repl
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|buf
argument_list|,
name|txt
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ctx
operator|->
name|ctx_reply
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ctx
operator|->
name|ctx_reply
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ctx_reply
operator|=
name|buf
expr_stmt|;
name|SM_VA_END
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|MI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_SETPRIV -- set private data ** **	Parameters: **		ctx -- Opaque context structure **		privatedata -- pointer to private data ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
name|smfi_setpriv
parameter_list|(
name|ctx
parameter_list|,
name|privatedata
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
name|void
modifier|*
name|privatedata
decl_stmt|;
block|{
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
name|MI_FAILURE
return|;
name|ctx
operator|->
name|ctx_privdata
operator|=
name|privatedata
expr_stmt|;
return|return
name|MI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_GETPRIV -- get private data ** **	Parameters: **		ctx -- Opaque context structure ** **	Returns: **		pointer to private data */
end_comment

begin_function
name|void
modifier|*
name|smfi_getpriv
parameter_list|(
name|ctx
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
block|{
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|ctx
operator|->
name|ctx_privdata
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_GETSYMVAL -- get the value of a macro ** **	See explanation in mfapi.h about layout of the structures. ** **	Parameters: **		ctx -- Opaque context structure **		symname -- name of macro ** **	Returns: **		value of macro (NULL in case of failure) */
end_comment

begin_function
name|char
modifier|*
name|smfi_getsymval
parameter_list|(
name|ctx
parameter_list|,
name|symname
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
name|char
modifier|*
name|symname
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
name|char
name|one
index|[
literal|2
index|]
decl_stmt|;
name|char
name|braces
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
operator|||
name|symname
operator|==
name|NULL
operator|||
operator|*
name|symname
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|strlen
argument_list|(
name|symname
argument_list|)
operator|==
literal|3
operator|&&
name|symname
index|[
literal|0
index|]
operator|==
literal|'{'
operator|&&
name|symname
index|[
literal|2
index|]
operator|==
literal|'}'
condition|)
block|{
name|one
index|[
literal|0
index|]
operator|=
name|symname
index|[
literal|1
index|]
expr_stmt|;
name|one
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|one
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|symname
argument_list|)
operator|==
literal|1
condition|)
block|{
name|braces
index|[
literal|0
index|]
operator|=
literal|'{'
expr_stmt|;
name|braces
index|[
literal|1
index|]
operator|=
operator|*
name|symname
expr_stmt|;
name|braces
index|[
literal|2
index|]
operator|=
literal|'}'
expr_stmt|;
name|braces
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|braces
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* search backwards through the macro array */
for|for
control|(
name|i
operator|=
name|MAX_MACROS_ENTRIES
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|ctx
operator|->
name|ctx_mac_ptr
index|[
name|i
index|]
operator|)
operator|==
name|NULL
operator|||
name|ctx
operator|->
name|ctx_mac_buf
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
while|while
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|*
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|s
argument_list|,
name|symname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|*
operator|++
name|s
return|;
if|if
condition|(
name|one
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|strcmp
argument_list|(
operator|*
name|s
argument_list|,
name|one
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|*
operator|++
name|s
return|;
if|if
condition|(
name|braces
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|strcmp
argument_list|(
operator|*
name|s
argument_list|,
name|braces
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|*
operator|++
name|s
return|;
operator|++
name|s
expr_stmt|;
comment|/* skip over macro value */
operator|++
name|s
expr_stmt|;
comment|/* points to next macro name */
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_PROGRESS -- send "progress" message to the MTA to prevent premature **		     timeouts during long milter-side operations ** **	Parameters: **		ctx -- Opaque context structure ** **	Return value: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
name|smfi_progress
parameter_list|(
name|ctx
parameter_list|)
name|SMFICTX
modifier|*
name|ctx
decl_stmt|;
block|{
name|struct
name|timeval
name|timeout
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
name|MI_FAILURE
return|;
name|timeout
operator|.
name|tv_sec
operator|=
name|ctx
operator|->
name|ctx_timeout
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
return|return
name|mi_wr_cmd
argument_list|(
name|ctx
operator|->
name|ctx_sd
argument_list|,
operator|&
name|timeout
argument_list|,
name|SMFIR_PROGRESS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SMFI_VERSION -- return (runtime) version of libmilter ** **	Parameters: **		major -- (pointer to) major version **		minor -- (pointer to) minor version **		patchlevel -- (pointer to) patchlevel version ** **	Return value: **		MI_SUCCESS */
end_comment

begin_function
name|int
name|smfi_version
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|,
name|patchlevel
parameter_list|)
name|unsigned
name|int
modifier|*
name|major
decl_stmt|;
name|unsigned
name|int
modifier|*
name|minor
decl_stmt|;
name|unsigned
name|int
modifier|*
name|patchlevel
decl_stmt|;
block|{
if|if
condition|(
name|major
operator|!=
name|NULL
condition|)
operator|*
name|major
operator|=
name|SM_LM_VRS_MAJOR
argument_list|(
name|SMFI_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|minor
operator|!=
name|NULL
condition|)
operator|*
name|minor
operator|=
name|SM_LM_VRS_MINOR
argument_list|(
name|SMFI_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|patchlevel
operator|!=
name|NULL
condition|)
operator|*
name|patchlevel
operator|=
name|SM_LM_VRS_PLVL
argument_list|(
name|SMFI_VERSION
argument_list|)
expr_stmt|;
return|return
name|MI_SUCCESS
return|;
block|}
end_function

end_unit

