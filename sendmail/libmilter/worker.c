begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 2003-2004, 2006 Sendmail, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  * Contributed by Jose Marcio Martins da Cruz - Ecole des Mines de Paris  *   Jose-Marcio.Martins@ensmp.fr  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: worker.c,v 8.9 2006/12/18 18:26:51 ca Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|"libmilter.h"
end_include

begin_if
if|#
directive|if
name|_FFR_WORKERS_POOL
end_if

begin_typedef
typedef|typedef
name|struct
name|taskmgr_S
name|taskmgr_T
typedef|;
end_typedef

begin_define
define|#
directive|define
name|TM_SIGNATURE
value|0x23021957
end_define

begin_struct
struct|struct
name|taskmgr_S
block|{
name|long
name|tm_signature
decl_stmt|;
comment|/* has the controller been initialized */
name|sthread_t
name|tm_tid
decl_stmt|;
comment|/* thread id of controller */
name|smfi_hd_T
name|tm_ctx_head
decl_stmt|;
comment|/* head of the linked list of contexts */
name|int
name|tm_nb_workers
decl_stmt|;
comment|/* number of workers in the pool */
name|int
name|tm_nb_idle
decl_stmt|;
comment|/* number of workers waiting */
name|int
name|tm_p
index|[
literal|2
index|]
decl_stmt|;
comment|/* poll control pipe */
name|smutex_t
name|tm_w_mutex
decl_stmt|;
comment|/* linked list access mutex */
name|scond_t
name|tm_w_cond
decl_stmt|;
comment|/* */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|taskmgr_T
name|Tskmgr
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WRK_CTX_HEAD
value|Tskmgr.tm_ctx_head
end_define

begin_define
define|#
directive|define
name|RD_PIPE
value|(Tskmgr.tm_p[0])
end_define

begin_define
define|#
directive|define
name|WR_PIPE
value|(Tskmgr.tm_p[1])
end_define

begin_define
define|#
directive|define
name|PIPE_SEND_SIGNAL
parameter_list|()
define|\
value|do								\ 	{								\ 		char evt = 0x5a;					\ 		int fd = WR_PIPE;					\ 		if (write(fd,&evt, sizeof(evt)) != sizeof(evt))	\ 			smi_log(SMI_LOG_ERR,				\ 				"Error writing to event pipe: %s",	\ 				sm_errstring(errno));			\ 	} while (0)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|USE_PIPE_WAKE_POLL
end_ifndef

begin_define
define|#
directive|define
name|USE_PIPE_WAKE_POLL
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_PIPE_WAKE_POLL */
end_comment

begin_comment
comment|/* poll check periodicity (default 10000 - 10 s) */
end_comment

begin_define
define|#
directive|define
name|POLL_TIMEOUT
value|10000
end_define

begin_comment
comment|/* worker conditional wait timeout (default 10 s) */
end_comment

begin_define
define|#
directive|define
name|COND_TIMEOUT
value|10
end_define

begin_comment
comment|/* functions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mi_close_session
name|__P
argument_list|(
operator|(
name|SMFICTX_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|mi_worker
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|mi_pool_controller
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mi_list_add_ctx
name|__P
argument_list|(
operator|(
name|SMFICTX_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mi_list_del_ctx
name|__P
argument_list|(
operator|(
name|SMFICTX_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  periodicity of cleaning up old sessions (timedout) **	sessions list will be checked to find old inactive **	sessions each DT_CHECK_OLD_SESSIONS sec */
end_comment

begin_define
define|#
directive|define
name|DT_CHECK_OLD_SESSIONS
value|600
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|OLD_SESSION_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|OLD_SESSION_TIMEOUT
value|ctx->ctx_timeout
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OLD_SESSION_TIMEOUT */
end_comment

begin_comment
comment|/* session states - with respect to the pool of workers */
end_comment

begin_define
define|#
directive|define
name|WKST_INIT
value|0
end_define

begin_comment
comment|/* initial state */
end_comment

begin_define
define|#
directive|define
name|WKST_READY_TO_RUN
value|1
end_define

begin_comment
comment|/* command ready do be read */
end_comment

begin_define
define|#
directive|define
name|WKST_RUNNING
value|2
end_define

begin_comment
comment|/* session running on a worker */
end_comment

begin_define
define|#
directive|define
name|WKST_READY_TO_WAIT
value|3
end_define

begin_comment
comment|/* session just finished by a worker */
end_comment

begin_define
define|#
directive|define
name|WKST_WAITING
value|4
end_define

begin_comment
comment|/* waiting for new command */
end_comment

begin_define
define|#
directive|define
name|WKST_CLOSING
value|5
end_define

begin_comment
comment|/* session finished */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIN_WORKERS
end_ifndef

begin_define
define|#
directive|define
name|MIN_WORKERS
value|2
end_define

begin_comment
comment|/* minimum number of threads to keep around */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MIN_IDLE
value|1
end_define

begin_comment
comment|/* minimum number of idle threads */
end_comment

begin_comment
comment|/* **  Macros for threads and mutex management */
end_comment

begin_define
define|#
directive|define
name|TASKMGR_LOCK
parameter_list|()
define|\
value|do								\ 	{								\ 		if (!smutex_lock(&Tskmgr.tm_w_mutex))			\ 			smi_log(SMI_LOG_ERR, "TASKMGR_LOCK error");	\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|TASKMGR_UNLOCK
parameter_list|()
define|\
value|do								\ 	{								\ 		if (!smutex_unlock(&Tskmgr.tm_w_mutex))			\ 			smi_log(SMI_LOG_ERR, "TASKMGR_UNLOCK error");	\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|TASKMGR_COND_WAIT
parameter_list|()
define|\
value|scond_timedwait(&Tskmgr.tm_w_cond,&Tskmgr.tm_w_mutex, COND_TIMEOUT)
end_define

begin_define
define|#
directive|define
name|TASKMGR_COND_SIGNAL
parameter_list|()
define|\
value|do								\ 	{								\ 		if (scond_signal(&Tskmgr.tm_w_cond) != 0)		\ 			smi_log(SMI_LOG_ERR, "TASKMGR_COND_SIGNAL error"); \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|LAUNCH_WORKER
parameter_list|(
name|ctx
parameter_list|)
define|\
value|do								\ 	{								\ 		int r;							\ 		sthread_t tid;						\ 									\ 		if ((r = thread_create(&tid, mi_worker, ctx)) != 0)	\ 			smi_log(SMI_LOG_ERR, "LAUNCH_WORKER error: %s",\ 				sm_errstring(r));			\ 	} while (0)
end_define

begin_if
if|#
directive|if
name|POOL_DEBUG
end_if

begin_define
define|#
directive|define
name|POOL_LEV_DPRINTF
parameter_list|(
name|lev
parameter_list|,
name|x
parameter_list|)
define|\
value|do {								\ 		if ((lev)< ctx->ctx_dbg)				\ 			sm_dprintf x;					\ 	} while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* POOL_DEBUG */
end_comment

begin_define
define|#
directive|define
name|POOL_LEV_DPRINTF
parameter_list|(
name|lev
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* POOL_DEBUG */
end_comment

begin_comment
comment|/* **  MI_START_SESSION -- Start a session in the pool of workers ** **	Parameters: **		ctx -- context structure ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
name|mi_start_session
parameter_list|(
name|ctx
parameter_list|)
name|SMFICTX_PTR
name|ctx
decl_stmt|;
block|{
specifier|static
name|long
name|id
init|=
literal|0
decl_stmt|;
name|SM_ASSERT
argument_list|(
name|Tskmgr
operator|.
name|tm_signature
operator|==
name|TM_SIGNATURE
argument_list|)
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|ctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|POOL_LEV_DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"PIPE r=[%d] w=[%d]"
operator|,
name|RD_PIPE
operator|,
name|WR_PIPE
operator|)
argument_list|)
expr_stmt|;
name|TASKMGR_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|mi_list_add_ctx
argument_list|(
name|ctx
argument_list|)
operator|!=
name|MI_SUCCESS
condition|)
block|{
name|TASKMGR_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|MI_FAILURE
return|;
block|}
name|ctx
operator|->
name|ctx_sid
operator|=
name|id
operator|++
expr_stmt|;
comment|/* if there is an idle worker, signal it, otherwise start new worker */
if|if
condition|(
name|Tskmgr
operator|.
name|tm_nb_idle
operator|>
literal|0
condition|)
block|{
name|ctx
operator|->
name|ctx_wstate
operator|=
name|WKST_READY_TO_RUN
expr_stmt|;
name|TASKMGR_COND_SIGNAL
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|ctx_wstate
operator|=
name|WKST_RUNNING
expr_stmt|;
name|LAUNCH_WORKER
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
name|TASKMGR_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|MI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* **  MI_CLOSE_SESSION -- Close a session and clean up data structures ** **	Parameters: **		ctx -- context structure ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
specifier|static
name|int
name|mi_close_session
parameter_list|(
name|ctx
parameter_list|)
name|SMFICTX_PTR
name|ctx
decl_stmt|;
block|{
name|SM_ASSERT
argument_list|(
name|ctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mi_list_del_ctx
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ValidSocket
argument_list|(
name|ctx
operator|->
name|ctx_sd
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|ctx
operator|->
name|ctx_sd
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ctx_sd
operator|=
name|INVALID_SOCKET
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|ctx_reply
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ctx
operator|->
name|ctx_reply
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ctx_reply
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|ctx_privdata
operator|!=
name|NULL
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_WARN
argument_list|,
literal|"%s: private data not NULL"
argument_list|,
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|)
expr_stmt|;
block|}
name|mi_clr_macros
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|MI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* **  MI_POOL_CONTROLER_INIT -- Launch the worker pool controller **		Must be called before starting sessions. ** **	Parameters: **		none ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
name|mi_pool_controller_init
parameter_list|()
block|{
name|sthread_t
name|tid
decl_stmt|;
name|int
name|r
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|Tskmgr
operator|.
name|tm_signature
operator|==
name|TM_SIGNATURE
condition|)
return|return
name|MI_SUCCESS
return|;
name|SM_TAILQ_INIT
argument_list|(
operator|&
name|WRK_CTX_HEAD
argument_list|)
expr_stmt|;
name|Tskmgr
operator|.
name|tm_tid
operator|=
operator|(
name|sthread_t
operator|)
operator|-
literal|1
expr_stmt|;
name|Tskmgr
operator|.
name|tm_nb_workers
operator|=
literal|0
expr_stmt|;
name|Tskmgr
operator|.
name|tm_nb_idle
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|Tskmgr
operator|.
name|tm_p
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"can't create event pipe: %s"
argument_list|,
name|sm_errstring
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MI_FAILURE
return|;
block|}
name|POOL_LEV_DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"PIPE r=[%d] w=[%d]"
operator|,
name|RD_PIPE
operator|,
name|WR_PIPE
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|smutex_init
argument_list|(
operator|&
name|Tskmgr
operator|.
name|tm_w_mutex
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|scond_init
argument_list|(
operator|&
name|Tskmgr
operator|.
name|tm_w_cond
argument_list|)
expr_stmt|;
comment|/* Launch the pool controller */
if|if
condition|(
operator|(
name|r
operator|=
name|thread_create
argument_list|(
operator|&
name|tid
argument_list|,
name|mi_pool_controller
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"can't create controller thread: %s"
argument_list|,
name|sm_errstring
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MI_FAILURE
return|;
block|}
name|Tskmgr
operator|.
name|tm_tid
operator|=
name|tid
expr_stmt|;
name|Tskmgr
operator|.
name|tm_signature
operator|=
name|TM_SIGNATURE
expr_stmt|;
comment|/* Create the pool of workers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MIN_WORKERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|thread_create
argument_list|(
operator|&
name|tid
argument_list|,
name|mi_worker
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"can't create workers crew: %s"
argument_list|,
name|sm_errstring
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MI_FAILURE
return|;
block|}
block|}
return|return
name|MI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* **  MI_POOL_CONTROLLER -- manage the pool of workers **	This thread must be running when listener begins **	starting sessions ** **	Parameters: **		arg -- unused ** **	Returns: **		NULL ** **	Control flow: **		for (;;) **			Look for timed out sessions **			Select sessions to wait for sendmail command **			Poll set of file descriptors **			if timeout **				continue **			For each file descriptor ready **				launch new thread if no worker available **				else **				signal waiting worker */
end_comment

begin_comment
comment|/* Poll structure array (pollfd) size step */
end_comment

begin_define
define|#
directive|define
name|PFD_STEP
value|256
end_define

begin_define
define|#
directive|define
name|WAIT_FD
parameter_list|(
name|i
parameter_list|)
value|(pfd[i].fd)
end_define

begin_define
define|#
directive|define
name|WAITFN
value|"POLL"
end_define

begin_function
specifier|static
name|void
modifier|*
name|mi_pool_controller
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|pollfd
modifier|*
name|pfd
init|=
name|NULL
decl_stmt|;
name|int
name|dim_pfd
init|=
literal|0
decl_stmt|;
name|bool
name|rebuild_set
init|=
name|true
decl_stmt|;
name|int
name|pcnt
init|=
literal|0
decl_stmt|;
comment|/* error count for poll() failures */
name|Tskmgr
operator|.
name|tm_tid
operator|=
name|sthread_get_id
argument_list|()
expr_stmt|;
if|if
condition|(
name|pthread_detach
argument_list|(
name|Tskmgr
operator|.
name|tm_tid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"Failed to detach pool controller thread"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pfd
operator|=
operator|(
expr|struct
name|pollfd
operator|*
operator|)
name|malloc
argument_list|(
name|PFD_STEP
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfd
operator|==
name|NULL
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"Failed to malloc pollfd array: %s"
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dim_pfd
operator|=
name|PFD_STEP
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|SMFICTX_PTR
name|ctx
decl_stmt|;
name|int
name|nfd
decl_stmt|,
name|rfd
decl_stmt|,
name|i
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|time_t
name|lastcheck
decl_stmt|;
name|POOL_LEV_DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Let's %s again..."
operator|,
name|WAITFN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi_stop
argument_list|()
operator|!=
name|MILTER_CONT
condition|)
break|break;
name|TASKMGR_LOCK
argument_list|()
expr_stmt|;
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* check for timed out sessions? */
if|if
condition|(
name|lastcheck
operator|+
name|DT_CHECK_OLD_SESSIONS
operator|<
name|now
condition|)
block|{
name|SM_TAILQ_FOREACH
argument_list|(
argument|ctx
argument_list|,
argument|&WRK_CTX_HEAD
argument_list|,
argument|ctx_link
argument_list|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ctx_wstate
operator|==
name|WKST_WAITING
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ctx_wait
operator|==
literal|0
condition|)
block|{
name|ctx
operator|->
name|ctx_wait
operator|=
name|now
expr_stmt|;
continue|continue;
block|}
comment|/* if session timed out, close it */
if|if
condition|(
name|ctx
operator|->
name|ctx_wait
operator|+
name|OLD_SESSION_TIMEOUT
operator|<
name|now
condition|)
block|{
name|sfsistat
argument_list|(
argument|*fi_close
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|)
argument_list|)
expr_stmt|;
name|POOL_LEV_DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Closing old connection: sd=%d id=%d"
operator|,
name|ctx
operator|->
name|ctx_sd
operator|,
name|ctx
operator|->
name|ctx_sid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fi_close
operator|=
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_close
operator|)
operator|!=
name|NULL
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|fi_close
argument_list|)
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|mi_close_session
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|SM_TAILQ_FIRST
argument_list|(
operator|&
name|WRK_CTX_HEAD
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|lastcheck
operator|=
name|now
expr_stmt|;
block|}
if|if
condition|(
name|rebuild_set
condition|)
block|{
comment|/* 			**  Initialize poll set. 			**  Insert into the poll set the file descriptors of 			**  all sessions waiting for a command from sendmail. 			*/
name|nfd
operator|=
literal|0
expr_stmt|;
comment|/* begin with worker pipe */
name|pfd
index|[
name|nfd
index|]
operator|.
name|fd
operator|=
name|RD_PIPE
expr_stmt|;
name|pfd
index|[
name|nfd
index|]
operator|.
name|events
operator|=
name|MI_POLL_RD_FLAGS
expr_stmt|;
name|pfd
index|[
name|nfd
index|]
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
name|nfd
operator|++
expr_stmt|;
name|SM_TAILQ_FOREACH
argument_list|(
argument|ctx
argument_list|,
argument|&WRK_CTX_HEAD
argument_list|,
argument|ctx_link
argument_list|)
block|{
comment|/* 				**  update ctx_wait - start of wait moment - 				**  for timeout 				*/
if|if
condition|(
name|ctx
operator|->
name|ctx_wstate
operator|==
name|WKST_READY_TO_WAIT
condition|)
name|ctx
operator|->
name|ctx_wait
operator|=
name|now
expr_stmt|;
comment|/* add the session to the pollfd array? */
if|if
condition|(
operator|(
name|ctx
operator|->
name|ctx_wstate
operator|==
name|WKST_READY_TO_WAIT
operator|)
operator|||
operator|(
name|ctx
operator|->
name|ctx_wstate
operator|==
name|WKST_WAITING
operator|)
condition|)
block|{
comment|/* 					**  Resize the pollfd array if it 					**  isn't large enough. 					*/
if|if
condition|(
name|nfd
operator|>=
name|dim_pfd
condition|)
block|{
name|struct
name|pollfd
modifier|*
name|tpfd
decl_stmt|;
name|size_t
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|dim_pfd
operator|+
name|PFD_STEP
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tpfd
argument_list|)
expr_stmt|;
name|tpfd
operator|=
operator|(
expr|struct
name|pollfd
operator|*
operator|)
name|realloc
argument_list|(
name|pfd
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpfd
operator|!=
name|NULL
condition|)
block|{
name|pfd
operator|=
name|tpfd
expr_stmt|;
name|dim_pfd
operator|+=
name|PFD_STEP
expr_stmt|;
block|}
else|else
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"Failed to realloc pollfd array:%s"
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* add the session to pollfd array */
if|if
condition|(
name|nfd
operator|<
name|dim_pfd
condition|)
block|{
name|ctx
operator|->
name|ctx_wstate
operator|=
name|WKST_WAITING
expr_stmt|;
name|pfd
index|[
name|nfd
index|]
operator|.
name|fd
operator|=
name|ctx
operator|->
name|ctx_sd
expr_stmt|;
name|pfd
index|[
name|nfd
index|]
operator|.
name|events
operator|=
name|MI_POLL_RD_FLAGS
expr_stmt|;
name|pfd
index|[
name|nfd
index|]
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
name|nfd
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
name|TASKMGR_UNLOCK
argument_list|()
expr_stmt|;
comment|/* Everything is ready, let's wait for an event */
name|rfd
operator|=
name|poll
argument_list|(
name|pfd
argument_list|,
name|nfd
argument_list|,
name|POLL_TIMEOUT
argument_list|)
expr_stmt|;
name|POOL_LEV_DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%s returned: at epoch %d value %d"
operator|,
name|WAITFN
operator|,
name|now
operator|,
name|nfd
operator|)
argument_list|)
expr_stmt|;
comment|/* timeout */
if|if
condition|(
name|rfd
operator|==
literal|0
condition|)
continue|continue;
name|rebuild_set
operator|=
name|true
expr_stmt|;
comment|/* error */
if|if
condition|(
name|rfd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|pcnt
operator|++
expr_stmt|;
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s() failed (%s), %s"
argument_list|,
name|WAITFN
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|,
name|pcnt
operator|>=
name|MAX_FAILS_S
condition|?
literal|"abort"
else|:
literal|"try again"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcnt
operator|>=
name|MAX_FAILS_S
condition|)
goto|goto
name|err
goto|;
block|}
name|pcnt
operator|=
literal|0
expr_stmt|;
comment|/* something happened */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfd
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pfd
index|[
name|i
index|]
operator|.
name|revents
operator|==
literal|0
condition|)
continue|continue;
name|POOL_LEV_DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"%s event on pfd[%d/%d]=%d "
operator|,
name|WAITFN
operator|,
name|i
operator|,
name|nfd
operator|,
name|WAIT_FD
argument_list|(
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* has a worker signaled an end of task ? */
if|if
condition|(
name|WAIT_FD
argument_list|(
name|i
argument_list|)
operator|==
name|RD_PIPE
condition|)
block|{
name|char
name|evt
init|=
literal|0
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|POOL_LEV_DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"PIPE WILL READ evt = %08X %08X"
operator|,
name|pfd
index|[
name|i
index|]
operator|.
name|events
operator|,
name|pfd
index|[
name|i
index|]
operator|.
name|revents
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pfd
index|[
name|i
index|]
operator|.
name|revents
operator|&
name|MI_POLL_RD_FLAGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|read
argument_list|(
name|RD_PIPE
argument_list|,
operator|&
name|evt
argument_list|,
sizeof|sizeof
argument_list|(
name|evt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
sizeof|sizeof
argument_list|(
name|evt
argument_list|)
condition|)
block|{
comment|/* Do nothing */
block|}
block|}
name|POOL_LEV_DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"PIPE DONE READ i=[%d] fd=[%d] r=[%d] evt=[%d]"
operator|,
name|i
operator|,
name|RD_PIPE
operator|,
name|r
operator|,
name|evt
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pfd
index|[
name|i
index|]
operator|.
name|revents
operator|&
operator|~
name|MI_POLL_RD_FLAGS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Exception handling */
block|}
continue|continue;
block|}
comment|/* no ! sendmail wants to send a command */
name|SM_TAILQ_FOREACH
argument_list|(
argument|ctx
argument_list|,
argument|&WRK_CTX_HEAD
argument_list|,
argument|ctx_link
argument_list|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ctx_wstate
operator|!=
name|WKST_WAITING
condition|)
continue|continue;
name|POOL_LEV_DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"Checking context sd=%d - fd=%d "
operator|,
name|ctx
operator|->
name|ctx_sd
operator|,
name|WAIT_FD
argument_list|(
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ctx_sd
operator|==
name|pfd
index|[
name|i
index|]
operator|.
name|fd
condition|)
block|{
name|TASKMGR_LOCK
argument_list|()
expr_stmt|;
name|POOL_LEV_DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"TASK: found %d for fd[%d]=%d"
operator|,
name|ctx
operator|->
name|ctx_sid
operator|,
name|i
operator|,
name|WAIT_FD
argument_list|(
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tskmgr
operator|.
name|tm_nb_idle
operator|>
literal|0
condition|)
block|{
name|ctx
operator|->
name|ctx_wstate
operator|=
name|WKST_READY_TO_RUN
expr_stmt|;
name|TASKMGR_COND_SIGNAL
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|ctx_wstate
operator|=
name|WKST_RUNNING
expr_stmt|;
name|LAUNCH_WORKER
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
name|TASKMGR_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|POOL_LEV_DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"TASK %s FOUND - Checking PIPE for fd[%d]"
operator|,
name|ctx
operator|!=
name|NULL
condition|?
literal|""
else|:
literal|"NOT"
operator|,
name|WAIT_FD
argument_list|(
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|err
label|:
if|if
condition|(
name|pfd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|pfd
argument_list|)
expr_stmt|;
name|Tskmgr
operator|.
name|tm_signature
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|SMFICTX_PTR
name|ctx
decl_stmt|;
name|ctx
operator|=
name|SM_TAILQ_FIRST
argument_list|(
operator|&
name|WRK_CTX_HEAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
break|break;
name|mi_close_session
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|smutex_destroy
argument_list|(
operator|&
name|Tskmgr
operator|.
name|tm_w_mutex
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|scond_destroy
argument_list|(
operator|&
name|Tskmgr
operator|.
name|tm_w_cond
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Look for a task ready to run. **  Value of ctx is NULL or a pointer to a task ready to run. */
end_comment

begin_define
define|#
directive|define
name|GET_TASK_READY_TO_RUN
parameter_list|()
define|\
value|SM_TAILQ_FOREACH(ctx,&WRK_CTX_HEAD, ctx_link)		\ 	{							\ 		if (ctx->ctx_wstate == WKST_READY_TO_RUN)	\ 		{						\ 			ctx->ctx_wstate = WKST_RUNNING;		\ 			break;					\ 		}						\ 	}
end_define

begin_comment
comment|/* **  MI_WORKER -- worker thread **	executes tasks distributed by the mi_pool_controller **	or by mi_start_session ** **	Parameters: **		arg -- pointer to context structure ** **	Returns: **		NULL pointer */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|mi_worker
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|SMFICTX_PTR
name|ctx
decl_stmt|;
name|bool
name|done
decl_stmt|;
name|sthread_t
name|t_id
decl_stmt|;
name|int
name|r
decl_stmt|;
name|ctx
operator|=
operator|(
name|SMFICTX_PTR
operator|)
name|arg
expr_stmt|;
name|done
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|ctx
operator|!=
name|NULL
condition|)
name|ctx
operator|->
name|ctx_wstate
operator|=
name|WKST_RUNNING
expr_stmt|;
name|t_id
operator|=
name|sthread_get_id
argument_list|()
expr_stmt|;
if|if
condition|(
name|pthread_detach
argument_list|(
name|t_id
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"Failed to detach worker thread"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|!=
name|NULL
condition|)
name|ctx
operator|->
name|ctx_wstate
operator|=
name|WKST_READY_TO_RUN
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|TASKMGR_LOCK
argument_list|()
expr_stmt|;
name|Tskmgr
operator|.
name|tm_nb_workers
operator|++
expr_stmt|;
name|TASKMGR_UNLOCK
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|mi_stop
argument_list|()
operator|!=
name|MILTER_CONT
condition|)
break|break;
comment|/* let's handle next task... */
if|if
condition|(
name|ctx
operator|!=
name|NULL
condition|)
block|{
name|int
name|res
decl_stmt|;
name|POOL_LEV_DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"worker %d: new task -> let's handle it"
operator|,
name|t_id
operator|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|mi_engine
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|POOL_LEV_DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"worker %d: mi_engine returned %d"
operator|,
name|t_id
operator|,
name|res
operator|)
argument_list|)
expr_stmt|;
name|TASKMGR_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|MI_CONTINUE
condition|)
block|{
name|ctx
operator|->
name|ctx_wstate
operator|=
name|WKST_CLOSING
expr_stmt|;
comment|/* 				**  Delete context from linked list of 				**  sessions and close session. 				*/
name|mi_close_session
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|ctx_wstate
operator|=
name|WKST_READY_TO_WAIT
expr_stmt|;
name|POOL_LEV_DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"writing to event pipe..."
operator|)
argument_list|)
expr_stmt|;
comment|/* 				**  Signal task controller to add new session 				**  to poll set. 				*/
name|PIPE_SEND_SIGNAL
argument_list|()
expr_stmt|;
block|}
name|TASKMGR_UNLOCK
argument_list|()
expr_stmt|;
name|ctx
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* check if there is any task waiting to be served */
name|TASKMGR_LOCK
argument_list|()
expr_stmt|;
name|GET_TASK_READY_TO_RUN
argument_list|()
expr_stmt|;
comment|/* Got a task? */
if|if
condition|(
name|ctx
operator|!=
name|NULL
condition|)
block|{
name|TASKMGR_UNLOCK
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* 		**  if not, let's check if there is enough idle workers 		**	if yes: quit 		*/
if|if
condition|(
name|Tskmgr
operator|.
name|tm_nb_workers
operator|>
name|MIN_WORKERS
operator|&&
name|Tskmgr
operator|.
name|tm_nb_idle
operator|>
name|MIN_IDLE
condition|)
name|done
operator|=
name|true
expr_stmt|;
name|POOL_LEV_DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"worker %d: checking ... %d %d"
operator|,
name|t_id
operator|,
name|Tskmgr
operator|.
name|tm_nb_workers
operator|,
name|Tskmgr
operator|.
name|tm_nb_idle
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
block|{
name|POOL_LEV_DPRINTF
argument_list|(
literal|4
argument_list|,
operator|(
literal|"worker %d: quitting... "
operator|,
name|t_id
operator|)
argument_list|)
expr_stmt|;
name|Tskmgr
operator|.
name|tm_nb_workers
operator|--
expr_stmt|;
name|TASKMGR_UNLOCK
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* 		**  if no task ready to run, wait for another one 		*/
name|Tskmgr
operator|.
name|tm_nb_idle
operator|++
expr_stmt|;
name|TASKMGR_COND_WAIT
argument_list|()
expr_stmt|;
name|Tskmgr
operator|.
name|tm_nb_idle
operator|--
expr_stmt|;
comment|/* look for a task */
name|GET_TASK_READY_TO_RUN
argument_list|()
expr_stmt|;
name|TASKMGR_UNLOCK
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  MI_LIST_ADD_CTX -- add new session to linked list ** **	Parameters: **		ctx -- context structure ** **	Returns: **		MI_FAILURE/MI_SUCCESS */
end_comment

begin_function
specifier|static
name|int
name|mi_list_add_ctx
parameter_list|(
name|ctx
parameter_list|)
name|SMFICTX_PTR
name|ctx
decl_stmt|;
block|{
name|SM_ASSERT
argument_list|(
name|ctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SM_TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|WRK_CTX_HEAD
argument_list|,
name|ctx
argument_list|,
name|ctx_link
argument_list|)
expr_stmt|;
return|return
name|MI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* **  MI_LIST_DEL_CTX -- remove session from linked list when finished ** **	Parameters: **		ctx -- context structure ** **	Returns: **		MI_FAILURE/MI_SUCCESS */
end_comment

begin_function
specifier|static
name|int
name|mi_list_del_ctx
parameter_list|(
name|ctx
parameter_list|)
name|SMFICTX_PTR
name|ctx
decl_stmt|;
block|{
name|SM_ASSERT
argument_list|(
name|ctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SM_TAILQ_EMPTY
argument_list|(
operator|&
name|WRK_CTX_HEAD
argument_list|)
condition|)
return|return
name|MI_FAILURE
return|;
name|SM_TAILQ_REMOVE
argument_list|(
operator|&
name|WRK_CTX_HEAD
argument_list|,
name|ctx
argument_list|,
name|ctx_link
argument_list|)
expr_stmt|;
return|return
name|MI_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_WORKERS_POOL */
end_comment

end_unit

