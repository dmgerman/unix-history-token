begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2003, 2007 Sendmail, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: config.c,v 1.31 2007/03/14 21:21:49 ca Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sm/heap.h>
end_include

begin_include
include|#
directive|include
file|<sm/string.h>
end_include

begin_include
include|#
directive|include
file|<sm/conf.h>
end_include

begin_comment
comment|/* **  PUTENV -- emulation of putenv() in terms of setenv() ** **	Not needed on Posix-compliant systems. **	This doesn't have full Posix semantics, but it's good enough **		for sendmail. ** **	Parameter: **		env -- the environment to put. ** **	Returns: **		0 on success,< 0 on failure. */
end_comment

begin_if
if|#
directive|if
name|NEEDPUTENV
end_if

begin_if
if|#
directive|if
name|NEEDPUTENV
operator|==
literal|2
end_if

begin_comment
comment|/* no setenv(3) call available */
end_comment

begin_function
name|int
name|putenv
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|current
decl_stmt|;
name|int
name|matchlen
decl_stmt|,
name|envlen
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|char
modifier|*
modifier|*
name|newenv
decl_stmt|;
specifier|static
name|bool
name|first
init|=
name|true
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
comment|/* 	**  find out how much of str to match when searching 	**  for a string to replace. 	*/
if|if
condition|(
operator|(
name|tmp
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|tmp
operator|==
name|str
condition|)
name|matchlen
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
else|else
name|matchlen
operator|=
call|(
name|int
call|)
argument_list|(
name|tmp
operator|-
name|str
argument_list|)
expr_stmt|;
operator|++
name|matchlen
expr_stmt|;
comment|/* 	**  Search for an existing string in the environment and find the 	**  length of environ.  If found, replace and exit. 	*/
for|for
control|(
name|current
operator|=
name|environ
init|;
operator|*
name|current
operator|!=
name|NULL
condition|;
name|current
operator|++
control|)
block|{
operator|++
name|envlen
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
operator|*
name|current
argument_list|,
name|matchlen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* found it, now insert the new version */
operator|*
name|current
operator|=
operator|(
name|char
operator|*
operator|)
name|str
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 	**  There wasn't already a slot so add space for a new slot. 	**  If this is our first time through, use malloc(), else realloc(). 	*/
if|if
condition|(
name|first
condition|)
block|{
name|newenv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|sm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|envlen
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newenv
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|first
operator|=
name|false
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|newenv
argument_list|,
name|environ
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|envlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newenv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|sm_realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|environ
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|envlen
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newenv
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* actually add in the new entry */
name|environ
operator|=
name|newenv
expr_stmt|;
name|environ
index|[
name|envlen
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|str
expr_stmt|;
name|environ
index|[
name|envlen
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* NEEDPUTENV == 2 */
end_comment

begin_function
name|int
name|putenv
parameter_list|(
name|env
parameter_list|)
name|char
modifier|*
name|env
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|;
name|char
name|nbuf
index|[
literal|100
index|]
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|env
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|l
operator|=
name|p
operator|-
name|env
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
name|nbuf
operator|-
literal|1
condition|)
name|l
operator|=
sizeof|sizeof
name|nbuf
operator|-
literal|1
expr_stmt|;
name|memmove
argument_list|(
name|nbuf
argument_list|,
name|env
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|nbuf
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|setenv
argument_list|(
name|nbuf
argument_list|,
operator|++
name|p
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEEDPUTENV == 2 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEEDPUTENV */
end_comment

begin_comment
comment|/* **  UNSETENV -- remove a variable from the environment ** **	Not needed on newer systems. ** **	Parameters: **		name -- the string name of the environment variable to be **			deleted from the current environment. ** **	Returns: **		none. ** **	Globals: **		environ -- a pointer to the current environment. ** **	Side Effects: **		Modifies environ. */
end_comment

begin_if
if|#
directive|if
operator|!
name|HASUNSETENV
end_if

begin_function
name|void
name|unsetenv
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|environ
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
operator|*
name|pp
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|*
name|pp
operator|)
index|[
name|len
index|]
operator|==
literal|'='
operator|||
operator|(
operator|*
name|pp
operator|)
index|[
name|len
index|]
operator|==
literal|'\0'
operator|)
condition|)
break|break;
block|}
for|for
control|(
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|++
control|)
operator|*
name|pp
operator|=
name|pp
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HASUNSETENV */
end_comment

begin_decl_stmt
name|char
modifier|*
name|SmCompileOptions
index|[]
init|=
block|{
if|#
directive|if
name|SM_CONF_BROKEN_STRTOD
literal|"SM_CONF_BROKEN_STRTOD"
block|,
endif|#
directive|endif
comment|/* SM_CONF_BROKEN_STRTOD */
if|#
directive|if
name|SM_CONF_GETOPT
literal|"SM_CONF_GETOPT"
block|,
endif|#
directive|endif
comment|/* SM_CONF_GETOPT */
if|#
directive|if
name|SM_CONF_LDAP_INITIALIZE
literal|"SM_CONF_LDAP_INITIALIZE"
block|,
endif|#
directive|endif
comment|/* SM_CONF_LDAP_INITIALIZE */
if|#
directive|if
name|SM_CONF_LDAP_MEMFREE
literal|"SM_CONF_LDAP_MEMFREE"
block|,
endif|#
directive|endif
comment|/* SM_CONF_LDAP_MEMFREE */
if|#
directive|if
name|SM_CONF_LONGLONG
literal|"SM_CONF_LONGLONG"
block|,
endif|#
directive|endif
comment|/* SM_CONF_LONGLONG */
if|#
directive|if
name|SM_CONF_MEMCHR
literal|"SM_CONF_MEMCHR"
block|,
endif|#
directive|endif
comment|/* SM_CONF_MEMCHR */
if|#
directive|if
name|SM_CONF_MSG
literal|"SM_CONF_MSG"
block|,
endif|#
directive|endif
comment|/* SM_CONF_MSG */
if|#
directive|if
name|SM_CONF_QUAD_T
literal|"SM_CONF_QUAD_T"
block|,
endif|#
directive|endif
comment|/* SM_CONF_QUAD_T */
if|#
directive|if
name|SM_CONF_SEM
literal|"SM_CONF_SEM"
block|,
endif|#
directive|endif
comment|/* SM_CONF_SEM */
if|#
directive|if
name|SM_CONF_SETITIMER
literal|"SM_CONF_SETITIMER"
block|,
endif|#
directive|endif
comment|/* SM_CONF_SETITIMER */
if|#
directive|if
name|SM_CONF_SIGSETJMP
literal|"SM_CONF_SIGSETJMP"
block|,
endif|#
directive|endif
comment|/* SM_CONF_SIGSETJMP */
if|#
directive|if
name|SM_CONF_SHM
literal|"SM_CONF_SHM"
block|,
endif|#
directive|endif
comment|/* SM_CONF_SHM */
if|#
directive|if
name|SM_CONF_SHM_DELAY
literal|"SM_CONF_SHM_DELAY"
block|,
endif|#
directive|endif
comment|/* SM_CONF_SHM_DELAY */
if|#
directive|if
name|SM_CONF_SSIZE_T
literal|"SM_CONF_SSIZE_T"
block|,
endif|#
directive|endif
comment|/* SM_CONF_SSIZE_T */
if|#
directive|if
name|SM_CONF_STDBOOL_H
literal|"SM_CONF_STDBOOL_H"
block|,
endif|#
directive|endif
comment|/* SM_CONF_STDBOOL_H */
if|#
directive|if
name|SM_CONF_STDDEF_H
literal|"SM_CONF_STDDEF_H"
block|,
endif|#
directive|endif
comment|/* SM_CONF_STDDEF_H */
if|#
directive|if
literal|0
comment|/* XXX this is always enabled (for now) */
if|#
directive|if
name|SM_CONF_STRL
block|"SM_CONF_STRL",
endif|#
directive|endif
comment|/* SM_CONF_STRL */
endif|#
directive|endif
comment|/* 0 */
if|#
directive|if
name|SM_CONF_SYS_CDEFS_H
literal|"SM_CONF_SYS_CDEFS_H"
block|,
endif|#
directive|endif
comment|/* SM_CONF_SYS_CDEFS_H */
if|#
directive|if
name|SM_CONF_SYSEXITS_H
literal|"SM_CONF_SYSEXITS_H"
block|,
endif|#
directive|endif
comment|/* SM_CONF_SYSEXITS_H */
if|#
directive|if
name|SM_CONF_UID_GID
literal|"SM_CONF_UID_GID"
block|,
endif|#
directive|endif
comment|/* SM_CONF_UID_GID */
if|#
directive|if
name|DO_NOT_USE_STRCPY
literal|"DO_NOT_USE_STRCPY"
block|,
endif|#
directive|endif
comment|/* DO_NOT_USE_STRCPY */
if|#
directive|if
name|SM_HEAP_CHECK
literal|"SM_HEAP_CHECK"
block|,
endif|#
directive|endif
comment|/* SM_HEAP_CHECK */
if|#
directive|if
name|defined
argument_list|(
name|SM_OS_NAME
argument_list|)
operator|&&
name|defined
argument_list|(
name|__STDC__
argument_list|)
literal|"SM_OS=sm_os_"
name|SM_OS_NAME
block|,
endif|#
directive|endif
comment|/* defined(SM_OS_NAME)&& defined(__STDC__) */
if|#
directive|if
name|SM_VA_STD
literal|"SM_VA_STD"
block|,
endif|#
directive|endif
comment|/* SM_VA_STD */
if|#
directive|if
name|USEKSTAT
literal|"USEKSTAT"
block|,
endif|#
directive|endif
comment|/* USEKSTAT */
if|#
directive|if
name|USEPROCMEMINFO
literal|"USEPROCMEMINFO"
block|,
endif|#
directive|endif
comment|/* USEPROCMEMINFO */
if|#
directive|if
name|USESWAPCTL
literal|"USESWAPCTL"
block|,
endif|#
directive|endif
comment|/* USESWAPCTL */
name|NULL
block|}
decl_stmt|;
end_decl_stmt

end_unit

