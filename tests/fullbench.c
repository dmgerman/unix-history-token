begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_comment
comment|/*_************************************ *  Includes **************************************/
end_comment

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_comment
comment|/* Compiler options, UTIL_GetFileSize */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* fprintf, fopen, ftello64 */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* clock_t, clock, CLOCKS_PER_SEC */
end_comment

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_DLL_IMPORT
end_ifndef

begin_include
include|#
directive|include
file|"zstd_internal.h"
end_include

begin_comment
comment|/* ZSTD_blockHeaderSize, blockType_e, KB, MB */
end_comment

begin_define
define|#
directive|define
name|ZSTD_STATIC_LINKING_ONLY
end_define

begin_comment
comment|/* ZSTD_compressBegin, ZSTD_compressContinue, etc. */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KB
value|*(1<<10)
end_define

begin_define
define|#
directive|define
name|MB
value|*(1<<20)
end_define

begin_define
define|#
directive|define
name|GB
value|*(1U<<30)
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|bt_raw
block|,
name|bt_rle
block|,
name|bt_compressed
block|,
name|bt_reserved
block|}
name|blockType_e
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"zstd.h"
end_include

begin_comment
comment|/* ZSTD_VERSION_STRING */
end_comment

begin_include
include|#
directive|include
file|"datagen.h"
end_include

begin_comment
comment|/*_************************************ *  Constants **************************************/
end_comment

begin_define
define|#
directive|define
name|PROGRAM_DESCRIPTION
value|"Zstandard speed analyzer"
end_define

begin_define
define|#
directive|define
name|AUTHOR
value|"Yann Collet"
end_define

begin_define
define|#
directive|define
name|WELCOME_MESSAGE
value|"*** %s %s %i-bits, by %s (%s) ***\n", PROGRAM_DESCRIPTION, ZSTD_VERSION_STRING, (int)(sizeof(void*)*8), AUTHOR, __DATE__
end_define

begin_define
define|#
directive|define
name|NBLOOPS
value|6
end_define

begin_define
define|#
directive|define
name|TIMELOOP_S
value|2
end_define

begin_define
define|#
directive|define
name|KNUTH
value|2654435761U
end_define

begin_define
define|#
directive|define
name|MAX_MEM
value|(1984 MB)
end_define

begin_define
define|#
directive|define
name|COMPRESSIBILITY_DEFAULT
value|0.50
end_define

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|g_sampleSize
init|=
literal|10000000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*_************************************ *  Macros **************************************/
end_comment

begin_define
define|#
directive|define
name|DISPLAY
parameter_list|(
modifier|...
parameter_list|)
value|fprintf(stderr, __VA_ARGS__)
end_define

begin_comment
comment|/*_************************************ *  Benchmark Parameters **************************************/
end_comment

begin_decl_stmt
specifier|static
name|U32
name|g_nbIterations
init|=
name|NBLOOPS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|g_compressibility
init|=
name|COMPRESSIBILITY_DEFAULT
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|BMK_SetNbIterations
parameter_list|(
name|U32
name|nbLoops
parameter_list|)
block|{
name|g_nbIterations
operator|=
name|nbLoops
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"- %i iterations -\n"
argument_list|,
name|g_nbIterations
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*_******************************************************* *  Private functions *********************************************************/
end_comment

begin_function
specifier|static
name|clock_t
name|BMK_clockSpan
parameter_list|(
name|clock_t
name|clockStart
parameter_list|)
block|{
return|return
name|clock
argument_list|()
operator|-
name|clockStart
return|;
comment|/* works even if overflow, span limited to<= ~30mn */
block|}
end_function

begin_function
specifier|static
name|size_t
name|BMK_findMaxMem
parameter_list|(
name|U64
name|requiredMem
parameter_list|)
block|{
name|size_t
specifier|const
name|step
init|=
literal|64
name|MB
decl_stmt|;
name|void
modifier|*
name|testmem
init|=
name|NULL
decl_stmt|;
name|requiredMem
operator|=
operator|(
operator|(
operator|(
name|requiredMem
operator|>>
literal|26
operator|)
operator|+
literal|1
operator|)
operator|<<
literal|26
operator|)
expr_stmt|;
if|if
condition|(
name|requiredMem
operator|>
name|MAX_MEM
condition|)
name|requiredMem
operator|=
name|MAX_MEM
expr_stmt|;
name|requiredMem
operator|+=
name|step
expr_stmt|;
do|do
block|{
name|testmem
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|requiredMem
argument_list|)
expr_stmt|;
name|requiredMem
operator|-=
name|step
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|testmem
condition|)
do|;
name|free
argument_list|(
name|testmem
argument_list|)
expr_stmt|;
return|return
operator|(
name|size_t
operator|)
name|requiredMem
return|;
block|}
end_function

begin_comment
comment|/*_******************************************************* *  Benchmark wrappers *********************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|blockType_e
name|blockType
decl_stmt|;
name|U32
name|unusedBits
decl_stmt|;
name|U32
name|origSize
decl_stmt|;
block|}
name|blockProperties_t
typedef|;
end_typedef

begin_function
name|size_t
name|local_ZSTD_compress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
name|void
modifier|*
name|buff2
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
operator|(
name|void
operator|)
name|buff2
expr_stmt|;
return|return
name|ZSTD_compress
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|size_t
name|g_cSize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|size_t
name|local_ZSTD_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
name|void
modifier|*
name|buff2
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
operator|(
name|void
operator|)
name|src
expr_stmt|;
operator|(
name|void
operator|)
name|srcSize
expr_stmt|;
return|return
name|ZSTD_decompress
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|buff2
argument_list|,
name|g_cSize
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_DLL_IMPORT
end_ifndef

begin_decl_stmt
specifier|static
name|ZSTD_DCtx
modifier|*
name|g_zdc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|size_t
name|ZSTD_decodeLiteralsBlock
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|size_t
name|local_ZSTD_decodeLiteralsBlock
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
name|void
modifier|*
name|buff2
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
operator|(
name|void
operator|)
name|src
expr_stmt|;
operator|(
name|void
operator|)
name|srcSize
expr_stmt|;
operator|(
name|void
operator|)
name|dst
expr_stmt|;
operator|(
name|void
operator|)
name|dstSize
expr_stmt|;
return|return
name|ZSTD_decodeLiteralsBlock
argument_list|(
operator|(
name|ZSTD_DCtx
operator|*
operator|)
name|g_zdc
argument_list|,
name|buff2
argument_list|,
name|g_cSize
argument_list|)
return|;
block|}
end_function

begin_function_decl
specifier|extern
name|size_t
name|ZSTD_getcBlockSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|blockProperties_t
modifier|*
name|bpPtr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|size_t
name|ZSTD_decodeSeqHeaders
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|int
modifier|*
name|nbSeq
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|size_t
name|local_ZSTD_decodeSeqHeaders
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
name|void
modifier|*
name|buff2
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|int
name|nbSeq
decl_stmt|;
operator|(
name|void
operator|)
name|src
expr_stmt|;
operator|(
name|void
operator|)
name|srcSize
expr_stmt|;
operator|(
name|void
operator|)
name|dst
expr_stmt|;
operator|(
name|void
operator|)
name|dstSize
expr_stmt|;
return|return
name|ZSTD_decodeSeqHeaders
argument_list|(
name|g_zdc
argument_list|,
operator|&
name|nbSeq
argument_list|,
name|buff2
argument_list|,
name|g_cSize
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|ZSTD_CStream
modifier|*
name|g_cstream
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|size_t
name|local_ZSTD_compressStream
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
name|void
modifier|*
name|buff2
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|ZSTD_outBuffer
name|buffOut
decl_stmt|;
name|ZSTD_inBuffer
name|buffIn
decl_stmt|;
operator|(
name|void
operator|)
name|buff2
expr_stmt|;
name|ZSTD_initCStream
argument_list|(
name|g_cstream
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buffOut
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|buffOut
operator|.
name|size
operator|=
name|dstCapacity
expr_stmt|;
name|buffOut
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|buffIn
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|buffIn
operator|.
name|size
operator|=
name|srcSize
expr_stmt|;
name|buffIn
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|ZSTD_compressStream
argument_list|(
name|g_cstream
argument_list|,
operator|&
name|buffOut
argument_list|,
operator|&
name|buffIn
argument_list|)
expr_stmt|;
name|ZSTD_endStream
argument_list|(
name|g_cstream
argument_list|,
operator|&
name|buffOut
argument_list|)
expr_stmt|;
return|return
name|buffOut
operator|.
name|pos
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|ZSTD_DStream
modifier|*
name|g_dstream
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|size_t
name|local_ZSTD_decompressStream
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
name|void
modifier|*
name|buff2
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|ZSTD_outBuffer
name|buffOut
decl_stmt|;
name|ZSTD_inBuffer
name|buffIn
decl_stmt|;
operator|(
name|void
operator|)
name|src
expr_stmt|;
operator|(
name|void
operator|)
name|srcSize
expr_stmt|;
name|ZSTD_initDStream
argument_list|(
name|g_dstream
argument_list|)
expr_stmt|;
name|buffOut
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|buffOut
operator|.
name|size
operator|=
name|dstCapacity
expr_stmt|;
name|buffOut
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|buffIn
operator|.
name|src
operator|=
name|buff2
expr_stmt|;
name|buffIn
operator|.
name|size
operator|=
name|g_cSize
expr_stmt|;
name|buffIn
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|ZSTD_decompressStream
argument_list|(
name|g_dstream
argument_list|,
operator|&
name|buffOut
argument_list|,
operator|&
name|buffIn
argument_list|)
expr_stmt|;
return|return
name|buffOut
operator|.
name|pos
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_DLL_IMPORT
end_ifndef

begin_decl_stmt
specifier|static
name|ZSTD_CCtx
modifier|*
name|g_zcc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|size_t
name|local_ZSTD_compressContinue
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
name|void
modifier|*
name|buff2
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
operator|(
name|void
operator|)
name|buff2
expr_stmt|;
name|ZSTD_compressBegin
argument_list|(
name|g_zcc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|ZSTD_compressEnd
argument_list|(
name|g_zcc
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FIRST_BLOCK_SIZE
value|8
end_define

begin_function
name|size_t
name|local_ZSTD_compressContinue_extDict
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
name|void
modifier|*
name|buff2
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|BYTE
name|firstBlockBuf
index|[
name|FIRST_BLOCK_SIZE
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|buff2
expr_stmt|;
name|memcpy
argument_list|(
name|firstBlockBuf
argument_list|,
name|src
argument_list|,
name|FIRST_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|ZSTD_compressBegin
argument_list|(
name|g_zcc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|compressResult
init|=
name|ZSTD_compressContinue
argument_list|(
name|g_zcc
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|firstBlockBuf
argument_list|,
name|FIRST_BLOCK_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|compressResult
argument_list|)
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"local_ZSTD_compressContinue_extDict error : %s\n"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|compressResult
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|compressResult
return|;
block|}
name|dst
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
operator|+
name|compressResult
expr_stmt|;
name|dstCapacity
operator|-=
name|compressResult
expr_stmt|;
block|}
return|return
name|ZSTD_compressEnd
argument_list|(
name|g_zcc
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
operator|+
name|FIRST_BLOCK_SIZE
argument_list|,
name|srcSize
operator|-
name|FIRST_BLOCK_SIZE
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|local_ZSTD_decompressContinue
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
name|void
modifier|*
name|buff2
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|size_t
name|regeneratedSize
init|=
literal|0
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|buff2
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|ip
operator|+
name|g_cSize
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|size_t
name|remainingCapacity
init|=
name|dstCapacity
decl_stmt|;
operator|(
name|void
operator|)
name|src
expr_stmt|;
operator|(
name|void
operator|)
name|srcSize
expr_stmt|;
name|ZSTD_decompressBegin
argument_list|(
name|g_zdc
argument_list|)
expr_stmt|;
while|while
condition|(
name|ip
operator|<
name|iend
condition|)
block|{
name|size_t
specifier|const
name|iSize
init|=
name|ZSTD_nextSrcSizeToDecompress
argument_list|(
name|g_zdc
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|decodedSize
init|=
name|ZSTD_decompressContinue
argument_list|(
name|g_zdc
argument_list|,
name|op
argument_list|,
name|remainingCapacity
argument_list|,
name|ip
argument_list|,
name|iSize
argument_list|)
decl_stmt|;
name|ip
operator|+=
name|iSize
expr_stmt|;
name|regeneratedSize
operator|+=
name|decodedSize
expr_stmt|;
name|op
operator|+=
name|decodedSize
expr_stmt|;
name|remainingCapacity
operator|-=
name|decodedSize
expr_stmt|;
block|}
return|return
name|regeneratedSize
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*_******************************************************* *  Bench functions *********************************************************/
end_comment

begin_function
specifier|static
name|size_t
name|benchMem
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|U32
name|benchNb
parameter_list|)
block|{
name|BYTE
modifier|*
name|dstBuff
decl_stmt|;
name|size_t
specifier|const
name|dstBuffSize
init|=
name|ZSTD_compressBound
argument_list|(
name|srcSize
argument_list|)
decl_stmt|;
name|void
modifier|*
name|buff2
decl_stmt|;
specifier|const
name|char
modifier|*
name|benchName
decl_stmt|;
name|size_t
function_decl|(
modifier|*
name|benchFunction
function_decl|)
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
name|void
modifier|*
name|verifBuff
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
name|double
name|bestTime
init|=
literal|100000000.
decl_stmt|;
comment|/* Selection */
switch|switch
condition|(
name|benchNb
condition|)
block|{
case|case
literal|1
case|:
name|benchFunction
operator|=
name|local_ZSTD_compress
expr_stmt|;
name|benchName
operator|=
literal|"ZSTD_compress"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|benchFunction
operator|=
name|local_ZSTD_decompress
expr_stmt|;
name|benchName
operator|=
literal|"ZSTD_decompress"
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ZSTD_DLL_IMPORT
case|case
literal|11
case|:
name|benchFunction
operator|=
name|local_ZSTD_compressContinue
expr_stmt|;
name|benchName
operator|=
literal|"ZSTD_compressContinue"
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|benchFunction
operator|=
name|local_ZSTD_compressContinue_extDict
expr_stmt|;
name|benchName
operator|=
literal|"ZSTD_compressContinue_extDict"
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|benchFunction
operator|=
name|local_ZSTD_decompressContinue
expr_stmt|;
name|benchName
operator|=
literal|"ZSTD_decompressContinue"
expr_stmt|;
break|break;
case|case
literal|31
case|:
name|benchFunction
operator|=
name|local_ZSTD_decodeLiteralsBlock
expr_stmt|;
name|benchName
operator|=
literal|"ZSTD_decodeLiteralsBlock"
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|benchFunction
operator|=
name|local_ZSTD_decodeSeqHeaders
expr_stmt|;
name|benchName
operator|=
literal|"ZSTD_decodeSeqHeaders"
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|41
case|:
name|benchFunction
operator|=
name|local_ZSTD_compressStream
expr_stmt|;
name|benchName
operator|=
literal|"ZSTD_compressStream"
expr_stmt|;
break|break;
case|case
literal|42
case|:
name|benchFunction
operator|=
name|local_ZSTD_decompressStream
expr_stmt|;
name|benchName
operator|=
literal|"ZSTD_decompressStream"
expr_stmt|;
break|break;
default|default :
return|return
literal|0
return|;
block|}
comment|/* Allocation */
name|dstBuff
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|malloc
argument_list|(
name|dstBuffSize
argument_list|)
expr_stmt|;
name|buff2
operator|=
name|malloc
argument_list|(
name|dstBuffSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|dstBuff
operator|)
operator|||
operator|(
operator|!
name|buff2
operator|)
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"\nError: not enough memory!\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dstBuff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff2
argument_list|)
expr_stmt|;
return|return
literal|12
return|;
block|}
comment|/* Preparation */
switch|switch
condition|(
name|benchNb
condition|)
block|{
case|case
literal|2
case|:
name|g_cSize
operator|=
name|ZSTD_compress
argument_list|(
name|buff2
argument_list|,
name|dstBuffSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ZSTD_DLL_IMPORT
case|case
literal|11
case|:
if|if
condition|(
name|g_zcc
operator|==
name|NULL
condition|)
name|g_zcc
operator|=
name|ZSTD_createCCtx
argument_list|()
expr_stmt|;
break|break;
case|case
literal|12
case|:
if|if
condition|(
name|g_zcc
operator|==
name|NULL
condition|)
name|g_zcc
operator|=
name|ZSTD_createCCtx
argument_list|()
expr_stmt|;
break|break;
case|case
literal|13
case|:
if|if
condition|(
name|g_zdc
operator|==
name|NULL
condition|)
name|g_zdc
operator|=
name|ZSTD_createDCtx
argument_list|()
expr_stmt|;
name|g_cSize
operator|=
name|ZSTD_compress
argument_list|(
name|buff2
argument_list|,
name|dstBuffSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|31
case|:
comment|/* ZSTD_decodeLiteralsBlock */
if|if
condition|(
name|g_zdc
operator|==
name|NULL
condition|)
name|g_zdc
operator|=
name|ZSTD_createDCtx
argument_list|()
expr_stmt|;
block|{
name|blockProperties_t
name|bp
decl_stmt|;
name|ZSTD_frameParams
name|zfp
decl_stmt|;
name|size_t
name|frameHeaderSize
decl_stmt|,
name|skippedSize
decl_stmt|;
name|g_cSize
operator|=
name|ZSTD_compress
argument_list|(
name|dstBuff
argument_list|,
name|dstBuffSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frameHeaderSize
operator|=
name|ZSTD_getFrameParams
argument_list|(
operator|&
name|zfp
argument_list|,
name|dstBuff
argument_list|,
name|ZSTD_frameHeaderSize_min
argument_list|)
expr_stmt|;
if|if
condition|(
name|frameHeaderSize
operator|==
literal|0
condition|)
name|frameHeaderSize
operator|=
name|ZSTD_frameHeaderSize_min
expr_stmt|;
name|ZSTD_getcBlockSize
argument_list|(
name|dstBuff
operator|+
name|frameHeaderSize
argument_list|,
name|dstBuffSize
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
comment|/* Get 1st block type */
if|if
condition|(
name|bp
operator|.
name|blockType
operator|!=
name|bt_compressed
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"ZSTD_decodeLiteralsBlock : impossible to test on this sample (not compressible)\n"
argument_list|)
expr_stmt|;
goto|goto
name|_cleanOut
goto|;
block|}
name|skippedSize
operator|=
name|frameHeaderSize
operator|+
name|ZSTD_blockHeaderSize
expr_stmt|;
name|memcpy
argument_list|(
name|buff2
argument_list|,
name|dstBuff
operator|+
name|skippedSize
argument_list|,
name|g_cSize
operator|-
name|skippedSize
argument_list|)
expr_stmt|;
name|srcSize
operator|=
name|srcSize
operator|>
literal|128
name|KB
condition|?
literal|128
name|KB
else|:
name|srcSize
expr_stmt|;
comment|/* speed relative to block */
break|break;
block|}
case|case
literal|32
case|:
comment|/* ZSTD_decodeSeqHeaders */
if|if
condition|(
name|g_zdc
operator|==
name|NULL
condition|)
name|g_zdc
operator|=
name|ZSTD_createDCtx
argument_list|()
expr_stmt|;
block|{
name|blockProperties_t
name|bp
decl_stmt|;
name|ZSTD_frameParams
name|zfp
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|dstBuff
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|iend
decl_stmt|;
name|size_t
name|frameHeaderSize
decl_stmt|,
name|cBlockSize
decl_stmt|;
name|ZSTD_compress
argument_list|(
name|dstBuff
argument_list|,
name|dstBuffSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* it would be better to use direct block compression here */
name|g_cSize
operator|=
name|ZSTD_compress
argument_list|(
name|dstBuff
argument_list|,
name|dstBuffSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frameHeaderSize
operator|=
name|ZSTD_getFrameParams
argument_list|(
operator|&
name|zfp
argument_list|,
name|dstBuff
argument_list|,
name|ZSTD_frameHeaderSize_min
argument_list|)
expr_stmt|;
if|if
condition|(
name|frameHeaderSize
operator|==
literal|0
condition|)
name|frameHeaderSize
operator|=
name|ZSTD_frameHeaderSize_min
expr_stmt|;
name|ip
operator|+=
name|frameHeaderSize
expr_stmt|;
comment|/* Skip frame Header */
name|cBlockSize
operator|=
name|ZSTD_getcBlockSize
argument_list|(
name|ip
argument_list|,
name|dstBuffSize
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
comment|/* Get 1st block type */
if|if
condition|(
name|bp
operator|.
name|blockType
operator|!=
name|bt_compressed
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"ZSTD_decodeSeqHeaders : impossible to test on this sample (not compressible)\n"
argument_list|)
expr_stmt|;
goto|goto
name|_cleanOut
goto|;
block|}
name|iend
operator|=
name|ip
operator|+
name|ZSTD_blockHeaderSize
operator|+
name|cBlockSize
expr_stmt|;
comment|/* End of first block */
name|ip
operator|+=
name|ZSTD_blockHeaderSize
expr_stmt|;
comment|/* skip block header */
name|ZSTD_decompressBegin
argument_list|(
name|g_zdc
argument_list|)
expr_stmt|;
name|ip
operator|+=
name|ZSTD_decodeLiteralsBlock
argument_list|(
name|g_zdc
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
expr_stmt|;
comment|/* skip literal segment */
name|g_cSize
operator|=
name|iend
operator|-
name|ip
expr_stmt|;
name|memcpy
argument_list|(
name|buff2
argument_list|,
name|ip
argument_list|,
name|g_cSize
argument_list|)
expr_stmt|;
comment|/* copy rest of block (it starts by SeqHeader) */
name|srcSize
operator|=
name|srcSize
operator|>
literal|128
name|KB
condition|?
literal|128
name|KB
else|:
name|srcSize
expr_stmt|;
comment|/* speed relative to block */
break|break;
block|}
else|#
directive|else
case|case
literal|31
case|:
goto|goto
name|_cleanOut
goto|;
endif|#
directive|endif
case|case
literal|41
case|:
if|if
condition|(
name|g_cstream
operator|==
name|NULL
condition|)
name|g_cstream
operator|=
name|ZSTD_createCStream
argument_list|()
expr_stmt|;
break|break;
case|case
literal|42
case|:
if|if
condition|(
name|g_dstream
operator|==
name|NULL
condition|)
name|g_dstream
operator|=
name|ZSTD_createDStream
argument_list|()
expr_stmt|;
name|g_cSize
operator|=
name|ZSTD_compress
argument_list|(
name|buff2
argument_list|,
name|dstBuffSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/* test functions */
comment|/* by convention, test functions can be added> 100 */
default|default :
empty_stmt|;
block|}
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dstBuffSize
condition|;
name|i
operator|++
control|)
name|dstBuff
index|[
name|i
index|]
operator|=
operator|(
name|BYTE
operator|)
name|i
expr_stmt|;
block|}
comment|/* warming up memory */
block|{
name|U32
name|loopNb
decl_stmt|;
name|DISPLAY
argument_list|(
literal|"%2i- %-30.30s : \r"
argument_list|,
name|benchNb
argument_list|,
name|benchName
argument_list|)
expr_stmt|;
for|for
control|(
name|loopNb
operator|=
literal|1
init|;
name|loopNb
operator|<=
name|g_nbIterations
condition|;
name|loopNb
operator|++
control|)
block|{
name|clock_t
specifier|const
name|timeLoop
init|=
name|TIMELOOP_S
operator|*
name|CLOCKS_PER_SEC
decl_stmt|;
name|clock_t
name|clockStart
decl_stmt|;
name|U32
name|nbRounds
decl_stmt|;
name|size_t
name|benchResult
init|=
literal|0
decl_stmt|;
name|double
name|averageTime
decl_stmt|;
name|clockStart
operator|=
name|clock
argument_list|()
expr_stmt|;
while|while
condition|(
name|clock
argument_list|()
operator|==
name|clockStart
condition|)
empty_stmt|;
name|clockStart
operator|=
name|clock
argument_list|()
expr_stmt|;
for|for
control|(
name|nbRounds
operator|=
literal|0
init|;
name|BMK_clockSpan
argument_list|(
name|clockStart
argument_list|)
operator|<
name|timeLoop
condition|;
name|nbRounds
operator|++
control|)
block|{
name|benchResult
operator|=
name|benchFunction
argument_list|(
name|dstBuff
argument_list|,
name|dstBuffSize
argument_list|,
name|buff2
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|benchResult
argument_list|)
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"ERROR ! %s() => %s !! \n"
argument_list|,
name|benchName
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|benchResult
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|averageTime
operator|=
operator|(
operator|(
operator|(
name|double
operator|)
name|BMK_clockSpan
argument_list|(
name|clockStart
argument_list|)
operator|)
operator|/
name|CLOCKS_PER_SEC
operator|)
operator|/
name|nbRounds
expr_stmt|;
if|if
condition|(
name|averageTime
operator|<
name|bestTime
condition|)
name|bestTime
operator|=
name|averageTime
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"%2i- %-30.30s : %7.1f MB/s  (%9u)\r"
argument_list|,
name|loopNb
argument_list|,
name|benchName
argument_list|,
operator|(
name|double
operator|)
name|srcSize
operator|/
operator|(
literal|1
name|MB
operator|)
operator|/
name|bestTime
argument_list|,
operator|(
name|U32
operator|)
name|benchResult
argument_list|)
expr_stmt|;
block|}
block|}
name|DISPLAY
argument_list|(
literal|"%2u\n"
argument_list|,
name|benchNb
argument_list|)
expr_stmt|;
name|_cleanOut
label|:
name|free
argument_list|(
name|dstBuff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|benchSample
parameter_list|(
name|U32
name|benchNb
parameter_list|)
block|{
name|size_t
specifier|const
name|benchedSize
init|=
name|g_sampleSize
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
literal|"Sample 10MiB"
decl_stmt|;
comment|/* Allocation */
name|void
modifier|*
name|origBuff
init|=
name|malloc
argument_list|(
name|benchedSize
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|origBuff
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"\nError: not enough memory!\n"
argument_list|)
expr_stmt|;
return|return
literal|12
return|;
block|}
comment|/* Fill buffer */
name|RDG_genBuffer
argument_list|(
name|origBuff
argument_list|,
name|benchedSize
argument_list|,
name|g_compressibility
argument_list|,
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* bench */
name|DISPLAY
argument_list|(
literal|"\r%79s\r"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" %s : \n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|benchNb
condition|)
name|benchMem
argument_list|(
name|origBuff
argument_list|,
name|benchedSize
argument_list|,
name|benchNb
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|benchNb
operator|=
literal|0
init|;
name|benchNb
operator|<
literal|100
condition|;
name|benchNb
operator|++
control|)
name|benchMem
argument_list|(
name|origBuff
argument_list|,
name|benchedSize
argument_list|,
name|benchNb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|origBuff
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|benchFiles
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
parameter_list|,
specifier|const
name|int
name|nbFiles
parameter_list|,
name|U32
name|benchNb
parameter_list|)
block|{
comment|/* Loop for each file */
name|int
name|fileIdx
decl_stmt|;
for|for
control|(
name|fileIdx
operator|=
literal|0
init|;
name|fileIdx
operator|<
name|nbFiles
condition|;
name|fileIdx
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|inFileName
init|=
name|fileNamesTable
index|[
name|fileIdx
index|]
decl_stmt|;
name|FILE
modifier|*
name|inFile
init|=
name|fopen
argument_list|(
name|inFileName
argument_list|,
literal|"rb"
argument_list|)
decl_stmt|;
name|U64
name|inFileSize
decl_stmt|;
name|size_t
name|benchedSize
decl_stmt|;
name|void
modifier|*
name|origBuff
decl_stmt|;
comment|/* Check file existence */
if|if
condition|(
name|inFile
operator|==
name|NULL
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"Pb opening %s\n"
argument_list|,
name|inFileName
argument_list|)
expr_stmt|;
return|return
literal|11
return|;
block|}
comment|/* Memory allocation& restrictions */
name|inFileSize
operator|=
name|UTIL_getFileSize
argument_list|(
name|inFileName
argument_list|)
expr_stmt|;
name|benchedSize
operator|=
name|BMK_findMaxMem
argument_list|(
name|inFileSize
operator|*
literal|3
argument_list|)
operator|/
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|U64
operator|)
name|benchedSize
operator|>
name|inFileSize
condition|)
name|benchedSize
operator|=
operator|(
name|size_t
operator|)
name|inFileSize
expr_stmt|;
if|if
condition|(
name|benchedSize
operator|<
name|inFileSize
condition|)
name|DISPLAY
argument_list|(
literal|"Not enough memory for '%s' full size; testing %u MB only...\n"
argument_list|,
name|inFileName
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|benchedSize
operator|>>
literal|20
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Alloc */
name|origBuff
operator|=
name|malloc
argument_list|(
name|benchedSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|origBuff
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"\nError: not enough memory!\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|inFile
argument_list|)
expr_stmt|;
return|return
literal|12
return|;
block|}
comment|/* Fill input buffer */
name|DISPLAY
argument_list|(
literal|"Loading %s...       \r"
argument_list|,
name|inFileName
argument_list|)
expr_stmt|;
block|{
name|size_t
name|readSize
init|=
name|fread
argument_list|(
name|origBuff
argument_list|,
literal|1
argument_list|,
name|benchedSize
argument_list|,
name|inFile
argument_list|)
decl_stmt|;
name|fclose
argument_list|(
name|inFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|readSize
operator|!=
name|benchedSize
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"\nError: problem reading file '%s' !!    \n"
argument_list|,
name|inFileName
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|origBuff
argument_list|)
expr_stmt|;
return|return
literal|13
return|;
block|}
block|}
comment|/* bench */
name|DISPLAY
argument_list|(
literal|"\r%79s\r"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" %s : \n"
argument_list|,
name|inFileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|benchNb
condition|)
name|benchMem
argument_list|(
name|origBuff
argument_list|,
name|benchedSize
argument_list|,
name|benchNb
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|benchNb
operator|=
literal|0
init|;
name|benchNb
operator|<
literal|100
condition|;
name|benchNb
operator|++
control|)
name|benchMem
argument_list|(
name|origBuff
argument_list|,
name|benchedSize
argument_list|,
name|benchNb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|origBuff
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|exename
parameter_list|)
block|{
name|DISPLAY
argument_list|(
literal|"Usage :\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"      %s [arg] file1 file2 ... fileX\n"
argument_list|,
name|exename
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"Arguments :\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -H/-h  : Help (this text + advanced options)\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usage_advanced
parameter_list|(
specifier|const
name|char
modifier|*
name|exename
parameter_list|)
block|{
name|usage
argument_list|(
name|exename
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"\nAdvanced options :\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -b#    : test only function # \n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -i#    : iteration loops [1-9](default : %i)\n"
argument_list|,
name|NBLOOPS
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -P#    : sample compressibility (default : %.1f%%)\n"
argument_list|,
name|COMPRESSIBILITY_DEFAULT
operator|*
literal|100
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|badusage
parameter_list|(
specifier|const
name|char
modifier|*
name|exename
parameter_list|)
block|{
name|DISPLAY
argument_list|(
literal|"Wrong parameters\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|exename
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|filenamesStart
init|=
literal|0
decl_stmt|,
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|exename
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|input_filename
init|=
name|NULL
decl_stmt|;
name|U32
name|benchNb
init|=
literal|0
decl_stmt|,
name|main_pause
init|=
literal|0
decl_stmt|;
name|DISPLAY
argument_list|(
name|WELCOME_MESSAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
return|return
name|badusage
argument_list|(
name|exename
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|argument
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|argument
condition|)
continue|continue;
comment|/* Protection if argument empty */
comment|/* Commands (note : aggregated commands are allowed) */
if|if
condition|(
name|argument
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
while|while
condition|(
name|argument
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|argument
operator|++
expr_stmt|;
switch|switch
condition|(
name|argument
index|[
literal|0
index|]
condition|)
block|{
comment|/* Display help on usage */
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
return|return
name|usage_advanced
argument_list|(
name|exename
argument_list|)
return|;
comment|/* Pause at the end (hidden option) */
case|case
literal|'p'
case|:
name|main_pause
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Select specific algorithm to bench */
case|case
literal|'b'
case|:
name|benchNb
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|argument
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|argument
index|[
literal|1
index|]
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|benchNb
operator|*=
literal|10
expr_stmt|;
name|benchNb
operator|+=
name|argument
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|argument
operator|++
expr_stmt|;
block|}
break|break;
comment|/* Modify Nb Iterations */
case|case
literal|'i'
case|:
if|if
condition|(
operator|(
name|argument
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|argument
index|[
literal|1
index|]
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|int
name|iters
init|=
name|argument
index|[
literal|1
index|]
operator|-
literal|'0'
decl_stmt|;
name|BMK_SetNbIterations
argument_list|(
name|iters
argument_list|)
expr_stmt|;
name|argument
operator|++
expr_stmt|;
block|}
break|break;
comment|/* Select compressibility of synthetic sample */
case|case
literal|'P'
case|:
block|{
name|U32
name|proba32
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|argument
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|argument
index|[
literal|1
index|]
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|proba32
operator|*=
literal|10
expr_stmt|;
name|proba32
operator|+=
name|argument
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|argument
operator|++
expr_stmt|;
block|}
name|g_compressibility
operator|=
operator|(
name|double
operator|)
name|proba32
operator|/
literal|100.
expr_stmt|;
block|}
break|break;
comment|/* Unknown command */
default|default :
return|return
name|badusage
argument_list|(
name|exename
argument_list|)
return|;
block|}
block|}
continue|continue;
block|}
comment|/* first provided filename is input */
if|if
condition|(
operator|!
name|input_filename
condition|)
block|{
name|input_filename
operator|=
name|argument
expr_stmt|;
name|filenamesStart
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|filenamesStart
operator|==
literal|0
condition|)
comment|/* no input file */
name|result
operator|=
name|benchSample
argument_list|(
name|benchNb
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|benchFiles
argument_list|(
name|argv
operator|+
name|filenamesStart
argument_list|,
name|argc
operator|-
name|filenamesStart
argument_list|,
name|benchNb
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_pause
condition|)
block|{
name|int
name|unused
decl_stmt|;
name|printf
argument_list|(
literal|"press enter...\n"
argument_list|)
expr_stmt|;
name|unused
operator|=
name|getchar
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|unused
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

end_unit

