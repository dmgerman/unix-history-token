begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/*  * Regression test to exercise POSIX fifo I/O.  *  * We test a number of aspect of behavior, including:  *  * - If there's no data to read, then for blocking fifos, we block, and for  *   non-blocking, we return EAGAIN.  *  * - If we write ten bytes, ten bytes can be read, and they're the same  *   bytes, in the same order.  *  * - If we write two batches of five bytes, we can read the same ten bytes in  *   one read of ten bytes.  *  * - If we write ten bytes, we can read the same ten bytes in two reads of  *   five bytes each.  *  * - If we over-fill a buffer (by writing 512k, which we take to be a large  *   number above default buffer sizes), we block if there is no reader.  *  * - That once 512k (ish) is read from the other end, the blocked writer  *   wakes up.  *  * - When a fifo is empty, poll, select, kqueue, and fionread report it is  *   writable but not readable.  *  * - When a fifo has data in it, poll, select, and kqueue report that it is  *   writable.  *  * - XXX: blocked reader semantics?  *  * - XXX: event behavior on remote close?  *  * Although behavior of O_RDWR isn't defined for fifos by POSIX, we expect  * "reasonable" behavior, and run some additional tests relating to event  * management on O_RDWR fifo descriptors.  */
end_comment

begin_define
define|#
directive|define
name|KQUEUE_MAX_EVENT
value|8
end_define

begin_comment
comment|/*  * All activity occurs within a temporary directory created early in the  * test.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|temp_dir
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|__unused
name|atexit_temp_dir
parameter_list|(
name|void
parameter_list|)
block|{
name|rmdir
argument_list|(
name|temp_dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|makefifo
parameter_list|(
specifier|const
name|char
modifier|*
name|fifoname
parameter_list|,
specifier|const
name|char
modifier|*
name|testname
parameter_list|)
block|{
if|if
condition|(
name|mkfifo
argument_list|(
name|fifoname
argument_list|,
literal|0700
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"%s: makefifo: mkfifo: %s"
argument_list|,
name|testname
argument_list|,
name|fifoname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cleanfifo2
parameter_list|(
specifier|const
name|char
modifier|*
name|fifoname
parameter_list|,
name|int
name|fd1
parameter_list|,
name|int
name|fd2
parameter_list|)
block|{
if|if
condition|(
name|fd1
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd2
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|fifoname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cleanfifo3
parameter_list|(
specifier|const
name|char
modifier|*
name|fifoname
parameter_list|,
name|int
name|fd1
parameter_list|,
name|int
name|fd2
parameter_list|,
name|int
name|fd3
parameter_list|)
block|{
if|if
condition|(
name|fd3
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fd3
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
name|fifoname
argument_list|,
name|fd1
argument_list|,
name|fd2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open two different file descriptors for a fifo: one read, one write.  Do  * so using non-blocking opens in order to avoid deadlocking the process.  */
end_comment

begin_function
specifier|static
name|int
name|openfifo
parameter_list|(
specifier|const
name|char
modifier|*
name|fifoname
parameter_list|,
name|int
modifier|*
name|reader_fdp
parameter_list|,
name|int
modifier|*
name|writer_fdp
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|fd1
decl_stmt|,
name|fd2
decl_stmt|;
name|fd1
operator|=
name|open
argument_list|(
name|fifoname
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd1
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|fd2
operator|=
name|open
argument_list|(
name|fifoname
argument_list|,
name|O_WRONLY
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd2
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
name|errno
operator|=
name|error
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|reader_fdp
operator|=
name|fd1
expr_stmt|;
operator|*
name|writer_fdp
operator|=
name|fd2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open one file descriptor for the fifo, supporting both read and write.  */
end_comment

begin_function
specifier|static
name|int
name|openfifo_rw
parameter_list|(
specifier|const
name|char
modifier|*
name|fifoname
parameter_list|,
name|int
modifier|*
name|fdp
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|fifoname
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|fdp
operator|=
name|fd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_nonblocking
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|testname
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: fcntl(fd, F_GETFL)"
argument_list|,
name|testname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|flags
operator||=
name|O_NONBLOCK
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: fcntl(fd, 0x%x)"
argument_list|,
name|testname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_blocking
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|testname
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: fcntl(fd, F_GETFL)"
argument_list|,
name|testname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|flags
operator|&=
operator|~
name|O_NONBLOCK
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: fcntl(fd, 0x%x)"
argument_list|,
name|testname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Drain a file descriptor (fifo) of any readable data.  Note: resets the  * blocking state.  */
end_comment

begin_function
specifier|static
name|int
name|drain_fd
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|testname
parameter_list|)
block|{
name|ssize_t
name|len
decl_stmt|;
name|u_char
name|ch
decl_stmt|;
if|if
condition|(
name|set_nonblocking
argument_list|(
name|fd
argument_list|,
name|testname
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EAGAIN
case|:
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|warn
argument_list|(
literal|"%s: drain_fd: read"
argument_list|,
name|testname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|warn
argument_list|(
literal|"%s: drain_fd: read: returned 0 bytes"
argument_list|,
name|testname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Simple I/O test: write ten integers, and make sure we get back the same  * integers in the same order.  This assumes a minimum fifo buffer> 10  * bytes in order to not block and deadlock.  */
end_comment

begin_function
specifier|static
name|void
name|test_simpleio
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|reader_fd
decl_stmt|,
name|writer_fd
decl_stmt|;
name|u_char
name|buffer
index|[
literal|10
index|]
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|makefifo
argument_list|(
literal|"testfifo"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfifo
argument_list|(
literal|"testfifo"
argument_list|,
operator|&
name|reader_fd
argument_list|,
operator|&
name|writer_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_simpleio: openfifo: testfifo"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|buffer
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|len
operator|=
name|write
argument_list|(
name|writer_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_simpleio: write"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"test_simplio: tried %zu but wrote %zd"
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|read
argument_list|(
name|reader_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_simpleio: read"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"test_simpleio: tried %zu but read %zd"
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|==
name|i
condition|)
continue|continue;
name|warnx
argument_list|(
literal|"test_simpleio: write byte %d as 0x%02x, but read "
literal|"0x%02x"
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|alarm_fired
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Non-destructive SIGALRM handler.  */
end_comment

begin_function
specifier|static
name|void
name|sigalarm
parameter_list|(
name|int
name|signum
name|__unused
parameter_list|)
block|{
name|alarm_fired
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wrapper function for write, which uses a timer to interrupt any blocking.  * Because we can't reliably detect EINTR for blocking I/O, we also track  * whether or not our timeout fired.  */
end_comment

begin_function
specifier|static
name|int
name|__unused
name|timed_write
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|ssize_t
modifier|*
name|written_lenp
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
modifier|*
name|timedoutp
parameter_list|,
specifier|const
name|char
modifier|*
name|testname
parameter_list|)
block|{
name|struct
name|sigaction
name|act
decl_stmt|,
name|oact
decl_stmt|;
name|ssize_t
name|written_len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|alarm_fired
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|act
argument_list|,
sizeof|sizeof
argument_list|(
name|oact
argument_list|)
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|sigalarm
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|oact
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: timed_write: sigaction"
argument_list|,
name|testname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|alarm
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|written_len
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|errno
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|oact
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: timed_write: sigaction"
argument_list|,
name|testname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|alarm_fired
condition|)
operator|*
name|timedoutp
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|timedoutp
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|written_len
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|written_lenp
operator|=
name|written_len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wrapper function for read, which uses a timer to interrupt any blocking.  * Because we can't reliably detect EINTR for blocking I/O, we also track  * whether or not our timeout fired.  */
end_comment

begin_function
specifier|static
name|int
name|timed_read
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|ssize_t
modifier|*
name|read_lenp
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
modifier|*
name|timedoutp
parameter_list|,
specifier|const
name|char
modifier|*
name|testname
parameter_list|)
block|{
name|struct
name|sigaction
name|act
decl_stmt|,
name|oact
decl_stmt|;
name|ssize_t
name|read_len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|alarm_fired
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|act
argument_list|,
sizeof|sizeof
argument_list|(
name|oact
argument_list|)
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|sigalarm
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|oact
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: timed_write: sigaction"
argument_list|,
name|testname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|alarm
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|read_len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|errno
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|oact
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: timed_write: sigaction"
argument_list|,
name|testname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|alarm_fired
condition|)
operator|*
name|timedoutp
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|timedoutp
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|read_len
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|read_lenp
operator|=
name|read_len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This test operates on blocking and non-blocking fifo file descriptors, in  * order to determine whether they block at good moments or not.  By good we  * mean: don't block for non-blocking sockets, and do block for blocking  * ones, assuming there isn't I/O buffer to satisfy the request.  *  * We use a timeout of 5 seconds, concluding that in 5 seconds either all I/O  * that can take place will, and that if we reach the end of the timeout,  * then blocking has occurred.  *  * We assume that the buffer size on a fifo is<512K, and as such, that  * writing that much data without an active reader will result in blocking.  */
end_comment

begin_function
specifier|static
name|void
name|test_blocking_read_empty
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|reader_fd
decl_stmt|,
name|ret
decl_stmt|,
name|timedout
decl_stmt|,
name|writer_fd
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|u_char
name|ch
decl_stmt|;
name|makefifo
argument_list|(
literal|"testfifo"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfifo
argument_list|(
literal|"testfifo"
argument_list|,
operator|&
name|reader_fd
argument_list|,
operator|&
name|writer_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_blocking_read_empty: openfifo: testfifo"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Read one byte from an empty blocking fifo, block as there is no 	 * data. 	 */
if|if
condition|(
name|set_blocking
argument_list|(
name|reader_fd
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|timed_read
argument_list|(
name|reader_fd
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|,
operator|&
name|len
argument_list|,
literal|5
argument_list|,
operator|&
name|timedout
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"test_blocking_read_empty: timed_read: returned "
literal|"success"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|warn
argument_list|(
literal|"test_blocking_read_empty: timed_read"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Read one byte from an empty non-blocking fifo, return EAGAIN as 	 * there is no data. 	 */
if|if
condition|(
name|set_nonblocking
argument_list|(
name|reader_fd
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|timed_read
argument_list|(
name|reader_fd
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|,
operator|&
name|len
argument_list|,
literal|5
argument_list|,
operator|&
name|timedout
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"test_blocking_read_empty: timed_read: returned "
literal|"success"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
condition|)
block|{
name|warn
argument_list|(
literal|"test_blocking_read_empty: timed_read"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write one byte to an empty fifo, then try to read one byte and make sure  * we don't block in either the write or the read.  This tests both for  * improper blocking in the send and receive code.  */
end_comment

begin_function
specifier|static
name|void
name|test_blocking_one_byte
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|reader_fd
decl_stmt|,
name|ret
decl_stmt|,
name|timedout
decl_stmt|,
name|writer_fd
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|u_char
name|ch
decl_stmt|;
name|makefifo
argument_list|(
literal|"testfifo"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfifo
argument_list|(
literal|"testfifo"
argument_list|,
operator|&
name|reader_fd
argument_list|,
operator|&
name|writer_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_blocking: openfifo: testfifo"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_blocking
argument_list|(
name|writer_fd
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_blocking
argument_list|(
name|reader_fd
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ch
operator|=
literal|0xfe
expr_stmt|;
name|ret
operator|=
name|timed_write
argument_list|(
name|writer_fd
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|,
operator|&
name|len
argument_list|,
literal|5
argument_list|,
operator|&
name|timedout
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_blocking_one_byte: timed_write"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"test_blocking_one_byte: timed_write: tried to write "
literal|"%zu, wrote %zd"
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ch
operator|=
literal|0xab
expr_stmt|;
name|ret
operator|=
name|timed_read
argument_list|(
name|reader_fd
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|,
operator|&
name|len
argument_list|,
literal|5
argument_list|,
operator|&
name|timedout
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_blocking_one_byte: timed_read"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"test_blocking_one_byte: timed_read: wanted %zu, "
literal|"read %zd"
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|!=
literal|0xfe
condition|)
block|{
name|warnx
argument_list|(
literal|"test_blocking_one_byte: timed_read: expected to read "
literal|"0x%02x, read 0x%02x"
argument_list|,
literal|0xfe
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write one byte to an empty fifo, then try to read one byte and make sure  * we don't get back EAGAIN.  */
end_comment

begin_function
specifier|static
name|void
name|test_nonblocking_one_byte
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|reader_fd
decl_stmt|,
name|ret
decl_stmt|,
name|timedout
decl_stmt|,
name|writer_fd
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|u_char
name|ch
decl_stmt|;
name|makefifo
argument_list|(
literal|"testfifo"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfifo
argument_list|(
literal|"testfifo"
argument_list|,
operator|&
name|reader_fd
argument_list|,
operator|&
name|writer_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_nonblocking: openfifo: testfifo"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_nonblocking
argument_list|(
name|reader_fd
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ch
operator|=
literal|0xfe
expr_stmt|;
name|ret
operator|=
name|timed_write
argument_list|(
name|writer_fd
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|,
operator|&
name|len
argument_list|,
literal|5
argument_list|,
operator|&
name|timedout
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_nonblocking_one_byte: timed_write"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"test_nonblocking_one_byte: timed_write: tried to write "
literal|"%zu, wrote %zd"
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ch
operator|=
literal|0xab
expr_stmt|;
name|ret
operator|=
name|timed_read
argument_list|(
name|reader_fd
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|,
operator|&
name|len
argument_list|,
literal|5
argument_list|,
operator|&
name|timedout
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_nonblocking_one_byte: timed_read"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"test_nonblocking_one_byte: timed_read: wanted %zu, read "
literal|"%zd"
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|!=
literal|0xfe
condition|)
block|{
name|warnx
argument_list|(
literal|"test_nonblocking_one_byte: timed_read: expected to read "
literal|"0x%02x, read 0x%02x"
argument_list|,
literal|0xfe
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * First of two test cases involving a 512K buffer: write the buffer into a  * blocking file descriptor.  We'd like to know it blocks, but the closest we  * can get is to see if SIGALRM fired during the I/O resulting in a partial  * write.  */
end_comment

begin_function
specifier|static
name|void
name|test_blocking_partial_write
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|reader_fd
decl_stmt|,
name|ret
decl_stmt|,
name|timedout
decl_stmt|,
name|writer_fd
decl_stmt|;
name|u_char
modifier|*
name|buffer
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|makefifo
argument_list|(
literal|"testfifo"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfifo
argument_list|(
literal|"testfifo"
argument_list|,
operator|&
name|reader_fd
argument_list|,
operator|&
name|writer_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_blocking_partial_write: openfifo: testfifo"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_blocking
argument_list|(
name|writer_fd
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|=
name|malloc
argument_list|(
literal|512
operator|*
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"test_blocking_partial_write: malloc"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|buffer
argument_list|,
literal|512
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|ret
operator|=
name|timed_write
argument_list|(
name|writer_fd
argument_list|,
name|buffer
argument_list|,
literal|512
operator|*
literal|1024
argument_list|,
operator|&
name|len
argument_list|,
literal|5
argument_list|,
operator|&
name|timedout
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_blocking_partial_write: timed_write"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timedout
condition|)
block|{
name|warnx
argument_list|(
literal|"test_blocking_partial_write: timed_write: blocking "
literal|"socket didn't time out"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|drain_fd
argument_list|(
name|reader_fd
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a 512K buffer to an empty fifo using a non-blocking file descriptor,  * and make sure it doesn't block.  */
end_comment

begin_function
specifier|static
name|void
name|test_nonblocking_partial_write
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|reader_fd
decl_stmt|,
name|ret
decl_stmt|,
name|timedout
decl_stmt|,
name|writer_fd
decl_stmt|;
name|u_char
modifier|*
name|buffer
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|makefifo
argument_list|(
literal|"testfifo"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfifo
argument_list|(
literal|"testfifo"
argument_list|,
operator|&
name|reader_fd
argument_list|,
operator|&
name|writer_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_blocking_partial_write: openfifo: testfifo"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_nonblocking
argument_list|(
name|writer_fd
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|=
name|malloc
argument_list|(
literal|512
operator|*
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"test_blocking_partial_write: malloc"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|buffer
argument_list|,
literal|512
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|ret
operator|=
name|timed_write
argument_list|(
name|writer_fd
argument_list|,
name|buffer
argument_list|,
literal|512
operator|*
literal|1024
argument_list|,
operator|&
name|len
argument_list|,
literal|5
argument_list|,
operator|&
name|timedout
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_blocking_partial_write: timed_write"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timedout
condition|)
block|{
name|warnx
argument_list|(
literal|"test_blocking_partial_write: timed_write: "
literal|"non-blocking socket timed out"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
operator|||
name|len
operator|>=
literal|512
operator|*
literal|1024
condition|)
block|{
name|warnx
argument_list|(
literal|"test_blocking_partial_write: timed_write: requested "
literal|"%d, sent %zd"
argument_list|,
literal|512
operator|*
literal|1024
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|drain_fd
argument_list|(
name|reader_fd
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * test_coalesce_big_read() verifies that data mingles in the fifo across  * message boundaries by performing two small writes, then a bigger read  * that should return data from both writes.  */
end_comment

begin_function
specifier|static
name|void
name|test_coalesce_big_read
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|reader_fd
decl_stmt|,
name|writer_fd
decl_stmt|;
name|u_char
name|buffer
index|[
literal|10
index|]
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|makefifo
argument_list|(
literal|"testfifo"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfifo
argument_list|(
literal|"testfifo"
argument_list|,
operator|&
name|reader_fd
argument_list|,
operator|&
name|writer_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_coalesce_big_read: openfifo: testfifo"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Write five, write five, read ten. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|buffer
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|len
operator|=
name|write
argument_list|(
name|writer_fd
argument_list|,
name|buffer
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_coalesce_big_read: write 5"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|5
condition|)
block|{
name|warnx
argument_list|(
literal|"test_coalesce_big_read: write 5 wrote %zd"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|write
argument_list|(
name|writer_fd
argument_list|,
name|buffer
operator|+
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_coalesce_big_read: write 5"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|5
condition|)
block|{
name|warnx
argument_list|(
literal|"test_coalesce_big_read: write 5 wrote %zd"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|read
argument_list|(
name|reader_fd
argument_list|,
name|buffer
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_coalesce_big_read: read 10"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|10
condition|)
block|{
name|warnx
argument_list|(
literal|"test_coalesce_big_read: read 10 read %zd"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|==
name|i
condition|)
continue|continue;
name|warnx
argument_list|(
literal|"test_coalesce_big_read: expected to read 0x%02x, "
literal|"read 0x%02x"
argument_list|,
name|i
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * test_coalesce_big_write() verifies that data mingles in the fifo across  * message boundaries by performing one big write, then two smaller reads  * that should return sequential elements of data from the write.  */
end_comment

begin_function
specifier|static
name|void
name|test_coalesce_big_write
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|reader_fd
decl_stmt|,
name|writer_fd
decl_stmt|;
name|u_char
name|buffer
index|[
literal|10
index|]
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|makefifo
argument_list|(
literal|"testfifo"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfifo
argument_list|(
literal|"testfifo"
argument_list|,
operator|&
name|reader_fd
argument_list|,
operator|&
name|writer_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_coalesce_big_write: openfifo: testfifo"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Write ten, read five, read five. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|buffer
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|len
operator|=
name|write
argument_list|(
name|writer_fd
argument_list|,
name|buffer
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_coalesce_big_write: write 10"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|10
condition|)
block|{
name|warnx
argument_list|(
literal|"test_coalesce_big_write: write 10 wrote %zd"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|read
argument_list|(
name|reader_fd
argument_list|,
name|buffer
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_coalesce_big_write: read 5"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|5
condition|)
block|{
name|warnx
argument_list|(
literal|"test_coalesce_big_write: read 5 read %zd"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|read
argument_list|(
name|reader_fd
argument_list|,
name|buffer
operator|+
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_coalesce_big_write: read 5"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|5
condition|)
block|{
name|warnx
argument_list|(
literal|"test_coalesce_big_write: read 5 read %zd"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|==
name|i
condition|)
continue|continue;
name|warnx
argument_list|(
literal|"test_coalesce_big_write: expected to read 0x%02x, "
literal|"read 0x%02x"
argument_list|,
name|i
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|poll_status
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
modifier|*
name|readable
parameter_list|,
name|int
modifier|*
name|writable
parameter_list|,
name|int
modifier|*
name|exception
parameter_list|,
specifier|const
name|char
modifier|*
name|testname
parameter_list|)
block|{
name|struct
name|pollfd
name|fds
index|[
literal|1
index|]
decl_stmt|;
name|fds
index|[
literal|0
index|]
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
name|fds
index|[
literal|0
index|]
operator|.
name|events
operator|=
name|POLLIN
operator||
name|POLLOUT
operator||
name|POLLERR
expr_stmt|;
name|fds
index|[
literal|0
index|]
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|poll
argument_list|(
name|fds
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: poll"
argument_list|,
name|testname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|readable
operator|=
operator|(
name|fds
index|[
literal|0
index|]
operator|.
name|revents
operator|&
name|POLLIN
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
operator|*
name|writable
operator|=
operator|(
name|fds
index|[
literal|0
index|]
operator|.
name|revents
operator|&
name|POLLOUT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
operator|*
name|exception
operator|=
operator|(
name|fds
index|[
literal|0
index|]
operator|.
name|revents
operator|&
name|POLLERR
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|select_status
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
modifier|*
name|readable
parameter_list|,
name|int
modifier|*
name|writable
parameter_list|,
name|int
modifier|*
name|exception
parameter_list|,
specifier|const
name|char
modifier|*
name|testname
parameter_list|)
block|{
name|struct
name|fd_set
name|readfds
decl_stmt|,
name|writefds
decl_stmt|,
name|exceptfds
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|writefds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|exceptfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|writefds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|exceptfds
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
operator|&
name|writefds
argument_list|,
operator|&
name|exceptfds
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: select"
argument_list|,
name|testname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|readable
operator|=
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|readfds
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
operator|*
name|writable
operator|=
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|writefds
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
operator|*
name|exception
operator|=
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|exceptfds
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an existing kqueue, set up read and write event filters for the  * passed file descriptor.  Typically called once for the read endpoint, and  * once for the write endpoint.  */
end_comment

begin_function
specifier|static
name|int
name|kqueue_setup
parameter_list|(
name|int
name|kqueue_fd
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|testname
parameter_list|)
block|{
name|struct
name|kevent
name|kevent_changelist
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|kevent
name|kevent_eventlist
index|[
name|KQUEUE_MAX_EVENT
index|]
decl_stmt|,
modifier|*
name|kp
decl_stmt|;
name|struct
name|timespec
name|timeout
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|kevent_changelist
argument_list|,
sizeof|sizeof
argument_list|(
name|kevent_changelist
argument_list|)
argument_list|)
expr_stmt|;
name|EV_SET
argument_list|(
operator|&
name|kevent_changelist
index|[
literal|0
index|]
argument_list|,
name|fd
argument_list|,
name|EVFILT_READ
argument_list|,
name|EV_ADD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EV_SET
argument_list|(
operator|&
name|kevent_changelist
index|[
literal|1
index|]
argument_list|,
name|fd
argument_list|,
name|EVFILT_WRITE
argument_list|,
name|EV_ADD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|kevent_eventlist
argument_list|,
sizeof|sizeof
argument_list|(
name|kevent_eventlist
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|kevent
argument_list|(
name|kqueue_fd
argument_list|,
name|kevent_changelist
argument_list|,
literal|2
argument_list|,
name|kevent_eventlist
argument_list|,
name|KQUEUE_MAX_EVENT
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s:%s: kevent initial register"
argument_list|,
name|testname
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Verify that the events registered alright. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ret
condition|;
name|i
operator|++
control|)
block|{
name|kp
operator|=
operator|&
name|kevent_eventlist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kp
operator|->
name|flags
operator|!=
name|EV_ERROR
condition|)
continue|continue;
name|errno
operator|=
name|kp
operator|->
name|data
expr_stmt|;
name|warn
argument_list|(
literal|"%s:%s: kevent register index %d"
argument_list|,
name|testname
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kqueue_status
parameter_list|(
name|int
name|kqueue_fd
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
modifier|*
name|readable
parameter_list|,
name|int
modifier|*
name|writable
parameter_list|,
name|int
modifier|*
name|exception
parameter_list|,
specifier|const
name|char
modifier|*
name|testname
parameter_list|)
block|{
name|struct
name|kevent
name|kevent_eventlist
index|[
name|KQUEUE_MAX_EVENT
index|]
decl_stmt|,
modifier|*
name|kp
decl_stmt|;
name|struct
name|timespec
name|timeout
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|kevent
argument_list|(
name|kqueue_fd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|kevent_eventlist
argument_list|,
name|KQUEUE_MAX_EVENT
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: %s: kevent"
argument_list|,
name|testname
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|readable
operator|=
operator|*
name|writable
operator|=
operator|*
name|exception
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ret
condition|;
name|i
operator|++
control|)
block|{
name|kp
operator|=
operator|&
name|kevent_eventlist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|kp
operator|->
name|ident
operator|!=
operator|(
name|u_int
operator|)
name|fd
condition|)
continue|continue;
if|if
condition|(
name|kp
operator|->
name|filter
operator|==
name|EVFILT_READ
condition|)
operator|*
name|readable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|kp
operator|->
name|filter
operator|==
name|EVFILT_WRITE
condition|)
operator|*
name|writable
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fionread_status
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
modifier|*
name|readable
parameter_list|,
specifier|const
name|char
modifier|*
name|testname
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|i
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: ioctl(FIONREAD)"
argument_list|,
name|testname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
operator|*
name|readable
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|readable
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|READABLE
value|1
end_define

begin_define
define|#
directive|define
name|WRITABLE
value|1
end_define

begin_define
define|#
directive|define
name|EXCEPTION
value|1
end_define

begin_define
define|#
directive|define
name|NOT_READABLE
value|0
end_define

begin_define
define|#
directive|define
name|NOT_WRITABLE
value|0
end_define

begin_define
define|#
directive|define
name|NOT_EXCEPTION
value|0
end_define

begin_function
specifier|static
name|int
name|assert_status
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|kqueue_fd
parameter_list|,
name|int
name|assert_readable
parameter_list|,
name|int
name|assert_writable
parameter_list|,
name|int
name|assert_exception
parameter_list|,
specifier|const
name|char
modifier|*
name|testname
parameter_list|,
specifier|const
name|char
modifier|*
name|conditionname
parameter_list|,
specifier|const
name|char
modifier|*
name|fdname
parameter_list|)
block|{
name|int
name|readable
decl_stmt|,
name|writable
decl_stmt|,
name|exception
decl_stmt|;
if|if
condition|(
name|poll_status
argument_list|(
name|fd
argument_list|,
operator|&
name|readable
argument_list|,
operator|&
name|writable
argument_list|,
operator|&
name|exception
argument_list|,
name|testname
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|readable
operator|!=
name|assert_readable
operator|||
name|writable
operator|!=
name|assert_writable
operator|||
name|exception
operator|!=
name|assert_exception
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s polls r:%d, w:%d, e:%d on %s"
argument_list|,
name|testname
argument_list|,
name|fdname
argument_list|,
name|readable
argument_list|,
name|writable
argument_list|,
name|exception
argument_list|,
name|conditionname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|select_status
argument_list|(
name|fd
argument_list|,
operator|&
name|readable
argument_list|,
operator|&
name|writable
argument_list|,
operator|&
name|exception
argument_list|,
name|testname
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|readable
operator|!=
name|assert_readable
operator|||
name|writable
operator|!=
name|assert_writable
operator|||
name|exception
operator|!=
name|assert_exception
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s selects r:%d, w:%d, e:%d on %s"
argument_list|,
name|testname
argument_list|,
name|fdname
argument_list|,
name|readable
argument_list|,
name|writable
argument_list|,
name|exception
argument_list|,
name|conditionname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|kqueue_status
argument_list|(
name|kqueue_fd
argument_list|,
name|fd
argument_list|,
operator|&
name|readable
argument_list|,
operator|&
name|writable
argument_list|,
operator|&
name|exception
argument_list|,
name|testname
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|readable
operator|!=
name|assert_readable
operator|||
name|writable
operator|!=
name|assert_writable
operator|||
name|exception
operator|!=
name|assert_exception
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s kevent r:%d, w:%d, e:%d on %s"
argument_list|,
name|testname
argument_list|,
name|fdname
argument_list|,
name|readable
argument_list|,
name|writable
argument_list|,
name|exception
argument_list|,
name|conditionname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fionread_status
argument_list|(
name|fd
argument_list|,
operator|&
name|readable
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|readable
operator|!=
name|assert_readable
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s fionread r:%d on %s"
argument_list|,
name|testname
argument_list|,
name|fdname
argument_list|,
name|readable
argument_list|,
name|conditionname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * test_events() uses poll(), select(), and kevent() to query the status of  * fifo file descriptors and determine whether they match expected state  * based on earlier semantic tests: specifically, whether or not poll/select/  * kevent will correctly inform on readable/writable state following I/O.  *  * It would be nice to also test status changes as a result of closing of one  * or another fifo endpoint.  */
end_comment

begin_function
specifier|static
name|void
name|test_events_outofbox
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|kqueue_fd
decl_stmt|,
name|reader_fd
decl_stmt|,
name|writer_fd
decl_stmt|;
name|makefifo
argument_list|(
literal|"testfifo"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfifo
argument_list|(
literal|"testfifo"
argument_list|,
operator|&
name|reader_fd
argument_list|,
operator|&
name|writer_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_events_outofbox: openfifo: testfifo"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|kqueue_fd
operator|=
name|kqueue
argument_list|()
expr_stmt|;
if|if
condition|(
name|kqueue_fd
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: kqueue"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kqueue_setup
argument_list|(
name|kqueue_fd
argument_list|,
name|reader_fd
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kqueue_setup
argument_list|(
name|kqueue_fd
argument_list|,
name|writer_fd
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make sure that fresh, out-of-the-box fifo file descriptors have 	 * good initial states.  The reader_fd should have no active state, 	 * since it will not be readable (no data in pipe), writable (it's 	 * a read-only descriptor), and there's no reason for error yet. 	 */
if|if
condition|(
name|assert_status
argument_list|(
name|reader_fd
argument_list|,
name|kqueue_fd
argument_list|,
name|NOT_READABLE
argument_list|,
name|NOT_WRITABLE
argument_list|,
name|NOT_EXCEPTION
argument_list|,
name|__func__
argument_list|,
literal|"create"
argument_list|,
literal|"reader_fd"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make sure that fresh, out-of-the-box fifo file descriptors have 	 * good initial states.  The writer_fd should be ready to write. 	 */
if|if
condition|(
name|assert_status
argument_list|(
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|,
name|NOT_READABLE
argument_list|,
name|WRITABLE
argument_list|,
name|NOT_EXCEPTION
argument_list|,
name|__func__
argument_list|,
literal|"create"
argument_list|,
literal|"writer_fd"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_events_write_read_byte
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|kqueue_fd
decl_stmt|,
name|reader_fd
decl_stmt|,
name|writer_fd
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|u_char
name|ch
decl_stmt|;
name|makefifo
argument_list|(
literal|"testfifo"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfifo
argument_list|(
literal|"testfifo"
argument_list|,
operator|&
name|reader_fd
argument_list|,
operator|&
name|writer_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_events_write_read_byte: openfifo: testfifo"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|kqueue_fd
operator|=
name|kqueue
argument_list|()
expr_stmt|;
if|if
condition|(
name|kqueue_fd
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: kqueue"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kqueue_setup
argument_list|(
name|kqueue_fd
argument_list|,
name|reader_fd
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kqueue_setup
argument_list|(
name|kqueue_fd
argument_list|,
name|writer_fd
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Write a byte to the fifo, and make sure that the read end becomes 	 * readable, and that the write end remains writable (small write). 	 */
name|ch
operator|=
literal|0x00
expr_stmt|;
name|len
operator|=
name|write
argument_list|(
name|writer_fd
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: write"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|assert_status
argument_list|(
name|reader_fd
argument_list|,
name|kqueue_fd
argument_list|,
name|READABLE
argument_list|,
name|NOT_WRITABLE
argument_list|,
name|NOT_EXCEPTION
argument_list|,
name|__func__
argument_list|,
literal|"write"
argument_list|,
literal|"reader_fd"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * the writer_fd should remain writable. 	 */
if|if
condition|(
name|assert_status
argument_list|(
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|,
name|NOT_READABLE
argument_list|,
name|WRITABLE
argument_list|,
name|NOT_EXCEPTION
argument_list|,
name|__func__
argument_list|,
literal|"write"
argument_list|,
literal|"writer_fd"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Read the byte from the reader_fd, and now confirm that that fifo 	 * becomes unreadable. 	 */
name|len
operator|=
name|read
argument_list|(
name|reader_fd
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: read"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|assert_status
argument_list|(
name|reader_fd
argument_list|,
name|kqueue_fd
argument_list|,
name|NOT_READABLE
argument_list|,
name|NOT_WRITABLE
argument_list|,
name|NOT_EXCEPTION
argument_list|,
name|__func__
argument_list|,
literal|"write+read"
argument_list|,
literal|"reader_fd"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The writer_fd should remain writable. 	 */
if|if
condition|(
name|assert_status
argument_list|(
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|,
name|NOT_READABLE
argument_list|,
name|WRITABLE
argument_list|,
name|NOT_EXCEPTION
argument_list|,
name|__func__
argument_list|,
literal|"write+read"
argument_list|,
literal|"writer_fd"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a 512k buffer to the fifo in non-blocking mode, and make sure that  * the write end becomes un-writable as a result of a partial write that  * fills the fifo buffer.  */
end_comment

begin_function
specifier|static
name|void
name|test_events_partial_write
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|kqueue_fd
decl_stmt|,
name|reader_fd
decl_stmt|,
name|writer_fd
decl_stmt|;
name|u_char
modifier|*
name|buffer
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|makefifo
argument_list|(
literal|"testfifo"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfifo
argument_list|(
literal|"testfifo"
argument_list|,
operator|&
name|reader_fd
argument_list|,
operator|&
name|writer_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_events_partial_write: openfifo: testfifo"
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|kqueue_fd
operator|=
name|kqueue
argument_list|()
expr_stmt|;
if|if
condition|(
name|kqueue_fd
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: kqueue"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kqueue_setup
argument_list|(
name|kqueue_fd
argument_list|,
name|reader_fd
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kqueue_setup
argument_list|(
name|kqueue_fd
argument_list|,
name|writer_fd
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_nonblocking
argument_list|(
name|writer_fd
argument_list|,
literal|"test_events"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|=
name|malloc
argument_list|(
literal|512
operator|*
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"test_events_partial_write: malloc"
argument_list|)
expr_stmt|;
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|buffer
argument_list|,
literal|512
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|len
operator|=
name|write
argument_list|(
name|writer_fd
argument_list|,
name|buffer
argument_list|,
literal|512
operator|*
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"test_events_partial_write: write"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|assert_status
argument_list|(
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|,
name|NOT_READABLE
argument_list|,
name|NOT_WRITABLE
argument_list|,
name|NOT_EXCEPTION
argument_list|,
name|__func__
argument_list|,
literal|"big write"
argument_list|,
literal|"writer_fd"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drain_fd
argument_list|(
name|reader_fd
argument_list|,
literal|"test_events"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Test that the writer_fd has been restored to writable state after 	 * draining. 	 */
if|if
condition|(
name|assert_status
argument_list|(
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|,
name|NOT_READABLE
argument_list|,
name|WRITABLE
argument_list|,
name|NOT_EXCEPTION
argument_list|,
name|__func__
argument_list|,
literal|"big write + drain"
argument_list|,
literal|"writer_fd"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cleanfifo3
argument_list|(
literal|"testfifo"
argument_list|,
name|reader_fd
argument_list|,
name|writer_fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We don't comprehensively test O_RDWR file descriptors, but do run a couple  * of event tests to make sure that the fifo implementation doesn't mixed up  * status checks.  In particular, at least one past FreeBSD bug exists in  * which the FIONREAD test was performed on the wrong socket implementing the  * fifo, resulting in the fifo never returning readable.  */
end_comment

begin_function
specifier|static
name|void
name|test_events_rdwr
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|kqueue_fd
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|makefifo
argument_list|(
literal|"testfifo"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfifo_rw
argument_list|(
literal|"testfifo"
argument_list|,
operator|&
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: openfifo_rw: testfifo"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|kqueue_fd
operator|=
name|kqueue
argument_list|()
expr_stmt|;
if|if
condition|(
name|kqueue_fd
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: kqueue"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testifo"
argument_list|,
name|fd
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kqueue_setup
argument_list|(
name|kqueue_fd
argument_list|,
name|fd
argument_list|,
name|__func__
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * On first creation, the O_RDWR descriptor should be writable but 	 * not readable. 	 */
if|if
condition|(
name|assert_status
argument_list|(
name|fd
argument_list|,
name|kqueue_fd
argument_list|,
name|NOT_READABLE
argument_list|,
name|WRITABLE
argument_list|,
name|NOT_EXCEPTION
argument_list|,
name|__func__
argument_list|,
literal|"create"
argument_list|,
literal|"fd"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Write a byte, which should cause the file descriptor to become 	 * readable and writable. 	 */
name|ch
operator|=
literal|0x00
expr_stmt|;
name|len
operator|=
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: write"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|assert_status
argument_list|(
name|fd
argument_list|,
name|kqueue_fd
argument_list|,
name|READABLE
argument_list|,
name|WRITABLE
argument_list|,
name|NOT_EXCEPTION
argument_list|,
name|__func__
argument_list|,
literal|"write"
argument_list|,
literal|"fd"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Read a byte, which should cause the file descriptor to return to 	 * simply being writable. 	 */
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: read"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|assert_status
argument_list|(
name|fd
argument_list|,
name|kqueue_fd
argument_list|,
name|NOT_READABLE
argument_list|,
name|WRITABLE
argument_list|,
name|NOT_EXCEPTION
argument_list|,
name|__func__
argument_list|,
literal|"write+read"
argument_list|,
literal|"fd"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cleanfifo2
argument_list|(
literal|"testfifo"
argument_list|,
name|fd
argument_list|,
name|kqueue_fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|strcpy
argument_list|(
name|temp_dir
argument_list|,
literal|"fifo_io.XXXXXXXXXXX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdtemp
argument_list|(
name|temp_dir
argument_list|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"mkdtemp"
argument_list|)
expr_stmt|;
name|atexit
argument_list|(
name|atexit_temp_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|temp_dir
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|-
literal|1
argument_list|,
literal|"chdir %s"
argument_list|,
name|temp_dir
argument_list|)
expr_stmt|;
name|test_simpleio
argument_list|()
expr_stmt|;
name|test_blocking_read_empty
argument_list|()
expr_stmt|;
name|test_blocking_one_byte
argument_list|()
expr_stmt|;
name|test_nonblocking_one_byte
argument_list|()
expr_stmt|;
name|test_blocking_partial_write
argument_list|()
expr_stmt|;
name|test_nonblocking_partial_write
argument_list|()
expr_stmt|;
name|test_coalesce_big_read
argument_list|()
expr_stmt|;
name|test_coalesce_big_write
argument_list|()
expr_stmt|;
name|test_events_outofbox
argument_list|()
expr_stmt|;
name|test_events_write_read_byte
argument_list|()
expr_stmt|;
name|test_events_partial_write
argument_list|()
expr_stmt|;
name|test_events_rdwr
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

