begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 2014 Spectra Logic Corporation  *  All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions, and the following disclaimer,  *     without modification.  *  2. Redistributions in binary form must reproduce at minimum a disclaimer  *     substantially similar to the "NO WARRANTY" disclaimer below  *     ("Disclaimer") and any redistribution must be conditioned upon  *     including a substantially similar Disclaimer requirement for further  *     binary redistribution.  *  *  NO WARRANTY  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *  HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  *  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  *  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  *  POSSIBILITY OF SUCH DAMAGES.  *  *  Authors: Alan Somers         (Spectra Logic Corporation)  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/*  * Sends a single UDP packet to the provided address, with SO_DONTROUTE set  * I couldn't find a way to do this with builtin utilities like nc(1)  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|dst
decl_stmt|;
name|int
name|s
decl_stmt|,
name|t
decl_stmt|;
name|int
name|opt
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|sendbuf
init|=
literal|"Hello, World!"
decl_stmt|;
specifier|const
name|size_t
name|buflen
init|=
literal|80
decl_stmt|;
name|char
name|recvbuf
index|[
name|buflen
index|]
decl_stmt|;
name|bool
name|v6
init|=
name|false
decl_stmt|;
specifier|const
name|char
modifier|*
name|addr
decl_stmt|,
modifier|*
name|tapdev
decl_stmt|;
specifier|const
name|uint16_t
name|port
init|=
literal|46120
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
operator|||
name|argc
operator|>
literal|4
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-6] ip_address tapdev\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
literal|"-6"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|v6
operator|=
name|true
expr_stmt|;
name|addr
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|tapdev
operator|=
name|argv
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|tapdev
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
block|}
name|t
operator|=
name|open
argument_list|(
name|tapdev
argument_list|,
name|O_RDWR
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"open"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v6
condition|)
name|s
operator|=
name|socket
argument_list|(
name|PF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
name|opt
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DONTROUTE
argument_list|,
operator|&
name|opt
argument_list|,
sizeof|sizeof
argument_list|(
name|opt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"setsockopt(SO_DONTROUTE)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|dst6
init|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|dst
operator|)
decl_stmt|;
name|dst
operator|.
name|ss_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|dst
operator|.
name|ss_family
operator|=
name|AF_INET6
expr_stmt|;
name|dst6
operator|->
name|sin6_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|addr
argument_list|,
operator|&
name|dst6
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sockaddr_in
modifier|*
name|dst4
init|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|dst
operator|)
decl_stmt|;
name|dst
operator|.
name|ss_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|dst
operator|.
name|ss_family
operator|=
name|AF_INET
expr_stmt|;
name|dst4
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|ret
operator|=
name|inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|addr
argument_list|,
operator|&
name|dst4
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"inet_pton returned %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sendto
argument_list|(
name|s
argument_list|,
name|sendbuf
argument_list|,
name|strlen
argument_list|(
name|sendbuf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dst
argument_list|,
name|dst
operator|.
name|ss_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"sendto"
argument_list|)
expr_stmt|;
comment|/* Verify that the packet went to the desired tap device */
name|len
operator|=
name|read
argument_list|(
name|t
argument_list|,
name|recvbuf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"read returned EOF"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Did not receive any packets"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"read"
argument_list|)
expr_stmt|;
comment|/* 	 * If read returned anything at all, consider it a success.  The packet 	 * should be an Ethernet frame containing an ARP request for 	 * ip_address.  We won't bother to decode it 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

