begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2004 Michael J. Silbersack. All rights reserved.   Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.  THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/*  * $FreeBSD$  * The goal of this program is to see if fstat reports the correct  * data count for a pipe.  Prior to revision 1.172 of sys_pipe.c,  * 0 would be returned once the pipe entered direct write mode.  *  * Linux (2.6) always returns zero, so it's not a valuable platform  * for comparison.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|32768
index|]
decl_stmt|,
name|buffer2
index|[
literal|32768
index|]
decl_stmt|,
name|go
index|[]
init|=
literal|"go"
decl_stmt|,
name|go2
index|[]
init|=
literal|"go2"
decl_stmt|;
name|int
name|desc
index|[
literal|2
index|]
decl_stmt|,
name|ipc_coord
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|kevent
name|event
decl_stmt|,
name|ke
decl_stmt|;
name|ssize_t
name|error
decl_stmt|;
name|int
name|successes
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|status
decl_stmt|;
name|pid_t
name|new_pid
decl_stmt|;
name|int
name|kq
decl_stmt|;
name|error
operator|=
name|pipe
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Couldn't allocate data pipe"
argument_list|)
expr_stmt|;
name|error
operator|=
name|pipe
argument_list|(
name|ipc_coord
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Couldn't allocate IPC coordination pipe"
argument_list|)
expr_stmt|;
name|new_pid
operator|=
name|fork
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|new_pid
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|new_pid
operator|==
literal|0
condition|?
name|desc
index|[
literal|0
index|]
else|:
name|desc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
define|#
directive|define
name|SYNC_R
parameter_list|(
name|i
parameter_list|,
name|_buf
parameter_list|)
value|do {	\ 	int _error = errno; \ 	warnx("%d: waiting for synchronization", __LINE__); \ 	if (read(ipc_coord[i],&_buf, sizeof(_buf)) != sizeof(_buf)) \ 		err(1, "failed to synchronize (%s)", (i == 0 ? "parent" : "child")); \ 	errno = _error; \ 	} while(0)
define|#
directive|define
name|SYNC_W
parameter_list|(
name|i
parameter_list|,
name|_buf
parameter_list|)
value|do {	\ 	int _error = errno; \ 	warnx("%d: sending synchronization", __LINE__); \ 	if (write(ipc_coord[i],&_buf, sizeof(_buf)) != sizeof(_buf)) \ 		err(1, "failed to synchronize (%s)", (i == 0 ? "child" : "parent")); \ 	errno = _error; \ 	} while(0)
define|#
directive|define
name|WRITE
parameter_list|(
name|s
parameter_list|)
value|do { 							\ 	ssize_t _size; 							\ 	if ((_size = write(desc[1],&buffer, s)) != s)			\ 		warn("short write; wrote %zd, expected %d", _size, s);	\ 	} while(0)
if|if
condition|(
name|new_pid
operator|==
literal|0
condition|)
block|{
name|SYNC_R
argument_list|(
literal|0
argument_list|,
name|go
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
literal|145
argument_list|)
expr_stmt|;
name|SYNC_W
argument_list|(
literal|0
argument_list|,
name|go2
argument_list|)
expr_stmt|;
name|SYNC_R
argument_list|(
literal|0
argument_list|,
name|go
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
literal|2048
argument_list|)
expr_stmt|;
name|SYNC_W
argument_list|(
literal|0
argument_list|,
name|go2
argument_list|)
expr_stmt|;
name|SYNC_R
argument_list|(
literal|0
argument_list|,
name|go
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
literal|4096
argument_list|)
expr_stmt|;
name|SYNC_W
argument_list|(
literal|0
argument_list|,
name|go2
argument_list|)
expr_stmt|;
name|SYNC_R
argument_list|(
literal|0
argument_list|,
name|go
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
literal|8191
argument_list|)
expr_stmt|;
name|SYNC_W
argument_list|(
literal|0
argument_list|,
name|go2
argument_list|)
expr_stmt|;
name|SYNC_R
argument_list|(
literal|0
argument_list|,
name|go
argument_list|)
expr_stmt|;
name|SYNC_W
argument_list|(
literal|0
argument_list|,
name|go2
argument_list|)
expr_stmt|;
comment|/* XXX: why is this required? */
name|WRITE
argument_list|(
literal|8192
argument_list|)
expr_stmt|;
name|SYNC_W
argument_list|(
literal|0
argument_list|,
name|go2
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ipc_coord
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ipc_coord
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|kq
operator|=
name|kqueue
argument_list|()
expr_stmt|;
if|if
condition|(
name|kq
operator|==
operator|-
literal|1
condition|)
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|EV_SET
argument_list|(
operator|&
name|ke
argument_list|,
name|desc
index|[
literal|0
index|]
argument_list|,
name|EVFILT_READ
argument_list|,
name|EV_ADD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Attach event to the kqueue. */
if|if
condition|(
name|kevent
argument_list|(
name|kq
argument_list|,
operator|&
name|ke
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|_exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|successes
operator|<
literal|5
condition|)
block|{
name|SYNC_W
argument_list|(
literal|1
argument_list|,
name|go
argument_list|)
expr_stmt|;
name|SYNC_R
argument_list|(
literal|1
argument_list|,
name|go2
argument_list|)
expr_stmt|;
comment|/* Ensure data is available to read */
if|if
condition|(
name|kevent
argument_list|(
name|kq
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|event
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|1
condition|)
name|_exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|desc
index|[
literal|0
index|]
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|error
operator|=
name|read
argument_list|(
name|desc
index|[
literal|0
index|]
argument_list|,
operator|&
name|buffer2
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|st_size
operator|!=
name|error
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"FAILURE: stat size %jd read size %zd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|status
operator|.
name|st_size
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"SUCCESS at stat size %jd read size %zd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|status
operator|.
name|st_size
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|successes
operator|++
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

