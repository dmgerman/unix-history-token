begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2004 Michael J. Silbersack. All rights reserved.   Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.  THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/*  * $FreeBSD$  * This program tests to make sure that wraparound writes and reads  * are working, assuming that 16K socket buffers are used.  In order  * to really stress the pipe code with this test, kernel modifications  * nay be necessary.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|32768
index|]
decl_stmt|,
name|buffer2
index|[
literal|32768
index|]
decl_stmt|,
name|go
index|[]
init|=
literal|"go"
decl_stmt|,
name|go2
index|[]
init|=
literal|"go2"
decl_stmt|;
name|int
name|desc
index|[
literal|2
index|]
decl_stmt|,
name|ipc_coord
index|[
literal|2
index|]
decl_stmt|;
name|ssize_t
name|error
decl_stmt|,
name|total
decl_stmt|;
name|int
name|buggy
decl_stmt|,
name|i
decl_stmt|;
name|pid_t
name|new_pid
decl_stmt|;
name|buggy
operator|=
literal|0
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|pipe
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Couldn't allocate data pipe"
argument_list|)
expr_stmt|;
name|error
operator|=
name|pipe
argument_list|(
name|ipc_coord
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Couldn't allocate IPC coordination pipe"
argument_list|)
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
literal|'A'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
name|buffer
index|[
name|i
operator|-
literal|1
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|>
literal|'Z'
condition|)
name|buffer
index|[
name|i
index|]
operator|=
literal|'A'
expr_stmt|;
block|}
name|new_pid
operator|=
name|fork
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|new_pid
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
define|#
directive|define
name|SYNC_R
parameter_list|(
name|i
parameter_list|,
name|_buf
parameter_list|)
value|do {	\ 	int _error = errno; \ 	warnx("%d: waiting for synchronization", __LINE__); \ 	if (read(ipc_coord[i],&_buf, sizeof(_buf)) != sizeof(_buf)) \ 		err(1, "failed to synchronize (%s)", (i == 0 ? "parent" : "child")); \ 	errno = _error; \ 	} while(0)
define|#
directive|define
name|SYNC_W
parameter_list|(
name|i
parameter_list|,
name|_buf
parameter_list|)
value|do {	\ 	int _error = errno; \ 	warnx("%d: sending synchronization", __LINE__); \ 	if (write(ipc_coord[i],&_buf, sizeof(_buf)) != sizeof(_buf)) \ 		err(1, "failed to synchronize (%s)", (i == 0 ? "child" : "parent")); \ 	errno = _error; \ 	} while(0)
define|#
directive|define
name|WRITE
parameter_list|(
name|s
parameter_list|)
value|do { 							\ 	ssize_t _size; 							\ 	if ((_size = write(desc[1],&buffer[total], s)) != s)		\ 		warn("short write; wrote %zd, expected %d", _size, s);	\ 	total += _size;							\ 	} while(0)
if|if
condition|(
name|new_pid
operator|==
literal|0
condition|)
block|{
name|WRITE
argument_list|(
literal|4096
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
literal|4096
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
name|SYNC_W
argument_list|(
literal|0
argument_list|,
name|go2
argument_list|)
expr_stmt|;
name|SYNC_R
argument_list|(
literal|0
argument_list|,
name|go
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
name|SYNC_W
argument_list|(
literal|0
argument_list|,
name|go2
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|SYNC_R
argument_list|(
literal|1
argument_list|,
name|go2
argument_list|)
expr_stmt|;
name|error
operator|=
name|read
argument_list|(
name|desc
index|[
literal|0
index|]
argument_list|,
operator|&
name|buffer2
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
name|total
operator|+=
name|error
expr_stmt|;
name|printf
argument_list|(
literal|"Read %zd bytes\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|SYNC_W
argument_list|(
literal|1
argument_list|,
name|go
argument_list|)
expr_stmt|;
name|SYNC_R
argument_list|(
literal|1
argument_list|,
name|go2
argument_list|)
expr_stmt|;
name|error
operator|=
name|read
argument_list|(
name|desc
index|[
literal|0
index|]
argument_list|,
operator|&
name|buffer2
index|[
name|total
index|]
argument_list|,
literal|16384
argument_list|)
expr_stmt|;
name|total
operator|+=
name|error
expr_stmt|;
name|printf
argument_list|(
literal|"Read %zd bytes, done\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|buffer
argument_list|,
name|buffer2
argument_list|,
name|total
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|!=
name|buffer2
index|[
name|i
index|]
condition|)
block|{
name|buggy
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"Location %d input: %hhx output: %hhx\n"
argument_list|,
name|i
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|,
name|buffer2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|waitpid
argument_list|(
name|new_pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buggy
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"FAILURE"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SUCCESS\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

