begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 1996, 1997, 2000 N.M. Maclaren     Copyright (C) 1996, 1997, 2000 The University of Cambridge  This is a complete SNTP implementation, which was easier to write than to port xntp to a new version of Unix with any hope of maintaining it thereafter.  It supports the full SNTP (RFC 2030) client- and server-side challenge-response and broadcast protocols.  It should achieve nearly optimal accuracy with very few transactions, provided only that a client has access to a trusted server and that communications are not INVARIABLY slow.  As this is the environment in which 90-99% of all NTP systems are run ....  The specification of this program is:      msntp [ --help | -h | -? ] [ -v | -V | -W ]         [ -B [ period ] | -S | -q [ -f savefile ] |             [ { -r | -a } [ -P prompt ] [ -l lockfile ] ]             [ -c count ] [ -e minerr ][ -E maxerr ]             [ -d delay | -x [ separation ] [ -f savefile ] ]             [ -4 | -6 ] [ address(es) ] ]      --help, -h and -? all print the syntax of the command.      -v indicates that diagnostic messages should be written to standard error, and -V requests more output for investigating apparently inconsistent timestamps.  -W requests very verbose debugging output, and will interfere with the timing when writing to the terminal (because of line buffered output from C); it is useful only when debugging the source.  Note that the times produced by -V and -W are the corrections needed, and not the error in the local clock.      -B indicates that it should behave as a server, broadcasting time packets at intervals of 'period' minutes.  Acceptable values of 'period' are from 1 to 1440 (a day) and the default is 60.  Naturally, this will work only if the user has enough privilege.      -S indicates that it should behave as a server, responding to time requests  from clients.  Naturally, this will work only if the user has enough privilege.      -q indicates that it will query a savefile that is being maintained by it being run in daemon mode.       The default is that it should behave as a client, and the following options are then relevant:      -r indicates that the system clock should be reset by 'settimeofday'. Naturally, this will work only if the user has enough privilege.      -a indicates that the system clock should be reset by 'adjtime'. Naturally, this will work only if the user has enough privilege.      -x indicates that the program should run as a daemon (i.e. forever), and allow for clock drift.      -4 or -6 force dns resolving to ipv4 or ipv6 addresses.      The default is to write the current date and time to the standard output in a format like '1996 Oct 15 20:17:25.123 + 4.567 +/- 0.089 secs', indicating the estimated true (local) time and the error in the local clock.  In daemon mode, it will add drift information in a format like ' + 1.3 +/- 0.1 ppm', and display this at roughly 'separation' intervals.      'minerr' is the maximum ignorable variation between the clocks.  Acceptable values are from 0.001 to 1, and the default is 0.1 if 'address' is specified and 0.5 otherwise.      'maxerr' is the maximum value of various delays that are deemed acceptable. Acceptable values are from 1 to 60, and the default is 5.  It should sometimes be increased if there are problems with the network, NTP server or system clock, but take care.      'prompt' is the maximum clock change that will be made automatically. Acceptable values are from 1 to 3600, and the default is 30.  If the program is being run interactively, larger values will cause a prompt.  The value may also be 'no', and the change will be made without prompting.      'count' is the maximum number of NTP packets to require.  Acceptable values are from 1 to 25 if 'address' is specified and '-x' is not, and from 5 to 25 otherwise; the default is 5.  If the maximum isn't enough, you need a better consistency algorithm than this program uses.  Don't increase it.      'delay' is a rough limit on the total running time in seconds.  Acceptable values are from 1 to 3600, and the default is 15 if 'address' is specified and 300 otherwise.      'separation' is the time to wait between calls to the server in minutes if 'address' is specified, and the minimum time between broadcast packets if not. Acceptable values are from 1 to 1440 (a day), and the default is 300.      'lockfile' may be used in an update mode to ensure that there is only one copy of msntp running at once.  The default is installation-dependent, but will usually be /etc/msntp.pid.      'savefile' may be used in daemon mode to store a record of previous packets, which may speed up recalculating the drift after msntp has to be restarted (e.g. because of network or server outages).  The default is installation-dependent, but will usually be /etc/msntp.state.  Note that there is no locking of this file, and using it twice may cause chaos.      'address' is the DNS name or IP number of a host to poll; if no name is given, the program waits for broadcasts.  Note that a single component numeric address is not allowed.  For sanity, it is also required that 'minerr'< 'maxerr'< 'delay' (if listening for broadcasts, 'delay/count' and, in daemon mode, 'separation') and, for sordid Unixish reasons, that 2*'count'< 'delay'.  The last could be fixed, but isn't worth it.  Note that none of the above values are closely linked to the limits described in the NTP protocol (RFC 1305).  Do not increase the compiled-in bounds excessively, or the code will fail.  The algorithm used to decide whether to accept a correction is whether it would seem to improve matters.  Unlike the 'xntp' suite, little attempt is made to handle really knotted scenarios, and diagnostics are written to standard error. In non-daemon client mode, it is intended to be run as a command or in a 'cron' job.  Unlike 'ntpdate', its default mode is simply to display the clock error.  It assumes that floating-point arithmetic is tolerably efficient, which is true for even the cheapest personal computer nowadays.  If, however, you want to port this to a toaster, you may have problems!  In its terminating modes, its return code is EXIT_SUCCESS if the operation was completed successfully and EXIT_FAILURE otherwise.  In server or daemon mode, it runs for ever and stops with a return code EXIT_FAILURE only after a severe error.  Commonly, two server processes will be run, one with each of the -B and -S options.  In daemon mode, it will fail if the server is inaccessible for a long time or seriously sick, and will need manual restarting.   WARNING: this program has reached its 'hack count' and needs restructuring, badly.  Perhaps the worst code is in run_daemon().  You are advised not to fiddle unless you really have to. */
end_comment

begin_include
include|#
directive|include
file|"header.h"
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_define
define|#
directive|define
name|MAIN
end_define

begin_include
include|#
directive|include
file|"kludges.h"
end_include

begin_undef
undef|#
directive|undef
name|MAIN
end_undef

begin_comment
comment|/* NTP definitions.  Note that these assume 8-bit bytes - sigh.  There is little point in parameterising everything, as it is neither feasible nor useful.  It would be very useful if more fields could be defined as unspecified.  The NTP packet-handling routines contain a lot of extra assumptions. */
end_comment

begin_define
define|#
directive|define
name|JAN_1970
value|2208988800.0
end_define

begin_comment
comment|/* 1970 - 1900 in seconds */
end_comment

begin_define
define|#
directive|define
name|NTP_SCALE
value|4294967296.0
end_define

begin_comment
comment|/* 2^32, of course! */
end_comment

begin_define
define|#
directive|define
name|NTP_PACKET_MIN
value|48
end_define

begin_comment
comment|/* Without authentication */
end_comment

begin_define
define|#
directive|define
name|NTP_PACKET_MAX
value|68
end_define

begin_comment
comment|/* With authentication (ignored) */
end_comment

begin_define
define|#
directive|define
name|NTP_DISP_FIELD
value|8
end_define

begin_comment
comment|/* Offset of dispersion field */
end_comment

begin_define
define|#
directive|define
name|NTP_REFERENCE
value|16
end_define

begin_comment
comment|/* Offset of reference timestamp */
end_comment

begin_define
define|#
directive|define
name|NTP_ORIGINATE
value|24
end_define

begin_comment
comment|/* Offset of originate timestamp */
end_comment

begin_define
define|#
directive|define
name|NTP_RECEIVE
value|32
end_define

begin_comment
comment|/* Offset of receive timestamp */
end_comment

begin_define
define|#
directive|define
name|NTP_TRANSMIT
value|40
end_define

begin_comment
comment|/* Offset of transmit timestamp */
end_comment

begin_define
define|#
directive|define
name|NTP_LI_FUDGE
value|0
end_define

begin_comment
comment|/* The current 'status' */
end_comment

begin_define
define|#
directive|define
name|NTP_VERSION
value|3
end_define

begin_comment
comment|/* The current version */
end_comment

begin_define
define|#
directive|define
name|NTP_VERSION_MAX
value|4
end_define

begin_comment
comment|/* The maximum valid version */
end_comment

begin_define
define|#
directive|define
name|NTP_STRATUM
value|15
end_define

begin_comment
comment|/* The current stratum as a server */
end_comment

begin_define
define|#
directive|define
name|NTP_STRATUM_MAX
value|15
end_define

begin_comment
comment|/* The maximum valid stratum */
end_comment

begin_define
define|#
directive|define
name|NTP_POLLING
value|8
end_define

begin_comment
comment|/* The current 'polling interval' */
end_comment

begin_define
define|#
directive|define
name|NTP_PRECISION
value|0
end_define

begin_comment
comment|/* The current 'precision' - 1 sec. */
end_comment

begin_define
define|#
directive|define
name|NTP_ACTIVE
value|1
end_define

begin_comment
comment|/* NTP symmetric active request */
end_comment

begin_define
define|#
directive|define
name|NTP_PASSIVE
value|2
end_define

begin_comment
comment|/* NTP symmetric passive response */
end_comment

begin_define
define|#
directive|define
name|NTP_CLIENT
value|3
end_define

begin_comment
comment|/* NTP client request */
end_comment

begin_define
define|#
directive|define
name|NTP_SERVER
value|4
end_define

begin_comment
comment|/* NTP server response */
end_comment

begin_define
define|#
directive|define
name|NTP_BROADCAST
value|5
end_define

begin_comment
comment|/* NTP server broadcast */
end_comment

begin_define
define|#
directive|define
name|NTP_INSANITY
value|3600.0
end_define

begin_comment
comment|/* Errors beyond this are hopeless */
end_comment

begin_define
define|#
directive|define
name|RESET_MIN
value|15
end_define

begin_comment
comment|/* Minimum period between resets */
end_comment

begin_define
define|#
directive|define
name|ABSCISSA
value|3.0
end_define

begin_comment
comment|/* Scale factor for standard errors */
end_comment

begin_comment
comment|/* Local definitions and global variables (mostly options).  These are all of the quantities that control the main actions of the program.  The first three  are the only ones that are exported to other modules. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|argv0
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For diagnostics only - not NULL */
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|,
comment|/* Default = 0, -v = 1, -V = 2, -W = 3 */
name|operation
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Defined in header.h - see action */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|lockname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the lock file */
end_comment

begin_define
define|#
directive|define
name|COUNT_MAX
value|25
end_define

begin_comment
comment|/* Do NOT increase this! */
end_comment

begin_define
define|#
directive|define
name|WEEBLE_FACTOR
value|1.2
end_define

begin_comment
comment|/* See run_server() and run_daemon() */
end_comment

begin_define
define|#
directive|define
name|ETHERNET_MAX
value|5
end_define

begin_comment
comment|/* See run_daemon() and run_client() */
end_comment

begin_define
define|#
directive|define
name|action_display
value|1
end_define

begin_comment
comment|/* Just display the result */
end_comment

begin_define
define|#
directive|define
name|action_reset
value|2
end_define

begin_comment
comment|/* Reset using 'settimeofday' */
end_comment

begin_define
define|#
directive|define
name|action_adjust
value|3
end_define

begin_comment
comment|/* Reset using 'adjtime' */
end_comment

begin_define
define|#
directive|define
name|action_broadcast
value|4
end_define

begin_comment
comment|/* Behave as a server, broadcasting */
end_comment

begin_define
define|#
directive|define
name|action_server
value|5
end_define

begin_comment
comment|/* Behave as a server for clients */
end_comment

begin_define
define|#
directive|define
name|action_query
value|6
end_define

begin_comment
comment|/* Query a daemon savefile */
end_comment

begin_define
define|#
directive|define
name|save_read_only
value|1
end_define

begin_comment
comment|/* Read the saved state only */
end_comment

begin_define
define|#
directive|define
name|save_read_check
value|2
end_define

begin_comment
comment|/* Read and check it */
end_comment

begin_define
define|#
directive|define
name|save_write
value|3
end_define

begin_comment
comment|/* Write the saved state */
end_comment

begin_define
define|#
directive|define
name|save_clear
value|4
end_define

begin_comment
comment|/* Clear the saved state */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|version
index|[]
init|=
name|VERSION
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For reverse engineering :-) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|action
init|=
literal|0
decl_stmt|,
comment|/* Defined above - see operation */
name|period
init|=
literal|0
decl_stmt|,
comment|/* -B value in seconds (broadcast) */
name|count
init|=
literal|0
decl_stmt|,
comment|/* -c value in seconds */
name|delay
init|=
literal|0
decl_stmt|,
comment|/* -d or -x value in seconds */
name|attempts
init|=
literal|0
decl_stmt|,
comment|/* Packets transmitted up to 2*count */
name|waiting
init|=
literal|0
decl_stmt|,
comment|/* -d/-c except for in daemon mode */
name|locked
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set_lock(1) has been called */
end_comment

begin_decl_stmt
specifier|static
name|double
name|outgoing
index|[
literal|2
operator|*
name|COUNT_MAX
index|]
decl_stmt|,
comment|/* Transmission timestamps */
name|minerr
init|=
literal|0.0
decl_stmt|,
comment|/* -e value in seconds */
name|maxerr
init|=
literal|0.0
decl_stmt|,
comment|/* -E value in seconds */
name|prompt
init|=
literal|0.0
decl_stmt|,
comment|/* -p value in seconds */
name|dispersion
init|=
literal|0.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The source dispersion in seconds */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|savefile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the data to restart from */
end_comment

begin_comment
comment|/* The unpacked NTP data structure, with all the fields even remotely relevant to SNTP. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|NTP_DATA
block|{
name|unsigned
name|char
name|status
decl_stmt|,
name|version
decl_stmt|,
name|mode
decl_stmt|,
name|stratum
decl_stmt|,
name|polling
decl_stmt|,
name|precision
decl_stmt|;
name|double
name|dispersion
decl_stmt|,
name|reference
decl_stmt|,
name|originate
decl_stmt|,
name|receive
decl_stmt|,
name|transmit
decl_stmt|,
name|current
decl_stmt|;
block|}
name|ntp_data
typedef|;
end_typedef

begin_comment
comment|/* The following structure is used to keep a record of packets in daemon mode; it contains only the information that is actually used for the drift and error calculations. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|double
name|dispersion
decl_stmt|,
name|weight
decl_stmt|,
name|when
decl_stmt|,
name|offset
decl_stmt|,
name|error
decl_stmt|;
block|}
name|data_record
typedef|;
end_typedef

begin_function
name|void
name|fatal
parameter_list|(
name|int
name|syserr
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|,
specifier|const
name|char
modifier|*
name|insert
parameter_list|)
block|{
comment|/* Issue a diagnostic and stop.  Be a little paranoid about recursion. */
name|int
name|k
init|=
name|errno
decl_stmt|;
specifier|static
name|int
name|called
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|message
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
name|k
expr_stmt|;
if|if
condition|(
name|syserr
condition|)
name|perror
argument_list|(
name|argv0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|called
condition|)
block|{
name|called
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|savefile
operator|!=
name|NULL
operator|&&
name|fclose
argument_list|(
name|savefile
argument_list|)
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to close the daemon save file"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|set_lock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|syntax
parameter_list|(
name|int
name|halt
parameter_list|)
block|{
comment|/* The standard, unfriendly Unix error message.  Some errors are diagnosed more helpfully.  This is called before any files or sockets are opened. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Syntax: %s [ --help | -h | -? ] [ -v | -V | -W ] \n"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    [ -B period | -S | -q [ -f savefile ] |\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"        [ { -r | -a } [ -P prompt ] [ -l lockfile ] ]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"            [ -c count ] [ -e minerr ] [ -E maxerr ]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"            [ -d delay | -x [ separation ] "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[ -f savefile ] ]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"        [ -4 | -6 ] [ address(es) ] ]\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|halt
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|display_data
parameter_list|(
name|ntp_data
modifier|*
name|data
parameter_list|)
block|{
comment|/* This formats the essential NTP data, as a debugging aid. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sta=%d ver=%d mod=%d str=%d pol=%d dis=%.6f ref=%.6f\n"
argument_list|,
name|data
operator|->
name|status
argument_list|,
name|data
operator|->
name|version
argument_list|,
name|data
operator|->
name|mode
argument_list|,
name|data
operator|->
name|stratum
argument_list|,
name|data
operator|->
name|polling
argument_list|,
name|data
operator|->
name|dispersion
argument_list|,
name|data
operator|->
name|reference
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ori=%.6f rec=%.6f\n"
argument_list|,
name|data
operator|->
name|originate
argument_list|,
name|data
operator|->
name|receive
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tra=%.6f cur=%.6f\n"
argument_list|,
name|data
operator|->
name|transmit
argument_list|,
name|data
operator|->
name|current
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|display_packet
parameter_list|(
name|unsigned
name|char
modifier|*
name|packet
parameter_list|,
name|int
name|length
parameter_list|)
block|{
comment|/* This formats a possible packet very roughly, as a debugging aid. */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|length
operator|<
name|NTP_PACKET_MIN
operator|||
name|length
operator|>
name|NTP_PACKET_MAX
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|i
operator|%
literal|32
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|i
operator|%
literal|4
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%.2x"
argument_list|,
name|packet
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pack_ntp
parameter_list|(
name|unsigned
name|char
modifier|*
name|packet
parameter_list|,
name|int
name|length
parameter_list|,
name|ntp_data
modifier|*
name|data
parameter_list|)
block|{
comment|/* Pack the essential data into an NTP packet, bypassing struct layout and endian problems.  Note that it ignores fields irrelevant to SNTP. */
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|double
name|d
decl_stmt|;
name|memset
argument_list|(
name|packet
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
expr_stmt|;
name|packet
index|[
literal|0
index|]
operator|=
operator|(
name|data
operator|->
name|status
operator|<<
literal|6
operator|)
operator||
operator|(
name|data
operator|->
name|version
operator|<<
literal|3
operator|)
operator||
name|data
operator|->
name|mode
expr_stmt|;
name|packet
index|[
literal|1
index|]
operator|=
name|data
operator|->
name|stratum
expr_stmt|;
name|packet
index|[
literal|2
index|]
operator|=
name|data
operator|->
name|polling
expr_stmt|;
name|packet
index|[
literal|3
index|]
operator|=
name|data
operator|->
name|precision
expr_stmt|;
name|d
operator|=
name|data
operator|->
name|originate
operator|/
name|NTP_SCALE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
call|(
name|int
call|)
argument_list|(
name|d
operator|*=
literal|256.0
argument_list|)
operator|)
operator|>=
literal|256
condition|)
name|k
operator|=
literal|255
expr_stmt|;
name|packet
index|[
name|NTP_ORIGINATE
operator|+
name|i
index|]
operator|=
name|k
expr_stmt|;
name|d
operator|-=
name|k
expr_stmt|;
block|}
name|d
operator|=
name|data
operator|->
name|receive
operator|/
name|NTP_SCALE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
call|(
name|int
call|)
argument_list|(
name|d
operator|*=
literal|256.0
argument_list|)
operator|)
operator|>=
literal|256
condition|)
name|k
operator|=
literal|255
expr_stmt|;
name|packet
index|[
name|NTP_RECEIVE
operator|+
name|i
index|]
operator|=
name|k
expr_stmt|;
name|d
operator|-=
name|k
expr_stmt|;
block|}
name|d
operator|=
name|data
operator|->
name|transmit
operator|/
name|NTP_SCALE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
call|(
name|int
call|)
argument_list|(
name|d
operator|*=
literal|256.0
argument_list|)
operator|)
operator|>=
literal|256
condition|)
name|k
operator|=
literal|255
expr_stmt|;
name|packet
index|[
name|NTP_TRANSMIT
operator|+
name|i
index|]
operator|=
name|k
expr_stmt|;
name|d
operator|-=
name|k
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|unpack_ntp
parameter_list|(
name|ntp_data
modifier|*
name|data
parameter_list|,
name|unsigned
name|char
modifier|*
name|packet
parameter_list|,
name|int
name|length
parameter_list|)
block|{
comment|/* Unpack the essential data from an NTP packet, bypassing struct layout and endian problems.  Note that it ignores fields irrelevant to SNTP. */
name|int
name|i
decl_stmt|;
name|double
name|d
decl_stmt|;
name|data
operator|->
name|current
operator|=
name|current_time
argument_list|(
name|JAN_1970
argument_list|)
expr_stmt|;
comment|/* Best to come first */
name|data
operator|->
name|status
operator|=
operator|(
name|packet
index|[
literal|0
index|]
operator|>>
literal|6
operator|)
expr_stmt|;
name|data
operator|->
name|version
operator|=
operator|(
name|packet
index|[
literal|0
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x07
expr_stmt|;
name|data
operator|->
name|mode
operator|=
name|packet
index|[
literal|0
index|]
operator|&
literal|0x07
expr_stmt|;
name|data
operator|->
name|stratum
operator|=
name|packet
index|[
literal|1
index|]
expr_stmt|;
name|data
operator|->
name|polling
operator|=
name|packet
index|[
literal|2
index|]
expr_stmt|;
name|data
operator|->
name|precision
operator|=
name|packet
index|[
literal|3
index|]
expr_stmt|;
name|d
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
name|d
operator|=
literal|256.0
operator|*
name|d
operator|+
name|packet
index|[
name|NTP_DISP_FIELD
operator|+
name|i
index|]
expr_stmt|;
name|data
operator|->
name|dispersion
operator|=
name|d
operator|/
literal|65536.0
expr_stmt|;
name|d
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|d
operator|=
literal|256.0
operator|*
name|d
operator|+
name|packet
index|[
name|NTP_REFERENCE
operator|+
name|i
index|]
expr_stmt|;
name|data
operator|->
name|reference
operator|=
name|d
operator|/
name|NTP_SCALE
expr_stmt|;
name|d
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|d
operator|=
literal|256.0
operator|*
name|d
operator|+
name|packet
index|[
name|NTP_ORIGINATE
operator|+
name|i
index|]
expr_stmt|;
name|data
operator|->
name|originate
operator|=
name|d
operator|/
name|NTP_SCALE
expr_stmt|;
name|d
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|d
operator|=
literal|256.0
operator|*
name|d
operator|+
name|packet
index|[
name|NTP_RECEIVE
operator|+
name|i
index|]
expr_stmt|;
name|data
operator|->
name|receive
operator|=
name|d
operator|/
name|NTP_SCALE
expr_stmt|;
name|d
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|d
operator|=
literal|256.0
operator|*
name|d
operator|+
name|packet
index|[
name|NTP_TRANSMIT
operator|+
name|i
index|]
expr_stmt|;
name|data
operator|->
name|transmit
operator|=
name|d
operator|/
name|NTP_SCALE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|make_packet
parameter_list|(
name|ntp_data
modifier|*
name|data
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
comment|/* Create an outgoing NTP packet, either from scratch or starting from a request from a client.  Note that it implements the NTP specification, even when this is clearly misguided, except possibly for the setting of LI.  It would be easy enough to add a sanity flag, but I am not in the business of designing an alternative protocol (however much better it might be). */
name|data
operator|->
name|status
operator|=
name|NTP_LI_FUDGE
operator|<<
literal|6
expr_stmt|;
name|data
operator|->
name|stratum
operator|=
name|NTP_STRATUM
expr_stmt|;
name|data
operator|->
name|reference
operator|=
name|data
operator|->
name|dispersion
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|NTP_SERVER
condition|)
block|{
name|data
operator|->
name|mode
operator|=
operator|(
name|data
operator|->
name|mode
operator|==
name|NTP_CLIENT
condition|?
name|NTP_SERVER
else|:
name|NTP_PASSIVE
operator|)
expr_stmt|;
name|data
operator|->
name|originate
operator|=
name|data
operator|->
name|transmit
expr_stmt|;
name|data
operator|->
name|receive
operator|=
name|data
operator|->
name|current
expr_stmt|;
block|}
else|else
block|{
name|data
operator|->
name|version
operator|=
name|NTP_VERSION
expr_stmt|;
name|data
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|data
operator|->
name|polling
operator|=
name|NTP_POLLING
expr_stmt|;
name|data
operator|->
name|precision
operator|=
name|NTP_PRECISION
expr_stmt|;
name|data
operator|->
name|receive
operator|=
name|data
operator|->
name|originate
operator|=
literal|0.0
expr_stmt|;
block|}
name|data
operator|->
name|current
operator|=
name|data
operator|->
name|transmit
operator|=
name|current_time
argument_list|(
name|JAN_1970
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|read_packet
parameter_list|(
name|int
name|which
parameter_list|,
name|ntp_data
modifier|*
name|data
parameter_list|,
name|double
modifier|*
name|off
parameter_list|,
name|double
modifier|*
name|err
parameter_list|)
block|{
comment|/* Check the packet and work out the offset and optionally the error.  Note that this contains more checking than xntp does.  This returns 0 for success, 1 for failure and 2 for an ignored broadcast packet (a kludge for servers).  Note that it must not change its arguments if it fails. */
name|unsigned
name|char
name|receive
index|[
name|NTP_PACKET_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|double
name|delay1
decl_stmt|,
name|delay2
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|response
init|=
literal|0
decl_stmt|,
name|failed
decl_stmt|,
name|length
decl_stmt|,
name|i
decl_stmt|,
name|k
decl_stmt|;
comment|/* Read the packet and deal with diagnostics. */
if|if
condition|(
operator|(
name|length
operator|=
name|read_socket
argument_list|(
name|which
argument_list|,
name|receive
argument_list|,
name|NTP_PACKET_MAX
operator|+
literal|1
argument_list|,
name|waiting
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|length
operator|<
name|NTP_PACKET_MIN
operator|||
name|length
operator|>
name|NTP_PACKET_MAX
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad length %d for NTP packet on socket %d\n"
argument_list|,
name|argv0
argument_list|,
name|length
argument_list|,
name|which
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Incoming packet on socket %d:\n"
argument_list|,
name|which
argument_list|)
expr_stmt|;
name|display_packet
argument_list|(
name|receive
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|unpack_ntp
argument_list|(
name|data
argument_list|,
name|receive
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|display_data
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Start by checking that the packet looks reasonable.  Be a little paranoid, but allow for version 1 semantics and sick clients. */
if|if
condition|(
name|operation
operator|==
name|op_server
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|mode
operator|==
name|NTP_BROADCAST
condition|)
return|return
literal|2
return|;
name|failed
operator|=
operator|(
name|data
operator|->
name|mode
operator|!=
name|NTP_CLIENT
operator|&&
name|data
operator|->
name|mode
operator|!=
name|NTP_ACTIVE
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|op_listen
condition|)
name|failed
operator|=
operator|(
name|data
operator|->
name|mode
operator|!=
name|NTP_BROADCAST
operator|)
expr_stmt|;
else|else
block|{
name|failed
operator|=
operator|(
name|data
operator|->
name|mode
operator|!=
name|NTP_SERVER
operator|&&
name|data
operator|->
name|mode
operator|!=
name|NTP_PASSIVE
operator|)
expr_stmt|;
name|response
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|failed
operator|||
name|data
operator|->
name|status
operator|!=
literal|0
operator|||
name|data
operator|->
name|version
operator|<
literal|1
operator|||
name|data
operator|->
name|version
operator|>
name|NTP_VERSION_MAX
operator|||
name|data
operator|->
name|stratum
operator|>
name|NTP_STRATUM_MAX
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: totally spurious NTP packet rejected on socket %d\n"
argument_list|,
name|argv0
argument_list|,
name|which
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Note that the conventions are very poorly defined in the NTP protocol, so we have to guess.  Any full NTP server perpetrating completely unsynchronised packets is an abomination, anyway, so reject it. */
name|delay1
operator|=
name|data
operator|->
name|transmit
operator|-
name|data
operator|->
name|receive
expr_stmt|;
name|delay2
operator|=
name|data
operator|->
name|current
operator|-
name|data
operator|->
name|originate
expr_stmt|;
name|failed
operator|=
operator|(
operator|(
name|data
operator|->
name|stratum
operator|!=
literal|0
operator|&&
name|data
operator|->
name|stratum
operator|!=
name|NTP_STRATUM_MAX
operator|&&
name|data
operator|->
name|reference
operator|==
literal|0.0
operator|)
operator|||
operator|(
name|operation
operator|!=
name|op_server
operator|&&
name|data
operator|->
name|transmit
operator|==
literal|0.0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|response
operator|&&
operator|(
name|data
operator|->
name|originate
operator|==
literal|0.0
operator|||
name|data
operator|->
name|receive
operator|==
literal|0.0
operator|||
operator|(
name|data
operator|->
name|reference
operator|!=
literal|0.0
operator|&&
name|data
operator|->
name|receive
operator|<
name|data
operator|->
name|reference
operator|)
operator|||
name|delay1
operator|<
literal|0.0
operator|||
name|delay1
operator|>
name|NTP_INSANITY
operator|||
name|delay2
operator|<
literal|0.0
operator|||
name|data
operator|->
name|dispersion
operator|>
name|NTP_INSANITY
operator|)
condition|)
name|failed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|failed
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: incomprehensible NTP packet rejected on socket %d\n"
argument_list|,
name|argv0
argument_list|,
name|which
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If it is a response, check that it corresponds to one of our requests and has got here in a reasonable length of time. */
if|if
condition|(
name|response
condition|)
block|{
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|attempts
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|data
operator|->
name|originate
operator|==
name|outgoing
index|[
name|i
index|]
condition|)
block|{
name|outgoing
index|[
name|i
index|]
operator|=
literal|0.0
expr_stmt|;
operator|++
name|k
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|!=
literal|1
operator|||
name|delay2
operator|>
name|NTP_INSANITY
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad response from NTP server rejected on socket %d\n"
argument_list|,
name|argv0
argument_list|,
name|which
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Now return the time information.  If it is a server response, it contains enough information that we can be almost certain that we have not been fooled too badly.  Heaven help us with broadcasts - make a wild kludge here, and see elsewhere for other kludges. */
if|if
condition|(
name|dispersion
operator|<
name|data
operator|->
name|dispersion
condition|)
name|dispersion
operator|=
name|data
operator|->
name|dispersion
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|op_listen
operator|||
name|operation
operator|==
name|op_server
condition|)
block|{
operator|*
name|off
operator|=
name|data
operator|->
name|transmit
operator|-
name|data
operator|->
name|current
expr_stmt|;
operator|*
name|err
operator|=
name|NTP_INSANITY
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|data
operator|->
name|receive
operator|-
name|data
operator|->
name|originate
expr_stmt|;
name|y
operator|=
operator|(
name|data
operator|->
name|transmit
operator|==
literal|0.0
condition|?
literal|0.0
else|:
name|data
operator|->
name|transmit
operator|-
name|data
operator|->
name|current
operator|)
expr_stmt|;
operator|*
name|off
operator|=
literal|0.5
operator|*
operator|(
name|x
operator|+
name|y
operator|)
expr_stmt|;
operator|*
name|err
operator|=
name|x
operator|-
name|y
expr_stmt|;
name|x
operator|=
name|data
operator|->
name|current
operator|-
name|data
operator|->
name|originate
expr_stmt|;
if|if
condition|(
literal|0.5
operator|*
name|x
operator|>
operator|*
name|err
condition|)
operator|*
name|err
operator|=
literal|0.5
operator|*
name|x
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|format_time
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|int
name|length
parameter_list|,
name|double
name|offset
parameter_list|,
name|double
name|error
parameter_list|,
name|double
name|drift
parameter_list|,
name|double
name|drifterr
parameter_list|)
block|{
comment|/* Format the current time into a string, with the extra information as requested.  Note that the rest of the program uses the correction needed, which is what is printed for diagnostics, but this formats the error in the local system for display to users.  So the results from this are the negation of those printed by the verbose options. */
name|int
name|milli
decl_stmt|,
name|len
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|struct
name|tm
modifier|*
name|gmt
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|months
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
comment|/* Work out and format the current local time.  Note that some semi-ANSI systems do not set the return value from (s)printf. */
name|now
operator|=
name|convert_time
argument_list|(
name|current_time
argument_list|(
name|offset
argument_list|)
argument_list|,
operator|&
name|milli
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|gmt
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to work out local time"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
literal|24
expr_stmt|;
if|if
condition|(
name|length
operator|<=
name|len
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"internal error calling format_time"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|text
argument_list|,
literal|"%.4d %s %.2d %.2d:%.2d:%.2d.%.3d"
argument_list|,
name|gmt
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|months
index|[
name|gmt
operator|->
name|tm_mon
index|]
argument_list|,
name|gmt
operator|->
name|tm_mday
argument_list|,
name|gmt
operator|->
name|tm_hour
argument_list|,
name|gmt
operator|->
name|tm_min
argument_list|,
name|gmt
operator|->
name|tm_sec
argument_list|,
name|milli
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|text
argument_list|)
operator|!=
name|len
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to format current local time"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Append the information about the offset, if requested. */
if|if
condition|(
name|error
operator|>=
literal|0.0
condition|)
block|{
if|if
condition|(
name|length
operator|<
name|len
operator|+
literal|30
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"internal error calling format_time"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|text
index|[
name|len
index|]
argument_list|,
literal|" %c %.3f +/- %.3f secs"
argument_list|,
operator|(
name|offset
operator|>
literal|0.0
condition|?
literal|'-'
else|:
literal|'+'
operator|)
argument_list|,
operator|(
name|offset
operator|>
literal|0.0
condition|?
name|offset
else|:
operator|-
name|offset
operator|)
argument_list|,
name|dispersion
operator|+
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|&
name|text
index|[
name|len
index|]
argument_list|)
operator|<
literal|22
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to format clock correction"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Append the information about the drift, if requested. */
if|if
condition|(
name|drifterr
operator|>=
literal|0.0
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|len
operator|+
literal|25
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"internal error calling format_time"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|text
index|[
name|len
index|]
argument_list|,
literal|" %c %.1f +/- %.1f ppm"
argument_list|,
operator|(
name|drift
operator|>
literal|0.0
condition|?
literal|'-'
else|:
literal|'+'
operator|)
argument_list|,
literal|1.0e6
operator|*
name|fabs
argument_list|(
name|drift
argument_list|)
argument_list|,
literal|1.0e6
operator|*
name|drifterr
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|&
name|text
index|[
name|len
index|]
argument_list|)
operator|<
literal|17
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to format clock correction"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* It would be better to check for field overflow, but it is a lot of code to trap extremely implausible scenarios.  This will usually stop chaos from spreading. */
if|if
condition|(
name|strlen
argument_list|(
name|text
argument_list|)
operator|>=
name|length
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"internal error calling format_time"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|double
name|reset_clock
parameter_list|(
name|double
name|offset
parameter_list|,
name|double
name|error
parameter_list|,
name|int
name|daemon
parameter_list|)
block|{
comment|/* Reset the clock, if appropriate, and return the correction actually used. This contains most of the checking for whether changes are worthwhile, except in daemon mode. */
name|double
name|absoff
init|=
operator|(
name|offset
operator|<
literal|0
condition|?
operator|-
name|offset
else|:
name|offset
operator|)
decl_stmt|;
name|char
name|text
index|[
literal|50
index|]
decl_stmt|;
comment|/* If the correction is large, ask for confirmation before proceeding. */
if|if
condition|(
name|absoff
operator|>
name|prompt
condition|)
block|{
if|if
condition|(
operator|!
name|daemon
operator|&&
name|ftty
argument_list|(
name|stdin
argument_list|)
operator|&&
name|ftty
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"The time correction is %.3f +/- %.3f+%.3f seconds\n"
argument_list|,
name|offset
argument_list|,
name|dispersion
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Do you want to correct the time anyway? "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|toupper
argument_list|(
name|getchar
argument_list|()
argument_list|)
operator|!=
literal|'Y'
condition|)
block|{
name|printf
argument_list|(
literal|"OK - quitting\n"
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sprintf
argument_list|(
name|text
argument_list|,
literal|"%.3f +/- %.3f+%.3f"
argument_list|,
name|offset
argument_list|,
name|dispersion
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"time correction too large: %s seconds"
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* See if the correction is reasonably reliable and worth making. */
if|if
condition|(
name|absoff
operator|<
operator|(
name|daemon
condition|?
literal|0.5
else|:
literal|1.0
operator|)
operator|*
name|minerr
condition|)
block|{
if|if
condition|(
name|daemon
condition|?
name|verbose
operator|>
literal|1
else|:
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: correction %.3f +/- %.3f+%.3f secs - ignored\n"
argument_list|,
name|argv0
argument_list|,
name|offset
argument_list|,
name|dispersion
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
literal|0.0
return|;
block|}
elseif|else
if|if
condition|(
name|absoff
operator|<
literal|2.0
operator|*
name|error
condition|)
block|{
if|if
condition|(
name|daemon
condition|?
name|verbose
operator|>
literal|1
else|:
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: correction %.3f +/- %.3f+%.3f secs - suppressed\n"
argument_list|,
name|argv0
argument_list|,
name|offset
argument_list|,
name|dispersion
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
literal|0.0
return|;
block|}
comment|/* Make the correction.  Provide some protection against the previous correction not having completed, but it will rarely help much. */
name|adjust_time
argument_list|(
name|offset
argument_list|,
operator|(
name|action
operator|==
name|action_reset
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
operator|(
name|daemon
condition|?
literal|2.0
operator|*
name|minerr
else|:
literal|0.0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|daemon
condition|?
name|verbose
operator|>
literal|1
else|:
name|verbose
condition|)
block|{
name|format_time
argument_list|(
name|text
argument_list|,
literal|50
argument_list|,
literal|0.0
argument_list|,
operator|-
literal|1.0
argument_list|,
literal|0.0
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: time changed by %.3f secs to %s +/- %.3f+%.3f\n"
argument_list|,
name|argv0
argument_list|,
name|offset
argument_list|,
name|text
argument_list|,
name|dispersion
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_function
name|void
name|run_server
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Set up a socket, and either broadcast at intervals or wait for requests. It is quite tricky to get this to fail, and it will usually indicate that the local system is sick. */
name|unsigned
name|char
name|transmit
index|[
name|NTP_PACKET_MIN
index|]
decl_stmt|;
name|ntp_data
name|data
decl_stmt|;
name|double
name|started
init|=
name|current_time
argument_list|(
name|JAN_1970
argument_list|)
decl_stmt|,
name|successes
init|=
literal|0.0
decl_stmt|,
name|failures
init|=
literal|0.0
decl_stmt|,
name|broadcasts
init|=
literal|0.0
decl_stmt|,
name|weeble
init|=
literal|1.0
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|open_socket
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|delay
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* In server mode, provide some tracing of normal running (but not too much, except when debugging!) */
if|if
condition|(
name|operation
operator|==
name|op_server
condition|)
block|{
name|x
operator|=
name|current_time
argument_list|(
name|JAN_1970
argument_list|)
operator|-
name|started
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
name|x
operator|/
literal|3600.0
operator|+
name|successes
operator|+
name|failures
operator|>=
name|weeble
condition|)
block|{
name|weeble
operator|*=
name|WEEBLE_FACTOR
expr_stmt|;
name|x
operator|-=
literal|3600.0
operator|*
operator|(
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|x
operator|/
literal|3600.0
argument_list|)
operator|)
expr_stmt|;
name|x
operator|-=
literal|60.0
operator|*
operator|(
name|j
operator|=
call|(
name|int
call|)
argument_list|(
name|x
operator|/
literal|60.0
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: after %d hours %d mins "
argument_list|,
name|argv0
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: after %d mins %.0f secs "
argument_list|,
name|argv0
argument_list|,
name|j
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: after %.1f secs "
argument_list|,
name|argv0
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%.0f acc. %.0f rej. %.0f b'cast\n"
argument_list|,
name|successes
argument_list|,
name|failures
argument_list|,
name|broadcasts
argument_list|)
expr_stmt|;
block|}
comment|/* Respond to incoming requests or plaster broadcasts over the net.  Note that we could skip almost all of the decoding, but it provides a healthy amount of error detection.  We could print some information on incoming packets, but the code is not structured to do this very helpfully. */
name|i
operator|=
name|read_packet
argument_list|(
literal|0
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
operator|++
name|broadcasts
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
operator|++
name|failures
expr_stmt|;
continue|continue;
block|}
else|else
block|{
operator|++
name|successes
expr_stmt|;
name|make_packet
argument_list|(
operator|&
name|data
argument_list|,
name|NTP_SERVER
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|do_nothing
argument_list|(
name|period
argument_list|)
expr_stmt|;
name|make_packet
argument_list|(
operator|&
name|data
argument_list|,
name|NTP_BROADCAST
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Outgoing packet:\n"
argument_list|)
expr_stmt|;
name|display_data
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
name|pack_ntp
argument_list|(
name|transmit
argument_list|,
name|NTP_PACKET_MIN
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|display_packet
argument_list|(
name|transmit
argument_list|,
name|NTP_PACKET_MIN
argument_list|)
expr_stmt|;
name|write_socket
argument_list|(
literal|0
argument_list|,
name|transmit
argument_list|,
name|NTP_PACKET_MIN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|double
name|estimate_stats
parameter_list|(
name|int
modifier|*
name|a_total
parameter_list|,
name|int
modifier|*
name|a_index
parameter_list|,
name|data_record
modifier|*
name|record
parameter_list|,
name|double
name|correction
parameter_list|,
name|double
modifier|*
name|a_disp
parameter_list|,
name|double
modifier|*
name|a_when
parameter_list|,
name|double
modifier|*
name|a_offset
parameter_list|,
name|double
modifier|*
name|a_error
parameter_list|,
name|double
modifier|*
name|a_drift
parameter_list|,
name|double
modifier|*
name|a_drifterr
parameter_list|,
name|int
modifier|*
name|a_wait
parameter_list|,
name|int
name|update
parameter_list|)
block|{
comment|/* This updates the running statistics and returns the best estimate of what to do now.  It returns the timestamp relevant to the correction.  If broadcasts are rare and the drift is large, it will fail - you should then use a better synchronisation method.  It will also fail if something goes severely wrong (e.g. if the local clock is reset by another process or the transmission errors are beyond reason).  There is a kludge for synchronisation loss during down time.  If it detects this, it will update only the history data and return zero; this is then handled specially in run_daemon().  While it could correct the offset, this might not always be the right thing to do. */
name|double
name|weight
decl_stmt|,
name|disp
decl_stmt|,
name|when
decl_stmt|,
name|offset
decl_stmt|,
name|error
decl_stmt|,
name|drift
decl_stmt|,
name|drifterr
decl_stmt|,
name|now
decl_stmt|,
name|e
decl_stmt|,
name|w
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|int
name|total
init|=
operator|*
name|a_total
decl_stmt|,
name|index
init|=
operator|*
name|a_index
decl_stmt|,
name|wait
init|=
operator|*
name|a_wait
decl_stmt|,
name|i
decl_stmt|;
name|char
name|text
index|[
literal|50
index|]
decl_stmt|;
comment|/* Correct the previous data and store a new entry in the circular buffer. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total
condition|;
operator|++
name|i
control|)
block|{
name|record
index|[
name|i
index|]
operator|.
name|when
operator|+=
name|correction
expr_stmt|;
name|record
index|[
name|i
index|]
operator|.
name|offset
operator|-=
name|correction
expr_stmt|;
block|}
if|if
condition|(
name|update
condition|)
block|{
name|record
index|[
name|index
index|]
operator|.
name|dispersion
operator|=
operator|*
name|a_disp
expr_stmt|;
name|record
index|[
name|index
index|]
operator|.
name|when
operator|=
operator|*
name|a_when
expr_stmt|;
name|record
index|[
name|index
index|]
operator|.
name|offset
operator|=
operator|*
name|a_offset
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: corr=%.3f when=%.3f disp=%.3f off=%.3f"
argument_list|,
name|argv0
argument_list|,
name|correction
argument_list|,
operator|*
name|a_when
argument_list|,
operator|*
name|a_disp
argument_list|,
operator|*
name|a_offset
argument_list|)
expr_stmt|;
comment|/* See below */
if|if
condition|(
name|operation
operator|==
name|op_listen
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|record
index|[
name|index
index|]
operator|.
name|error
operator|=
name|minerr
expr_stmt|;
name|record
index|[
name|index
index|]
operator|.
name|weight
operator|=
literal|1.0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" err=%.3f\n"
argument_list|,
operator|*
name|a_error
argument_list|)
expr_stmt|;
name|record
index|[
name|index
index|]
operator|.
name|error
operator|=
name|x
operator|=
operator|*
name|a_error
expr_stmt|;
name|record
index|[
name|index
index|]
operator|.
name|weight
operator|=
literal|1.0
operator|/
operator|(
name|x
operator|>
name|minerr
condition|?
name|x
operator|*
name|x
else|:
name|minerr
operator|*
name|minerr
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|index
operator|>=
name|count
condition|)
name|index
operator|=
literal|0
expr_stmt|;
operator|*
name|a_index
operator|=
name|index
expr_stmt|;
if|if
condition|(
operator|++
name|total
operator|>
name|count
condition|)
name|total
operator|=
name|count
expr_stmt|;
operator|*
name|a_total
operator|=
name|total
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"corr=%.6f tot=%d ind=%d\n"
argument_list|,
name|correction
argument_list|,
name|total
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* If there is insufficient data yet, use the latest estimates and return forthwith.  Note that this will not work for broadcasts, but they will be disabled in run_daemon(). */
if|if
condition|(
operator|(
name|operation
operator|==
name|op_listen
operator|&&
name|total
operator|<
name|count
operator|&&
name|update
operator|)
operator|||
name|total
operator|<
literal|3
condition|)
block|{
operator|*
name|a_drift
operator|=
literal|0.0
expr_stmt|;
operator|*
name|a_drifterr
operator|=
operator|-
literal|1.0
expr_stmt|;
operator|*
name|a_wait
operator|=
name|delay
expr_stmt|;
return|return
operator|*
name|a_when
return|;
block|}
comment|/* Work out the average time, offset, error etc.  Note that the dispersion is not subject to the central limit theorem.  Unfortunately, the variation in the source's dispersion is our only indication of how consistent its clock is. */
name|disp
operator|=
name|weight
operator|=
name|when
operator|=
name|offset
operator|=
name|y
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total
condition|;
operator|++
name|i
control|)
block|{
name|weight
operator|+=
name|w
operator|=
name|record
index|[
name|i
index|]
operator|.
name|weight
expr_stmt|;
name|when
operator|+=
name|w
operator|*
name|record
index|[
name|i
index|]
operator|.
name|when
expr_stmt|;
name|offset
operator|+=
name|w
operator|*
name|record
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
name|y
operator|+=
name|w
operator|*
name|record
index|[
name|i
index|]
operator|.
name|dispersion
expr_stmt|;
if|if
condition|(
name|disp
operator|<
name|record
index|[
name|i
index|]
operator|.
name|dispersion
condition|)
name|disp
operator|=
name|record
index|[
name|i
index|]
operator|.
name|dispersion
expr_stmt|;
block|}
name|when
operator|/=
name|weight
expr_stmt|;
name|offset
operator|/=
name|weight
expr_stmt|;
name|y
operator|/=
name|weight
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"disp=%.6f wgt=%.3f when=%.6f off=%.6f\n"
argument_list|,
name|disp
argument_list|,
name|weight
argument_list|,
name|when
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* If there is enough data, estimate the drift and errors by regression.  Note that it is essential to calculate the mean square error, not the mean error. */
name|error
operator|=
name|drift
operator|=
name|x
operator|=
name|z
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total
condition|;
operator|++
name|i
control|)
block|{
name|w
operator|=
name|record
index|[
name|i
index|]
operator|.
name|weight
operator|/
name|weight
expr_stmt|;
name|x
operator|+=
name|w
operator|*
operator|(
name|record
index|[
name|i
index|]
operator|.
name|when
operator|-
name|when
operator|)
operator|*
operator|(
name|record
index|[
name|i
index|]
operator|.
name|when
operator|-
name|when
operator|)
expr_stmt|;
name|drift
operator|+=
name|w
operator|*
operator|(
name|record
index|[
name|i
index|]
operator|.
name|when
operator|-
name|when
operator|)
operator|*
operator|(
name|record
index|[
name|i
index|]
operator|.
name|offset
operator|-
name|offset
operator|)
expr_stmt|;
name|z
operator|+=
name|w
operator|*
operator|(
name|record
index|[
name|i
index|]
operator|.
name|offset
operator|-
name|offset
operator|)
operator|*
operator|(
name|record
index|[
name|i
index|]
operator|.
name|offset
operator|-
name|offset
operator|)
expr_stmt|;
name|error
operator|+=
name|w
operator|*
name|record
index|[
name|i
index|]
operator|.
name|error
operator|*
name|record
index|[
name|i
index|]
operator|.
name|error
operator|+
literal|2.0
operator|*
name|w
operator|*
operator|(
name|record
index|[
name|i
index|]
operator|.
name|dispersion
operator|-
name|y
operator|)
operator|*
operator|(
name|record
index|[
name|i
index|]
operator|.
name|dispersion
operator|-
name|y
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"X2=%.3f XY=%.6f Y2=%.9f E2=%.9f "
argument_list|,
name|x
argument_list|,
name|drift
argument_list|,
name|z
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* When calculating the errors, add some paranoia mainly to check for coding errors and complete lunacy, attempting to retry if at all possible.  Because glitches at this point are so common, log a reset even in non-verbose mode. There will be more thorough checks later.  Note that we cannot usefully check the error for broadcasts. */
name|z
operator|-=
name|drift
operator|*
name|drift
operator|/
name|x
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"S2=%.9f\n"
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|update
condition|)
block|{
if|if
condition|(
name|z
operator|>
literal|1.0e6
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"stored data too unreliable for time estimation"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|op_client
condition|)
block|{
name|e
operator|=
name|error
operator|+
name|disp
operator|*
name|disp
operator|+
name|minerr
operator|*
name|minerr
expr_stmt|;
if|if
condition|(
name|z
operator|>
name|e
condition|)
block|{
if|if
condition|(
name|verbose
operator|||
name|z
operator|>=
name|maxerr
operator|*
name|maxerr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: excessively high error %.3f> %.3f> %.3f\n"
argument_list|,
name|argv0
argument_list|,
name|sqrt
argument_list|(
name|z
argument_list|)
argument_list|,
name|sqrt
argument_list|(
name|e
argument_list|)
argument_list|,
name|sqrt
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|total
operator|<=
literal|1
condition|)
return|return
literal|0.0
return|;
elseif|else
if|if
condition|(
name|z
operator|<
name|maxerr
operator|*
name|maxerr
condition|)
block|{
name|sprintf
argument_list|(
name|text
argument_list|,
literal|"resetting on error %.3g> %.3g"
argument_list|,
name|sqrt
argument_list|(
name|z
argument_list|)
argument_list|,
name|sqrt
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|log_message
argument_list|(
name|text
argument_list|)
expr_stmt|;
return|return
literal|0.0
return|;
block|}
else|else
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"incompatible (i.e. erroneous) timestamps"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
operator|>
name|error
operator|&&
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: anomalously high error %.3f> %.3f, but< %.3f\n"
argument_list|,
name|argv0
argument_list|,
name|sqrt
argument_list|(
name|z
argument_list|)
argument_list|,
name|sqrt
argument_list|(
name|error
argument_list|)
argument_list|,
name|sqrt
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|z
operator|>
name|maxerr
operator|*
name|maxerr
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"broadcasts too unreliable for time estimation"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|drift
operator|/=
name|x
expr_stmt|;
name|drifterr
operator|=
name|ABSCISSA
operator|*
name|sqrt
argument_list|(
name|z
operator|/
operator|(
name|x
operator|*
name|total
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
operator|(
name|operation
operator|==
name|op_listen
condition|?
name|minerr
else|:
literal|0.0
operator|)
operator|+
name|ABSCISSA
operator|*
name|sqrt
argument_list|(
name|z
operator|/
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"err=%.6f drift=%.6f+/-%.6f\n"
argument_list|,
name|error
argument_list|,
name|drift
argument_list|,
name|drifterr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|+
name|drifterr
operator|*
name|delay
operator|>
name|NTP_INSANITY
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"unable to get a reasonable drift estimate"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Estimate the optimal short-loop period, checking it carefully.  Remember to check that this whole process is likely to be accurate enough and that the delay function may be inaccurate. */
name|wait
operator|=
name|delay
expr_stmt|;
name|x
operator|=
operator|(
name|drift
operator|<
literal|0.0
condition|?
operator|-
name|drift
else|:
name|drift
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|*
name|delay
operator|<
literal|0.5
operator|*
name|minerr
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Drift too small to correct\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<
literal|2.0
operator|*
name|drifterr
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Drift correction suppressed\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|z
operator|=
name|drifterr
operator|*
name|delay
operator|)
operator|<
literal|0.5
operator|*
name|minerr
condition|)
name|z
operator|=
literal|0.5
operator|*
name|minerr
expr_stmt|;
name|wait
operator|=
operator|(
name|x
operator|<
name|z
operator|/
name|delay
condition|?
name|delay
else|:
call|(
name|int
call|)
argument_list|(
name|z
operator|/
name|x
operator|+
literal|0.5
argument_list|)
operator|)
expr_stmt|;
name|wait
operator|=
call|(
name|int
call|)
argument_list|(
name|delay
operator|/
call|(
name|int
call|)
argument_list|(
name|delay
operator|/
operator|(
name|double
operator|)
name|wait
operator|+
literal|0.999
argument_list|)
operator|+
literal|0.999
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait
operator|>
name|delay
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"internal error in drift calculation"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|update
operator|&&
operator|(
name|drift
operator|*
name|wait
operator|>
name|maxerr
operator|||
name|wait
operator|<
name|RESET_MIN
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|text
argument_list|,
literal|"%.6f+/-%.6f"
argument_list|,
name|drift
argument_list|,
name|drifterr
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"drift correction too large: %s"
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wait
operator|<
operator|*
name|a_wait
operator|/
literal|2
condition|)
name|wait
operator|=
operator|*
name|a_wait
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|wait
operator|>
operator|*
name|a_wait
operator|*
literal|2
condition|)
name|wait
operator|=
operator|*
name|a_wait
operator|*
literal|2
expr_stmt|;
comment|/* Now work out what the correction should be, as distinct from what it should have been, remembering that older times are less certain. */
name|now
operator|=
name|current_time
argument_list|(
name|JAN_1970
argument_list|)
expr_stmt|;
name|x
operator|=
name|now
operator|-
name|when
expr_stmt|;
name|offset
operator|+=
name|x
operator|*
name|drift
expr_stmt|;
name|error
operator|+=
name|x
operator|*
name|drifterr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total
condition|;
operator|++
name|i
control|)
block|{
name|x
operator|=
name|now
operator|-
name|record
index|[
name|i
index|]
operator|.
name|when
expr_stmt|;
name|z
operator|=
name|record
index|[
name|i
index|]
operator|.
name|error
operator|+
name|x
operator|*
name|drifterr
expr_stmt|;
if|if
condition|(
name|z
operator|<
name|error
condition|)
block|{
name|when
operator|=
name|record
index|[
name|i
index|]
operator|.
name|when
expr_stmt|;
name|offset
operator|=
name|record
index|[
name|i
index|]
operator|.
name|offset
operator|+
name|x
operator|*
name|drift
expr_stmt|;
name|error
operator|=
name|z
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"now=%.6f when=%.6f off=%.6f err=%.6f wait=%d\n"
argument_list|,
name|now
argument_list|,
name|when
argument_list|,
name|offset
argument_list|,
name|error
argument_list|,
name|wait
argument_list|)
expr_stmt|;
comment|/* Finally, return the result. */
operator|*
name|a_disp
operator|=
name|disp
expr_stmt|;
operator|*
name|a_when
operator|=
name|when
expr_stmt|;
operator|*
name|a_offset
operator|=
name|offset
expr_stmt|;
operator|*
name|a_error
operator|=
name|error
expr_stmt|;
operator|*
name|a_drift
operator|=
name|drift
expr_stmt|;
operator|*
name|a_drifterr
operator|=
name|drifterr
expr_stmt|;
operator|*
name|a_wait
operator|=
name|wait
expr_stmt|;
return|return
name|now
return|;
block|}
end_function

begin_function
name|double
name|correct_drift
parameter_list|(
name|double
modifier|*
name|a_when
parameter_list|,
name|double
modifier|*
name|a_offset
parameter_list|,
name|double
name|drift
parameter_list|)
block|{
comment|/* Correct for the drift since the last time it was done, provided that a long enough time has elapsed.  And do remember to kludge up the time and discrepancy, when appropriate. */
name|double
name|d
decl_stmt|,
name|x
decl_stmt|;
name|d
operator|=
name|current_time
argument_list|(
name|JAN_1970
argument_list|)
operator|-
operator|*
name|a_when
expr_stmt|;
operator|*
name|a_when
operator|+=
name|d
expr_stmt|;
name|x
operator|=
operator|*
name|a_offset
operator|+
name|d
operator|*
name|drift
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Correction %.6f @ %.6f off=%.6f "
argument_list|,
name|x
argument_list|,
operator|*
name|a_when
argument_list|,
operator|*
name|a_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>=
name|waiting
operator|&&
operator|(
name|x
operator|<
literal|0.0
condition|?
operator|-
name|x
else|:
name|x
operator|)
operator|>=
literal|0.5
operator|*
name|minerr
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"performed\n"
argument_list|)
expr_stmt|;
name|adjust_time
argument_list|(
name|x
argument_list|,
operator|(
name|action
operator|==
name|action_reset
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
literal|0.5
operator|*
name|minerr
argument_list|)
expr_stmt|;
operator|*
name|a_offset
operator|=
literal|0.0
expr_stmt|;
return|return
name|x
return|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ignored\n"
argument_list|)
expr_stmt|;
operator|*
name|a_offset
operator|=
name|x
expr_stmt|;
return|return
literal|0.0
return|;
block|}
block|}
end_function

begin_function
name|void
name|handle_saving
parameter_list|(
name|int
name|operation
parameter_list|,
name|int
modifier|*
name|total
parameter_list|,
name|int
modifier|*
name|index
parameter_list|,
name|int
modifier|*
name|cycle
parameter_list|,
name|data_record
modifier|*
name|record
parameter_list|,
name|double
modifier|*
name|previous
parameter_list|,
name|double
modifier|*
name|when
parameter_list|,
name|double
modifier|*
name|correction
parameter_list|)
block|{
comment|/* This handles the saving and restoring of the state to a file.  While it is subject to spoofing, this is not a major security problem.  But, out of general paranoia, check everything in sight when restoring.  Note that this function has no external effect if something goes wrong. */
struct|struct
block|{
name|data_record
name|record
index|[
name|COUNT_MAX
index|]
decl_stmt|;
name|double
name|previous
decl_stmt|,
name|when
decl_stmt|,
name|correction
decl_stmt|;
name|int
name|operation
decl_stmt|,
name|delay
decl_stmt|,
name|count
decl_stmt|,
name|total
decl_stmt|,
name|index
decl_stmt|,
name|cycle
decl_stmt|,
name|waiting
decl_stmt|;
block|}
name|buffer
struct|;
name|double
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|savefile
operator|==
name|NULL
condition|)
return|return;
comment|/* Read the restart file and print its data in diagnostic mode.  Note that some care is necessary to avoid introducing a security exposure - but we trust the C library not to trash the stack on bad numbers! */
if|if
condition|(
name|operation
operator|==
name|save_read_only
operator|||
name|operation
operator|==
name|save_read_check
condition|)
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|1
argument_list|,
name|savefile
argument_list|)
operator|!=
literal|1
operator|||
name|ferror
argument_list|(
name|savefile
argument_list|)
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|savefile
argument_list|)
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to read record from daemon save file"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad daemon restart information\n"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reading prev=%.6f when=%.6f corr=%.6f\n"
argument_list|,
name|buffer
operator|.
name|previous
argument_list|,
name|buffer
operator|.
name|when
argument_list|,
name|buffer
operator|.
name|correction
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"op=%d dly=%d cnt=%d tot=%d ind=%d cyc=%d wait=%d\n"
argument_list|,
name|buffer
operator|.
name|operation
argument_list|,
name|buffer
operator|.
name|delay
argument_list|,
name|buffer
operator|.
name|count
argument_list|,
name|buffer
operator|.
name|total
argument_list|,
name|buffer
operator|.
name|index
argument_list|,
name|buffer
operator|.
name|cycle
argument_list|,
name|buffer
operator|.
name|waiting
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|.
name|total
operator|<
name|COUNT_MAX
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buffer
operator|.
name|total
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"disp=%.6f wgt=%.3f when=%.6f off=%.6f err=%.6f\n"
argument_list|,
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|dispersion
argument_list|,
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|weight
argument_list|,
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|when
argument_list|,
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* Start checking the data for sanity. */
if|if
condition|(
name|buffer
operator|.
name|operation
operator|==
literal|0
operator|&&
name|buffer
operator|.
name|delay
operator|==
literal|0
operator|&&
name|buffer
operator|.
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|operation
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"the daemon save file has been cleared"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: restarting from a cleared file\n"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|operation
operator|==
name|save_read_check
condition|)
block|{
if|if
condition|(
name|buffer
operator|.
name|operation
operator|!=
name|operation
operator|||
name|buffer
operator|.
name|delay
operator|!=
name|delay
operator|||
name|buffer
operator|.
name|count
operator|!=
name|count
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: different parameters for restart\n"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|buffer
operator|.
name|total
operator|<
literal|1
operator|||
name|buffer
operator|.
name|total
operator|>
name|count
operator|||
name|buffer
operator|.
name|index
operator|<
literal|0
operator|||
name|buffer
operator|.
name|index
operator|>=
name|count
operator|||
name|buffer
operator|.
name|cycle
operator|<
literal|0
operator|||
name|buffer
operator|.
name|cycle
operator|>=
name|count
operator|||
name|buffer
operator|.
name|correction
operator|<
operator|-
name|maxerr
operator|||
name|buffer
operator|.
name|correction
operator|>
name|maxerr
operator|||
name|buffer
operator|.
name|waiting
operator|<
name|RESET_MIN
operator|||
name|buffer
operator|.
name|waiting
operator|>
name|delay
operator|||
name|buffer
operator|.
name|previous
operator|>
name|buffer
operator|.
name|when
operator|||
name|buffer
operator|.
name|previous
operator|<
name|buffer
operator|.
name|when
operator|-
name|count
operator|*
name|delay
operator|||
name|buffer
operator|.
name|when
operator|>=
operator|*
name|when
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: corrupted restart information\n"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Checking the record is even more tedious. */
name|x
operator|=
operator|*
name|when
expr_stmt|;
name|y
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buffer
operator|.
name|total
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|dispersion
operator|<
literal|0.0
operator|||
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|dispersion
operator|>
name|maxerr
operator|||
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|weight
operator|<=
literal|0.0
operator|||
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|weight
operator|>
literal|1.001
operator|/
operator|(
name|minerr
operator|*
name|minerr
operator|)
operator|||
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|offset
operator|<
operator|-
name|count
operator|*
name|maxerr
operator|||
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|offset
operator|>
name|count
operator|*
name|maxerr
operator|||
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|error
operator|<
literal|0.0
operator|||
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|error
operator|>
name|maxerr
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: corrupted restart record\n"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|when
operator|<
name|x
condition|)
name|x
operator|=
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|when
expr_stmt|;
if|if
condition|(
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|when
operator|>
name|y
condition|)
name|y
operator|=
name|buffer
operator|.
name|record
index|[
name|i
index|]
operator|.
name|when
expr_stmt|;
block|}
comment|/* Check for consistency and, finally, whether this is too old. */
if|if
condition|(
name|y
operator|>
name|buffer
operator|.
name|when
operator|||
name|y
operator|-
name|x
operator|<
operator|(
name|buffer
operator|.
name|total
operator|-
literal|1
operator|)
operator|*
name|delay
operator|||
name|y
operator|-
name|x
operator|>
operator|(
name|buffer
operator|.
name|total
operator|-
literal|1
operator|)
operator|*
name|count
operator|*
name|delay
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: corrupted restart times\n"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|buffer
operator|.
name|when
operator|<
operator|*
name|when
operator|-
name|count
operator|*
name|delay
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: restart information too old\n"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* If we get here, just copy the data back. */
name|memcpy
argument_list|(
name|record
argument_list|,
name|buffer
operator|.
name|record
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
operator|.
name|record
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|previous
operator|=
name|buffer
operator|.
name|previous
expr_stmt|;
operator|*
name|when
operator|=
name|buffer
operator|.
name|when
expr_stmt|;
operator|*
name|correction
operator|=
name|buffer
operator|.
name|correction
expr_stmt|;
operator|*
name|total
operator|=
name|buffer
operator|.
name|total
expr_stmt|;
operator|*
name|index
operator|=
name|buffer
operator|.
name|index
expr_stmt|;
operator|*
name|cycle
operator|=
name|buffer
operator|.
name|cycle
expr_stmt|;
name|waiting
operator|=
name|buffer
operator|.
name|waiting
expr_stmt|;
name|memset
argument_list|(
operator|&
name|buffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print out the data if requested. */
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: prev=%.3f when=%.3f corr=%.3f\n"
argument_list|,
name|argv0
argument_list|,
operator|*
name|previous
argument_list|,
operator|*
name|when
argument_list|,
operator|*
name|correction
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|total
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
name|i
operator|+
operator|*
name|index
operator|-
operator|*
name|total
operator|)
operator|<
literal|0
condition|)
name|j
operator|+=
operator|*
name|total
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: when=%.3f disp=%.3f off=%.3f"
argument_list|,
name|argv0
argument_list|,
name|record
index|[
name|j
index|]
operator|.
name|when
argument_list|,
name|record
index|[
name|j
index|]
operator|.
name|dispersion
argument_list|,
name|record
index|[
name|j
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|op_client
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" err=%.3f\n"
argument_list|,
name|record
index|[
name|j
index|]
operator|.
name|error
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* All errors on output are fatal. */
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|save_write
condition|)
block|{
name|memcpy
argument_list|(
name|buffer
operator|.
name|record
argument_list|,
name|record
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
operator|.
name|record
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|previous
operator|=
operator|*
name|previous
expr_stmt|;
name|buffer
operator|.
name|when
operator|=
operator|*
name|when
expr_stmt|;
name|buffer
operator|.
name|correction
operator|=
operator|*
name|correction
expr_stmt|;
name|buffer
operator|.
name|operation
operator|=
name|operation
expr_stmt|;
name|buffer
operator|.
name|delay
operator|=
name|delay
expr_stmt|;
name|buffer
operator|.
name|count
operator|=
name|count
expr_stmt|;
name|buffer
operator|.
name|total
operator|=
operator|*
name|total
expr_stmt|;
name|buffer
operator|.
name|index
operator|=
operator|*
name|index
expr_stmt|;
name|buffer
operator|.
name|cycle
operator|=
operator|*
name|cycle
expr_stmt|;
name|buffer
operator|.
name|waiting
operator|=
name|waiting
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|savefile
argument_list|,
literal|0l
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|fwrite
argument_list|(
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|1
argument_list|,
name|savefile
argument_list|)
operator|!=
literal|1
operator|||
name|fflush
argument_list|(
name|savefile
argument_list|)
operator|!=
literal|0
operator|||
name|ferror
argument_list|(
name|savefile
argument_list|)
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to write record to daemon save file"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing prev=%.6f when=%.6f corr=%.6f\n"
argument_list|,
operator|*
name|previous
argument_list|,
operator|*
name|when
argument_list|,
operator|*
name|correction
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"op=%d dly=%d cnt=%d tot=%d ind=%d cyc=%d wait=%d\n"
argument_list|,
name|operation
argument_list|,
name|delay
argument_list|,
name|count
argument_list|,
operator|*
name|total
argument_list|,
operator|*
name|index
argument_list|,
operator|*
name|cycle
argument_list|,
name|waiting
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|total
operator|<
name|COUNT_MAX
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|total
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"disp=%.6f wgt=%.3f when=%.6f off=%.6f err=%.6f\n"
argument_list|,
name|record
index|[
name|i
index|]
operator|.
name|dispersion
argument_list|,
name|record
index|[
name|i
index|]
operator|.
name|weight
argument_list|,
name|record
index|[
name|i
index|]
operator|.
name|when
argument_list|,
name|record
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
name|record
index|[
name|i
index|]
operator|.
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* Clearing the save file is similar. */
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|save_clear
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|savefile
argument_list|,
literal|0l
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|fwrite
argument_list|(
operator|&
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|1
argument_list|,
name|savefile
argument_list|)
operator|!=
literal|1
operator|||
name|fflush
argument_list|(
name|savefile
argument_list|)
operator|!=
literal|0
operator|||
name|ferror
argument_list|(
name|savefile
argument_list|)
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to clear daemon save file"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"internal error in handle_saving"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|query_savefile
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* This queries a daemon save file. */
name|double
name|previous
decl_stmt|,
name|when
decl_stmt|,
name|correction
init|=
literal|0.0
decl_stmt|,
name|offset
init|=
literal|0.0
decl_stmt|,
name|error
init|=
operator|-
literal|1.0
decl_stmt|,
name|drift
init|=
literal|0.0
decl_stmt|,
name|drifterr
init|=
operator|-
literal|1.0
decl_stmt|;
name|data_record
name|record
index|[
name|COUNT_MAX
index|]
decl_stmt|;
name|int
name|total
init|=
literal|0
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|,
name|cycle
init|=
literal|0
decl_stmt|;
name|char
name|text
index|[
literal|100
index|]
decl_stmt|;
comment|/* This is a few lines stripped out of run_daemon() and slightly hacked. */
name|previous
operator|=
name|when
operator|=
name|current_time
argument_list|(
name|JAN_1970
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
block|{
name|format_time
argument_list|(
name|text
argument_list|,
literal|50
argument_list|,
literal|0.0
argument_list|,
operator|-
literal|1.0
argument_list|,
literal|0.0
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Started=%.6f %s\n"
argument_list|,
name|when
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
name|handle_saving
argument_list|(
name|save_read_only
argument_list|,
operator|&
name|total
argument_list|,
operator|&
name|index
argument_list|,
operator|&
name|cycle
argument_list|,
name|record
argument_list|,
operator|&
name|previous
argument_list|,
operator|&
name|when
argument_list|,
operator|&
name|correction
argument_list|)
expr_stmt|;
name|estimate_stats
argument_list|(
operator|&
name|total
argument_list|,
operator|&
name|index
argument_list|,
name|record
argument_list|,
name|correction
argument_list|,
operator|&
name|dispersion
argument_list|,
operator|&
name|when
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|error
argument_list|,
operator|&
name|drift
argument_list|,
operator|&
name|drifterr
argument_list|,
operator|&
name|waiting
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|format_time
argument_list|(
name|text
argument_list|,
literal|100
argument_list|,
name|offset
argument_list|,
name|error
argument_list|,
name|drift
argument_list|,
name|drifterr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|savefile
argument_list|)
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to close daemon save file"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Stopped normally\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|run_daemon
parameter_list|(
name|char
modifier|*
name|hostnames
index|[]
parameter_list|,
name|int
name|nhosts
parameter_list|,
name|int
name|initial
parameter_list|)
block|{
comment|/* This does not adjust the time between calls to the server, but it does adjust the time between clock resets.  This function will survive short periods of server inaccessibility or network glitches, but not long ones, and will then need restarting manually.  It is far too complex for a single function, but could really only be simplified by making most of its variables global or by a similarly horrible trick.  Oh, for nested scopes as in Algol 68! */
name|double
name|history
index|[
name|COUNT_MAX
index|]
decl_stmt|,
name|started
decl_stmt|,
name|previous
decl_stmt|,
name|when
decl_stmt|,
name|correction
init|=
literal|0.0
decl_stmt|,
name|weeble
init|=
literal|1.0
decl_stmt|,
name|accepts
init|=
literal|0.0
decl_stmt|,
name|rejects
init|=
literal|0.0
decl_stmt|,
name|flushes
init|=
literal|0.0
decl_stmt|,
name|replicates
init|=
literal|0.0
decl_stmt|,
name|skips
init|=
literal|0.0
decl_stmt|,
name|offset
init|=
literal|0.0
decl_stmt|,
name|error
init|=
operator|-
literal|1.0
decl_stmt|,
name|drift
init|=
literal|0.0
decl_stmt|,
name|drifterr
init|=
operator|-
literal|1.0
decl_stmt|,
name|maxoff
init|=
literal|0.0
decl_stmt|,
name|x
decl_stmt|;
name|data_record
name|record
index|[
name|COUNT_MAX
index|]
decl_stmt|;
name|int
name|total
init|=
literal|0
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|,
name|item
init|=
literal|0
decl_stmt|,
name|rej_level
init|=
literal|0
decl_stmt|,
name|rep_level
init|=
literal|0
decl_stmt|,
name|cycle
init|=
literal|0
decl_stmt|,
name|retry
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|char
name|transmit
index|[
name|NTP_PACKET_MIN
index|]
decl_stmt|;
name|ntp_data
name|data
decl_stmt|;
name|char
name|text
index|[
literal|100
index|]
decl_stmt|;
comment|/* After initialising, restore from a previous run if possible.  Note that only a few of the variables are actually needed to control the operation and the rest are mainly for diagnostics. */
name|started
operator|=
name|previous
operator|=
name|when
operator|=
name|current_time
argument_list|(
name|JAN_1970
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
block|{
name|format_time
argument_list|(
name|text
argument_list|,
literal|50
argument_list|,
literal|0.0
argument_list|,
operator|-
literal|1.0
argument_list|,
literal|0.0
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Started=%.6f %s\n"
argument_list|,
name|when
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|initial
condition|)
block|{
name|handle_saving
argument_list|(
name|save_read_check
argument_list|,
operator|&
name|total
argument_list|,
operator|&
name|index
argument_list|,
operator|&
name|cycle
argument_list|,
name|record
argument_list|,
operator|&
name|previous
argument_list|,
operator|&
name|when
argument_list|,
operator|&
name|correction
argument_list|)
expr_stmt|;
name|cycle
operator|=
operator|(
name|nhosts
operator|>
literal|0
condition|?
name|cycle
operator|%
name|nhosts
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|total
operator|>
literal|0
operator|&&
name|started
operator|-
name|previous
operator|<
name|delay
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Last packet too recent\n"
argument_list|)
expr_stmt|;
name|retry
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"prev=%.6f when=%.6f retry=%d\n"
argument_list|,
name|previous
argument_list|,
name|when
argument_list|,
name|retry
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nhosts
condition|;
operator|++
name|i
control|)
name|open_socket
argument_list|(
name|i
argument_list|,
name|hostnames
index|[
name|i
index|]
argument_list|,
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|!=
name|action_display
condition|)
block|{
name|set_lock
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|dispersion
operator|=
literal|0.0
expr_stmt|;
name|attempts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|history
index|[
name|i
index|]
operator|=
literal|0.0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Print out a reasonable amount of diagnostics, rather like a server.  Note that it may take a little time, but shouldn't affect the estimates much.  Then check that we aren't in a failing loop. */
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"item=%d rej=%d\n"
argument_list|,
name|item
argument_list|,
name|rej_level
argument_list|)
expr_stmt|;
name|x
operator|=
name|current_time
argument_list|(
name|JAN_1970
argument_list|)
operator|-
name|started
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
name|x
operator|/
literal|3600.0
operator|+
name|accepts
operator|+
name|rejects
operator|+
name|flushes
operator|+
name|replicates
operator|+
name|skips
operator|>=
name|weeble
condition|)
block|{
name|weeble
operator|*=
name|WEEBLE_FACTOR
expr_stmt|;
name|x
operator|-=
literal|3600.0
operator|*
operator|(
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|x
operator|/
literal|3600.0
argument_list|)
operator|)
expr_stmt|;
name|x
operator|-=
literal|60.0
operator|*
operator|(
name|j
operator|=
call|(
name|int
call|)
argument_list|(
name|x
operator|/
literal|60.0
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: after %d hours %d mins "
argument_list|,
name|argv0
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: after %d mins %.0f secs "
argument_list|,
name|argv0
argument_list|,
name|j
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: after %.1f secs "
argument_list|,
name|argv0
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"acc. %.0f rej. %.0f flush %.0f"
argument_list|,
name|accepts
argument_list|,
name|rejects
argument_list|,
name|flushes
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|op_listen
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" rep. %.0f skip %.0f"
argument_list|,
name|replicates
argument_list|,
name|skips
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" max.off. %.3f corr. %.3f\n"
argument_list|,
name|maxoff
argument_list|,
name|correction
argument_list|)
expr_stmt|;
name|format_time
argument_list|(
name|text
argument_list|,
literal|100
argument_list|,
name|offset
argument_list|,
name|error
argument_list|,
name|drift
argument_list|,
name|drifterr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|argv0
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|maxoff
operator|=
literal|0.0
expr_stmt|;
block|}
if|if
condition|(
name|current_time
argument_list|(
name|JAN_1970
argument_list|)
operator|-
name|previous
operator|>
name|count
operator|*
name|delay
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no packets in too long a period\n"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Listen for the next broadcast packet.  This allows up to ETHERNET_MAX replications per packet, for systems with multiple addresses for receiving broadcasts; the only reason for a limit is to protect against broken NTP servers always returning the same time. */
if|if
condition|(
name|operation
operator|==
name|op_listen
condition|)
block|{
name|flushes
operator|+=
name|flush_socket
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_packet
argument_list|(
literal|0
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
operator|++
name|rejects
expr_stmt|;
if|if
condition|(
operator|++
name|rej_level
operator|>
name|count
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"too many bad or lost packets"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|!=
name|action_display
operator|&&
name|drifterr
operator|>=
literal|0.0
condition|)
block|{
name|correction
operator|+=
name|correct_drift
argument_list|(
operator|&
name|when
argument_list|,
operator|&
name|offset
argument_list|,
name|drift
argument_list|)
expr_stmt|;
name|handle_saving
argument_list|(
name|save_write
argument_list|,
operator|&
name|total
argument_list|,
operator|&
name|index
argument_list|,
operator|&
name|cycle
argument_list|,
name|record
argument_list|,
operator|&
name|previous
argument_list|,
operator|&
name|when
argument_list|,
operator|&
name|correction
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|(
name|rej_level
operator|-=
operator|(
name|count
operator|<
literal|5
condition|?
name|count
else|:
literal|5
operator|)
operator|)
operator|<
literal|0
condition|)
name|rej_level
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|data
operator|.
name|transmit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|x
operator|==
name|history
index|[
name|i
index|]
condition|)
block|{
operator|++
name|replicates
expr_stmt|;
if|if
condition|(
operator|++
name|rep_level
operator|>
name|ETHERNET_MAX
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"too many replicated packets"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|continue1
goto|;
block|}
name|rep_level
operator|=
literal|0
expr_stmt|;
name|history
index|[
name|item
index|]
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|++
name|item
operator|>=
name|count
condition|)
name|item
operator|=
literal|0
expr_stmt|;
comment|/* Accept a packet only after a long enough period has elapsed. */
name|when
operator|=
name|data
operator|.
name|current
expr_stmt|;
if|if
condition|(
operator|!
name|retry
operator|&&
name|when
operator|<
name|previous
operator|+
name|delay
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Skipping too recent packet\n"
argument_list|)
expr_stmt|;
operator|++
name|skips
expr_stmt|;
continue|continue;
block|}
name|retry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Offset=%.6f @ %.6f disp=%.6f\n"
argument_list|,
name|offset
argument_list|,
name|when
argument_list|,
name|dispersion
argument_list|)
expr_stmt|;
comment|/* Handle the client/server model.  It keeps a record of transmitted times, mainly out of paranoia.  The waiting time is kludged up to attempt to provide reasonable resilience against both lost packets and dead servers.  But it won't handle much of either, and will stop after a while, needing manual restarting.  Running it under cron is the best approach. */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|retry
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sleeping for %d\n"
argument_list|,
name|waiting
argument_list|)
expr_stmt|;
name|do_nothing
argument_list|(
name|waiting
argument_list|)
expr_stmt|;
block|}
name|make_packet
argument_list|(
operator|&
name|data
argument_list|,
name|NTP_CLIENT
argument_list|)
expr_stmt|;
name|outgoing
index|[
name|item
index|]
operator|=
name|data
operator|.
name|transmit
expr_stmt|;
if|if
condition|(
operator|++
name|item
operator|>=
literal|2
operator|*
name|count
condition|)
name|item
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|attempts
operator|<
literal|2
operator|*
name|count
condition|)
operator|++
name|attempts
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Outgoing packet on socket %d:\n"
argument_list|,
name|cycle
argument_list|)
expr_stmt|;
name|display_data
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
name|pack_ntp
argument_list|(
name|transmit
argument_list|,
name|NTP_PACKET_MIN
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|display_packet
argument_list|(
name|transmit
argument_list|,
name|NTP_PACKET_MIN
argument_list|)
expr_stmt|;
name|flushes
operator|+=
name|flush_socket
argument_list|(
name|cycle
argument_list|)
expr_stmt|;
name|write_socket
argument_list|(
name|cycle
argument_list|,
name|transmit
argument_list|,
name|NTP_PACKET_MIN
argument_list|)
expr_stmt|;
comment|/* Read the packet and check that it is an appropriate response.  Because this is rather more numerically sensitive than simple resynchronisation, reject all very inaccurate packets.  Be careful if you modify this, because the error handling is rather nasty to avoid replicating code. */
name|k
operator|=
name|read_packet
argument_list|(
name|cycle
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|cycle
operator|>=
name|nhosts
condition|)
name|cycle
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|k
condition|)
name|when
operator|=
operator|(
name|data
operator|.
name|originate
operator|+
name|data
operator|.
name|current
operator|)
operator|/
literal|2.0
expr_stmt|;
elseif|else
if|if
condition|(
name|action
operator|!=
name|action_display
operator|&&
name|drifterr
operator|>=
literal|0.0
condition|)
block|{
name|correction
operator|+=
name|correct_drift
argument_list|(
operator|&
name|when
argument_list|,
operator|&
name|offset
argument_list|,
name|drift
argument_list|)
expr_stmt|;
name|handle_saving
argument_list|(
name|save_write
argument_list|,
operator|&
name|total
argument_list|,
operator|&
name|index
argument_list|,
operator|&
name|cycle
argument_list|,
name|record
argument_list|,
operator|&
name|previous
argument_list|,
operator|&
name|when
argument_list|,
operator|&
name|correction
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|k
operator|&&
operator|!
name|retry
operator|&&
name|when
operator|<
name|previous
operator|+
name|delay
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: packets out of order on socket %d\n"
argument_list|,
name|argv0
argument_list|,
name|cycle
argument_list|)
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|k
operator|&&
name|data
operator|.
name|current
operator|-
name|data
operator|.
name|originate
operator|>
name|maxerr
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: very slow response rejected on socket %d\n"
argument_list|,
name|argv0
argument_list|,
name|cycle
argument_list|)
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Count the number of rejected packets and fail if there are too many. */
if|if
condition|(
name|k
condition|)
block|{
operator|++
name|rejects
expr_stmt|;
if|if
condition|(
operator|++
name|rej_level
operator|>
name|count
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"too many bad or lost packets"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|retry
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
else|else
name|retry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rej_level
operator|-=
operator|(
name|count
operator|<
literal|5
condition|?
name|count
else|:
literal|5
operator|)
operator|)
operator|<
literal|0
condition|)
name|rej_level
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Offset=%.6f+/-%.6f @ %.6f disp=%.6f\n"
argument_list|,
name|offset
argument_list|,
name|error
argument_list|,
name|when
argument_list|,
name|dispersion
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate the statistics, and display the results or make the initial correction.  Note that estimate_stats() will return zero if a timestamp indicates synchronisation loss (usually due to down time or a change of server, somewhere upstream), and that the recovery operation is unstructured, so great care should be taken when modifying it.  Also, we want to clear the saved state is the statistics are bad. */
name|handle_saving
argument_list|(
name|save_clear
argument_list|,
operator|&
name|total
argument_list|,
operator|&
name|index
argument_list|,
operator|&
name|cycle
argument_list|,
name|record
argument_list|,
operator|&
name|previous
argument_list|,
operator|&
name|when
argument_list|,
operator|&
name|correction
argument_list|)
expr_stmt|;
operator|++
name|accepts
expr_stmt|;
name|dispersion
operator|=
name|data
operator|.
name|dispersion
expr_stmt|;
name|previous
operator|=
name|when
operator|=
name|estimate_stats
argument_list|(
operator|&
name|total
argument_list|,
operator|&
name|index
argument_list|,
name|record
argument_list|,
name|correction
argument_list|,
operator|&
name|dispersion
argument_list|,
operator|&
name|when
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|error
argument_list|,
operator|&
name|drift
argument_list|,
operator|&
name|drifterr
argument_list|,
operator|&
name|waiting
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tot=%d ind=%d dis=%.3f when=%.3f off=%.3f "
argument_list|,
name|total
argument_list|,
name|index
argument_list|,
name|dispersion
argument_list|,
name|when
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"err=%.3f wait=%d\n"
argument_list|,
name|error
argument_list|,
name|waiting
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|when
operator|==
literal|0.0
condition|)
return|return;
name|x
operator|=
operator|(
name|maxoff
operator|<
literal|0.0
condition|?
operator|-
name|maxoff
else|:
name|maxoff
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|<
literal|0.0
condition|?
operator|-
name|offset
else|:
name|offset
operator|)
operator|>
name|x
condition|)
name|maxoff
operator|=
name|offset
expr_stmt|;
name|correction
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|op_client
operator|||
name|accepts
operator|>=
name|count
condition|)
block|{
if|if
condition|(
name|action
operator|==
name|action_display
condition|)
block|{
name|format_time
argument_list|(
name|text
argument_list|,
literal|100
argument_list|,
name|offset
argument_list|,
name|error
argument_list|,
name|drift
argument_list|,
name|drifterr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|reset_clock
argument_list|(
name|offset
argument_list|,
name|error
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|correction
operator|+=
name|x
expr_stmt|;
name|offset
operator|-=
name|x
expr_stmt|;
block|}
block|}
else|else
name|waiting
operator|=
name|delay
expr_stmt|;
name|handle_saving
argument_list|(
name|save_write
argument_list|,
operator|&
name|total
argument_list|,
operator|&
name|index
argument_list|,
operator|&
name|cycle
argument_list|,
name|record
argument_list|,
operator|&
name|previous
argument_list|,
operator|&
name|when
argument_list|,
operator|&
name|correction
argument_list|)
expr_stmt|;
comment|/* Now correct the clock for a while, before getting another packet and updating the statistics. */
while|while
condition|(
name|when
operator|<
name|previous
operator|+
name|delay
operator|-
name|waiting
condition|)
block|{
name|do_nothing
argument_list|(
name|waiting
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|action_display
condition|)
name|when
operator|+=
name|waiting
expr_stmt|;
else|else
block|{
name|correction
operator|+=
name|correct_drift
argument_list|(
operator|&
name|when
argument_list|,
operator|&
name|offset
argument_list|,
name|drift
argument_list|)
expr_stmt|;
name|handle_saving
argument_list|(
name|save_write
argument_list|,
operator|&
name|total
argument_list|,
operator|&
name|index
argument_list|,
operator|&
name|cycle
argument_list|,
name|record
argument_list|,
operator|&
name|previous
argument_list|,
operator|&
name|when
argument_list|,
operator|&
name|correction
argument_list|)
expr_stmt|;
block|}
block|}
name|continue1
label|:
empty_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|run_client
parameter_list|(
name|char
modifier|*
name|hostnames
index|[]
parameter_list|,
name|int
name|nhosts
parameter_list|)
block|{
comment|/* Get enough responses to do something with; or not, as the case may be.  Note that it allows for half of the packets to be bad, so may make up to twice as many attempts as specified by the -c value.  The deadline checking is merely paranoia, to protect against broken signal handling - it cannot easily be triggered if the signal handling works. */
name|double
name|history
index|[
name|COUNT_MAX
index|]
decl_stmt|,
name|guesses
index|[
name|COUNT_MAX
index|]
decl_stmt|,
name|offset
decl_stmt|,
name|error
decl_stmt|,
name|deadline
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|accepts
init|=
literal|0
decl_stmt|,
name|rejects
init|=
literal|0
decl_stmt|,
name|flushes
init|=
literal|0
decl_stmt|,
name|replicates
init|=
literal|0
decl_stmt|,
name|cycle
init|=
literal|0
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|char
name|transmit
index|[
name|NTP_PACKET_MIN
index|]
decl_stmt|;
name|ntp_data
name|data
decl_stmt|;
name|char
name|text
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
block|{
name|format_time
argument_list|(
name|text
argument_list|,
literal|50
argument_list|,
literal|0.0
argument_list|,
operator|-
literal|1.0
argument_list|,
literal|0.0
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Started=%.6f %s\n"
argument_list|,
name|current_time
argument_list|(
name|JAN_1970
argument_list|)
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nhosts
condition|;
operator|++
name|k
control|)
name|open_socket
argument_list|(
name|k
argument_list|,
name|hostnames
index|[
name|k
index|]
argument_list|,
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|!=
name|action_display
condition|)
block|{
name|set_lock
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|1
expr_stmt|;
block|}
name|attempts
operator|=
literal|0
expr_stmt|;
name|deadline
operator|=
name|current_time
argument_list|(
name|JAN_1970
argument_list|)
operator|+
name|delay
expr_stmt|;
comment|/* Listen to broadcast packets and select the best (i.e. earliest).  This will be sensitive to a bad NTP broadcaster, but I believe such things are very rare in practice.  In any case, if you have one, it is probably the only one on your subnet, so you are knackered!  This allows up to ETHERNET_MAX replications per packet, for systems with multiple addresses for receiving broadcasts; the only reason for a limit is to protect against broken NTP servers always returning the same time. */
if|if
condition|(
name|operation
operator|==
name|op_listen
condition|)
block|{
while|while
condition|(
name|accepts
operator|<
name|count
condition|)
block|{
if|if
condition|(
name|current_time
argument_list|(
name|JAN_1970
argument_list|)
operator|>
name|deadline
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"not enough valid broadcasts received in time"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|flushes
operator|+=
name|flush_socket
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_packet
argument_list|(
literal|0
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|rejects
operator|>
name|count
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"too many bad or lost packets"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
continue|continue;
block|}
else|else
block|{
name|a
operator|=
name|data
operator|.
name|transmit
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|accepts
condition|;
operator|++
name|k
control|)
if|if
condition|(
name|a
operator|==
name|history
index|[
name|k
index|]
condition|)
block|{
if|if
condition|(
operator|++
name|replicates
operator|>
name|ETHERNET_MAX
operator|*
name|count
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"too many replicated packets"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|continue1
goto|;
block|}
name|history
index|[
name|accepts
index|]
operator|=
name|a
expr_stmt|;
name|guesses
index|[
name|accepts
operator|++
index|]
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Offset=%.6f disp=%.6f\n"
argument_list|,
name|x
argument_list|,
name|dispersion
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: offset=%.3f disp=%.3f\n"
argument_list|,
name|argv0
argument_list|,
name|x
argument_list|,
name|dispersion
argument_list|)
expr_stmt|;
comment|/* Note that bubblesort IS a good method for this amount of data.  */
for|for
control|(
name|k
operator|=
name|accepts
operator|-
literal|2
init|;
name|k
operator|>=
literal|0
condition|;
operator|--
name|k
control|)
if|if
condition|(
name|guesses
index|[
name|k
index|]
operator|<
name|guesses
index|[
name|k
operator|+
literal|1
index|]
condition|)
break|break;
else|else
block|{
name|x
operator|=
name|guesses
index|[
name|k
index|]
expr_stmt|;
name|guesses
index|[
name|k
index|]
operator|=
name|guesses
index|[
name|k
operator|+
literal|1
index|]
expr_stmt|;
name|guesses
index|[
name|k
operator|+
literal|1
index|]
operator|=
name|x
expr_stmt|;
block|}
name|continue1
label|:
empty_stmt|;
block|}
name|offset
operator|=
name|guesses
index|[
literal|0
index|]
expr_stmt|;
name|error
operator|=
name|minerr
operator|+
name|guesses
index|[
name|count
operator|<=
literal|5
condition|?
name|count
operator|-
literal|1
else|:
literal|5
index|]
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"accepts=%d rejects=%d flushes=%d replicates=%d\n"
argument_list|,
name|accepts
argument_list|,
name|rejects
argument_list|,
name|flushes
argument_list|,
name|replicates
argument_list|)
expr_stmt|;
comment|/* Handle the client/server model.  It keeps a record of transmitted times, mainly out of paranoia. */
block|}
else|else
block|{
name|offset
operator|=
literal|0.0
expr_stmt|;
name|error
operator|=
name|NTP_INSANITY
expr_stmt|;
while|while
condition|(
name|accepts
operator|<
name|count
operator|&&
name|attempts
operator|<
literal|2
operator|*
name|count
condition|)
block|{
if|if
condition|(
name|current_time
argument_list|(
name|JAN_1970
argument_list|)
operator|>
name|deadline
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"not enough valid responses received in time"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|make_packet
argument_list|(
operator|&
name|data
argument_list|,
name|NTP_CLIENT
argument_list|)
expr_stmt|;
name|outgoing
index|[
name|attempts
operator|++
index|]
operator|=
name|data
operator|.
name|transmit
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Outgoing packet on socket %d:\n"
argument_list|,
name|cycle
argument_list|)
expr_stmt|;
name|display_data
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
name|pack_ntp
argument_list|(
name|transmit
argument_list|,
name|NTP_PACKET_MIN
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|display_packet
argument_list|(
name|transmit
argument_list|,
name|NTP_PACKET_MIN
argument_list|)
expr_stmt|;
name|flushes
operator|+=
name|flush_socket
argument_list|(
name|cycle
argument_list|)
expr_stmt|;
name|write_socket
argument_list|(
name|cycle
argument_list|,
name|transmit
argument_list|,
name|NTP_PACKET_MIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_packet
argument_list|(
name|cycle
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|rejects
operator|>
name|count
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"too many bad or lost packets"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
continue|continue;
block|}
else|else
operator|++
name|accepts
expr_stmt|;
if|if
condition|(
operator|++
name|cycle
operator|>=
name|nhosts
condition|)
name|cycle
operator|=
literal|0
expr_stmt|;
comment|/* Work out the most accurate time, and check that it isn't more accurate than the results warrant. */
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Offset=%.6f+/-%.6f disp=%.6f\n"
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|dispersion
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: offset=%.3f+/-%.3f disp=%.3f\n"
argument_list|,
name|argv0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|dispersion
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|x
operator|-
name|offset
operator|)
operator|<
literal|0.0
condition|)
name|a
operator|=
operator|-
name|a
expr_stmt|;
if|if
condition|(
name|accepts
operator|<=
literal|1
condition|)
name|a
operator|=
literal|0.0
expr_stmt|;
name|b
operator|=
name|error
operator|+
name|y
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|error
condition|)
block|{
name|offset
operator|=
name|x
expr_stmt|;
name|error
operator|=
name|y
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"best=%.6f+/-%.6f\n"
argument_list|,
name|offset
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|>
name|b
condition|)
block|{
name|sprintf
argument_list|(
name|text
argument_list|,
literal|"%d"
argument_list|,
name|cycle
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"inconsistent times got from NTP server on socket %s"
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|<=
name|minerr
condition|)
break|break;
block|}
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"accepts=%d rejects=%d flushes=%d\n"
argument_list|,
name|accepts
argument_list|,
name|rejects
argument_list|,
name|flushes
argument_list|)
expr_stmt|;
block|}
comment|/* Tidy up the socket, issues diagnostics and perform the action. */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nhosts
condition|;
operator|++
name|k
control|)
name|close_socket
argument_list|(
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|accepts
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"no acceptable packets received"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
name|NTP_INSANITY
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"unable to get a reasonable time estimate"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Correction: %.6f +/- %.6f disp=%.6f\n"
argument_list|,
name|offset
argument_list|,
name|error
argument_list|,
name|dispersion
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|action_display
condition|)
block|{
name|format_time
argument_list|(
name|text
argument_list|,
literal|75
argument_list|,
name|offset
argument_list|,
name|error
argument_list|,
literal|0.0
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|reset_clock
argument_list|(
name|offset
argument_list|,
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|set_lock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Stopped normally\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
comment|/* This is the entry point and all that.  It decodes the arguments and calls one of the specialised routines to do the work. */
name|char
modifier|*
name|hostnames
index|[
name|MAX_SOCKETS
index|]
decl_stmt|,
modifier|*
name|savename
init|=
name|NULL
decl_stmt|;
name|int
name|daemon
init|=
literal|0
decl_stmt|,
name|nhosts
init|=
literal|0
decl_stmt|,
name|help
init|=
literal|0
decl_stmt|,
name|args
init|=
name|argc
operator|-
literal|1
decl_stmt|,
name|k
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|argv0
operator|=
literal|"msntp"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|argv0
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|++
name|argv0
expr_stmt|;
else|else
name|argv0
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|setvbuf
argument_list|(
name|stderr
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_MAX
operator|<
literal|2147483647
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"msntp requires>= 32-bit ints"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|DBL_EPSILON
operator|>
literal|1.0e-13
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"msntp requires doubles with eps<= 1.0e-13"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|MAX_SOCKETS
condition|;
operator|++
name|k
control|)
name|hostnames
index|[
name|k
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Decode the arguments. */
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|k
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-4"
argument_list|)
operator|==
literal|0
condition|)
name|preferred_family
argument_list|(
name|PREF_FAM_INET
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-6"
argument_list|)
operator|==
literal|0
condition|)
name|preferred_family
argument_list|(
name|PREF_FAM_INET6
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-B"
argument_list|)
operator|==
literal|0
operator|&&
name|action
operator|==
literal|0
condition|)
block|{
name|action
operator|=
name|action_broadcast
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"%d%c"
argument_list|,
operator|&
name|period
argument_list|,
operator|&
name|c
argument_list|)
operator|!=
literal|1
condition|)
name|syntax
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|period
operator|<
literal|1
operator|||
name|period
operator|>
literal|1440
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"%s option value out of range"
argument_list|,
literal|"-B"
argument_list|)
expr_stmt|;
name|period
operator|*=
literal|60
expr_stmt|;
name|k
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|period
operator|=
literal|60
operator|*
literal|60
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-S"
argument_list|)
operator|==
literal|0
operator|&&
name|action
operator|==
literal|0
condition|)
name|action
operator|=
name|action_server
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-q"
argument_list|)
operator|==
literal|0
operator|&&
name|action
operator|==
literal|0
condition|)
name|action
operator|=
name|action_query
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-r"
argument_list|)
operator|==
literal|0
operator|&&
name|action
operator|==
literal|0
condition|)
name|action
operator|=
name|action_reset
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-a"
argument_list|)
operator|==
literal|0
operator|&&
name|action
operator|==
literal|0
condition|)
name|action
operator|=
name|action_adjust
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-l"
argument_list|)
operator|==
literal|0
operator|&&
name|lockname
operator|==
name|NULL
operator|&&
name|argc
operator|>
literal|2
condition|)
block|{
name|lockname
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|k
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-x"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|daemon
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|2
operator|&&
name|sscanf
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"%d%c"
argument_list|,
operator|&
name|daemon
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|daemon
operator|<
literal|1
operator|||
name|daemon
operator|>
literal|1440
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"%s option value out of range"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|k
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|daemon
operator|=
literal|300
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-f"
argument_list|)
operator|==
literal|0
operator|&&
name|savename
operator|==
name|NULL
operator|&&
name|argc
operator|>
literal|2
condition|)
block|{
name|savename
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|k
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--help"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-h"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-?"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|help
operator|==
literal|0
condition|)
name|help
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-v"
argument_list|)
operator|==
literal|0
operator|&&
name|verbose
operator|==
literal|0
condition|)
name|verbose
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-V"
argument_list|)
operator|==
literal|0
operator|&&
name|verbose
operator|==
literal|0
condition|)
name|verbose
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-W"
argument_list|)
operator|==
literal|0
operator|&&
name|verbose
operator|==
literal|0
condition|)
name|verbose
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-e"
argument_list|)
operator|==
literal|0
operator|&&
name|minerr
operator|==
literal|0.0
operator|&&
name|argc
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"%lf%c"
argument_list|,
operator|&
name|minerr
argument_list|,
operator|&
name|c
argument_list|)
operator|!=
literal|1
condition|)
name|syntax
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|minerr
operator|<=
literal|0.000999999
operator|||
name|minerr
operator|>
literal|1.0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"%s option value out of range"
argument_list|,
literal|"-e"
argument_list|)
expr_stmt|;
name|k
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-E"
argument_list|)
operator|==
literal|0
operator|&&
name|maxerr
operator|==
literal|0.0
operator|&&
name|argc
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"%lf%c"
argument_list|,
operator|&
name|maxerr
argument_list|,
operator|&
name|c
argument_list|)
operator|!=
literal|1
condition|)
name|syntax
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxerr
operator|<
literal|1.0
operator|||
name|maxerr
operator|>
literal|60.0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"%s option value out of range"
argument_list|,
literal|"-E"
argument_list|)
expr_stmt|;
name|k
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-P"
argument_list|)
operator|==
literal|0
operator|&&
name|prompt
operator|==
literal|0.0
operator|&&
name|argc
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"no"
argument_list|)
operator|==
literal|0
condition|)
name|prompt
operator|=
operator|(
name|double
operator|)
name|INT_MAX
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"%lf%c"
argument_list|,
operator|&
name|prompt
argument_list|,
operator|&
name|c
argument_list|)
operator|!=
literal|1
condition|)
name|syntax
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prompt
operator|<
literal|1.0
operator|||
name|prompt
operator|>
literal|3600.0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"%s option value out of range"
argument_list|,
literal|"-p"
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-d"
argument_list|)
operator|==
literal|0
operator|&&
name|delay
operator|==
literal|0
operator|&&
name|argc
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"%d%c"
argument_list|,
operator|&
name|delay
argument_list|,
operator|&
name|c
argument_list|)
operator|!=
literal|1
condition|)
name|syntax
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
operator|<
literal|1
operator|||
name|delay
operator|>
literal|3600
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"%s option value out of range"
argument_list|,
literal|"-d"
argument_list|)
expr_stmt|;
name|k
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-c"
argument_list|)
operator|==
literal|0
operator|&&
name|count
operator|==
literal|0
operator|&&
name|argc
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"%d%c"
argument_list|,
operator|&
name|count
argument_list|,
operator|&
name|c
argument_list|)
operator|!=
literal|1
condition|)
name|syntax
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|1
operator|||
name|count
operator|>
name|COUNT_MAX
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"%s option value out of range"
argument_list|,
literal|"-c"
argument_list|)
expr_stmt|;
name|k
operator|=
literal|2
expr_stmt|;
block|}
else|else
break|break;
name|argc
operator|-=
name|k
expr_stmt|;
name|argv
operator|+=
name|k
expr_stmt|;
block|}
comment|/* Check the arguments for consistency and set the defaults. */
if|if
condition|(
name|action
operator|==
name|action_broadcast
operator|||
name|action
operator|==
name|action_server
condition|)
block|{
name|operation
operator|=
operator|(
name|action
operator|==
name|action_server
condition|?
name|op_server
else|:
name|op_broadcast
operator|)
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
operator|||
name|minerr
operator|!=
literal|0.0
operator|||
name|maxerr
operator|!=
literal|0.0
operator|||
name|count
operator|!=
literal|0
operator|||
name|delay
operator|!=
literal|0
operator|||
name|daemon
operator|!=
literal|0
operator|||
name|prompt
operator|!=
literal|0.0
operator|||
name|lockname
operator|!=
name|NULL
operator|||
name|savename
operator|!=
name|NULL
condition|)
name|syntax
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|action_query
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|1
operator|||
name|minerr
operator|!=
literal|0.0
operator|||
name|maxerr
operator|!=
literal|0.0
operator|||
name|count
operator|!=
literal|0
operator|||
name|delay
operator|!=
literal|0
operator|||
name|daemon
operator|!=
literal|0
operator|||
name|prompt
operator|!=
literal|0.0
operator|||
name|lockname
operator|!=
name|NULL
condition|)
name|syntax
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|argc
operator|<
literal|1
operator|||
name|argc
operator|>
name|MAX_SOCKETS
operator|||
operator|(
name|daemon
operator|!=
literal|0
operator|&&
name|delay
operator|!=
literal|0
operator|)
condition|)
name|syntax
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prompt
operator|||
name|lockname
operator|!=
name|NULL
operator|)
operator|&&
name|action
operator|!=
name|action_reset
operator|&&
name|action
operator|!=
name|action_adjust
condition|)
name|syntax
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|count
operator|<
name|argc
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"-c value less than number of addresses"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|operation
operator|=
name|op_client
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|argc
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
name|argv
index|[
name|k
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|argv
index|[
name|k
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"invalid Internet address '%s'"
argument_list|,
name|argv
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|hostnames
index|[
name|k
operator|-
literal|1
index|]
operator|=
name|argv
index|[
name|k
index|]
expr_stmt|;
block|}
name|nhosts
operator|=
name|argc
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|operation
operator|=
name|op_listen
expr_stmt|;
name|nhosts
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|==
literal|0
condition|)
name|action
operator|=
name|action_display
expr_stmt|;
if|if
condition|(
name|minerr
operator|<=
literal|0.0
condition|)
name|minerr
operator|=
operator|(
name|operation
operator|==
name|op_listen
condition|?
literal|0.5
else|:
literal|0.1
operator|)
expr_stmt|;
if|if
condition|(
name|maxerr
operator|<=
literal|0.0
condition|)
name|maxerr
operator|=
literal|5.0
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|count
operator|=
operator|(
name|argc
operator|-
literal|1
operator|<
literal|5
condition|?
literal|5
else|:
name|argc
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|argc
operator|==
literal|1
operator|||
operator|(
name|daemon
operator|!=
literal|0
operator|&&
name|action
operator|!=
name|action_query
operator|)
operator|)
operator|&&
name|count
operator|<
literal|5
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"at least 5 packets needed in this mode"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|action
operator|==
name|action_reset
operator|||
name|action
operator|==
name|action_adjust
operator|)
operator|&&
name|lockname
operator|==
name|NULL
condition|)
name|lockname
operator|=
name|LOCKNAME
expr_stmt|;
comment|/* The '-x' option changes the implications of many other settings, though this is not usually apparent to the caller.  Most of the time delays are to ensure that stuck states terminate, and do not affect the result. */
if|if
condition|(
name|daemon
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|minerr
operator|>=
name|maxerr
operator|||
name|maxerr
operator|>=
name|daemon
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"values not in order -e< -E< -x"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|waiting
operator|=
name|delay
operator|=
name|daemon
operator|*=
literal|60
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|savename
operator|!=
name|NULL
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"-f can be specified only with -x"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
operator|==
literal|0
condition|)
name|delay
operator|=
operator|(
name|operation
operator|==
name|op_listen
condition|?
literal|300
else|:
operator|(
literal|2
operator|*
name|count
operator|>=
literal|15
condition|?
literal|2
operator|*
name|count
operator|+
literal|1
else|:
literal|15
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|op_listen
condition|)
block|{
if|if
condition|(
name|minerr
operator|>=
name|maxerr
operator|||
name|maxerr
operator|>=
name|delay
operator|/
name|count
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"values not in order -e< -E< -d/-c"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|minerr
operator|>=
name|maxerr
operator|||
name|maxerr
operator|>=
name|delay
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"values not in order -e< -E< -d"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|2
operator|*
name|count
operator|>=
name|delay
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"-c must be less than half -d"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|waiting
operator|=
name|delay
operator|/
name|count
expr_stmt|;
block|}
if|if
condition|(
name|prompt
operator|==
literal|0.0
condition|)
name|prompt
operator|=
literal|30.0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|daemon
operator|||
name|action
operator|==
name|action_query
operator|)
operator|&&
name|savename
operator|==
name|NULL
condition|)
name|savename
operator|=
name|SAVENAME
expr_stmt|;
comment|/* Diagnose where we are, if requested, and separate out the classes of  operation.  The calls do not return. */
if|if
condition|(
name|help
condition|)
name|syntax
argument_list|(
name|args
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s options: a=%d p=%d v=%d e=%.3f E=%.3f P=%.3f\n"
argument_list|,
name|argv0
argument_list|,
name|action
argument_list|,
name|period
argument_list|,
name|verbose
argument_list|,
name|minerr
argument_list|,
name|maxerr
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    d=%d c=%d %c=%d op=%d l=%s f=%s"
argument_list|,
name|delay
argument_list|,
name|count
argument_list|,
literal|'x'
argument_list|,
name|daemon
argument_list|,
name|operation
argument_list|,
operator|(
name|lockname
operator|==
name|NULL
condition|?
literal|""
else|:
name|lockname
operator|)
argument_list|,
operator|(
name|savename
operator|==
name|NULL
condition|?
literal|""
else|:
name|savename
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|MAX_SOCKETS
condition|;
operator|++
name|k
control|)
if|if
condition|(
name|hostnames
index|[
name|k
index|]
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|hostnames
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nhosts
operator|==
literal|0
condition|)
name|nhosts
operator|=
literal|1
expr_stmt|;
comment|/* Kludge for broadcasts */
if|if
condition|(
name|operation
operator|==
name|op_server
operator|||
name|operation
operator|==
name|op_broadcast
condition|)
name|run_server
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|action
operator|==
name|action_query
condition|)
block|{
if|if
condition|(
name|savename
operator|==
name|NULL
operator|||
name|savename
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"no daemon save file specified"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|savefile
operator|=
name|fopen
argument_list|(
name|savename
argument_list|,
literal|"rb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"unable to open the daemon save file"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|query_savefile
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|daemon
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|savename
operator|!=
name|NULL
operator|&&
name|savename
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|savefile
operator|=
name|fopen
argument_list|(
name|savename
argument_list|,
literal|"rb+"
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|savefile
operator|=
name|fopen
argument_list|(
name|savename
argument_list|,
literal|"wb+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"unable to open the daemon save file"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|run_daemon
argument_list|(
name|hostnames
argument_list|,
name|nhosts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
name|run_daemon
argument_list|(
name|hostnames
argument_list|,
name|nhosts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|run_client
argument_list|(
name|hostnames
argument_list|,
name|nhosts
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"internal error at end of main"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
end_function

end_unit

