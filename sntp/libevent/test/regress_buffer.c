begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2003-2007 Niels Provos<provos@citi.umich.edu>  * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer_compat.h"
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"defer-internal.h"
end_include

begin_include
include|#
directive|include
file|"evbuffer-internal.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|"regress.h"
end_include

begin_comment
comment|/* Validates that an evbuffer is good. Returns false if it isn't, true if it  * is*/
end_comment

begin_function
specifier|static
name|int
name|evbuffer_validate_
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
name|size_t
name|sum
init|=
literal|0
decl_stmt|;
name|int
name|found_last_with_datap
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|first
operator|==
name|NULL
condition|)
block|{
name|tt_assert
argument_list|(
name|buf
operator|->
name|last
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
operator|->
name|total_len
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|buf
operator|->
name|first
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
operator|->
name|last_with_datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|last_with_datap
operator|==
operator|&
name|buf
operator|->
name|first
condition|)
name|found_last_with_datap
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|chain
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|&
name|chain
operator|->
name|next
operator|==
name|buf
operator|->
name|last_with_datap
condition|)
name|found_last_with_datap
operator|=
literal|1
expr_stmt|;
name|sum
operator|+=
name|chain
operator|->
name|off
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|tt_assert
argument_list|(
name|buf
operator|->
name|last
operator|==
name|chain
argument_list|)
expr_stmt|;
block|}
name|tt_assert
argument_list|(
name|chain
operator|->
name|buffer_len
operator|>=
name|chain
operator|->
name|misalign
operator|+
name|chain
operator|->
name|off
argument_list|)
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|->
name|first
condition|)
name|tt_assert
argument_list|(
operator|*
name|buf
operator|->
name|last_with_datap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|->
name|last_with_datap
condition|)
block|{
name|chain
operator|=
operator|*
name|buf
operator|->
name|last_with_datap
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|off
operator|==
literal|0
operator|||
name|buf
operator|->
name|total_len
operator|==
literal|0
condition|)
block|{
name|tt_assert
argument_list|(
argument|chain->off ==
literal|0
argument_list|)
name|tt_assert
argument_list|(
name|chain
operator|==
name|buf
operator|->
name|first
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
operator|->
name|total_len
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|chain
operator|!=
name|NULL
condition|)
block|{
name|tt_assert
argument_list|(
name|chain
operator|->
name|off
operator|==
literal|0
argument_list|)
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|tt_assert
argument_list|(
name|buf
operator|->
name|last_with_datap
operator|==
operator|&
name|buf
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
name|tt_assert
argument_list|(
name|found_last_with_datap
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|sum
operator|==
name|buf
operator|->
name|total_len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|end
label|:
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evbuffer_get_waste
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|allocatedp
parameter_list|,
name|size_t
modifier|*
name|wastedp
parameter_list|,
name|size_t
modifier|*
name|usedp
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
name|size_t
name|a
decl_stmt|,
name|w
decl_stmt|,
name|u
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|u
operator|=
name|a
operator|=
name|w
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|buf
operator|->
name|first
expr_stmt|;
comment|/* skip empty at start */
while|while
condition|(
name|chain
operator|&&
name|chain
operator|->
name|off
operator|==
literal|0
condition|)
block|{
operator|++
name|n
expr_stmt|;
name|a
operator|+=
name|chain
operator|->
name|buffer_len
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
comment|/* first nonempty chain: stuff at the end only is wasted. */
if|if
condition|(
name|chain
condition|)
block|{
operator|++
name|n
expr_stmt|;
name|a
operator|+=
name|chain
operator|->
name|buffer_len
expr_stmt|;
name|u
operator|+=
name|chain
operator|->
name|off
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|next
operator|&&
name|chain
operator|->
name|next
operator|->
name|off
condition|)
name|w
operator|+=
call|(
name|size_t
call|)
argument_list|(
name|chain
operator|->
name|buffer_len
operator|-
operator|(
name|chain
operator|->
name|misalign
operator|+
name|chain
operator|->
name|off
operator|)
argument_list|)
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
comment|/* subsequent nonempty chains */
while|while
condition|(
name|chain
operator|&&
name|chain
operator|->
name|off
condition|)
block|{
operator|++
name|n
expr_stmt|;
name|a
operator|+=
name|chain
operator|->
name|buffer_len
expr_stmt|;
name|w
operator|+=
operator|(
name|size_t
operator|)
name|chain
operator|->
name|misalign
expr_stmt|;
name|u
operator|+=
name|chain
operator|->
name|off
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|next
operator|&&
name|chain
operator|->
name|next
operator|->
name|off
condition|)
name|w
operator|+=
call|(
name|size_t
call|)
argument_list|(
name|chain
operator|->
name|buffer_len
operator|-
operator|(
name|chain
operator|->
name|misalign
operator|+
name|chain
operator|->
name|off
operator|)
argument_list|)
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
comment|/* subsequent empty chains */
while|while
condition|(
name|chain
condition|)
block|{
operator|++
name|n
expr_stmt|;
name|a
operator|+=
name|chain
operator|->
name|buffer_len
expr_stmt|;
block|}
operator|*
name|allocatedp
operator|=
name|a
expr_stmt|;
operator|*
name|wastedp
operator|=
name|w
expr_stmt|;
operator|*
name|usedp
operator|=
name|u
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|evbuffer_validate
parameter_list|(
name|buf
parameter_list|)
define|\
value|TT_STMT_BEGIN if (!evbuffer_validate_(buf)) TT_DIE(("Buffer format invalid")); TT_STMT_END
end_define

begin_function
specifier|static
name|void
name|test_evbuffer
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|512
index|]
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|evb
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|evb_two
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|size_t
name|sz_tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_add_printf
argument_list|(
name|evb
argument_list|,
literal|"%s/%d"
argument_list|,
literal|"hello"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_get_length
argument_list|(
name|evb
argument_list|)
operator|==
literal|7
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|EVBUFFER_DATA
argument_list|(
name|evb
argument_list|)
argument_list|,
literal|"hello/1"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_add_buffer
argument_list|(
name|evb
argument_list|,
name|evb_two
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|evb
argument_list|,
name|strlen
argument_list|(
literal|"hello/"
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_get_length
argument_list|(
name|evb
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|EVBUFFER_DATA
argument_list|(
name|evb
argument_list|)
argument_list|,
literal|"1"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_add_printf
argument_list|(
name|evb_two
argument_list|,
literal|"%s"
argument_list|,
literal|"/hello"
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_add_buffer
argument_list|(
name|evb
argument_list|,
name|evb_two
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_get_length
argument_list|(
name|evb_two
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_get_length
argument_list|(
name|evb
argument_list|)
operator|==
literal|7
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|EVBUFFER_DATA
argument_list|(
name|evb
argument_list|)
argument_list|,
literal|"1/hello"
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|evb
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_get_length
argument_list|(
name|evb
argument_list|)
operator|==
literal|7
operator|+
literal|512
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|evbuffer_pullup
argument_list|(
name|evb
argument_list|,
literal|7
operator|+
literal|512
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|strncmp
argument_list|(
name|tmp
argument_list|,
literal|"1/hello"
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|memcmp
argument_list|(
name|tmp
operator|+
literal|7
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_prepend
argument_list|(
name|evb
argument_list|,
literal|"something"
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_prepend
argument_list|(
name|evb
argument_list|,
literal|"else"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|evbuffer_pullup
argument_list|(
name|evb
argument_list|,
literal|4
operator|+
literal|9
operator|+
literal|7
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|strncmp
argument_list|(
name|tmp
argument_list|,
literal|"elsesomething1/hello"
argument_list|,
literal|4
operator|+
literal|9
operator|+
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|evb
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|evb_two
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|evbuffer_add
argument_list|(
name|evb_two
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb_two
argument_list|)
expr_stmt|;
name|evbuffer_add_buffer
argument_list|(
name|evb
argument_list|,
name|evb_two
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb_two
argument_list|)
expr_stmt|;
block|}
name|tt_assert
argument_list|(
name|evbuffer_get_length
argument_list|(
name|evb_two
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_get_length
argument_list|(
name|evb
argument_list|)
operator|==
name|i
operator|*
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* test remove buffer */
name|sz_tmp
operator|=
call|(
name|size_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|*
literal|2.5
argument_list|)
expr_stmt|;
name|evbuffer_remove_buffer
argument_list|(
name|evb
argument_list|,
name|evb_two
argument_list|,
name|sz_tmp
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_get_length
argument_list|(
name|evb_two
argument_list|)
operator|==
name|sz_tmp
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_get_length
argument_list|(
name|evb
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|evbuffer_pullup
argument_list|(
name|evb
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|/
literal|2
argument_list|)
operator|!=
literal|0
operator|||
name|memcmp
argument_list|(
name|evbuffer_pullup
argument_list|(
name|evb_two
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|!=
literal|0
argument_list|)
condition|)
name|tt_abort_msg
argument_list|(
literal|"Pullup did not preserve content"
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
comment|/* testing one-vector reserve and commit */
block|{
name|struct
name|evbuffer_iovec
name|v
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|r
operator|=
name|evbuffer_reserve_space
argument_list|(
name|evb
argument_list|,
literal|10000
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
operator|>=
literal|10000
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|buf
operator|=
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|10000
condition|;
operator|++
name|j
control|)
block|{
name|buf
index|[
name|j
index|]
operator|=
name|j
expr_stmt|;
block|}
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_commit_space
argument_list|(
name|evb
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_get_length
argument_list|(
name|evb
argument_list|)
operator|>=
literal|10000
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|evb
argument_list|,
name|j
operator|*
literal|5000
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
block|}
block|}
name|end
label|:
name|evbuffer_free
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_free
argument_list|(
name|evb_two
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|no_cleanup
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|datalen
parameter_list|,
name|void
modifier|*
name|extra
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_remove_buffer_with_empty
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|src
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|dst
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|evbuffer_validate
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|dst
argument_list|)
expr_stmt|;
comment|/* setup the buffers */
comment|/* we need more data in src than we will move later */
name|evbuffer_add_reference
argument_list|(
name|src
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|no_cleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evbuffer_add_reference
argument_list|(
name|src
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|no_cleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* we need one buffer in dst and one empty buffer at the end */
name|evbuffer_add
argument_list|(
name|dst
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_add_reference
argument_list|(
name|dst
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|no_cleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|dst
argument_list|)
expr_stmt|;
comment|/* move three bytes over */
name|evbuffer_remove_buffer
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|end
label|:
name|evbuffer_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|evbuffer_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_reserve2
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
comment|/* Test the two-vector cases of reserve/commit. */
name|struct
name|evbuffer
modifier|*
name|buf
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|evbuffer_iovec
name|v
index|[
literal|2
index|]
decl_stmt|;
name|size_t
name|remaining
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
comment|/* First chunk will necessarily be one chunk. Use 512 bytes of it.*/
name|n
operator|=
name|evbuffer_reserve_space
argument_list|(
name|buf
argument_list|,
literal|1024
argument_list|,
name|v
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|,
operator|>=
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|,
literal|'X'
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|cp
operator|=
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
expr_stmt|;
name|remaining
operator|=
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
operator|-
literal|512
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
literal|512
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|evbuffer_commit_space
argument_list|(
name|buf
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Ask for another same-chunk request, in an existing chunk. Use 8 	 * bytes of it. */
name|n
operator|=
name|evbuffer_reserve_space
argument_list|(
name|buf
argument_list|,
literal|32
argument_list|,
name|v
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|cp
operator|+
literal|512
operator|==
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|remaining
argument_list|,
operator|==
argument_list|,
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|,
literal|'Y'
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
literal|8
expr_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|evbuffer_commit_space
argument_list|(
name|buf
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|520
argument_list|)
expr_stmt|;
name|remaining
operator|-=
literal|8
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Now ask for a request that will be split. Use only one byte of it, 	   though. */
name|n
operator|=
name|evbuffer_reserve_space
argument_list|(
name|buf
argument_list|,
name|remaining
operator|+
literal|64
argument_list|,
name|v
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|cp
operator|+
literal|520
operator|==
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|remaining
argument_list|,
operator|==
argument_list|,
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|1
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|1
index|]
operator|.
name|iov_len
operator|>=
literal|64
argument_list|)
expr_stmt|;
name|cp2
operator|=
name|v
index|[
literal|1
index|]
operator|.
name|iov_base
expr_stmt|;
name|memset
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|,
literal|'Z'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
literal|1
expr_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|evbuffer_commit_space
argument_list|(
name|buf
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|521
argument_list|)
expr_stmt|;
name|remaining
operator|-=
literal|1
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Now ask for a request that will be split. Use some of the first 	 * part and some of the second. */
name|n
operator|=
name|evbuffer_reserve_space
argument_list|(
name|buf
argument_list|,
name|remaining
operator|+
literal|64
argument_list|,
name|v
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|cp
operator|+
literal|521
operator|==
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|remaining
argument_list|,
operator|==
argument_list|,
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|1
index|]
operator|.
name|iov_base
operator|==
name|cp2
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|1
index|]
operator|.
name|iov_len
operator|>=
literal|64
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|,
literal|'W'
argument_list|,
literal|400
argument_list|)
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
literal|400
expr_stmt|;
name|memset
argument_list|(
name|v
index|[
literal|1
index|]
operator|.
name|iov_base
argument_list|,
literal|'x'
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
literal|60
expr_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|evbuffer_commit_space
argument_list|(
name|buf
argument_list|,
name|v
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|981
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Now peek to make sure stuff got made how we like. */
name|memset
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|evbuffer_peek
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|v
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|,
operator|==
argument_list|,
literal|921
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|v
index|[
literal|1
index|]
operator|.
name|iov_len
argument_list|,
operator|==
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|cp
operator|=
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|512
condition|;
operator|++
name|i
control|)
name|tt_int_op
argument_list|(
name|cp
index|[
name|i
index|]
argument_list|,
operator|==
argument_list|,
literal|'X'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|512
init|;
name|i
operator|<
literal|520
condition|;
operator|++
name|i
control|)
name|tt_int_op
argument_list|(
name|cp
index|[
name|i
index|]
argument_list|,
operator|==
argument_list|,
literal|'Y'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|520
init|;
name|i
operator|<
literal|521
condition|;
operator|++
name|i
control|)
name|tt_int_op
argument_list|(
name|cp
index|[
name|i
index|]
argument_list|,
operator|==
argument_list|,
literal|'Z'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|521
init|;
name|i
operator|<
literal|921
condition|;
operator|++
name|i
control|)
name|tt_int_op
argument_list|(
name|cp
index|[
name|i
index|]
argument_list|,
operator|==
argument_list|,
literal|'W'
argument_list|)
expr_stmt|;
name|cp
operator|=
name|v
index|[
literal|1
index|]
operator|.
name|iov_base
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|60
condition|;
operator|++
name|i
control|)
name|tt_int_op
argument_list|(
name|cp
index|[
name|i
index|]
argument_list|,
operator|==
argument_list|,
literal|'x'
argument_list|)
expr_stmt|;
name|end
label|:
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_reserve_many
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
comment|/* This is a glass-box test to handle expanding a buffer with more 	 * chunks and reallocating chunks as needed */
name|struct
name|evbuffer
modifier|*
name|buf
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|struct
name|evbuffer_iovec
name|v
index|[
literal|8
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|int
name|add_data
init|=
name|ptr
operator|&&
operator|!
name|strcmp
argument_list|(
name|ptr
argument_list|,
literal|"add"
argument_list|)
decl_stmt|;
name|int
name|fill_first
init|=
name|ptr
operator|&&
operator|!
name|strcmp
argument_list|(
name|ptr
argument_list|,
literal|"fill"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
comment|/* When reserving the the first chunk, we just allocate it */
name|n
operator|=
name|evbuffer_reserve_space
argument_list|(
name|buf
argument_list|,
literal|128
argument_list|,
name|v
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
operator|>=
literal|128
argument_list|)
expr_stmt|;
name|sz
operator|=
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
expr_stmt|;
name|cp1
operator|=
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
expr_stmt|;
if|if
condition|(
name|add_data
condition|)
block|{
operator|*
operator|(
name|char
operator|*
operator|)
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
literal|'X'
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
literal|1
expr_stmt|;
name|n
operator|=
name|evbuffer_commit_space
argument_list|(
name|buf
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fill_first
condition|)
block|{
name|memset
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|,
literal|'X'
argument_list|,
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|n
operator|=
name|evbuffer_commit_space
argument_list|(
name|buf
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|evbuffer_reserve_space
argument_list|(
name|buf
argument_list|,
literal|128
argument_list|,
name|v
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sz
operator|=
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
operator|!=
name|cp1
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
expr_stmt|;
block|}
comment|/* Make another chunk get added. */
name|n
operator|=
name|evbuffer_reserve_space
argument_list|(
name|buf
argument_list|,
name|sz
operator|+
literal|128
argument_list|,
name|v
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sz
operator|=
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
operator|+
name|v
index|[
literal|1
index|]
operator|.
name|iov_len
expr_stmt|;
name|tt_int_op
argument_list|(
name|sz
argument_list|,
operator|>=
argument_list|,
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
operator|+
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_data
condition|)
block|{
name|tt_assert
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
operator|==
name|cp1
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_assert
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
operator|==
name|cp1
argument_list|)
expr_stmt|;
block|}
name|cp1
operator|=
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
expr_stmt|;
name|cp2
operator|=
name|v
index|[
literal|1
index|]
operator|.
name|iov_base
expr_stmt|;
comment|/* And a third chunk. */
name|n
operator|=
name|evbuffer_reserve_space
argument_list|(
name|buf
argument_list|,
name|sz
operator|+
literal|128
argument_list|,
name|v
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n
argument_list|,
operator|==
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|cp1
operator|==
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|cp2
operator|==
name|v
index|[
literal|1
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
name|sz
operator|=
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
operator|+
name|v
index|[
literal|1
index|]
operator|.
name|iov_len
operator|+
name|v
index|[
literal|2
index|]
operator|.
name|iov_len
expr_stmt|;
comment|/* Now force a reallocation by asking for more space in only 2 	 * buffers. */
name|n
operator|=
name|evbuffer_reserve_space
argument_list|(
name|buf
argument_list|,
name|sz
operator|+
literal|128
argument_list|,
name|v
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_data
condition|)
block|{
name|tt_int_op
argument_list|(
name|n
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|cp1
operator|==
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_int_op
argument_list|(
name|n
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|end
label|:
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_expand
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|char
name|data
index|[
literal|4096
index|]
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|buf
decl_stmt|;
name|size_t
name|a
decl_stmt|,
name|w
decl_stmt|,
name|u
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|'X'
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure that expand() works on an empty buffer */
name|buf
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_expand
argument_list|(
name|buf
argument_list|,
literal|20000
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|a
operator|=
name|w
operator|=
name|u
operator|=
literal|0
expr_stmt|;
name|evbuffer_get_waste
argument_list|(
name|buf
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|w
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|w
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|u
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|a
operator|>=
literal|20000
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
operator|->
name|first
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
operator|->
name|first
operator|==
name|buf
operator|->
name|last
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
operator|->
name|first
operator|->
name|off
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
operator|->
name|first
operator|->
name|buffer_len
operator|>=
literal|20000
argument_list|)
expr_stmt|;
comment|/* Make sure that expand() works as a no-op when there's enough 	 * contiguous space already. */
name|buffer
operator|=
name|buf
operator|->
name|first
operator|->
name|buffer
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
name|data
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_expand
argument_list|(
name|buf
argument_list|,
literal|1024
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
operator|->
name|first
operator|->
name|buffer
operator|==
name|buffer
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Make sure that expand() can work by moving misaligned data 	 * when it makes sense to do so. */
name|buf
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
name|data
argument_list|,
literal|400
argument_list|)
expr_stmt|;
block|{
name|int
name|n
init|=
call|(
name|int
call|)
argument_list|(
name|buf
operator|->
name|first
operator|->
name|buffer_len
operator|-
name|buf
operator|->
name|first
operator|->
name|off
operator|-
literal|1
argument_list|)
decl_stmt|;
name|tt_assert
argument_list|(
name|n
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
name|data
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|tt_assert
argument_list|(
name|buf
operator|->
name|first
operator|==
name|buf
operator|->
name|last
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
operator|->
name|first
operator|->
name|off
operator|==
name|buf
operator|->
name|first
operator|->
name|buffer_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|buf
argument_list|,
name|buf
operator|->
name|first
operator|->
name|off
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
literal|1
operator|==
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
operator|->
name|first
operator|->
name|misalign
operator|>
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
operator|->
name|first
operator|->
name|off
operator|==
literal|1
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|buf
operator|->
name|first
operator|->
name|buffer
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_expand
argument_list|(
name|buf
argument_list|,
literal|40
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
operator|->
name|first
operator|==
name|buf
operator|->
name|last
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
operator|->
name|first
operator|->
name|off
operator|==
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
operator|->
name|first
operator|->
name|buffer
operator|==
name|buffer
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
operator|->
name|first
operator|->
name|misalign
operator|==
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* add, expand, pull-up: This used to crash libevent. */
name|buf
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|evbuffer_expand
argument_list|(
name|buf
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|evbuffer_pullup
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|end
label|:
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|reference_cb_called
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|reference_cb
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
modifier|*
name|extra
parameter_list|)
block|{
name|tt_str_op
argument_list|(
name|data
argument_list|,
operator|==
argument_list|,
literal|"this is what we add as read-only memory."
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|len
argument_list|,
operator|==
argument_list|,
name|strlen
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
name|extra
operator|==
operator|(
name|void
operator|*
operator|)
literal|0xdeadaffe
argument_list|)
expr_stmt|;
operator|++
name|reference_cb_called
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_reference
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|src
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|dst
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|struct
name|evbuffer_iovec
name|v
index|[
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
init|=
literal|"this is what we add as read-only memory."
decl_stmt|;
name|reference_cb_called
operator|=
literal|0
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_add_reference
argument_list|(
name|src
argument_list|,
name|data
argument_list|,
name|strlen
argument_list|(
name|data
argument_list|)
argument_list|,
name|reference_cb
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0xdeadaffe
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_reserve_space
argument_list|(
name|dst
argument_list|,
name|strlen
argument_list|(
name|data
argument_list|)
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_remove
argument_list|(
name|src
argument_list|,
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|,
literal|10
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|dst
argument_list|)
expr_stmt|;
comment|/* make sure that we don't write data at the beginning */
name|evbuffer_prepend
argument_list|(
name|src
argument_list|,
literal|"aaaaa"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|src
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_remove
argument_list|(
name|src
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
operator|)
operator|)
operator|+
literal|10
argument_list|,
name|strlen
argument_list|(
name|data
argument_list|)
operator|-
literal|10
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|evbuffer_commit_space
argument_list|(
name|dst
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|reference_cb_called
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|memcmp
argument_list|(
name|evbuffer_pullup
argument_list|(
name|dst
argument_list|,
name|strlen
argument_list|(
name|data
argument_list|)
argument_list|)
argument_list|,
name|data
argument_list|,
name|strlen
argument_list|(
name|data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|end
label|:
name|evbuffer_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|evbuffer_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|event_base
modifier|*
name|addfile_test_event_base
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|addfile_test_done_writing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|addfile_test_total_written
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|addfile_test_total_read
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|addfile_test_writecb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|b
init|=
name|arg
decl_stmt|;
name|int
name|r
decl_stmt|;
name|evbuffer_validate
argument_list|(
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
name|evbuffer_get_length
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|r
operator|=
name|evbuffer_write
argument_list|(
name|b
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
literal|0
condition|)
block|{
name|addfile_test_total_written
operator|+=
name|r
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"Wrote %d/%d bytes"
operator|,
name|r
operator|,
name|addfile_test_total_written
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|e
init|=
name|evutil_socket_geterror
argument_list|(
name|fd
argument_list|)
decl_stmt|;
if|if
condition|(
name|EVUTIL_ERR_RW_RETRIABLE
argument_list|(
name|e
argument_list|)
condition|)
return|return;
name|tt_fail_perror
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
name|event_base_loopexit
argument_list|(
name|addfile_test_event_base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|evbuffer_validate
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|addfile_test_done_writing
operator|=
literal|1
expr_stmt|;
return|return;
name|end
label|:
name|event_base_loopexit
argument_list|(
name|addfile_test_event_base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|addfile_test_readcb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|b
init|=
name|arg
decl_stmt|;
name|int
name|e
decl_stmt|,
name|r
init|=
literal|0
decl_stmt|;
do|do
block|{
name|r
operator|=
name|evbuffer_read
argument_list|(
name|b
argument_list|,
name|fd
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
literal|0
condition|)
block|{
name|addfile_test_total_read
operator|+=
name|r
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"Read %d/%d bytes"
operator|,
name|r
operator|,
name|addfile_test_total_read
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|r
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|e
operator|=
name|evutil_socket_geterror
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EVUTIL_ERR_RW_RETRIABLE
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|tt_fail_perror
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
name|event_base_loopexit
argument_list|(
name|addfile_test_event_base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|addfile_test_done_writing
operator|&&
name|addfile_test_total_read
operator|>=
name|addfile_test_total_written
condition|)
block|{
name|event_base_loopexit
argument_list|(
name|addfile_test_event_base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_add_file
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|testdata
init|=
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|impl
init|=
name|testdata
operator|->
name|setup_data
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|src
init|=
name|evbuffer_new
argument_list|()
decl_stmt|,
modifier|*
name|dest
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|char
modifier|*
name|tmpfilename
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|expect_data
decl_stmt|;
name|size_t
name|datalen
decl_stmt|,
name|expect_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|compare
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|want_ismapping
init|=
operator|-
literal|1
decl_stmt|,
name|want_cansendfile
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|use_segment
init|=
literal|1
decl_stmt|,
name|use_bigfile
init|=
literal|0
decl_stmt|,
name|map_from_offset
init|=
literal|0
decl_stmt|,
name|view_from_offset
init|=
literal|0
decl_stmt|;
name|struct
name|evbuffer_file_segment
modifier|*
name|seg
init|=
name|NULL
decl_stmt|;
name|ev_off_t
name|starting_offset
init|=
literal|0
decl_stmt|,
name|mapping_len
init|=
operator|-
literal|1
decl_stmt|;
name|ev_off_t
name|segment_offset
init|=
literal|0
decl_stmt|,
name|segment_len
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|event
modifier|*
name|rev
init|=
name|NULL
decl_stmt|,
modifier|*
name|wev
init|=
name|NULL
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|testdata
operator|->
name|base
decl_stmt|;
name|evutil_socket_t
name|pair
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|struct
name|evutil_weakrand_state
name|seed
init|=
block|{
literal|123456789U
block|}
decl_stmt|;
comment|/* This test is highly parameterized based on substrings of its 	 * argument.  The strings are: */
name|tt_assert
argument_list|(
name|impl
argument_list|)
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|impl
argument_list|,
literal|"nosegment"
argument_list|)
condition|)
block|{
comment|/* If nosegment is set, use the older evbuffer_add_file 		 * interface */
name|use_segment
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|impl
argument_list|,
literal|"bigfile"
argument_list|)
condition|)
block|{
comment|/* If bigfile is set, use a 512K file.  Else use a smaller 		 * one. */
name|use_bigfile
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|impl
argument_list|,
literal|"map_offset"
argument_list|)
condition|)
block|{
comment|/* If map_offset is set, we build the file segment starting 		 * from a point other than byte 0 and ending somewhere other 		 * than the last byte.  Otherwise we map the whole thing */
name|map_from_offset
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|impl
argument_list|,
literal|"offset_in_segment"
argument_list|)
condition|)
block|{
comment|/* If offset_in_segment is set, we add a subsection of the 		 * file semgment starting from a point other than byte 0 of 		 * the segment. */
name|view_from_offset
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|impl
argument_list|,
literal|"sendfile"
argument_list|)
condition|)
block|{
comment|/* If sendfile is set, we try to use a sendfile/splice style 		 * backend. */
name|flags
operator|=
name|EVBUF_FS_DISABLE_MMAP
expr_stmt|;
name|want_cansendfile
operator|=
literal|1
expr_stmt|;
name|want_ismapping
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|impl
argument_list|,
literal|"mmap"
argument_list|)
condition|)
block|{
comment|/* If sendfile is set, we try to use a mmap/CreateFileMapping 		 * style backend. */
name|flags
operator|=
name|EVBUF_FS_DISABLE_SENDFILE
expr_stmt|;
name|want_ismapping
operator|=
literal|1
expr_stmt|;
name|want_cansendfile
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|impl
argument_list|,
literal|"linear"
argument_list|)
condition|)
block|{
comment|/* If linear is set, we try to use a read-the-whole-thing 		 * backend. */
name|flags
operator|=
name|EVBUF_FS_DISABLE_SENDFILE
operator||
name|EVBUF_FS_DISABLE_MMAP
expr_stmt|;
name|want_ismapping
operator|=
literal|0
expr_stmt|;
name|want_cansendfile
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|impl
argument_list|,
literal|"default"
argument_list|)
condition|)
block|{
comment|/* The caller doesn't care which backend we use. */
empty_stmt|;
block|}
else|else
block|{
comment|/* The caller must choose a backend. */
name|TT_DIE
argument_list|(
operator|(
literal|"Didn't recognize the implementation"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use_bigfile
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|datalen
operator|=
literal|1024
operator|*
literal|512
expr_stmt|;
name|data
operator|=
name|malloc
argument_list|(
literal|1024
operator|*
literal|512
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|data
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|datalen
condition|;
operator|++
name|i
control|)
name|data
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|evutil_weakrand_
argument_list|(
operator|&
name|seed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|strdup
argument_list|(
literal|"here is a relatively small string."
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|strlen
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
name|fd
operator|=
name|regress_make_tmpfile
argument_list|(
name|data
argument_list|,
name|datalen
argument_list|,
operator|&
name|tmpfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_from_offset
condition|)
block|{
name|starting_offset
operator|=
name|datalen
operator|/
literal|4
operator|+
literal|1
expr_stmt|;
name|mapping_len
operator|=
name|datalen
operator|/
literal|2
operator|-
literal|1
expr_stmt|;
name|expect_data
operator|=
name|data
operator|+
name|starting_offset
expr_stmt|;
name|expect_len
operator|=
name|mapping_len
expr_stmt|;
block|}
else|else
block|{
name|expect_data
operator|=
name|data
expr_stmt|;
name|expect_len
operator|=
name|datalen
expr_stmt|;
block|}
if|if
condition|(
name|view_from_offset
condition|)
block|{
name|tt_assert
argument_list|(
name|use_segment
argument_list|)
expr_stmt|;
comment|/* Can't do this with add_file*/
name|segment_offset
operator|=
name|expect_len
operator|/
literal|3
expr_stmt|;
name|segment_len
operator|=
name|expect_len
operator|/
literal|2
expr_stmt|;
name|expect_data
operator|=
name|expect_data
operator|+
name|segment_offset
expr_stmt|;
name|expect_len
operator|=
name|segment_len
expr_stmt|;
block|}
if|if
condition|(
name|use_segment
condition|)
block|{
name|seg
operator|=
name|evbuffer_file_segment_new
argument_list|(
name|fd
argument_list|,
name|starting_offset
argument_list|,
name|mapping_len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_ismapping
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|seg
operator|->
name|is_mapping
operator|!=
operator|(
name|unsigned
operator|)
name|want_ismapping
condition|)
name|tt_skip
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|want_cansendfile
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|seg
operator|->
name|can_sendfile
operator|!=
operator|(
name|unsigned
operator|)
name|want_cansendfile
condition|)
name|tt_skip
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Say that it drains to a fd so that we can use sendfile. */
name|evbuffer_set_flags
argument_list|(
name|src
argument_list|,
name|EVBUFFER_FLAG_DRAINS_TO_FD
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_SENDFILE
argument_list|)
operator|&&
name|defined
argument_list|(
name|__sun__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__svr4__
argument_list|)
comment|/* We need to use a pair of AF_INET sockets, since Solaris 	   doesn't support sendfile() over AF_UNIX. */
if|if
condition|(
name|evutil_ersatz_socketpair_
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|pair
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|tt_abort_msg
argument_list|(
literal|"ersatz_socketpair failed"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|evutil_socketpair
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|pair
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|tt_abort_msg
argument_list|(
literal|"socketpair failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|evutil_make_socket_nonblocking
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|evutil_make_socket_nonblocking
argument_list|(
name|pair
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|fd
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_segment
condition|)
block|{
name|tt_assert
argument_list|(
name|evbuffer_add_file_segment
argument_list|(
name|src
argument_list|,
name|seg
argument_list|,
name|segment_offset
argument_list|,
name|segment_len
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_assert
argument_list|(
name|evbuffer_add_file
argument_list|(
name|src
argument_list|,
name|fd
argument_list|,
name|starting_offset
argument_list|,
name|mapping_len
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|evbuffer_validate
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|addfile_test_event_base
operator|=
name|base
expr_stmt|;
name|wev
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|pair
index|[
literal|0
index|]
argument_list|,
name|EV_WRITE
operator||
name|EV_PERSIST
argument_list|,
name|addfile_test_writecb
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|rev
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
name|addfile_test_readcb
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|wev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|rev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|addfile_test_done_writing
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|addfile_test_total_written
argument_list|,
operator|==
argument_list|,
name|expect_len
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|addfile_test_total_read
argument_list|,
operator|==
argument_list|,
name|expect_len
argument_list|)
expr_stmt|;
name|compare
operator|=
operator|(
name|char
operator|*
operator|)
name|evbuffer_pullup
argument_list|(
name|dest
argument_list|,
name|expect_len
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|compare
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|compare
argument_list|,
name|expect_data
argument_list|,
name|expect_len
argument_list|)
condition|)
block|{
name|tt_abort_msg
argument_list|(
literal|"Data from add_file differs."
argument_list|)
expr_stmt|;
block|}
name|evbuffer_validate
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|data
condition|)
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
condition|)
name|evbuffer_file_segment_free
argument_list|(
name|seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
condition|)
name|evbuffer_free
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
condition|)
name|evbuffer_free
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
name|evutil_closesocket
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
index|[
literal|1
index|]
operator|>=
literal|0
condition|)
name|evutil_closesocket
argument_list|(
name|pair
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfilename
condition|)
block|{
name|unlink
argument_list|(
name|tmpfilename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmpfilename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|file_segment_cleanup_cb_called_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|evbuffer_file_segment
specifier|const
modifier|*
name|file_segment_cleanup_cb_called_with
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|file_segment_cleanup_cb_called_with_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|file_segment_cleanup_cb_called_with_arg
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|file_segment_cleanup_cp
parameter_list|(
name|struct
name|evbuffer_file_segment
specifier|const
modifier|*
name|seg
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
operator|++
name|file_segment_cleanup_cb_called_count
expr_stmt|;
name|file_segment_cleanup_cb_called_with
operator|=
name|seg
expr_stmt|;
name|file_segment_cleanup_cb_called_with_flags
operator|=
name|flags
expr_stmt|;
name|file_segment_cleanup_cb_called_with_arg
operator|=
name|arg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_file_segment_add_cleanup_cb
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|char
modifier|*
name|tmpfilename
init|=
name|NULL
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|evb
init|=
name|NULL
decl_stmt|;
name|struct
name|evbuffer_file_segment
modifier|*
name|seg
init|=
name|NULL
decl_stmt|,
modifier|*
name|segptr
decl_stmt|;
name|char
specifier|const
modifier|*
name|arg
init|=
literal|"token"
decl_stmt|;
name|fd
operator|=
name|regress_make_tmpfile
argument_list|(
literal|"file_segment_test_file"
argument_list|,
literal|22
argument_list|,
operator|&
name|tmpfilename
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|fd
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evb
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|segptr
operator|=
name|seg
operator|=
name|evbuffer_file_segment_new
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|seg
argument_list|)
expr_stmt|;
name|evbuffer_file_segment_add_cleanup_cb
argument_list|(
name|seg
argument_list|,
operator|&
name|file_segment_cleanup_cp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|fd
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_add_file_segment
argument_list|(
name|evb
argument_list|,
name|seg
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|file_segment_cleanup_cb_called_count
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_file_segment_free
argument_list|(
name|seg
argument_list|)
expr_stmt|;
name|seg
operator|=
name|NULL
expr_stmt|;
comment|/* Prevent double-free. */
name|tt_int_op
argument_list|(
name|file_segment_cleanup_cb_called_count
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_free
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evb
operator|=
name|NULL
expr_stmt|;
comment|/* pevent double-free */
name|tt_int_op
argument_list|(
name|file_segment_cleanup_cb_called_count
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|file_segment_cleanup_cb_called_with
operator|==
name|segptr
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|file_segment_cleanup_cb_called_with_flags
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|file_segment_cleanup_cb_called_with_arg
operator|==
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|evb
condition|)
name|evbuffer_free
argument_list|(
name|evb
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
condition|)
name|evbuffer_file_segment_free
argument_list|(
name|seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfilename
condition|)
block|{
name|unlink
argument_list|(
name|tmpfilename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmpfilename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|EVENT__DISABLE_MM_REPLACEMENT
end_ifndef

begin_function
specifier|static
name|void
modifier|*
name|failing_malloc
parameter_list|(
name|size_t
name|how_much
parameter_list|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|test_evbuffer_readln
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|evb
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|evb_tmp
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
define|#
directive|define
name|tt_line_eq
parameter_list|(
name|content
parameter_list|)
define|\
value|TT_STMT_BEGIN							\ 	if (!cp || sz != strlen(content) || strcmp(cp, content)) {	\ 		TT_DIE(("Wanted %s; got %s [%d]", content, cp, (int)sz)); \ 	}								\ 	TT_STMT_END
comment|/* Test EOL_ANY. */
name|s
operator|=
literal|"complex silly newline\r\n\n\r\n\n\rmore\0\n"
expr_stmt|;
name|evbuffer_add
argument_list|(
name|evb
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_ANY
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|"complex silly newline"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
operator|||
name|sz
operator|!=
literal|5
operator|||
name|memcmp
argument_list|(
name|cp
argument_list|,
literal|"more\0\0"
argument_list|,
literal|6
argument_list|)
condition|)
name|tt_abort_msg
argument_list|(
literal|"Not as expected"
argument_list|)
expr_stmt|;
name|tt_uint_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|evb
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"\nno newline"
expr_stmt|;
name|evbuffer_add
argument_list|(
name|evb
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_ANY
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_ANY
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|evb
argument_list|,
name|evbuffer_get_length
argument_list|(
name|evb
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_get_length
argument_list|(
name|evb
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
comment|/* Test EOL_CRLF */
name|s
operator|=
literal|"Line with\rin the middle\nLine with good crlf\r\n\nfinal\n"
expr_stmt|;
name|evbuffer_add
argument_list|(
name|evb
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_CRLF
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|"Line with\rin the middle"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_CRLF
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|"Line with good crlf"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_CRLF
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_CRLF
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|"final"
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"x"
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|evb
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_CRLF
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
comment|/* Test CRLF_STRICT */
name|s
operator|=
literal|" and a bad crlf\nand a good one\r\n\r\nMore\r"
expr_stmt|;
name|evbuffer_add
argument_list|(
name|evb
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_CRLF_STRICT
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|"x and a bad crlf\nand a good one"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_CRLF_STRICT
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_CRLF_STRICT
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|evb
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_CRLF_STRICT
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|"More"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_get_length
argument_list|(
name|evb
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"An internal CR\r is not an eol\r\nNor is a lack of one"
expr_stmt|;
name|evbuffer_add
argument_list|(
name|evb
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_CRLF_STRICT
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|"An internal CR\r is not an eol"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_CRLF_STRICT
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|evb
argument_list|,
literal|"\r\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_CRLF_STRICT
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|"Nor is a lack of one"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_get_length
argument_list|(
name|evb
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
comment|/* Test LF */
name|s
operator|=
literal|"An\rand a nl\n\nText"
expr_stmt|;
name|evbuffer_add
argument_list|(
name|evb
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_LF
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|"An\rand a nl"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_LF
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_LF
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|evb
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_LF
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|"Text"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
comment|/* Test NUL */
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|evb
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|char
name|x
index|[]
init|=
literal|"NUL\n\0\0"
literal|"The all-zeros character which may serve\0"
literal|"to accomplish time fill\0and media fill"
decl_stmt|;
comment|/* Add all but the final NUL of x. */
name|evbuffer_add
argument_list|(
name|evb
argument_list|,
name|x
argument_list|,
sizeof|sizeof
argument_list|(
name|x
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_NUL
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|"NUL\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_NUL
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_NUL
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|"The all-zeros character which may serve"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_NUL
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|"to accomplish time fill"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_NUL
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|cp
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|evb
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Test CRLF_STRICT - across boundaries*/
name|s
operator|=
literal|" and a bad crlf\nand a good one\r"
expr_stmt|;
name|evbuffer_add
argument_list|(
name|evb_tmp
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_add_buffer
argument_list|(
name|evb
argument_list|,
name|evb_tmp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"\n\r"
expr_stmt|;
name|evbuffer_add
argument_list|(
name|evb_tmp
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_add_buffer
argument_list|(
name|evb
argument_list|,
name|evb_tmp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"\nMore\r"
expr_stmt|;
name|evbuffer_add
argument_list|(
name|evb_tmp
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_add_buffer
argument_list|(
name|evb
argument_list|,
name|evb_tmp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_CRLF_STRICT
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|" and a bad crlf\nand a good one"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_CRLF_STRICT
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_CRLF_STRICT
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|evb
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_CRLF_STRICT
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|"More"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|NULL
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_get_length
argument_list|(
name|evb
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Test memory problem*/
name|s
operator|=
literal|"one line\ntwo line\nblue line"
expr_stmt|;
name|evbuffer_add
argument_list|(
name|evb_tmp
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_add_buffer
argument_list|(
name|evb
argument_list|,
name|evb_tmp
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_LF
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|"one line"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|NULL
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
comment|/* the next call to readline should fail */
ifndef|#
directive|ifndef
name|EVENT__DISABLE_MM_REPLACEMENT
name|event_set_mem_functions
argument_list|(
name|failing_malloc
argument_list|,
name|realloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_LF
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|cp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
comment|/* now we should get the next line back */
name|event_set_mem_functions
argument_list|(
name|malloc
argument_list|,
name|realloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|evb
argument_list|,
operator|&
name|sz
argument_list|,
name|EVBUFFER_EOL_LF
argument_list|)
expr_stmt|;
name|tt_line_eq
argument_list|(
literal|"two line"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|NULL
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|end
label|:
name|evbuffer_free
argument_list|(
name|evb
argument_list|)
expr_stmt|;
name|evbuffer_free
argument_list|(
name|evb_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_search_eol
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|buf
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|struct
name|evbuffer_ptr
name|ptr1
decl_stmt|,
name|ptr2
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|eol_len
decl_stmt|;
name|s
operator|=
literal|"string! \r\n\r\nx\n"
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|eol_len
operator|=
operator|-
literal|1
expr_stmt|;
name|ptr1
operator|=
name|evbuffer_search_eol
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
operator|&
name|eol_len
argument_list|,
name|EVBUFFER_EOL_CRLF
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ptr1
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|eol_len
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|eol_len
operator|=
operator|-
literal|1
expr_stmt|;
name|ptr2
operator|=
name|evbuffer_search_eol
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr1
argument_list|,
operator|&
name|eol_len
argument_list|,
name|EVBUFFER_EOL_CRLF
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ptr2
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|eol_len
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr1
argument_list|,
literal|1
argument_list|,
name|EVBUFFER_PTR_ADD
argument_list|)
expr_stmt|;
name|eol_len
operator|=
operator|-
literal|1
expr_stmt|;
name|ptr2
operator|=
name|evbuffer_search_eol
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr1
argument_list|,
operator|&
name|eol_len
argument_list|,
name|EVBUFFER_EOL_CRLF
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ptr2
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|eol_len
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|eol_len
operator|=
operator|-
literal|1
expr_stmt|;
name|ptr2
operator|=
name|evbuffer_search_eol
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr1
argument_list|,
operator|&
name|eol_len
argument_list|,
name|EVBUFFER_EOL_CRLF_STRICT
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ptr2
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|eol_len
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|eol_len
operator|=
operator|-
literal|1
expr_stmt|;
name|ptr1
operator|=
name|evbuffer_search_eol
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
operator|&
name|eol_len
argument_list|,
name|EVBUFFER_EOL_LF
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ptr1
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|eol_len
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|eol_len
operator|=
operator|-
literal|1
expr_stmt|;
name|ptr2
operator|=
name|evbuffer_search_eol
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr1
argument_list|,
operator|&
name|eol_len
argument_list|,
name|EVBUFFER_EOL_LF
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ptr2
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|eol_len
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr1
argument_list|,
literal|1
argument_list|,
name|EVBUFFER_PTR_ADD
argument_list|)
expr_stmt|;
name|eol_len
operator|=
operator|-
literal|1
expr_stmt|;
name|ptr2
operator|=
name|evbuffer_search_eol
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr1
argument_list|,
operator|&
name|eol_len
argument_list|,
name|EVBUFFER_EOL_LF
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ptr2
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|eol_len
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr1
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|eol_len
operator|=
operator|-
literal|1
expr_stmt|;
name|ptr2
operator|=
name|evbuffer_search_eol
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr1
argument_list|,
operator|&
name|eol_len
argument_list|,
name|EVBUFFER_EOL_LF
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ptr2
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|eol_len
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end
label|:
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_iterative
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|buf
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|abc
init|=
literal|"abcdefghijklmnopqrstvuwxyzabcdefghijklmnopqrstvuwxyzabcdefghijklmnopqrstvuwxyzabcdefghijklmnopqrstvuwxyz"
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|,
name|sum
decl_stmt|,
name|n
decl_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|strlen
argument_list|(
name|abc
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
name|char
name|format
index|[
literal|32
index|]
decl_stmt|;
name|evutil_snprintf
argument_list|(
name|format
argument_list|,
sizeof|sizeof
argument_list|(
name|format
argument_list|)
argument_list|,
literal|"%%%u.%us"
argument_list|,
name|j
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|evbuffer_add_printf
argument_list|(
name|buf
argument_list|,
name|format
argument_list|,
name|abc
argument_list|)
expr_stmt|;
comment|/* Only check for rep violations every so often. 			   Walking over the whole list of chains can get 			   pretty expensive as it gets long. 			 */
if|if
condition|(
operator|(
name|n
operator|%
literal|337
operator|)
operator|==
literal|0
condition|)
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sum
operator|+=
name|j
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|tt_uint_op
argument_list|(
name|sum
argument_list|,
operator|==
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|size_t
name|a
decl_stmt|,
name|w
decl_stmt|,
name|u
decl_stmt|;
name|a
operator|=
name|w
operator|=
name|u
operator|=
literal|0
expr_stmt|;
name|evbuffer_get_waste
argument_list|(
name|buf
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|w
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
name|printf
argument_list|(
literal|"Allocated: %u.\nWasted: %u.\nUsed: %u."
argument_list|,
operator|(
name|unsigned
operator|)
name|a
argument_list|,
operator|(
name|unsigned
operator|)
name|w
argument_list|,
operator|(
name|unsigned
operator|)
name|u
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|(
operator|(
name|double
operator|)
name|w
operator|)
operator|/
name|a
operator|<
literal|.125
argument_list|)
expr_stmt|;
block|}
name|end
label|:
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_find
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|u_char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|test1
init|=
literal|"1234567890\r\n"
decl_stmt|;
specifier|const
name|char
modifier|*
name|test2
init|=
literal|"1234567890\r"
decl_stmt|;
define|#
directive|define
name|EVBUFFER_INITIAL_LENGTH
value|256
name|char
name|test3
index|[
name|EVBUFFER_INITIAL_LENGTH
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|buf
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|tt_assert
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* make sure evbuffer_find doesn't match past the end of the buffer */
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|test1
argument_list|,
name|strlen
argument_list|(
name|test1
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|test1
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|test2
argument_list|,
name|strlen
argument_list|(
name|test2
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|evbuffer_find
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|"\r\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * drain the buffer and do another find; in r309 this would 	 * read past the allocated buffer causing a valgrind error. 	 */
name|evbuffer_drain
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|test2
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EVBUFFER_INITIAL_LENGTH
condition|;
operator|++
name|i
control|)
name|test3
index|[
name|i
index|]
operator|=
literal|'a'
expr_stmt|;
name|test3
index|[
name|EVBUFFER_INITIAL_LENGTH
operator|-
literal|1
index|]
operator|=
literal|'x'
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|test3
argument_list|,
name|EVBUFFER_INITIAL_LENGTH
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|evbuffer_find
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|"xy"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* simple test for match at end of allocated buffer */
name|p
operator|=
name|evbuffer_find
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|"ax"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
literal|"ax"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|buf
condition|)
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_ptr_set
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|buf
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|struct
name|evbuffer_ptr
name|pos
decl_stmt|;
name|struct
name|evbuffer_iovec
name|v
index|[
literal|1
index|]
decl_stmt|;
name|tt_assert
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|0
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|pos
operator|.
name|pos
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|1
argument_list|,
name|EVBUFFER_PTR_ADD
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|pos
operator|.
name|pos
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|1
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|pos
operator|.
name|pos
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* create some chains */
name|evbuffer_reserve_space
argument_list|(
name|buf
argument_list|,
literal|5000
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
literal|5000
expr_stmt|;
name|memset
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|,
literal|1
argument_list|,
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|evbuffer_commit_space
argument_list|(
name|buf
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|evbuffer_reserve_space
argument_list|(
name|buf
argument_list|,
literal|4000
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
literal|4000
expr_stmt|;
name|memset
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|,
literal|2
argument_list|,
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|evbuffer_commit_space
argument_list|(
name|buf
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_reserve_space
argument_list|(
name|buf
argument_list|,
literal|3000
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
literal|3000
expr_stmt|;
name|memset
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|,
literal|3
argument_list|,
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|evbuffer_commit_space
argument_list|(
name|buf
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|12000
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|13000
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|pos
operator|.
name|pos
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|0
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|pos
operator|.
name|pos
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|13000
argument_list|,
name|EVBUFFER_PTR_ADD
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|0
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|pos
operator|.
name|pos
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|10000
argument_list|,
name|EVBUFFER_PTR_ADD
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|pos
operator|.
name|pos
operator|==
literal|10000
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|1000
argument_list|,
name|EVBUFFER_PTR_ADD
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|pos
operator|.
name|pos
operator|==
literal|11000
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|1000
argument_list|,
name|EVBUFFER_PTR_ADD
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|pos
operator|.
name|pos
operator|==
literal|12000
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|1000
argument_list|,
name|EVBUFFER_PTR_ADD
argument_list|)
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|pos
operator|.
name|pos
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|buf
condition|)
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_search
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|buf
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|tmp
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|struct
name|evbuffer_ptr
name|pos
decl_stmt|,
name|end
decl_stmt|;
name|tt_assert
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search
argument_list|(
name|buf
argument_list|,
literal|"x"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|0
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search
argument_list|(
name|buf
argument_list|,
literal|"x"
argument_list|,
literal|1
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|0
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search_range
argument_list|(
name|buf
argument_list|,
literal|"x"
argument_list|,
literal|1
argument_list|,
operator|&
name|pos
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|0
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search_range
argument_list|(
name|buf
argument_list|,
literal|"x"
argument_list|,
literal|1
argument_list|,
operator|&
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* set up our chains */
name|evbuffer_add_printf
argument_list|(
name|tmp
argument_list|,
literal|"hello"
argument_list|)
expr_stmt|;
comment|/* 5 chars */
name|evbuffer_add_buffer
argument_list|(
name|buf
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|evbuffer_add_printf
argument_list|(
name|tmp
argument_list|,
literal|"foo"
argument_list|)
expr_stmt|;
comment|/* 3 chars */
name|evbuffer_add_buffer
argument_list|(
name|buf
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|evbuffer_add_printf
argument_list|(
name|tmp
argument_list|,
literal|"cat"
argument_list|)
expr_stmt|;
comment|/* 3 chars */
name|evbuffer_add_buffer
argument_list|(
name|buf
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|evbuffer_add_printf
argument_list|(
name|tmp
argument_list|,
literal|"attack"
argument_list|)
expr_stmt|;
name|evbuffer_add_buffer
argument_list|(
name|buf
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search
argument_list|(
name|buf
argument_list|,
literal|"attack"
argument_list|,
literal|6
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search
argument_list|(
name|buf
argument_list|,
literal|"attacker"
argument_list|,
literal|8
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* test continuing search */
name|pos
operator|=
name|evbuffer_search
argument_list|(
name|buf
argument_list|,
literal|"oc"
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search
argument_list|(
name|buf
argument_list|,
literal|"cat"
argument_list|,
literal|3
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search
argument_list|(
name|buf
argument_list|,
literal|"tacking"
argument_list|,
literal|7
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|5
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search
argument_list|(
name|buf
argument_list|,
literal|"foo"
argument_list|,
literal|3
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|2
argument_list|,
name|EVBUFFER_PTR_ADD
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search
argument_list|(
name|buf
argument_list|,
literal|"tat"
argument_list|,
literal|3
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* test bounded search. */
comment|/* Set "end" to the first t in "attack". */
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|end
argument_list|,
literal|12
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search_range
argument_list|(
name|buf
argument_list|,
literal|"foo"
argument_list|,
literal|3
argument_list|,
name|NULL
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search_range
argument_list|(
name|buf
argument_list|,
literal|"foocata"
argument_list|,
literal|7
argument_list|,
name|NULL
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search_range
argument_list|(
name|buf
argument_list|,
literal|"foocatat"
argument_list|,
literal|8
argument_list|,
name|NULL
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search_range
argument_list|(
name|buf
argument_list|,
literal|"ack"
argument_list|,
literal|3
argument_list|,
name|NULL
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Set "end" after the last byte in the buffer. */
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|end
argument_list|,
literal|17
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search_range
argument_list|(
name|buf
argument_list|,
literal|"attack"
argument_list|,
literal|6
argument_list|,
name|NULL
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|11
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search_range
argument_list|(
name|buf
argument_list|,
literal|"attack"
argument_list|,
literal|6
argument_list|,
operator|&
name|pos
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|17
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search_range
argument_list|(
name|buf
argument_list|,
literal|"attack"
argument_list|,
literal|6
argument_list|,
operator|&
name|pos
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
literal|17
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
name|evbuffer_search_range
argument_list|(
name|buf
argument_list|,
literal|"attack"
argument_list|,
literal|6
argument_list|,
operator|&
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|pos
operator|.
name|pos
argument_list|,
operator|==
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|buf
condition|)
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|evbuffer_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|log_change_callback
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
specifier|const
name|struct
name|evbuffer_cb_info
modifier|*
name|cbinfo
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|size_t
name|old_len
init|=
name|cbinfo
operator|->
name|orig_size
decl_stmt|;
name|size_t
name|new_len
init|=
name|old_len
operator|+
name|cbinfo
operator|->
name|n_added
operator|-
name|cbinfo
operator|->
name|n_deleted
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|out
init|=
name|arg
decl_stmt|;
name|evbuffer_add_printf
argument_list|(
name|out
argument_list|,
literal|"%lu->%lu; "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|old_len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|new_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|self_draining_callback
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|evbuffer
parameter_list|,
name|size_t
name|old_len
parameter_list|,
name|size_t
name|new_len
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|new_len
operator|>
name|old_len
condition|)
name|evbuffer_drain
argument_list|(
name|evbuffer
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_callbacks
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|buf
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|buf_out1
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|buf_out2
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|struct
name|evbuffer_cb_entry
modifier|*
name|cb1
decl_stmt|,
modifier|*
name|cb2
decl_stmt|;
name|tt_assert
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|buf_out1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|buf_out2
argument_list|)
expr_stmt|;
name|cb1
operator|=
name|evbuffer_add_cb
argument_list|(
name|buf
argument_list|,
name|log_change_callback
argument_list|,
name|buf_out1
argument_list|)
expr_stmt|;
name|cb2
operator|=
name|evbuffer_add_cb
argument_list|(
name|buf
argument_list|,
name|log_change_callback
argument_list|,
name|buf_out2
argument_list|)
expr_stmt|;
comment|/* Let's run through adding and deleting some stuff from the buffer 	 * and turning the callbacks on and off and removing them.  The callback 	 * adds a summary of length changes to buf_out1/buf_out2 when called. */
comment|/* size: 0-> 36. */
name|evbuffer_add_printf
argument_list|(
name|buf
argument_list|,
literal|"The %d magic words are spotty pudding"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|evbuffer_cb_clear_flags
argument_list|(
name|buf
argument_list|,
name|cb2
argument_list|,
name|EVBUFFER_CB_ENABLED
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|buf
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/*36->26*/
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|evbuffer_prepend
argument_list|(
name|buf
argument_list|,
literal|"Hello"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/*26->31*/
name|evbuffer_cb_set_flags
argument_list|(
name|buf
argument_list|,
name|cb2
argument_list|,
name|EVBUFFER_CB_ENABLED
argument_list|)
expr_stmt|;
name|evbuffer_add_reference
argument_list|(
name|buf
argument_list|,
literal|"Goodbye"
argument_list|,
literal|7
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*31->38*/
name|evbuffer_remove_cb_entry
argument_list|(
name|buf
argument_list|,
name|cb1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|buf
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/*38->0*/
empty_stmt|;
name|tt_assert
argument_list|(
operator|-
literal|1
operator|==
name|evbuffer_remove_cb
argument_list|(
name|buf
argument_list|,
name|log_change_callback
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
literal|"X"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 0->1 */
name|tt_assert
argument_list|(
operator|!
name|evbuffer_remove_cb
argument_list|(
name|buf
argument_list|,
name|log_change_callback
argument_list|,
name|buf_out2
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|evbuffer_pullup
argument_list|(
name|buf_out1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|"0->36; 36->26; 26->31; 31->38; "
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|evbuffer_pullup
argument_list|(
name|buf_out2
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|"0->36; 31->38; 38->0; 0->1; "
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|buf_out1
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf_out1
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|buf_out2
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf_out2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Let's test the obsolete buffer_setcb function too. */
name|cb1
operator|=
name|evbuffer_add_cb
argument_list|(
name|buf
argument_list|,
name|log_change_callback
argument_list|,
name|buf_out1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|cb1
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cb2
operator|=
name|evbuffer_add_cb
argument_list|(
name|buf
argument_list|,
name|log_change_callback
argument_list|,
name|buf_out2
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|cb2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|evbuffer_setcb
argument_list|(
name|buf
argument_list|,
name|self_draining_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evbuffer_add_printf
argument_list|(
name|buf
argument_list|,
literal|"This should get drained right away."
argument_list|)
expr_stmt|;
name|tt_uint_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_uint_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf_out1
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_uint_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf_out2
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_setcb
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evbuffer_add_printf
argument_list|(
name|buf
argument_list|,
literal|"This will not."
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|evbuffer_pullup
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|"This will not."
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|buf
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Now let's try a suspended callback. */
block|cb1 = evbuffer_add_cb(buf, log_change_callback, buf_out1); 	cb2 = evbuffer_add_cb(buf, log_change_callback, buf_out2); 	evbuffer_cb_suspend(buf,cb2); 	evbuffer_prepend(buf,"Hello world",11);
comment|/*0->11*/
block|evbuffer_validate(buf); 	evbuffer_cb_suspend(buf,cb1); 	evbuffer_add(buf,"more",4);
comment|/* 11->15 */
block|evbuffer_cb_unsuspend(buf,cb2); 	evbuffer_drain(buf, 4);
comment|/* 15->11 */
block|evbuffer_cb_unsuspend(buf,cb1); 	evbuffer_drain(buf, evbuffer_get_length(buf));
comment|/* 11->0 */
block|tt_str_op(evbuffer_pullup(buf_out1, -1), ==, 		  "0->11; 11->11; 11->0; "); 	tt_str_op(evbuffer_pullup(buf_out2, -1), ==, 		  "0->15; 15->11; 11->0; ");
endif|#
directive|endif
name|end
label|:
if|if
condition|(
name|buf
condition|)
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_out1
condition|)
name|evbuffer_free
argument_list|(
name|buf_out1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_out2
condition|)
name|evbuffer_free
argument_list|(
name|buf_out2
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|ref_done_cb_called_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|ref_done_cb_called_with
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|void
modifier|*
name|ref_done_cb_called_with_data
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|ref_done_cb_called_with_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ref_done_cb
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
modifier|*
name|info
parameter_list|)
block|{
operator|++
name|ref_done_cb_called_count
expr_stmt|;
name|ref_done_cb_called_with
operator|=
name|info
expr_stmt|;
name|ref_done_cb_called_with_data
operator|=
name|data
expr_stmt|;
name|ref_done_cb_called_with_len
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_add_reference
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|char
name|chunk1
index|[]
init|=
literal|"If you have found the answer to such a problem"
decl_stmt|;
specifier|const
name|char
name|chunk2
index|[]
init|=
literal|"you ought to write it up for publication"
decl_stmt|;
comment|/* -- Knuth's "Notes on the Exercises" from TAOCP */
name|char
name|tmp
index|[
literal|16
index|]
decl_stmt|;
name|size_t
name|len1
init|=
name|strlen
argument_list|(
name|chunk1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|chunk2
argument_list|)
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|buf1
init|=
name|NULL
decl_stmt|,
modifier|*
name|buf2
init|=
name|NULL
decl_stmt|;
name|buf1
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|evbuffer_add_reference
argument_list|(
name|buf1
argument_list|,
name|chunk1
argument_list|,
name|len1
argument_list|,
name|ref_done_cb
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|111
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf1
argument_list|,
literal|", "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|evbuffer_add_reference
argument_list|(
name|buf1
argument_list|,
name|chunk2
argument_list|,
name|len2
argument_list|,
name|ref_done_cb
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|222
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf1
argument_list|)
argument_list|,
operator|==
argument_list|,
name|len1
operator|+
name|len2
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Make sure we can drain a little from a reference. */
name|tt_int_op
argument_list|(
name|evbuffer_remove
argument_list|(
name|buf1
argument_list|,
name|tmp
argument_list|,
literal|6
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|memcmp
argument_list|(
name|tmp
argument_list|,
literal|"If you"
argument_list|,
literal|6
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_remove
argument_list|(
name|buf1
argument_list|,
name|tmp
argument_list|,
literal|5
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|memcmp
argument_list|(
name|tmp
argument_list|,
literal|" have"
argument_list|,
literal|5
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure that prepending does not meddle with immutable data */
name|tt_int_op
argument_list|(
name|evbuffer_prepend
argument_list|(
name|buf1
argument_list|,
literal|"I have "
argument_list|,
literal|7
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|memcmp
argument_list|(
name|chunk1
argument_list|,
literal|"If you"
argument_list|,
literal|6
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
comment|/* Make sure that when the chunk is over, the callback is invoked. */
name|evbuffer_drain
argument_list|(
name|buf1
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* Remove prepended stuff. */
name|evbuffer_drain
argument_list|(
name|buf1
argument_list|,
name|len1
operator|-
literal|11
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* remove all but one byte of chunk1 */
name|tt_int_op
argument_list|(
name|ref_done_cb_called_count
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_remove
argument_list|(
name|buf1
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|,
operator|==
argument_list|,
literal|'m'
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ref_done_cb_called_with
operator|==
operator|(
name|void
operator|*
operator|)
literal|111
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ref_done_cb_called_with_data
operator|==
name|chunk1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ref_done_cb_called_with_len
operator|==
name|len1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ref_done_cb_called_count
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
comment|/* Drain some of the remaining chunk, then add it to another buffer */
name|evbuffer_drain
argument_list|(
name|buf1
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Remove the ", you ". */
name|buf2
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ref_done_cb_called_count
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf2
argument_list|,
literal|"I "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|evbuffer_add_buffer
argument_list|(
name|buf2
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ref_done_cb_called_count
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_remove
argument_list|(
name|buf2
argument_list|,
name|tmp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|memcmp
argument_list|(
literal|"I ought to write"
argument_list|,
name|tmp
argument_list|,
literal|16
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|buf2
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ref_done_cb_called_count
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ref_done_cb_called_with
operator|==
operator|(
name|void
operator|*
operator|)
literal|222
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
comment|/* Now add more stuff to buf1 and make sure that it gets removed on 	 * free. */
name|evbuffer_add
argument_list|(
name|buf1
argument_list|,
literal|"You shake and shake the "
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|evbuffer_add_reference
argument_list|(
name|buf1
argument_list|,
literal|"ketchup bottle"
argument_list|,
literal|14
argument_list|,
name|ref_done_cb
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|3333
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf1
argument_list|,
literal|". Nothing comes and then a lot'll."
argument_list|,
literal|42
argument_list|)
expr_stmt|;
name|evbuffer_free
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|buf1
operator|=
name|NULL
expr_stmt|;
name|tt_int_op
argument_list|(
name|ref_done_cb_called_count
argument_list|,
operator|==
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ref_done_cb_called_with
operator|==
operator|(
name|void
operator|*
operator|)
literal|3333
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|buf1
condition|)
name|evbuffer_free
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf2
condition|)
name|evbuffer_free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_multicast
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|char
name|chunk1
index|[]
init|=
literal|"If you have found the answer to such a problem"
decl_stmt|;
specifier|const
name|char
name|chunk2
index|[]
init|=
literal|"you ought to write it up for publication"
decl_stmt|;
comment|/* -- Knuth's "Notes on the Exercises" from TAOCP */
name|char
name|tmp
index|[
literal|16
index|]
decl_stmt|;
name|size_t
name|len1
init|=
name|strlen
argument_list|(
name|chunk1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|chunk2
argument_list|)
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|buf1
init|=
name|NULL
decl_stmt|,
modifier|*
name|buf2
init|=
name|NULL
decl_stmt|;
name|buf1
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf1
argument_list|,
name|chunk1
argument_list|,
name|len1
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf1
argument_list|,
literal|", "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf1
argument_list|,
name|chunk2
argument_list|,
name|len2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf1
argument_list|)
argument_list|,
operator|==
argument_list|,
name|len1
operator|+
name|len2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|buf2
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_add_buffer_reference
argument_list|(
name|buf2
argument_list|,
name|buf1
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* nested references are not allowed */
name|tt_int_op
argument_list|(
name|evbuffer_add_buffer_reference
argument_list|(
name|buf2
argument_list|,
name|buf2
argument_list|)
argument_list|,
operator|==
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_add_buffer_reference
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
argument_list|,
operator|==
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* both buffers contain the same amount of data */
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf1
argument_list|)
argument_list|,
operator|==
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure we can drain a little from the first buffer. */
name|tt_int_op
argument_list|(
name|evbuffer_remove
argument_list|(
name|buf1
argument_list|,
name|tmp
argument_list|,
literal|6
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|memcmp
argument_list|(
name|tmp
argument_list|,
literal|"If you"
argument_list|,
literal|6
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_remove
argument_list|(
name|buf1
argument_list|,
name|tmp
argument_list|,
literal|5
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|memcmp
argument_list|(
name|tmp
argument_list|,
literal|" have"
argument_list|,
literal|5
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure that prepending does not meddle with immutable data */
name|tt_int_op
argument_list|(
name|evbuffer_prepend
argument_list|(
name|buf1
argument_list|,
literal|"I have "
argument_list|,
literal|7
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|memcmp
argument_list|(
name|chunk1
argument_list|,
literal|"If you"
argument_list|,
literal|6
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
comment|/* Make sure we can drain a little from the second buffer. */
name|tt_int_op
argument_list|(
name|evbuffer_remove
argument_list|(
name|buf2
argument_list|,
name|tmp
argument_list|,
literal|6
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|memcmp
argument_list|(
name|tmp
argument_list|,
literal|"If you"
argument_list|,
literal|6
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_remove
argument_list|(
name|buf2
argument_list|,
name|tmp
argument_list|,
literal|5
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|memcmp
argument_list|(
name|tmp
argument_list|,
literal|" have"
argument_list|,
literal|5
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure that prepending does not meddle with immutable data */
name|tt_int_op
argument_list|(
name|evbuffer_prepend
argument_list|(
name|buf2
argument_list|,
literal|"I have "
argument_list|,
literal|7
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|memcmp
argument_list|(
name|chunk1
argument_list|,
literal|"If you"
argument_list|,
literal|6
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
comment|/* Make sure the data can be read from the second buffer when the first is freed */
name|evbuffer_free
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|buf1
operator|=
name|NULL
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_remove
argument_list|(
name|buf2
argument_list|,
name|tmp
argument_list|,
literal|6
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|memcmp
argument_list|(
name|tmp
argument_list|,
literal|"I have"
argument_list|,
literal|6
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_remove
argument_list|(
name|buf2
argument_list|,
name|tmp
argument_list|,
literal|6
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|memcmp
argument_list|(
name|tmp
argument_list|,
literal|"  foun"
argument_list|,
literal|6
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|buf1
condition|)
name|evbuffer_free
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf2
condition|)
name|evbuffer_free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_multicast_drain
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|char
name|chunk1
index|[]
init|=
literal|"If you have found the answer to such a problem"
decl_stmt|;
specifier|const
name|char
name|chunk2
index|[]
init|=
literal|"you ought to write it up for publication"
decl_stmt|;
comment|/* -- Knuth's "Notes on the Exercises" from TAOCP */
name|size_t
name|len1
init|=
name|strlen
argument_list|(
name|chunk1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|chunk2
argument_list|)
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|buf1
init|=
name|NULL
decl_stmt|,
modifier|*
name|buf2
init|=
name|NULL
decl_stmt|;
name|buf1
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf1
argument_list|,
name|chunk1
argument_list|,
name|len1
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf1
argument_list|,
literal|", "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf1
argument_list|,
name|chunk2
argument_list|,
name|len2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf1
argument_list|)
argument_list|,
operator|==
argument_list|,
name|len1
operator|+
name|len2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|buf2
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_add_buffer_reference
argument_list|(
name|buf2
argument_list|,
name|buf1
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf2
argument_list|)
argument_list|,
operator|==
argument_list|,
name|len1
operator|+
name|len2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_drain
argument_list|(
name|buf1
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf1
argument_list|)
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf2
argument_list|)
argument_list|,
operator|==
argument_list|,
name|len1
operator|+
name|len2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_drain
argument_list|(
name|buf2
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf2
argument_list|)
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|buf1
condition|)
name|evbuffer_free
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf2
condition|)
name|evbuffer_free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Some cases that we didn't get in test_evbuffer() above, for more coverage. */
end_comment

begin_function
specifier|static
name|void
name|test_evbuffer_prepend
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|buf1
init|=
name|NULL
decl_stmt|,
modifier|*
name|buf2
init|=
name|NULL
decl_stmt|;
name|char
name|tmp
index|[
literal|128
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|buf1
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
comment|/* Case 0: The evbuffer is entirely empty. */
name|evbuffer_prepend
argument_list|(
name|buf1
argument_list|,
literal|"This string has 29 characters"
argument_list|,
literal|29
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
comment|/* Case 1: Prepend goes entirely in new chunk. */
name|evbuffer_prepend
argument_list|(
name|buf1
argument_list|,
literal|"Short."
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
comment|/* Case 2: prepend goes entirely in first chunk. */
name|evbuffer_drain
argument_list|(
name|buf1
argument_list|,
literal|6
operator|+
literal|11
argument_list|)
expr_stmt|;
name|evbuffer_prepend
argument_list|(
name|buf1
argument_list|,
literal|"it"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|memcmp
argument_list|(
name|buf1
operator|->
name|first
operator|->
name|buffer
operator|+
name|buf1
operator|->
name|first
operator|->
name|misalign
argument_list|,
literal|"it has"
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Case 3: prepend is split over multiple chunks. */
name|evbuffer_prepend
argument_list|(
name|buf1
argument_list|,
literal|"It is no longer true to say "
argument_list|,
literal|28
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|n
operator|=
name|evbuffer_remove
argument_list|(
name|buf1
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tt_str_op
argument_list|(
name|tmp
argument_list|,
operator|==
argument_list|,
literal|"It is no longer true to say it has 29 characters"
argument_list|)
expr_stmt|;
name|buf2
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
comment|/* Case 4: prepend a buffer to an empty buffer. */
name|n
operator|=
literal|999
expr_stmt|;
name|evbuffer_add_printf
argument_list|(
name|buf1
argument_list|,
literal|"Here is string %d. "
argument_list|,
name|n
operator|++
argument_list|)
expr_stmt|;
name|evbuffer_prepend_buffer
argument_list|(
name|buf2
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
comment|/* Case 5: prepend a buffer to a nonempty buffer. */
name|evbuffer_add_printf
argument_list|(
name|buf1
argument_list|,
literal|"Here is string %d. "
argument_list|,
name|n
operator|++
argument_list|)
expr_stmt|;
name|evbuffer_prepend_buffer
argument_list|(
name|buf2
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
name|evbuffer_validate
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|n
operator|=
name|evbuffer_remove
argument_list|(
name|buf2
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tt_str_op
argument_list|(
name|tmp
argument_list|,
operator|==
argument_list|,
literal|"Here is string 1000. Here is string 999. "
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|buf1
condition|)
name|evbuffer_free
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf2
condition|)
name|evbuffer_free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_peek
parameter_list|(
name|void
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|buf
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmp_buf
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|evbuffer_iovec
name|v
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|evbuffer_ptr
name|ptr
decl_stmt|;
define|#
directive|define
name|tt_iov_eq
parameter_list|(
name|v
parameter_list|,
name|s
parameter_list|)
define|\
value|tt_int_op((v)->iov_len, ==, strlen(s));			\ 	tt_assert(!memcmp((v)->iov_base, (s), strlen(s)))
comment|/* Let's make a very fragmented buffer. */
name|buf
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|tmp_buf
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
name|evbuffer_add_printf
argument_list|(
name|tmp_buf
argument_list|,
literal|"Contents of chunk [%d]\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|evbuffer_add_buffer
argument_list|(
name|buf
argument_list|,
name|tmp_buf
argument_list|)
expr_stmt|;
block|}
comment|/* How many chunks do we need for everything? */
name|i
operator|=
name|evbuffer_peek
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|i
argument_list|,
operator|==
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Simple peek: get everything. */
name|i
operator|=
name|evbuffer_peek
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|v
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|i
argument_list|,
operator|==
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* we used only 16 chunks. */
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|0
index|]
argument_list|,
literal|"Contents of chunk [0]\n"
argument_list|)
expr_stmt|;
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|3
index|]
argument_list|,
literal|"Contents of chunk [3]\n"
argument_list|)
expr_stmt|;
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|12
index|]
argument_list|,
literal|"Contents of chunk [12]\n"
argument_list|)
expr_stmt|;
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|15
index|]
argument_list|,
literal|"Contents of chunk [15]\n"
argument_list|)
expr_stmt|;
comment|/* Just get one chunk worth. */
name|memset
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|evbuffer_peek
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|i
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|0
index|]
argument_list|,
literal|"Contents of chunk [0]\n"
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|1
index|]
operator|.
name|iov_base
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Suppose we want at least the first 40 bytes. */
name|memset
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|evbuffer_peek
argument_list|(
name|buf
argument_list|,
literal|40
argument_list|,
name|NULL
argument_list|,
name|v
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|i
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|0
index|]
argument_list|,
literal|"Contents of chunk [0]\n"
argument_list|)
expr_stmt|;
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|1
index|]
argument_list|,
literal|"Contents of chunk [1]\n"
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|2
index|]
operator|.
name|iov_base
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* How many chunks do we need for 100 bytes? */
name|memset
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|evbuffer_peek
argument_list|(
name|buf
argument_list|,
literal|100
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|i
argument_list|,
operator|==
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now we ask for more bytes than we provide chunks for */
name|memset
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|evbuffer_peek
argument_list|(
name|buf
argument_list|,
literal|60
argument_list|,
name|NULL
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|i
argument_list|,
operator|==
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|0
index|]
argument_list|,
literal|"Contents of chunk [0]\n"
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|1
index|]
operator|.
name|iov_base
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now we ask for more bytes than the buffer has. */
name|memset
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|evbuffer_peek
argument_list|(
name|buf
argument_list|,
literal|65536
argument_list|,
name|NULL
argument_list|,
name|v
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|i
argument_list|,
operator|==
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* we used only 16 chunks. */
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|0
index|]
argument_list|,
literal|"Contents of chunk [0]\n"
argument_list|)
expr_stmt|;
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|3
index|]
argument_list|,
literal|"Contents of chunk [3]\n"
argument_list|)
expr_stmt|;
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|12
index|]
argument_list|,
literal|"Contents of chunk [12]\n"
argument_list|)
expr_stmt|;
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|15
index|]
argument_list|,
literal|"Contents of chunk [15]\n"
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|16
index|]
operator|.
name|iov_base
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* What happens if we try an empty buffer? */
name|memset
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|evbuffer_peek
argument_list|(
name|tmp_buf
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|v
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|i
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|evbuffer_peek
argument_list|(
name|tmp_buf
argument_list|,
literal|50
argument_list|,
name|NULL
argument_list|,
name|v
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|i
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Okay, now time to have fun with pointers. */
name|memset
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr
argument_list|,
literal|30
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
expr_stmt|;
name|i
operator|=
name|evbuffer_peek
argument_list|(
name|buf
argument_list|,
literal|50
argument_list|,
operator|&
name|ptr
argument_list|,
name|v
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|i
argument_list|,
operator|==
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|0
index|]
argument_list|,
literal|" of chunk [1]\n"
argument_list|)
expr_stmt|;
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|1
index|]
argument_list|,
literal|"Contents of chunk [2]\n"
argument_list|)
expr_stmt|;
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|2
index|]
argument_list|,
literal|"Contents of chunk [3]\n"
argument_list|)
expr_stmt|;
comment|/*more than we asked for*/
comment|/* advance to the start of another chain. */
name|memset
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr
argument_list|,
literal|14
argument_list|,
name|EVBUFFER_PTR_ADD
argument_list|)
expr_stmt|;
name|i
operator|=
name|evbuffer_peek
argument_list|(
name|buf
argument_list|,
literal|44
argument_list|,
operator|&
name|ptr
argument_list|,
name|v
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|i
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|0
index|]
argument_list|,
literal|"Contents of chunk [2]\n"
argument_list|)
expr_stmt|;
name|tt_iov_eq
argument_list|(
operator|&
name|v
index|[
literal|1
index|]
argument_list|,
literal|"Contents of chunk [3]\n"
argument_list|)
expr_stmt|;
comment|/*more than we asked for*/
comment|/* peek at the end of the buffer */
name|memset
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|evbuffer_peek
argument_list|(
name|buf
argument_list|,
literal|44
argument_list|,
operator|&
name|ptr
argument_list|,
name|v
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|i
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|buf
condition|)
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_buf
condition|)
name|evbuffer_free
argument_list|(
name|tmp_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check whether evbuffer freezing works right.  This is called twice,    once with the argument "start" and once with the argument "end".    When we test "start", we freeze the start of an evbuffer and make sure    that modifying the start of the buffer doesn't work.  When we test    "end", we freeze the end of an evbuffer and make sure that modifying    the end of the buffer doesn't work.  */
end_comment

begin_function
specifier|static
name|void
name|test_evbuffer_freeze
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|buf
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmp_buf
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
name|string
index|[]
init|=
comment|/* Year's End, Richard Wilbur */
literal|"I've known the wind by water banks to shake\n"
literal|"The late leaves down, which frozen where they fell\n"
literal|"And held in ice as dancers in a spell\n"
literal|"Fluttered all winter long into a lake..."
decl_stmt|;
specifier|const
name|int
name|start
init|=
operator|!
name|strcmp
argument_list|(
name|ptr
argument_list|,
literal|"start"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|charbuf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|r
decl_stmt|;
name|size_t
name|orig_length
decl_stmt|;
name|struct
name|evbuffer_iovec
name|v
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|start
condition|)
name|tt_str_op
argument_list|(
name|ptr
argument_list|,
operator|==
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
name|buf
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|tmp_buf
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|tmp_buf
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_freeze
argument_list|(
name|buf
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* Freeze the start or the end.*/
define|#
directive|define
name|FREEZE_EQ
parameter_list|(
name|a
parameter_list|,
name|startcase
parameter_list|,
name|endcase
parameter_list|)
define|\
value|do {						\ 	    if (start) {				\ 		    tt_int_op((a), ==, (startcase));	\ 	    } else {					\ 		    tt_int_op((a), ==, (endcase));	\ 	    }						\ 	} while (0)
name|orig_length
operator|=
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* These functions all manipulate the end of buf. */
name|r
operator|=
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
literal|"abc"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FREEZE_EQ
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|r
operator|=
name|evbuffer_reserve_space
argument_list|(
name|buf
argument_list|,
literal|10
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FREEZE_EQ
argument_list|(
name|r
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|1
condition|)
block|{
name|memset
argument_list|(
name|v
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|,
literal|'X'
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
literal|10
expr_stmt|;
block|}
name|r
operator|=
name|evbuffer_commit_space
argument_list|(
name|buf
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FREEZE_EQ
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|r
operator|=
name|evbuffer_add_reference
argument_list|(
name|buf
argument_list|,
name|string
argument_list|,
literal|5
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|FREEZE_EQ
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|r
operator|=
name|evbuffer_add_printf
argument_list|(
name|buf
argument_list|,
literal|"Hello %s"
argument_list|,
literal|"world"
argument_list|)
expr_stmt|;
name|FREEZE_EQ
argument_list|(
name|r
argument_list|,
literal|11
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* TODO: test add_buffer, add_file, read */
if|if
condition|(
operator|!
name|start
condition|)
name|tt_int_op
argument_list|(
name|orig_length
argument_list|,
operator|==
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|orig_length
operator|=
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* These functions all manipulate the start of buf. */
name|r
operator|=
name|evbuffer_remove
argument_list|(
name|buf
argument_list|,
name|charbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FREEZE_EQ
argument_list|(
name|r
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|r
operator|=
name|evbuffer_drain
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|FREEZE_EQ
argument_list|(
name|r
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|evbuffer_prepend
argument_list|(
name|buf
argument_list|,
literal|"dummy"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|FREEZE_EQ
argument_list|(
name|r
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|evbuffer_readln
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
name|EVBUFFER_EOL_LF
argument_list|)
expr_stmt|;
name|FREEZE_EQ
argument_list|(
name|cp
operator|==
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* TODO: Test remove_buffer, add_buffer, write, prepend_buffer */
if|if
condition|(
name|start
condition|)
name|tt_int_op
argument_list|(
name|orig_length
argument_list|,
operator|==
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|buf
condition|)
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_buf
condition|)
name|evbuffer_free
argument_list|(
name|tmp_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_add_iovec
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|struct
name|evbuffer_iovec
name|vec
index|[
literal|4
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
index|[]
init|=
block|{
literal|"Guilt resembles a sword with two edges."
block|,
literal|"On the one hand, it cuts for Justice, imposing practical morality upon those who fear it."
block|,
literal|"Conscience does not always adhere to rational judgment."
block|,
literal|"Guilt is always a self-imposed burden, but it is not always rightly imposed."
comment|/* -- R.A. Salvatore, _Sojurn_ */
block|}
decl_stmt|;
name|size_t
name|expected_length
init|=
literal|0
decl_stmt|;
name|size_t
name|returned_length
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|buf
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|vec
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|data
index|[
name|i
index|]
expr_stmt|;
name|expected_length
operator|+=
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
name|returned_length
operator|=
name|evbuffer_add_iovec
argument_list|(
name|buf
argument_list|,
name|vec
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|returned_length
argument_list|,
operator|==
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|==
argument_list|,
name|expected_length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|char
name|charbuf
index|[
literal|1024
index|]
decl_stmt|;
name|memset
argument_list|(
name|charbuf
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|evbuffer_remove
argument_list|(
name|buf
argument_list|,
name|charbuf
argument_list|,
name|strlen
argument_list|(
name|data
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|strcmp
argument_list|(
name|charbuf
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|tt_assert
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|buf
condition|)
block|{
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_evbuffer_copyout
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
specifier|const
name|char
name|string
index|[]
init|=
literal|"Still they skirmish to and fro, men my messmates on the snow "
literal|"When we headed off the aurochs turn for turn; "
literal|"When the rich Allobrogenses never kept amanuenses, "
literal|"And our only plots were piled in lakes at Berne."
decl_stmt|;
comment|/* -- Kipling, "In The Neolithic Age" */
name|char
name|tmp
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|evbuffer_ptr
name|ptr
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|buf
decl_stmt|;
operator|(
name|void
operator|)
name|dummy
expr_stmt|;
name|buf
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|206
argument_list|)
expr_stmt|;
comment|/* Ensure separate chains */
name|evbuffer_add_reference
argument_list|(
name|buf
argument_list|,
name|string
argument_list|,
literal|80
argument_list|,
name|no_cleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evbuffer_add_reference
argument_list|(
name|buf
argument_list|,
name|string
operator|+
literal|80
argument_list|,
literal|80
argument_list|,
name|no_cleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
name|string
operator|+
literal|160
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
operator|-
literal|160
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|206
argument_list|,
operator|==
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First, let's test plain old copyout. */
comment|/* Copy a little from the beginning. */
name|tt_int_op
argument_list|(
literal|10
argument_list|,
operator|==
argument_list|,
name|evbuffer_copyout
argument_list|(
name|buf
argument_list|,
name|tmp
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|memcmp
argument_list|(
name|tmp
argument_list|,
literal|"Still they"
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now copy more than a little from the beginning */
name|memset
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|100
argument_list|,
operator|==
argument_list|,
name|evbuffer_copyout
argument_list|(
name|buf
argument_list|,
name|tmp
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|memcmp
argument_list|(
name|tmp
argument_list|,
name|string
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy too much; ensure truncation. */
name|memset
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|206
argument_list|,
operator|==
argument_list|,
name|evbuffer_copyout
argument_list|(
name|buf
argument_list|,
name|tmp
argument_list|,
literal|230
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|memcmp
argument_list|(
name|tmp
argument_list|,
name|string
argument_list|,
literal|206
argument_list|)
argument_list|)
expr_stmt|;
comment|/* That was supposed to be nondestructive, btw */
name|tt_int_op
argument_list|(
literal|206
argument_list|,
operator|==
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now it's time to test copyout_from!  First, let's start in the 	 * first chain. */
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr
argument_list|,
literal|15
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|10
argument_list|,
operator|==
argument_list|,
name|evbuffer_copyout_from
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr
argument_list|,
name|tmp
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|memcmp
argument_list|(
name|tmp
argument_list|,
literal|"mish to an"
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Right up to the end of the first chain */
name|memset
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|65
argument_list|,
operator|==
argument_list|,
name|evbuffer_copyout_from
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr
argument_list|,
name|tmp
argument_list|,
literal|65
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|memcmp
argument_list|(
name|tmp
argument_list|,
name|string
operator|+
literal|15
argument_list|,
literal|65
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Span into the second chain */
name|memset
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|90
argument_list|,
operator|==
argument_list|,
name|evbuffer_copyout_from
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr
argument_list|,
name|tmp
argument_list|,
literal|90
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|memcmp
argument_list|(
name|tmp
argument_list|,
name|string
operator|+
literal|15
argument_list|,
literal|90
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Span into the third chain */
name|memset
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|160
argument_list|,
operator|==
argument_list|,
name|evbuffer_copyout_from
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr
argument_list|,
name|tmp
argument_list|,
literal|160
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|memcmp
argument_list|(
name|tmp
argument_list|,
name|string
operator|+
literal|15
argument_list|,
literal|160
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Overrun */
name|memset
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|206
operator|-
literal|15
argument_list|,
operator|==
argument_list|,
name|evbuffer_copyout_from
argument_list|(
name|buf
argument_list|,
operator|&
name|ptr
argument_list|,
name|tmp
argument_list|,
literal|999
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|memcmp
argument_list|(
name|tmp
argument_list|,
name|string
operator|+
literal|15
argument_list|,
literal|206
operator|-
literal|15
argument_list|)
argument_list|)
expr_stmt|;
comment|/* That was supposed to be nondestructive, too */
name|tt_int_op
argument_list|(
literal|206
argument_list|,
operator|==
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|buf
condition|)
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|setup_passthrough
parameter_list|(
specifier|const
name|struct
name|testcase_t
modifier|*
name|testcase
parameter_list|)
block|{
return|return
name|testcase
operator|->
name|setup_data
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cleanup_passthrough
parameter_list|(
specifier|const
name|struct
name|testcase_t
modifier|*
name|testcase
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
operator|(
name|void
operator|)
name|ptr
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|testcase_setup_t
name|nil_setup
init|=
block|{
name|setup_passthrough
block|,
name|cleanup_passthrough
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|testcase_t
name|evbuffer_testcases
index|[]
init|=
block|{
block|{
literal|"evbuffer"
block|,
name|test_evbuffer
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"remove_buffer_with_empty"
block|,
name|test_evbuffer_remove_buffer_with_empty
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"reserve2"
block|,
name|test_evbuffer_reserve2
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"reserve_many"
block|,
name|test_evbuffer_reserve_many
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"reserve_many2"
block|,
name|test_evbuffer_reserve_many
block|,
literal|0
block|,
operator|&
name|nil_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"add"
block|}
block|,
block|{
literal|"reserve_many3"
block|,
name|test_evbuffer_reserve_many
block|,
literal|0
block|,
operator|&
name|nil_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"fill"
block|}
block|,
block|{
literal|"expand"
block|,
name|test_evbuffer_expand
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"reference"
block|,
name|test_evbuffer_reference
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"iterative"
block|,
name|test_evbuffer_iterative
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"readln"
block|,
name|test_evbuffer_readln
block|,
name|TT_NO_LOGS
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
block|{
literal|"search_eol"
block|,
name|test_evbuffer_search_eol
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"find"
block|,
name|test_evbuffer_find
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"ptr_set"
block|,
name|test_evbuffer_ptr_set
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"search"
block|,
name|test_evbuffer_search
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"callbacks"
block|,
name|test_evbuffer_callbacks
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"add_reference"
block|,
name|test_evbuffer_add_reference
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"multicast"
block|,
name|test_evbuffer_multicast
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"multicast_drain"
block|,
name|test_evbuffer_multicast_drain
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"prepend"
block|,
name|test_evbuffer_prepend
block|,
name|TT_FORK
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"peek"
block|,
name|test_evbuffer_peek
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"freeze_start"
block|,
name|test_evbuffer_freeze
block|,
literal|0
block|,
operator|&
name|nil_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"start"
block|}
block|,
block|{
literal|"freeze_end"
block|,
name|test_evbuffer_freeze
block|,
literal|0
block|,
operator|&
name|nil_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"end"
block|}
block|,
block|{
literal|"add_iovec"
block|,
name|test_evbuffer_add_iovec
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"copyout"
block|,
name|test_evbuffer_copyout
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"file_segment_add_cleanup_cb"
block|,
name|test_evbuffer_file_segment_add_cleanup_cb
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
define|#
directive|define
name|ADDFILE_TEST
parameter_list|(
name|name
parameter_list|,
name|parameters
parameter_list|)
define|\
value|{ name, test_evbuffer_add_file, TT_FORK|TT_NEED_BASE,		\&basic_setup, (void*)(parameters) }
define|#
directive|define
name|ADDFILE_TEST_GROUP
parameter_list|(
name|name
parameter_list|,
name|parameters
parameter_list|)
define|\
value|ADDFILE_TEST(name "_sendfile", "sendfile " parameters), \ 	ADDFILE_TEST(name "_mmap", "mmap " parameters),		\ 	ADDFILE_TEST(name "_linear", "linear " parameters)
name|ADDFILE_TEST_GROUP
argument_list|(
literal|"add_file"
argument_list|,
literal|""
argument_list|)
block|,
name|ADDFILE_TEST
argument_list|(
literal|"add_file_nosegment"
argument_list|,
literal|"default nosegment"
argument_list|)
block|,
name|ADDFILE_TEST_GROUP
argument_list|(
literal|"add_big_file"
argument_list|,
literal|"bigfile"
argument_list|)
block|,
name|ADDFILE_TEST
argument_list|(
literal|"add_big_file_nosegment"
argument_list|,
literal|"default nosegment bigfile"
argument_list|)
block|,
name|ADDFILE_TEST_GROUP
argument_list|(
literal|"add_file_offset"
argument_list|,
literal|"bigfile map_offset"
argument_list|)
block|,
name|ADDFILE_TEST
argument_list|(
literal|"add_file_offset_nosegment"
argument_list|,
literal|"default nosegment bigfile map_offset"
argument_list|)
block|,
name|ADDFILE_TEST_GROUP
argument_list|(
literal|"add_file_offset2"
argument_list|,
literal|"bigfile offset_in_segment"
argument_list|)
block|,
name|ADDFILE_TEST_GROUP
argument_list|(
literal|"add_file_offset3"
argument_list|,
literal|"bigfile offset_in_segment map_offset"
argument_list|)
block|,
name|END_OF_TESTCASES
block|}
decl_stmt|;
end_decl_stmt

end_unit

