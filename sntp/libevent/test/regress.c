begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2003-2007 Niels Provos<provos@citi.umich.edu>  * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_compat.h"
end_include

begin_include
include|#
directive|include
file|"event2/tag.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer_compat.h"
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"event-internal.h"
end_include

begin_include
include|#
directive|include
file|"evthread-internal.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|"time-internal.h"
end_include

begin_include
include|#
directive|include
file|"regress.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_include
include|#
directive|include
file|"regress.gen.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|evutil_socket_t
name|pair
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|test_ok
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|called
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|event_base
modifier|*
name|global_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|wbuf
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rbuf
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|woff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|roff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usepersist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|tset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|tcalled
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TEST1
value|"this is a test"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SHUT_WR
end_ifndef

begin_define
define|#
directive|define
name|SHUT_WR
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_define
define|#
directive|define
name|write
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
value|send((fd),(buf),(int)(len),0)
end_define

begin_define
define|#
directive|define
name|read
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
value|recv((fd),(buf),(int)(len),0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|basic_cb_args
block|{
name|struct
name|event_base
modifier|*
name|eb
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
decl_stmt|;
name|unsigned
name|int
name|callcount
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|simple_read_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
operator|!
name|called
condition|)
block|{
if|if
condition|(
name|event_add
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|called
operator|==
literal|1
condition|)
name|test_ok
operator|=
literal|1
expr_stmt|;
name|called
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|basic_read_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|basic_cb_args
modifier|*
name|arg
init|=
name|data
decl_stmt|;
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|tt_fail_perror
argument_list|(
literal|"read (callback)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|arg
operator|->
name|callcount
operator|++
condition|)
block|{
case|case
literal|0
case|:
comment|/* first call: expect to read data; cycle */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
return|return;
name|tt_fail_msg
argument_list|(
literal|"EOF before data read"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* second call: expect EOF; stop */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|tt_fail_msg
argument_list|(
literal|"not all data read on first cycle"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* third call: should not happen */
name|tt_fail_msg
argument_list|(
literal|"too many cycles"
argument_list|)
expr_stmt|;
block|}
block|}
name|event_del
argument_list|(
name|arg
operator|->
name|ev
argument_list|)
expr_stmt|;
name|event_base_loopexit
argument_list|(
name|arg
operator|->
name|eb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dummy_read_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|simple_write_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|TEST1
argument_list|,
name|strlen
argument_list|(
name|TEST1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
name|test_ok
operator|=
literal|0
expr_stmt|;
else|else
name|test_ok
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|multiple_write_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event
modifier|*
name|ev
init|=
name|arg
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
literal|128
expr_stmt|;
if|if
condition|(
name|woff
operator|+
name|len
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|wbuf
argument_list|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|wbuf
argument_list|)
operator|-
name|woff
expr_stmt|;
name|len
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|wbuf
operator|+
name|woff
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: write\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|usepersist
condition|)
name|event_del
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return;
block|}
name|woff
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|woff
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|wbuf
argument_list|)
condition|)
block|{
name|shutdown
argument_list|(
name|fd
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
if|if
condition|(
name|usepersist
condition|)
name|event_del
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|usepersist
condition|)
block|{
if|if
condition|(
name|event_add
argument_list|(
name|ev
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|multiple_read_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event
modifier|*
name|ev
init|=
name|arg
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|rbuf
operator|+
name|roff
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
operator|-
name|roff
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: read\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|usepersist
condition|)
name|event_del
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return;
block|}
name|roff
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|usepersist
condition|)
block|{
if|if
condition|(
name|event_add
argument_list|(
name|ev
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|timeout_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|evutil_gettimeofday
argument_list|(
operator|&
name|tcalled
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|both
block|{
name|struct
name|event
name|ev
decl_stmt|;
name|int
name|nread
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|combined_read_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|both
modifier|*
name|both
init|=
name|arg
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: read\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return;
name|both
operator|->
name|nread
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|both
operator|->
name|ev
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|combined_write_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|both
modifier|*
name|both
init|=
name|arg
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|both
operator|->
name|nread
condition|)
name|len
operator|=
name|both
operator|->
name|nread
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|'q'
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: write\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|shutdown
argument_list|(
name|fd
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
return|return;
block|}
name|both
operator|->
name|nread
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|both
operator|->
name|ev
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These macros used to replicate the work of the legacy test wrapper code */
end_comment

begin_define
define|#
directive|define
name|setup_test
parameter_list|(
name|x
parameter_list|)
value|do {						\ 	if (!in_legacy_test_wrapper) {					\ 		TT_FAIL(("Legacy test %s not wrapped properly", x));	\ 		return;							\ 	}								\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|cleanup_test
parameter_list|()
value|setup_test("cleanup")
end_define

begin_function
specifier|static
name|void
name|test_simpleread
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event
name|ev
decl_stmt|;
comment|/* Very simple read test */
name|setup_test
argument_list|(
literal|"Simple read: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|,
name|TEST1
argument_list|,
name|strlen
argument_list|(
name|TEST1
argument_list|)
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tt_fail_perror
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
block|}
name|shutdown
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|ev
argument_list|,
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_READ
argument_list|,
name|simple_read_cb
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|ev
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_simplewrite
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event
name|ev
decl_stmt|;
comment|/* Very simple write test */
name|setup_test
argument_list|(
literal|"Simple write: "
argument_list|)
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|ev
argument_list|,
name|pair
index|[
literal|0
index|]
argument_list|,
name|EV_WRITE
argument_list|,
name|simple_write_cb
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|ev
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|simpleread_multiple_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|++
name|called
operator|==
literal|2
condition|)
name|test_ok
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_simpleread_multiple
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event
name|one
decl_stmt|,
name|two
decl_stmt|;
comment|/* Very simple read test */
name|setup_test
argument_list|(
literal|"Simple read to multiple evens: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|,
name|TEST1
argument_list|,
name|strlen
argument_list|(
name|TEST1
argument_list|)
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tt_fail_perror
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
block|}
name|shutdown
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|one
argument_list|,
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_READ
argument_list|,
name|simpleread_multiple_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|one
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|two
argument_list|,
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_READ
argument_list|,
name|simpleread_multiple_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|two
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|have_closed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|premature_event
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|simpleclose_close_fd_cb
parameter_list|(
name|evutil_socket_t
name|s
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|evutil_socket_t
modifier|*
modifier|*
name|fds
init|=
name|ptr
decl_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"Closing"
operator|)
argument_list|)
expr_stmt|;
name|evutil_closesocket
argument_list|(
operator|*
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|evutil_closesocket
argument_list|(
operator|*
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|fds
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|fds
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|have_closed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|record_event_cb
parameter_list|(
name|evutil_socket_t
name|s
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|short
modifier|*
name|whatp
init|=
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|have_closed
condition|)
name|premature_event
operator|=
literal|1
expr_stmt|;
operator|*
name|whatp
operator|=
name|what
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"Recorded %d on socket %d"
operator|,
operator|(
name|int
operator|)
name|what
operator|,
operator|(
name|int
operator|)
name|s
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_simpleclose
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
comment|/* Test that a close of FD is detected as a read and as a write. */
name|struct
name|event_base
modifier|*
name|base
init|=
name|event_base_new
argument_list|()
decl_stmt|;
name|evutil_socket_t
name|pair1
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|,
name|pair2
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|evutil_socket_t
modifier|*
name|to_close
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|event
modifier|*
name|rev
init|=
name|NULL
decl_stmt|,
modifier|*
name|wev
init|=
name|NULL
decl_stmt|,
modifier|*
name|closeev
init|=
name|NULL
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|short
name|got_read_on_close
init|=
literal|0
decl_stmt|,
name|got_write_on_close
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|99
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
define|#
directive|define
name|LOCAL_SOCKETPAIR_AF
value|AF_INET
else|#
directive|else
define|#
directive|define
name|LOCAL_SOCKETPAIR_AF
value|AF_UNIX
endif|#
directive|endif
if|if
condition|(
name|evutil_socketpair
argument_list|(
name|LOCAL_SOCKETPAIR_AF
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|pair1
argument_list|)
operator|<
literal|0
condition|)
name|TT_DIE
argument_list|(
operator|(
literal|"socketpair: %s"
operator|,
name|strerror
argument_list|(
name|errno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|evutil_socketpair
argument_list|(
name|LOCAL_SOCKETPAIR_AF
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|pair2
argument_list|)
operator|<
literal|0
condition|)
name|TT_DIE
argument_list|(
operator|(
literal|"socketpair: %s"
operator|,
name|strerror
argument_list|(
name|errno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|evutil_make_socket_nonblocking
argument_list|(
name|pair1
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|TT_DIE
argument_list|(
operator|(
literal|"make_socket_nonblocking"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|evutil_make_socket_nonblocking
argument_list|(
name|pair2
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|TT_DIE
argument_list|(
operator|(
literal|"make_socket_nonblocking"
operator|)
argument_list|)
expr_stmt|;
comment|/** Stuff pair2[1] full of data, until write fails */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|r
init|=
name|write
argument_list|(
name|pair2
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|int
name|err
init|=
name|evutil_socket_geterror
argument_list|(
name|pair2
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|EVUTIL_ERR_RW_RETRIABLE
argument_list|(
name|err
argument_list|)
condition|)
name|TT_DIE
argument_list|(
operator|(
literal|"write failed strangely: %s"
operator|,
name|evutil_socket_error_to_string
argument_list|(
name|err
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|to_close
index|[
literal|0
index|]
operator|=
operator|&
name|pair1
index|[
literal|0
index|]
expr_stmt|;
name|to_close
index|[
literal|1
index|]
operator|=
operator|&
name|pair2
index|[
literal|0
index|]
expr_stmt|;
name|closeev
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|simpleclose_close_fd_cb
argument_list|,
name|to_close
argument_list|)
expr_stmt|;
name|rev
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|pair1
index|[
literal|1
index|]
argument_list|,
name|EV_READ
argument_list|,
name|record_event_cb
argument_list|,
operator|&
name|got_read_on_close
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"Waiting for read on %d"
operator|,
operator|(
name|int
operator|)
name|pair1
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|wev
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|pair2
index|[
literal|1
index|]
argument_list|,
name|EV_WRITE
argument_list|,
name|record_event_cb
argument_list|,
operator|&
name|got_write_on_close
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"Waiting for write on %d"
operator|,
operator|(
name|int
operator|)
name|pair2
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|100
operator|*
literal|1000
expr_stmt|;
comment|/* Close pair1[0] after a little while, and make 			       * sure we get a read event. */
name|event_add
argument_list|(
name|closeev
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|rev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|wev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Don't let the test go on too long. */
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|200
operator|*
literal|1000
expr_stmt|;
name|event_base_loopexit
argument_list|(
name|base
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|event_base_loop
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|got_read_on_close
argument_list|,
operator|==
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|got_write_on_close
argument_list|,
operator|==
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|premature_event
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|pair1
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
name|evutil_closesocket
argument_list|(
name|pair1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair1
index|[
literal|1
index|]
operator|>=
literal|0
condition|)
name|evutil_closesocket
argument_list|(
name|pair1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair2
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
name|evutil_closesocket
argument_list|(
name|pair2
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair2
index|[
literal|1
index|]
operator|>=
literal|0
condition|)
name|evutil_closesocket
argument_list|(
name|pair2
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
condition|)
name|event_free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|wev
condition|)
name|event_free
argument_list|(
name|wev
argument_list|)
expr_stmt|;
if|if
condition|(
name|closeev
condition|)
name|event_free
argument_list|(
name|closeev
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_multiple
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event
name|ev
decl_stmt|,
name|ev2
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Multiple read and write test */
name|setup_test
argument_list|(
literal|"Multiple read/write: "
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|wbuf
argument_list|)
condition|;
name|i
operator|++
control|)
name|wbuf
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|roff
operator|=
name|woff
operator|=
literal|0
expr_stmt|;
name|usepersist
operator|=
literal|0
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|ev
argument_list|,
name|pair
index|[
literal|0
index|]
argument_list|,
name|EV_WRITE
argument_list|,
name|multiple_write_cb
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|ev
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|ev2
argument_list|,
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_READ
argument_list|,
name|multiple_read_cb
argument_list|,
operator|&
name|ev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|ev2
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
if|if
condition|(
name|roff
operator|==
name|woff
condition|)
name|test_ok
operator|=
name|memcmp
argument_list|(
name|rbuf
argument_list|,
name|wbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|wbuf
argument_list|)
argument_list|)
operator|==
literal|0
expr_stmt|;
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_persistent
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event
name|ev
decl_stmt|,
name|ev2
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Multiple read and write test with persist */
name|setup_test
argument_list|(
literal|"Persist read/write: "
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|wbuf
argument_list|)
condition|;
name|i
operator|++
control|)
name|wbuf
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|roff
operator|=
name|woff
operator|=
literal|0
expr_stmt|;
name|usepersist
operator|=
literal|1
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|ev
argument_list|,
name|pair
index|[
literal|0
index|]
argument_list|,
name|EV_WRITE
operator||
name|EV_PERSIST
argument_list|,
name|multiple_write_cb
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|ev
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|ev2
argument_list|,
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
name|multiple_read_cb
argument_list|,
operator|&
name|ev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|ev2
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
if|if
condition|(
name|roff
operator|==
name|woff
condition|)
name|test_ok
operator|=
name|memcmp
argument_list|(
name|rbuf
argument_list|,
name|wbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|wbuf
argument_list|)
argument_list|)
operator|==
literal|0
expr_stmt|;
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_combined
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|both
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|w1
decl_stmt|,
name|w2
decl_stmt|;
name|setup_test
argument_list|(
literal|"Combined read/write: "
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|r1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|r1
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|r2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|r2
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|w1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|w1
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|w2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|w2
argument_list|)
argument_list|)
expr_stmt|;
name|w1
operator|.
name|nread
operator|=
literal|4096
expr_stmt|;
name|w2
operator|.
name|nread
operator|=
literal|8192
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|r1
operator|.
name|ev
argument_list|,
name|pair
index|[
literal|0
index|]
argument_list|,
name|EV_READ
argument_list|,
name|combined_read_cb
argument_list|,
operator|&
name|r1
argument_list|)
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|w1
operator|.
name|ev
argument_list|,
name|pair
index|[
literal|0
index|]
argument_list|,
name|EV_WRITE
argument_list|,
name|combined_write_cb
argument_list|,
operator|&
name|w1
argument_list|)
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|r2
operator|.
name|ev
argument_list|,
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_READ
argument_list|,
name|combined_read_cb
argument_list|,
operator|&
name|r2
argument_list|)
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|w2
operator|.
name|ev
argument_list|,
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_WRITE
argument_list|,
name|combined_write_cb
argument_list|,
operator|&
name|w2
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|event_add
argument_list|(
operator|&
name|r1
operator|.
name|ev
argument_list|,
name|NULL
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_add
argument_list|(
operator|&
name|w1
operator|.
name|ev
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_add
argument_list|(
operator|&
name|r2
operator|.
name|ev
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_add
argument_list|(
operator|&
name|w2
operator|.
name|ev
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
if|if
condition|(
name|r1
operator|.
name|nread
operator|==
literal|8192
operator|&&
name|r2
operator|.
name|nread
operator|==
literal|4096
condition|)
name|test_ok
operator|=
literal|1
expr_stmt|;
name|end
label|:
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_simpletimeout
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|event
name|ev
decl_stmt|;
name|setup_test
argument_list|(
literal|"Simple timeout: "
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|200
operator|*
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|evutil_timerclear
argument_list|(
operator|&
name|tcalled
argument_list|)
expr_stmt|;
name|evtimer_set
argument_list|(
operator|&
name|ev
argument_list|,
name|timeout_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evtimer_add
argument_list|(
operator|&
name|ev
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|tset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
name|test_timeval_diff_eq
argument_list|(
operator|&
name|tset
argument_list|,
operator|&
name|tcalled
argument_list|,
literal|200
argument_list|)
expr_stmt|;
name|test_ok
operator|=
literal|1
expr_stmt|;
name|end
label|:
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|periodic_timeout_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
modifier|*
name|count
init|=
name|arg
decl_stmt|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|count
operator|==
literal|6
condition|)
block|{
comment|/* call loopexit only once - on slow machines(?), it is 		 * apparently possible for this to get called twice. */
name|test_ok
operator|=
literal|1
expr_stmt|;
name|event_base_loopexit
argument_list|(
name|global_base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_persistent_timeout
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|event
name|ev
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|evutil_timerclear
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|10000
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|ev
argument_list|,
name|global_base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
operator||
name|EV_PERSIST
argument_list|,
name|periodic_timeout_cb
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|ev
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
name|event_del
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_persistent_timeout_jump
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|event
name|ev
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|msec100
init|=
block|{
literal|0
block|,
literal|100
operator|*
literal|1000
block|}
decl_stmt|;
name|struct
name|timeval
name|msec50
init|=
block|{
literal|0
block|,
literal|50
operator|*
literal|1000
block|}
decl_stmt|;
name|struct
name|timeval
name|msec300
init|=
block|{
literal|0
block|,
literal|300
operator|*
literal|1000
block|}
decl_stmt|;
name|event_assign
argument_list|(
operator|&
name|ev
argument_list|,
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_PERSIST
argument_list|,
name|periodic_timeout_cb
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|ev
argument_list|,
operator|&
name|msec100
argument_list|)
expr_stmt|;
comment|/* Wait for a bit */
name|evutil_usleep_
argument_list|(
operator|&
name|msec300
argument_list|)
expr_stmt|;
name|event_base_loopexit
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|&
name|msec50
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|data
operator|->
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|count
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|end
label|:
name|event_del
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|persist_active_timeout_called
block|{
name|int
name|n
decl_stmt|;
name|short
name|events
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|timeval
name|tvs
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|activate_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event
modifier|*
name|ev
init|=
name|arg
decl_stmt|;
name|event_active
argument_list|(
name|ev
argument_list|,
name|EV_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|persist_active_timeout_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|persist_active_timeout_called
modifier|*
name|c
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|n
operator|<
literal|15
condition|)
block|{
name|c
operator|->
name|events
index|[
name|c
operator|->
name|n
index|]
operator|=
name|event
expr_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|c
operator|->
name|tvs
index|[
name|c
operator|->
name|n
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_persistent_active_timeout
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|,
name|tv2
decl_stmt|,
name|tv_exit
decl_stmt|,
name|start
decl_stmt|;
name|struct
name|event
name|ev
decl_stmt|;
name|struct
name|persist_active_timeout_called
name|res
decl_stmt|;
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|memset
argument_list|(
operator|&
name|res
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|200
operator|*
literal|1000
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|ev
argument_list|,
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
operator||
name|EV_PERSIST
argument_list|,
name|persist_active_timeout_cb
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|ev
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tv2
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv2
operator|.
name|tv_usec
operator|=
literal|100
operator|*
literal|1000
expr_stmt|;
name|event_base_once
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|activate_cb
argument_list|,
operator|&
name|ev
argument_list|,
operator|&
name|tv2
argument_list|)
expr_stmt|;
name|tv_exit
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv_exit
operator|.
name|tv_usec
operator|=
literal|600
operator|*
literal|1000
expr_stmt|;
name|event_base_loopexit
argument_list|(
name|base
argument_list|,
operator|&
name|tv_exit
argument_list|)
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|res
operator|.
name|n
argument_list|,
operator|==
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|res
operator|.
name|events
index|[
literal|0
index|]
argument_list|,
operator|==
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|res
operator|.
name|events
index|[
literal|1
index|]
argument_list|,
operator|==
argument_list|,
name|EV_TIMEOUT
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|res
operator|.
name|events
index|[
literal|2
index|]
argument_list|,
operator|==
argument_list|,
name|EV_TIMEOUT
argument_list|)
expr_stmt|;
name|test_timeval_diff_eq
argument_list|(
operator|&
name|start
argument_list|,
operator|&
name|res
operator|.
name|tvs
index|[
literal|0
index|]
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|test_timeval_diff_eq
argument_list|(
operator|&
name|start
argument_list|,
operator|&
name|res
operator|.
name|tvs
index|[
literal|1
index|]
argument_list|,
literal|300
argument_list|)
expr_stmt|;
name|test_timeval_diff_eq
argument_list|(
operator|&
name|start
argument_list|,
operator|&
name|res
operator|.
name|tvs
index|[
literal|2
index|]
argument_list|,
literal|500
argument_list|)
expr_stmt|;
name|end
label|:
name|event_del
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|common_timeout_info
block|{
name|struct
name|event
name|ev
decl_stmt|;
name|struct
name|timeval
name|called_at
decl_stmt|;
name|int
name|which
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|common_timeout_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|common_timeout_info
modifier|*
name|ti
init|=
name|arg
decl_stmt|;
operator|++
name|ti
operator|->
name|count
expr_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|ti
operator|->
name|called_at
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|count
operator|>=
literal|4
condition|)
name|event_del
argument_list|(
operator|&
name|ti
operator|->
name|ev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_common_timeout
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|common_timeout_info
name|info
index|[
literal|100
index|]
decl_stmt|;
name|struct
name|timeval
name|start
decl_stmt|;
name|struct
name|timeval
name|tmp_100_ms
init|=
block|{
literal|0
block|,
literal|100
operator|*
literal|1000
block|}
decl_stmt|;
name|struct
name|timeval
name|tmp_200_ms
init|=
block|{
literal|0
block|,
literal|200
operator|*
literal|1000
block|}
decl_stmt|;
name|struct
name|timeval
name|tmp_5_sec
init|=
block|{
literal|5
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|timeval
name|tmp_5M_usec
init|=
block|{
literal|0
block|,
literal|5
operator|*
literal|1000
operator|*
literal|1000
block|}
decl_stmt|;
specifier|const
name|struct
name|timeval
modifier|*
name|ms_100
decl_stmt|,
modifier|*
name|ms_200
decl_stmt|,
modifier|*
name|sec_5
decl_stmt|;
name|ms_100
operator|=
name|event_base_init_common_timeout
argument_list|(
name|base
argument_list|,
operator|&
name|tmp_100_ms
argument_list|)
expr_stmt|;
name|ms_200
operator|=
name|event_base_init_common_timeout
argument_list|(
name|base
argument_list|,
operator|&
name|tmp_200_ms
argument_list|)
expr_stmt|;
name|sec_5
operator|=
name|event_base_init_common_timeout
argument_list|(
name|base
argument_list|,
operator|&
name|tmp_5_sec
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ms_100
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ms_200
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|sec_5
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|event_base_init_common_timeout
argument_list|(
name|base
argument_list|,
operator|&
name|tmp_200_ms
argument_list|)
argument_list|,
operator|==
argument_list|,
name|ms_200
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|event_base_init_common_timeout
argument_list|(
name|base
argument_list|,
name|ms_200
argument_list|)
argument_list|,
operator|==
argument_list|,
name|ms_200
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|event_base_init_common_timeout
argument_list|(
name|base
argument_list|,
operator|&
name|tmp_5M_usec
argument_list|)
argument_list|,
operator|==
argument_list|,
name|sec_5
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ms_100
operator|->
name|tv_sec
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ms_200
operator|->
name|tv_sec
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|sec_5
operator|->
name|tv_sec
argument_list|,
operator|==
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ms_100
operator|->
name|tv_usec
argument_list|,
operator|==
argument_list|,
literal|100000
operator||
literal|0x50000000
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ms_200
operator|->
name|tv_usec
argument_list|,
operator|==
argument_list|,
literal|200000
operator||
literal|0x50100000
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|sec_5
operator|->
name|tv_usec
argument_list|,
operator|==
argument_list|,
literal|0
operator||
literal|0x50200000
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
operator|++
name|i
control|)
block|{
name|info
index|[
name|i
index|]
operator|.
name|which
operator|=
name|i
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|info
index|[
name|i
index|]
operator|.
name|ev
argument_list|,
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
operator||
name|EV_PERSIST
argument_list|,
name|common_timeout_cb
argument_list|,
operator|&
name|info
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|20
operator|)
operator|==
literal|1
condition|)
block|{
comment|/* Glass-box test: Make sure we survive the 				 * transition to non-common timeouts. It's 				 * a little tricky. */
name|event_add
argument_list|(
operator|&
name|info
index|[
name|i
index|]
operator|.
name|ev
argument_list|,
name|ms_200
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|info
index|[
name|i
index|]
operator|.
name|ev
argument_list|,
operator|&
name|tmp_100_ms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|%
literal|20
operator|)
operator|==
literal|3
condition|)
block|{
comment|/* Check heap-to-common too. */
name|event_add
argument_list|(
operator|&
name|info
index|[
name|i
index|]
operator|.
name|ev
argument_list|,
operator|&
name|tmp_200_ms
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|info
index|[
name|i
index|]
operator|.
name|ev
argument_list|,
name|ms_100
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|%
literal|20
operator|)
operator|==
literal|5
condition|)
block|{
comment|/* Also check common-to-common. */
name|event_add
argument_list|(
operator|&
name|info
index|[
name|i
index|]
operator|.
name|ev
argument_list|,
name|ms_200
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|info
index|[
name|i
index|]
operator|.
name|ev
argument_list|,
name|ms_100
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|event_add
argument_list|(
operator|&
name|info
index|[
name|i
index|]
operator|.
name|ev
argument_list|,
name|ms_100
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|event_add
argument_list|(
operator|&
name|info
index|[
name|i
index|]
operator|.
name|ev
argument_list|,
name|ms_200
argument_list|)
expr_stmt|;
block|}
block|}
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
block|{
name|tt_int_op
argument_list|(
name|info
index|[
name|i
index|]
operator|.
name|count
argument_list|,
operator|==
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|2
condition|)
block|{
name|test_timeval_diff_eq
argument_list|(
operator|&
name|start
argument_list|,
operator|&
name|info
index|[
name|i
index|]
operator|.
name|called_at
argument_list|,
literal|400
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|test_timeval_diff_eq
argument_list|(
operator|&
name|start
argument_list|,
operator|&
name|info
index|[
name|i
index|]
operator|.
name|called_at
argument_list|,
literal|800
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Make sure we can free the base with some events in. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|2
condition|)
block|{
name|event_add
argument_list|(
operator|&
name|info
index|[
name|i
index|]
operator|.
name|ev
argument_list|,
name|ms_100
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|event_add
argument_list|(
operator|&
name|info
index|[
name|i
index|]
operator|.
name|ev
argument_list|,
name|ms_200
argument_list|)
expr_stmt|;
block|}
block|}
name|end
label|:
name|event_base_free
argument_list|(
name|data
operator|->
name|base
argument_list|)
expr_stmt|;
comment|/* need to do this here before info is 				      * out-of-scope */
name|data
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_function_decl
specifier|static
name|void
name|signal_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|current_base
value|event_global_current_base_
end_define

begin_decl_stmt
specifier|extern
name|struct
name|event_base
modifier|*
name|current_base
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|child_signal_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
modifier|*
name|pint
init|=
name|arg
decl_stmt|;
operator|*
name|pint
operator|=
literal|1
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|500000
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|event_loopexit
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_fork
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|got_sigchld
init|=
literal|0
decl_stmt|;
name|struct
name|event
name|ev
decl_stmt|,
name|sig_ev
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|setup_test
argument_list|(
literal|"After fork: "
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|current_base
argument_list|)
expr_stmt|;
name|evthread_make_base_notifiable
argument_list|(
name|current_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|,
name|TEST1
argument_list|,
name|strlen
argument_list|(
name|TEST1
argument_list|)
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tt_fail_perror
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
block|}
name|event_set
argument_list|(
operator|&
name|ev
argument_list|,
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_READ
argument_list|,
name|simple_read_cb
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|ev
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|evsignal_set
argument_list|(
operator|&
name|sig_ev
argument_list|,
name|SIGCHLD
argument_list|,
name|child_signal_cb
argument_list|,
operator|&
name|got_sigchld
argument_list|)
expr_stmt|;
name|evsignal_add
argument_list|(
operator|&
name|sig_ev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|current_base
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"Before fork"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|regress_fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* in the child */
name|TT_BLATHER
argument_list|(
operator|(
literal|"In child, before reinit"
operator|)
argument_list|)
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|current_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_reinit
argument_list|(
name|current_base
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"FAILED (reinit)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|TT_BLATHER
argument_list|(
operator|(
literal|"After reinit"
operator|)
argument_list|)
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|current_base
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"After assert-ok"
operator|)
argument_list|)
expr_stmt|;
name|evsignal_del
argument_list|(
operator|&
name|sig_ev
argument_list|)
expr_stmt|;
name|called
operator|=
literal|0
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
name|event_base_free
argument_list|(
name|current_base
argument_list|)
expr_stmt|;
comment|/* we do not send an EOF; simple_read_cb requires an EOF 		 * to set test_ok.  we just verify that the callback was 		 * called. */
name|exit
argument_list|(
name|test_ok
operator|!=
literal|0
operator|||
name|called
operator|!=
literal|2
condition|?
operator|-
literal|2
else|:
literal|76
argument_list|)
expr_stmt|;
block|}
comment|/* wait for the child to read the data */
block|{
specifier|const
name|struct
name|timeval
name|tv
init|=
block|{
literal|0
block|,
literal|100000
block|}
decl_stmt|;
name|evutil_usleep_
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|,
name|TEST1
argument_list|,
name|strlen
argument_list|(
name|TEST1
argument_list|)
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tt_fail_perror
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
block|}
name|TT_BLATHER
argument_list|(
operator|(
literal|"Before waitpid"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"FAILED (fork)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|TT_BLATHER
argument_list|(
operator|(
literal|"After waitpid"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|76
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"FAILED (exit): %d\n"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* test that the current event loop still works */
if|if
condition|(
name|write
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|,
name|TEST1
argument_list|,
name|strlen
argument_list|(
name|TEST1
argument_list|)
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: write\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|shutdown
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|got_sigchld
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"FAILED (sigchld)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|evsignal_del
argument_list|(
operator|&
name|sig_ev
argument_list|)
expr_stmt|;
name|end
label|:
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|signal_cb_sa
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|test_ok
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|signal_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event
modifier|*
name|ev
init|=
name|arg
decl_stmt|;
name|evsignal_del
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|test_ok
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_simplesignal
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event
name|ev
decl_stmt|;
name|struct
name|itimerval
name|itv
decl_stmt|;
name|setup_test
argument_list|(
literal|"Simple signal: "
argument_list|)
expr_stmt|;
name|evsignal_set
argument_list|(
operator|&
name|ev
argument_list|,
name|SIGALRM
argument_list|,
name|signal_cb
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
name|evsignal_add
argument_list|(
operator|&
name|ev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* find bugs in which operations are re-ordered */
name|evsignal_del
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
name|evsignal_add
argument_list|(
operator|&
name|ev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|itv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|itv
argument_list|)
argument_list|)
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|100000
expr_stmt|;
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|skip_simplesignal
goto|;
name|event_dispatch
argument_list|()
expr_stmt|;
name|skip_simplesignal
label|:
if|if
condition|(
name|evsignal_del
argument_list|(
operator|&
name|ev
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|test_ok
operator|=
literal|0
expr_stmt|;
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_multiplesignal
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event
name|ev_one
decl_stmt|,
name|ev_two
decl_stmt|;
name|struct
name|itimerval
name|itv
decl_stmt|;
name|setup_test
argument_list|(
literal|"Multiple signal: "
argument_list|)
expr_stmt|;
name|evsignal_set
argument_list|(
operator|&
name|ev_one
argument_list|,
name|SIGALRM
argument_list|,
name|signal_cb
argument_list|,
operator|&
name|ev_one
argument_list|)
expr_stmt|;
name|evsignal_add
argument_list|(
operator|&
name|ev_one
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evsignal_set
argument_list|(
operator|&
name|ev_two
argument_list|,
name|SIGALRM
argument_list|,
name|signal_cb
argument_list|,
operator|&
name|ev_two
argument_list|)
expr_stmt|;
name|evsignal_add
argument_list|(
operator|&
name|ev_two
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|itv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|itv
argument_list|)
argument_list|)
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|100000
expr_stmt|;
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|skip_simplesignal
goto|;
name|event_dispatch
argument_list|()
expr_stmt|;
name|skip_simplesignal
label|:
if|if
condition|(
name|evsignal_del
argument_list|(
operator|&
name|ev_one
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|test_ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|evsignal_del
argument_list|(
operator|&
name|ev_two
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|test_ok
operator|=
literal|0
expr_stmt|;
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_immediatesignal
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event
name|ev
decl_stmt|;
name|test_ok
operator|=
literal|0
expr_stmt|;
name|evsignal_set
argument_list|(
operator|&
name|ev
argument_list|,
name|SIGUSR1
argument_list|,
name|signal_cb
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
name|evsignal_add
argument_list|(
operator|&
name|ev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|raise
argument_list|(
name|SIGUSR1
argument_list|)
expr_stmt|;
name|event_loop
argument_list|(
name|EVLOOP_NONBLOCK
argument_list|)
expr_stmt|;
name|evsignal_del
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_signal_dealloc
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* make sure that evsignal_event is event_del'ed and pipe closed */
name|struct
name|event
name|ev
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|event_init
argument_list|()
decl_stmt|;
name|evsignal_set
argument_list|(
operator|&
name|ev
argument_list|,
name|SIGUSR1
argument_list|,
name|signal_cb
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
name|evsignal_add
argument_list|(
operator|&
name|ev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evsignal_del
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* If we got here without asserting, we're fine. */
name|test_ok
operator|=
literal|1
expr_stmt|;
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_signal_pipeloss
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* make sure that the base1 pipe is closed correctly. */
name|struct
name|event_base
modifier|*
name|base1
decl_stmt|,
modifier|*
name|base2
decl_stmt|;
name|int
name|pipe1
decl_stmt|;
name|test_ok
operator|=
literal|0
expr_stmt|;
name|base1
operator|=
name|event_init
argument_list|()
expr_stmt|;
name|pipe1
operator|=
name|base1
operator|->
name|sig
operator|.
name|ev_signal_pair
index|[
literal|0
index|]
expr_stmt|;
name|base2
operator|=
name|event_init
argument_list|()
expr_stmt|;
name|event_base_free
argument_list|(
name|base2
argument_list|)
expr_stmt|;
name|event_base_free
argument_list|(
name|base1
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|pipe1
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|EBADF
condition|)
block|{
comment|/* fd must be closed, so second close gives -1, EBADF */
name|printf
argument_list|(
literal|"signal pipe not closed. "
argument_list|)
expr_stmt|;
name|test_ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|test_ok
operator|=
literal|1
expr_stmt|;
block|}
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * make two bases to catch signals, use both of them.  this only works  * for event mechanisms that use our signal pipe trick.	 kqueue handles  * signals internally, and all interested kqueues get all the signals.  */
end_comment

begin_function
specifier|static
name|void
name|test_signal_switchbase
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event
name|ev1
decl_stmt|,
name|ev2
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base1
decl_stmt|,
modifier|*
name|base2
decl_stmt|;
name|int
name|is_kqueue
decl_stmt|;
name|test_ok
operator|=
literal|0
expr_stmt|;
name|base1
operator|=
name|event_init
argument_list|()
expr_stmt|;
name|base2
operator|=
name|event_init
argument_list|()
expr_stmt|;
name|is_kqueue
operator|=
operator|!
name|strcmp
argument_list|(
name|event_get_method
argument_list|()
argument_list|,
literal|"kqueue"
argument_list|)
expr_stmt|;
name|evsignal_set
argument_list|(
operator|&
name|ev1
argument_list|,
name|SIGUSR1
argument_list|,
name|signal_cb
argument_list|,
operator|&
name|ev1
argument_list|)
expr_stmt|;
name|evsignal_set
argument_list|(
operator|&
name|ev2
argument_list|,
name|SIGUSR1
argument_list|,
name|signal_cb
argument_list|,
operator|&
name|ev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_set
argument_list|(
name|base1
argument_list|,
operator|&
name|ev1
argument_list|)
operator|||
name|event_base_set
argument_list|(
name|base2
argument_list|,
operator|&
name|ev2
argument_list|)
operator|||
name|event_add
argument_list|(
operator|&
name|ev1
argument_list|,
name|NULL
argument_list|)
operator|||
name|event_add
argument_list|(
operator|&
name|ev2
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot set base, add\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tt_ptr_op
argument_list|(
name|event_get_base
argument_list|(
operator|&
name|ev1
argument_list|)
argument_list|,
operator|==
argument_list|,
name|base1
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|event_get_base
argument_list|(
operator|&
name|ev2
argument_list|)
argument_list|,
operator|==
argument_list|,
name|base2
argument_list|)
expr_stmt|;
name|test_ok
operator|=
literal|0
expr_stmt|;
comment|/* can handle signal before loop is called */
name|raise
argument_list|(
name|SIGUSR1
argument_list|)
expr_stmt|;
name|event_base_loop
argument_list|(
name|base2
argument_list|,
name|EVLOOP_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_kqueue
condition|)
block|{
if|if
condition|(
operator|!
name|test_ok
condition|)
goto|goto
name|end
goto|;
name|test_ok
operator|=
literal|0
expr_stmt|;
block|}
name|event_base_loop
argument_list|(
name|base1
argument_list|,
name|EVLOOP_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_ok
operator|&&
operator|!
name|is_kqueue
condition|)
block|{
name|test_ok
operator|=
literal|0
expr_stmt|;
comment|/* set base1 to handle signals */
name|event_base_loop
argument_list|(
name|base1
argument_list|,
name|EVLOOP_NONBLOCK
argument_list|)
expr_stmt|;
name|raise
argument_list|(
name|SIGUSR1
argument_list|)
expr_stmt|;
name|event_base_loop
argument_list|(
name|base1
argument_list|,
name|EVLOOP_NONBLOCK
argument_list|)
expr_stmt|;
name|event_base_loop
argument_list|(
name|base2
argument_list|,
name|EVLOOP_NONBLOCK
argument_list|)
expr_stmt|;
block|}
name|end
label|:
name|event_base_free
argument_list|(
name|base1
argument_list|)
expr_stmt|;
name|event_base_free
argument_list|(
name|base2
argument_list|)
expr_stmt|;
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * assert that a signal event removed from the event queue really is  * removed - with no possibility of it's parent handler being fired.  */
end_comment

begin_function
specifier|static
name|void
name|test_signal_assert
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event
name|ev
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|event_init
argument_list|()
decl_stmt|;
name|test_ok
operator|=
literal|0
expr_stmt|;
comment|/* use SIGCONT so we don't kill ourselves when we signal to nowhere */
name|evsignal_set
argument_list|(
operator|&
name|ev
argument_list|,
name|SIGCONT
argument_list|,
name|signal_cb
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
name|evsignal_add
argument_list|(
operator|&
name|ev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * if evsignal_del() fails to reset the handler, it's current handler 	 * will still point to evsig_handler(). 	 */
name|evsignal_del
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
name|raise
argument_list|(
name|SIGCONT
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* only way to verify we were in evsig_handler() */
comment|/* XXXX Now there's no longer a good way. */
block|if (base->sig.evsig_caught) 		test_ok = 0; 	else 		test_ok = 1;
else|#
directive|else
name|test_ok
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|cleanup_test
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * assert that we restore our previous signal handler properly.  */
end_comment

begin_function
specifier|static
name|void
name|test_signal_restore
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event
name|ev
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|event_init
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|EVENT__HAVE_SIGACTION
name|struct
name|sigaction
name|sa
decl_stmt|;
endif|#
directive|endif
name|test_ok
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENT__HAVE_SIGACTION
name|sa
operator|.
name|sa_handler
operator|=
name|signal_cb_sa
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0x0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGUSR1
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
else|#
directive|else
if|if
condition|(
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|signal_cb_sa
argument_list|)
operator|==
name|SIG_ERR
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
name|evsignal_set
argument_list|(
operator|&
name|ev
argument_list|,
name|SIGUSR1
argument_list|,
name|signal_cb
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
name|evsignal_add
argument_list|(
operator|&
name|ev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evsignal_del
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
name|raise
argument_list|(
name|SIGUSR1
argument_list|)
expr_stmt|;
comment|/* 1 == signal_cb, 2 == signal_cb_sa, we want our previous handler */
if|if
condition|(
name|test_ok
operator|!=
literal|2
condition|)
name|test_ok
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|cleanup_test
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|signal_cb_swp
parameter_list|(
name|int
name|sig
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|called
operator|++
expr_stmt|;
if|if
condition|(
name|called
operator|<
literal|5
condition|)
name|raise
argument_list|(
name|sig
argument_list|)
expr_stmt|;
else|else
name|event_loopexit
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|timeout_cb_swp
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|called
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|timeval
name|tv
init|=
block|{
literal|5
block|,
literal|0
block|}
decl_stmt|;
name|called
operator|=
literal|0
expr_stmt|;
name|evtimer_add
argument_list|(
operator|(
expr|struct
name|event
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|raise
argument_list|(
name|SIGUSR1
argument_list|)
expr_stmt|;
return|return;
block|}
name|test_ok
operator|=
literal|0
expr_stmt|;
name|event_loopexit
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_signal_while_processing
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
init|=
name|event_init
argument_list|()
decl_stmt|;
name|struct
name|event
name|ev
decl_stmt|,
name|ev_timer
decl_stmt|;
name|struct
name|timeval
name|tv
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|setup_test
argument_list|(
literal|"Receiving a signal while processing other signal: "
argument_list|)
expr_stmt|;
name|called
operator|=
operator|-
literal|1
expr_stmt|;
name|test_ok
operator|=
literal|1
expr_stmt|;
name|signal_set
argument_list|(
operator|&
name|ev
argument_list|,
name|SIGUSR1
argument_list|,
name|signal_cb_swp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|signal_add
argument_list|(
operator|&
name|ev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evtimer_set
argument_list|(
operator|&
name|ev_timer
argument_list|,
name|timeout_cb_swp
argument_list|,
operator|&
name|ev_timer
argument_list|)
expr_stmt|;
name|evtimer_add
argument_list|(
operator|&
name|ev_timer
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|cleanup_test
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|test_free_active_base
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base1
decl_stmt|;
name|struct
name|event
name|ev1
decl_stmt|;
name|base1
operator|=
name|event_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|base1
condition|)
block|{
name|event_assign
argument_list|(
operator|&
name|ev1
argument_list|,
name|base1
argument_list|,
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_READ
argument_list|,
name|dummy_read_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|ev1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_base_free
argument_list|(
name|base1
argument_list|)
expr_stmt|;
comment|/* should not crash */
block|}
else|else
block|{
name|tt_fail_msg
argument_list|(
literal|"failed to create event_base for test"
argument_list|)
expr_stmt|;
block|}
name|base1
operator|=
name|event_init
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|base1
argument_list|)
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|ev1
argument_list|,
name|base1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dummy_read_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
operator|&
name|ev1
argument_list|,
name|EV_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_base_free
argument_list|(
name|base1
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_manipulate_active_events
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|event
name|ev1
decl_stmt|;
name|event_assign
argument_list|(
operator|&
name|ev1
argument_list|,
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|dummy_read_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make sure an active event is pending. */
name|event_active
argument_list|(
operator|&
name|ev1
argument_list|,
name|EV_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_pending
argument_list|(
operator|&
name|ev1
argument_list|,
name|EV_READ
operator||
name|EV_TIMEOUT
operator||
name|EV_WRITE
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|==
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
comment|/* Make sure that activating an event twice works. */
name|event_active
argument_list|(
operator|&
name|ev1
argument_list|,
name|EV_WRITE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_pending
argument_list|(
operator|&
name|ev1
argument_list|,
name|EV_READ
operator||
name|EV_TIMEOUT
operator||
name|EV_WRITE
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|==
argument_list|,
name|EV_READ
operator||
name|EV_WRITE
argument_list|)
expr_stmt|;
name|end
label|:
name|event_del
argument_list|(
operator|&
name|ev1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_selfarg_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event
modifier|*
name|ev
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|event_get_base
argument_list|(
name|ev
argument_list|)
decl_stmt|;
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|event_base_loopexit
argument_list|(
name|base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_want
argument_list|(
name|ev
operator|==
name|event_base_get_running_event
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_event_new_selfarg
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
init|=
name|event_new
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_READ
argument_list|,
name|event_selfarg_cb
argument_list|,
name|event_self_cbarg
argument_list|()
argument_list|)
decl_stmt|;
name|event_active
argument_list|(
name|ev
argument_list|,
name|EV_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|event_free
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_event_assign_selfarg
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|event
name|ev
decl_stmt|;
name|event_assign
argument_list|(
operator|&
name|ev
argument_list|,
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_READ
argument_list|,
name|event_selfarg_cb
argument_list|,
name|event_self_cbarg
argument_list|()
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
operator|&
name|ev
argument_list|,
name|EV_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_event_base_get_num_events
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|event
name|ev
decl_stmt|;
name|int
name|event_count_active
decl_stmt|;
name|int
name|event_count_virtual
decl_stmt|;
name|int
name|event_count_added
decl_stmt|;
name|int
name|event_count_active_virtual
decl_stmt|;
name|int
name|event_count_active_added
decl_stmt|;
name|int
name|event_count_virtual_added
decl_stmt|;
name|int
name|event_count_active_added_virtual
decl_stmt|;
name|struct
name|timeval
name|qsec
init|=
block|{
literal|0
block|,
literal|100000
block|}
decl_stmt|;
name|event_assign
argument_list|(
operator|&
name|ev
argument_list|,
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_READ
argument_list|,
name|event_selfarg_cb
argument_list|,
name|event_self_cbarg
argument_list|()
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|ev
argument_list|,
operator|&
name|qsec
argument_list|)
expr_stmt|;
name|event_count_active
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
argument_list|)
expr_stmt|;
name|event_count_virtual
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|)
expr_stmt|;
name|event_count_added
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ADDED
argument_list|)
expr_stmt|;
name|event_count_active_virtual
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|)
expr_stmt|;
name|event_count_active_added
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_ADDED
argument_list|)
expr_stmt|;
name|event_count_virtual_added
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
operator||
name|EVENT_BASE_COUNT_ADDED
argument_list|)
expr_stmt|;
name|event_count_active_added_virtual
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_ADDED
operator||
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* libevent itself adds a timeout event, so the event_count is 2 here */
name|tt_int_op
argument_list|(
name|event_count_added
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_virtual
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_added
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual_added
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_added_virtual
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
operator|&
name|ev
argument_list|,
name|EV_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_count_active
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
argument_list|)
expr_stmt|;
name|event_count_virtual
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|)
expr_stmt|;
name|event_count_added
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ADDED
argument_list|)
expr_stmt|;
name|event_count_active_virtual
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|)
expr_stmt|;
name|event_count_active_added
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_ADDED
argument_list|)
expr_stmt|;
name|event_count_virtual_added
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
operator||
name|EVENT_BASE_COUNT_ADDED
argument_list|)
expr_stmt|;
name|event_count_active_added_virtual
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_ADDED
operator||
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_added
argument_list|,
operator|==
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_virtual
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_added
argument_list|,
operator|==
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual_added
argument_list|,
operator|==
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_added_virtual
argument_list|,
operator|==
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|event_base_loop
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_active
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
argument_list|)
expr_stmt|;
name|event_count_virtual
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|)
expr_stmt|;
name|event_count_added
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ADDED
argument_list|)
expr_stmt|;
name|event_count_active_virtual
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|)
expr_stmt|;
name|event_count_active_added
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_ADDED
argument_list|)
expr_stmt|;
name|event_count_virtual_added
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
operator||
name|EVENT_BASE_COUNT_ADDED
argument_list|)
expr_stmt|;
name|event_count_active_added_virtual
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_ADDED
operator||
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_added
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_virtual
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_added
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual_added
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_added_virtual
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_base_add_virtual_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|event_count_active
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
argument_list|)
expr_stmt|;
name|event_count_virtual
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|)
expr_stmt|;
name|event_count_added
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ADDED
argument_list|)
expr_stmt|;
name|event_count_active_virtual
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|)
expr_stmt|;
name|event_count_active_added
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_ADDED
argument_list|)
expr_stmt|;
name|event_count_virtual_added
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
operator||
name|EVENT_BASE_COUNT_ADDED
argument_list|)
expr_stmt|;
name|event_count_active_added_virtual
operator|=
name|event_base_get_num_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_ADDED
operator||
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_added
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_virtual
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_added
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual_added
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_added_virtual
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_event_base_get_max_events
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|event
name|ev
decl_stmt|;
name|struct
name|event
name|ev2
decl_stmt|;
name|int
name|event_count_active
decl_stmt|;
name|int
name|event_count_virtual
decl_stmt|;
name|int
name|event_count_added
decl_stmt|;
name|int
name|event_count_active_virtual
decl_stmt|;
name|int
name|event_count_active_added
decl_stmt|;
name|int
name|event_count_virtual_added
decl_stmt|;
name|int
name|event_count_active_added_virtual
decl_stmt|;
name|struct
name|timeval
name|qsec
init|=
block|{
literal|0
block|,
literal|100000
block|}
decl_stmt|;
name|event_assign
argument_list|(
operator|&
name|ev
argument_list|,
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_READ
argument_list|,
name|event_selfarg_cb
argument_list|,
name|event_self_cbarg
argument_list|()
argument_list|)
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|ev2
argument_list|,
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_READ
argument_list|,
name|event_selfarg_cb
argument_list|,
name|event_self_cbarg
argument_list|()
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|ev
argument_list|,
operator|&
name|qsec
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|ev2
argument_list|,
operator|&
name|qsec
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
operator|&
name|ev2
argument_list|)
expr_stmt|;
name|event_count_active
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_virtual
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_added
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ADDED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_active_virtual
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_active_added
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_ADDED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_virtual_added
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
operator||
name|EVENT_BASE_COUNT_ADDED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_active_added_virtual
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_ADDED
operator||
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* libevent itself adds a timeout event, so the event_count is 4 here */
name|tt_int_op
argument_list|(
name|event_count_added
argument_list|,
operator|==
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_virtual
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_added
argument_list|,
operator|==
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual_added
argument_list|,
operator|==
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_added_virtual
argument_list|,
operator|==
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
operator|&
name|ev
argument_list|,
name|EV_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_count_active
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_virtual
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_added
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ADDED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_active_virtual
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_active_added
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_ADDED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_virtual_added
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
operator||
name|EVENT_BASE_COUNT_ADDED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_active_added_virtual
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_ADDED
operator||
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_added
argument_list|,
operator|==
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_virtual
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_added
argument_list|,
operator|==
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual_added
argument_list|,
operator|==
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_added_virtual
argument_list|,
operator|==
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|event_base_loop
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_active
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_count_virtual
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_count_added
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ADDED
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_count_active_virtual
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_active_added
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_ADDED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_virtual_added
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
operator||
name|EVENT_BASE_COUNT_ADDED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_active_added_virtual
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_ADDED
operator||
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_added
argument_list|,
operator|==
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_virtual
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_added
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual_added
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_added_virtual
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_active
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_virtual
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_added
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ADDED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_added
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_base_add_virtual_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|event_count_active
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_virtual
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_added
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ADDED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_active_virtual
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_active_added
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_ADDED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_virtual_added
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_VIRTUAL
operator||
name|EVENT_BASE_COUNT_ADDED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_count_active_added_virtual
operator|=
name|event_base_get_max_events
argument_list|(
name|base
argument_list|,
name|EVENT_BASE_COUNT_ACTIVE
operator||
name|EVENT_BASE_COUNT_ADDED
operator||
name|EVENT_BASE_COUNT_VIRTUAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_added
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_virtual
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_added
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_virtual_added
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_count_active_added_virtual
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_bad_assign
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|event
name|ev
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* READ|SIGNAL is not allowed */
name|r
operator|=
name|event_assign
argument_list|(
operator|&
name|ev
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_SIGNAL
operator||
name|EV_READ
argument_list|,
name|dummy_read_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|reentrant_cb_run
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|bad_reentrant_run_loop_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
init|=
name|ptr
decl_stmt|;
name|int
name|r
decl_stmt|;
name|reentrant_cb_run
operator|=
literal|1
expr_stmt|;
comment|/* This reentrant call to event_base_loop should be detected and 	 * should fail */
name|r
operator|=
name|event_base_loop
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_bad_reentrant
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|event
name|ev
decl_stmt|;
name|int
name|r
decl_stmt|;
name|event_assign
argument_list|(
operator|&
name|ev
argument_list|,
name|base
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|bad_reentrant_run_loop_cb
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
operator|&
name|ev
argument_list|,
name|EV_WRITE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|r
operator|=
name|event_base_loop
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|reentrant_cb_run
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|n_write_a_byte_cb
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_read_and_drain_cb
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_activate_other_event_cb
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|write_a_byte_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|buf
index|[]
init|=
literal|"x"
decl_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
operator|++
name|n_write_a_byte_cb
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_and_drain_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
operator|++
name|n_read_and_drain_cb
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|activate_other_event_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|other_
parameter_list|)
block|{
name|struct
name|event
modifier|*
name|ev_activate
init|=
name|other_
decl_stmt|;
operator|++
name|n_activate_other_event_cb
expr_stmt|;
name|event_active_later_
argument_list|(
name|ev_activate
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_active_later
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|event
modifier|*
name|ev1
decl_stmt|,
modifier|*
name|ev2
decl_stmt|;
name|struct
name|event
name|ev3
decl_stmt|,
name|ev4
decl_stmt|;
name|struct
name|timeval
name|qsec
init|=
block|{
literal|0
block|,
literal|100000
block|}
decl_stmt|;
name|ev1
operator|=
name|event_new
argument_list|(
name|data
operator|->
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|0
index|]
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
name|read_and_drain_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ev2
operator|=
name|event_new
argument_list|(
name|data
operator|->
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_WRITE
operator||
name|EV_PERSIST
argument_list|,
name|write_a_byte_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|ev3
argument_list|,
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|activate_other_event_cb
argument_list|,
operator|&
name|ev4
argument_list|)
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|ev4
argument_list|,
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|activate_other_event_cb
argument_list|,
operator|&
name|ev3
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|ev1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|ev2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_active_later_
argument_list|(
operator|&
name|ev3
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|event_base_loopexit
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|&
name|qsec
argument_list|)
expr_stmt|;
name|event_base_loop
argument_list|(
name|data
operator|->
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"%d write calls, %d read calls, %d activate-other calls."
operator|,
name|n_write_a_byte_cb
operator|,
name|n_read_and_drain_cb
operator|,
name|n_activate_other_event_cb
operator|)
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
operator|&
name|ev3
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
operator|&
name|ev4
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n_write_a_byte_cb
argument_list|,
operator|==
argument_list|,
name|n_activate_other_event_cb
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n_write_a_byte_cb
argument_list|,
operator|>
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n_read_and_drain_cb
argument_list|,
operator|>
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n_activate_other_event_cb
argument_list|,
operator|>
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|event_active_later_
argument_list|(
operator|&
name|ev4
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
operator|&
name|ev4
argument_list|,
name|EV_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* This should make the event 					   active immediately. */
name|tt_assert
argument_list|(
operator|(
name|ev4
operator|.
name|ev_flags
operator|&
name|EVLIST_ACTIVE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|(
name|ev4
operator|.
name|ev_flags
operator|&
name|EVLIST_ACTIVE_LATER
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Now leave this one around, so that event_free sees it and removes 	 * it. */
name|event_active_later_
argument_list|(
operator|&
name|ev3
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|data
operator|->
name|base
argument_list|)
expr_stmt|;
name|event_base_free
argument_list|(
name|data
operator|->
name|base
argument_list|)
expr_stmt|;
name|data
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|incr_arg_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
modifier|*
name|intptr
init|=
name|arg
decl_stmt|;
operator|(
name|void
operator|)
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|what
expr_stmt|;
operator|++
operator|*
name|intptr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_timers_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event
modifier|*
modifier|*
name|ep
init|=
name|arg
decl_stmt|;
operator|(
name|void
operator|)
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|what
expr_stmt|;
name|event_remove_timer
argument_list|(
name|ep
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|event_remove_timer
argument_list|(
name|ep
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_a_byte_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|evutil_socket_t
modifier|*
name|sockp
init|=
name|arg
decl_stmt|;
operator|(
name|void
operator|)
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|what
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
operator|*
name|sockp
argument_list|,
literal|"A"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|read_not_timeout_param
block|{
name|struct
name|event
modifier|*
modifier|*
name|ev
decl_stmt|;
name|int
name|events
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|read_not_timeout_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|read_not_timeout_param
modifier|*
name|rntp
init|=
name|arg
decl_stmt|;
name|char
name|c
decl_stmt|;
name|ev_ssize_t
name|n
decl_stmt|;
operator|(
name|void
operator|)
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|what
expr_stmt|;
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rntp
operator|->
name|events
operator||=
name|what
expr_stmt|;
operator|++
name|rntp
operator|->
name|count
expr_stmt|;
if|if
condition|(
literal|2
operator|==
name|rntp
operator|->
name|count
condition|)
name|event_del
argument_list|(
name|rntp
operator|->
name|ev
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_event_remove_timeout
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
index|[
literal|5
index|]
decl_stmt|;
name|int
name|ev1_fired
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|ms25
init|=
block|{
literal|0
block|,
literal|25
operator|*
literal|1000
block|}
decl_stmt|,
name|ms40
init|=
block|{
literal|0
block|,
literal|40
operator|*
literal|1000
block|}
decl_stmt|,
name|ms75
init|=
block|{
literal|0
block|,
literal|75
operator|*
literal|1000
block|}
decl_stmt|,
name|ms125
init|=
block|{
literal|0
block|,
literal|125
operator|*
literal|1000
block|}
decl_stmt|;
name|struct
name|read_not_timeout_param
name|rntp
init|=
block|{
name|ev
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|ev
index|[
literal|0
index|]
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|0
index|]
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
name|read_not_timeout_cb
argument_list|,
operator|&
name|rntp
argument_list|)
expr_stmt|;
name|ev
index|[
literal|1
index|]
operator|=
name|evtimer_new
argument_list|(
name|base
argument_list|,
name|incr_arg_cb
argument_list|,
operator|&
name|ev1_fired
argument_list|)
expr_stmt|;
name|ev
index|[
literal|2
index|]
operator|=
name|evtimer_new
argument_list|(
name|base
argument_list|,
name|remove_timers_cb
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|ev
index|[
literal|3
index|]
operator|=
name|evtimer_new
argument_list|(
name|base
argument_list|,
name|send_a_byte_cb
argument_list|,
operator|&
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ev
index|[
literal|4
index|]
operator|=
name|evtimer_new
argument_list|(
name|base
argument_list|,
name|send_a_byte_cb
argument_list|,
operator|&
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|ev
index|[
literal|2
index|]
argument_list|,
operator|&
name|ms25
argument_list|)
expr_stmt|;
comment|/* remove timers */
name|event_add
argument_list|(
name|ev
index|[
literal|4
index|]
argument_list|,
operator|&
name|ms40
argument_list|)
expr_stmt|;
comment|/* write to test if timer re-activates */
name|event_add
argument_list|(
name|ev
index|[
literal|0
index|]
argument_list|,
operator|&
name|ms75
argument_list|)
expr_stmt|;
comment|/* read */
name|event_add
argument_list|(
name|ev
index|[
literal|1
index|]
argument_list|,
operator|&
name|ms75
argument_list|)
expr_stmt|;
comment|/* timer */
name|event_add
argument_list|(
name|ev
index|[
literal|3
index|]
argument_list|,
operator|&
name|ms125
argument_list|)
expr_stmt|;
comment|/* timeout. */
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ev1_fired
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|rntp
operator|.
name|events
argument_list|,
operator|==
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|end
label|:
name|event_free
argument_list|(
name|ev
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|event_free
argument_list|(
name|ev
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|event_free
argument_list|(
name|ev
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|event_free
argument_list|(
name|ev
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|event_free
argument_list|(
name|ev
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_event_base_new
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
literal|0
decl_stmt|;
name|struct
name|event
name|ev1
decl_stmt|;
name|struct
name|basic_cb_args
name|args
decl_stmt|;
name|int
name|towrite
init|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|TEST1
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|len
init|=
name|write
argument_list|(
name|data
operator|->
name|pair
index|[
literal|0
index|]
argument_list|,
name|TEST1
argument_list|,
name|towrite
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|tt_abort_perror
argument_list|(
literal|"initial write"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|!=
name|towrite
condition|)
name|tt_abort_printf
argument_list|(
operator|(
literal|"initial write fell short (%d of %d bytes)"
operator|,
name|len
operator|,
name|towrite
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shutdown
argument_list|(
name|data
operator|->
name|pair
index|[
literal|0
index|]
argument_list|,
name|SHUT_WR
argument_list|)
condition|)
name|tt_abort_perror
argument_list|(
literal|"initial write shutdown"
argument_list|)
expr_stmt|;
name|base
operator|=
name|event_base_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
name|tt_abort_msg
argument_list|(
literal|"failed to create event base"
argument_list|)
expr_stmt|;
name|args
operator|.
name|eb
operator|=
name|base
expr_stmt|;
name|args
operator|.
name|ev
operator|=
operator|&
name|ev1
expr_stmt|;
name|args
operator|.
name|callcount
operator|=
literal|0
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|ev1
argument_list|,
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
name|basic_read_cb
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|ev1
argument_list|,
name|NULL
argument_list|)
condition|)
name|tt_abort_perror
argument_list|(
literal|"initial event_add"
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_base_loop
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
condition|)
name|tt_abort_msg
argument_list|(
literal|"unsuccessful exit from event loop"
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|base
condition|)
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_loopexit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|,
name|tv_start
decl_stmt|,
name|tv_end
decl_stmt|;
name|struct
name|event
name|ev
decl_stmt|;
name|setup_test
argument_list|(
literal|"Loop exit: "
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|60
operator|*
literal|60
operator|*
literal|24
expr_stmt|;
name|evtimer_set
argument_list|(
operator|&
name|ev
argument_list|,
name|timeout_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evtimer_add
argument_list|(
operator|&
name|ev
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|300
operator|*
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|event_loopexit
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|tv_start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|tv_end
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evtimer_del
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|event_base_got_exit
argument_list|(
name|global_base
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_base_got_break
argument_list|(
name|global_base
argument_list|)
argument_list|)
expr_stmt|;
name|test_timeval_diff_eq
argument_list|(
operator|&
name|tv_start
argument_list|,
operator|&
name|tv_end
argument_list|,
literal|300
argument_list|)
expr_stmt|;
name|test_ok
operator|=
literal|1
expr_stmt|;
name|end
label|:
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_loopexit_multiple
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|,
name|tv_start
decl_stmt|,
name|tv_end
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
decl_stmt|;
name|setup_test
argument_list|(
literal|"Loop Multiple exit: "
argument_list|)
expr_stmt|;
name|base
operator|=
name|event_base_new
argument_list|()
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|200
operator|*
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|event_base_loopexit
argument_list|(
name|base
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|3
expr_stmt|;
name|event_base_loopexit
argument_list|(
name|base
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|tv_start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|tv_end
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|event_base_got_exit
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_base_got_break
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|test_timeval_diff_eq
argument_list|(
operator|&
name|tv_start
argument_list|,
operator|&
name|tv_end
argument_list|,
literal|200
argument_list|)
expr_stmt|;
name|test_ok
operator|=
literal|1
expr_stmt|;
name|end
label|:
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|break_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|test_ok
operator|=
literal|1
expr_stmt|;
name|event_loopbreak
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fail_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|test_ok
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_loopbreak
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event
name|ev1
decl_stmt|,
name|ev2
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|setup_test
argument_list|(
literal|"Loop break: "
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|evtimer_set
argument_list|(
operator|&
name|ev1
argument_list|,
name|break_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evtimer_add
argument_list|(
operator|&
name|ev1
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|evtimer_set
argument_list|(
operator|&
name|ev2
argument_list|,
name|fail_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evtimer_add
argument_list|(
operator|&
name|ev2
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_base_got_exit
argument_list|(
name|global_base
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|event_base_got_break
argument_list|(
name|global_base
argument_list|)
argument_list|)
expr_stmt|;
name|evtimer_del
argument_list|(
operator|&
name|ev1
argument_list|)
expr_stmt|;
name|evtimer_del
argument_list|(
operator|&
name|ev2
argument_list|)
expr_stmt|;
name|end
label|:
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|event
modifier|*
name|readd_test_event_last_added
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|re_add_read_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|event
modifier|*
name|ev_other
init|=
name|arg
decl_stmt|;
name|ev_ssize_t
name|n_read
decl_stmt|;
name|readd_test_event_last_added
operator|=
name|ev_other
expr_stmt|;
name|n_read
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_read
operator|<
literal|0
condition|)
block|{
name|tt_fail_perror
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
name|event_base_loopbreak
argument_list|(
name|event_get_base
argument_list|(
name|ev_other
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|event_add
argument_list|(
name|ev_other
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|++
name|test_ok
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_nonpersist_readd
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event
name|ev1
decl_stmt|,
name|ev2
decl_stmt|;
name|setup_test
argument_list|(
literal|"Re-add nonpersistent events: "
argument_list|)
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|ev1
argument_list|,
name|pair
index|[
literal|0
index|]
argument_list|,
name|EV_READ
argument_list|,
name|re_add_read_cb
argument_list|,
operator|&
name|ev2
argument_list|)
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|ev2
argument_list|,
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_READ
argument_list|,
name|re_add_read_cb
argument_list|,
operator|&
name|ev1
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|,
literal|"Hello"
argument_list|,
literal|5
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tt_fail_perror
argument_list|(
literal|"write(pair[0])"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|pair
index|[
literal|1
index|]
argument_list|,
literal|"Hello"
argument_list|,
literal|5
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tt_fail_perror
argument_list|(
literal|"write(pair[1])\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|ev1
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|event_add
argument_list|(
operator|&
name|ev2
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|test_ok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|test_ok
operator|!=
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|event_loop
argument_list|(
name|EVLOOP_ONCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_ok
operator|!=
literal|2
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* At this point, we executed both callbacks.  Whichever one got 	 * called first added the second, but the second then immediately got 	 * deleted before its callback was called.  At this point, though, it 	 * re-added the first. 	 */
if|if
condition|(
operator|!
name|readd_test_event_last_added
condition|)
block|{
name|test_ok
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readd_test_event_last_added
operator|==
operator|&
name|ev1
condition|)
block|{
if|if
condition|(
operator|!
name|event_pending
argument_list|(
operator|&
name|ev1
argument_list|,
name|EV_READ
argument_list|,
name|NULL
argument_list|)
operator|||
name|event_pending
argument_list|(
operator|&
name|ev2
argument_list|,
name|EV_READ
argument_list|,
name|NULL
argument_list|)
condition|)
name|test_ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|event_pending
argument_list|(
operator|&
name|ev1
argument_list|,
name|EV_READ
argument_list|,
name|NULL
argument_list|)
operator|||
operator|!
name|event_pending
argument_list|(
operator|&
name|ev2
argument_list|,
name|EV_READ
argument_list|,
name|NULL
argument_list|)
condition|)
name|test_ok
operator|=
literal|0
expr_stmt|;
block|}
name|event_del
argument_list|(
operator|&
name|ev1
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
operator|&
name|ev2
argument_list|)
expr_stmt|;
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|test_pri_event
block|{
name|struct
name|event
name|ev
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|test_priorities_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|test_pri_event
modifier|*
name|pri
init|=
name|arg
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
if|if
condition|(
name|pri
operator|->
name|count
operator|==
literal|3
condition|)
block|{
name|event_loopexit
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|pri
operator|->
name|count
operator|++
expr_stmt|;
name|evutil_timerclear
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|pri
operator|->
name|ev
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_priorities_impl
parameter_list|(
name|int
name|npriorities
parameter_list|)
block|{
name|struct
name|test_pri_event
name|one
decl_stmt|,
name|two
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"Testing Priorities %d: "
operator|,
name|npriorities
operator|)
argument_list|)
expr_stmt|;
name|event_base_priority_init
argument_list|(
name|global_base
argument_list|,
name|npriorities
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|one
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|one
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|two
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|two
argument_list|)
argument_list|)
expr_stmt|;
name|timeout_set
argument_list|(
operator|&
name|one
operator|.
name|ev
argument_list|,
name|test_priorities_cb
argument_list|,
operator|&
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_priority_set
argument_list|(
operator|&
name|one
operator|.
name|ev
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: failed to set priority"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|timeout_set
argument_list|(
operator|&
name|two
operator|.
name|ev
argument_list|,
name|test_priorities_cb
argument_list|,
operator|&
name|two
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_priority_set
argument_list|(
operator|&
name|two
operator|.
name|ev
argument_list|,
name|npriorities
operator|-
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: failed to set priority"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|evutil_timerclear
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|one
operator|.
name|ev
argument_list|,
operator|&
name|tv
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|two
operator|.
name|ev
argument_list|,
operator|&
name|tv
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
name|event_del
argument_list|(
operator|&
name|one
operator|.
name|ev
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
operator|&
name|two
operator|.
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|npriorities
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|one
operator|.
name|count
operator|==
literal|3
operator|&&
name|two
operator|.
name|count
operator|==
literal|3
condition|)
name|test_ok
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|npriorities
operator|==
literal|2
condition|)
block|{
comment|/* Two is called once because event_loopexit is priority 1 */
if|if
condition|(
name|one
operator|.
name|count
operator|==
literal|3
operator|&&
name|two
operator|.
name|count
operator|==
literal|1
condition|)
name|test_ok
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|one
operator|.
name|count
operator|==
literal|3
operator|&&
name|two
operator|.
name|count
operator|==
literal|0
condition|)
name|test_ok
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_priorities
parameter_list|(
name|void
parameter_list|)
block|{
name|test_priorities_impl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_ok
condition|)
name|test_priorities_impl
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_ok
condition|)
name|test_priorities_impl
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* priority-active-inversion: activate a higher-priority event, and make sure  * it keeps us from running a lower-priority event first. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_pai_calls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|event
name|pai_events
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|prio_active_inversion_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
modifier|*
name|call_order
init|=
name|arg
decl_stmt|;
operator|*
name|call_order
operator|=
name|n_pai_calls
operator|++
expr_stmt|;
if|if
condition|(
name|n_pai_calls
operator|==
literal|1
condition|)
block|{
comment|/* This should activate later, even though it shares a 		   priority with us. */
name|event_active
argument_list|(
operator|&
name|pai_events
index|[
literal|1
index|]
argument_list|,
name|EV_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* This should activate next, since its priority is higher, 		   even though we activated it second. */
name|event_active
argument_list|(
operator|&
name|pai_events
index|[
literal|2
index|]
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_priority_active_inversion
parameter_list|(
name|void
modifier|*
name|data_
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|data_
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|int
name|call_order
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tt_int_op
argument_list|(
name|event_base_priority_init
argument_list|(
name|base
argument_list|,
literal|8
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n_pai_calls
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|call_order
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|call_order
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|event_assign
argument_list|(
operator|&
name|pai_events
index|[
name|i
index|]
argument_list|,
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|prio_active_inversion_cb
argument_list|,
operator|&
name|call_order
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|event_priority_set
argument_list|(
operator|&
name|pai_events
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|event_priority_set
argument_list|(
operator|&
name|pai_events
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|event_priority_set
argument_list|(
operator|&
name|pai_events
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
operator|&
name|pai_events
index|[
literal|0
index|]
argument_list|,
name|EV_WRITE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|n_pai_calls
argument_list|,
operator|==
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|call_order
index|[
literal|0
index|]
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|call_order
index|[
literal|1
index|]
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|call_order
index|[
literal|2
index|]
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_multiple_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|event
operator|&
name|EV_READ
condition|)
name|test_ok
operator||=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|event
operator|&
name|EV_WRITE
condition|)
name|test_ok
operator||=
literal|2
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_multiple_events_for_same_fd
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|setup_test
argument_list|(
literal|"Multiple events for same fd: "
argument_list|)
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|e1
argument_list|,
name|pair
index|[
literal|0
index|]
argument_list|,
name|EV_READ
argument_list|,
name|test_multiple_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|e1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|e2
argument_list|,
name|pair
index|[
literal|0
index|]
argument_list|,
name|EV_WRITE
argument_list|,
name|test_multiple_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
operator|&
name|e2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_loop
argument_list|(
name|EVLOOP_ONCE
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
operator|&
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pair
index|[
literal|1
index|]
argument_list|,
name|TEST1
argument_list|,
name|strlen
argument_list|(
name|TEST1
argument_list|)
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tt_fail_perror
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
block|}
name|event_loop
argument_list|(
name|EVLOOP_ONCE
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
operator|&
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_ok
operator|!=
literal|3
condition|)
name|test_ok
operator|=
literal|0
expr_stmt|;
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_function_decl
name|int
name|evtag_decode_int
parameter_list|(
name|ev_uint32_t
modifier|*
name|pnumber
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|evbuf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|evtag_decode_int64
parameter_list|(
name|ev_uint64_t
modifier|*
name|pnumber
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|evbuf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|evtag_encode_tag
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|evbuf
parameter_list|,
name|ev_uint32_t
name|number
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|evtag_decode_tag
parameter_list|(
name|ev_uint32_t
modifier|*
name|pnumber
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|evbuf
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|read_once_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|called
condition|)
block|{
name|test_ok
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
condition|)
block|{
comment|/* Assumes global pair[0] can be used for writing */
if|if
condition|(
name|write
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|,
name|TEST1
argument_list|,
name|strlen
argument_list|(
name|TEST1
argument_list|)
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tt_fail_perror
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
name|test_ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|test_ok
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|called
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_want_only_once
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event
name|ev
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* Very simple read test */
name|setup_test
argument_list|(
literal|"Want read only once: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|,
name|TEST1
argument_list|,
name|strlen
argument_list|(
name|TEST1
argument_list|)
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tt_fail_perror
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the loop termination */
name|evutil_timerclear
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|300
operator|*
literal|1000
expr_stmt|;
name|event_loopexit
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|ev
argument_list|,
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_READ
argument_list|,
name|read_once_cb
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|ev
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|event_dispatch
argument_list|()
expr_stmt|;
name|cleanup_test
argument_list|()
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|TEST_MAX_INT
value|6
end_define

begin_function
specifier|static
name|void
name|evtag_int_test
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|tmp
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|ev_uint32_t
name|integers
index|[
name|TEST_MAX_INT
index|]
init|=
block|{
literal|0xaf0
block|,
literal|0x1000
block|,
literal|0x1
block|,
literal|0xdeadbeef
block|,
literal|0x00
block|,
literal|0xbef000
block|}
decl_stmt|;
name|ev_uint32_t
name|integer
decl_stmt|;
name|ev_uint64_t
name|big_int
decl_stmt|;
name|int
name|i
decl_stmt|;
name|evtag_init
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TEST_MAX_INT
condition|;
name|i
operator|++
control|)
block|{
name|int
name|oldlen
decl_stmt|,
name|newlen
decl_stmt|;
name|oldlen
operator|=
operator|(
name|int
operator|)
name|EVBUFFER_LENGTH
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|evtag_encode_int
argument_list|(
name|tmp
argument_list|,
name|integers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|newlen
operator|=
operator|(
name|int
operator|)
name|EVBUFFER_LENGTH
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"encoded 0x%08x with %d bytes"
operator|,
operator|(
name|unsigned
operator|)
name|integers
index|[
name|i
index|]
operator|,
name|newlen
operator|-
name|oldlen
operator|)
argument_list|)
expr_stmt|;
name|big_int
operator|=
name|integers
index|[
name|i
index|]
expr_stmt|;
name|big_int
operator|*=
literal|1000000000
expr_stmt|;
comment|/* 1 billion */
name|evtag_encode_int64
argument_list|(
name|tmp
argument_list|,
name|big_int
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TEST_MAX_INT
condition|;
name|i
operator|++
control|)
block|{
name|tt_int_op
argument_list|(
name|evtag_decode_int
argument_list|(
operator|&
name|integer
argument_list|,
name|tmp
argument_list|)
argument_list|,
operator|!=
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_uint_op
argument_list|(
name|integer
argument_list|,
operator|==
argument_list|,
name|integers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evtag_decode_int64
argument_list|(
operator|&
name|big_int
argument_list|,
name|tmp
argument_list|)
argument_list|,
operator|!=
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|(
name|big_int
operator|/
literal|1000000000
operator|)
operator|==
name|integers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|tt_uint_op
argument_list|(
name|EVBUFFER_LENGTH
argument_list|(
name|tmp
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end
label|:
name|evbuffer_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evtag_fuzz
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|u_char
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|tmp
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|not_failed
init|=
literal|0
decl_stmt|;
name|evtag_init
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|100
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|;
name|i
operator|++
control|)
name|buffer
index|[
name|i
index|]
operator|=
name|rand
argument_list|()
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|tmp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|tmp
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|evtag_unmarshal_timeval
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
operator|&
name|tv
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|not_failed
operator|++
expr_stmt|;
block|}
comment|/* The majority of decodes should fail */
name|tt_int_op
argument_list|(
name|not_failed
argument_list|,
operator|<
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Now insert some corruption into the tag length field */
name|evbuffer_drain
argument_list|(
name|tmp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|evutil_timerclear
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
name|evtag_marshal_timeval
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|tmp
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
name|EVBUFFER_DATA
argument_list|(
name|tmp
argument_list|)
operator|)
index|[
literal|1
index|]
operator|=
literal|'\xff'
expr_stmt|;
if|if
condition|(
name|evtag_unmarshal_timeval
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
operator|&
name|tv
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|tt_abort_msg
argument_list|(
literal|"evtag_unmarshal_timeval should have failed"
argument_list|)
expr_stmt|;
block|}
name|end
label|:
name|evbuffer_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evtag_tag_encoding
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|tmp
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|ev_uint32_t
name|integers
index|[
name|TEST_MAX_INT
index|]
init|=
block|{
literal|0xaf0
block|,
literal|0x1000
block|,
literal|0x1
block|,
literal|0xdeadbeef
block|,
literal|0x00
block|,
literal|0xbef000
block|}
decl_stmt|;
name|ev_uint32_t
name|integer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|evtag_init
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TEST_MAX_INT
condition|;
name|i
operator|++
control|)
block|{
name|int
name|oldlen
decl_stmt|,
name|newlen
decl_stmt|;
name|oldlen
operator|=
operator|(
name|int
operator|)
name|EVBUFFER_LENGTH
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|evtag_encode_tag
argument_list|(
name|tmp
argument_list|,
name|integers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|newlen
operator|=
operator|(
name|int
operator|)
name|EVBUFFER_LENGTH
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"encoded 0x%08x with %d bytes"
operator|,
operator|(
name|unsigned
operator|)
name|integers
index|[
name|i
index|]
operator|,
name|newlen
operator|-
name|oldlen
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TEST_MAX_INT
condition|;
name|i
operator|++
control|)
block|{
name|tt_int_op
argument_list|(
name|evtag_decode_tag
argument_list|(
operator|&
name|integer
argument_list|,
name|tmp
argument_list|)
argument_list|,
operator|!=
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_uint_op
argument_list|(
name|integer
argument_list|,
operator|==
argument_list|,
name|integers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|tt_uint_op
argument_list|(
name|EVBUFFER_LENGTH
argument_list|(
name|tmp
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end
label|:
name|evbuffer_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evtag_test_peek
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|tmp
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
name|ev_uint32_t
name|u32
decl_stmt|;
name|evtag_marshal_int
argument_list|(
name|tmp
argument_list|,
literal|30
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evtag_marshal_string
argument_list|(
name|tmp
argument_list|,
literal|40
argument_list|,
literal|"Hello world"
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evtag_peek
argument_list|(
name|tmp
argument_list|,
operator|&
name|u32
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|u32
argument_list|,
operator|==
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evtag_peek_length
argument_list|(
name|tmp
argument_list|,
operator|&
name|u32
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|u32
argument_list|,
operator|==
argument_list|,
literal|1
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evtag_consume
argument_list|(
name|tmp
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evtag_peek
argument_list|(
name|tmp
argument_list|,
operator|&
name|u32
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|u32
argument_list|,
operator|==
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evtag_peek_length
argument_list|(
name|tmp
argument_list|,
operator|&
name|u32
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|u32
argument_list|,
operator|==
argument_list|,
literal|1
operator|+
literal|1
operator|+
literal|11
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|evtag_payload_length
argument_list|(
name|tmp
argument_list|,
operator|&
name|u32
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|u32
argument_list|,
operator|==
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|end
label|:
name|evbuffer_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_methods
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|methods
init|=
name|event_get_supported_methods
argument_list|()
decl_stmt|;
name|struct
name|event_config
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|backend
decl_stmt|;
name|int
name|n_methods
init|=
literal|0
decl_stmt|;
name|tt_assert
argument_list|(
name|methods
argument_list|)
expr_stmt|;
name|backend
operator|=
name|methods
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|methods
operator|!=
name|NULL
condition|)
block|{
name|TT_BLATHER
argument_list|(
operator|(
literal|"Support method: %s"
operator|,
operator|*
name|methods
operator|)
argument_list|)
expr_stmt|;
operator|++
name|methods
expr_stmt|;
operator|++
name|n_methods
expr_stmt|;
block|}
name|cfg
operator|=
name|event_config_new
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|cfg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|event_config_avoid_method
argument_list|(
name|cfg
argument_list|,
name|backend
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_config_set_flag
argument_list|(
name|cfg
argument_list|,
name|EVENT_BASE_FLAG_IGNORE_ENV
argument_list|)
expr_stmt|;
name|base
operator|=
name|event_base_new_with_config
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_methods
operator|>
literal|1
condition|)
block|{
name|tt_assert
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|backend
argument_list|,
operator|!=
argument_list|,
name|event_base_get_method
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_assert
argument_list|(
name|base
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|end
label|:
if|if
condition|(
name|base
condition|)
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
condition|)
name|event_config_free
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_version
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|vstr
decl_stmt|;
name|ev_uint32_t
name|vint
decl_stmt|;
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|,
name|patch
decl_stmt|,
name|n
decl_stmt|;
name|vstr
operator|=
name|event_get_version
argument_list|()
expr_stmt|;
name|vint
operator|=
name|event_get_version_number
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|vstr
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|vint
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|vstr
argument_list|,
operator|==
argument_list|,
name|LIBEVENT_VERSION
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|vint
argument_list|,
operator|==
argument_list|,
name|LIBEVENT_VERSION_NUMBER
argument_list|)
expr_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|vstr
argument_list|,
literal|"%d.%d.%d"
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|,
operator|&
name|patch
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
literal|3
operator|==
name|n
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
operator|(
name|vint
operator|&
literal|0xffffff00
operator|)
argument_list|,
operator|==
argument_list|,
operator|(
operator|(
name|major
operator|<<
literal|24
operator|)
operator||
operator|(
name|minor
operator|<<
literal|16
operator|)
operator||
operator|(
name|patch
operator|<<
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_base_features
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
init|=
name|NULL
decl_stmt|;
name|struct
name|event_config
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|cfg
operator|=
name|event_config_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
literal|0
operator|==
name|event_config_require_features
argument_list|(
name|cfg
argument_list|,
name|EV_FEATURE_ET
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|event_base_new_with_config
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|tt_int_op
argument_list|(
name|EV_FEATURE_ET
argument_list|,
operator|==
argument_list|,
name|event_base_get_features
argument_list|(
name|base
argument_list|)
operator|&
name|EV_FEATURE_ET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|event_base_new
argument_list|()
expr_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|event_base_get_features
argument_list|(
name|base
argument_list|)
operator|&
name|EV_FEATURE_ET
argument_list|)
expr_stmt|;
block|}
name|end
label|:
if|if
condition|(
name|base
condition|)
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
condition|)
name|event_config_free
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SETENV
end_ifdef

begin_define
define|#
directive|define
name|SETENV_OK
end_define

begin_elif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|EVENT__HAVE_SETENV
argument_list|)
operator|&&
name|defined
argument_list|(
name|EVENT__HAVE_PUTENV
argument_list|)
end_elif

begin_function
specifier|static
name|void
name|setenv
parameter_list|(
specifier|const
name|char
modifier|*
name|k
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|int
name|o_
parameter_list|)
block|{
name|char
name|b
index|[
literal|256
index|]
decl_stmt|;
name|evutil_snprintf
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|,
literal|"%s=%s"
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SETENV_OK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_UNSETENV
end_ifdef

begin_define
define|#
directive|define
name|UNSETENV_OK
end_define

begin_elif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|EVENT__HAVE_UNSETENV
argument_list|)
operator|&&
name|defined
argument_list|(
name|EVENT__HAVE_PUTENV
argument_list|)
end_elif

begin_function
specifier|static
name|void
name|unsetenv
parameter_list|(
specifier|const
name|char
modifier|*
name|k
parameter_list|)
block|{
name|char
name|b
index|[
literal|256
index|]
decl_stmt|;
name|evutil_snprintf
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|,
literal|"%s="
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|UNSETENV_OK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SETENV_OK
argument_list|)
operator|&&
name|defined
argument_list|(
name|UNSETENV_OK
argument_list|)
end_if

begin_function
specifier|static
name|void
name|methodname_to_envvar
parameter_list|(
specifier|const
name|char
modifier|*
name|mname
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"EVENT_NO%s"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
init|;
operator|*
name|cp
condition|;
operator|++
name|cp
control|)
block|{
operator|*
name|cp
operator|=
name|EVUTIL_TOUPPER_
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|test_base_environ
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
init|=
name|NULL
decl_stmt|;
name|struct
name|event_config
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SETENV_OK
argument_list|)
operator|&&
name|defined
argument_list|(
name|UNSETENV_OK
argument_list|)
specifier|const
name|char
modifier|*
modifier|*
name|basenames
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_methods
init|=
literal|0
decl_stmt|;
name|char
name|varbuf
index|[
literal|128
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|defaultname
decl_stmt|,
modifier|*
name|ignoreenvname
decl_stmt|;
comment|/* See if unsetenv works before we rely on it. */
name|setenv
argument_list|(
literal|"EVENT_NOWAFFLES"
argument_list|,
literal|"1"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|unsetenv
argument_list|(
literal|"EVENT_NOWAFFLES"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"EVENT_NOWAFFLES"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|EVENT__HAVE_UNSETENV
name|TT_DECLARE
argument_list|(
literal|"NOTE"
argument_list|,
operator|(
literal|"Can't fake unsetenv; skipping test"
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|TT_DECLARE
argument_list|(
literal|"NOTE"
argument_list|,
operator|(
literal|"unsetenv doesn't work; skipping test"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tt_skip
argument_list|()
expr_stmt|;
block|}
name|basenames
operator|=
name|event_get_supported_methods
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|basenames
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
name|methodname_to_envvar
argument_list|(
name|basenames
index|[
name|i
index|]
argument_list|,
name|varbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|varbuf
argument_list|)
argument_list|)
expr_stmt|;
name|unsetenv
argument_list|(
name|varbuf
argument_list|)
expr_stmt|;
operator|++
name|n_methods
expr_stmt|;
block|}
name|base
operator|=
name|event_base_new
argument_list|()
expr_stmt|;
name|tt_assert
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|defaultname
operator|=
name|event_base_get_method
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|TT_BLATHER
argument_list|(
operator|(
literal|"default is<%s>"
operator|,
name|defaultname
operator|)
argument_list|)
expr_stmt|;
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|NULL
expr_stmt|;
comment|/* Can we disable the method with EVENT_NOfoo ? */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|defaultname
argument_list|,
literal|"epoll (with changelist)"
argument_list|)
condition|)
block|{
name|setenv
argument_list|(
literal|"EVENT_NOEPOLL"
argument_list|,
literal|"1"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ignoreenvname
operator|=
literal|"epoll"
expr_stmt|;
block|}
else|else
block|{
name|methodname_to_envvar
argument_list|(
name|defaultname
argument_list|,
name|varbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|varbuf
argument_list|)
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
name|varbuf
argument_list|,
literal|"1"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ignoreenvname
operator|=
name|defaultname
expr_stmt|;
block|}
comment|/* Use an empty cfg rather than NULL so a failure doesn't exit() */
name|cfg
operator|=
name|event_config_new
argument_list|()
expr_stmt|;
name|base
operator|=
name|event_base_new_with_config
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|event_config_free
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|cfg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|n_methods
operator|==
literal|1
condition|)
block|{
name|tt_assert
argument_list|(
operator|!
name|base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_assert
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|defaultname
argument_list|,
operator|!=
argument_list|,
name|event_base_get_method
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Can we disable looking at the environment with IGNORE_ENV ? */
name|cfg
operator|=
name|event_config_new
argument_list|()
expr_stmt|;
name|event_config_set_flag
argument_list|(
name|cfg
argument_list|,
name|EVENT_BASE_FLAG_IGNORE_ENV
argument_list|)
expr_stmt|;
name|base
operator|=
name|event_base_new_with_config
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|tt_str_op
argument_list|(
name|ignoreenvname
argument_list|,
operator|==
argument_list|,
name|event_base_get_method
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|tt_skip
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|end
label|:
if|if
condition|(
name|base
condition|)
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
condition|)
name|event_config_free
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_called_once_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tt_int_op
argument_list|(
name|event
argument_list|,
operator|==
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|called
operator|+=
literal|1
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|timeout_called_once_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tt_int_op
argument_list|(
name|event
argument_list|,
operator|==
argument_list|,
name|EV_TIMEOUT
argument_list|)
expr_stmt|;
name|called
operator|+=
literal|100
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|immediate_called_twice_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tt_int_op
argument_list|(
name|event
argument_list|,
operator|==
argument_list|,
name|EV_TIMEOUT
argument_list|)
expr_stmt|;
name|called
operator|+=
literal|1000
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_event_once
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|r
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|50
operator|*
literal|1000
expr_stmt|;
name|called
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|event_base_once
argument_list|(
name|data
operator|->
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|0
index|]
argument_list|,
name|EV_READ
argument_list|,
name|read_called_once_cb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|event_base_once
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|timeout_called_once_cb
argument_list|,
name|NULL
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|event_base_once
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|<
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|event_base_once
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|immediate_called_twice_cb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|event_base_once
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|immediate_called_twice_cb
argument_list|,
name|NULL
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|r
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|,
name|TEST1
argument_list|,
name|strlen
argument_list|(
name|TEST1
argument_list|)
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tt_fail_perror
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
block|}
name|shutdown
argument_list|(
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|data
operator|->
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|called
argument_list|,
operator|==
argument_list|,
literal|2101
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_event_once_never
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* Have one trigger in 10 seconds (don't worry, because) */
name|tv
operator|.
name|tv_sec
operator|=
literal|10
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|called
operator|=
literal|0
expr_stmt|;
name|event_base_once
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|timeout_called_once_cb
argument_list|,
name|NULL
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
comment|/* But shut down the base in 75 msec. */
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|75
operator|*
literal|1000
expr_stmt|;
name|event_base_loopexit
argument_list|(
name|data
operator|->
name|base
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|data
operator|->
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|called
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_event_pending
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|ptr
decl_stmt|;
name|struct
name|event
modifier|*
name|r
init|=
name|NULL
decl_stmt|,
modifier|*
name|w
init|=
name|NULL
decl_stmt|,
modifier|*
name|t
init|=
name|NULL
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|,
name|now
decl_stmt|,
name|tv2
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|500
operator|*
literal|1000
expr_stmt|;
name|r
operator|=
name|event_new
argument_list|(
name|data
operator|->
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|0
index|]
argument_list|,
name|EV_READ
argument_list|,
name|simple_read_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|w
operator|=
name|event_new
argument_list|(
name|data
operator|->
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_WRITE
argument_list|,
name|simple_write_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|evtimer_new
argument_list|(
name|data
operator|->
name|base
argument_list|,
name|timeout_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|r
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|t
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|event_pending
argument_list|(
name|r
argument_list|,
name|EV_READ
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_pending
argument_list|(
name|w
argument_list|,
name|EV_WRITE
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_pending
argument_list|(
name|r
argument_list|,
name|EV_WRITE
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|event_pending
argument_list|(
name|r
argument_list|,
name|EV_READ
operator||
name|EV_WRITE
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
operator|!
name|event_pending
argument_list|(
name|r
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|event_pending
argument_list|(
name|t
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|event_pending
argument_list|(
name|t
argument_list|,
name|EV_TIMEOUT
argument_list|,
operator|&
name|tv2
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evutil_timercmp
argument_list|(
operator|&
name|tv2
argument_list|,
operator|&
name|now
argument_list|,
operator|>
argument_list|)
argument_list|)
expr_stmt|;
name|test_timeval_diff_eq
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|tv2
argument_list|,
literal|500
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|r
condition|)
block|{
name|event_del
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|event_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
condition|)
block|{
name|event_del
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|event_free
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
condition|)
block|{
name|event_del
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|event_free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_comment
comment|/* You can't do this test on windows, since dup2 doesn't work on sockets */
end_comment

begin_function
specifier|static
name|void
name|dfd_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|e
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|int
operator|)
name|e
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Regression test for our workaround for a fun epoll/linux related bug  * where fd2 = dup(fd1); add(fd2); close(fd2); dup2(fd1,fd2); add(fd2)  * will get you an EEXIST */
end_comment

begin_function
specifier|static
name|void
name|test_dup_fd
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|event
modifier|*
name|ev1
init|=
name|NULL
decl_stmt|,
modifier|*
name|ev2
init|=
name|NULL
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|dfd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ev1_got
decl_stmt|,
name|ev2_got
decl_stmt|;
name|tt_int_op
argument_list|(
name|write
argument_list|(
name|data
operator|->
name|pair
index|[
literal|0
index|]
argument_list|,
literal|"Hello world"
argument_list|,
name|strlen
argument_list|(
literal|"Hello world"
argument_list|)
argument_list|)
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fd
operator|=
name|data
operator|->
name|pair
index|[
literal|1
index|]
expr_stmt|;
name|dfd
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|dfd
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ev1
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|fd
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
name|dfd_cb
argument_list|,
operator|&
name|ev1_got
argument_list|)
expr_stmt|;
name|ev2
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|dfd
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
name|dfd_cb
argument_list|,
operator|&
name|ev2_got
argument_list|)
expr_stmt|;
name|ev1_got
operator|=
name|ev2_got
operator|=
literal|0
expr_stmt|;
name|event_add
argument_list|(
name|ev1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|ev2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_base_loop
argument_list|(
name|base
argument_list|,
name|EVLOOP_ONCE
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ev1_got
argument_list|,
operator|==
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ev2_got
argument_list|,
operator|==
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
comment|/* Now close and delete dfd then dispatch.  We need to do the 	 * dispatch here so that when we add it later, we think there 	 * was an intermediate delete. */
name|close
argument_list|(
name|dfd
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
name|ev2
argument_list|)
expr_stmt|;
name|ev1_got
operator|=
name|ev2_got
operator|=
literal|0
expr_stmt|;
name|event_base_loop
argument_list|(
name|base
argument_list|,
name|EVLOOP_ONCE
argument_list|)
expr_stmt|;
name|tt_want_int_op
argument_list|(
name|ev1_got
argument_list|,
operator|==
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ev2_got
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Re-duplicate the fd.  We need to get the same duplicated 	 * value that we closed to provoke the epoll quirk.  Also, we 	 * need to change the events to write, or else the old lingering 	 * read event will make the test pass whether the change was 	 * successful or not. */
name|tt_int_op
argument_list|(
name|dup2
argument_list|(
name|fd
argument_list|,
name|dfd
argument_list|)
argument_list|,
operator|==
argument_list|,
name|dfd
argument_list|)
expr_stmt|;
name|event_free
argument_list|(
name|ev2
argument_list|)
expr_stmt|;
name|ev2
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|dfd
argument_list|,
name|EV_WRITE
operator||
name|EV_PERSIST
argument_list|,
name|dfd_cb
argument_list|,
operator|&
name|ev2_got
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|ev2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ev1_got
operator|=
name|ev2_got
operator|=
literal|0
expr_stmt|;
name|event_base_loop
argument_list|(
name|base
argument_list|,
name|EVLOOP_ONCE
argument_list|)
expr_stmt|;
name|tt_want_int_op
argument_list|(
name|ev1_got
argument_list|,
operator|==
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|ev2_got
argument_list|,
operator|==
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|ev1
condition|)
name|event_free
argument_list|(
name|ev1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev2
condition|)
name|event_free
argument_list|(
name|ev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|dfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__DISABLE_MM_REPLACEMENT
end_ifdef

begin_function
specifier|static
name|void
name|test_mm_functions
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tinytest_set_test_skipped_
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|check_dummy_mem_ok
parameter_list|(
name|void
modifier|*
name|mem_
parameter_list|)
block|{
name|char
modifier|*
name|mem
init|=
name|mem_
decl_stmt|;
name|mem
operator|-=
literal|16
expr_stmt|;
return|return
operator|!
name|memcmp
argument_list|(
name|mem
argument_list|,
literal|"{[<guardedram>]}"
argument_list|,
literal|16
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|dummy_malloc
parameter_list|(
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|mem
init|=
name|malloc
argument_list|(
name|len
operator|+
literal|16
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|mem
argument_list|,
literal|"{[<guardedram>]}"
argument_list|,
literal|16
argument_list|)
expr_stmt|;
return|return
name|mem
operator|+
literal|16
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|dummy_realloc
parameter_list|(
name|void
modifier|*
name|mem_
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|mem
init|=
name|mem_
decl_stmt|;
if|if
condition|(
operator|!
name|mem
condition|)
return|return
name|dummy_malloc
argument_list|(
name|len
argument_list|)
return|;
name|tt_want
argument_list|(
name|check_dummy_mem_ok
argument_list|(
name|mem_
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|-=
literal|16
expr_stmt|;
name|mem
operator|=
name|realloc
argument_list|(
name|mem
argument_list|,
name|len
operator|+
literal|16
argument_list|)
expr_stmt|;
return|return
name|mem
operator|+
literal|16
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dummy_free
parameter_list|(
name|void
modifier|*
name|mem_
parameter_list|)
block|{
name|char
modifier|*
name|mem
init|=
name|mem_
decl_stmt|;
name|tt_want
argument_list|(
name|check_dummy_mem_ok
argument_list|(
name|mem_
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|-=
literal|16
expr_stmt|;
name|free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_mm_functions
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|struct
name|event_config
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|event_set_mem_functions
argument_list|(
name|dummy_malloc
argument_list|,
name|dummy_realloc
argument_list|,
name|dummy_free
argument_list|)
expr_stmt|;
name|cfg
operator|=
name|event_config_new
argument_list|()
expr_stmt|;
name|event_config_avoid_method
argument_list|(
name|cfg
argument_list|,
literal|"Nonesuch"
argument_list|)
expr_stmt|;
name|b
operator|=
name|event_base_new_with_config
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|check_dummy_mem_ok
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|cfg
condition|)
name|event_config_free
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
condition|)
name|event_base_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|many_event_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
modifier|*
name|calledp
init|=
name|arg
decl_stmt|;
operator|*
name|calledp
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_many_events
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* Try 70 events that should all be ready at once.  This will 	 * exercise the "resize" code on most of the backends, and will make 	 * sure that we can get past the 64-handle limit of some windows 	 * functions. */
define|#
directive|define
name|MANY
value|70
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|int
name|one_at_a_time
init|=
name|data
operator|->
name|setup_data
operator|!=
name|NULL
decl_stmt|;
name|evutil_socket_t
name|sock
index|[
name|MANY
index|]
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
index|[
name|MANY
index|]
decl_stmt|;
name|int
name|called
index|[
name|MANY
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|loopflags
init|=
name|EVLOOP_NONBLOCK
decl_stmt|,
name|evflags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|one_at_a_time
condition|)
block|{
name|loopflags
operator||=
name|EVLOOP_ONCE
expr_stmt|;
name|evflags
operator|=
name|EV_PERSIST
expr_stmt|;
block|}
name|memset
argument_list|(
name|sock
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|called
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|called
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MANY
condition|;
operator|++
name|i
control|)
block|{
comment|/* We need an event that will hit the backend, and that will 		 * be ready immediately.  "Send a datagram" is an easy 		 * instance of that. */
name|sock
index|[
name|i
index|]
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|sock
index|[
name|i
index|]
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|called
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ev
index|[
name|i
index|]
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|sock
index|[
name|i
index|]
argument_list|,
name|EV_WRITE
operator||
name|evflags
argument_list|,
name|many_event_cb
argument_list|,
operator|&
name|called
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|ev
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|one_at_a_time
condition|)
name|event_base_loop
argument_list|(
name|base
argument_list|,
name|EVLOOP_NONBLOCK
operator||
name|EVLOOP_ONCE
argument_list|)
expr_stmt|;
block|}
name|event_base_loop
argument_list|(
name|base
argument_list|,
name|loopflags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MANY
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|one_at_a_time
condition|)
name|tt_int_op
argument_list|(
name|called
index|[
name|i
index|]
argument_list|,
operator|==
argument_list|,
name|MANY
operator|-
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|tt_int_op
argument_list|(
name|called
index|[
name|i
index|]
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|end
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MANY
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ev
index|[
name|i
index|]
condition|)
name|event_free
argument_list|(
name|ev
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|evutil_closesocket
argument_list|(
name|sock
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|MANY
block|}
end_function

begin_function
specifier|static
name|void
name|test_struct_event_size
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tt_int_op
argument_list|(
name|event_get_struct_event_size
argument_list|()
argument_list|,
operator|<=
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_get_assignment
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|event
modifier|*
name|ev1
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
init|=
literal|"foo"
decl_stmt|;
name|struct
name|event_base
modifier|*
name|b
decl_stmt|;
name|evutil_socket_t
name|s
decl_stmt|;
name|short
name|what
decl_stmt|;
name|event_callback_fn
name|cb
decl_stmt|;
name|void
modifier|*
name|cb_arg
decl_stmt|;
name|ev1
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_READ
argument_list|,
name|dummy_read_cb
argument_list|,
operator|(
name|void
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
name|event_get_assignment
argument_list|(
name|ev1
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|what
argument_list|,
operator|&
name|cb
argument_list|,
operator|&
name|cb_arg
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|b
argument_list|,
operator|==
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|s
argument_list|,
operator|==
argument_list|,
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|what
argument_list|,
operator|==
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|cb
argument_list|,
operator|==
argument_list|,
name|dummy_read_cb
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|cb_arg
argument_list|,
operator|==
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Now make sure this doesn't crash. */
name|event_get_assignment
argument_list|(
name|ev1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|ev1
condition|)
name|event_free
argument_list|(
name|ev1
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|foreach_helper
block|{
name|int
name|count
decl_stmt|;
specifier|const
name|struct
name|event
modifier|*
name|ev
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|foreach_count_cb
parameter_list|(
specifier|const
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|foreach_helper
modifier|*
name|h
init|=
name|event_get_callback_arg
argument_list|(
name|ev
argument_list|)
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|event_get_callback
argument_list|(
name|ev
argument_list|)
operator|!=
name|timeout_cb
condition|)
return|return
literal|0
return|;
name|tt_ptr_op
argument_list|(
name|event_get_base
argument_list|(
name|ev
argument_list|)
argument_list|,
operator|==
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|tv
operator|->
name|tv_sec
argument_list|,
operator|==
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|h
operator|->
name|ev
operator|=
name|ev
expr_stmt|;
name|h
operator|->
name|count
operator|++
expr_stmt|;
return|return
literal|0
return|;
name|end
label|:
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|foreach_find_cb
parameter_list|(
specifier|const
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|struct
name|event
modifier|*
modifier|*
name|ev_out
init|=
name|arg
decl_stmt|;
name|struct
name|foreach_helper
modifier|*
name|h
init|=
name|event_get_callback_arg
argument_list|(
name|ev
argument_list|)
decl_stmt|;
if|if
condition|(
name|event_get_callback
argument_list|(
name|ev
argument_list|)
operator|!=
name|timeout_cb
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|h
operator|->
name|count
operator|==
literal|99
condition|)
block|{
operator|*
name|ev_out
operator|=
name|ev
expr_stmt|;
return|return
literal|101
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_event_foreach
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
index|[
literal|5
index|]
decl_stmt|;
name|struct
name|foreach_helper
name|visited
index|[
literal|5
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|timeval
name|ten_sec
init|=
block|{
literal|10
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|struct
name|event
modifier|*
name|ev_found
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
operator|++
name|i
control|)
block|{
name|visited
index|[
name|i
index|]
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|visited
index|[
name|i
index|]
operator|.
name|ev
operator|=
name|NULL
expr_stmt|;
name|ev
index|[
name|i
index|]
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|timeout_cb
argument_list|,
operator|&
name|visited
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|tt_int_op
argument_list|(
operator|-
literal|1
argument_list|,
operator|==
argument_list|,
name|event_base_foreach_event
argument_list|(
name|NULL
argument_list|,
name|foreach_count_cb
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
operator|-
literal|1
argument_list|,
operator|==
argument_list|,
name|event_base_foreach_event
argument_list|(
name|base
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|ev
index|[
literal|0
index|]
argument_list|,
operator|&
name|ten_sec
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|ev
index|[
literal|1
index|]
argument_list|,
operator|&
name|ten_sec
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
name|ev
index|[
literal|1
index|]
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
name|ev
index|[
literal|2
index|]
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|ev
index|[
literal|3
index|]
argument_list|,
operator|&
name|ten_sec
argument_list|)
expr_stmt|;
comment|/* Don't touch ev[4]. */
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|event_base_foreach_event
argument_list|(
name|base
argument_list|,
name|foreach_count_cb
argument_list|,
operator|&
name|ten_sec
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|1
argument_list|,
operator|==
argument_list|,
name|visited
index|[
literal|0
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|1
argument_list|,
operator|==
argument_list|,
name|visited
index|[
literal|1
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|1
argument_list|,
operator|==
argument_list|,
name|visited
index|[
literal|2
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|1
argument_list|,
operator|==
argument_list|,
name|visited
index|[
literal|3
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|ev
index|[
literal|0
index|]
argument_list|,
operator|==
argument_list|,
name|visited
index|[
literal|0
index|]
operator|.
name|ev
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|ev
index|[
literal|1
index|]
argument_list|,
operator|==
argument_list|,
name|visited
index|[
literal|1
index|]
operator|.
name|ev
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|ev
index|[
literal|2
index|]
argument_list|,
operator|==
argument_list|,
name|visited
index|[
literal|2
index|]
operator|.
name|ev
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|ev
index|[
literal|3
index|]
argument_list|,
operator|==
argument_list|,
name|visited
index|[
literal|3
index|]
operator|.
name|ev
argument_list|)
expr_stmt|;
name|visited
index|[
literal|2
index|]
operator|.
name|count
operator|=
literal|99
expr_stmt|;
name|tt_int_op
argument_list|(
literal|101
argument_list|,
operator|==
argument_list|,
name|event_base_foreach_event
argument_list|(
name|base
argument_list|,
name|foreach_find_cb
argument_list|,
operator|&
name|ev_found
argument_list|)
argument_list|)
expr_stmt|;
name|tt_ptr_op
argument_list|(
name|ev_found
argument_list|,
operator|==
argument_list|,
name|ev
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|end
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
operator|++
name|i
control|)
block|{
name|event_free
argument_list|(
name|ev
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|event_base
modifier|*
name|cached_time_base
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cached_time_reset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cached_time_sleep
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|cache_time_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|timeval
modifier|*
name|tv
init|=
name|arg
decl_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|event_base_gettimeofday_cached
argument_list|(
name|cached_time_base
argument_list|,
name|tv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached_time_sleep
condition|)
block|{
name|struct
name|timeval
name|delay
init|=
block|{
literal|0
block|,
literal|30
operator|*
literal|1000
block|}
decl_stmt|;
name|evutil_usleep_
argument_list|(
operator|&
name|delay
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cached_time_reset
condition|)
block|{
name|event_base_update_cache_time
argument_list|(
name|cached_time_base
argument_list|)
expr_stmt|;
block|}
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_gettimeofday_cached
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|event_config
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|NULL
decl_stmt|;
name|struct
name|timeval
name|tv1
decl_stmt|,
name|tv2
decl_stmt|,
name|tv3
decl_stmt|,
name|now
decl_stmt|;
name|struct
name|event
modifier|*
name|ev1
init|=
name|NULL
decl_stmt|,
modifier|*
name|ev2
init|=
name|NULL
decl_stmt|,
modifier|*
name|ev3
init|=
name|NULL
decl_stmt|;
name|int
name|cached_time_disable
init|=
name|strstr
argument_list|(
name|data
operator|->
name|setup_data
argument_list|,
literal|"disable"
argument_list|)
operator|!=
name|NULL
decl_stmt|;
name|cfg
operator|=
name|event_config_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|cached_time_disable
condition|)
block|{
name|event_config_set_flag
argument_list|(
name|cfg
argument_list|,
name|EVENT_BASE_FLAG_NO_CACHE_TIME
argument_list|)
expr_stmt|;
block|}
name|cached_time_base
operator|=
name|base
operator|=
name|event_base_new_with_config
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Try gettimeofday_cached outside of an event loop. */
name|evutil_gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|event_base_gettimeofday_cached
argument_list|(
name|NULL
argument_list|,
operator|&
name|tv1
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|event_base_gettimeofday_cached
argument_list|(
name|base
argument_list|,
operator|&
name|tv2
argument_list|)
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|timeval_msec_diff
argument_list|(
operator|&
name|tv1
argument_list|,
operator|&
name|tv2
argument_list|)
argument_list|,
operator|<
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|timeval_msec_diff
argument_list|(
operator|&
name|tv1
argument_list|,
operator|&
name|now
argument_list|)
argument_list|,
operator|<
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cached_time_reset
operator|=
name|strstr
argument_list|(
name|data
operator|->
name|setup_data
argument_list|,
literal|"reset"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|cached_time_sleep
operator|=
name|strstr
argument_list|(
name|data
operator|->
name|setup_data
argument_list|,
literal|"sleep"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|ev1
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|cache_time_cb
argument_list|,
operator|&
name|tv1
argument_list|)
expr_stmt|;
name|ev2
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|cache_time_cb
argument_list|,
operator|&
name|tv2
argument_list|)
expr_stmt|;
name|ev3
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|cache_time_cb
argument_list|,
operator|&
name|tv3
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
name|ev1
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
name|ev2
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
name|ev3
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached_time_reset
operator|&&
name|cached_time_sleep
condition|)
block|{
name|tt_int_op
argument_list|(
name|labs
argument_list|(
name|timeval_msec_diff
argument_list|(
operator|&
name|tv1
argument_list|,
operator|&
name|tv2
argument_list|)
argument_list|)
argument_list|,
operator|>
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|labs
argument_list|(
name|timeval_msec_diff
argument_list|(
operator|&
name|tv2
argument_list|,
operator|&
name|tv3
argument_list|)
argument_list|)
argument_list|,
operator|>
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cached_time_disable
operator|&&
name|cached_time_sleep
condition|)
block|{
name|tt_int_op
argument_list|(
name|labs
argument_list|(
name|timeval_msec_diff
argument_list|(
operator|&
name|tv1
argument_list|,
operator|&
name|tv2
argument_list|)
argument_list|)
argument_list|,
operator|>
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|labs
argument_list|(
name|timeval_msec_diff
argument_list|(
operator|&
name|tv2
argument_list|,
operator|&
name|tv3
argument_list|)
argument_list|)
argument_list|,
operator|>
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|cached_time_disable
condition|)
block|{
name|tt_assert
argument_list|(
name|evutil_timercmp
argument_list|(
operator|&
name|tv1
argument_list|,
operator|&
name|tv2
argument_list|,
operator|==
argument_list|)
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evutil_timercmp
argument_list|(
operator|&
name|tv2
argument_list|,
operator|&
name|tv3
argument_list|,
operator|==
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|end
label|:
if|if
condition|(
name|ev1
condition|)
name|event_free
argument_list|(
name|ev1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev2
condition|)
name|event_free
argument_list|(
name|ev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev3
condition|)
name|event_free
argument_list|(
name|ev3
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
condition|)
name|event_config_free
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tabf_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
modifier|*
name|ptr
init|=
name|arg
decl_stmt|;
operator|*
name|ptr
operator|=
name|what
expr_stmt|;
operator|*
name|ptr
operator|+=
literal|0x10000
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_active_by_fd
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|basic_test_data
modifier|*
name|data
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|data
operator|->
name|base
decl_stmt|;
name|struct
name|event
modifier|*
name|ev1
init|=
name|NULL
decl_stmt|,
modifier|*
name|ev2
init|=
name|NULL
decl_stmt|,
modifier|*
name|ev3
init|=
name|NULL
decl_stmt|,
modifier|*
name|ev4
init|=
name|NULL
decl_stmt|;
name|int
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|e3
decl_stmt|,
name|e4
decl_stmt|;
ifndef|#
directive|ifndef
name|_WIN32
name|struct
name|event
modifier|*
name|evsig
init|=
name|NULL
decl_stmt|;
name|int
name|es
decl_stmt|;
endif|#
directive|endif
name|struct
name|timeval
name|tenmin
init|=
block|{
literal|600
block|,
literal|0
block|}
decl_stmt|;
comment|/* Ensure no crash on nonexistent FD. */
name|event_base_active_by_fd
argument_list|(
name|base
argument_list|,
literal|1000
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
comment|/* Ensure no crash on bogus FD. */
name|event_base_active_by_fd
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
comment|/* Ensure no crash on nonexistent/bogus signal. */
name|event_base_active_by_signal
argument_list|(
name|base
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|event_base_active_by_signal
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|e1
operator|=
name|e2
operator|=
name|e3
operator|=
name|e4
operator|=
literal|0
expr_stmt|;
name|ev1
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|0
index|]
argument_list|,
name|EV_READ
argument_list|,
name|tabf_cb
argument_list|,
operator|&
name|e1
argument_list|)
expr_stmt|;
name|ev2
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|0
index|]
argument_list|,
name|EV_WRITE
argument_list|,
name|tabf_cb
argument_list|,
operator|&
name|e2
argument_list|)
expr_stmt|;
name|ev3
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_READ
argument_list|,
name|tabf_cb
argument_list|,
operator|&
name|e3
argument_list|)
expr_stmt|;
name|ev4
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_READ
argument_list|,
name|tabf_cb
argument_list|,
operator|&
name|e4
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ev1
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ev2
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ev3
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|ev4
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|_WIN32
name|evsig
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|SIGHUP
argument_list|,
name|EV_SIGNAL
argument_list|,
name|tabf_cb
argument_list|,
operator|&
name|es
argument_list|)
expr_stmt|;
name|tt_assert
argument_list|(
name|evsig
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|evsig
argument_list|,
operator|&
name|tenmin
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|event_add
argument_list|(
name|ev1
argument_list|,
operator|&
name|tenmin
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|ev2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|ev3
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|ev4
argument_list|,
operator|&
name|tenmin
argument_list|)
expr_stmt|;
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Trigger 2, 3, 4 */
name|event_base_active_by_fd
argument_list|(
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|0
index|]
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
name|event_base_active_by_fd
argument_list|(
name|base
argument_list|,
name|data
operator|->
name|pair
index|[
literal|1
index|]
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|_WIN32
name|event_base_active_by_signal
argument_list|(
name|base
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|event_base_assert_ok_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|event_base_loop
argument_list|(
name|base
argument_list|,
name|EVLOOP_ONCE
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|e1
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|e2
argument_list|,
operator|==
argument_list|,
name|EV_WRITE
operator||
literal|0x10000
argument_list|)
expr_stmt|;
name|tt_int_op
argument_list|(
name|e3
argument_list|,
operator|==
argument_list|,
name|EV_READ
operator||
literal|0x10000
argument_list|)
expr_stmt|;
comment|/* Mask out EV_WRITE here, since it could be genuinely writeable. */
name|tt_int_op
argument_list|(
operator|(
name|e4
operator|&
operator|~
name|EV_WRITE
operator|)
argument_list|,
operator|==
argument_list|,
name|EV_READ
operator||
literal|0x10000
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|_WIN32
name|tt_int_op
argument_list|(
name|es
argument_list|,
operator|==
argument_list|,
name|EV_SIGNAL
operator||
literal|0x10000
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|end
label|:
if|if
condition|(
name|ev1
condition|)
name|event_free
argument_list|(
name|ev1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev2
condition|)
name|event_free
argument_list|(
name|ev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev3
condition|)
name|event_free
argument_list|(
name|ev3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev4
condition|)
name|event_free
argument_list|(
name|ev4
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|_WIN32
if|if
condition|(
name|evsig
condition|)
name|event_free
argument_list|(
name|evsig
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|struct
name|testcase_t
name|main_testcases
index|[]
init|=
block|{
comment|/* Some converted-over tests */
block|{
literal|"methods"
block|,
name|test_methods
block|,
name|TT_FORK
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"version"
block|,
name|test_version
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
name|BASIC
argument_list|(
name|base_features
argument_list|,
name|TT_FORK
operator||
name|TT_NO_LOGS
argument_list|)
block|,
block|{
literal|"base_environ"
block|,
name|test_base_environ
block|,
name|TT_FORK
block|,
name|NULL
block|,
name|NULL
block|}
block|,
name|BASIC
argument_list|(
name|event_base_new
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_SOCKETPAIR
argument_list|)
block|,
name|BASIC
argument_list|(
name|free_active_base
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_SOCKETPAIR
argument_list|)
block|,
name|BASIC
argument_list|(
name|manipulate_active_events
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
argument_list|)
block|,
name|BASIC
argument_list|(
name|event_new_selfarg
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
argument_list|)
block|,
name|BASIC
argument_list|(
name|event_assign_selfarg
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
argument_list|)
block|,
name|BASIC
argument_list|(
name|event_base_get_num_events
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
argument_list|)
block|,
name|BASIC
argument_list|(
name|event_base_get_max_events
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
argument_list|)
block|,
name|BASIC
argument_list|(
name|bad_assign
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
operator||
name|TT_NO_LOGS
argument_list|)
block|,
name|BASIC
argument_list|(
name|bad_reentrant
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
operator||
name|TT_NO_LOGS
argument_list|)
block|,
name|BASIC
argument_list|(
name|active_later
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
operator||
name|TT_NEED_SOCKETPAIR
argument_list|)
block|,
name|BASIC
argument_list|(
name|event_remove_timeout
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
operator||
name|TT_NEED_SOCKETPAIR
argument_list|)
block|,
comment|/* These are still using the old API */
name|LEGACY
argument_list|(
name|persistent_timeout
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
argument_list|)
block|,
block|{
literal|"persistent_timeout_jump"
block|,
name|test_persistent_timeout_jump
block|,
name|TT_FORK
operator||
name|TT_NEED_BASE
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
block|{
literal|"persistent_active_timeout"
block|,
name|test_persistent_active_timeout
block|,
name|TT_FORK
operator||
name|TT_NEED_BASE
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
name|LEGACY
argument_list|(
name|priorities
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
argument_list|)
block|,
name|BASIC
argument_list|(
name|priority_active_inversion
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
argument_list|)
block|,
block|{
literal|"common_timeout"
block|,
name|test_common_timeout
block|,
name|TT_FORK
operator||
name|TT_NEED_BASE
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
comment|/* These legacy tests may not all need all of these flags. */
name|LEGACY
argument_list|(
name|simpleread
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|simpleread_multiple
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|simplewrite
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
block|{
literal|"simpleclose"
block|,
name|test_simpleclose
block|,
name|TT_FORK
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
name|LEGACY
argument_list|(
name|multiple
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|persistent
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|combined
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|simpletimeout
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|loopbreak
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|loopexit
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|loopexit_multiple
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|nonpersist_readd
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|multiple_events_for_same_fd
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|want_only_once
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
block|{
literal|"event_once"
block|,
name|test_event_once
block|,
name|TT_ISOLATED
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
block|{
literal|"event_once_never"
block|,
name|test_event_once_never
block|,
name|TT_ISOLATED
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
block|{
literal|"event_pending"
block|,
name|test_event_pending
block|,
name|TT_ISOLATED
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
ifndef|#
directive|ifndef
name|_WIN32
block|{
literal|"dup_fd"
block|,
name|test_dup_fd
block|,
name|TT_ISOLATED
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
endif|#
directive|endif
block|{
literal|"mm_functions"
block|,
name|test_mm_functions
block|,
name|TT_FORK
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"many_events"
block|,
name|test_many_events
block|,
name|TT_ISOLATED
block|,
operator|&
name|basic_setup
block|,
name|NULL
block|}
block|,
block|{
literal|"many_events_slow_add"
block|,
name|test_many_events
block|,
name|TT_ISOLATED
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|1
block|}
block|,
block|{
literal|"struct_event_size"
block|,
name|test_struct_event_size
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
name|BASIC
argument_list|(
name|get_assignment
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
operator||
name|TT_NEED_SOCKETPAIR
argument_list|)
block|,
name|BASIC
argument_list|(
name|event_foreach
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
argument_list|)
block|,
block|{
literal|"gettimeofday_cached"
block|,
name|test_gettimeofday_cached
block|,
name|TT_FORK
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|""
block|}
block|,
block|{
literal|"gettimeofday_cached_sleep"
block|,
name|test_gettimeofday_cached
block|,
name|TT_FORK
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"sleep"
block|}
block|,
block|{
literal|"gettimeofday_cached_reset"
block|,
name|test_gettimeofday_cached
block|,
name|TT_FORK
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"sleep reset"
block|}
block|,
block|{
literal|"gettimeofday_cached_disabled"
block|,
name|test_gettimeofday_cached
block|,
name|TT_FORK
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"sleep disable"
block|}
block|,
block|{
literal|"gettimeofday_cached_disabled_nosleep"
block|,
name|test_gettimeofday_cached
block|,
name|TT_FORK
block|,
operator|&
name|basic_setup
block|,
operator|(
name|void
operator|*
operator|)
literal|"disable"
block|}
block|,
name|BASIC
argument_list|(
name|active_by_fd
argument_list|,
name|TT_FORK
operator||
name|TT_NEED_BASE
operator||
name|TT_NEED_SOCKETPAIR
argument_list|)
block|,
ifndef|#
directive|ifndef
name|_WIN32
name|LEGACY
argument_list|(
name|fork
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
endif|#
directive|endif
name|END_OF_TESTCASES
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|testcase_t
name|evtag_testcases
index|[]
init|=
block|{
block|{
literal|"int"
block|,
name|evtag_int_test
block|,
name|TT_FORK
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"fuzz"
block|,
name|evtag_fuzz
block|,
name|TT_FORK
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"encoding"
block|,
name|evtag_tag_encoding
block|,
name|TT_FORK
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
literal|"peek"
block|,
name|evtag_test_peek
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
name|END_OF_TESTCASES
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|testcase_t
name|signal_testcases
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|_WIN32
name|LEGACY
argument_list|(
name|simplesignal
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|multiplesignal
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|immediatesignal
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|signal_dealloc
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|signal_pipeloss
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|signal_switchbase
argument_list|,
name|TT_ISOLATED
operator||
name|TT_NO_LOGS
argument_list|)
block|,
name|LEGACY
argument_list|(
name|signal_restore
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|signal_assert
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
name|LEGACY
argument_list|(
name|signal_while_processing
argument_list|,
name|TT_ISOLATED
argument_list|)
block|,
endif|#
directive|endif
name|END_OF_TESTCASES
block|}
decl_stmt|;
end_decl_stmt

end_unit

