begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2007 Niels Provos<provos@citi.umich.edu>  * Copyright (c) 2007-2012 Niels Provos, Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_STDARG_H
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer_compat.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent_compat.h"
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event-internal.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|"mm-internal.h"
end_include

begin_include
include|#
directive|include
file|"bufferevent-internal.h"
end_include

begin_include
include|#
directive|include
file|"evbuffer-internal.h"
end_include

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_function_decl
specifier|static
name|void
name|bufferevent_cancel_all_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bufferevent_finalize_cb_
parameter_list|(
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|,
name|void
modifier|*
name|arg_
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|bufferevent_suspend_read_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|bufferevent_suspend_flags
name|what
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bufev_private
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bufev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufev_private
operator|->
name|read_suspended
condition|)
name|bufev
operator|->
name|be_ops
operator|->
name|disable
argument_list|(
name|bufev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|bufev_private
operator|->
name|read_suspended
operator||=
name|what
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bufferevent_unsuspend_read_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|bufferevent_suspend_flags
name|what
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bufev_private
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bufev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
name|bufev_private
operator|->
name|read_suspended
operator|&=
operator|~
name|what
expr_stmt|;
if|if
condition|(
operator|!
name|bufev_private
operator|->
name|read_suspended
operator|&&
operator|(
name|bufev
operator|->
name|enabled
operator|&
name|EV_READ
operator|)
condition|)
name|bufev
operator|->
name|be_ops
operator|->
name|enable
argument_list|(
name|bufev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bufferevent_suspend_write_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|bufferevent_suspend_flags
name|what
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bufev_private
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bufev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufev_private
operator|->
name|write_suspended
condition|)
name|bufev
operator|->
name|be_ops
operator|->
name|disable
argument_list|(
name|bufev
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
name|bufev_private
operator|->
name|write_suspended
operator||=
name|what
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bufferevent_unsuspend_write_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|bufferevent_suspend_flags
name|what
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bufev_private
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bufev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
name|bufev_private
operator|->
name|write_suspended
operator|&=
operator|~
name|what
expr_stmt|;
if|if
condition|(
operator|!
name|bufev_private
operator|->
name|write_suspended
operator|&&
operator|(
name|bufev
operator|->
name|enabled
operator|&
name|EV_WRITE
operator|)
condition|)
name|bufev
operator|->
name|be_ops
operator|->
name|enable
argument_list|(
name|bufev
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callback to implement watermarks on the input buffer.  Only enabled  * if the watermark is set. */
end_comment

begin_function
specifier|static
name|void
name|bufferevent_inbuf_wm_cb
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|evbuffer_cb_info
modifier|*
name|cbinfo
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|bufev
init|=
name|arg
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|size
operator|=
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|bufev
operator|->
name|wm_read
operator|.
name|high
condition|)
name|bufferevent_wm_suspend_read
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
else|else
name|bufferevent_wm_unsuspend_read
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bufferevent_run_deferred_callbacks_locked
parameter_list|(
name|struct
name|event_callback
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bufev_private
init|=
name|arg
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bufev
init|=
operator|&
name|bufev_private
operator|->
name|bev
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bufev_private
operator|->
name|eventcb_pending
operator|&
name|BEV_EVENT_CONNECTED
operator|)
operator|&&
name|bufev
operator|->
name|errorcb
condition|)
block|{
comment|/* The "connected" happened before any reads or writes, so 		   send it first. */
name|bufev_private
operator|->
name|eventcb_pending
operator|&=
operator|~
name|BEV_EVENT_CONNECTED
expr_stmt|;
name|bufev
operator|->
name|errorcb
argument_list|(
name|bufev
argument_list|,
name|BEV_EVENT_CONNECTED
argument_list|,
name|bufev
operator|->
name|cbarg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bufev_private
operator|->
name|readcb_pending
operator|&&
name|bufev
operator|->
name|readcb
condition|)
block|{
name|bufev_private
operator|->
name|readcb_pending
operator|=
literal|0
expr_stmt|;
name|bufev
operator|->
name|readcb
argument_list|(
name|bufev
argument_list|,
name|bufev
operator|->
name|cbarg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bufev_private
operator|->
name|writecb_pending
operator|&&
name|bufev
operator|->
name|writecb
condition|)
block|{
name|bufev_private
operator|->
name|writecb_pending
operator|=
literal|0
expr_stmt|;
name|bufev
operator|->
name|writecb
argument_list|(
name|bufev
argument_list|,
name|bufev
operator|->
name|cbarg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bufev_private
operator|->
name|eventcb_pending
operator|&&
name|bufev
operator|->
name|errorcb
condition|)
block|{
name|short
name|what
init|=
name|bufev_private
operator|->
name|eventcb_pending
decl_stmt|;
name|int
name|err
init|=
name|bufev_private
operator|->
name|errno_pending
decl_stmt|;
name|bufev_private
operator|->
name|eventcb_pending
operator|=
literal|0
expr_stmt|;
name|bufev_private
operator|->
name|errno_pending
operator|=
literal|0
expr_stmt|;
name|EVUTIL_SET_SOCKET_ERROR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|bufev
operator|->
name|errorcb
argument_list|(
name|bufev
argument_list|,
name|what
argument_list|,
name|bufev
operator|->
name|cbarg
argument_list|)
expr_stmt|;
block|}
name|bufferevent_decref_and_unlock_
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bufferevent_run_deferred_callbacks_unlocked
parameter_list|(
name|struct
name|event_callback
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bufev_private
init|=
name|arg
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bufev
init|=
operator|&
name|bufev_private
operator|->
name|bev
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
define|#
directive|define
name|UNLOCKED
parameter_list|(
name|stmt
parameter_list|)
define|\
value|do { BEV_UNLOCK(bufev); stmt; BEV_LOCK(bufev); } while(0)
if|if
condition|(
operator|(
name|bufev_private
operator|->
name|eventcb_pending
operator|&
name|BEV_EVENT_CONNECTED
operator|)
operator|&&
name|bufev
operator|->
name|errorcb
condition|)
block|{
comment|/* The "connected" happened before any reads or writes, so 		   send it first. */
name|bufferevent_event_cb
name|errorcb
init|=
name|bufev
operator|->
name|errorcb
decl_stmt|;
name|void
modifier|*
name|cbarg
init|=
name|bufev
operator|->
name|cbarg
decl_stmt|;
name|bufev_private
operator|->
name|eventcb_pending
operator|&=
operator|~
name|BEV_EVENT_CONNECTED
expr_stmt|;
name|UNLOCKED
argument_list|(
name|errorcb
argument_list|(
name|bufev
argument_list|,
name|BEV_EVENT_CONNECTED
argument_list|,
name|cbarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bufev_private
operator|->
name|readcb_pending
operator|&&
name|bufev
operator|->
name|readcb
condition|)
block|{
name|bufferevent_data_cb
name|readcb
init|=
name|bufev
operator|->
name|readcb
decl_stmt|;
name|void
modifier|*
name|cbarg
init|=
name|bufev
operator|->
name|cbarg
decl_stmt|;
name|bufev_private
operator|->
name|readcb_pending
operator|=
literal|0
expr_stmt|;
name|UNLOCKED
argument_list|(
name|readcb
argument_list|(
name|bufev
argument_list|,
name|cbarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bufev_private
operator|->
name|writecb_pending
operator|&&
name|bufev
operator|->
name|writecb
condition|)
block|{
name|bufferevent_data_cb
name|writecb
init|=
name|bufev
operator|->
name|writecb
decl_stmt|;
name|void
modifier|*
name|cbarg
init|=
name|bufev
operator|->
name|cbarg
decl_stmt|;
name|bufev_private
operator|->
name|writecb_pending
operator|=
literal|0
expr_stmt|;
name|UNLOCKED
argument_list|(
name|writecb
argument_list|(
name|bufev
argument_list|,
name|cbarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bufev_private
operator|->
name|eventcb_pending
operator|&&
name|bufev
operator|->
name|errorcb
condition|)
block|{
name|bufferevent_event_cb
name|errorcb
init|=
name|bufev
operator|->
name|errorcb
decl_stmt|;
name|void
modifier|*
name|cbarg
init|=
name|bufev
operator|->
name|cbarg
decl_stmt|;
name|short
name|what
init|=
name|bufev_private
operator|->
name|eventcb_pending
decl_stmt|;
name|int
name|err
init|=
name|bufev_private
operator|->
name|errno_pending
decl_stmt|;
name|bufev_private
operator|->
name|eventcb_pending
operator|=
literal|0
expr_stmt|;
name|bufev_private
operator|->
name|errno_pending
operator|=
literal|0
expr_stmt|;
name|EVUTIL_SET_SOCKET_ERROR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|UNLOCKED
argument_list|(
name|errorcb
argument_list|(
name|bufev
argument_list|,
name|what
argument_list|,
name|cbarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bufferevent_decref_and_unlock_
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|UNLOCKED
block|}
end_function

begin_define
define|#
directive|define
name|SCHEDULE_DEFERRED
parameter_list|(
name|bevp
parameter_list|)
define|\
value|do {								\ 		if (event_deferred_cb_schedule_(			\ 			    (bevp)->bev.ev_base,			\&(bevp)->deferred))				\ 			bufferevent_incref_(&(bevp)->bev);		\ 	} while (0)
end_define

begin_function
name|void
name|bufferevent_run_readcb_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|int
name|options
parameter_list|)
block|{
comment|/* Requires that we hold the lock and a reference */
name|struct
name|bufferevent_private
modifier|*
name|p
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bufev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufev
operator|->
name|readcb
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|p
operator|->
name|options
operator||
name|options
operator|)
operator|&
name|BEV_OPT_DEFER_CALLBACKS
condition|)
block|{
name|p
operator|->
name|readcb_pending
operator|=
literal|1
expr_stmt|;
name|SCHEDULE_DEFERRED
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bufev
operator|->
name|readcb
argument_list|(
name|bufev
argument_list|,
name|bufev
operator|->
name|cbarg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bufferevent_run_writecb_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|int
name|options
parameter_list|)
block|{
comment|/* Requires that we hold the lock and a reference */
name|struct
name|bufferevent_private
modifier|*
name|p
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bufev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufev
operator|->
name|writecb
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|p
operator|->
name|options
operator||
name|options
operator|)
operator|&
name|BEV_OPT_DEFER_CALLBACKS
condition|)
block|{
name|p
operator|->
name|writecb_pending
operator|=
literal|1
expr_stmt|;
name|SCHEDULE_DEFERRED
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bufev
operator|->
name|writecb
argument_list|(
name|bufev
argument_list|,
name|bufev
operator|->
name|cbarg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|BEV_TRIG_ALL_OPTS
value|(			\ 		BEV_TRIG_IGNORE_WATERMARKS|	\ 		BEV_TRIG_DEFER_CALLBACKS	\ 	)
end_define

begin_function
name|void
name|bufferevent_trigger
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|short
name|iotype
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|bufferevent_incref_and_lock_
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
name|bufferevent_trigger_nolock_
argument_list|(
name|bufev
argument_list|,
name|iotype
argument_list|,
name|options
operator|&
name|BEV_TRIG_ALL_OPTS
argument_list|)
expr_stmt|;
name|bufferevent_decref_and_unlock_
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bufferevent_run_eventcb_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|short
name|what
parameter_list|,
name|int
name|options
parameter_list|)
block|{
comment|/* Requires that we hold the lock and a reference */
name|struct
name|bufferevent_private
modifier|*
name|p
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bufev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufev
operator|->
name|errorcb
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|p
operator|->
name|options
operator||
name|options
operator|)
operator|&
name|BEV_OPT_DEFER_CALLBACKS
condition|)
block|{
name|p
operator|->
name|eventcb_pending
operator||=
name|what
expr_stmt|;
name|p
operator|->
name|errno_pending
operator|=
name|EVUTIL_SOCKET_ERROR
argument_list|()
expr_stmt|;
name|SCHEDULE_DEFERRED
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bufev
operator|->
name|errorcb
argument_list|(
name|bufev
argument_list|,
name|what
argument_list|,
name|bufev
operator|->
name|cbarg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bufferevent_trigger_event
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|short
name|what
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|bufferevent_incref_and_lock_
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
name|bufferevent_run_eventcb_
argument_list|(
name|bufev
argument_list|,
name|what
argument_list|,
name|options
operator|&
name|BEV_TRIG_ALL_OPTS
argument_list|)
expr_stmt|;
name|bufferevent_decref_and_unlock_
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bufferevent_init_common_
parameter_list|(
name|struct
name|bufferevent_private
modifier|*
name|bufev_private
parameter_list|,
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
specifier|const
name|struct
name|bufferevent_ops
modifier|*
name|ops
parameter_list|,
name|enum
name|bufferevent_options
name|options
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|bufev
init|=
operator|&
name|bufev_private
operator|->
name|bev
decl_stmt|;
if|if
condition|(
operator|!
name|bufev
operator|->
name|input
condition|)
block|{
if|if
condition|(
operator|(
name|bufev
operator|->
name|input
operator|=
name|evbuffer_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|bufev
operator|->
name|output
condition|)
block|{
if|if
condition|(
operator|(
name|bufev
operator|->
name|output
operator|=
name|evbuffer_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|evbuffer_free
argument_list|(
name|bufev
operator|->
name|input
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|bufev_private
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|bufev
operator|->
name|ev_base
operator|=
name|base
expr_stmt|;
comment|/* Disable timeouts. */
name|evutil_timerclear
argument_list|(
operator|&
name|bufev
operator|->
name|timeout_read
argument_list|)
expr_stmt|;
name|evutil_timerclear
argument_list|(
operator|&
name|bufev
operator|->
name|timeout_write
argument_list|)
expr_stmt|;
name|bufev
operator|->
name|be_ops
operator|=
name|ops
expr_stmt|;
name|bufferevent_ratelim_init_
argument_list|(
name|bufev_private
argument_list|)
expr_stmt|;
comment|/* 	 * Set to EV_WRITE so that using bufferevent_write is going to 	 * trigger a callback.  Reading needs to be explicitly enabled 	 * because otherwise no data will be available. 	 */
name|bufev
operator|->
name|enabled
operator|=
name|EV_WRITE
expr_stmt|;
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
if|if
condition|(
name|options
operator|&
name|BEV_OPT_THREADSAFE
condition|)
block|{
if|if
condition|(
name|bufferevent_enable_locking_
argument_list|(
name|bufev
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* cleanup */
name|evbuffer_free
argument_list|(
name|bufev
operator|->
name|input
argument_list|)
expr_stmt|;
name|evbuffer_free
argument_list|(
name|bufev
operator|->
name|output
argument_list|)
expr_stmt|;
name|bufev
operator|->
name|input
operator|=
name|NULL
expr_stmt|;
name|bufev
operator|->
name|output
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|options
operator|&
operator|(
name|BEV_OPT_DEFER_CALLBACKS
operator||
name|BEV_OPT_UNLOCK_CALLBACKS
operator|)
operator|)
operator|==
name|BEV_OPT_UNLOCK_CALLBACKS
condition|)
block|{
name|event_warnx
argument_list|(
literal|"UNLOCK_CALLBACKS requires DEFER_CALLBACKS"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|options
operator|&
name|BEV_OPT_UNLOCK_CALLBACKS
condition|)
name|event_deferred_cb_init_
argument_list|(
operator|&
name|bufev_private
operator|->
name|deferred
argument_list|,
name|event_base_get_npriorities
argument_list|(
name|base
argument_list|)
operator|/
literal|2
argument_list|,
name|bufferevent_run_deferred_callbacks_unlocked
argument_list|,
name|bufev_private
argument_list|)
expr_stmt|;
else|else
name|event_deferred_cb_init_
argument_list|(
operator|&
name|bufev_private
operator|->
name|deferred
argument_list|,
name|event_base_get_npriorities
argument_list|(
name|base
argument_list|)
operator|/
literal|2
argument_list|,
name|bufferevent_run_deferred_callbacks_locked
argument_list|,
name|bufev_private
argument_list|)
expr_stmt|;
name|bufev_private
operator|->
name|options
operator|=
name|options
expr_stmt|;
name|evbuffer_set_parent_
argument_list|(
name|bufev
operator|->
name|input
argument_list|,
name|bufev
argument_list|)
expr_stmt|;
name|evbuffer_set_parent_
argument_list|(
name|bufev
operator|->
name|output
argument_list|,
name|bufev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|bufferevent_setcb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|bufferevent_data_cb
name|readcb
parameter_list|,
name|bufferevent_data_cb
name|writecb
parameter_list|,
name|bufferevent_event_cb
name|eventcb
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|)
block|{
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
name|bufev
operator|->
name|readcb
operator|=
name|readcb
expr_stmt|;
name|bufev
operator|->
name|writecb
operator|=
name|writecb
expr_stmt|;
name|bufev
operator|->
name|errorcb
operator|=
name|eventcb
expr_stmt|;
name|bufev
operator|->
name|cbarg
operator|=
name|cbarg
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bufferevent_getcb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|bufferevent_data_cb
modifier|*
name|readcb_ptr
parameter_list|,
name|bufferevent_data_cb
modifier|*
name|writecb_ptr
parameter_list|,
name|bufferevent_event_cb
modifier|*
name|eventcb_ptr
parameter_list|,
name|void
modifier|*
modifier|*
name|cbarg_ptr
parameter_list|)
block|{
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
if|if
condition|(
name|readcb_ptr
condition|)
operator|*
name|readcb_ptr
operator|=
name|bufev
operator|->
name|readcb
expr_stmt|;
if|if
condition|(
name|writecb_ptr
condition|)
operator|*
name|writecb_ptr
operator|=
name|bufev
operator|->
name|writecb
expr_stmt|;
if|if
condition|(
name|eventcb_ptr
condition|)
operator|*
name|eventcb_ptr
operator|=
name|bufev
operator|->
name|errorcb
expr_stmt|;
if|if
condition|(
name|cbarg_ptr
condition|)
operator|*
name|cbarg_ptr
operator|=
name|bufev
operator|->
name|cbarg
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|evbuffer
modifier|*
name|bufferevent_get_input
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|)
block|{
return|return
name|bufev
operator|->
name|input
return|;
block|}
end_function

begin_function
name|struct
name|evbuffer
modifier|*
name|bufferevent_get_output
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|)
block|{
return|return
name|bufev
operator|->
name|output
return|;
block|}
end_function

begin_function
name|struct
name|event_base
modifier|*
name|bufferevent_get_base
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|)
block|{
return|return
name|bufev
operator|->
name|ev_base
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_get_priority
parameter_list|(
specifier|const
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|)
block|{
if|if
condition|(
name|event_initialized
argument_list|(
operator|&
name|bufev
operator|->
name|ev_read
argument_list|)
condition|)
block|{
return|return
name|event_get_priority
argument_list|(
operator|&
name|bufev
operator|->
name|ev_read
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|event_base_get_npriorities
argument_list|(
name|bufev
operator|->
name|ev_base
argument_list|)
operator|/
literal|2
return|;
block|}
block|}
end_function

begin_function
name|int
name|bufferevent_write
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|evbuffer_add
argument_list|(
name|bufev
operator|->
name|output
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_write_buffer
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|evbuffer_add_buffer
argument_list|(
name|bufev
operator|->
name|output
argument_list|,
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|size_t
name|bufferevent_read
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|evbuffer_remove
argument_list|(
name|bufev
operator|->
name|input
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_read_buffer
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
name|evbuffer_add_buffer
argument_list|(
name|buf
argument_list|,
name|bufev
operator|->
name|input
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_enable
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|short
name|event
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bufev_private
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bufev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
name|short
name|impl_events
init|=
name|event
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|bufferevent_incref_and_lock_
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufev_private
operator|->
name|read_suspended
condition|)
name|impl_events
operator|&=
operator|~
name|EV_READ
expr_stmt|;
if|if
condition|(
name|bufev_private
operator|->
name|write_suspended
condition|)
name|impl_events
operator|&=
operator|~
name|EV_WRITE
expr_stmt|;
name|bufev
operator|->
name|enabled
operator||=
name|event
expr_stmt|;
if|if
condition|(
name|impl_events
operator|&&
name|bufev
operator|->
name|be_ops
operator|->
name|enable
argument_list|(
name|bufev
argument_list|,
name|impl_events
argument_list|)
operator|<
literal|0
condition|)
name|r
operator|=
operator|-
literal|1
expr_stmt|;
name|bufferevent_decref_and_unlock_
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_set_timeouts
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tv_read
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tv_write
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
if|if
condition|(
name|tv_read
condition|)
block|{
name|bufev
operator|->
name|timeout_read
operator|=
operator|*
name|tv_read
expr_stmt|;
block|}
else|else
block|{
name|evutil_timerclear
argument_list|(
operator|&
name|bufev
operator|->
name|timeout_read
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tv_write
condition|)
block|{
name|bufev
operator|->
name|timeout_write
operator|=
operator|*
name|tv_write
expr_stmt|;
block|}
else|else
block|{
name|evutil_timerclear
argument_list|(
operator|&
name|bufev
operator|->
name|timeout_write
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bufev
operator|->
name|be_ops
operator|->
name|adj_timeouts
condition|)
name|r
operator|=
name|bufev
operator|->
name|be_ops
operator|->
name|adj_timeouts
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Obsolete; use bufferevent_set_timeouts */
end_comment

begin_function
name|void
name|bufferevent_settimeout
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|int
name|timeout_read
parameter_list|,
name|int
name|timeout_write
parameter_list|)
block|{
name|struct
name|timeval
name|tv_read
decl_stmt|,
name|tv_write
decl_stmt|;
name|struct
name|timeval
modifier|*
name|ptv_read
init|=
name|NULL
decl_stmt|,
modifier|*
name|ptv_write
init|=
name|NULL
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tv_read
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tv_read
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tv_write
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tv_write
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout_read
condition|)
block|{
name|tv_read
operator|.
name|tv_sec
operator|=
name|timeout_read
expr_stmt|;
name|ptv_read
operator|=
operator|&
name|tv_read
expr_stmt|;
block|}
if|if
condition|(
name|timeout_write
condition|)
block|{
name|tv_write
operator|.
name|tv_sec
operator|=
name|timeout_write
expr_stmt|;
name|ptv_write
operator|=
operator|&
name|tv_write
expr_stmt|;
block|}
name|bufferevent_set_timeouts
argument_list|(
name|bufev
argument_list|,
name|ptv_read
argument_list|,
name|ptv_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bufferevent_disable_hard_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|short
name|event
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|struct
name|bufferevent_private
modifier|*
name|bufev_private
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bufev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
name|bufev
operator|->
name|enabled
operator|&=
operator|~
name|event
expr_stmt|;
name|bufev_private
operator|->
name|connecting
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bufev
operator|->
name|be_ops
operator|->
name|disable
argument_list|(
name|bufev
argument_list|,
name|event
argument_list|)
operator|<
literal|0
condition|)
name|r
operator|=
operator|-
literal|1
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_disable
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|short
name|event
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
name|bufev
operator|->
name|enabled
operator|&=
operator|~
name|event
expr_stmt|;
if|if
condition|(
name|bufev
operator|->
name|be_ops
operator|->
name|disable
argument_list|(
name|bufev
argument_list|,
name|event
argument_list|)
operator|<
literal|0
condition|)
name|r
operator|=
operator|-
literal|1
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Sets the water marks  */
end_comment

begin_function
name|void
name|bufferevent_setwatermark
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|short
name|events
parameter_list|,
name|size_t
name|lowmark
parameter_list|,
name|size_t
name|highmark
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bufev_private
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bufev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|EV_WRITE
condition|)
block|{
name|bufev
operator|->
name|wm_write
operator|.
name|low
operator|=
name|lowmark
expr_stmt|;
name|bufev
operator|->
name|wm_write
operator|.
name|high
operator|=
name|highmark
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
name|EV_READ
condition|)
block|{
name|bufev
operator|->
name|wm_read
operator|.
name|low
operator|=
name|lowmark
expr_stmt|;
name|bufev
operator|->
name|wm_read
operator|.
name|high
operator|=
name|highmark
expr_stmt|;
if|if
condition|(
name|highmark
condition|)
block|{
comment|/* There is now a new high-water mark for read. 			   enable the callback if needed, and see if we should 			   suspend/bufferevent_wm_unsuspend. */
if|if
condition|(
name|bufev_private
operator|->
name|read_watermarks_cb
operator|==
name|NULL
condition|)
block|{
name|bufev_private
operator|->
name|read_watermarks_cb
operator|=
name|evbuffer_add_cb
argument_list|(
name|bufev
operator|->
name|input
argument_list|,
name|bufferevent_inbuf_wm_cb
argument_list|,
name|bufev
argument_list|)
expr_stmt|;
block|}
name|evbuffer_cb_set_flags
argument_list|(
name|bufev
operator|->
name|input
argument_list|,
name|bufev_private
operator|->
name|read_watermarks_cb
argument_list|,
name|EVBUFFER_CB_ENABLED
operator||
name|EVBUFFER_CB_NODEFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|evbuffer_get_length
argument_list|(
name|bufev
operator|->
name|input
argument_list|)
operator|>=
name|highmark
condition|)
name|bufferevent_wm_suspend_read
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|evbuffer_get_length
argument_list|(
name|bufev
operator|->
name|input
argument_list|)
operator|<
name|highmark
condition|)
name|bufferevent_wm_unsuspend_read
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* There is now no high-water mark for read. */
if|if
condition|(
name|bufev_private
operator|->
name|read_watermarks_cb
condition|)
name|evbuffer_cb_clear_flags
argument_list|(
name|bufev
operator|->
name|input
argument_list|,
name|bufev_private
operator|->
name|read_watermarks_cb
argument_list|,
name|EVBUFFER_CB_ENABLED
argument_list|)
expr_stmt|;
name|bufferevent_wm_unsuspend_read
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
block|}
block|}
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bufferevent_getwatermark
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|short
name|events
parameter_list|,
name|size_t
modifier|*
name|lowmark
parameter_list|,
name|size_t
modifier|*
name|highmark
parameter_list|)
block|{
if|if
condition|(
name|events
operator|==
name|EV_WRITE
condition|)
block|{
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowmark
condition|)
operator|*
name|lowmark
operator|=
name|bufev
operator|->
name|wm_write
operator|.
name|low
expr_stmt|;
if|if
condition|(
name|highmark
condition|)
operator|*
name|highmark
operator|=
name|bufev
operator|->
name|wm_write
operator|.
name|high
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|events
operator|==
name|EV_READ
condition|)
block|{
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowmark
condition|)
operator|*
name|lowmark
operator|=
name|bufev
operator|->
name|wm_read
operator|.
name|low
expr_stmt|;
if|if
condition|(
name|highmark
condition|)
operator|*
name|highmark
operator|=
name|bufev
operator|->
name|wm_read
operator|.
name|high
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_flush
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|short
name|iotype
parameter_list|,
name|enum
name|bufferevent_flush_mode
name|mode
parameter_list|)
block|{
name|int
name|r
init|=
operator|-
literal|1
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufev
operator|->
name|be_ops
operator|->
name|flush
condition|)
name|r
operator|=
name|bufev
operator|->
name|be_ops
operator|->
name|flush
argument_list|(
name|bufev
argument_list|,
name|iotype
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|bufferevent_incref_and_lock_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bufev_private
init|=
name|BEV_UPCAST
argument_list|(
name|bufev
argument_list|)
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
operator|++
name|bufev_private
operator|->
name|refcnt
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void bufferevent_transfer_lock_ownership_(struct bufferevent *donor,     struct bufferevent *recipient) { 	struct bufferevent_private *d = BEV_UPCAST(donor); 	struct bufferevent_private *r = BEV_UPCAST(recipient); 	if (d->lock != r->lock) 		return; 	if (r->own_lock) 		return; 	if (d->own_lock) { 		d->own_lock = 0; 		r->own_lock = 1; 	} }
endif|#
directive|endif
end_endif

begin_function
name|int
name|bufferevent_decref_and_unlock_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bufev_private
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bufev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
name|int
name|n_cbs
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|MAX_CBS
value|16
name|struct
name|event_callback
modifier|*
name|cbs
index|[
name|MAX_CBS
index|]
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|bufev_private
operator|->
name|refcnt
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|bufev_private
operator|->
name|refcnt
condition|)
block|{
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bufev
operator|->
name|be_ops
operator|->
name|unlink
condition|)
name|bufev
operator|->
name|be_ops
operator|->
name|unlink
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
comment|/* Okay, we're out of references. Let's finalize this once all the 	 * callbacks are done running. */
name|cbs
index|[
literal|0
index|]
operator|=
operator|&
name|bufev
operator|->
name|ev_read
operator|.
name|ev_evcallback
expr_stmt|;
name|cbs
index|[
literal|1
index|]
operator|=
operator|&
name|bufev
operator|->
name|ev_write
operator|.
name|ev_evcallback
expr_stmt|;
name|cbs
index|[
literal|2
index|]
operator|=
operator|&
name|bufev_private
operator|->
name|deferred
expr_stmt|;
name|n_cbs
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|bufev_private
operator|->
name|rate_limiting
condition|)
block|{
name|struct
name|event
modifier|*
name|e
init|=
operator|&
name|bufev_private
operator|->
name|rate_limiting
operator|->
name|refill_bucket_event
decl_stmt|;
if|if
condition|(
name|event_initialized
argument_list|(
name|e
argument_list|)
condition|)
name|cbs
index|[
name|n_cbs
operator|++
index|]
operator|=
operator|&
name|e
operator|->
name|ev_evcallback
expr_stmt|;
block|}
name|n_cbs
operator|+=
name|evbuffer_get_callbacks_
argument_list|(
name|bufev
operator|->
name|input
argument_list|,
name|cbs
operator|+
name|n_cbs
argument_list|,
name|MAX_CBS
operator|-
name|n_cbs
argument_list|)
expr_stmt|;
name|n_cbs
operator|+=
name|evbuffer_get_callbacks_
argument_list|(
name|bufev
operator|->
name|output
argument_list|,
name|cbs
operator|+
name|n_cbs
argument_list|,
name|MAX_CBS
operator|-
name|n_cbs
argument_list|)
expr_stmt|;
name|event_callback_finalize_many_
argument_list|(
name|bufev
operator|->
name|ev_base
argument_list|,
name|n_cbs
argument_list|,
name|cbs
argument_list|,
name|bufferevent_finalize_cb_
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|MAX_CBS
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bufferevent_finalize_cb_
parameter_list|(
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|,
name|void
modifier|*
name|arg_
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|bufev
init|=
name|arg_
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|underlying
decl_stmt|;
name|struct
name|bufferevent_private
modifier|*
name|bufev_private
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bufev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
name|underlying
operator|=
name|bufferevent_get_underlying
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
comment|/* Clean up the shared info */
if|if
condition|(
name|bufev
operator|->
name|be_ops
operator|->
name|destruct
condition|)
name|bufev
operator|->
name|be_ops
operator|->
name|destruct
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
comment|/* XXX what happens if refcnt for these buffers is> 1? 	 * The buffers can share a lock with this bufferevent object, 	 * but the lock might be destroyed below. */
comment|/* evbuffer will free the callbacks */
name|evbuffer_free
argument_list|(
name|bufev
operator|->
name|input
argument_list|)
expr_stmt|;
name|evbuffer_free
argument_list|(
name|bufev
operator|->
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufev_private
operator|->
name|rate_limiting
condition|)
block|{
if|if
condition|(
name|bufev_private
operator|->
name|rate_limiting
operator|->
name|group
condition|)
name|bufferevent_remove_from_rate_limit_group_internal_
argument_list|(
name|bufev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|bufev_private
operator|->
name|rate_limiting
argument_list|)
expr_stmt|;
name|bufev_private
operator|->
name|rate_limiting
operator|=
name|NULL
expr_stmt|;
block|}
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufev_private
operator|->
name|own_lock
condition|)
name|EVTHREAD_FREE_LOCK
argument_list|(
name|bufev_private
operator|->
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
comment|/* Free the actual allocated memory. */
name|mm_free
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|bufev
operator|)
operator|-
name|bufev
operator|->
name|be_ops
operator|->
name|mem_offset
argument_list|)
expr_stmt|;
comment|/* Release the reference to underlying now that we no longer need the 	 * reference to it.  We wait this long mainly in case our lock is 	 * shared with underlying. 	 * 	 * The 'destruct' function will also drop a reference to underlying 	 * if BEV_OPT_CLOSE_ON_FREE is set. 	 * 	 * XXX Should we/can we just refcount evbuffer/bufferevent locks? 	 * It would probably save us some headaches. 	 */
if|if
condition|(
name|underlying
condition|)
name|bufferevent_decref_
argument_list|(
name|underlying
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bufferevent_decref_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|)
block|{
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
return|return
name|bufferevent_decref_and_unlock_
argument_list|(
name|bufev
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|bufferevent_free
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|)
block|{
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
name|bufferevent_setcb
argument_list|(
name|bufev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bufferevent_cancel_all_
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
name|bufferevent_decref_and_unlock_
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bufferevent_incref_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bufev_private
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bufev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
operator|++
name|bufev_private
operator|->
name|refcnt
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bufferevent_enable_locking_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|void
modifier|*
name|lock
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|EVENT__DISABLE_THREAD_SUPPORT
return|return
operator|-
literal|1
return|;
else|#
directive|else
name|struct
name|bufferevent
modifier|*
name|underlying
decl_stmt|;
if|if
condition|(
name|BEV_UPCAST
argument_list|(
name|bufev
argument_list|)
operator|->
name|lock
condition|)
return|return
operator|-
literal|1
return|;
name|underlying
operator|=
name|bufferevent_get_underlying
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lock
operator|&&
name|underlying
operator|&&
name|BEV_UPCAST
argument_list|(
name|underlying
argument_list|)
operator|->
name|lock
condition|)
block|{
name|lock
operator|=
name|BEV_UPCAST
argument_list|(
name|underlying
argument_list|)
operator|->
name|lock
expr_stmt|;
name|BEV_UPCAST
argument_list|(
name|bufev
argument_list|)
operator|->
name|lock
operator|=
name|lock
expr_stmt|;
name|BEV_UPCAST
argument_list|(
name|bufev
argument_list|)
operator|->
name|own_lock
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|lock
condition|)
block|{
name|EVTHREAD_ALLOC_LOCK
argument_list|(
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lock
condition|)
return|return
operator|-
literal|1
return|;
name|BEV_UPCAST
argument_list|(
name|bufev
argument_list|)
operator|->
name|lock
operator|=
name|lock
expr_stmt|;
name|BEV_UPCAST
argument_list|(
name|bufev
argument_list|)
operator|->
name|own_lock
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|BEV_UPCAST
argument_list|(
name|bufev
argument_list|)
operator|->
name|lock
operator|=
name|lock
expr_stmt|;
name|BEV_UPCAST
argument_list|(
name|bufev
argument_list|)
operator|->
name|own_lock
operator|=
literal|0
expr_stmt|;
block|}
name|evbuffer_enable_locking
argument_list|(
name|bufev
operator|->
name|input
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|evbuffer_enable_locking
argument_list|(
name|bufev
operator|->
name|output
argument_list|,
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|underlying
operator|&&
operator|!
name|BEV_UPCAST
argument_list|(
name|underlying
argument_list|)
operator|->
name|lock
condition|)
name|bufferevent_enable_locking_
argument_list|(
name|underlying
argument_list|,
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|bufferevent_setfd
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|)
block|{
name|union
name|bufferevent_ctrl_data
name|d
decl_stmt|;
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|d
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev
operator|->
name|be_ops
operator|->
name|ctrl
condition|)
name|res
operator|=
name|bev
operator|->
name|be_ops
operator|->
name|ctrl
argument_list|(
name|bev
argument_list|,
name|BEV_CTRL_SET_FD
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|evutil_socket_t
name|bufferevent_getfd
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|union
name|bufferevent_ctrl_data
name|d
decl_stmt|;
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|d
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev
operator|->
name|be_ops
operator|->
name|ctrl
condition|)
name|res
operator|=
name|bev
operator|->
name|be_ops
operator|->
name|ctrl
argument_list|(
name|bev
argument_list|,
name|BEV_CTRL_GET_FD
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
name|d
operator|.
name|fd
return|;
block|}
end_function

begin_function
name|enum
name|bufferevent_options
name|bufferevent_get_options_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bev_p
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
name|enum
name|bufferevent_options
name|options
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|options
operator|=
name|bev_p
operator|->
name|options
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
name|options
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bufferevent_cancel_all_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|union
name|bufferevent_ctrl_data
name|d
decl_stmt|;
name|memset
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev
operator|->
name|be_ops
operator|->
name|ctrl
condition|)
name|bev
operator|->
name|be_ops
operator|->
name|ctrl
argument_list|(
name|bev
argument_list|,
name|BEV_CTRL_CANCEL_ALL
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|short
name|bufferevent_get_enabled
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|)
block|{
name|short
name|r
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
name|r
operator|=
name|bufev
operator|->
name|enabled
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|struct
name|bufferevent
modifier|*
name|bufferevent_get_underlying
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|union
name|bufferevent_ctrl_data
name|d
decl_stmt|;
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|d
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev
operator|->
name|be_ops
operator|->
name|ctrl
condition|)
name|res
operator|=
name|bev
operator|->
name|be_ops
operator|->
name|ctrl
argument_list|(
name|bev
argument_list|,
name|BEV_CTRL_GET_UNDERLYING
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|<
literal|0
operator|)
condition|?
name|NULL
else|:
name|d
operator|.
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bufferevent_generic_read_timeout_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
name|ctx
decl_stmt|;
name|bufferevent_incref_and_lock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bufferevent_disable
argument_list|(
name|bev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|bufferevent_run_eventcb_
argument_list|(
name|bev
argument_list|,
name|BEV_EVENT_TIMEOUT
operator||
name|BEV_EVENT_READING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bufferevent_decref_and_unlock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bufferevent_generic_write_timeout_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
name|ctx
decl_stmt|;
name|bufferevent_incref_and_lock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bufferevent_disable
argument_list|(
name|bev
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
name|bufferevent_run_eventcb_
argument_list|(
name|bev
argument_list|,
name|BEV_EVENT_TIMEOUT
operator||
name|BEV_EVENT_WRITING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bufferevent_decref_and_unlock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bufferevent_init_generic_timeout_cbs_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|event_assign
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|,
name|bev
operator|->
name|ev_base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_FINALIZE
argument_list|,
name|bufferevent_generic_read_timeout_cb
argument_list|,
name|bev
argument_list|)
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|bev
operator|->
name|ev_write
argument_list|,
name|bev
operator|->
name|ev_base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_FINALIZE
argument_list|,
name|bufferevent_generic_write_timeout_cb
argument_list|,
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bufferevent_generic_adj_timeouts_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
specifier|const
name|short
name|enabled
init|=
name|bev
operator|->
name|enabled
decl_stmt|;
name|struct
name|bufferevent_private
modifier|*
name|bev_p
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
name|int
name|r1
init|=
literal|0
decl_stmt|,
name|r2
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|enabled
operator|&
name|EV_READ
operator|)
operator|&&
operator|!
name|bev_p
operator|->
name|read_suspended
operator|&&
name|evutil_timerisset
argument_list|(
operator|&
name|bev
operator|->
name|timeout_read
argument_list|)
condition|)
name|r1
operator|=
name|event_add
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|,
operator|&
name|bev
operator|->
name|timeout_read
argument_list|)
expr_stmt|;
else|else
name|r1
operator|=
name|event_del
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|enabled
operator|&
name|EV_WRITE
operator|)
operator|&&
operator|!
name|bev_p
operator|->
name|write_suspended
operator|&&
name|evutil_timerisset
argument_list|(
operator|&
name|bev
operator|->
name|timeout_write
argument_list|)
operator|&&
name|evbuffer_get_length
argument_list|(
name|bev
operator|->
name|output
argument_list|)
condition|)
name|r2
operator|=
name|event_add
argument_list|(
operator|&
name|bev
operator|->
name|ev_write
argument_list|,
operator|&
name|bev
operator|->
name|timeout_write
argument_list|)
expr_stmt|;
else|else
name|r2
operator|=
name|event_del
argument_list|(
operator|&
name|bev
operator|->
name|ev_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|<
literal|0
operator|||
name|r2
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_add_event_
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
if|if
condition|(
name|tv
operator|->
name|tv_sec
operator|==
literal|0
operator|&&
name|tv
operator|->
name|tv_usec
operator|==
literal|0
condition|)
return|return
name|event_add
argument_list|(
name|ev
argument_list|,
name|NULL
argument_list|)
return|;
else|else
return|return
name|event_add
argument_list|(
name|ev
argument_list|,
name|tv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For use by user programs only; internally, we should be calling    either bufferevent_incref_and_lock_(), or BEV_LOCK. */
end_comment

begin_function
name|void
name|bufferevent_lock
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|bufferevent_incref_and_lock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bufferevent_unlock
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|bufferevent_decref_and_unlock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

