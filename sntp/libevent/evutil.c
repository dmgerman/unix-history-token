begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<ws2tcpip.h>
end_include

begin_define
define|#
directive|define
name|WIN32_LEAN_AND_MEAN
end_define

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_undef
undef|#
directive|undef
name|WIN32_LEAN_AND_MEAN
end_undef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<tchar.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_undef
undef|#
directive|undef
name|_WIN32_WINNT
end_undef

begin_comment
comment|/* For structs needed by GetAdaptersAddresses */
end_comment

begin_define
define|#
directive|define
name|_WIN32_WINNT
value|0x0501
end_define

begin_include
include|#
directive|include
file|<iphlpapi.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_SOCKET_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_FCNTL_H
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_NETINET_IN_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_NETINET_IN6_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_NETINET_TCP_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_ARPA_INET_H
end_ifdef

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_IFADDRS_H
end_ifdef

begin_include
include|#
directive|include
file|<ifaddrs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|"mm-internal.h"
end_include

begin_include
include|#
directive|include
file|"evthread-internal.h"
end_include

begin_include
include|#
directive|include
file|"strlcpy-internal.h"
end_include

begin_include
include|#
directive|include
file|"ipv6-internal.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_define
define|#
directive|define
name|HT_NO_CACHE_HASH_VALUES
end_define

begin_include
include|#
directive|include
file|"ht-internal.h"
end_include

begin_define
define|#
directive|define
name|open
value|_open
end_define

begin_define
define|#
directive|define
name|read
value|_read
end_define

begin_define
define|#
directive|define
name|close
value|_close
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|fstat
end_ifndef

begin_define
define|#
directive|define
name|fstat
value|_fstati64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|stat
end_ifndef

begin_define
define|#
directive|define
name|stat
value|_stati64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|mode_t
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|evutil_open_closeonexec_
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|flags
parameter_list|,
name|unsigned
name|mode
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
ifdef|#
directive|ifdef
name|O_CLOEXEC
name|fd
operator|=
name|open
argument_list|(
name|pathname
argument_list|,
name|flags
operator||
name|O_CLOEXEC
argument_list|,
operator|(
name|mode_t
operator|)
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
operator|||
name|errno
operator|==
name|EINVAL
condition|)
return|return
name|fd
return|;
comment|/* If we got an EINVAL, fall through and try without O_CLOEXEC */
endif|#
directive|endif
name|fd
operator|=
name|open
argument_list|(
name|pathname
argument_list|,
name|flags
argument_list|,
operator|(
name|mode_t
operator|)
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|#
directive|if
name|defined
argument_list|(
name|FD_CLOEXEC
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/**    Read the contents of 'filename' into a newly allocated NUL-terminated    string.  Set *content_out to hold this string, and *len_out to hold its    length (not including the appended NUL).  If 'is_binary', open the file in    binary mode.     Returns 0 on success, -1 if the open fails, and -2 for all other failures.     Used internally only; may go away in a future version.  */
end_comment

begin_function
name|int
name|evutil_read_file_
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|char
modifier|*
modifier|*
name|content_out
parameter_list|,
name|size_t
modifier|*
name|len_out
parameter_list|,
name|int
name|is_binary
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|r
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|mem
decl_stmt|;
name|size_t
name|read_so_far
init|=
literal|0
decl_stmt|;
name|int
name|mode
init|=
name|O_RDONLY
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|content_out
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|len_out
argument_list|)
expr_stmt|;
operator|*
name|content_out
operator|=
name|NULL
expr_stmt|;
operator|*
name|len_out
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|O_BINARY
if|if
condition|(
name|is_binary
condition|)
name|mode
operator||=
name|O_BINARY
expr_stmt|;
endif|#
directive|endif
name|fd
operator|=
name|evutil_open_closeonexec_
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|||
name|st
operator|.
name|st_size
operator|<
literal|0
operator|||
name|st
operator|.
name|st_size
operator|>
name|EV_SSIZE_MAX
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|mem
operator|=
name|mm_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mem
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|read_so_far
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
define|#
directive|define
name|N_TO_READ
parameter_list|(
name|x
parameter_list|)
value|((x)> INT_MAX) ? INT_MAX : ((int)(x))
else|#
directive|else
define|#
directive|define
name|N_TO_READ
parameter_list|(
name|x
parameter_list|)
value|(x)
endif|#
directive|endif
while|while
condition|(
operator|(
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|mem
operator|+
name|read_so_far
argument_list|,
name|N_TO_READ
argument_list|(
name|st
operator|.
name|st_size
operator|-
name|read_so_far
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|read_so_far
operator|+=
name|r
expr_stmt|;
if|if
condition|(
name|read_so_far
operator|>=
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
condition|)
break|break;
name|EVUTIL_ASSERT
argument_list|(
name|read_so_far
operator|<
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|mm_free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|mem
index|[
name|read_so_far
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|len_out
operator|=
name|read_so_far
expr_stmt|;
operator|*
name|content_out
operator|=
name|mem
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evutil_socketpair
parameter_list|(
name|int
name|family
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|protocol
parameter_list|,
name|evutil_socket_t
name|fd
index|[
literal|2
index|]
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|_WIN32
return|return
name|socketpair
argument_list|(
name|family
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|,
name|fd
argument_list|)
return|;
else|#
directive|else
return|return
name|evutil_ersatz_socketpair_
argument_list|(
name|family
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|,
name|fd
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|evutil_ersatz_socketpair_
parameter_list|(
name|int
name|family
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|protocol
parameter_list|,
name|evutil_socket_t
name|fd
index|[
literal|2
index|]
parameter_list|)
block|{
comment|/* This code is originally from Tor.  Used with permission. */
comment|/* This socketpair does not work when localhost is down. So 	 * it's really not the same thing at all. But it's close enough 	 * for now, and really, when localhost is down sometimes, we 	 * have other problems too. 	 */
ifdef|#
directive|ifdef
name|_WIN32
define|#
directive|define
name|ERR
parameter_list|(
name|e
parameter_list|)
value|WSA##e
else|#
directive|else
define|#
directive|define
name|ERR
parameter_list|(
name|e
parameter_list|)
value|e
endif|#
directive|endif
name|evutil_socket_t
name|listener
init|=
operator|-
literal|1
decl_stmt|;
name|evutil_socket_t
name|connector
init|=
operator|-
literal|1
decl_stmt|;
name|evutil_socket_t
name|acceptor
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|sockaddr_in
name|listen_addr
decl_stmt|;
name|struct
name|sockaddr_in
name|connect_addr
decl_stmt|;
name|ev_socklen_t
name|size
decl_stmt|;
name|int
name|saved_errno
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|protocol
operator|||
operator|(
name|family
operator|!=
name|AF_INET
ifdef|#
directive|ifdef
name|AF_UNIX
operator|&&
name|family
operator|!=
name|AF_UNIX
endif|#
directive|endif
operator|)
condition|)
block|{
name|EVUTIL_SET_SOCKET_ERROR
argument_list|(
name|ERR
argument_list|(
name|EAFNOSUPPORT
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|fd
condition|)
block|{
name|EVUTIL_SET_SOCKET_ERROR
argument_list|(
name|ERR
argument_list|(
name|EINVAL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|listener
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|listener
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
operator|&
name|listen_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|listen_addr
argument_list|)
argument_list|)
expr_stmt|;
name|listen_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|listen_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_LOOPBACK
argument_list|)
expr_stmt|;
name|listen_addr
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
comment|/* kernel chooses port.	 */
if|if
condition|(
name|bind
argument_list|(
name|listener
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|listen_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|listen_addr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|tidy_up_and_fail
goto|;
if|if
condition|(
name|listen
argument_list|(
name|listener
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|tidy_up_and_fail
goto|;
name|connector
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|connector
operator|<
literal|0
condition|)
goto|goto
name|tidy_up_and_fail
goto|;
comment|/* We want to find out the port number to connect to.  */
name|size
operator|=
sizeof|sizeof
argument_list|(
name|connect_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|listener
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|connect_addr
argument_list|,
operator|&
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|tidy_up_and_fail
goto|;
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|connect_addr
argument_list|)
condition|)
goto|goto
name|abort_tidy_up_and_fail
goto|;
if|if
condition|(
name|connect
argument_list|(
name|connector
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|connect_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|connect_addr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|tidy_up_and_fail
goto|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|listen_addr
argument_list|)
expr_stmt|;
name|acceptor
operator|=
name|accept
argument_list|(
name|listener
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|listen_addr
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|acceptor
operator|<
literal|0
condition|)
goto|goto
name|tidy_up_and_fail
goto|;
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|listen_addr
argument_list|)
condition|)
goto|goto
name|abort_tidy_up_and_fail
goto|;
comment|/* Now check we are talking to ourself by matching port and host on the 	   two sockets.	 */
if|if
condition|(
name|getsockname
argument_list|(
name|connector
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|connect_addr
argument_list|,
operator|&
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|tidy_up_and_fail
goto|;
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|connect_addr
argument_list|)
operator|||
name|listen_addr
operator|.
name|sin_family
operator|!=
name|connect_addr
operator|.
name|sin_family
operator|||
name|listen_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|!=
name|connect_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|||
name|listen_addr
operator|.
name|sin_port
operator|!=
name|connect_addr
operator|.
name|sin_port
condition|)
goto|goto
name|abort_tidy_up_and_fail
goto|;
name|evutil_closesocket
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|fd
index|[
literal|0
index|]
operator|=
name|connector
expr_stmt|;
name|fd
index|[
literal|1
index|]
operator|=
name|acceptor
expr_stmt|;
return|return
literal|0
return|;
name|abort_tidy_up_and_fail
label|:
name|saved_errno
operator|=
name|ERR
argument_list|(
name|ECONNABORTED
argument_list|)
expr_stmt|;
name|tidy_up_and_fail
label|:
if|if
condition|(
name|saved_errno
operator|<
literal|0
condition|)
name|saved_errno
operator|=
name|EVUTIL_SOCKET_ERROR
argument_list|()
expr_stmt|;
if|if
condition|(
name|listener
operator|!=
operator|-
literal|1
condition|)
name|evutil_closesocket
argument_list|(
name|listener
argument_list|)
expr_stmt|;
if|if
condition|(
name|connector
operator|!=
operator|-
literal|1
condition|)
name|evutil_closesocket
argument_list|(
name|connector
argument_list|)
expr_stmt|;
if|if
condition|(
name|acceptor
operator|!=
operator|-
literal|1
condition|)
name|evutil_closesocket
argument_list|(
name|acceptor
argument_list|)
expr_stmt|;
name|EVUTIL_SET_SOCKET_ERROR
argument_list|(
name|saved_errno
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
undef|#
directive|undef
name|ERR
block|}
end_function

begin_function
name|int
name|evutil_make_socket_nonblocking
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
block|{
name|u_long
name|nonblocking
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ioctlsocket
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|nonblocking
argument_list|)
operator|==
name|SOCKET_ERROR
condition|)
block|{
name|event_sock_warn
argument_list|(
name|fd
argument_list|,
literal|"fcntl(%d, F_GETFL)"
argument_list|,
operator|(
name|int
operator|)
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|#
directive|else
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|event_warn
argument_list|(
literal|"fcntl(%d, F_GETFL)"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|O_NONBLOCK
operator|)
condition|)
block|{
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator||
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|event_warn
argument_list|(
literal|"fcntl(%d, F_SETFL)"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Faster version of evutil_make_socket_nonblocking for internal use.  *  * Requires that no F_SETFL flags were previously set on the fd.  */
end_comment

begin_function
specifier|static
name|int
name|evutil_fast_socket_nonblocking
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
return|return
name|evutil_make_socket_nonblocking
argument_list|(
name|fd
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|event_warn
argument_list|(
literal|"fcntl(%d, F_SETFL)"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|evutil_make_listen_socket_reuseable
parameter_list|(
name|evutil_socket_t
name|sock
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|_WIN32
name|int
name|one
init|=
literal|1
decl_stmt|;
comment|/* REUSEADDR on Unix means, "don't hang on to this address after the 	 * listener is closed."  On Windows, though, it means "don't keep other 	 * processes from binding to this address while we're using it. */
return|return
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|one
argument_list|,
operator|(
name|ev_socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|one
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|evutil_make_tcp_listen_socket_deferred
parameter_list|(
name|evutil_socket_t
name|sock
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_NETINET_TCP_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|TCP_DEFER_ACCEPT
argument_list|)
name|int
name|one
init|=
literal|1
decl_stmt|;
comment|/* TCP_DEFER_ACCEPT tells the kernel to call defer accept() only after data 	 * has arrived and ready to read */
return|return
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|TCP_DEFER_ACCEPT
argument_list|,
operator|&
name|one
argument_list|,
operator|(
name|ev_socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|one
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evutil_make_socket_closeonexec
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|EVENT__HAVE_SETFD
argument_list|)
name|int
name|flags
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFD
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|event_warn
argument_list|(
literal|"fcntl(%d, F_GETFD)"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|FD_CLOEXEC
operator|)
condition|)
block|{
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|flags
operator||
name|FD_CLOEXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|event_warn
argument_list|(
literal|"fcntl(%d, F_SETFD)"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Faster version of evutil_make_socket_closeonexec for internal use.  *  * Requires that no F_SETFD flags were previously set on the fd.  */
end_comment

begin_function
specifier|static
name|int
name|evutil_fast_socket_closeonexec
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|EVENT__HAVE_SETFD
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|event_warn
argument_list|(
literal|"fcntl(%d, F_SETFD)"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evutil_closesocket
parameter_list|(
name|evutil_socket_t
name|sock
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|_WIN32
return|return
name|close
argument_list|(
name|sock
argument_list|)
return|;
else|#
directive|else
return|return
name|closesocket
argument_list|(
name|sock
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|ev_int64_t
name|evutil_strtoll
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|endptr
parameter_list|,
name|int
name|base
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|EVENT__HAVE_STRTOLL
return|return
operator|(
name|ev_int64_t
operator|)
name|strtoll
argument_list|(
name|s
argument_list|,
name|endptr
argument_list|,
name|base
argument_list|)
return|;
elif|#
directive|elif
name|EVENT__SIZEOF_LONG
operator|==
literal|8
return|return
operator|(
name|ev_int64_t
operator|)
name|strtol
argument_list|(
name|s
argument_list|,
name|endptr
argument_list|,
name|base
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|<
literal|1300
comment|/* XXXX on old versions of MS APIs, we only support base 	 * 10. */
name|ev_int64_t
name|r
decl_stmt|;
if|if
condition|(
name|base
operator|!=
literal|10
condition|)
return|return
literal|0
return|;
name|r
operator|=
operator|(
name|ev_int64_t
operator|)
name|_atoi64
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
operator|++
name|s
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|endptr
condition|)
operator|*
name|endptr
operator|=
operator|(
name|char
operator|*
operator|)
name|s
expr_stmt|;
return|return
name|r
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN32
argument_list|)
return|return
operator|(
name|ev_int64_t
operator|)
name|_strtoi64
argument_list|(
name|s
argument_list|,
name|endptr
argument_list|,
name|base
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|EVENT__SIZEOF_LONG_LONG
argument_list|)
operator|&&
name|EVENT__SIZEOF_LONG_LONG
operator|==
literal|8
name|long
name|long
name|r
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|base
operator|!=
literal|10
operator|&&
name|base
operator|!=
literal|16
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|base
operator|==
literal|10
condition|)
block|{
name|n
operator|=
name|sscanf
argument_list|(
name|s
argument_list|,
literal|"%lld"
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|long
name|ru
init|=
literal|0
decl_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|s
argument_list|,
literal|"%llx"
argument_list|,
operator|&
name|ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|ru
operator|>
name|EV_INT64_MAX
condition|)
return|return
literal|0
return|;
name|r
operator|=
operator|(
name|long
name|long
operator|)
name|ru
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|EVUTIL_ISSPACE_
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|10
condition|)
block|{
while|while
condition|(
name|EVUTIL_ISDIGIT_
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|EVUTIL_ISXDIGIT_
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|endptr
condition|)
operator|*
name|endptr
operator|=
operator|(
name|char
operator|*
operator|)
name|s
expr_stmt|;
return|return
name|r
return|;
else|#
directive|else
error|#
directive|error
literal|"I don't know how to parse 64-bit integers."
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_function
name|int
name|evutil_socket_geterror
parameter_list|(
name|evutil_socket_t
name|sock
parameter_list|)
block|{
name|int
name|optval
decl_stmt|,
name|optvallen
init|=
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
decl_stmt|;
name|int
name|err
init|=
name|WSAGetLastError
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|WSAEWOULDBLOCK
operator|&&
name|sock
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|getsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|optval
argument_list|,
operator|&
name|optvallen
argument_list|)
condition|)
return|return
name|err
return|;
if|if
condition|(
name|optval
condition|)
return|return
name|optval
return|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX we should use an enum here. */
end_comment

begin_comment
comment|/* 2 for connection refused, 1 for connected, 0 for not yet, -1 for error. */
end_comment

begin_function
name|int
name|evutil_socket_connect_
parameter_list|(
name|evutil_socket_t
modifier|*
name|fd_ptr
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|int
name|socklen
parameter_list|)
block|{
name|int
name|made_fd
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|fd_ptr
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|fd_ptr
operator|=
name|socket
argument_list|(
name|sa
operator|->
name|sa_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
name|made_fd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|evutil_make_socket_nonblocking
argument_list|(
operator|*
name|fd_ptr
argument_list|)
operator|<
literal|0
condition|)
block|{
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
name|connect
argument_list|(
operator|*
name|fd_ptr
argument_list|,
name|sa
argument_list|,
name|socklen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|e
init|=
name|evutil_socket_geterror
argument_list|(
operator|*
name|fd_ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|EVUTIL_ERR_CONNECT_RETRIABLE
argument_list|(
name|e
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|EVUTIL_ERR_CONNECT_REFUSED
argument_list|(
name|e
argument_list|)
condition|)
return|return
literal|2
return|;
goto|goto
name|err
goto|;
block|}
else|else
block|{
return|return
literal|1
return|;
block|}
name|err
label|:
if|if
condition|(
name|made_fd
condition|)
block|{
name|evutil_closesocket
argument_list|(
operator|*
name|fd_ptr
argument_list|)
expr_stmt|;
operator|*
name|fd_ptr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check whether a socket on which we called connect() is done    connecting. Return 1 for connected, 0 for not yet, -1 for error.  In the    error case, set the current socket errno to the error that happened during    the connect operation. */
end_comment

begin_function
name|int
name|evutil_socket_finished_connecting_
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|)
block|{
name|int
name|e
decl_stmt|;
name|ev_socklen_t
name|elen
init|=
sizeof|sizeof
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|e
argument_list|,
operator|&
name|elen
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|e
condition|)
block|{
if|if
condition|(
name|EVUTIL_ERR_CONNECT_RETRIABLE
argument_list|(
name|e
argument_list|)
condition|)
return|return
literal|0
return|;
name|EVUTIL_SET_SOCKET_ERROR
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|EVUTIL_AI_PASSIVE
operator||
name|EVUTIL_AI_CANONNAME
operator||
name|EVUTIL_AI_NUMERICHOST
operator||
expr|\
name|EVUTIL_AI_NUMERICSERV
operator||
name|EVUTIL_AI_V4MAPPED
operator||
name|EVUTIL_AI_ALL
operator||
expr|\
name|EVUTIL_AI_ADDRCONFIG
operator|)
operator|!=
expr|\
operator|(
name|EVUTIL_AI_PASSIVE
operator|^
name|EVUTIL_AI_CANONNAME
operator|^
name|EVUTIL_AI_NUMERICHOST
operator|^
expr|\
name|EVUTIL_AI_NUMERICSERV
operator|^
name|EVUTIL_AI_V4MAPPED
operator|^
name|EVUTIL_AI_ALL
operator|^
expr|\
name|EVUTIL_AI_ADDRCONFIG
operator|)
end_if

begin_error
error|#
directive|error
literal|"Some of our EVUTIL_AI_* flags seem to overlap with system AI_* flags"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We sometimes need to know whether we have an ipv4 address and whether we    have an ipv6 address. If 'have_checked_interfaces', then we've already done    the test.  If 'had_ipv4_address', then it turns out we had an ipv4 address.    If 'had_ipv6_address', then it turns out we had an ipv6 address.   These are    set by evutil_check_interfaces. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_checked_interfaces
decl_stmt|,
name|had_ipv4_address
decl_stmt|,
name|had_ipv6_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro: True iff the IPv4 address 'addr', in host order, is in 127.0.0.0/8  */
end_comment

begin_define
define|#
directive|define
name|EVUTIL_V4ADDR_IS_LOCALHOST
parameter_list|(
name|addr
parameter_list|)
value|(((addr)>>24) == 127)
end_define

begin_comment
comment|/* Macro: True iff the IPv4 address 'addr', in host order, is a class D  * (multiclass) address.  */
end_comment

begin_define
define|#
directive|define
name|EVUTIL_V4ADDR_IS_CLASSD
parameter_list|(
name|addr
parameter_list|)
value|((((addr)>>24)& 0xf0) == 0xe0)
end_define

begin_function
specifier|static
name|void
name|evutil_found_ifaddr
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
specifier|const
name|char
name|ZEROES
index|[]
init|=
literal|"\x00\x00\x00\x00\x00\x00\x00\x00"
literal|"\x00\x00\x00\x00\x00\x00\x00\x00"
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
decl_stmt|;
name|ev_uint32_t
name|addr
init|=
name|ntohl
argument_list|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
operator|||
name|EVUTIL_V4ADDR_IS_LOCALHOST
argument_list|(
name|addr
argument_list|)
operator|||
name|EVUTIL_V4ADDR_IS_CLASSD
argument_list|(
name|addr
argument_list|)
condition|)
block|{
comment|/* Not actually a usable external address. */
block|}
else|else
block|{
name|event_debug
argument_list|(
operator|(
literal|"Detected an IPv4 interface"
operator|)
argument_list|)
expr_stmt|;
name|had_ipv4_address
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|addr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sin6
operator|->
name|sin6_addr
operator|.
name|s6_addr
decl_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|addr
argument_list|,
name|ZEROES
argument_list|,
literal|8
argument_list|)
operator|||
operator|(
operator|(
name|addr
index|[
literal|0
index|]
operator|&
literal|0xfe
operator|)
operator|==
literal|0xfc
operator|)
operator|||
operator|(
name|addr
index|[
literal|0
index|]
operator|==
literal|0xfe
operator|&&
operator|(
name|addr
index|[
literal|1
index|]
operator|&
literal|0xc0
operator|)
operator|==
literal|0x80
operator|)
operator|||
operator|(
name|addr
index|[
literal|0
index|]
operator|==
literal|0xfe
operator|&&
operator|(
name|addr
index|[
literal|1
index|]
operator|&
literal|0xc0
operator|)
operator|==
literal|0xc0
operator|)
operator|||
operator|(
name|addr
index|[
literal|0
index|]
operator|==
literal|0xff
operator|)
condition|)
block|{
comment|/* This is a reserved, ipv4compat, ipv4map, loopback, 			 * link-local, multicast, or unspecified address. */
block|}
else|else
block|{
name|event_debug
argument_list|(
operator|(
literal|"Detected an IPv6 interface"
operator|)
argument_list|)
expr_stmt|;
name|had_ipv6_address
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_typedef
typedef|typedef
name|ULONG
function_decl|(
name|WINAPI
modifier|*
name|GetAdaptersAddresses_fn_t
function_decl|)
parameter_list|(
name|ULONG
parameter_list|,
name|ULONG
parameter_list|,
name|PVOID
parameter_list|,
name|PIP_ADAPTER_ADDRESSES
parameter_list|,
name|PULONG
parameter_list|)
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|evutil_check_ifaddrs
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_GETIFADDRS
argument_list|)
comment|/* Most free Unixy systems provide getifaddrs, which gives us a linked list 	 * of struct ifaddrs. */
name|struct
name|ifaddrs
modifier|*
name|ifa
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|ifaddrs
modifier|*
name|i
decl_stmt|;
if|if
condition|(
name|getifaddrs
argument_list|(
operator|&
name|ifa
argument_list|)
operator|<
literal|0
condition|)
block|{
name|event_warn
argument_list|(
literal|"Unable to call getifaddrs()"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
name|ifa
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|ifa_next
control|)
block|{
if|if
condition|(
operator|!
name|i
operator|->
name|ifa_addr
condition|)
continue|continue;
name|evutil_found_ifaddr
argument_list|(
name|i
operator|->
name|ifa_addr
argument_list|)
expr_stmt|;
block|}
name|freeifaddrs
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN32
argument_list|)
comment|/* Windows XP began to provide GetAdaptersAddresses. Windows 2000 had a 	   "GetAdaptersInfo", but that's deprecated; let's just try 	   GetAdaptersAddresses and fall back to connect+getsockname. 	*/
name|HANDLE
name|lib
init|=
name|evutil_load_windows_system_library_
argument_list|(
name|TEXT
argument_list|(
literal|"ihplapi.dll"
argument_list|)
argument_list|)
decl_stmt|;
name|GetAdaptersAddresses_fn_t
name|fn
decl_stmt|;
name|ULONG
name|size
decl_stmt|,
name|res
decl_stmt|;
name|IP_ADAPTER_ADDRESSES
modifier|*
name|addresses
init|=
name|NULL
decl_stmt|,
modifier|*
name|address
decl_stmt|;
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
define|#
directive|define
name|FLAGS
value|(GAA_FLAG_SKIP_ANYCAST | \                GAA_FLAG_SKIP_MULTICAST | \                GAA_FLAG_SKIP_DNS_SERVER)
if|if
condition|(
operator|!
name|lib
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
operator|(
name|fn
operator|=
operator|(
name|GetAdaptersAddresses_fn_t
operator|)
name|GetProcAddress
argument_list|(
name|lib
argument_list|,
literal|"GetAdaptersAddresses"
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
comment|/* Guess how much space we need. */
name|size
operator|=
literal|15
operator|*
literal|1024
expr_stmt|;
name|addresses
operator|=
name|mm_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addresses
condition|)
goto|goto
name|done
goto|;
name|res
operator|=
name|fn
argument_list|(
name|AF_UNSPEC
argument_list|,
name|FLAGS
argument_list|,
name|NULL
argument_list|,
name|addresses
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|ERROR_BUFFER_OVERFLOW
condition|)
block|{
comment|/* we didn't guess that we needed enough space; try again */
name|mm_free
argument_list|(
name|addresses
argument_list|)
expr_stmt|;
name|addresses
operator|=
name|mm_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addresses
condition|)
goto|goto
name|done
goto|;
name|res
operator|=
name|fn
argument_list|(
name|AF_UNSPEC
argument_list|,
name|FLAGS
argument_list|,
name|NULL
argument_list|,
name|addresses
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|!=
name|NO_ERROR
condition|)
goto|goto
name|done
goto|;
for|for
control|(
name|address
operator|=
name|addresses
init|;
name|address
condition|;
name|address
operator|=
name|address
operator|->
name|Next
control|)
block|{
name|IP_ADAPTER_UNICAST_ADDRESS
modifier|*
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|address
operator|->
name|FirstUnicastAddress
init|;
name|a
condition|;
name|a
operator|=
name|a
operator|->
name|Next
control|)
block|{
comment|/* Yes, it's a linked list inside a linked list */
name|struct
name|sockaddr
modifier|*
name|sa
init|=
name|a
operator|->
name|Address
operator|.
name|lpSockaddr
decl_stmt|;
name|evutil_found_ifaddr
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
literal|0
expr_stmt|;
name|done
label|:
if|if
condition|(
name|lib
condition|)
name|FreeLibrary
argument_list|(
name|lib
argument_list|)
expr_stmt|;
if|if
condition|(
name|addresses
condition|)
name|mm_free
argument_list|(
name|addresses
argument_list|)
expr_stmt|;
return|return
name|result
return|;
else|#
directive|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Test whether we have an ipv4 interface and an ipv6 interface.  Return 0 if  * the test seemed successful. */
end_comment

begin_function
specifier|static
name|int
name|evutil_check_interfaces
parameter_list|(
name|int
name|force_recheck
parameter_list|)
block|{
name|evutil_socket_t
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|,
name|sin_out
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|,
name|sin6_out
decl_stmt|;
name|ev_socklen_t
name|sin_out_len
init|=
sizeof|sizeof
argument_list|(
name|sin_out
argument_list|)
decl_stmt|;
name|ev_socklen_t
name|sin6_out_len
init|=
sizeof|sizeof
argument_list|(
name|sin6_out
argument_list|)
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|have_checked_interfaces
operator|&&
operator|!
name|force_recheck
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|evutil_check_ifaddrs
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* Use a nice sane interface, if this system has one. */
return|return
literal|0
return|;
block|}
comment|/* Ugh. There was no nice sane interface.  So to check whether we have 	 * an interface open for a given protocol, will try to make a UDP 	 * 'connection' to a remote host on the internet.  We don't actually 	 * use it, so the address doesn't matter, but we want to pick one that 	 * keep us from using a host- or link-local interface. */
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|53
argument_list|)
expr_stmt|;
name|r
operator|=
name|evutil_inet_pton
argument_list|(
name|AF_INET
argument_list|,
literal|"18.244.0.188"
argument_list|,
operator|&
name|sin
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|htons
argument_list|(
literal|53
argument_list|)
expr_stmt|;
name|r
operator|=
name|evutil_inet_pton
argument_list|(
name|AF_INET6
argument_list|,
literal|"2001:4860:b002::68"
argument_list|,
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sin_out
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin_out
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sin6_out
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6_out
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX some errnos mean 'no address'; some mean 'not enough sockets'. */
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|connect
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|getsockname
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin_out
argument_list|,
operator|&
name|sin_out_len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We might have an IPv4 interface. */
name|evutil_found_ifaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin_out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|evutil_closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|connect
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|getsockname
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6_out
argument_list|,
operator|&
name|sin6_out_len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We might have an IPv6 interface. */
name|evutil_found_ifaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6_out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|evutil_closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Internal addrinfo flag.  This one is set when we allocate the addrinfo from  * inside libevent.  Otherwise, the built-in getaddrinfo() function allocated  * it, and we should trust what they said.  **/
end_comment

begin_define
define|#
directive|define
name|EVUTIL_AI_LIBEVENT_ALLOCATED
value|0x80000000
end_define

begin_comment
comment|/* Helper: construct a new addrinfo containing the socket address in  * 'sa', which must be a sockaddr_in or a sockaddr_in6.  Take the  * socktype and protocol info from hints.  If they weren't set, then  * allocate both a TCP and a UDP addrinfo.  */
end_comment

begin_function
name|struct
name|evutil_addrinfo
modifier|*
name|evutil_new_addrinfo_
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|ev_socklen_t
name|socklen
parameter_list|,
specifier|const
name|struct
name|evutil_addrinfo
modifier|*
name|hints
parameter_list|)
block|{
name|struct
name|evutil_addrinfo
modifier|*
name|res
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|hints
argument_list|)
expr_stmt|;
if|if
condition|(
name|hints
operator|->
name|ai_socktype
operator|==
literal|0
operator|&&
name|hints
operator|->
name|ai_protocol
operator|==
literal|0
condition|)
block|{
comment|/* Indecisive user! Give them a UDP and a TCP. */
name|struct
name|evutil_addrinfo
modifier|*
name|r1
decl_stmt|,
modifier|*
name|r2
decl_stmt|;
name|struct
name|evutil_addrinfo
name|tmp
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp
argument_list|,
name|hints
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|tmp
operator|.
name|ai_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|r1
operator|=
name|evutil_new_addrinfo_
argument_list|(
name|sa
argument_list|,
name|socklen
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r1
condition|)
return|return
name|NULL
return|;
name|tmp
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|tmp
operator|.
name|ai_protocol
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|r2
operator|=
name|evutil_new_addrinfo_
argument_list|(
name|sa
argument_list|,
name|socklen
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r2
condition|)
block|{
name|evutil_freeaddrinfo
argument_list|(
name|r1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|r1
operator|->
name|ai_next
operator|=
name|r2
expr_stmt|;
return|return
name|r1
return|;
block|}
comment|/* We're going to allocate extra space to hold the sockaddr. */
name|res
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evutil_addrinfo
argument_list|)
operator|+
name|socklen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
return|return
name|NULL
return|;
name|res
operator|->
name|ai_addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|res
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|evutil_addrinfo
argument_list|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|->
name|ai_addr
argument_list|,
name|sa
argument_list|,
name|socklen
argument_list|)
expr_stmt|;
name|res
operator|->
name|ai_addrlen
operator|=
name|socklen
expr_stmt|;
name|res
operator|->
name|ai_family
operator|=
name|sa
operator|->
name|sa_family
expr_stmt|;
comment|/* Same or not? XXX */
name|res
operator|->
name|ai_flags
operator|=
name|EVUTIL_AI_LIBEVENT_ALLOCATED
expr_stmt|;
name|res
operator|->
name|ai_socktype
operator|=
name|hints
operator|->
name|ai_socktype
expr_stmt|;
name|res
operator|->
name|ai_protocol
operator|=
name|hints
operator|->
name|ai_protocol
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Append the addrinfo 'append' to the end of 'first', and return the start of  * the list.  Either element can be NULL, in which case we return the element  * that is not NULL. */
end_comment

begin_function
name|struct
name|evutil_addrinfo
modifier|*
name|evutil_addrinfo_append_
parameter_list|(
name|struct
name|evutil_addrinfo
modifier|*
name|first
parameter_list|,
name|struct
name|evutil_addrinfo
modifier|*
name|append
parameter_list|)
block|{
name|struct
name|evutil_addrinfo
modifier|*
name|ai
init|=
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|ai
condition|)
return|return
name|append
return|;
while|while
condition|(
name|ai
operator|->
name|ai_next
condition|)
name|ai
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
name|ai
operator|->
name|ai_next
operator|=
name|append
expr_stmt|;
return|return
name|first
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_numeric_servname
parameter_list|(
specifier|const
name|char
modifier|*
name|servname
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|endptr
init|=
name|NULL
decl_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|servname
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
operator|&&
name|n
operator|<=
literal|65535
operator|&&
name|servname
index|[
literal|0
index|]
operator|&&
name|endptr
operator|&&
operator|!
name|endptr
index|[
literal|0
index|]
condition|)
return|return
name|n
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/** Parse a service name in 'servname', which can be a decimal port.  * Return the port number, or -1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|evutil_parse_servname
parameter_list|(
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
specifier|const
name|char
modifier|*
name|protocol
parameter_list|,
specifier|const
name|struct
name|evutil_addrinfo
modifier|*
name|hints
parameter_list|)
block|{
name|int
name|n
init|=
name|parse_numeric_servname
argument_list|(
name|servname
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
return|return
name|n
return|;
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_GETSERVBYNAME
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
if|if
condition|(
operator|!
operator|(
name|hints
operator|->
name|ai_flags
operator|&
name|EVUTIL_AI_NUMERICSERV
operator|)
condition|)
block|{
name|struct
name|servent
modifier|*
name|ent
init|=
name|getservbyname
argument_list|(
name|servname
argument_list|,
name|protocol
argument_list|)
decl_stmt|;
if|if
condition|(
name|ent
condition|)
block|{
return|return
name|ntohs
argument_list|(
name|ent
operator|->
name|s_port
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return a string corresponding to a protocol number that we can pass to  * getservyname.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|evutil_unparse_protoname
parameter_list|(
name|int
name|proto
parameter_list|)
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
literal|0
case|:
return|return
name|NULL
return|;
case|case
name|IPPROTO_TCP
case|:
return|return
literal|"tcp"
return|;
case|case
name|IPPROTO_UDP
case|:
return|return
literal|"udp"
return|;
ifdef|#
directive|ifdef
name|IPPROTO_SCTP
case|case
name|IPPROTO_SCTP
case|:
return|return
literal|"sctp"
return|;
endif|#
directive|endif
default|default:
ifdef|#
directive|ifdef
name|EVENT__HAVE_GETPROTOBYNUMBER
block|{
name|struct
name|protoent
modifier|*
name|ent
init|=
name|getprotobynumber
argument_list|(
name|proto
argument_list|)
decl_stmt|;
if|if
condition|(
name|ent
condition|)
return|return
name|ent
operator|->
name|p_name
return|;
block|}
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|evutil_getaddrinfo_infer_protocols
parameter_list|(
name|struct
name|evutil_addrinfo
modifier|*
name|hints
parameter_list|)
block|{
comment|/* If we can guess the protocol from the socktype, do so. */
if|if
condition|(
operator|!
name|hints
operator|->
name|ai_protocol
operator|&&
name|hints
operator|->
name|ai_socktype
condition|)
block|{
if|if
condition|(
name|hints
operator|->
name|ai_socktype
operator|==
name|SOCK_DGRAM
condition|)
name|hints
operator|->
name|ai_protocol
operator|=
name|IPPROTO_UDP
expr_stmt|;
elseif|else
if|if
condition|(
name|hints
operator|->
name|ai_socktype
operator|==
name|SOCK_STREAM
condition|)
name|hints
operator|->
name|ai_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
block|}
comment|/* Set the socktype if it isn't set. */
if|if
condition|(
operator|!
name|hints
operator|->
name|ai_socktype
operator|&&
name|hints
operator|->
name|ai_protocol
condition|)
block|{
if|if
condition|(
name|hints
operator|->
name|ai_protocol
operator|==
name|IPPROTO_UDP
condition|)
name|hints
operator|->
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
elseif|else
if|if
condition|(
name|hints
operator|->
name|ai_protocol
operator|==
name|IPPROTO_TCP
condition|)
name|hints
operator|->
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
ifdef|#
directive|ifdef
name|IPPROTO_SCTP
elseif|else
if|if
condition|(
name|hints
operator|->
name|ai_protocol
operator|==
name|IPPROTO_SCTP
condition|)
name|hints
operator|->
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_if
if|#
directive|if
name|AF_UNSPEC
operator|!=
name|PF_UNSPEC
end_if

begin_error
error|#
directive|error
literal|"I cannot build on a system where AF_UNSPEC != PF_UNSPEC"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** Implements the part of looking up hosts by name that's common to both  * the blocking and nonblocking resolver:  *   - Adjust 'hints' to have a reasonable socktype and protocol.  *   - Look up the port based on 'servname', and store it in *portnum,  *   - Handle the nodename==NULL case  *   - Handle some invalid arguments cases.  *   - Handle the cases where nodename is an IPv4 or IPv6 address.  *  * If we need the resolver to look up the hostname, we return  * EVUTIL_EAI_NEED_RESOLVE.  Otherwise, we can completely implement  * getaddrinfo: we return 0 or an appropriate EVUTIL_EAI_* error, and  * set *res as getaddrinfo would.  */
end_comment

begin_function
name|int
name|evutil_getaddrinfo_common_
parameter_list|(
specifier|const
name|char
modifier|*
name|nodename
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
name|struct
name|evutil_addrinfo
modifier|*
name|hints
parameter_list|,
name|struct
name|evutil_addrinfo
modifier|*
modifier|*
name|res
parameter_list|,
name|int
modifier|*
name|portnum
parameter_list|)
block|{
name|int
name|port
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|pname
decl_stmt|;
if|if
condition|(
name|nodename
operator|==
name|NULL
operator|&&
name|servname
operator|==
name|NULL
condition|)
return|return
name|EVUTIL_EAI_NONAME
return|;
comment|/* We only understand 3 families */
if|if
condition|(
name|hints
operator|->
name|ai_family
operator|!=
name|PF_UNSPEC
operator|&&
name|hints
operator|->
name|ai_family
operator|!=
name|PF_INET
operator|&&
name|hints
operator|->
name|ai_family
operator|!=
name|PF_INET6
condition|)
return|return
name|EVUTIL_EAI_FAMILY
return|;
name|evutil_getaddrinfo_infer_protocols
argument_list|(
name|hints
argument_list|)
expr_stmt|;
comment|/* Look up the port number and protocol, if possible. */
name|pname
operator|=
name|evutil_unparse_protoname
argument_list|(
name|hints
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|servname
condition|)
block|{
comment|/* XXXX We could look at the protocol we got back from 		 * getservbyname, but it doesn't seem too useful. */
name|port
operator|=
name|evutil_parse_servname
argument_list|(
name|servname
argument_list|,
name|pname
argument_list|,
name|hints
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<
literal|0
condition|)
block|{
return|return
name|EVUTIL_EAI_NONAME
return|;
block|}
block|}
comment|/* If we have no node name, then we're supposed to bind to 'any' and 	 * connect to localhost. */
if|if
condition|(
name|nodename
operator|==
name|NULL
condition|)
block|{
name|struct
name|evutil_addrinfo
modifier|*
name|res4
init|=
name|NULL
decl_stmt|,
modifier|*
name|res6
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|hints
operator|->
name|ai_family
operator|!=
name|PF_INET
condition|)
block|{
comment|/* INET6 or UNSPEC. */
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|hints
operator|->
name|ai_flags
operator|&
name|EVUTIL_AI_PASSIVE
condition|)
block|{
comment|/* Bind to :: */
block|}
else|else
block|{
comment|/* connect to ::1 */
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
literal|15
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|res6
operator|=
name|evutil_new_addrinfo_
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|,
name|hints
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res6
condition|)
return|return
name|EVUTIL_EAI_MEMORY
return|;
block|}
if|if
condition|(
name|hints
operator|->
name|ai_family
operator|!=
name|PF_INET6
condition|)
block|{
comment|/* INET or UNSPEC */
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|hints
operator|->
name|ai_flags
operator|&
name|EVUTIL_AI_PASSIVE
condition|)
block|{
comment|/* Bind to 0.0.0.0 */
block|}
else|else
block|{
comment|/* connect to 127.0.0.1 */
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
literal|0x7f000001
argument_list|)
expr_stmt|;
block|}
name|res4
operator|=
name|evutil_new_addrinfo_
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|,
name|hints
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res4
condition|)
block|{
if|if
condition|(
name|res6
condition|)
name|evutil_freeaddrinfo
argument_list|(
name|res6
argument_list|)
expr_stmt|;
return|return
name|EVUTIL_EAI_MEMORY
return|;
block|}
block|}
operator|*
name|res
operator|=
name|evutil_addrinfo_append_
argument_list|(
name|res4
argument_list|,
name|res6
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If we can, we should try to parse the hostname without resolving 	 * it. */
comment|/* Try ipv6. */
if|if
condition|(
name|hints
operator|->
name|ai_family
operator|==
name|PF_INET6
operator|||
name|hints
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
block|{
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|evutil_inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|nodename
argument_list|,
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* Got an ipv6 address. */
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|evutil_new_addrinfo_
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|,
name|hints
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|res
condition|)
return|return
name|EVUTIL_EAI_MEMORY
return|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Try ipv4. */
if|if
condition|(
name|hints
operator|->
name|ai_family
operator|==
name|PF_INET
operator|||
name|hints
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|evutil_inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|nodename
argument_list|,
operator|&
name|sin
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
comment|/* Got an ipv6 address. */
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|evutil_new_addrinfo_
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|,
name|hints
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|res
condition|)
return|return
name|EVUTIL_EAI_MEMORY
return|;
return|return
literal|0
return|;
block|}
block|}
comment|/* If we have reached this point, we definitely need to do a DNS 	 * lookup. */
if|if
condition|(
operator|(
name|hints
operator|->
name|ai_flags
operator|&
name|EVUTIL_AI_NUMERICHOST
operator|)
condition|)
block|{
comment|/* If we're not allowed to do one, then say so. */
return|return
name|EVUTIL_EAI_NONAME
return|;
block|}
operator|*
name|portnum
operator|=
name|port
expr_stmt|;
return|return
name|EVUTIL_EAI_NEED_RESOLVE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_GETADDRINFO
end_ifdef

begin_define
define|#
directive|define
name|USE_NATIVE_GETADDRINFO
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_NATIVE_GETADDRINFO
end_ifdef

begin_comment
comment|/* A mask of all the flags that we declare, so we can clear them before calling  * the native getaddrinfo */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int
name|ALL_NONNATIVE_AI_FLAGS
init|=
ifndef|#
directive|ifndef
name|AI_PASSIVE
name|EVUTIL_AI_PASSIVE
operator||
endif|#
directive|endif
ifndef|#
directive|ifndef
name|AI_CANONNAME
name|EVUTIL_AI_CANONNAME
operator||
endif|#
directive|endif
ifndef|#
directive|ifndef
name|AI_NUMERICHOST
name|EVUTIL_AI_NUMERICHOST
operator||
endif|#
directive|endif
ifndef|#
directive|ifndef
name|AI_NUMERICSERV
name|EVUTIL_AI_NUMERICSERV
operator||
endif|#
directive|endif
ifndef|#
directive|ifndef
name|AI_ADDRCONFIG
name|EVUTIL_AI_ADDRCONFIG
operator||
endif|#
directive|endif
ifndef|#
directive|ifndef
name|AI_ALL
name|EVUTIL_AI_ALL
operator||
endif|#
directive|endif
ifndef|#
directive|ifndef
name|AI_V4MAPPED
name|EVUTIL_AI_V4MAPPED
operator||
endif|#
directive|endif
name|EVUTIL_AI_LIBEVENT_ALLOCATED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int
name|ALL_NATIVE_AI_FLAGS
init|=
ifdef|#
directive|ifdef
name|AI_PASSIVE
name|AI_PASSIVE
operator||
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AI_CANONNAME
name|AI_CANONNAME
operator||
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AI_NUMERICHOST
name|AI_NUMERICHOST
operator||
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AI_NUMERICSERV
name|AI_NUMERICSERV
operator||
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AI_ADDRCONFIG
name|AI_ADDRCONFIG
operator||
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AI_ALL
name|AI_ALL
operator||
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AI_V4MAPPED
name|AI_V4MAPPED
operator||
endif|#
directive|endif
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USE_NATIVE_GETADDRINFO
end_ifndef

begin_comment
comment|/* Helper for systems with no getaddrinfo(): make one or more addrinfos out of  * a struct hostent.  */
end_comment

begin_function
specifier|static
name|struct
name|evutil_addrinfo
modifier|*
name|addrinfo_from_hostent
parameter_list|(
specifier|const
name|struct
name|hostent
modifier|*
name|ent
parameter_list|,
name|int
name|port
parameter_list|,
specifier|const
name|struct
name|evutil_addrinfo
modifier|*
name|hints
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|int
name|socklen
decl_stmt|;
name|struct
name|evutil_addrinfo
modifier|*
name|res
init|=
name|NULL
decl_stmt|,
modifier|*
name|ai
decl_stmt|;
name|void
modifier|*
name|addrp
decl_stmt|;
if|if
condition|(
name|ent
operator|->
name|h_addrtype
operator|==
name|PF_INET
condition|)
block|{
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
name|socklen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|addrp
operator|=
operator|&
name|sin
operator|.
name|sin_addr
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|h_length
operator|!=
sizeof|sizeof
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|event_warnx
argument_list|(
literal|"Weird h_length from gethostbyname"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ent
operator|->
name|h_addrtype
operator|==
name|PF_INET6
condition|)
block|{
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
expr_stmt|;
name|socklen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|addrp
operator|=
operator|&
name|sin6
operator|.
name|sin6_addr
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|h_length
operator|!=
sizeof|sizeof
argument_list|(
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|event_warnx
argument_list|(
literal|"Weird h_length from gethostbyname"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ent
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
name|memcpy
argument_list|(
name|addrp
argument_list|,
name|ent
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|,
name|ent
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|ai
operator|=
name|evutil_new_addrinfo_
argument_list|(
name|sa
argument_list|,
name|socklen
argument_list|,
name|hints
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ai
condition|)
block|{
name|evutil_freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|res
operator|=
name|evutil_addrinfo_append_
argument_list|(
name|res
argument_list|,
name|ai
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|&&
operator|(
operator|(
name|hints
operator|->
name|ai_flags
operator|&
name|EVUTIL_AI_CANONNAME
operator|)
operator|&&
name|ent
operator|->
name|h_name
operator|)
condition|)
block|{
name|res
operator|->
name|ai_canonname
operator|=
name|mm_strdup
argument_list|(
name|ent
operator|->
name|h_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|ai_canonname
operator|==
name|NULL
condition|)
block|{
name|evutil_freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If the EVUTIL_AI_ADDRCONFIG flag is set on hints->ai_flags, and  * hints->ai_family is PF_UNSPEC, then revise the value of hints->ai_family so  * that we'll only get addresses we could maybe connect to.  */
end_comment

begin_function
name|void
name|evutil_adjust_hints_for_addrconfig_
parameter_list|(
name|struct
name|evutil_addrinfo
modifier|*
name|hints
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|hints
operator|->
name|ai_flags
operator|&
name|EVUTIL_AI_ADDRCONFIG
operator|)
condition|)
return|return;
if|if
condition|(
name|hints
operator|->
name|ai_family
operator|!=
name|PF_UNSPEC
condition|)
return|return;
if|if
condition|(
operator|!
name|have_checked_interfaces
condition|)
name|evutil_check_interfaces
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|had_ipv4_address
operator|&&
operator|!
name|had_ipv6_address
condition|)
block|{
name|hints
operator|->
name|ai_family
operator|=
name|PF_INET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|had_ipv4_address
operator|&&
name|had_ipv6_address
condition|)
block|{
name|hints
operator|->
name|ai_family
operator|=
name|PF_INET6
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_NATIVE_GETADDRINFO
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|need_numeric_port_hack_
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|need_socktype_protocol_hack_
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tested_for_getaddrinfo_hacks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some older BSDs (like OpenBSD up to 4.6) used to believe that    giving a numeric port without giving an ai_socktype was verboten.    We test for this so we can apply an appropriate workaround.  If it    turns out that the bug is present, then:      - If nodename==NULL and servname is numeric, we build an answer       ourselves using evutil_getaddrinfo_common_().      - If nodename!=NULL and servname is numeric, then we set       servname=NULL when calling getaddrinfo, and post-process the       result to set the ports on it.     We test for this bug at runtime, since otherwise we can't have the    same binary run on multiple BSD versions.     - Some versions of Solaris believe that it's nice to leave to protocol      field set to 0.  We test for this so we can apply an appropriate      workaround. */
end_comment

begin_function
specifier|static
name|void
name|test_for_getaddrinfo_hacks
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|r2
decl_stmt|;
name|struct
name|evutil_addrinfo
modifier|*
name|ai
init|=
name|NULL
decl_stmt|,
modifier|*
name|ai2
init|=
name|NULL
decl_stmt|;
name|struct
name|evutil_addrinfo
name|hints
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
ifdef|#
directive|ifdef
name|AI_NUMERICHOST
name|AI_NUMERICHOST
operator||
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AI_NUMERICSERV
name|AI_NUMERICSERV
operator||
endif|#
directive|endif
literal|0
expr_stmt|;
name|r
operator|=
name|getaddrinfo
argument_list|(
literal|"1.2.3.4"
argument_list|,
literal|"80"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|r2
operator|=
name|getaddrinfo
argument_list|(
literal|"1.2.3.4"
argument_list|,
literal|"80"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
operator|==
literal|0
operator|&&
name|r
operator|!=
literal|0
condition|)
block|{
name|need_numeric_port_hack_
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ai2
operator|&&
name|ai2
operator|->
name|ai_protocol
operator|==
literal|0
condition|)
block|{
name|need_socktype_protocol_hack_
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ai
condition|)
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai2
condition|)
name|freeaddrinfo
argument_list|(
name|ai2
argument_list|)
expr_stmt|;
name|tested_for_getaddrinfo_hacks
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|need_numeric_port_hack
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tested_for_getaddrinfo_hacks
condition|)
name|test_for_getaddrinfo_hacks
argument_list|()
expr_stmt|;
return|return
name|need_numeric_port_hack_
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|need_socktype_protocol_hack
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tested_for_getaddrinfo_hacks
condition|)
name|test_for_getaddrinfo_hacks
argument_list|()
expr_stmt|;
return|return
name|need_socktype_protocol_hack_
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|apply_numeric_port_hack
parameter_list|(
name|int
name|port
parameter_list|,
name|struct
name|evutil_addrinfo
modifier|*
modifier|*
name|ai
parameter_list|)
block|{
comment|/* Now we run through the list and set the ports on all of the 	 * results where ports would make sense. */
for|for
control|(
init|;
operator|*
name|ai
condition|;
name|ai
operator|=
operator|&
operator|(
operator|*
name|ai
operator|)
operator|->
name|ai_next
control|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa
init|=
operator|(
operator|*
name|ai
operator|)
operator|->
name|ai_addr
decl_stmt|;
if|if
condition|(
name|sa
operator|&&
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
decl_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|&&
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
decl_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A numeric port makes no sense here; remove this one 			 * from the list. */
name|struct
name|evutil_addrinfo
modifier|*
name|victim
init|=
operator|*
name|ai
decl_stmt|;
operator|*
name|ai
operator|=
name|victim
operator|->
name|ai_next
expr_stmt|;
name|victim
operator|->
name|ai_next
operator|=
name|NULL
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|victim
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|apply_socktype_protocol_hack
parameter_list|(
name|struct
name|evutil_addrinfo
modifier|*
name|ai
parameter_list|)
block|{
name|struct
name|evutil_addrinfo
modifier|*
name|ai_new
decl_stmt|;
for|for
control|(
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
name|evutil_getaddrinfo_infer_protocols
argument_list|(
name|ai
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_socktype
operator|||
name|ai
operator|->
name|ai_protocol
condition|)
continue|continue;
name|ai_new
operator|=
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ai_new
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ai_new
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
name|ai_new
argument_list|,
name|ai
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ai_new
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|->
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|ai
operator|->
name|ai_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|ai_new
operator|->
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|ai_new
operator|->
name|ai_protocol
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|ai_new
operator|->
name|ai_next
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
name|ai
operator|->
name|ai_next
operator|=
name|ai_new
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|evutil_getaddrinfo
parameter_list|(
specifier|const
name|char
modifier|*
name|nodename
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
specifier|const
name|struct
name|evutil_addrinfo
modifier|*
name|hints_in
parameter_list|,
name|struct
name|evutil_addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_NATIVE_GETADDRINFO
name|struct
name|evutil_addrinfo
name|hints
decl_stmt|;
name|int
name|portnum
init|=
operator|-
literal|1
decl_stmt|,
name|need_np_hack
decl_stmt|,
name|err
decl_stmt|;
if|if
condition|(
name|hints_in
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|hints
argument_list|,
name|hints_in
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|AI_ADDRCONFIG
comment|/* Not every system has AI_ADDRCONFIG, so fake it. */
if|if
condition|(
name|hints
operator|.
name|ai_family
operator|==
name|PF_UNSPEC
operator|&&
operator|(
name|hints
operator|.
name|ai_flags
operator|&
name|EVUTIL_AI_ADDRCONFIG
operator|)
condition|)
block|{
name|evutil_adjust_hints_for_addrconfig_
argument_list|(
operator|&
name|hints
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|AI_NUMERICSERV
comment|/* Not every system has AI_NUMERICSERV, so fake it. */
if|if
condition|(
name|hints
operator|.
name|ai_flags
operator|&
name|EVUTIL_AI_NUMERICSERV
condition|)
block|{
if|if
condition|(
name|servname
operator|&&
name|parse_numeric_servname
argument_list|(
name|servname
argument_list|)
operator|<
literal|0
condition|)
return|return
name|EVUTIL_EAI_NONAME
return|;
block|}
endif|#
directive|endif
comment|/* Enough operating systems handle enough common non-resolve 	 * cases here weirdly enough that we are better off just 	 * overriding them.  For example: 	 * 	 * - Windows doesn't like to infer the protocol from the 	 *   socket type, or fill in socket or protocol types much at 	 *   all.  It also seems to do its own broken implicit 	 *   always-on version of AI_ADDRCONFIG that keeps it from 	 *   ever resolving even a literal IPv6 address when 	 *   ai_addrtype is PF_UNSPEC. 	 */
ifdef|#
directive|ifdef
name|_WIN32
block|{
name|int
name|tmp_port
decl_stmt|;
name|err
operator|=
name|evutil_getaddrinfo_common_
argument_list|(
name|nodename
argument_list|,
name|servname
argument_list|,
operator|&
name|hints
argument_list|,
name|res
argument_list|,
operator|&
name|tmp_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|EVUTIL_EAI_MEMORY
operator|||
name|err
operator|==
name|EVUTIL_EAI_NONAME
condition|)
return|return
name|err
return|;
comment|/* If we make it here, the system getaddrinfo can 		 * have a crack at it. */
block|}
endif|#
directive|endif
comment|/* See documentation for need_numeric_port_hack above.*/
name|need_np_hack
operator|=
name|need_numeric_port_hack
argument_list|()
operator|&&
name|servname
operator|&&
operator|!
name|hints
operator|.
name|ai_socktype
operator|&&
operator|(
operator|(
name|portnum
operator|=
name|parse_numeric_servname
argument_list|(
name|servname
argument_list|)
operator|)
operator|>=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|need_np_hack
condition|)
block|{
if|if
condition|(
operator|!
name|nodename
condition|)
return|return
name|evutil_getaddrinfo_common_
argument_list|(
name|NULL
argument_list|,
name|servname
argument_list|,
operator|&
name|hints
argument_list|,
name|res
argument_list|,
operator|&
name|portnum
argument_list|)
return|;
name|servname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|need_socktype_protocol_hack
argument_list|()
condition|)
block|{
name|evutil_getaddrinfo_infer_protocols
argument_list|(
operator|&
name|hints
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure that we didn't actually steal any AI_FLAGS values that 	 * the system is using.  (This is a constant expression, and should ge 	 * optimized out.) 	 * 	 * XXXX Turn this into a compile-time failure rather than a run-time 	 * failure. 	 */
name|EVUTIL_ASSERT
argument_list|(
operator|(
name|ALL_NONNATIVE_AI_FLAGS
operator|&
name|ALL_NATIVE_AI_FLAGS
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear any flags that only libevent understands. */
name|hints
operator|.
name|ai_flags
operator|&=
operator|~
name|ALL_NONNATIVE_AI_FLAGS
expr_stmt|;
name|err
operator|=
name|getaddrinfo
argument_list|(
name|nodename
argument_list|,
name|servname
argument_list|,
operator|&
name|hints
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_np_hack
condition|)
name|apply_numeric_port_hack
argument_list|(
name|portnum
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_socktype_protocol_hack
argument_list|()
condition|)
block|{
if|if
condition|(
name|apply_socktype_protocol_hack
argument_list|(
operator|*
name|res
argument_list|)
operator|<
literal|0
condition|)
block|{
name|evutil_freeaddrinfo
argument_list|(
operator|*
name|res
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
return|return
name|EVUTIL_EAI_MEMORY
return|;
block|}
block|}
return|return
name|err
return|;
else|#
directive|else
name|int
name|port
init|=
literal|0
decl_stmt|,
name|err
decl_stmt|;
name|struct
name|hostent
modifier|*
name|ent
init|=
name|NULL
decl_stmt|;
name|struct
name|evutil_addrinfo
name|hints
decl_stmt|;
if|if
condition|(
name|hints_in
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|hints
argument_list|,
name|hints_in
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
block|}
name|evutil_adjust_hints_for_addrconfig_
argument_list|(
operator|&
name|hints
argument_list|)
expr_stmt|;
name|err
operator|=
name|evutil_getaddrinfo_common_
argument_list|(
name|nodename
argument_list|,
name|servname
argument_list|,
operator|&
name|hints
argument_list|,
name|res
argument_list|,
operator|&
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|EVUTIL_EAI_NEED_RESOLVE
condition|)
block|{
comment|/* We either succeeded or failed.  No need to continue */
return|return
name|err
return|;
block|}
name|err
operator|=
literal|0
expr_stmt|;
comment|/* Use any of the various gethostbyname_r variants as available. */
block|{
ifdef|#
directive|ifdef
name|EVENT__HAVE_GETHOSTBYNAME_R_6_ARG
comment|/* This one is what glibc provides. */
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
name|struct
name|hostent
name|hostent
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|gethostbyname_r
argument_list|(
name|nodename
argument_list|,
operator|&
name|hostent
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|ent
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|EVENT__HAVE_GETHOSTBYNAME_R_5_ARG
argument_list|)
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
name|struct
name|hostent
name|hostent
decl_stmt|;
name|ent
operator|=
name|gethostbyname_r
argument_list|(
name|nodename
argument_list|,
operator|&
name|hostent
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|EVENT__HAVE_GETHOSTBYNAME_R_3_ARG
argument_list|)
name|struct
name|hostent_data
name|data
decl_stmt|;
name|struct
name|hostent
name|hostent
decl_stmt|;
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|gethostbyname_r
argument_list|(
name|nodename
argument_list|,
operator|&
name|hostent
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|ent
operator|=
name|err
condition|?
name|NULL
else|:
operator|&
name|hostent
expr_stmt|;
else|#
directive|else
comment|/* fall back to gethostbyname. */
comment|/* XXXX This needs a lock everywhere but Windows. */
name|ent
operator|=
name|gethostbyname
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|err
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
else|#
directive|else
name|err
operator|=
name|h_errno
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* Now we have either ent or err set. */
if|if
condition|(
operator|!
name|ent
condition|)
block|{
comment|/* XXX is this right for windows ? */
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|TRY_AGAIN
case|:
return|return
name|EVUTIL_EAI_AGAIN
return|;
case|case
name|NO_RECOVERY
case|:
default|default:
return|return
name|EVUTIL_EAI_FAIL
return|;
case|case
name|HOST_NOT_FOUND
case|:
return|return
name|EVUTIL_EAI_NONAME
return|;
case|case
name|NO_ADDRESS
case|:
if|#
directive|if
name|NO_DATA
operator|!=
name|NO_ADDRESS
case|case
name|NO_DATA
case|:
endif|#
directive|endif
return|return
name|EVUTIL_EAI_NODATA
return|;
block|}
block|}
if|if
condition|(
name|ent
operator|->
name|h_addrtype
operator|!=
name|hints
operator|.
name|ai_family
operator|&&
name|hints
operator|.
name|ai_family
operator|!=
name|PF_UNSPEC
condition|)
block|{
comment|/* This wasn't the type we were hoping for.  Too bad 			 * we never had a chance to ask gethostbyname for what 			 * we wanted. */
return|return
name|EVUTIL_EAI_NONAME
return|;
block|}
comment|/* Make sure we got _some_ answers. */
if|if
condition|(
name|ent
operator|->
name|h_length
operator|==
literal|0
condition|)
return|return
name|EVUTIL_EAI_NODATA
return|;
comment|/* If we got an address type we don't know how to make a 		   sockaddr for, give up. */
if|if
condition|(
name|ent
operator|->
name|h_addrtype
operator|!=
name|PF_INET
operator|&&
name|ent
operator|->
name|h_addrtype
operator|!=
name|PF_INET6
condition|)
return|return
name|EVUTIL_EAI_FAMILY
return|;
operator|*
name|res
operator|=
name|addrinfo_from_hostent
argument_list|(
name|ent
argument_list|,
name|port
argument_list|,
operator|&
name|hints
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|res
condition|)
return|return
name|EVUTIL_EAI_MEMORY
return|;
block|}
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|evutil_freeaddrinfo
parameter_list|(
name|struct
name|evutil_addrinfo
modifier|*
name|ai
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|EVENT__HAVE_GETADDRINFO
if|if
condition|(
operator|!
operator|(
name|ai
operator|->
name|ai_flags
operator|&
name|EVUTIL_AI_LIBEVENT_ALLOCATED
operator|)
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
while|while
condition|(
name|ai
condition|)
block|{
name|struct
name|evutil_addrinfo
modifier|*
name|next
init|=
name|ai
operator|->
name|ai_next
decl_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
condition|)
name|mm_free
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|evdns_getaddrinfo_fn
name|evdns_getaddrinfo_impl
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|evutil_set_evdns_getaddrinfo_fn_
parameter_list|(
name|evdns_getaddrinfo_fn
name|fn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|evdns_getaddrinfo_impl
condition|)
name|evdns_getaddrinfo_impl
operator|=
name|fn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Internal helper function: act like evdns_getaddrinfo if dns_base is set;  * otherwise do a blocking resolve and pass the result to the callback in the  * way that evdns_getaddrinfo would.  */
end_comment

begin_function
name|int
name|evutil_getaddrinfo_async_
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|dns_base
parameter_list|,
specifier|const
name|char
modifier|*
name|nodename
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
specifier|const
name|struct
name|evutil_addrinfo
modifier|*
name|hints_in
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|struct
name|evutil_addrinfo
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|dns_base
operator|&&
name|evdns_getaddrinfo_impl
condition|)
block|{
name|evdns_getaddrinfo_impl
argument_list|(
name|dns_base
argument_list|,
name|nodename
argument_list|,
name|servname
argument_list|,
name|hints_in
argument_list|,
name|cb
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|evutil_addrinfo
modifier|*
name|ai
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|evutil_getaddrinfo
argument_list|(
name|nodename
argument_list|,
name|servname
argument_list|,
name|hints_in
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
name|cb
argument_list|(
name|err
argument_list|,
name|ai
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|evutil_gai_strerror
parameter_list|(
name|int
name|err
parameter_list|)
block|{
comment|/* As a sneaky side-benefit, this case statement will get most 	 * compilers to tell us if any of the error codes we defined 	 * conflict with the platform's native error codes. */
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|EVUTIL_EAI_CANCEL
case|:
return|return
literal|"Request canceled"
return|;
case|case
literal|0
case|:
return|return
literal|"No error"
return|;
case|case
name|EVUTIL_EAI_ADDRFAMILY
case|:
return|return
literal|"address family for nodename not supported"
return|;
case|case
name|EVUTIL_EAI_AGAIN
case|:
return|return
literal|"temporary failure in name resolution"
return|;
case|case
name|EVUTIL_EAI_BADFLAGS
case|:
return|return
literal|"invalid value for ai_flags"
return|;
case|case
name|EVUTIL_EAI_FAIL
case|:
return|return
literal|"non-recoverable failure in name resolution"
return|;
case|case
name|EVUTIL_EAI_FAMILY
case|:
return|return
literal|"ai_family not supported"
return|;
case|case
name|EVUTIL_EAI_MEMORY
case|:
return|return
literal|"memory allocation failure"
return|;
case|case
name|EVUTIL_EAI_NODATA
case|:
return|return
literal|"no address associated with nodename"
return|;
case|case
name|EVUTIL_EAI_NONAME
case|:
return|return
literal|"nodename nor servname provided, or not known"
return|;
case|case
name|EVUTIL_EAI_SERVICE
case|:
return|return
literal|"servname not supported for ai_socktype"
return|;
case|case
name|EVUTIL_EAI_SOCKTYPE
case|:
return|return
literal|"ai_socktype not supported"
return|;
case|case
name|EVUTIL_EAI_SYSTEM
case|:
return|return
literal|"system error"
return|;
default|default:
if|#
directive|if
name|defined
argument_list|(
name|USE_NATIVE_GETADDRINFO
argument_list|)
operator|&&
name|defined
argument_list|(
name|_WIN32
argument_list|)
return|return
name|gai_strerrorA
argument_list|(
name|err
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_NATIVE_GETADDRINFO
argument_list|)
return|return
name|gai_strerror
argument_list|(
name|err
argument_list|)
return|;
else|#
directive|else
return|return
literal|"Unknown error code"
return|;
endif|#
directive|endif
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_comment
comment|/* destructively remove a trailing line terminator from s */
end_comment

begin_function
specifier|static
name|void
name|chomp
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|s
operator|&&
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|s
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|s
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|s
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|s
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* FormatMessage returns allocated strings, but evutil_socket_error_to_string  * is supposed to return a string which is good indefinitely without having  * to be freed.  To make this work without leaking memory, we cache the  * string the first time FormatMessage is called on a particular error  * code, and then return the cached string on subsequent calls with the  * same code.  The strings aren't freed until libevent_global_shutdown  * (or never).  We use a linked list to cache the errors, because we  * only expect there to be a few dozen, and that should be fast enough.  */
end_comment

begin_struct
struct|struct
name|cached_sock_errs_entry
block|{
name|HT_ENTRY
argument_list|(
argument|cached_sock_errs_entry
argument_list|)
name|node
expr_stmt|;
name|DWORD
name|code
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* allocated with LocalAlloc; free with LocalFree */
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|unsigned
name|hash_cached_sock_errs
parameter_list|(
specifier|const
name|struct
name|cached_sock_errs_entry
modifier|*
name|e
parameter_list|)
block|{
comment|/* Use Murmur3's 32-bit finalizer as an integer hash function */
name|DWORD
name|h
init|=
name|e
operator|->
name|code
decl_stmt|;
name|h
operator|^=
name|h
operator|>>
literal|16
expr_stmt|;
name|h
operator|*=
literal|0x85ebca6b
expr_stmt|;
name|h
operator|^=
name|h
operator|>>
literal|13
expr_stmt|;
name|h
operator|*=
literal|0xc2b2ae35
expr_stmt|;
name|h
operator|^=
name|h
operator|>>
literal|16
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|eq_cached_sock_errs
parameter_list|(
specifier|const
name|struct
name|cached_sock_errs_entry
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|cached_sock_errs_entry
modifier|*
name|b
parameter_list|)
block|{
return|return
name|a
operator|->
name|code
operator|==
name|b
operator|->
name|code
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
end_ifndef

begin_decl_stmt
specifier|static
name|void
modifier|*
name|windows_socket_errors_lock_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|HT_HEAD
argument_list|(
argument|cached_sock_errs_map
argument_list|,
argument|cached_sock_errs_entry
argument_list|)
name|windows_socket_errors
operator|=
name|HT_INITIALIZER
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|HT_PROTOTYPE
argument_list|(
name|cached_sock_errs_map
argument_list|,
name|cached_sock_errs_entry
argument_list|,
name|node
argument_list|,
name|hash_cached_sock_errs
argument_list|,
name|eq_cached_sock_errs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|HT_GENERATE
argument_list|(
name|cached_sock_errs_map
argument_list|,
name|cached_sock_errs_entry
argument_list|,
name|node
argument_list|,
name|hash_cached_sock_errs
argument_list|,
name|eq_cached_sock_errs
argument_list|,
literal|0.5
argument_list|,
name|mm_malloc
argument_list|,
name|mm_realloc
argument_list|,
name|mm_free
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/** Equivalent to strerror, but for windows socket errors. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|evutil_socket_error_to_string
parameter_list|(
name|int
name|errcode
parameter_list|)
block|{
name|struct
name|cached_sock_errs_entry
modifier|*
name|errs
decl_stmt|,
modifier|*
name|newerr
decl_stmt|,
name|find
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|EVLOCK_LOCK
argument_list|(
name|windows_socket_errors_lock_
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|find
operator|.
name|code
operator|=
name|errcode
expr_stmt|;
name|errs
operator|=
name|HT_FIND
argument_list|(
name|cached_sock_errs_map
argument_list|,
operator|&
name|windows_socket_errors
argument_list|,
operator|&
name|find
argument_list|)
expr_stmt|;
if|if
condition|(
name|errs
condition|)
block|{
name|msg
operator|=
name|errs
operator|->
name|msg
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
literal|0
operator|!=
name|FormatMessage
argument_list|(
name|FORMAT_MESSAGE_FROM_SYSTEM
operator||
name|FORMAT_MESSAGE_IGNORE_INSERTS
operator||
name|FORMAT_MESSAGE_ALLOCATE_BUFFER
argument_list|,
name|NULL
argument_list|,
name|errcode
argument_list|,
literal|0
argument_list|,
operator|(
name|LPTSTR
operator|)
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
name|chomp
argument_list|(
name|msg
argument_list|)
expr_stmt|;
comment|/* because message has trailing newline */
else|else
block|{
name|size_t
name|len
init|=
literal|50
decl_stmt|;
comment|/* use LocalAlloc because FormatMessage does */
name|msg
operator|=
name|LocalAlloc
argument_list|(
name|LMEM_FIXED
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
block|{
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"LocalAlloc failed during Winsock error"
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|evutil_snprintf
argument_list|(
name|msg
argument_list|,
name|len
argument_list|,
literal|"winsock error 0x%08x"
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
block|}
name|newerr
operator|=
operator|(
expr|struct
name|cached_sock_errs_entry
operator|*
operator|)
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cached_sock_errs_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newerr
condition|)
block|{
name|LocalFree
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"malloc failed during Winsock error"
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|newerr
operator|->
name|code
operator|=
name|errcode
expr_stmt|;
name|newerr
operator|->
name|msg
operator|=
name|msg
expr_stmt|;
name|HT_INSERT
argument_list|(
name|cached_sock_errs_map
argument_list|,
operator|&
name|windows_socket_errors
argument_list|,
name|newerr
argument_list|)
expr_stmt|;
name|done
label|:
name|EVLOCK_UNLOCK
argument_list|(
name|windows_socket_errors_lock_
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
end_ifndef

begin_function
name|int
name|evutil_global_setup_locks_
parameter_list|(
specifier|const
name|int
name|enable_locks
parameter_list|)
block|{
name|EVTHREAD_SETUP_GLOBAL_LOCK
argument_list|(
name|windows_socket_errors_lock_
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|evutil_free_sock_err_globals
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cached_sock_errs_entry
modifier|*
modifier|*
name|errs
decl_stmt|,
modifier|*
name|tofree
decl_stmt|;
for|for
control|(
name|errs
operator|=
name|HT_START
argument_list|(
name|cached_sock_errs_map
argument_list|,
operator|&
name|windows_socket_errors
argument_list|)
init|;
name|errs
condition|;
control|)
block|{
name|tofree
operator|=
operator|*
name|errs
expr_stmt|;
name|errs
operator|=
name|HT_NEXT_RMV
argument_list|(
name|cached_sock_errs_map
argument_list|,
operator|&
name|windows_socket_errors
argument_list|,
name|errs
argument_list|)
expr_stmt|;
name|LocalFree
argument_list|(
name|tofree
operator|->
name|msg
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|tofree
argument_list|)
expr_stmt|;
block|}
name|HT_CLEAR
argument_list|(
name|cached_sock_errs_map
argument_list|,
operator|&
name|windows_socket_errors
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
if|if
condition|(
name|windows_socket_errors_lock_
operator|!=
name|NULL
condition|)
block|{
name|EVTHREAD_FREE_LOCK
argument_list|(
name|windows_socket_errors_lock_
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|windows_socket_errors_lock_
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
end_ifndef

begin_function
name|int
name|evutil_global_setup_locks_
parameter_list|(
specifier|const
name|int
name|enable_locks
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|evutil_free_sock_err_globals
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|evutil_snprintf
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|r
operator|=
name|evutil_vsnprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|evutil_vsnprintf
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|buflen
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
name|r
operator|=
name|_vsnprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|r
operator|=
name|_vscprintf
argument_list|(
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|sgi
argument_list|)
comment|/* Make sure we always use the correct vsnprintf on IRIX */
specifier|extern
name|int
name|_xpg5_vsnprintf
argument_list|(
name|char
operator|*
name|__restrict
argument_list|,
name|__SGI_LIBC_NAMESPACE_QUALIFIER
name|size_t
argument_list|,
specifier|const
name|char
operator|*
name|__restrict
argument_list|,
comment|/* va_list */
name|char
operator|*
argument_list|)
decl_stmt|;
name|r
operator|=
name|_xpg5_vsnprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|r
operator|=
name|vsnprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf
index|[
name|buflen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_define
define|#
directive|define
name|USE_INTERNAL_NTOP
end_define

begin_define
define|#
directive|define
name|USE_INTERNAL_PTON
end_define

begin_function
specifier|const
name|char
modifier|*
name|evutil_inet_ntop
parameter_list|(
name|int
name|af
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_INET_NTOP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|USE_INTERNAL_NTOP
argument_list|)
return|return
name|inet_ntop
argument_list|(
name|af
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|len
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|af
operator|==
name|AF_INET
condition|)
block|{
specifier|const
name|struct
name|in_addr
modifier|*
name|in
init|=
name|src
decl_stmt|;
specifier|const
name|ev_uint32_t
name|a
init|=
name|ntohl
argument_list|(
name|in
operator|->
name|s_addr
argument_list|)
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|evutil_snprintf
argument_list|(
name|dst
argument_list|,
name|len
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ev_uint8_t
argument_list|)
argument_list|(
operator|(
name|a
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ev_uint8_t
argument_list|)
argument_list|(
operator|(
name|a
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ev_uint8_t
argument_list|)
argument_list|(
operator|(
name|a
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ev_uint8_t
argument_list|)
argument_list|(
operator|(
name|a
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
operator|||
operator|(
name|size_t
operator|)
name|r
operator|>=
name|len
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|dst
return|;
ifdef|#
directive|ifdef
name|AF_INET6
block|}
elseif|else
if|if
condition|(
name|af
operator|==
name|AF_INET6
condition|)
block|{
specifier|const
name|struct
name|in6_addr
modifier|*
name|addr
init|=
name|src
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|longestGapLen
init|=
literal|0
decl_stmt|,
name|longestGapPos
init|=
operator|-
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|curGapPos
init|=
operator|-
literal|1
decl_stmt|,
name|curGapLen
init|=
literal|0
decl_stmt|;
name|ev_uint16_t
name|words
index|[
literal|8
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
name|words
index|[
name|i
index|]
operator|=
operator|(
operator|(
operator|(
name|ev_uint16_t
operator|)
name|addr
operator|->
name|s6_addr
index|[
literal|2
operator|*
name|i
index|]
operator|)
operator|<<
literal|8
operator|)
operator|+
name|addr
operator|->
name|s6_addr
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|words
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|words
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|words
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|words
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|words
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
operator|(
operator|(
name|words
index|[
literal|5
index|]
operator|==
literal|0
operator|&&
name|words
index|[
literal|6
index|]
operator|&&
name|words
index|[
literal|7
index|]
operator|)
operator|||
operator|(
name|words
index|[
literal|5
index|]
operator|==
literal|0xffff
operator|)
operator|)
condition|)
block|{
comment|/* This is an IPv4 address. */
if|if
condition|(
name|words
index|[
literal|5
index|]
operator|==
literal|0
condition|)
block|{
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"::%d.%d.%d.%d"
argument_list|,
name|addr
operator|->
name|s6_addr
index|[
literal|12
index|]
argument_list|,
name|addr
operator|->
name|s6_addr
index|[
literal|13
index|]
argument_list|,
name|addr
operator|->
name|s6_addr
index|[
literal|14
index|]
argument_list|,
name|addr
operator|->
name|s6_addr
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"::%x:%d.%d.%d.%d"
argument_list|,
name|words
index|[
literal|5
index|]
argument_list|,
name|addr
operator|->
name|s6_addr
index|[
literal|12
index|]
argument_list|,
name|addr
operator|->
name|s6_addr
index|[
literal|13
index|]
argument_list|,
name|addr
operator|->
name|s6_addr
index|[
literal|14
index|]
argument_list|,
name|addr
operator|->
name|s6_addr
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>
name|len
condition|)
return|return
name|NULL
return|;
name|strlcpy
argument_list|(
name|dst
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|dst
return|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|8
condition|)
block|{
if|if
condition|(
name|words
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|curGapPos
operator|=
name|i
operator|++
expr_stmt|;
name|curGapLen
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|8
operator|&&
name|words
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
operator|++
name|i
expr_stmt|;
operator|++
name|curGapLen
expr_stmt|;
block|}
if|if
condition|(
name|curGapLen
operator|>
name|longestGapLen
condition|)
block|{
name|longestGapPos
operator|=
name|curGapPos
expr_stmt|;
name|longestGapLen
operator|=
name|curGapLen
expr_stmt|;
block|}
block|}
else|else
block|{
operator|++
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|longestGapLen
operator|<=
literal|1
condition|)
name|longestGapPos
operator|=
operator|-
literal|1
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|words
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|longestGapPos
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
literal|':'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|':'
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|8
operator|&&
name|words
index|[
name|i
index|]
operator|==
literal|0
condition|)
operator|++
name|i
expr_stmt|;
operator|--
name|i
expr_stmt|;
comment|/* to compensate for loop increment. */
block|}
else|else
block|{
name|evutil_snprintf
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|buf
operator|)
argument_list|,
literal|"%x"
argument_list|,
operator|(
name|unsigned
operator|)
name|words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|7
condition|)
operator|*
name|cp
operator|++
operator|=
literal|':'
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>
name|len
condition|)
return|return
name|NULL
return|;
name|strlcpy
argument_list|(
name|dst
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|dst
return|;
endif|#
directive|endif
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|evutil_inet_pton
parameter_list|(
name|int
name|af
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_INET_PTON
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|USE_INTERNAL_PTON
argument_list|)
return|return
name|inet_pton
argument_list|(
name|af
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|af
operator|==
name|AF_INET
condition|)
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|char
name|more
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|addr
init|=
name|dst
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|src
argument_list|,
literal|"%d.%d.%d.%d%c"
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|d
argument_list|,
operator|&
name|more
argument_list|)
operator|!=
literal|4
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|a
operator|<
literal|0
operator|||
name|a
operator|>
literal|255
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|b
operator|<
literal|0
operator|||
name|b
operator|>
literal|255
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|<
literal|0
operator|||
name|c
operator|>
literal|255
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|d
operator|<
literal|0
operator|||
name|d
operator|>
literal|255
condition|)
return|return
literal|0
return|;
name|addr
operator|->
name|s_addr
operator|=
name|htonl
argument_list|(
operator|(
name|a
operator|<<
literal|24
operator|)
operator||
operator|(
name|b
operator|<<
literal|16
operator|)
operator||
operator|(
name|c
operator|<<
literal|8
operator|)
operator||
name|d
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|AF_INET6
block|}
elseif|else
if|if
condition|(
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|in6_addr
modifier|*
name|out
init|=
name|dst
decl_stmt|;
name|ev_uint16_t
name|words
index|[
literal|8
index|]
decl_stmt|;
name|int
name|gapPos
init|=
operator|-
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|setWords
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|dot
init|=
name|strchr
argument_list|(
name|src
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|eow
decl_stmt|;
comment|/* end of words. */
if|if
condition|(
name|dot
operator|==
name|src
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|!
name|dot
condition|)
name|eow
operator|=
name|src
operator|+
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|byte1
decl_stmt|,
name|byte2
decl_stmt|,
name|byte3
decl_stmt|,
name|byte4
decl_stmt|;
name|char
name|more
decl_stmt|;
for|for
control|(
name|eow
operator|=
name|dot
operator|-
literal|1
init|;
name|eow
operator|>=
name|src
operator|&&
name|EVUTIL_ISDIGIT_
argument_list|(
operator|*
name|eow
argument_list|)
condition|;
operator|--
name|eow
control|)
empty_stmt|;
operator|++
name|eow
expr_stmt|;
comment|/* We use "scanf" because some platform inet_aton()s are too lax 			 * about IPv4 addresses of the form "1.2.3" */
if|if
condition|(
name|sscanf
argument_list|(
name|eow
argument_list|,
literal|"%d.%d.%d.%d%c"
argument_list|,
operator|&
name|byte1
argument_list|,
operator|&
name|byte2
argument_list|,
operator|&
name|byte3
argument_list|,
operator|&
name|byte4
argument_list|,
operator|&
name|more
argument_list|)
operator|!=
literal|4
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|byte1
operator|>
literal|255
operator|||
name|byte1
operator|<
literal|0
operator|||
name|byte2
operator|>
literal|255
operator|||
name|byte2
operator|<
literal|0
operator|||
name|byte3
operator|>
literal|255
operator|||
name|byte3
operator|<
literal|0
operator|||
name|byte4
operator|>
literal|255
operator|||
name|byte4
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|words
index|[
literal|6
index|]
operator|=
operator|(
name|byte1
operator|<<
literal|8
operator|)
operator||
name|byte2
expr_stmt|;
name|words
index|[
literal|7
index|]
operator|=
operator|(
name|byte3
operator|<<
literal|8
operator|)
operator||
name|byte4
expr_stmt|;
name|setWords
operator|+=
literal|2
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|src
operator|<
name|eow
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|7
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|EVUTIL_ISXDIGIT_
argument_list|(
operator|*
name|src
argument_list|)
condition|)
block|{
name|char
modifier|*
name|next
decl_stmt|;
name|long
name|r
init|=
name|strtol
argument_list|(
name|src
argument_list|,
operator|&
name|next
argument_list|,
literal|16
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|>
literal|4
operator|+
name|src
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|next
operator|==
name|src
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|r
operator|<
literal|0
operator|||
name|r
operator|>
literal|65536
condition|)
return|return
literal|0
return|;
name|words
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|ev_uint16_t
operator|)
name|r
expr_stmt|;
name|setWords
operator|++
expr_stmt|;
name|src
operator|=
name|next
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|!=
literal|':'
operator|&&
name|src
operator|!=
name|eow
condition|)
return|return
literal|0
return|;
operator|++
name|src
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|src
operator|==
literal|':'
operator|&&
name|i
operator|>
literal|0
operator|&&
name|gapPos
operator|==
operator|-
literal|1
condition|)
block|{
name|gapPos
operator|=
name|i
expr_stmt|;
operator|++
name|src
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|src
operator|==
literal|':'
operator|&&
name|i
operator|==
literal|0
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|gapPos
operator|==
operator|-
literal|1
condition|)
block|{
name|gapPos
operator|=
name|i
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|setWords
operator|>
literal|8
operator|||
operator|(
name|setWords
operator|==
literal|8
operator|&&
name|gapPos
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
name|setWords
operator|<
literal|8
operator|&&
name|gapPos
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|gapPos
operator|>=
literal|0
condition|)
block|{
name|int
name|nToMove
init|=
name|setWords
operator|-
operator|(
name|dot
condition|?
literal|2
else|:
literal|0
operator|)
operator|-
name|gapPos
decl_stmt|;
name|int
name|gapLen
init|=
literal|8
operator|-
name|setWords
decl_stmt|;
comment|/* assert(nToMove>= 0); */
if|if
condition|(
name|nToMove
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* should be impossible */
name|memmove
argument_list|(
operator|&
name|words
index|[
name|gapPos
operator|+
name|gapLen
index|]
argument_list|,
operator|&
name|words
index|[
name|gapPos
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|ev_uint16_t
argument_list|)
operator|*
name|nToMove
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|words
index|[
name|gapPos
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ev_uint16_t
argument_list|)
operator|*
name|gapLen
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
name|out
operator|->
name|s6_addr
index|[
literal|2
operator|*
name|i
index|]
operator|=
name|words
index|[
name|i
index|]
operator|>>
literal|8
expr_stmt|;
name|out
operator|->
name|s6_addr
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|words
index|[
name|i
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
return|return
literal|1
return|;
endif|#
directive|endif
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|evutil_parse_sockaddr_port
parameter_list|(
specifier|const
name|char
modifier|*
name|ip_as_string
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|out
parameter_list|,
name|int
modifier|*
name|outlen
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|addr_part
decl_stmt|,
modifier|*
name|port_part
decl_stmt|;
name|int
name|is_ipv6
decl_stmt|;
comment|/* recognized formats are: 	 * [ipv6]:port 	 * ipv6 	 * [ipv6] 	 * ipv4:port 	 * ipv4 	 */
name|cp
operator|=
name|strchr
argument_list|(
name|ip_as_string
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ip_as_string
operator|==
literal|'['
condition|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|ip_as_string
argument_list|,
literal|']'
argument_list|)
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|len
operator|=
call|(
name|int
call|)
argument_list|(
name|cp
operator|-
operator|(
name|ip_as_string
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
name|ip_as_string
operator|+
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|addr_part
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|port_part
operator|=
name|cp
operator|+
literal|2
expr_stmt|;
else|else
name|port_part
operator|=
name|NULL
expr_stmt|;
name|is_ipv6
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|&&
name|strchr
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|is_ipv6
operator|=
literal|1
expr_stmt|;
name|addr_part
operator|=
name|ip_as_string
expr_stmt|;
name|port_part
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
condition|)
block|{
name|is_ipv6
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|-
name|ip_as_string
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
name|ip_as_string
argument_list|,
name|cp
operator|-
name|ip_as_string
argument_list|)
expr_stmt|;
name|buf
index|[
name|cp
operator|-
name|ip_as_string
index|]
operator|=
literal|'\0'
expr_stmt|;
name|addr_part
operator|=
name|buf
expr_stmt|;
name|port_part
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|addr_part
operator|=
name|ip_as_string
expr_stmt|;
name|port_part
operator|=
name|NULL
expr_stmt|;
name|is_ipv6
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|port_part
operator|==
name|NULL
condition|)
block|{
name|port
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|port
operator|=
name|atoi
argument_list|(
name|port_part
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<=
literal|0
operator|||
name|port
operator|>
literal|65535
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|!
name|addr_part
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Should be impossible. */
ifdef|#
directive|ifdef
name|AF_INET6
if|if
condition|(
name|is_ipv6
condition|)
block|{
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENT__HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|!=
name|evutil_inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|addr_part
argument_list|,
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
operator|>
operator|*
name|outlen
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
operator|*
name|outlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|outlen
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
endif|#
directive|endif
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EVENT__HAVE_STRUCT_SOCKADDR_IN_SIN_LEN
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|!=
name|evutil_inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|addr_part
argument_list|,
operator|&
name|sin
operator|.
name|sin_addr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
operator|>
operator|*
name|outlen
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
operator|*
name|outlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|outlen
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|evutil_format_sockaddr_port_
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|outlen
parameter_list|)
block|{
name|char
name|b
index|[
literal|128
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|int
name|port
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
decl_stmt|;
name|res
operator|=
name|evutil_inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|port
operator|=
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|evutil_snprintf
argument_list|(
name|out
argument_list|,
name|outlen
argument_list|,
literal|"%s:%d"
argument_list|,
name|b
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
decl_stmt|;
name|res
operator|=
name|evutil_inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|port
operator|=
name|ntohs
argument_list|(
name|sin6
operator|->
name|sin6_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|evutil_snprintf
argument_list|(
name|out
argument_list|,
name|outlen
argument_list|,
literal|"[%s]:%d"
argument_list|,
name|b
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
block|}
name|evutil_snprintf
argument_list|(
name|out
argument_list|,
name|outlen
argument_list|,
literal|"<addr with socktype %d>"
argument_list|,
operator|(
name|int
operator|)
name|sa
operator|->
name|sa_family
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
end_function

begin_function
name|int
name|evutil_sockaddr_cmp
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa1
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa2
parameter_list|,
name|int
name|include_port
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|r
operator|=
operator|(
name|sa1
operator|->
name|sa_family
operator|-
name|sa2
operator|->
name|sa_family
operator|)
operator|)
condition|)
return|return
name|r
return|;
if|if
condition|(
name|sa1
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|sin1
decl_stmt|,
modifier|*
name|sin2
decl_stmt|;
name|sin1
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa1
expr_stmt|;
name|sin2
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa2
expr_stmt|;
if|if
condition|(
name|sin1
operator|->
name|sin_addr
operator|.
name|s_addr
operator|<
name|sin2
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|sin1
operator|->
name|sin_addr
operator|.
name|s_addr
operator|>
name|sin2
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|include_port
operator|&&
operator|(
name|r
operator|=
operator|(
operator|(
name|int
operator|)
name|sin1
operator|->
name|sin_port
operator|-
operator|(
name|int
operator|)
name|sin2
operator|->
name|sin_port
operator|)
operator|)
condition|)
return|return
name|r
return|;
else|else
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|AF_INET6
elseif|else
if|if
condition|(
name|sa1
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|sin1
decl_stmt|,
modifier|*
name|sin2
decl_stmt|;
name|sin1
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa1
expr_stmt|;
name|sin2
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa2
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|memcmp
argument_list|(
name|sin1
operator|->
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
name|sin2
operator|->
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
literal|16
argument_list|)
operator|)
condition|)
return|return
name|r
return|;
elseif|else
if|if
condition|(
name|include_port
operator|&&
operator|(
name|r
operator|=
operator|(
operator|(
name|int
operator|)
name|sin1
operator|->
name|sin6_port
operator|-
operator|(
name|int
operator|)
name|sin2
operator|->
name|sin6_port
operator|)
operator|)
condition|)
return|return
name|r
return|;
else|else
return|return
literal|0
return|;
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Tables to implement ctypes-replacement EVUTIL_IS*() functions.  Each table  * has 256 bits to look up whether a character is in some set or not.  This  * fails on non-ASCII platforms, but so does every other place where we  * take a char and write it onto the network.  **/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|ev_uint32_t
name|EVUTIL_ISALPHA_TABLE
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0x7fffffe
block|,
literal|0x7fffffe
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|ev_uint32_t
name|EVUTIL_ISALNUM_TABLE
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|0x3ff0000
block|,
literal|0x7fffffe
block|,
literal|0x7fffffe
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|ev_uint32_t
name|EVUTIL_ISSPACE_TABLE
index|[
literal|8
index|]
init|=
block|{
literal|0x3e00
block|,
literal|0x1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|ev_uint32_t
name|EVUTIL_ISXDIGIT_TABLE
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|0x3ff0000
block|,
literal|0x7e
block|,
literal|0x7e
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|ev_uint32_t
name|EVUTIL_ISDIGIT_TABLE
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|0x3ff0000
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|ev_uint32_t
name|EVUTIL_ISPRINT_TABLE
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|0xffffffff
block|,
literal|0xffffffff
block|,
literal|0x7fffffff
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|ev_uint32_t
name|EVUTIL_ISUPPER_TABLE
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0x7fffffe
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|ev_uint32_t
name|EVUTIL_ISLOWER_TABLE
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x7fffffe
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Upper-casing and lowercasing tables to map characters to upper/lowercase  * equivalents. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|EVUTIL_TOUPPER_TABLE
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|65
block|,
literal|66
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
literal|70
block|,
literal|71
block|,
literal|72
block|,
literal|73
block|,
literal|74
block|,
literal|75
block|,
literal|76
block|,
literal|77
block|,
literal|78
block|,
literal|79
block|,
literal|80
block|,
literal|81
block|,
literal|82
block|,
literal|83
block|,
literal|84
block|,
literal|85
block|,
literal|86
block|,
literal|87
block|,
literal|88
block|,
literal|89
block|,
literal|90
block|,
literal|91
block|,
literal|92
block|,
literal|93
block|,
literal|94
block|,
literal|95
block|,
literal|96
block|,
literal|65
block|,
literal|66
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
literal|70
block|,
literal|71
block|,
literal|72
block|,
literal|73
block|,
literal|74
block|,
literal|75
block|,
literal|76
block|,
literal|77
block|,
literal|78
block|,
literal|79
block|,
literal|80
block|,
literal|81
block|,
literal|82
block|,
literal|83
block|,
literal|84
block|,
literal|85
block|,
literal|86
block|,
literal|87
block|,
literal|88
block|,
literal|89
block|,
literal|90
block|,
literal|123
block|,
literal|124
block|,
literal|125
block|,
literal|126
block|,
literal|127
block|,
literal|128
block|,
literal|129
block|,
literal|130
block|,
literal|131
block|,
literal|132
block|,
literal|133
block|,
literal|134
block|,
literal|135
block|,
literal|136
block|,
literal|137
block|,
literal|138
block|,
literal|139
block|,
literal|140
block|,
literal|141
block|,
literal|142
block|,
literal|143
block|,
literal|144
block|,
literal|145
block|,
literal|146
block|,
literal|147
block|,
literal|148
block|,
literal|149
block|,
literal|150
block|,
literal|151
block|,
literal|152
block|,
literal|153
block|,
literal|154
block|,
literal|155
block|,
literal|156
block|,
literal|157
block|,
literal|158
block|,
literal|159
block|,
literal|160
block|,
literal|161
block|,
literal|162
block|,
literal|163
block|,
literal|164
block|,
literal|165
block|,
literal|166
block|,
literal|167
block|,
literal|168
block|,
literal|169
block|,
literal|170
block|,
literal|171
block|,
literal|172
block|,
literal|173
block|,
literal|174
block|,
literal|175
block|,
literal|176
block|,
literal|177
block|,
literal|178
block|,
literal|179
block|,
literal|180
block|,
literal|181
block|,
literal|182
block|,
literal|183
block|,
literal|184
block|,
literal|185
block|,
literal|186
block|,
literal|187
block|,
literal|188
block|,
literal|189
block|,
literal|190
block|,
literal|191
block|,
literal|192
block|,
literal|193
block|,
literal|194
block|,
literal|195
block|,
literal|196
block|,
literal|197
block|,
literal|198
block|,
literal|199
block|,
literal|200
block|,
literal|201
block|,
literal|202
block|,
literal|203
block|,
literal|204
block|,
literal|205
block|,
literal|206
block|,
literal|207
block|,
literal|208
block|,
literal|209
block|,
literal|210
block|,
literal|211
block|,
literal|212
block|,
literal|213
block|,
literal|214
block|,
literal|215
block|,
literal|216
block|,
literal|217
block|,
literal|218
block|,
literal|219
block|,
literal|220
block|,
literal|221
block|,
literal|222
block|,
literal|223
block|,
literal|224
block|,
literal|225
block|,
literal|226
block|,
literal|227
block|,
literal|228
block|,
literal|229
block|,
literal|230
block|,
literal|231
block|,
literal|232
block|,
literal|233
block|,
literal|234
block|,
literal|235
block|,
literal|236
block|,
literal|237
block|,
literal|238
block|,
literal|239
block|,
literal|240
block|,
literal|241
block|,
literal|242
block|,
literal|243
block|,
literal|244
block|,
literal|245
block|,
literal|246
block|,
literal|247
block|,
literal|248
block|,
literal|249
block|,
literal|250
block|,
literal|251
block|,
literal|252
block|,
literal|253
block|,
literal|254
block|,
literal|255
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|EVUTIL_TOLOWER_TABLE
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|97
block|,
literal|98
block|,
literal|99
block|,
literal|100
block|,
literal|101
block|,
literal|102
block|,
literal|103
block|,
literal|104
block|,
literal|105
block|,
literal|106
block|,
literal|107
block|,
literal|108
block|,
literal|109
block|,
literal|110
block|,
literal|111
block|,
literal|112
block|,
literal|113
block|,
literal|114
block|,
literal|115
block|,
literal|116
block|,
literal|117
block|,
literal|118
block|,
literal|119
block|,
literal|120
block|,
literal|121
block|,
literal|122
block|,
literal|91
block|,
literal|92
block|,
literal|93
block|,
literal|94
block|,
literal|95
block|,
literal|96
block|,
literal|97
block|,
literal|98
block|,
literal|99
block|,
literal|100
block|,
literal|101
block|,
literal|102
block|,
literal|103
block|,
literal|104
block|,
literal|105
block|,
literal|106
block|,
literal|107
block|,
literal|108
block|,
literal|109
block|,
literal|110
block|,
literal|111
block|,
literal|112
block|,
literal|113
block|,
literal|114
block|,
literal|115
block|,
literal|116
block|,
literal|117
block|,
literal|118
block|,
literal|119
block|,
literal|120
block|,
literal|121
block|,
literal|122
block|,
literal|123
block|,
literal|124
block|,
literal|125
block|,
literal|126
block|,
literal|127
block|,
literal|128
block|,
literal|129
block|,
literal|130
block|,
literal|131
block|,
literal|132
block|,
literal|133
block|,
literal|134
block|,
literal|135
block|,
literal|136
block|,
literal|137
block|,
literal|138
block|,
literal|139
block|,
literal|140
block|,
literal|141
block|,
literal|142
block|,
literal|143
block|,
literal|144
block|,
literal|145
block|,
literal|146
block|,
literal|147
block|,
literal|148
block|,
literal|149
block|,
literal|150
block|,
literal|151
block|,
literal|152
block|,
literal|153
block|,
literal|154
block|,
literal|155
block|,
literal|156
block|,
literal|157
block|,
literal|158
block|,
literal|159
block|,
literal|160
block|,
literal|161
block|,
literal|162
block|,
literal|163
block|,
literal|164
block|,
literal|165
block|,
literal|166
block|,
literal|167
block|,
literal|168
block|,
literal|169
block|,
literal|170
block|,
literal|171
block|,
literal|172
block|,
literal|173
block|,
literal|174
block|,
literal|175
block|,
literal|176
block|,
literal|177
block|,
literal|178
block|,
literal|179
block|,
literal|180
block|,
literal|181
block|,
literal|182
block|,
literal|183
block|,
literal|184
block|,
literal|185
block|,
literal|186
block|,
literal|187
block|,
literal|188
block|,
literal|189
block|,
literal|190
block|,
literal|191
block|,
literal|192
block|,
literal|193
block|,
literal|194
block|,
literal|195
block|,
literal|196
block|,
literal|197
block|,
literal|198
block|,
literal|199
block|,
literal|200
block|,
literal|201
block|,
literal|202
block|,
literal|203
block|,
literal|204
block|,
literal|205
block|,
literal|206
block|,
literal|207
block|,
literal|208
block|,
literal|209
block|,
literal|210
block|,
literal|211
block|,
literal|212
block|,
literal|213
block|,
literal|214
block|,
literal|215
block|,
literal|216
block|,
literal|217
block|,
literal|218
block|,
literal|219
block|,
literal|220
block|,
literal|221
block|,
literal|222
block|,
literal|223
block|,
literal|224
block|,
literal|225
block|,
literal|226
block|,
literal|227
block|,
literal|228
block|,
literal|229
block|,
literal|230
block|,
literal|231
block|,
literal|232
block|,
literal|233
block|,
literal|234
block|,
literal|235
block|,
literal|236
block|,
literal|237
block|,
literal|238
block|,
literal|239
block|,
literal|240
block|,
literal|241
block|,
literal|242
block|,
literal|243
block|,
literal|244
block|,
literal|245
block|,
literal|246
block|,
literal|247
block|,
literal|248
block|,
literal|249
block|,
literal|250
block|,
literal|251
block|,
literal|252
block|,
literal|253
block|,
literal|254
block|,
literal|255
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IMPL_CTYPE_FN
parameter_list|(
name|name
parameter_list|)
define|\
value|int EVUTIL_##name##_(char c) {					\ 		ev_uint8_t u = c;					\ 		return !!(EVUTIL_##name##_TABLE[(u>> 5)& 7]& (1<< (u& 31))); \ 	}
end_define

begin_macro
name|IMPL_CTYPE_FN
argument_list|(
argument|ISALPHA
argument_list|)
end_macro

begin_macro
name|IMPL_CTYPE_FN
argument_list|(
argument|ISALNUM
argument_list|)
end_macro

begin_macro
name|IMPL_CTYPE_FN
argument_list|(
argument|ISSPACE
argument_list|)
end_macro

begin_macro
name|IMPL_CTYPE_FN
argument_list|(
argument|ISDIGIT
argument_list|)
end_macro

begin_macro
name|IMPL_CTYPE_FN
argument_list|(
argument|ISXDIGIT
argument_list|)
end_macro

begin_macro
name|IMPL_CTYPE_FN
argument_list|(
argument|ISPRINT
argument_list|)
end_macro

begin_macro
name|IMPL_CTYPE_FN
argument_list|(
argument|ISLOWER
argument_list|)
end_macro

begin_macro
name|IMPL_CTYPE_FN
argument_list|(
argument|ISUPPER
argument_list|)
end_macro

begin_function
name|char
name|EVUTIL_TOLOWER_
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
operator|(
operator|(
name|char
operator|)
name|EVUTIL_TOLOWER_TABLE
index|[
operator|(
name|ev_uint8_t
operator|)
name|c
index|]
operator|)
return|;
block|}
end_function

begin_function
name|char
name|EVUTIL_TOUPPER_
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
operator|(
operator|(
name|char
operator|)
name|EVUTIL_TOUPPER_TABLE
index|[
operator|(
name|ev_uint8_t
operator|)
name|c
index|]
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evutil_ascii_strcasecmp
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c1
operator|=
name|EVUTIL_TOLOWER_
argument_list|(
operator|*
name|s1
operator|++
argument_list|)
expr_stmt|;
name|c2
operator|=
name|EVUTIL_TOLOWER_
argument_list|(
operator|*
name|s2
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|<
name|c2
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|c1
operator|>
name|c2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|c1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|evutil_ascii_strncasecmp
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|c1
operator|=
name|EVUTIL_TOLOWER_
argument_list|(
operator|*
name|s1
operator|++
argument_list|)
expr_stmt|;
name|c2
operator|=
name|EVUTIL_TOLOWER_
argument_list|(
operator|*
name|s2
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|<
name|c2
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|c1
operator|>
name|c2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|c1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|evutil_rtrim_lws_
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'\0'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|cp
operator|==
name|str
operator|)
condition|)
return|return;
operator|--
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|str
condition|)
break|break;
operator|--
name|cp
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|evutil_issetugid
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|EVENT__HAVE_ISSETUGID
return|return
name|issetugid
argument_list|()
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|EVENT__HAVE_GETEUID
if|if
condition|(
name|getuid
argument_list|()
operator|!=
name|geteuid
argument_list|()
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EVENT__HAVE_GETEGID
if|if
condition|(
name|getgid
argument_list|()
operator|!=
name|getegid
argument_list|()
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|evutil_getenv_
parameter_list|(
specifier|const
name|char
modifier|*
name|varname
parameter_list|)
block|{
if|if
condition|(
name|evutil_issetugid
argument_list|()
condition|)
return|return
name|NULL
return|;
return|return
name|getenv
argument_list|(
name|varname
argument_list|)
return|;
block|}
end_function

begin_function
name|ev_uint32_t
name|evutil_weakrand_seed_
parameter_list|(
name|struct
name|evutil_weakrand_state
modifier|*
name|state
parameter_list|,
name|ev_uint32_t
name|seed
parameter_list|)
block|{
if|if
condition|(
name|seed
operator|==
literal|0
condition|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|seed
operator|=
operator|(
name|ev_uint32_t
operator|)
name|tv
operator|.
name|tv_sec
operator|+
operator|(
name|ev_uint32_t
operator|)
name|tv
operator|.
name|tv_usec
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|seed
operator|+=
operator|(
name|ev_uint32_t
operator|)
name|_getpid
argument_list|()
expr_stmt|;
else|#
directive|else
name|seed
operator|+=
operator|(
name|ev_uint32_t
operator|)
name|getpid
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|state
operator|->
name|seed
operator|=
name|seed
expr_stmt|;
return|return
name|seed
return|;
block|}
end_function

begin_function
name|ev_int32_t
name|evutil_weakrand_
parameter_list|(
name|struct
name|evutil_weakrand_state
modifier|*
name|state
parameter_list|)
block|{
comment|/* This RNG implementation is a linear congruential generator, with 	 * modulus 2^31, multiplier 1103515245, and addend 12345.  It's also 	 * used by OpenBSD, and by Glibc's TYPE_0 RNG. 	 * 	 * The linear congruential generator is not an industrial-strength 	 * RNG!  It's fast, but it can have higher-order patterns.  Notably, 	 * the low bits tend to have periodicity. 	 */
name|state
operator|->
name|seed
operator|=
operator|(
operator|(
name|state
operator|->
name|seed
operator|)
operator|*
literal|1103515245
operator|+
literal|12345
operator|)
operator|&
literal|0x7fffffff
expr_stmt|;
return|return
call|(
name|ev_int32_t
call|)
argument_list|(
name|state
operator|->
name|seed
argument_list|)
return|;
block|}
end_function

begin_function
name|ev_int32_t
name|evutil_weakrand_range_
parameter_list|(
name|struct
name|evutil_weakrand_state
modifier|*
name|state
parameter_list|,
name|ev_int32_t
name|top
parameter_list|)
block|{
name|ev_int32_t
name|divisor
decl_stmt|,
name|result
decl_stmt|;
comment|/* We can't just do weakrand() % top, since the low bits of the LCG 	 * are less random than the high ones.  (Specifically, since the LCG 	 * modulus is 2^N, every 2^m for m<N will divide the modulus, and so 	 * therefore the low m bits of the LCG will have period 2^m.) */
name|divisor
operator|=
name|EVUTIL_WEAKRAND_MAX
operator|/
name|top
expr_stmt|;
do|do
block|{
name|result
operator|=
name|evutil_weakrand_
argument_list|(
name|state
argument_list|)
operator|/
name|divisor
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|>=
name|top
condition|)
do|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * Volatile pointer to memset: we use this to keep the compiler from  * eliminating our call to memset.  */
end_comment

begin_expr_stmt
name|void
argument_list|*
operator|(
operator|*
specifier|volatile
name|evutil_memset_volatile_
operator|)
operator|(
name|void
operator|*
operator|,
name|int
operator|,
name|size_t
operator|)
operator|=
name|memset
argument_list|;
name|void
name|evutil_memclear_
argument_list|(
argument|void *mem
argument_list|,
argument|size_t len
argument_list|)
block|{
name|evutil_memset_volatile_
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
block|; }
name|int
name|evutil_sockaddr_is_loopback_
argument_list|(
argument|const struct sockaddr *addr
argument_list|)
block|{
specifier|static
specifier|const
name|char
name|LOOPBACK_S6
index|[
literal|16
index|]
operator|=
literal|"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1"
block|;
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
decl_stmt|;
return|return
operator|(
name|ntohl
argument_list|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|&
literal|0xff000000
operator|)
operator|==
literal|0x7f000000
return|;
block|}
elseif|else
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
decl_stmt|;
return|return
operator|!
name|memcmp
argument_list|(
name|sin6
operator|->
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
name|LOOPBACK_S6
argument_list|,
literal|16
argument_list|)
return|;
block|}
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_macro
unit|}  int
name|evutil_hex_char_to_int_
argument_list|(
argument|char c
argument_list|)
end_macro

begin_block
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
return|return
literal|0
return|;
case|case
literal|'1'
case|:
return|return
literal|1
return|;
case|case
literal|'2'
case|:
return|return
literal|2
return|;
case|case
literal|'3'
case|:
return|return
literal|3
return|;
case|case
literal|'4'
case|:
return|return
literal|4
return|;
case|case
literal|'5'
case|:
return|return
literal|5
return|;
case|case
literal|'6'
case|:
return|return
literal|6
return|;
case|case
literal|'7'
case|:
return|return
literal|7
return|;
case|case
literal|'8'
case|:
return|return
literal|8
return|;
case|case
literal|'9'
case|:
return|return
literal|9
return|;
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
return|return
literal|10
return|;
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
return|return
literal|11
return|;
case|case
literal|'C'
case|:
case|case
literal|'c'
case|:
return|return
literal|12
return|;
case|case
literal|'D'
case|:
case|case
literal|'d'
case|:
return|return
literal|13
return|;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
return|return
literal|14
return|;
case|case
literal|'F'
case|:
case|case
literal|'f'
case|:
return|return
literal|15
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_function
name|HANDLE
name|evutil_load_windows_system_library_
parameter_list|(
specifier|const
name|TCHAR
modifier|*
name|library_name
parameter_list|)
block|{
name|TCHAR
name|path
index|[
name|MAX_PATH
index|]
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|n
operator|=
name|GetSystemDirectory
argument_list|(
name|path
argument_list|,
name|MAX_PATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|n
operator|+
name|_tcslen
argument_list|(
name|library_name
argument_list|)
operator|+
literal|2
operator|>=
name|MAX_PATH
condition|)
return|return
literal|0
return|;
name|_tcscat
argument_list|(
name|path
argument_list|,
name|TEXT
argument_list|(
literal|"\\"
argument_list|)
argument_list|)
expr_stmt|;
name|_tcscat
argument_list|(
name|path
argument_list|,
name|library_name
argument_list|)
expr_stmt|;
return|return
name|LoadLibrary
argument_list|(
name|path
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Internal wrapper around 'socket' to provide Linux-style support for  * syscall-saving methods where available.  *  * In addition to regular socket behavior, you can use a bitwise or to set the  * flags EVUTIL_SOCK_NONBLOCK and EVUTIL_SOCK_CLOEXEC in the 'type' argument,  * to make the socket nonblocking or close-on-exec with as few syscalls as  * possible.  */
end_comment

begin_function
name|evutil_socket_t
name|evutil_socket_
parameter_list|(
name|int
name|domain
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|protocol
parameter_list|)
block|{
name|evutil_socket_t
name|r
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SOCK_NONBLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|SOCK_CLOEXEC
argument_list|)
name|r
operator|=
name|socket
argument_list|(
name|domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
return|return
name|r
return|;
elseif|else
if|if
condition|(
operator|(
name|type
operator|&
operator|(
name|SOCK_NONBLOCK
operator||
name|SOCK_CLOEXEC
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
define|#
directive|define
name|SOCKET_TYPE_MASK
value|(~(EVUTIL_SOCK_NONBLOCK|EVUTIL_SOCK_CLOEXEC))
name|r
operator|=
name|socket
argument_list|(
name|domain
argument_list|,
name|type
operator|&
name|SOCKET_TYPE_MASK
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|type
operator|&
name|EVUTIL_SOCK_NONBLOCK
condition|)
block|{
if|if
condition|(
name|evutil_fast_socket_nonblocking
argument_list|(
name|r
argument_list|)
operator|<
literal|0
condition|)
block|{
name|evutil_closesocket
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|type
operator|&
name|EVUTIL_SOCK_CLOEXEC
condition|)
block|{
if|if
condition|(
name|evutil_fast_socket_closeonexec
argument_list|(
name|r
argument_list|)
operator|<
literal|0
condition|)
block|{
name|evutil_closesocket
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Internal wrapper around 'accept' or 'accept4' to provide Linux-style  * support for syscall-saving methods where available.  *  * In addition to regular accept behavior, you can set one or more of flags  * EVUTIL_SOCK_NONBLOCK and EVUTIL_SOCK_CLOEXEC in the 'flags' argument, to  * make the socket nonblocking or close-on-exec with as few syscalls as  * possible.  */
end_comment

begin_function
name|evutil_socket_t
name|evutil_accept4_
parameter_list|(
name|evutil_socket_t
name|sockfd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|ev_socklen_t
modifier|*
name|addrlen
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|evutil_socket_t
name|result
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_ACCEPT4
argument_list|)
operator|&&
name|defined
argument_list|(
name|SOCK_CLOEXEC
argument_list|)
operator|&&
name|defined
argument_list|(
name|SOCK_NONBLOCK
argument_list|)
name|result
operator|=
name|accept4
argument_list|(
name|sockfd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>=
literal|0
operator|||
operator|(
name|errno
operator|!=
name|EINVAL
operator|&&
name|errno
operator|!=
name|ENOSYS
operator|)
condition|)
block|{
comment|/* A nonnegative result means that we succeeded, so return. 		 * Failing with EINVAL means that an option wasn't supported, 		 * and failing with ENOSYS means that the syscall wasn't 		 * there: in those cases we want to fall back.  Otherwise, we 		 * got a real error, and we should return. */
return|return
name|result
return|;
block|}
endif|#
directive|endif
name|result
operator|=
name|accept
argument_list|(
name|sockfd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
return|return
name|result
return|;
if|if
condition|(
name|flags
operator|&
name|EVUTIL_SOCK_CLOEXEC
condition|)
block|{
if|if
condition|(
name|evutil_fast_socket_closeonexec
argument_list|(
name|result
argument_list|)
operator|<
literal|0
condition|)
block|{
name|evutil_closesocket
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|EVUTIL_SOCK_NONBLOCK
condition|)
block|{
if|if
condition|(
name|evutil_fast_socket_nonblocking
argument_list|(
name|result
argument_list|)
operator|<
literal|0
condition|)
block|{
name|evutil_closesocket
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Internal function: Set fd[0] and fd[1] to a pair of fds such that writes on  * fd[0] get read from fd[1].  Make both fds nonblocking and close-on-exec.  * Return 0 on success, -1 on failure.  */
end_comment

begin_function
name|int
name|evutil_make_internal_pipe_
parameter_list|(
name|evutil_socket_t
name|fd
index|[
literal|2
index|]
parameter_list|)
block|{
comment|/* 	  Making the second socket nonblocking is a bit subtle, given that we 	  ignore any EAGAIN returns when writing to it, and you don't usally 	  do that for a nonblocking socket. But if the kernel gives us EAGAIN, 	  then there's no need to add any more data to the buffer, since 	  the main thread is already either about to wake up and drain it, 	  or woken up and in the process of draining it. 	*/
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_PIPE2
argument_list|)
if|if
condition|(
name|pipe2
argument_list|(
name|fd
argument_list|,
name|O_NONBLOCK
operator||
name|O_CLOEXEC
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_PIPE
argument_list|)
if|if
condition|(
name|pipe
argument_list|(
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|evutil_fast_socket_nonblocking
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
operator|||
name|evutil_fast_socket_nonblocking
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
operator|||
name|evutil_fast_socket_closeonexec
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
operator|||
name|evutil_fast_socket_closeonexec
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fd
index|[
literal|0
index|]
operator|=
name|fd
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
else|else
block|{
name|event_warn
argument_list|(
literal|"%s: pipe"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_WIN32
define|#
directive|define
name|LOCAL_SOCKETPAIR_AF
value|AF_INET
else|#
directive|else
define|#
directive|define
name|LOCAL_SOCKETPAIR_AF
value|AF_UNIX
endif|#
directive|endif
if|if
condition|(
name|evutil_socketpair
argument_list|(
name|LOCAL_SOCKETPAIR_AF
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|evutil_fast_socket_nonblocking
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
operator|||
name|evutil_fast_socket_nonblocking
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
operator|||
name|evutil_fast_socket_closeonexec
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
operator|||
name|evutil_fast_socket_closeonexec
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|evutil_closesocket
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|evutil_closesocket
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fd
index|[
literal|0
index|]
operator|=
name|fd
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
name|fd
index|[
literal|0
index|]
operator|=
name|fd
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Wrapper around eventfd on systems that provide it.  Unlike the system  * eventfd, it always supports EVUTIL_EFD_CLOEXEC and EVUTIL_EFD_NONBLOCK as  * flags.  Returns -1 on error or if eventfd is not supported.  */
end_comment

begin_function
name|evutil_socket_t
name|evutil_eventfd_
parameter_list|(
name|unsigned
name|initval
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_EVENTFD
argument_list|)
operator|&&
name|defined
argument_list|(
name|EVENT__HAVE_SYS_EVENTFD_H
argument_list|)
name|int
name|r
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EFD_CLOEXEC
argument_list|)
operator|&&
name|defined
argument_list|(
name|EFD_NONBLOCK
argument_list|)
name|r
operator|=
name|eventfd
argument_list|(
name|initval
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
operator|||
name|flags
operator|==
literal|0
condition|)
return|return
name|r
return|;
endif|#
directive|endif
name|r
operator|=
name|eventfd
argument_list|(
name|initval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
name|r
return|;
if|if
condition|(
name|flags
operator|&
name|EVUTIL_EFD_CLOEXEC
condition|)
block|{
if|if
condition|(
name|evutil_fast_socket_closeonexec
argument_list|(
name|r
argument_list|)
operator|<
literal|0
condition|)
block|{
name|evutil_closesocket
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|EVUTIL_EFD_NONBLOCK
condition|)
block|{
if|if
condition|(
name|evutil_fast_socket_nonblocking
argument_list|(
name|r
argument_list|)
operator|<
literal|0
condition|)
block|{
name|evutil_closesocket
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|r
return|;
else|#
directive|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|evutil_free_globals_
parameter_list|(
name|void
parameter_list|)
block|{
name|evutil_free_secure_rng_globals_
argument_list|()
expr_stmt|;
name|evutil_free_sock_err_globals
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

