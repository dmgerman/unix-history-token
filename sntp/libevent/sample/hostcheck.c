begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  *                                  _   _ ____  _  *  Project                     ___| | | |  _ \| |  *                             / __| | | | |_) | |  *                            | (__| |_| |  _<| |___  *                             \___|\___/|_| \_\_____|  *  * Copyright (C) 1998 - 2012, Daniel Stenberg,<daniel@haxx.se>, et al.  *  * This software is licensed as described in the file COPYING, which  * you should have received as part of this distribution. The terms  * are also available at http://curl.haxx.se/docs/copyright.html.  *  * You may opt to use, copy, modify, merge, publish, distribute and/or sell  * copies of the Software, and permit persons to whom the Software is  * furnished to do so, under the terms of the COPYING file.  *  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY  * KIND, either express or implied.  *  ***************************************************************************/
end_comment

begin_comment
comment|/* This file is an amalgamation of hostcheck.c and most of rawstr.c    from cURL.  The contents of the COPYING file mentioned above are:  COPYRIGHT AND PERMISSION NOTICE  Copyright (c) 1996 - 2013, Daniel Stenberg,<daniel@haxx.se>.  All rights reserved.  Permission to use, copy, modify, and distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  Except as contained in this notice, the name of a copyright holder shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization of the copyright holder. */
end_comment

begin_include
include|#
directive|include
file|"hostcheck.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* Portable, consistent toupper (remember EBCDIC). Do not use toupper() because    its behavior is altered by the current locale. */
end_comment

begin_function
specifier|static
name|char
name|Curl_raw_toupper
parameter_list|(
name|char
name|in
parameter_list|)
block|{
switch|switch
condition|(
name|in
condition|)
block|{
case|case
literal|'a'
case|:
return|return
literal|'A'
return|;
case|case
literal|'b'
case|:
return|return
literal|'B'
return|;
case|case
literal|'c'
case|:
return|return
literal|'C'
return|;
case|case
literal|'d'
case|:
return|return
literal|'D'
return|;
case|case
literal|'e'
case|:
return|return
literal|'E'
return|;
case|case
literal|'f'
case|:
return|return
literal|'F'
return|;
case|case
literal|'g'
case|:
return|return
literal|'G'
return|;
case|case
literal|'h'
case|:
return|return
literal|'H'
return|;
case|case
literal|'i'
case|:
return|return
literal|'I'
return|;
case|case
literal|'j'
case|:
return|return
literal|'J'
return|;
case|case
literal|'k'
case|:
return|return
literal|'K'
return|;
case|case
literal|'l'
case|:
return|return
literal|'L'
return|;
case|case
literal|'m'
case|:
return|return
literal|'M'
return|;
case|case
literal|'n'
case|:
return|return
literal|'N'
return|;
case|case
literal|'o'
case|:
return|return
literal|'O'
return|;
case|case
literal|'p'
case|:
return|return
literal|'P'
return|;
case|case
literal|'q'
case|:
return|return
literal|'Q'
return|;
case|case
literal|'r'
case|:
return|return
literal|'R'
return|;
case|case
literal|'s'
case|:
return|return
literal|'S'
return|;
case|case
literal|'t'
case|:
return|return
literal|'T'
return|;
case|case
literal|'u'
case|:
return|return
literal|'U'
return|;
case|case
literal|'v'
case|:
return|return
literal|'V'
return|;
case|case
literal|'w'
case|:
return|return
literal|'W'
return|;
case|case
literal|'x'
case|:
return|return
literal|'X'
return|;
case|case
literal|'y'
case|:
return|return
literal|'Y'
return|;
case|case
literal|'z'
case|:
return|return
literal|'Z'
return|;
block|}
return|return
name|in
return|;
block|}
end_function

begin_comment
comment|/*  * Curl_raw_equal() is for doing "raw" case insensitive strings. This is meant  * to be locale independent and only compare strings we know are safe for  * this.  See http://daniel.haxx.se/blog/2008/10/15/strcasecmp-in-turkish/ for  * some further explanation to why this function is necessary.  *  * The function is capable of comparing a-z case insensitively even for  * non-ascii.  */
end_comment

begin_function
specifier|static
name|int
name|Curl_raw_equal
parameter_list|(
specifier|const
name|char
modifier|*
name|first
parameter_list|,
specifier|const
name|char
modifier|*
name|second
parameter_list|)
block|{
while|while
condition|(
operator|*
name|first
operator|&&
operator|*
name|second
condition|)
block|{
if|if
condition|(
name|Curl_raw_toupper
argument_list|(
operator|*
name|first
argument_list|)
operator|!=
name|Curl_raw_toupper
argument_list|(
operator|*
name|second
argument_list|)
condition|)
comment|/* get out of the loop as soon as they don't match */
break|break;
name|first
operator|++
expr_stmt|;
name|second
operator|++
expr_stmt|;
block|}
comment|/* we do the comparison here (possibly again), just to make sure that if the      loop above is skipped because one of the strings reached zero, we must not      return this as a successful match */
return|return
operator|(
name|Curl_raw_toupper
argument_list|(
operator|*
name|first
argument_list|)
operator|==
name|Curl_raw_toupper
argument_list|(
operator|*
name|second
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|Curl_raw_nequal
parameter_list|(
specifier|const
name|char
modifier|*
name|first
parameter_list|,
specifier|const
name|char
modifier|*
name|second
parameter_list|,
name|size_t
name|max
parameter_list|)
block|{
while|while
condition|(
operator|*
name|first
operator|&&
operator|*
name|second
operator|&&
name|max
condition|)
block|{
if|if
condition|(
name|Curl_raw_toupper
argument_list|(
operator|*
name|first
argument_list|)
operator|!=
name|Curl_raw_toupper
argument_list|(
operator|*
name|second
argument_list|)
condition|)
block|{
break|break;
block|}
name|max
operator|--
expr_stmt|;
name|first
operator|++
expr_stmt|;
name|second
operator|++
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|max
condition|)
return|return
literal|1
return|;
comment|/* they are equal this far */
return|return
name|Curl_raw_toupper
argument_list|(
operator|*
name|first
argument_list|)
operator|==
name|Curl_raw_toupper
argument_list|(
operator|*
name|second
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Match a hostname against a wildcard pattern.  * E.g.  *  "foo.host.com" matches "*.host.com".  *  * We use the matching rule described in RFC6125, section 6.4.3.  * http://tools.ietf.org/html/rfc6125#section-6.4.3  */
end_comment

begin_function
specifier|static
name|int
name|hostmatch
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pattern_label_end
decl_stmt|,
modifier|*
name|pattern_wildcard
decl_stmt|,
modifier|*
name|hostname_label_end
decl_stmt|;
name|int
name|wildcard_enabled
decl_stmt|;
name|size_t
name|prefixlen
decl_stmt|,
name|suffixlen
decl_stmt|;
name|pattern_wildcard
operator|=
name|strchr
argument_list|(
name|pattern
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern_wildcard
operator|==
name|NULL
condition|)
return|return
name|Curl_raw_equal
argument_list|(
name|pattern
argument_list|,
name|hostname
argument_list|)
condition|?
name|CURL_HOST_MATCH
else|:
name|CURL_HOST_NOMATCH
return|;
comment|/* We require at least 2 dots in pattern to avoid too wide wildcard      match. */
name|wildcard_enabled
operator|=
literal|1
expr_stmt|;
name|pattern_label_end
operator|=
name|strchr
argument_list|(
name|pattern
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern_label_end
operator|==
name|NULL
operator|||
name|strchr
argument_list|(
name|pattern_label_end
operator|+
literal|1
argument_list|,
literal|'.'
argument_list|)
operator|==
name|NULL
operator|||
name|pattern_wildcard
operator|>
name|pattern_label_end
operator|||
name|Curl_raw_nequal
argument_list|(
name|pattern
argument_list|,
literal|"xn--"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|wildcard_enabled
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|wildcard_enabled
condition|)
return|return
name|Curl_raw_equal
argument_list|(
name|pattern
argument_list|,
name|hostname
argument_list|)
condition|?
name|CURL_HOST_MATCH
else|:
name|CURL_HOST_NOMATCH
return|;
name|hostname_label_end
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname_label_end
operator|==
name|NULL
operator|||
operator|!
name|Curl_raw_equal
argument_list|(
name|pattern_label_end
argument_list|,
name|hostname_label_end
argument_list|)
condition|)
return|return
name|CURL_HOST_NOMATCH
return|;
comment|/* The wildcard must match at least one character, so the left-most      label of the hostname is at least as large as the left-most label      of the pattern. */
if|if
condition|(
name|hostname_label_end
operator|-
name|hostname
operator|<
name|pattern_label_end
operator|-
name|pattern
condition|)
return|return
name|CURL_HOST_NOMATCH
return|;
name|prefixlen
operator|=
name|pattern_wildcard
operator|-
name|pattern
expr_stmt|;
name|suffixlen
operator|=
name|pattern_label_end
operator|-
operator|(
name|pattern_wildcard
operator|+
literal|1
operator|)
expr_stmt|;
return|return
name|Curl_raw_nequal
argument_list|(
name|pattern
argument_list|,
name|hostname
argument_list|,
name|prefixlen
argument_list|)
operator|&&
name|Curl_raw_nequal
argument_list|(
name|pattern_wildcard
operator|+
literal|1
argument_list|,
name|hostname_label_end
operator|-
name|suffixlen
argument_list|,
name|suffixlen
argument_list|)
condition|?
name|CURL_HOST_MATCH
else|:
name|CURL_HOST_NOMATCH
return|;
block|}
end_function

begin_function
name|int
name|Curl_cert_hostcheck
parameter_list|(
specifier|const
name|char
modifier|*
name|match_pattern
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
block|{
if|if
condition|(
operator|!
name|match_pattern
operator|||
operator|!
operator|*
name|match_pattern
operator|||
operator|!
name|hostname
operator|||
operator|!
operator|*
name|hostname
condition|)
comment|/* sanity check */
return|return
literal|0
return|;
if|if
condition|(
name|Curl_raw_equal
argument_list|(
name|hostname
argument_list|,
name|match_pattern
argument_list|)
condition|)
comment|/* trivial case */
return|return
literal|1
return|;
if|if
condition|(
name|hostmatch
argument_list|(
name|hostname
argument_list|,
name|match_pattern
argument_list|)
operator|==
name|CURL_HOST_MATCH
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

