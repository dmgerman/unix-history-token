begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson  * Copyright (c) 2002-2006 Niels Provos<provos@citi.umich.edu>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_STDARG_H
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|"mm-internal.h"
end_include

begin_include
include|#
directive|include
file|"bufferevent-internal.h"
end_include

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|be_filter_enable
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|,
name|short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|be_filter_disable
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|,
name|short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|be_filter_unlink
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|be_filter_destruct
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|be_filter_readcb
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|be_filter_writecb
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|be_filter_eventcb
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|be_filter_flush
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|short
name|iotype
parameter_list|,
name|enum
name|bufferevent_flush_mode
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|be_filter_ctrl
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|,
name|enum
name|bufferevent_ctrl_op
parameter_list|,
name|union
name|bufferevent_ctrl_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bufferevent_filtered_outbuf_cb
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|evbuffer_cb_info
modifier|*
name|info
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|bufferevent_filtered
block|{
name|struct
name|bufferevent_private
name|bev
decl_stmt|;
comment|/** The bufferevent that we read/write filtered data from/to. */
name|struct
name|bufferevent
modifier|*
name|underlying
decl_stmt|;
comment|/** A callback on our outbuf to notice when somebody adds data */
name|struct
name|evbuffer_cb_entry
modifier|*
name|outbuf_cb
decl_stmt|;
comment|/** True iff we have received an EOF callback from the underlying 	 * bufferevent. */
name|unsigned
name|got_eof
decl_stmt|;
comment|/** Function to free context when we're done. */
name|void
function_decl|(
modifier|*
name|free_context
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/** Input filter */
name|bufferevent_filter_cb
name|process_in
decl_stmt|;
comment|/** Output filter */
name|bufferevent_filter_cb
name|process_out
decl_stmt|;
comment|/** User-supplied argument to the filters. */
name|void
modifier|*
name|context
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|const
name|struct
name|bufferevent_ops
name|bufferevent_ops_filter
init|=
block|{
literal|"filter"
block|,
name|evutil_offsetof
argument_list|(
expr|struct
name|bufferevent_filtered
argument_list|,
name|bev
operator|.
name|bev
argument_list|)
block|,
name|be_filter_enable
block|,
name|be_filter_disable
block|,
name|be_filter_unlink
block|,
name|be_filter_destruct
block|,
name|bufferevent_generic_adj_timeouts_
block|,
name|be_filter_flush
block|,
name|be_filter_ctrl
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a bufferevent that's really the bev filter of a bufferevent_filtered,  * return that bufferevent_filtered. Returns NULL otherwise.*/
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|bufferevent_filtered
modifier|*
name|upcast
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|struct
name|bufferevent_filtered
modifier|*
name|bev_f
decl_stmt|;
if|if
condition|(
name|bev
operator|->
name|be_ops
operator|!=
operator|&
name|bufferevent_ops_filter
condition|)
return|return
name|NULL
return|;
name|bev_f
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|bev
operator|)
operator|-
name|evutil_offsetof
argument_list|(
expr|struct
name|bufferevent_filtered
argument_list|,
name|bev
operator|.
name|bev
argument_list|)
operator|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|bev_f
operator|->
name|bev
operator|.
name|bev
operator|.
name|be_ops
operator|==
operator|&
name|bufferevent_ops_filter
argument_list|)
expr_stmt|;
return|return
name|bev_f
return|;
block|}
end_function

begin_define
define|#
directive|define
name|downcast
parameter_list|(
name|bev_f
parameter_list|)
value|(&(bev_f)->bev.bev)
end_define

begin_comment
comment|/** Return 1 iff bevf's underlying bufferevent's output buffer is at or  * over its high watermark such that we should not write to it in a given  * flush mode. */
end_comment

begin_function
specifier|static
name|int
name|be_underlying_writebuf_full
parameter_list|(
name|struct
name|bufferevent_filtered
modifier|*
name|bevf
parameter_list|,
name|enum
name|bufferevent_flush_mode
name|state
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|u
init|=
name|bevf
operator|->
name|underlying
decl_stmt|;
return|return
name|state
operator|==
name|BEV_NORMAL
operator|&&
name|u
operator|->
name|wm_write
operator|.
name|high
operator|&&
name|evbuffer_get_length
argument_list|(
name|u
operator|->
name|output
argument_list|)
operator|>=
name|u
operator|->
name|wm_write
operator|.
name|high
return|;
block|}
end_function

begin_comment
comment|/** Return 1 if our input buffer is at or over its high watermark such that we  * should not write to it in a given flush mode. */
end_comment

begin_function
specifier|static
name|int
name|be_readbuf_full
parameter_list|(
name|struct
name|bufferevent_filtered
modifier|*
name|bevf
parameter_list|,
name|enum
name|bufferevent_flush_mode
name|state
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|bufev
init|=
name|downcast
argument_list|(
name|bevf
argument_list|)
decl_stmt|;
return|return
name|state
operator|==
name|BEV_NORMAL
operator|&&
name|bufev
operator|->
name|wm_read
operator|.
name|high
operator|&&
name|evbuffer_get_length
argument_list|(
name|bufev
operator|->
name|input
argument_list|)
operator|>=
name|bufev
operator|->
name|wm_read
operator|.
name|high
return|;
block|}
end_function

begin_comment
comment|/* Filter to use when we're created with a NULL filter. */
end_comment

begin_function
specifier|static
name|enum
name|bufferevent_filter_result
name|be_null_filter
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|src
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|dst
parameter_list|,
name|ev_ssize_t
name|lim
parameter_list|,
name|enum
name|bufferevent_flush_mode
name|state
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
operator|(
name|void
operator|)
name|state
expr_stmt|;
if|if
condition|(
name|evbuffer_remove_buffer
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|lim
argument_list|)
operator|==
literal|0
condition|)
return|return
name|BEV_OK
return|;
else|else
return|return
name|BEV_ERROR
return|;
block|}
end_function

begin_function
name|struct
name|bufferevent
modifier|*
name|bufferevent_filter_new
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|underlying
parameter_list|,
name|bufferevent_filter_cb
name|input_filter
parameter_list|,
name|bufferevent_filter_cb
name|output_filter
parameter_list|,
name|int
name|options
parameter_list|,
name|void
function_decl|(
modifier|*
name|free_context
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|bufferevent_filtered
modifier|*
name|bufev_f
decl_stmt|;
name|int
name|tmp_options
init|=
name|options
operator|&
operator|~
name|BEV_OPT_THREADSAFE
decl_stmt|;
if|if
condition|(
operator|!
name|underlying
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|input_filter
condition|)
name|input_filter
operator|=
name|be_null_filter
expr_stmt|;
if|if
condition|(
operator|!
name|output_filter
condition|)
name|output_filter
operator|=
name|be_null_filter
expr_stmt|;
name|bufev_f
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bufferevent_filtered
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufev_f
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bufferevent_init_common_
argument_list|(
operator|&
name|bufev_f
operator|->
name|bev
argument_list|,
name|underlying
operator|->
name|ev_base
argument_list|,
operator|&
name|bufferevent_ops_filter
argument_list|,
name|tmp_options
argument_list|)
operator|<
literal|0
condition|)
block|{
name|mm_free
argument_list|(
name|bufev_f
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|options
operator|&
name|BEV_OPT_THREADSAFE
condition|)
block|{
name|bufferevent_enable_locking_
argument_list|(
name|downcast
argument_list|(
name|bufev_f
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|bufev_f
operator|->
name|underlying
operator|=
name|underlying
expr_stmt|;
name|bufev_f
operator|->
name|process_in
operator|=
name|input_filter
expr_stmt|;
name|bufev_f
operator|->
name|process_out
operator|=
name|output_filter
expr_stmt|;
name|bufev_f
operator|->
name|free_context
operator|=
name|free_context
expr_stmt|;
name|bufev_f
operator|->
name|context
operator|=
name|ctx
expr_stmt|;
name|bufferevent_setcb
argument_list|(
name|bufev_f
operator|->
name|underlying
argument_list|,
name|be_filter_readcb
argument_list|,
name|be_filter_writecb
argument_list|,
name|be_filter_eventcb
argument_list|,
name|bufev_f
argument_list|)
expr_stmt|;
name|bufev_f
operator|->
name|outbuf_cb
operator|=
name|evbuffer_add_cb
argument_list|(
name|downcast
argument_list|(
name|bufev_f
argument_list|)
operator|->
name|output
argument_list|,
name|bufferevent_filtered_outbuf_cb
argument_list|,
name|bufev_f
argument_list|)
expr_stmt|;
name|bufferevent_init_generic_timeout_cbs_
argument_list|(
name|downcast
argument_list|(
name|bufev_f
argument_list|)
argument_list|)
expr_stmt|;
name|bufferevent_incref_
argument_list|(
name|underlying
argument_list|)
expr_stmt|;
name|bufferevent_enable
argument_list|(
name|underlying
argument_list|,
name|EV_READ
operator||
name|EV_WRITE
argument_list|)
expr_stmt|;
name|bufferevent_suspend_read_
argument_list|(
name|underlying
argument_list|,
name|BEV_SUSPEND_FILT_READ
argument_list|)
expr_stmt|;
return|return
name|downcast
argument_list|(
name|bufev_f
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|be_filter_unlink
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|struct
name|bufferevent_filtered
modifier|*
name|bevf
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|bevf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bevf
operator|->
name|bev
operator|.
name|options
operator|&
name|BEV_OPT_CLOSE_ON_FREE
condition|)
block|{
comment|/* Yes, there is also a decref in bufferevent_decref_. 		 * That decref corresponds to the incref when we set 		 * underlying for the first time.  This decref is an 		 * extra one to remove the last reference. 		 */
if|if
condition|(
name|BEV_UPCAST
argument_list|(
name|bevf
operator|->
name|underlying
argument_list|)
operator|->
name|refcnt
operator|<
literal|2
condition|)
block|{
name|event_warnx
argument_list|(
literal|"BEV_OPT_CLOSE_ON_FREE set on an "
literal|"bufferevent with too few references"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bufferevent_free
argument_list|(
name|bevf
operator|->
name|underlying
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bevf
operator|->
name|underlying
condition|)
block|{
if|if
condition|(
name|bevf
operator|->
name|underlying
operator|->
name|errorcb
operator|==
name|be_filter_eventcb
condition|)
name|bufferevent_setcb
argument_list|(
name|bevf
operator|->
name|underlying
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bufferevent_unsuspend_read_
argument_list|(
name|bevf
operator|->
name|underlying
argument_list|,
name|BEV_SUSPEND_FILT_READ
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|be_filter_destruct
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|struct
name|bufferevent_filtered
modifier|*
name|bevf
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|bevf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bevf
operator|->
name|free_context
condition|)
name|bevf
operator|->
name|free_context
argument_list|(
name|bevf
operator|->
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|be_filter_enable
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|short
name|event
parameter_list|)
block|{
name|struct
name|bufferevent_filtered
modifier|*
name|bevf
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
if|if
condition|(
name|event
operator|&
name|EV_WRITE
condition|)
name|BEV_RESET_GENERIC_WRITE_TIMEOUT
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|EV_READ
condition|)
block|{
name|BEV_RESET_GENERIC_READ_TIMEOUT
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bufferevent_unsuspend_read_
argument_list|(
name|bevf
operator|->
name|underlying
argument_list|,
name|BEV_SUSPEND_FILT_READ
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|be_filter_disable
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|short
name|event
parameter_list|)
block|{
name|struct
name|bufferevent_filtered
modifier|*
name|bevf
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
if|if
condition|(
name|event
operator|&
name|EV_WRITE
condition|)
name|BEV_DEL_GENERIC_WRITE_TIMEOUT
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|EV_READ
condition|)
block|{
name|BEV_DEL_GENERIC_READ_TIMEOUT
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bufferevent_suspend_read_
argument_list|(
name|bevf
operator|->
name|underlying
argument_list|,
name|BEV_SUSPEND_FILT_READ
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|bufferevent_filter_result
name|be_filter_process_input
parameter_list|(
name|struct
name|bufferevent_filtered
modifier|*
name|bevf
parameter_list|,
name|enum
name|bufferevent_flush_mode
name|state
parameter_list|,
name|int
modifier|*
name|processed_out
parameter_list|)
block|{
name|enum
name|bufferevent_filter_result
name|res
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev
init|=
name|downcast
argument_list|(
name|bevf
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|BEV_NORMAL
condition|)
block|{
comment|/* If we're in 'normal' mode, don't urge data on the filter 		 * unless we're reading data and under our high-water mark.*/
if|if
condition|(
operator|!
operator|(
name|bev
operator|->
name|enabled
operator|&
name|EV_READ
operator|)
operator|||
name|be_readbuf_full
argument_list|(
name|bevf
argument_list|,
name|state
argument_list|)
condition|)
return|return
name|BEV_OK
return|;
block|}
do|do
block|{
name|ev_ssize_t
name|limit
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|BEV_NORMAL
operator|&&
name|bev
operator|->
name|wm_read
operator|.
name|high
condition|)
name|limit
operator|=
name|bev
operator|->
name|wm_read
operator|.
name|high
operator|-
name|evbuffer_get_length
argument_list|(
name|bev
operator|->
name|input
argument_list|)
expr_stmt|;
name|res
operator|=
name|bevf
operator|->
name|process_in
argument_list|(
name|bevf
operator|->
name|underlying
operator|->
name|input
argument_list|,
name|bev
operator|->
name|input
argument_list|,
name|limit
argument_list|,
name|state
argument_list|,
name|bevf
operator|->
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|BEV_OK
condition|)
operator|*
name|processed_out
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|res
operator|==
name|BEV_OK
operator|&&
operator|(
name|bev
operator|->
name|enabled
operator|&
name|EV_READ
operator|)
operator|&&
name|evbuffer_get_length
argument_list|(
name|bevf
operator|->
name|underlying
operator|->
name|input
argument_list|)
operator|&&
operator|!
name|be_readbuf_full
argument_list|(
name|bevf
argument_list|,
name|state
argument_list|)
condition|)
do|;
if|if
condition|(
operator|*
name|processed_out
condition|)
name|BEV_RESET_GENERIC_READ_TIMEOUT
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|bufferevent_filter_result
name|be_filter_process_output
parameter_list|(
name|struct
name|bufferevent_filtered
modifier|*
name|bevf
parameter_list|,
name|enum
name|bufferevent_flush_mode
name|state
parameter_list|,
name|int
modifier|*
name|processed_out
parameter_list|)
block|{
comment|/* Requires references and lock: might call writecb */
name|enum
name|bufferevent_filter_result
name|res
init|=
name|BEV_OK
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bufev
init|=
name|downcast
argument_list|(
name|bevf
argument_list|)
decl_stmt|;
name|int
name|again
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|BEV_NORMAL
condition|)
block|{
comment|/* If we're in 'normal' mode, don't urge data on the 		 * filter unless we're writing data, and the underlying 		 * bufferevent is accepting data, and we have data to 		 * give the filter.  If we're in 'flush' or 'finish', 		 * call the filter no matter what. */
if|if
condition|(
operator|!
operator|(
name|bufev
operator|->
name|enabled
operator|&
name|EV_WRITE
operator|)
operator|||
name|be_underlying_writebuf_full
argument_list|(
name|bevf
argument_list|,
name|state
argument_list|)
operator|||
operator|!
name|evbuffer_get_length
argument_list|(
name|bufev
operator|->
name|output
argument_list|)
condition|)
return|return
name|BEV_OK
return|;
block|}
comment|/* disable the callback that calls this function 	   when the user adds to the output buffer. */
name|evbuffer_cb_set_flags
argument_list|(
name|bufev
operator|->
name|output
argument_list|,
name|bevf
operator|->
name|outbuf_cb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|processed
init|=
literal|0
decl_stmt|;
name|again
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|ev_ssize_t
name|limit
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|BEV_NORMAL
operator|&&
name|bevf
operator|->
name|underlying
operator|->
name|wm_write
operator|.
name|high
condition|)
name|limit
operator|=
name|bevf
operator|->
name|underlying
operator|->
name|wm_write
operator|.
name|high
operator|-
name|evbuffer_get_length
argument_list|(
name|bevf
operator|->
name|underlying
operator|->
name|output
argument_list|)
expr_stmt|;
name|res
operator|=
name|bevf
operator|->
name|process_out
argument_list|(
name|downcast
argument_list|(
name|bevf
argument_list|)
operator|->
name|output
argument_list|,
name|bevf
operator|->
name|underlying
operator|->
name|output
argument_list|,
name|limit
argument_list|,
name|state
argument_list|,
name|bevf
operator|->
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|BEV_OK
condition|)
name|processed
operator|=
operator|*
name|processed_out
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
comment|/* Stop if the filter wasn't successful...*/
name|res
operator|==
name|BEV_OK
operator|&&
comment|/* Or if we aren't writing any more. */
operator|(
name|bufev
operator|->
name|enabled
operator|&
name|EV_WRITE
operator|)
operator|&&
comment|/* Of if we have nothing more to write and we are 			 * not flushing. */
name|evbuffer_get_length
argument_list|(
name|bufev
operator|->
name|output
argument_list|)
operator|&&
comment|/* Or if we have filled the underlying output buffer. */
operator|!
name|be_underlying_writebuf_full
argument_list|(
name|bevf
argument_list|,
name|state
argument_list|)
condition|)
do|;
if|if
condition|(
name|processed
condition|)
block|{
comment|/* call the write callback.*/
name|bufferevent_trigger_nolock_
argument_list|(
name|bufev
argument_list|,
name|EV_WRITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|BEV_OK
operator|&&
operator|(
name|bufev
operator|->
name|enabled
operator|&
name|EV_WRITE
operator|)
operator|&&
name|evbuffer_get_length
argument_list|(
name|bufev
operator|->
name|output
argument_list|)
operator|&&
operator|!
name|be_underlying_writebuf_full
argument_list|(
name|bevf
argument_list|,
name|state
argument_list|)
condition|)
block|{
name|again
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|again
condition|)
do|;
comment|/* reenable the outbuf_cb */
name|evbuffer_cb_set_flags
argument_list|(
name|bufev
operator|->
name|output
argument_list|,
name|bevf
operator|->
name|outbuf_cb
argument_list|,
name|EVBUFFER_CB_ENABLED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|processed_out
condition|)
name|BEV_RESET_GENERIC_WRITE_TIMEOUT
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Called when the size of our outbuf changes. */
end_comment

begin_function
specifier|static
name|void
name|bufferevent_filtered_outbuf_cb
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|evbuffer_cb_info
modifier|*
name|cbinfo
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bufferevent_filtered
modifier|*
name|bevf
init|=
name|arg
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev
init|=
name|downcast
argument_list|(
name|bevf
argument_list|)
decl_stmt|;
if|if
condition|(
name|cbinfo
operator|->
name|n_added
condition|)
block|{
name|int
name|processed_any
init|=
literal|0
decl_stmt|;
comment|/* Somebody added more data to the output buffer. Try to 		 * process it, if we should. */
name|bufferevent_incref_and_lock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|be_filter_process_output
argument_list|(
name|bevf
argument_list|,
name|BEV_NORMAL
argument_list|,
operator|&
name|processed_any
argument_list|)
expr_stmt|;
name|bufferevent_decref_and_unlock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called when the underlying socket has read. */
end_comment

begin_function
specifier|static
name|void
name|be_filter_readcb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|underlying
parameter_list|,
name|void
modifier|*
name|me_
parameter_list|)
block|{
name|struct
name|bufferevent_filtered
modifier|*
name|bevf
init|=
name|me_
decl_stmt|;
name|enum
name|bufferevent_filter_result
name|res
decl_stmt|;
name|enum
name|bufferevent_flush_mode
name|state
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bufev
init|=
name|downcast
argument_list|(
name|bevf
argument_list|)
decl_stmt|;
name|int
name|processed_any
init|=
literal|0
decl_stmt|;
name|bufferevent_incref_and_lock_
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bevf
operator|->
name|got_eof
condition|)
name|state
operator|=
name|BEV_FINISHED
expr_stmt|;
else|else
name|state
operator|=
name|BEV_NORMAL
expr_stmt|;
comment|/* XXXX use return value */
name|res
operator|=
name|be_filter_process_input
argument_list|(
name|bevf
argument_list|,
name|state
argument_list|,
operator|&
name|processed_any
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|res
expr_stmt|;
comment|/* XXX This should be in process_input, not here.  There are 	 * other places that can call process-input, and they should 	 * force readcb calls as needed. */
if|if
condition|(
name|processed_any
condition|)
name|bufferevent_trigger_nolock_
argument_list|(
name|bufev
argument_list|,
name|EV_READ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bufferevent_decref_and_unlock_
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when the underlying socket has drained enough that we can write to    it. */
end_comment

begin_function
specifier|static
name|void
name|be_filter_writecb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|underlying
parameter_list|,
name|void
modifier|*
name|me_
parameter_list|)
block|{
name|struct
name|bufferevent_filtered
modifier|*
name|bevf
init|=
name|me_
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev
init|=
name|downcast
argument_list|(
name|bevf
argument_list|)
decl_stmt|;
name|int
name|processed_any
init|=
literal|0
decl_stmt|;
name|bufferevent_incref_and_lock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|be_filter_process_output
argument_list|(
name|bevf
argument_list|,
name|BEV_NORMAL
argument_list|,
operator|&
name|processed_any
argument_list|)
expr_stmt|;
name|bufferevent_decref_and_unlock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when the underlying socket has given us an error */
end_comment

begin_function
specifier|static
name|void
name|be_filter_eventcb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|underlying
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|me_
parameter_list|)
block|{
name|struct
name|bufferevent_filtered
modifier|*
name|bevf
init|=
name|me_
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev
init|=
name|downcast
argument_list|(
name|bevf
argument_list|)
decl_stmt|;
name|bufferevent_incref_and_lock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
comment|/* All we can really to is tell our own eventcb. */
name|bufferevent_run_eventcb_
argument_list|(
name|bev
argument_list|,
name|what
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bufferevent_decref_and_unlock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|be_filter_flush
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|short
name|iotype
parameter_list|,
name|enum
name|bufferevent_flush_mode
name|mode
parameter_list|)
block|{
name|struct
name|bufferevent_filtered
modifier|*
name|bevf
init|=
name|upcast
argument_list|(
name|bufev
argument_list|)
decl_stmt|;
name|int
name|processed_any
init|=
literal|0
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|bevf
argument_list|)
expr_stmt|;
name|bufferevent_incref_and_lock_
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
if|if
condition|(
name|iotype
operator|&
name|EV_READ
condition|)
block|{
name|be_filter_process_input
argument_list|(
name|bevf
argument_list|,
name|mode
argument_list|,
operator|&
name|processed_any
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iotype
operator|&
name|EV_WRITE
condition|)
block|{
name|be_filter_process_output
argument_list|(
name|bevf
argument_list|,
name|mode
argument_list|,
operator|&
name|processed_any
argument_list|)
expr_stmt|;
block|}
comment|/* XXX check the return value? */
comment|/* XXX does this want to recursively call lower-level flushes? */
name|bufferevent_flush
argument_list|(
name|bevf
operator|->
name|underlying
argument_list|,
name|iotype
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|bufferevent_decref_and_unlock_
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
return|return
name|processed_any
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|be_filter_ctrl
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|enum
name|bufferevent_ctrl_op
name|op
parameter_list|,
name|union
name|bufferevent_ctrl_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|bufferevent_filtered
modifier|*
name|bevf
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BEV_CTRL_GET_UNDERLYING
case|:
name|bevf
operator|=
name|upcast
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|data
operator|->
name|ptr
operator|=
name|bevf
operator|->
name|underlying
expr_stmt|;
return|return
literal|0
return|;
case|case
name|BEV_CTRL_GET_FD
case|:
case|case
name|BEV_CTRL_SET_FD
case|:
case|case
name|BEV_CTRL_CANCEL_ALL
case|:
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

end_unit

