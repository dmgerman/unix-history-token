begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2009-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|// Get rid of OSX 10.7 and greater deprecation warnings.
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__clang__
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|clang
name|diagnostic
name|ignored
literal|"-Wdeprecated-declarations"
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_STDARG_H
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"event2/bufferevent.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent_ssl.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer.h"
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"mm-internal.h"
end_include

begin_include
include|#
directive|include
file|"bufferevent-internal.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|<openssl/bio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_comment
comment|/*  * Define an OpenSSL bio that targets a bufferevent.  */
end_comment

begin_comment
comment|/* --------------------    A BIO is an OpenSSL abstraction that handles reading and writing data.  The    library will happily speak SSL over anything that implements a BIO    interface.     Here we define a BIO implementation that directs its output to a    bufferevent.  We'll want to use this only when none of OpenSSL's built-in    IO mechanisms work for us.    -------------------- */
end_comment

begin_comment
comment|/* every BIO type needs its own integer type value. */
end_comment

begin_define
define|#
directive|define
name|BIO_TYPE_LIBEVENT
value|57
end_define

begin_comment
comment|/* ???? Arguably, we should set BIO_TYPE_FILTER or BIO_TYPE_SOURCE_SINK on  * this. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static void print_err(int val) { 	int err; 	printf("Error was %d\n", val);  	while ((err = ERR_get_error())) { 		const char *msg = (const char*)ERR_reason_error_string(err); 		const char *lib = (const char*)ERR_lib_error_string(err); 		const char *func = (const char*)ERR_func_error_string(err);  		printf("%s in %s %s\n", msg, lib, func); 	} }
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|print_err
parameter_list|(
name|v
parameter_list|)
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Called to initialize a new BIO */
end_comment

begin_function
specifier|static
name|int
name|bio_bufferevent_new
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|)
block|{
name|b
operator|->
name|init
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|num
operator|=
operator|-
literal|1
expr_stmt|;
name|b
operator|->
name|ptr
operator|=
name|NULL
expr_stmt|;
comment|/* We'll be putting the bufferevent in this field.*/
name|b
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Called to uninitialize the BIO. */
end_comment

begin_function
specifier|static
name|int
name|bio_bufferevent_free
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|b
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|b
operator|->
name|shutdown
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|init
operator|&&
name|b
operator|->
name|ptr
condition|)
name|bufferevent_free
argument_list|(
name|b
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|b
operator|->
name|init
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Called to extract data from the BIO. */
end_comment

begin_function
specifier|static
name|int
name|bio_bufferevent_read
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
name|char
modifier|*
name|out
parameter_list|,
name|int
name|outlen
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|input
decl_stmt|;
name|BIO_clear_retry_flags
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|b
operator|->
name|ptr
condition|)
return|return
operator|-
literal|1
return|;
name|input
operator|=
name|bufferevent_get_input
argument_list|(
name|b
operator|->
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|evbuffer_get_length
argument_list|(
name|input
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If there's no data to read, say so. */
name|BIO_set_retry_read
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|r
operator|=
name|evbuffer_remove
argument_list|(
name|input
argument_list|,
name|out
argument_list|,
name|outlen
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Called to write data info the BIO */
end_comment

begin_function
specifier|static
name|int
name|bio_bufferevent_write
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|int
name|inlen
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|bufev
init|=
name|b
operator|->
name|ptr
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|output
decl_stmt|;
name|size_t
name|outlen
decl_stmt|;
name|BIO_clear_retry_flags
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|->
name|ptr
condition|)
return|return
operator|-
literal|1
return|;
name|output
operator|=
name|bufferevent_get_output
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
name|outlen
operator|=
name|evbuffer_get_length
argument_list|(
name|output
argument_list|)
expr_stmt|;
comment|/* Copy only as much data onto the output buffer as can fit under the 	 * high-water mark. */
if|if
condition|(
name|bufev
operator|->
name|wm_write
operator|.
name|high
operator|&&
name|bufev
operator|->
name|wm_write
operator|.
name|high
operator|<=
operator|(
name|outlen
operator|+
name|inlen
operator|)
condition|)
block|{
if|if
condition|(
name|bufev
operator|->
name|wm_write
operator|.
name|high
operator|<=
name|outlen
condition|)
block|{
comment|/* If no data can fit, we'll need to retry later. */
name|BIO_set_retry_write
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|inlen
operator|=
name|bufev
operator|->
name|wm_write
operator|.
name|high
operator|-
name|outlen
expr_stmt|;
block|}
name|EVUTIL_ASSERT
argument_list|(
name|inlen
operator|>
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|output
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|)
expr_stmt|;
return|return
name|inlen
return|;
block|}
end_function

begin_comment
comment|/* Called to handle various requests */
end_comment

begin_function
specifier|static
name|long
name|bio_bufferevent_ctrl
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|num
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|bufev
init|=
name|b
operator|->
name|ptr
decl_stmt|;
name|long
name|ret
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|BIO_CTRL_GET_CLOSE
case|:
name|ret
operator|=
name|b
operator|->
name|shutdown
expr_stmt|;
break|break;
case|case
name|BIO_CTRL_SET_CLOSE
case|:
name|b
operator|->
name|shutdown
operator|=
operator|(
name|int
operator|)
name|num
expr_stmt|;
break|break;
case|case
name|BIO_CTRL_PENDING
case|:
name|ret
operator|=
name|evbuffer_get_length
argument_list|(
name|bufferevent_get_input
argument_list|(
name|bufev
argument_list|)
argument_list|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|BIO_CTRL_WPENDING
case|:
name|ret
operator|=
name|evbuffer_get_length
argument_list|(
name|bufferevent_get_output
argument_list|(
name|bufev
argument_list|)
argument_list|)
operator|!=
literal|0
expr_stmt|;
break|break;
comment|/* XXXX These two are given a special-case treatment because 	 * of cargo-cultism.  I should come up with a better reason. */
case|case
name|BIO_CTRL_DUP
case|:
case|case
name|BIO_CTRL_FLUSH
case|:
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Called to write a string to the BIO */
end_comment

begin_function
specifier|static
name|int
name|bio_bufferevent_puts
parameter_list|(
name|BIO
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
return|return
name|bio_bufferevent_write
argument_list|(
name|b
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Method table for the bufferevent BIO */
end_comment

begin_decl_stmt
specifier|static
name|BIO_METHOD
name|methods_bufferevent
init|=
block|{
name|BIO_TYPE_LIBEVENT
block|,
literal|"bufferevent"
block|,
name|bio_bufferevent_write
block|,
name|bio_bufferevent_read
block|,
name|bio_bufferevent_puts
block|,
name|NULL
comment|/* bio_bufferevent_gets */
block|,
name|bio_bufferevent_ctrl
block|,
name|bio_bufferevent_new
block|,
name|bio_bufferevent_free
block|,
name|NULL
comment|/* callback_ctrl */
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the method table for the bufferevents BIO */
end_comment

begin_function
specifier|static
name|BIO_METHOD
modifier|*
name|BIO_s_bufferevent
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|methods_bufferevent
return|;
block|}
end_function

begin_comment
comment|/* Create a new BIO to wrap communication around a bufferevent.  If close_flag  * is true, the bufferevent will be freed when the BIO is closed. */
end_comment

begin_function
specifier|static
name|BIO
modifier|*
name|BIO_new_bufferevent
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufferevent
parameter_list|,
name|int
name|close_flag
parameter_list|)
block|{
name|BIO
modifier|*
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|bufferevent
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|result
operator|=
name|BIO_new
argument_list|(
name|BIO_s_bufferevent
argument_list|()
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
name|result
operator|->
name|init
operator|=
literal|1
expr_stmt|;
name|result
operator|->
name|ptr
operator|=
name|bufferevent
expr_stmt|;
name|result
operator|->
name|shutdown
operator|=
name|close_flag
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* --------------------    Now, here's the OpenSSL-based implementation of bufferevent.     The implementation comes in two flavors: one that connects its SSL object    to an underlying bufferevent using a BIO_bufferevent, and one that has the    SSL object connect to a socket directly.  The latter should generally be    faster, except on Windows, where your best bet is using a    bufferevent_async.     (OpenSSL supports many other BIO types, too.  But we can't use any unless    we have a good way to get notified when they become readable/writable.)    -------------------- */
end_comment

begin_struct
struct|struct
name|bio_data_counts
block|{
name|unsigned
name|long
name|n_written
decl_stmt|;
name|unsigned
name|long
name|n_read
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|bufferevent_openssl
block|{
comment|/* Shared fields with common bufferevent implementation code. 	   If we were set up with an underlying bufferevent, we use the 	   events here as timers only.  If we have an SSL, then we use 	   the events as socket events. 	 */
name|struct
name|bufferevent_private
name|bev
decl_stmt|;
comment|/* An underlying bufferevent that we're directing our output to. 	   If it's NULL, then we're connected to an fd, not an evbuffer. */
name|struct
name|bufferevent
modifier|*
name|underlying
decl_stmt|;
comment|/* The SSL object doing our encryption. */
name|SSL
modifier|*
name|ssl
decl_stmt|;
comment|/* A callback that's invoked when data arrives on our outbuf so we 	   know to write data to the SSL. */
name|struct
name|evbuffer_cb_entry
modifier|*
name|outbuf_cb
decl_stmt|;
comment|/* A count of how much data the bios have read/written total.  Used 	   for rate-limiting. */
name|struct
name|bio_data_counts
name|counts
decl_stmt|;
comment|/* If this value is greater than 0, then the last SSL_write blocked, 	 * and we need to try it again with this many bytes. */
name|ev_ssize_t
name|last_write
decl_stmt|;
define|#
directive|define
name|NUM_ERRORS
value|3
name|ev_uint32_t
name|errors
index|[
name|NUM_ERRORS
index|]
decl_stmt|;
comment|/* When we next get available space, we should say "read" instead of 	   "write". This can happen if there's a renegotiation during a read 	   operation. */
name|unsigned
name|read_blocked_on_write
range|:
literal|1
decl_stmt|;
comment|/* When we next get data, we should say "write" instead of "read". */
name|unsigned
name|write_blocked_on_read
range|:
literal|1
decl_stmt|;
comment|/* Treat TCP close before SSL close on SSL>= v3 as clean EOF. */
name|unsigned
name|allow_dirty_shutdown
range|:
literal|1
decl_stmt|;
comment|/* XXXX */
name|unsigned
name|fd_is_set
range|:
literal|1
decl_stmt|;
comment|/* XXX */
name|unsigned
name|n_errors
range|:
literal|2
decl_stmt|;
comment|/* Are we currently connecting, accepting, or doing IO? */
name|unsigned
name|state
range|:
literal|2
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|be_openssl_enable
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|,
name|short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|be_openssl_disable
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|,
name|short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|be_openssl_unlink
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|be_openssl_destruct
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|be_openssl_adj_timeouts
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|be_openssl_flush
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|short
name|iotype
parameter_list|,
name|enum
name|bufferevent_flush_mode
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|be_openssl_ctrl
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|,
name|enum
name|bufferevent_ctrl_op
parameter_list|,
name|union
name|bufferevent_ctrl_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|struct
name|bufferevent_ops
name|bufferevent_ops_openssl
init|=
block|{
literal|"ssl"
block|,
name|evutil_offsetof
argument_list|(
expr|struct
name|bufferevent_openssl
argument_list|,
name|bev
operator|.
name|bev
argument_list|)
block|,
name|be_openssl_enable
block|,
name|be_openssl_disable
block|,
name|be_openssl_unlink
block|,
name|be_openssl_destruct
block|,
name|be_openssl_adj_timeouts
block|,
name|be_openssl_flush
block|,
name|be_openssl_ctrl
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a bufferevent, return a pointer to the bufferevent_openssl that  * contains it, if any. */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|bufferevent_openssl
modifier|*
name|upcast
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_o
decl_stmt|;
if|if
condition|(
name|bev
operator|->
name|be_ops
operator|!=
operator|&
name|bufferevent_ops_openssl
condition|)
return|return
name|NULL
return|;
name|bev_o
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|bev
operator|)
operator|-
name|evutil_offsetof
argument_list|(
expr|struct
name|bufferevent_openssl
argument_list|,
name|bev
operator|.
name|bev
argument_list|)
operator|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|bev_o
operator|->
name|bev
operator|.
name|bev
operator|.
name|be_ops
operator|==
operator|&
name|bufferevent_ops_openssl
argument_list|)
expr_stmt|;
return|return
name|bev_o
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|put_error
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|,
name|unsigned
name|long
name|err
parameter_list|)
block|{
if|if
condition|(
name|bev_ssl
operator|->
name|n_errors
operator|==
name|NUM_ERRORS
condition|)
return|return;
comment|/* The error type according to openssl is "unsigned long", but 	   openssl never uses more than 32 bits of it.  It _can't_ use more 	   than 32 bits of it, since it needs to report errors on systems 	   where long is only 32 bits. 	 */
name|bev_ssl
operator|->
name|errors
index|[
name|bev_ssl
operator|->
name|n_errors
operator|++
index|]
operator|=
operator|(
name|ev_uint32_t
operator|)
name|err
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Have the base communications channel (either the underlying bufferevent or  * ev_read and ev_write) start reading.  Take the read-blocked-on-write flag  * into account. */
end_comment

begin_function
specifier|static
name|int
name|start_reading
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|)
block|{
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
name|bufferevent_unsuspend_read_
argument_list|(
name|bev_ssl
operator|->
name|underlying
argument_list|,
name|BEV_SUSPEND_FILT_READ
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|bufferevent_add_event_
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|,
operator|&
name|bev
operator|->
name|timeout_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|bev_ssl
operator|->
name|read_blocked_on_write
condition|)
name|r
operator|=
name|bufferevent_add_event_
argument_list|(
operator|&
name|bev
operator|->
name|ev_write
argument_list|,
operator|&
name|bev
operator|->
name|timeout_write
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
end_function

begin_comment
comment|/* Have the base communications channel (either the underlying bufferevent or  * ev_read and ev_write) start writing.  Take the write-blocked-on-read flag  * into account. */
end_comment

begin_function
specifier|static
name|int
name|start_writing
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
name|r
operator|=
name|bufferevent_add_event_
argument_list|(
operator|&
name|bev
operator|->
name|ev_write
argument_list|,
operator|&
name|bev
operator|->
name|timeout_write
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|&&
name|bev_ssl
operator|->
name|write_blocked_on_read
condition|)
name|r
operator|=
name|bufferevent_add_event_
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|,
operator|&
name|bev
operator|->
name|timeout_read
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|stop_reading
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|)
block|{
if|if
condition|(
name|bev_ssl
operator|->
name|write_blocked_on_read
condition|)
return|return;
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
name|bufferevent_suspend_read_
argument_list|(
name|bev_ssl
operator|->
name|underlying
argument_list|,
name|BEV_SUSPEND_FILT_READ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
name|event_del
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|stop_writing
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|)
block|{
if|if
condition|(
name|bev_ssl
operator|->
name|read_blocked_on_write
condition|)
return|return;
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
name|event_del
argument_list|(
operator|&
name|bev
operator|->
name|ev_write
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|set_rbow
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|bev_ssl
operator|->
name|underlying
condition|)
name|stop_reading
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
name|bev_ssl
operator|->
name|read_blocked_on_write
operator|=
literal|1
expr_stmt|;
return|return
name|start_writing
argument_list|(
name|bev_ssl
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_wbor
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|bev_ssl
operator|->
name|underlying
condition|)
name|stop_writing
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
name|bev_ssl
operator|->
name|write_blocked_on_read
operator|=
literal|1
expr_stmt|;
return|return
name|start_reading
argument_list|(
name|bev_ssl
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|clear_rbow
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|bev_ssl
operator|->
name|read_blocked_on_write
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bev
operator|->
name|enabled
operator|&
name|EV_WRITE
operator|)
condition|)
name|stop_writing
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev
operator|->
name|enabled
operator|&
name|EV_READ
condition|)
name|r
operator|=
name|start_reading
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|clear_wbor
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|bev_ssl
operator|->
name|write_blocked_on_read
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bev
operator|->
name|enabled
operator|&
name|EV_READ
operator|)
condition|)
name|stop_reading
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev
operator|->
name|enabled
operator|&
name|EV_WRITE
condition|)
name|r
operator|=
name|start_writing
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|conn_closed
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|,
name|int
name|when
parameter_list|,
name|int
name|errcode
parameter_list|,
name|int
name|ret
parameter_list|)
block|{
name|int
name|event
init|=
name|BEV_EVENT_ERROR
decl_stmt|;
name|int
name|dirty_shutdown
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|err
decl_stmt|;
switch|switch
condition|(
name|errcode
condition|)
block|{
case|case
name|SSL_ERROR_ZERO_RETURN
case|:
comment|/* Possibly a clean shutdown. */
if|if
condition|(
name|SSL_get_shutdown
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|)
operator|&
name|SSL_RECEIVED_SHUTDOWN
condition|)
name|event
operator|=
name|BEV_EVENT_EOF
expr_stmt|;
else|else
name|dirty_shutdown
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SSL_ERROR_SYSCALL
case|:
comment|/* IO error; possibly a dirty shutdown. */
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|ERR_peek_error
argument_list|()
operator|==
literal|0
condition|)
name|dirty_shutdown
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SSL_ERROR_SSL
case|:
comment|/* Protocol error. */
break|break;
case|case
name|SSL_ERROR_WANT_X509_LOOKUP
case|:
comment|/* XXXX handle this. */
break|break;
case|case
name|SSL_ERROR_NONE
case|:
case|case
name|SSL_ERROR_WANT_READ
case|:
case|case
name|SSL_ERROR_WANT_WRITE
case|:
case|case
name|SSL_ERROR_WANT_CONNECT
case|:
case|case
name|SSL_ERROR_WANT_ACCEPT
case|:
default|default:
comment|/* should be impossible; treat as normal error. */
name|event_warnx
argument_list|(
literal|"BUG: Unexpected OpenSSL error code %d"
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|(
name|err
operator|=
name|ERR_get_error
argument_list|()
operator|)
condition|)
block|{
name|put_error
argument_list|(
name|bev_ssl
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dirty_shutdown
operator|&&
name|bev_ssl
operator|->
name|allow_dirty_shutdown
condition|)
name|event
operator|=
name|BEV_EVENT_EOF
expr_stmt|;
name|stop_reading
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
name|stop_writing
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
comment|/* when is BEV_EVENT_{READING|WRITING} */
name|event
operator|=
name|when
operator||
name|event
expr_stmt|;
name|bufferevent_run_eventcb_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
argument_list|,
name|event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_bio_counts
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|)
block|{
name|bev_ssl
operator|->
name|counts
operator|.
name|n_written
operator|=
name|BIO_number_written
argument_list|(
name|SSL_get_wbio
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|)
argument_list|)
expr_stmt|;
name|bev_ssl
operator|->
name|counts
operator|.
name|n_read
operator|=
name|BIO_number_read
argument_list|(
name|SSL_get_rbio
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|decrement_buckets
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|)
block|{
name|unsigned
name|long
name|num_w
init|=
name|BIO_number_written
argument_list|(
name|SSL_get_wbio
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|num_r
init|=
name|BIO_number_read
argument_list|(
name|SSL_get_rbio
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* These next two subtractions can wrap around. That's okay. */
name|unsigned
name|long
name|w
init|=
name|num_w
operator|-
name|bev_ssl
operator|->
name|counts
operator|.
name|n_written
decl_stmt|;
name|unsigned
name|long
name|r
init|=
name|num_r
operator|-
name|bev_ssl
operator|->
name|counts
operator|.
name|n_read
decl_stmt|;
if|if
condition|(
name|w
condition|)
name|bufferevent_decrement_write_buckets_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|bufferevent_decrement_read_buckets_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|bev_ssl
operator|->
name|counts
operator|.
name|n_written
operator|=
name|num_w
expr_stmt|;
name|bev_ssl
operator|->
name|counts
operator|.
name|n_read
operator|=
name|num_r
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|OP_MADE_PROGRESS
value|1
end_define

begin_define
define|#
directive|define
name|OP_BLOCKED
value|2
end_define

begin_define
define|#
directive|define
name|OP_ERR
value|4
end_define

begin_comment
comment|/* Return a bitmask of OP_MADE_PROGRESS (if we read anything); OP_BLOCKED (if    we're now blocked); and OP_ERR (if an error occurred). */
end_comment

begin_function
specifier|static
name|int
name|do_read
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|,
name|int
name|n_to_read
parameter_list|)
block|{
comment|/* Requires lock */
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|input
init|=
name|bev
operator|->
name|input
decl_stmt|;
name|int
name|r
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|n_used
init|=
literal|0
decl_stmt|,
name|atmost
decl_stmt|;
name|struct
name|evbuffer_iovec
name|space
index|[
literal|2
index|]
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|bev
operator|.
name|read_suspended
condition|)
return|return
literal|0
return|;
name|atmost
operator|=
name|bufferevent_get_read_max_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_to_read
operator|>
name|atmost
condition|)
name|n_to_read
operator|=
name|atmost
expr_stmt|;
name|n
operator|=
name|evbuffer_reserve_space
argument_list|(
name|input
argument_list|,
name|n_to_read
argument_list|,
name|space
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
name|OP_ERR
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|bev_ssl
operator|->
name|bev
operator|.
name|read_suspended
condition|)
break|break;
name|r
operator|=
name|SSL_read
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|,
name|space
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|space
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
literal|0
condition|)
block|{
name|result
operator||=
name|OP_MADE_PROGRESS
expr_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|read_blocked_on_write
condition|)
if|if
condition|(
name|clear_rbow
argument_list|(
name|bev_ssl
argument_list|)
operator|<
literal|0
condition|)
return|return
name|OP_ERR
operator||
name|result
return|;
operator|++
name|n_used
expr_stmt|;
name|space
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
name|r
expr_stmt|;
name|decrement_buckets
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|err
init|=
name|SSL_get_error
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|,
name|r
argument_list|)
decl_stmt|;
name|print_err
argument_list|(
name|err
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|SSL_ERROR_WANT_READ
case|:
comment|/* Can't read until underlying has more data. */
if|if
condition|(
name|bev_ssl
operator|->
name|read_blocked_on_write
condition|)
if|if
condition|(
name|clear_rbow
argument_list|(
name|bev_ssl
argument_list|)
operator|<
literal|0
condition|)
return|return
name|OP_ERR
operator||
name|result
return|;
break|break;
case|case
name|SSL_ERROR_WANT_WRITE
case|:
comment|/* This read operation requires a write, and the 				 * underlying is full */
if|if
condition|(
operator|!
name|bev_ssl
operator|->
name|read_blocked_on_write
condition|)
if|if
condition|(
name|set_rbow
argument_list|(
name|bev_ssl
argument_list|)
operator|<
literal|0
condition|)
return|return
name|OP_ERR
operator||
name|result
return|;
break|break;
default|default:
name|conn_closed
argument_list|(
name|bev_ssl
argument_list|,
name|BEV_EVENT_READING
argument_list|,
name|err
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
block|}
name|result
operator||=
name|OP_BLOCKED
expr_stmt|;
break|break;
comment|/* out of the loop */
block|}
block|}
if|if
condition|(
name|n_used
condition|)
block|{
name|evbuffer_commit_space
argument_list|(
name|input
argument_list|,
name|space
argument_list|,
name|n_used
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
condition|)
name|BEV_RESET_GENERIC_READ_TIMEOUT
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return a bitmask of OP_MADE_PROGRESS (if we wrote anything); OP_BLOCKED (if    we're now blocked); and OP_ERR (if an error occurred). */
end_comment

begin_function
specifier|static
name|int
name|do_write
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|,
name|int
name|atmost
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|r
decl_stmt|,
name|n
decl_stmt|,
name|n_written
init|=
literal|0
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|output
init|=
name|bev
operator|->
name|output
decl_stmt|;
name|struct
name|evbuffer_iovec
name|space
index|[
literal|8
index|]
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|last_write
operator|>
literal|0
condition|)
name|atmost
operator|=
name|bev_ssl
operator|->
name|last_write
expr_stmt|;
else|else
name|atmost
operator|=
name|bufferevent_get_write_max_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
argument_list|)
expr_stmt|;
name|n
operator|=
name|evbuffer_peek
argument_list|(
name|output
argument_list|,
name|atmost
argument_list|,
name|NULL
argument_list|,
name|space
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
name|OP_ERR
operator||
name|result
return|;
if|if
condition|(
name|n
operator|>
literal|8
condition|)
name|n
operator|=
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|bev_ssl
operator|->
name|bev
operator|.
name|write_suspended
condition|)
break|break;
comment|/* SSL_write will (reasonably) return 0 if we tell it to 		   send 0 data.  Skip this case so we don't interpret the 		   result as an error */
if|if
condition|(
name|space
index|[
name|i
index|]
operator|.
name|iov_len
operator|==
literal|0
condition|)
continue|continue;
name|r
operator|=
name|SSL_write
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|,
name|space
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|space
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
literal|0
condition|)
block|{
name|result
operator||=
name|OP_MADE_PROGRESS
expr_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|write_blocked_on_read
condition|)
if|if
condition|(
name|clear_wbor
argument_list|(
name|bev_ssl
argument_list|)
operator|<
literal|0
condition|)
return|return
name|OP_ERR
operator||
name|result
return|;
name|n_written
operator|+=
name|r
expr_stmt|;
name|bev_ssl
operator|->
name|last_write
operator|=
operator|-
literal|1
expr_stmt|;
name|decrement_buckets
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|err
init|=
name|SSL_get_error
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|,
name|r
argument_list|)
decl_stmt|;
name|print_err
argument_list|(
name|err
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|SSL_ERROR_WANT_WRITE
case|:
comment|/* Can't read until underlying has more data. */
if|if
condition|(
name|bev_ssl
operator|->
name|write_blocked_on_read
condition|)
if|if
condition|(
name|clear_wbor
argument_list|(
name|bev_ssl
argument_list|)
operator|<
literal|0
condition|)
return|return
name|OP_ERR
operator||
name|result
return|;
name|bev_ssl
operator|->
name|last_write
operator|=
name|space
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
break|break;
case|case
name|SSL_ERROR_WANT_READ
case|:
comment|/* This read operation requires a write, and the 				 * underlying is full */
if|if
condition|(
operator|!
name|bev_ssl
operator|->
name|write_blocked_on_read
condition|)
if|if
condition|(
name|set_wbor
argument_list|(
name|bev_ssl
argument_list|)
operator|<
literal|0
condition|)
return|return
name|OP_ERR
operator||
name|result
return|;
name|bev_ssl
operator|->
name|last_write
operator|=
name|space
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
break|break;
default|default:
name|conn_closed
argument_list|(
name|bev_ssl
argument_list|,
name|BEV_EVENT_WRITING
argument_list|,
name|err
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|bev_ssl
operator|->
name|last_write
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|result
operator||=
name|OP_BLOCKED
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|n_written
condition|)
block|{
name|evbuffer_drain
argument_list|(
name|output
argument_list|,
name|n_written
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
condition|)
name|BEV_RESET_GENERIC_WRITE_TIMEOUT
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bufferevent_trigger_nolock_
argument_list|(
name|bev
argument_list|,
name|EV_WRITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_define
define|#
directive|define
name|WRITE_FRAME
value|15000
end_define

begin_define
define|#
directive|define
name|READ_DEFAULT
value|4096
end_define

begin_comment
comment|/* Try to figure out how many bytes to read; return 0 if we shouldn't be  * reading. */
end_comment

begin_function
specifier|static
name|int
name|bytes_to_read
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|input
init|=
name|bev
operator|->
name|bev
operator|.
name|bev
operator|.
name|input
decl_stmt|;
name|struct
name|event_watermark
modifier|*
name|wm
init|=
operator|&
name|bev
operator|->
name|bev
operator|.
name|bev
operator|.
name|wm_read
decl_stmt|;
name|int
name|result
init|=
name|READ_DEFAULT
decl_stmt|;
name|ev_ssize_t
name|limit
decl_stmt|;
comment|/* XXX 99% of this is generic code that nearly all bufferevents will 	 * want. */
if|if
condition|(
name|bev
operator|->
name|write_blocked_on_read
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|bev
operator|->
name|bev
operator|.
name|bev
operator|.
name|enabled
operator|&
name|EV_READ
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bev
operator|->
name|bev
operator|.
name|read_suspended
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|wm
operator|->
name|high
condition|)
block|{
if|if
condition|(
name|evbuffer_get_length
argument_list|(
name|input
argument_list|)
operator|>=
name|wm
operator|->
name|high
condition|)
block|{
return|return
literal|0
return|;
block|}
name|result
operator|=
name|wm
operator|->
name|high
operator|-
name|evbuffer_get_length
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|READ_DEFAULT
expr_stmt|;
block|}
comment|/* Respect the rate limit */
name|limit
operator|=
name|bufferevent_get_read_max_
argument_list|(
operator|&
name|bev
operator|->
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
name|limit
condition|)
block|{
name|result
operator|=
name|limit
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Things look readable.  If write is blocked on read, write till it isn't.  * Read from the underlying buffer until we block or we hit our high-water  * mark.  */
end_comment

begin_function
specifier|static
name|void
name|consider_reading
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|int
name|n_to_read
decl_stmt|;
name|int
name|all_result_flags
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bev_ssl
operator|->
name|write_blocked_on_read
condition|)
block|{
name|r
operator|=
name|do_write
argument_list|(
name|bev_ssl
argument_list|,
name|WRITE_FRAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&
operator|(
name|OP_BLOCKED
operator||
name|OP_ERR
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|bev_ssl
operator|->
name|write_blocked_on_read
condition|)
return|return;
name|n_to_read
operator|=
name|bytes_to_read
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
while|while
condition|(
name|n_to_read
condition|)
block|{
name|r
operator|=
name|do_read
argument_list|(
name|bev_ssl
argument_list|,
name|n_to_read
argument_list|)
expr_stmt|;
name|all_result_flags
operator||=
name|r
expr_stmt|;
if|if
condition|(
name|r
operator|&
operator|(
name|OP_BLOCKED
operator||
name|OP_ERR
operator|)
condition|)
break|break;
if|if
condition|(
name|bev_ssl
operator|->
name|bev
operator|.
name|read_suspended
condition|)
break|break;
comment|/* Read all pending data.  This won't hit the network 		 * again, and will (most importantly) put us in a state 		 * where we don't need to read anything else until the 		 * socket is readable again.  It'll potentially make us 		 * overrun our read high-watermark (somewhat 		 * regrettable).  The damage to the rate-limit has 		 * already been done, since OpenSSL went and read a 		 * whole SSL record anyway. */
name|n_to_read
operator|=
name|SSL_pending
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|)
expr_stmt|;
comment|/* XXX This if statement is actually a bad bug, added to avoid 		 * XXX a worse bug. 		 * 		 * The bad bug: It can potentially cause resource unfairness 		 * by reading too much data from the underlying bufferevent; 		 * it can potentially cause read looping if the underlying 		 * bufferevent is a bufferevent_pair and deferred callbacks 		 * aren't used. 		 * 		 * The worse bug: If we didn't do this, then we would 		 * potentially not read any more from bev_ssl->underlying 		 * until more data arrived there, which could lead to us 		 * waiting forever. 		 */
if|if
condition|(
operator|!
name|n_to_read
operator|&&
name|bev_ssl
operator|->
name|underlying
condition|)
name|n_to_read
operator|=
name|bytes_to_read
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|all_result_flags
operator|&
name|OP_MADE_PROGRESS
condition|)
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
name|bufferevent_trigger_nolock_
argument_list|(
name|bev
argument_list|,
name|EV_READ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
comment|/* Should be redundant, but let's avoid busy-looping */
if|if
condition|(
name|bev_ssl
operator|->
name|bev
operator|.
name|read_suspended
operator|||
operator|!
operator|(
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
operator|.
name|enabled
operator|&
name|EV_READ
operator|)
condition|)
block|{
name|event_del
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
operator|.
name|ev_read
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|consider_writing
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|output
init|=
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
operator|.
name|output
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|target
init|=
name|NULL
decl_stmt|;
name|struct
name|event_watermark
modifier|*
name|wm
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|bev_ssl
operator|->
name|read_blocked_on_write
condition|)
block|{
name|r
operator|=
name|do_read
argument_list|(
name|bev_ssl
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
comment|/* XXXX 1024 is a hack */
if|if
condition|(
name|r
operator|&
name|OP_MADE_PROGRESS
condition|)
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
name|bufferevent_trigger_nolock_
argument_list|(
name|bev
argument_list|,
name|EV_READ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|&
operator|(
name|OP_ERR
operator||
name|OP_BLOCKED
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|bev_ssl
operator|->
name|read_blocked_on_write
condition|)
return|return;
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
name|target
operator|=
name|bev_ssl
operator|->
name|underlying
operator|->
name|output
expr_stmt|;
name|wm
operator|=
operator|&
name|bev_ssl
operator|->
name|underlying
operator|->
name|wm_write
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
operator|.
name|enabled
operator|&
name|EV_WRITE
operator|)
operator|&&
operator|(
operator|!
name|bev_ssl
operator|->
name|bev
operator|.
name|write_suspended
operator|)
operator|&&
name|evbuffer_get_length
argument_list|(
name|output
argument_list|)
operator|&&
operator|(
operator|!
name|target
operator|||
operator|(
operator|!
name|wm
operator|->
name|high
operator|||
name|evbuffer_get_length
argument_list|(
name|target
argument_list|)
operator|<
name|wm
operator|->
name|high
operator|)
operator|)
condition|)
block|{
name|int
name|n_to_write
decl_stmt|;
if|if
condition|(
name|wm
operator|&&
name|wm
operator|->
name|high
condition|)
name|n_to_write
operator|=
name|wm
operator|->
name|high
operator|-
name|evbuffer_get_length
argument_list|(
name|target
argument_list|)
expr_stmt|;
else|else
name|n_to_write
operator|=
name|WRITE_FRAME
expr_stmt|;
name|r
operator|=
name|do_write
argument_list|(
name|bev_ssl
argument_list|,
name|n_to_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&
operator|(
name|OP_BLOCKED
operator||
name|OP_ERR
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
if|if
condition|(
name|evbuffer_get_length
argument_list|(
name|output
argument_list|)
operator|==
literal|0
condition|)
block|{
name|event_del
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
operator|.
name|ev_write
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bev_ssl
operator|->
name|bev
operator|.
name|write_suspended
operator|||
operator|!
operator|(
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
operator|.
name|enabled
operator|&
name|EV_WRITE
operator|)
condition|)
block|{
comment|/* Should be redundant, but let's avoid busy-looping */
name|event_del
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
operator|.
name|ev_write
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|be_openssl_readcb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev_base
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|ctx
decl_stmt|;
name|consider_reading
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|be_openssl_writecb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev_base
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|ctx
decl_stmt|;
name|consider_writing
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|be_openssl_eventcb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev_base
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|ctx
decl_stmt|;
name|int
name|event
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|what
operator|&
name|BEV_EVENT_EOF
condition|)
block|{
if|if
condition|(
name|bev_ssl
operator|->
name|allow_dirty_shutdown
condition|)
name|event
operator|=
name|BEV_EVENT_EOF
expr_stmt|;
else|else
name|event
operator|=
name|BEV_EVENT_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|what
operator|&
name|BEV_EVENT_TIMEOUT
condition|)
block|{
comment|/* We sure didn't set this.  Propagate it to the user. */
name|event
operator|=
name|what
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|what
operator|&
name|BEV_EVENT_ERROR
condition|)
block|{
comment|/* An error occurred on the connection.  Propagate it to the user. */
name|event
operator|=
name|what
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|what
operator|&
name|BEV_EVENT_CONNECTED
condition|)
block|{
comment|/* Ignore it.  We're saying SSL_connect() already, which will 		   eat it. */
block|}
if|if
condition|(
name|event
condition|)
name|bufferevent_run_eventcb_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
argument_list|,
name|event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|be_openssl_readeventcb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|ptr
decl_stmt|;
name|bufferevent_incref_and_lock_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
name|EV_TIMEOUT
condition|)
block|{
name|bufferevent_run_eventcb_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
argument_list|,
name|BEV_EVENT_TIMEOUT
operator||
name|BEV_EVENT_READING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|consider_reading
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
block|}
name|bufferevent_decref_and_unlock_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|be_openssl_writeeventcb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|ptr
decl_stmt|;
name|bufferevent_incref_and_lock_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
name|EV_TIMEOUT
condition|)
block|{
name|bufferevent_run_eventcb_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
argument_list|,
name|BEV_EVENT_TIMEOUT
operator||
name|BEV_EVENT_WRITING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|consider_writing
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
block|}
name|bufferevent_decref_and_unlock_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_open_callbacks
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|)
block|{
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
name|bufferevent_setcb
argument_list|(
name|bev_ssl
operator|->
name|underlying
argument_list|,
name|be_openssl_readcb
argument_list|,
name|be_openssl_writecb
argument_list|,
name|be_openssl_eventcb
argument_list|,
name|bev_ssl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
name|int
name|rpending
init|=
literal|0
decl_stmt|,
name|wpending
init|=
literal|0
decl_stmt|,
name|r1
init|=
literal|0
decl_stmt|,
name|r2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|&&
name|bev_ssl
operator|->
name|fd_is_set
condition|)
name|fd
operator|=
name|event_get_fd
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|fd_is_set
condition|)
block|{
name|rpending
operator|=
name|event_pending
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|,
name|EV_READ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wpending
operator|=
name|event_pending
argument_list|(
operator|&
name|bev
operator|->
name|ev_write
argument_list|,
name|EV_WRITE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
operator|&
name|bev
operator|->
name|ev_write
argument_list|)
expr_stmt|;
block|}
name|event_assign
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|,
name|bev
operator|->
name|ev_base
argument_list|,
name|fd
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
operator||
name|EV_FINALIZE
argument_list|,
name|be_openssl_readeventcb
argument_list|,
name|bev_ssl
argument_list|)
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|bev
operator|->
name|ev_write
argument_list|,
name|bev
operator|->
name|ev_base
argument_list|,
name|fd
argument_list|,
name|EV_WRITE
operator||
name|EV_PERSIST
operator||
name|EV_FINALIZE
argument_list|,
name|be_openssl_writeeventcb
argument_list|,
name|bev_ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpending
condition|)
name|r1
operator|=
name|bufferevent_add_event_
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|,
operator|&
name|bev
operator|->
name|timeout_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpending
condition|)
name|r2
operator|=
name|bufferevent_add_event_
argument_list|(
operator|&
name|bev
operator|->
name|ev_write
argument_list|,
operator|&
name|bev
operator|->
name|timeout_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|bev_ssl
operator|->
name|fd_is_set
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|r1
operator|<
literal|0
operator|||
name|r2
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|do_handshake
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
switch|switch
condition|(
name|bev_ssl
operator|->
name|state
condition|)
block|{
default|default:
case|case
name|BUFFEREVENT_SSL_OPEN
case|:
name|EVUTIL_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|BUFFEREVENT_SSL_CONNECTING
case|:
case|case
name|BUFFEREVENT_SSL_ACCEPTING
case|:
name|r
operator|=
name|SSL_do_handshake
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|)
expr_stmt|;
break|break;
block|}
name|decrement_buckets
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|1
condition|)
block|{
comment|/* We're done! */
name|bev_ssl
operator|->
name|state
operator|=
name|BUFFEREVENT_SSL_OPEN
expr_stmt|;
name|set_open_callbacks
argument_list|(
name|bev_ssl
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* XXXX handle failure */
comment|/* Call do_read and do_write as needed */
name|bufferevent_enable
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
argument_list|,
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
operator|.
name|enabled
argument_list|)
expr_stmt|;
name|bufferevent_run_eventcb_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
argument_list|,
name|BEV_EVENT_CONNECTED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|int
name|err
init|=
name|SSL_get_error
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|,
name|r
argument_list|)
decl_stmt|;
name|print_err
argument_list|(
name|err
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|SSL_ERROR_WANT_WRITE
case|:
if|if
condition|(
operator|!
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
name|stop_reading
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
return|return
name|start_writing
argument_list|(
name|bev_ssl
argument_list|)
return|;
block|}
return|return
literal|0
return|;
case|case
name|SSL_ERROR_WANT_READ
case|:
if|if
condition|(
operator|!
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
name|stop_writing
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
return|return
name|start_reading
argument_list|(
name|bev_ssl
argument_list|)
return|;
block|}
return|return
literal|0
return|;
default|default:
name|conn_closed
argument_list|(
name|bev_ssl
argument_list|,
name|BEV_EVENT_READING
argument_list|,
name|err
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|be_openssl_handshakecb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev_base
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|ctx
decl_stmt|;
name|do_handshake
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
comment|/* XXX handle failure */
block|}
end_function

begin_function
specifier|static
name|void
name|be_openssl_handshakeeventcb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|ptr
decl_stmt|;
name|bufferevent_incref_and_lock_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|&
name|EV_TIMEOUT
condition|)
block|{
name|bufferevent_run_eventcb_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
argument_list|,
name|BEV_EVENT_TIMEOUT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|do_handshake
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
comment|/* XXX handle failure */
name|bufferevent_decref_and_unlock_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_handshake_callbacks
parameter_list|(
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|)
block|{
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
name|bufferevent_setcb
argument_list|(
name|bev_ssl
operator|->
name|underlying
argument_list|,
name|be_openssl_handshakecb
argument_list|,
name|be_openssl_handshakecb
argument_list|,
name|be_openssl_eventcb
argument_list|,
name|bev_ssl
argument_list|)
expr_stmt|;
return|return
name|do_handshake
argument_list|(
name|bev_ssl
argument_list|)
return|;
block|}
else|else
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
name|int
name|r1
init|=
literal|0
decl_stmt|,
name|r2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|&&
name|bev_ssl
operator|->
name|fd_is_set
condition|)
name|fd
operator|=
name|event_get_fd
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|fd_is_set
condition|)
block|{
name|event_del
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
operator|&
name|bev
operator|->
name|ev_write
argument_list|)
expr_stmt|;
block|}
name|event_assign
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|,
name|bev
operator|->
name|ev_base
argument_list|,
name|fd
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
operator||
name|EV_FINALIZE
argument_list|,
name|be_openssl_handshakeeventcb
argument_list|,
name|bev_ssl
argument_list|)
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|bev
operator|->
name|ev_write
argument_list|,
name|bev
operator|->
name|ev_base
argument_list|,
name|fd
argument_list|,
name|EV_WRITE
operator||
name|EV_PERSIST
operator||
name|EV_FINALIZE
argument_list|,
name|be_openssl_handshakeeventcb
argument_list|,
name|bev_ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|r1
operator|=
name|bufferevent_add_event_
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|,
operator|&
name|bev
operator|->
name|timeout_read
argument_list|)
expr_stmt|;
name|r2
operator|=
name|bufferevent_add_event_
argument_list|(
operator|&
name|bev
operator|->
name|ev_write
argument_list|,
operator|&
name|bev
operator|->
name|timeout_write
argument_list|)
expr_stmt|;
name|bev_ssl
operator|->
name|fd_is_set
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|r1
operator|<
literal|0
operator|||
name|r2
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|bufferevent_ssl_renegotiate
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bev_ssl
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|SSL_renegotiate
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|bev_ssl
operator|->
name|state
operator|=
name|BUFFEREVENT_SSL_CONNECTING
expr_stmt|;
if|if
condition|(
name|set_handshake_callbacks
argument_list|(
name|bev_ssl
argument_list|,
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|bev_ssl
operator|->
name|underlying
condition|)
return|return
name|do_handshake
argument_list|(
name|bev_ssl
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|be_openssl_outbuf_cb
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|evbuffer_cb_info
modifier|*
name|cbinfo
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|arg
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
comment|/* XXX need to hold a reference here. */
if|if
condition|(
name|cbinfo
operator|->
name|n_added
operator|&&
name|bev_ssl
operator|->
name|state
operator|==
name|BUFFEREVENT_SSL_OPEN
condition|)
block|{
if|if
condition|(
name|cbinfo
operator|->
name|orig_size
operator|==
literal|0
condition|)
name|r
operator|=
name|bufferevent_add_event_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
operator|.
name|ev_write
argument_list|,
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
operator|.
name|timeout_write
argument_list|)
expr_stmt|;
name|consider_writing
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
block|}
comment|/* XXX Handle r< 0 */
operator|(
name|void
operator|)
name|r
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|be_openssl_enable
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|short
name|events
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
name|int
name|r1
init|=
literal|0
decl_stmt|,
name|r2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|state
operator|!=
name|BUFFEREVENT_SSL_OPEN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|events
operator|&
name|EV_READ
condition|)
name|r1
operator|=
name|start_reading
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|EV_WRITE
condition|)
name|r2
operator|=
name|start_writing
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
if|if
condition|(
name|events
operator|&
name|EV_READ
condition|)
name|BEV_RESET_GENERIC_READ_TIMEOUT
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|EV_WRITE
condition|)
name|BEV_RESET_GENERIC_WRITE_TIMEOUT
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|EV_READ
condition|)
name|consider_reading
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|EV_WRITE
condition|)
name|consider_writing
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|r1
operator|<
literal|0
operator|||
name|r2
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|be_openssl_disable
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|short
name|events
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|state
operator|!=
name|BUFFEREVENT_SSL_OPEN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|events
operator|&
name|EV_READ
condition|)
name|stop_reading
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|EV_WRITE
condition|)
name|stop_writing
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
if|if
condition|(
name|events
operator|&
name|EV_READ
condition|)
name|BEV_DEL_GENERIC_READ_TIMEOUT
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|EV_WRITE
condition|)
name|BEV_DEL_GENERIC_WRITE_TIMEOUT
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|be_openssl_unlink
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|bev
operator|.
name|options
operator|&
name|BEV_OPT_CLOSE_ON_FREE
condition|)
block|{
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
if|if
condition|(
name|BEV_UPCAST
argument_list|(
name|bev_ssl
operator|->
name|underlying
argument_list|)
operator|->
name|refcnt
operator|<
literal|2
condition|)
block|{
name|event_warnx
argument_list|(
literal|"BEV_OPT_CLOSE_ON_FREE set on an "
literal|"bufferevent with too few references"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bufferevent_free
argument_list|(
name|bev_ssl
operator|->
name|underlying
argument_list|)
expr_stmt|;
comment|/* We still have a reference to it, via our 				 * BIO. So we don't drop this. */
comment|// bev_ssl->underlying = NULL;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
operator|->
name|errorcb
operator|==
name|be_openssl_eventcb
condition|)
name|bufferevent_setcb
argument_list|(
name|bev_ssl
operator|->
name|underlying
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bufferevent_unsuspend_read_
argument_list|(
name|bev_ssl
operator|->
name|underlying
argument_list|,
name|BEV_SUSPEND_FILT_READ
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|be_openssl_destruct
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|bev
operator|.
name|options
operator|&
name|BEV_OPT_CLOSE_ON_FREE
condition|)
block|{
if|if
condition|(
operator|!
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
name|evutil_socket_t
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|BIO
modifier|*
name|bio
init|=
name|SSL_get_wbio
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|)
decl_stmt|;
if|if
condition|(
name|bio
condition|)
name|fd
operator|=
name|BIO_get_fd
argument_list|(
name|bio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|evutil_closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|SSL_free
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|be_openssl_adj_timeouts
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
condition|)
block|{
return|return
name|bufferevent_generic_adj_timeouts_
argument_list|(
name|bev
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|r1
init|=
literal|0
decl_stmt|,
name|r2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|event_pending
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|,
name|EV_READ
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|evutil_timerisset
argument_list|(
operator|&
name|bev
operator|->
name|timeout_read
argument_list|)
condition|)
block|{
name|r1
operator|=
name|bufferevent_add_event_
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|,
operator|&
name|bev
operator|->
name|timeout_read
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|event_remove_timer
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|event_pending
argument_list|(
operator|&
name|bev
operator|->
name|ev_write
argument_list|,
name|EV_WRITE
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|evutil_timerisset
argument_list|(
operator|&
name|bev
operator|->
name|timeout_write
argument_list|)
condition|)
block|{
name|r2
operator|=
name|bufferevent_add_event_
argument_list|(
operator|&
name|bev
operator|->
name|ev_write
argument_list|,
operator|&
name|bev
operator|->
name|timeout_write
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|event_remove_timer
argument_list|(
operator|&
name|bev
operator|->
name|ev_write
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|r1
operator|<
literal|0
operator|||
name|r2
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|be_openssl_flush
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|short
name|iotype
parameter_list|,
name|enum
name|bufferevent_flush_mode
name|mode
parameter_list|)
block|{
comment|/* XXXX Implement this. */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|be_openssl_ctrl
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|enum
name|bufferevent_ctrl_op
name|op
parameter_list|,
name|union
name|bufferevent_ctrl_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BEV_CTRL_SET_FD
case|:
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
condition|)
return|return
operator|-
literal|1
return|;
block|{
name|BIO
modifier|*
name|bio
decl_stmt|;
name|bio
operator|=
name|BIO_new_socket
argument_list|(
name|data
operator|->
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SSL_set_bio
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|,
name|bio
argument_list|,
name|bio
argument_list|)
expr_stmt|;
name|bev_ssl
operator|->
name|fd_is_set
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bev_ssl
operator|->
name|state
operator|==
name|BUFFEREVENT_SSL_OPEN
condition|)
return|return
name|set_open_callbacks
argument_list|(
name|bev_ssl
argument_list|,
name|data
operator|->
name|fd
argument_list|)
return|;
else|else
block|{
return|return
name|set_handshake_callbacks
argument_list|(
name|bev_ssl
argument_list|,
name|data
operator|->
name|fd
argument_list|)
return|;
block|}
case|case
name|BEV_CTRL_GET_FD
case|:
if|if
condition|(
name|bev_ssl
operator|->
name|underlying
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|bev_ssl
operator|->
name|fd_is_set
condition|)
return|return
operator|-
literal|1
return|;
name|data
operator|->
name|fd
operator|=
name|event_get_fd
argument_list|(
operator|&
name|bev
operator|->
name|ev_read
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|BEV_CTRL_GET_UNDERLYING
case|:
if|if
condition|(
operator|!
name|bev_ssl
operator|->
name|underlying
condition|)
return|return
operator|-
literal|1
return|;
name|data
operator|->
name|ptr
operator|=
name|bev_ssl
operator|->
name|underlying
expr_stmt|;
return|return
literal|0
return|;
case|case
name|BEV_CTRL_CANCEL_ALL
case|:
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
name|SSL
modifier|*
name|bufferevent_openssl_get_ssl
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|upcast
argument_list|(
name|bufev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bev_ssl
condition|)
return|return
name|NULL
return|;
return|return
name|bev_ssl
operator|->
name|ssl
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|bufferevent
modifier|*
name|bufferevent_openssl_new_impl
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|bufferevent
modifier|*
name|underlying
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|SSL
modifier|*
name|ssl
parameter_list|,
name|enum
name|bufferevent_ssl_state
name|state
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
init|=
name|NULL
decl_stmt|;
name|struct
name|bufferevent_private
modifier|*
name|bev_p
init|=
name|NULL
decl_stmt|;
name|int
name|tmp_options
init|=
name|options
operator|&
operator|~
name|BEV_OPT_THREADSAFE
decl_stmt|;
if|if
condition|(
name|underlying
operator|!=
name|NULL
operator|&&
name|fd
operator|>=
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* Only one can be set. */
if|if
condition|(
operator|!
operator|(
name|bev_ssl
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bufferevent_openssl
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
name|bev_p
operator|=
operator|&
name|bev_ssl
operator|->
name|bev
expr_stmt|;
if|if
condition|(
name|bufferevent_init_common_
argument_list|(
name|bev_p
argument_list|,
name|base
argument_list|,
operator|&
name|bufferevent_ops_openssl
argument_list|,
name|tmp_options
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/* Don't explode if we decide to realloc a chunk we're writing from in 	 * the output buffer. */
name|SSL_set_mode
argument_list|(
name|ssl
argument_list|,
name|SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER
argument_list|)
expr_stmt|;
name|bev_ssl
operator|->
name|underlying
operator|=
name|underlying
expr_stmt|;
name|bev_ssl
operator|->
name|ssl
operator|=
name|ssl
expr_stmt|;
name|bev_ssl
operator|->
name|outbuf_cb
operator|=
name|evbuffer_add_cb
argument_list|(
name|bev_p
operator|->
name|bev
operator|.
name|output
argument_list|,
name|be_openssl_outbuf_cb
argument_list|,
name|bev_ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|BEV_OPT_THREADSAFE
condition|)
name|bufferevent_enable_locking_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|underlying
condition|)
block|{
name|bufferevent_init_generic_timeout_cbs_
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
argument_list|)
expr_stmt|;
name|bufferevent_incref_
argument_list|(
name|underlying
argument_list|)
expr_stmt|;
block|}
name|bev_ssl
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|bev_ssl
operator|->
name|last_write
operator|=
operator|-
literal|1
expr_stmt|;
name|init_bio_counts
argument_list|(
name|bev_ssl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|BUFFEREVENT_SSL_ACCEPTING
case|:
name|SSL_set_accept_state
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_handshake_callbacks
argument_list|(
name|bev_ssl
argument_list|,
name|fd
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|BUFFEREVENT_SSL_CONNECTING
case|:
name|SSL_set_connect_state
argument_list|(
name|bev_ssl
operator|->
name|ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_handshake_callbacks
argument_list|(
name|bev_ssl
argument_list|,
name|fd
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|BUFFEREVENT_SSL_OPEN
case|:
if|if
condition|(
name|set_open_callbacks
argument_list|(
name|bev_ssl
argument_list|,
name|fd
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
break|break;
default|default:
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|underlying
condition|)
block|{
name|bufferevent_setwatermark
argument_list|(
name|underlying
argument_list|,
name|EV_READ
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bufferevent_enable
argument_list|(
name|underlying
argument_list|,
name|EV_READ
operator||
name|EV_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|BUFFEREVENT_SSL_OPEN
condition|)
name|bufferevent_suspend_read_
argument_list|(
name|underlying
argument_list|,
name|BEV_SUSPEND_FILT_READ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
operator|.
name|enabled
operator|=
name|EV_READ
operator||
name|EV_WRITE
expr_stmt|;
if|if
condition|(
name|bev_ssl
operator|->
name|fd_is_set
condition|)
block|{
if|if
condition|(
name|state
operator|!=
name|BUFFEREVENT_SSL_OPEN
condition|)
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
operator|.
name|ev_read
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
operator|.
name|ev_write
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
block|}
block|}
return|return
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
return|;
name|err
label|:
if|if
condition|(
name|bev_ssl
condition|)
name|bufferevent_free
argument_list|(
operator|&
name|bev_ssl
operator|->
name|bev
operator|.
name|bev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|bufferevent
modifier|*
name|bufferevent_openssl_filter_new
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|bufferevent
modifier|*
name|underlying
parameter_list|,
name|SSL
modifier|*
name|ssl
parameter_list|,
name|enum
name|bufferevent_ssl_state
name|state
parameter_list|,
name|int
name|options
parameter_list|)
block|{
comment|/* We don't tell the BIO to close the bufferevent; we do it ourselves 	 * on be_openssl_destruct */
name|int
name|close_flag
init|=
literal|0
decl_stmt|;
comment|/* options& BEV_OPT_CLOSE_ON_FREE; */
name|BIO
modifier|*
name|bio
decl_stmt|;
if|if
condition|(
operator|!
name|underlying
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|bio
operator|=
name|BIO_new_bufferevent
argument_list|(
name|underlying
argument_list|,
name|close_flag
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
name|SSL_set_bio
argument_list|(
name|ssl
argument_list|,
name|bio
argument_list|,
name|bio
argument_list|)
expr_stmt|;
return|return
name|bufferevent_openssl_new_impl
argument_list|(
name|base
argument_list|,
name|underlying
argument_list|,
operator|-
literal|1
argument_list|,
name|ssl
argument_list|,
name|state
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|bufferevent
modifier|*
name|bufferevent_openssl_socket_new
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|SSL
modifier|*
name|ssl
parameter_list|,
name|enum
name|bufferevent_ssl_state
name|state
parameter_list|,
name|int
name|options
parameter_list|)
block|{
comment|/* Does the SSL already have an fd? */
name|BIO
modifier|*
name|bio
init|=
name|SSL_get_wbio
argument_list|(
name|ssl
argument_list|)
decl_stmt|;
name|long
name|have_fd
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bio
condition|)
name|have_fd
operator|=
name|BIO_get_fd
argument_list|(
name|bio
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_fd
operator|>=
literal|0
condition|)
block|{
comment|/* The SSL is already configured with an fd. */
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
comment|/* We should learn the fd from the SSL. */
name|fd
operator|=
operator|(
name|evutil_socket_t
operator|)
name|have_fd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|have_fd
operator|==
operator|(
name|long
operator|)
name|fd
condition|)
block|{
comment|/* We already know the fd from the SSL; do nothing */
block|}
else|else
block|{
comment|/* We specified an fd different from that of the SSL. 			   This is probably an error on our part.  Fail. */
return|return
name|NULL
return|;
block|}
operator|(
name|void
operator|)
name|BIO_set_close
argument_list|(
name|bio
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The SSL isn't configured with a BIO with an fd. */
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
comment|/* ... and we have an fd we want to use. */
name|bio
operator|=
name|BIO_new_socket
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SSL_set_bio
argument_list|(
name|ssl
argument_list|,
name|bio
argument_list|,
name|bio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Leave the fd unset. */
block|}
block|}
return|return
name|bufferevent_openssl_new_impl
argument_list|(
name|base
argument_list|,
name|NULL
argument_list|,
name|fd
argument_list|,
name|ssl
argument_list|,
name|state
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_openssl_get_allow_dirty_shutdown
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|int
name|allow_dirty_shutdown
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bev_ssl
operator|=
name|upcast
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev_ssl
condition|)
name|allow_dirty_shutdown
operator|=
name|bev_ssl
operator|->
name|allow_dirty_shutdown
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
name|allow_dirty_shutdown
return|;
block|}
end_function

begin_function
name|void
name|bufferevent_openssl_set_allow_dirty_shutdown
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|int
name|allow_dirty_shutdown
parameter_list|)
block|{
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bev_ssl
operator|=
name|upcast
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev_ssl
condition|)
name|bev_ssl
operator|->
name|allow_dirty_shutdown
operator|=
operator|!
operator|!
name|allow_dirty_shutdown
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|long
name|bufferevent_get_openssl_error
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|unsigned
name|long
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|bufferevent_openssl
modifier|*
name|bev_ssl
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bev_ssl
operator|=
name|upcast
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev_ssl
operator|&&
name|bev_ssl
operator|->
name|n_errors
condition|)
block|{
name|err
operator|=
name|bev_ssl
operator|->
name|errors
index|[
operator|--
name|bev_ssl
operator|->
name|n_errors
index|]
expr_stmt|;
block|}
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

end_unit

