begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file makeshell.c  *  *  This module will interpret the options set in the tOptions  *  structure and create a Bourne shell script capable of parsing them.  *  * @addtogroup autoopts  * @{  */
end_comment

begin_comment
comment|/*  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  */
end_comment

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|void
name|emit_var_text
parameter_list|(
name|char
specifier|const
modifier|*
name|prog
parameter_list|,
name|char
specifier|const
modifier|*
name|var
parameter_list|,
name|int
name|fdin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|text_to_var
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|teTextTo
name|which
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_usage
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_wrapup
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_setup
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_action
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_inaction
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_flag
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_match_expr
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|tOptDesc
modifier|*
name|cod
parameter_list|,
name|tOptions
modifier|*
name|opts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_long
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|load_old_output
parameter_list|(
name|char
specifier|const
modifier|*
name|fname
parameter_list|,
name|char
specifier|const
modifier|*
name|pname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|open_out
parameter_list|(
name|char
specifier|const
modifier|*
name|fname
parameter_list|,
name|char
specifier|const
modifier|*
name|pname
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_function
name|LOCAL
name|noreturn
name|void
name|option_exits
parameter_list|(
name|int
name|exit_code
parameter_list|)
block|{
if|if
condition|(
name|print_exit
condition|)
name|printf
argument_list|(
literal|"\nexit %d\n"
argument_list|,
name|exit_code
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|noreturn
name|void
name|ao_bug
parameter_list|(
name|char
specifier|const
modifier|*
name|msg
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zao_bug_msg
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|option_exits
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|void
name|fserr_warn
parameter_list|(
name|char
specifier|const
modifier|*
name|prog
parameter_list|,
name|char
specifier|const
modifier|*
name|op
parameter_list|,
name|char
specifier|const
modifier|*
name|fname
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zfserr_fmt
argument_list|,
name|prog
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|op
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|noreturn
name|void
name|fserr_exit
parameter_list|(
name|char
specifier|const
modifier|*
name|prog
parameter_list|,
name|char
specifier|const
modifier|*
name|op
parameter_list|,
name|char
specifier|const
modifier|*
name|fname
parameter_list|)
block|{
name|fserr_warn
argument_list|(
name|prog
argument_list|,
name|op
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|option_exits
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*=export_func  optionParseShell  * private:  *  * what:  Decipher a boolean value  * arg:   + tOptions* + pOpts    + program options descriptor +  *  * doc:  *  Emit a shell script that will parse the command line options. =*/
end_comment

begin_function
name|void
name|optionParseShell
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
block|{
comment|/*      *  Check for our SHELL option now.      *  IF the output file contains the "#!" magic marker,      *  it will override anything we do here.      */
if|if
condition|(
name|HAVE_GENSHELL_OPT
argument_list|(
name|SHELL
argument_list|)
condition|)
name|shell_prog
operator|=
name|GENSHELL_OPT_ARG
argument_list|(
name|SHELL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ENABLED_GENSHELL_OPT
argument_list|(
name|SHELL
argument_list|)
condition|)
name|shell_prog
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|shell_prog
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|,
name|shell_prog
operator|==
name|NULL
condition|)
name|shell_prog
operator|=
name|POSIX_SHELL
expr_stmt|;
comment|/*      *  Check for a specified output file      */
if|if
condition|(
name|HAVE_GENSHELL_OPT
argument_list|(
name|SCRIPT
argument_list|)
condition|)
name|open_out
argument_list|(
name|GENSHELL_OPT_ARG
argument_list|(
name|SCRIPT
argument_list|)
argument_list|,
name|opts
operator|->
name|pzProgName
argument_list|)
expr_stmt|;
name|emit_usage
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|emit_setup
argument_list|(
name|opts
argument_list|)
expr_stmt|;
comment|/*      *  There are four modes of option processing.      */
switch|switch
condition|(
name|opts
operator|->
name|fOptSet
operator|&
operator|(
name|OPTPROC_LONGOPT
operator||
name|OPTPROC_SHORTOPT
operator|)
condition|)
block|{
case|case
name|OPTPROC_LONGOPT
case|:
name|fputs
argument_list|(
name|LOOP_STR
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|LONG_OPT_MARK
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|INIT_LOPT_STR
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|emit_long
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|LOPT_ARG_FMT
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|END_OPT_SEL_STR
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|NOT_FOUND_STR
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|fputs
argument_list|(
name|ONLY_OPTS_LOOP
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|INIT_LOPT_STR
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|emit_long
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|LOPT_ARG_FMT
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTPROC_SHORTOPT
case|:
name|fputs
argument_list|(
name|LOOP_STR
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|FLAG_OPT_MARK
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|INIT_OPT_STR
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|emit_flag
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|OPT_ARG_FMT
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|END_OPT_SEL_STR
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|NOT_FOUND_STR
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTPROC_LONGOPT
operator||
name|OPTPROC_SHORTOPT
case|:
name|fputs
argument_list|(
name|LOOP_STR
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|LONG_OPT_MARK
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|INIT_LOPT_STR
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|emit_long
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|LOPT_ARG_FMT
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|END_OPT_SEL_STR
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|FLAG_OPT_MARK
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|INIT_OPT_STR
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|emit_flag
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|OPT_ARG_FMT
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|END_OPT_SEL_STR
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|NOT_FOUND_STR
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
name|emit_wrapup
argument_list|(
name|opts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|script_trailer
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|script_trailer
operator|!=
name|NUL
operator|)
condition|)
name|fputs
argument_list|(
name|script_trailer
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ENABLED_GENSHELL_OPT
argument_list|(
name|SHELL
argument_list|)
condition|)
name|printf
argument_list|(
name|SHOW_PROG_ENV
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FCHMOD
name|fchmod
argument_list|(
name|STDOUT_FILENO
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|fserr_exit
argument_list|(
name|opts
operator|->
name|pzProgName
argument_list|,
name|zwriting
argument_list|,
name|zstdout_name
argument_list|)
expr_stmt|;
name|AGFREE
argument_list|(
name|script_text
argument_list|)
expr_stmt|;
name|script_leader
operator|=
name|NULL
expr_stmt|;
name|script_trailer
operator|=
name|NULL
expr_stmt|;
name|script_text
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WORKING_FORK
end_ifdef

begin_comment
comment|/**  * Print the value of "var" to a file descriptor.  * The "fdin" is the read end of a pipe to a forked process that  * is writing usage text to it.  We read that text in and re-emit  * to standard out, formatting it so that it is assigned to a  * shell variable.  *  * @param[in] prog  The capitalized, c-variable-formatted program name  * @param[in] var   a similarly formatted type name  *                  (LONGUSAGE, USAGE or VERSION)  * @param[in] fdin  the input end of a pipe  */
end_comment

begin_function
specifier|static
name|void
name|emit_var_text
parameter_list|(
name|char
specifier|const
modifier|*
name|prog
parameter_list|,
name|char
specifier|const
modifier|*
name|var
parameter_list|,
name|int
name|fdin
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|fdopen
argument_list|(
name|fdin
argument_list|,
literal|"r"
name|FOPEN_BINARY_FLAG
argument_list|)
decl_stmt|;
name|int
name|nlct
init|=
literal|0
decl_stmt|;
comment|/* defer newlines and skip trailing ones */
name|printf
argument_list|(
name|SET_TEXT_FMT
argument_list|,
name|prog
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
goto|goto
name|skip_text
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ch
init|=
name|fgetc
argument_list|(
name|fp
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|NL
case|:
name|nlct
operator|++
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
while|while
condition|(
name|nlct
operator|>
literal|0
condition|)
block|{
name|fputc
argument_list|(
name|NL
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|nlct
operator|--
expr_stmt|;
block|}
name|fputs
argument_list|(
name|apostrophe
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOF
case|:
goto|goto
name|done
goto|;
default|default:
while|while
condition|(
name|nlct
operator|>
literal|0
condition|)
block|{
name|fputc
argument_list|(
name|NL
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|nlct
operator|--
expr_stmt|;
block|}
name|fputc
argument_list|(
name|ch
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|done
label|:
empty_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|skip_text
label|:
name|fputs
argument_list|(
name|END_SET_TEXT
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  *  The purpose of this function is to assign "long usage", short usage  *  and version information to a shell variable.  Rather than wind our  *  way through all the logic necessary to emit the text directly, we  *  fork(), have our child process emit the text the normal way and  *  capture the output in the parent process.  *  * @param[in] opts  the program options  * @param[in] which what to print: long usage, usage or version  * @param[in] od    for TT_VERSION, it is the version option  */
end_comment

begin_function
specifier|static
name|void
name|text_to_var
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|teTextTo
name|which
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|)
block|{
define|#
directive|define
name|_TT_
parameter_list|(
name|n
parameter_list|)
value|static char const z ## n [] = #n;
name|TEXTTO_TABLE
undef|#
directive|undef
name|_TT_
define|#
directive|define
name|_TT_
parameter_list|(
name|n
parameter_list|)
value|z ## n ,
specifier|static
name|char
specifier|const
modifier|*
name|ttnames
index|[]
init|=
block|{
name|TEXTTO_TABLE
block|}
decl_stmt|;
undef|#
directive|undef
name|_TT_
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_WORKING_FORK
argument_list|)
name|printf
argument_list|(
name|SET_NO_TEXT_FMT
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|,
name|ttnames
index|[
name|which
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|fdpair
index|[
literal|2
index|]
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fdpair
argument_list|)
operator|!=
literal|0
condition|)
name|fserr_exit
argument_list|(
name|opts
operator|->
name|pzProgName
argument_list|,
literal|"pipe"
argument_list|,
name|zinter_proc_pipe
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|fserr_exit
argument_list|(
name|opts
operator|->
name|pzProgName
argument_list|,
literal|"fork"
argument_list|,
name|opts
operator|->
name|pzProgName
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|0
case|:
comment|/*          * Send both stderr and stdout to the pipe.  No matter which          * descriptor is used, we capture the output on the read end.          */
name|dup2
argument_list|(
name|fdpair
index|[
literal|1
index|]
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fdpair
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fdpair
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|TT_LONGUSAGE
case|:
operator|(
operator|*
operator|(
name|opts
operator|->
name|pUsageProc
operator|)
operator|)
operator|(
name|opts
operator|,
name|EXIT_SUCCESS
operator|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|TT_USAGE
case|:
operator|(
operator|*
operator|(
name|opts
operator|->
name|pUsageProc
operator|)
operator|)
operator|(
name|opts
operator|,
name|EXIT_FAILURE
operator|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|TT_VERSION
case|:
if|if
condition|(
name|od
operator|->
name|fOptState
operator|&
name|OPTST_ALLOC_ARG
condition|)
block|{
name|AGFREE
argument_list|(
name|od
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|od
operator|->
name|fOptState
operator|&=
operator|~
name|OPTST_ALLOC_ARG
expr_stmt|;
block|}
name|od
operator|->
name|optArg
operator|.
name|argString
operator|=
literal|"c"
expr_stmt|;
name|optionPrintVersion
argument_list|(
name|opts
argument_list|,
name|od
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
name|option_exits
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* NOTREACHED */
default|default:
name|close
argument_list|(
name|fdpair
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|emit_var_text
argument_list|(
name|opts
operator|->
name|pzPROGNAME
argument_list|,
name|ttnames
index|[
name|which
index|]
argument_list|,
name|fdpair
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * capture usage text in shell variables.  *   */
end_comment

begin_function
specifier|static
name|void
name|emit_usage
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
block|{
name|char
name|tm_nm_buf
index|[
name|AO_NAME_SIZE
index|]
decl_stmt|;
comment|/*      *  First, switch stdout to the output file name.      *  Then, change the program name to the one defined      *  by the definitions (rather than the current      *  executable name).  Down case the upper cased name.      */
if|if
condition|(
name|script_leader
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|script_leader
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|{
name|char
specifier|const
modifier|*
name|out_nm
decl_stmt|;
block|{
name|time_t
name|c_tim
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|tm
modifier|*
name|ptm
init|=
name|localtime
argument_list|(
operator|&
name|c_tim
argument_list|)
decl_stmt|;
name|strftime
argument_list|(
name|tm_nm_buf
argument_list|,
name|AO_NAME_SIZE
argument_list|,
name|TIME_FMT
argument_list|,
name|ptm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HAVE_GENSHELL_OPT
argument_list|(
name|SCRIPT
argument_list|)
condition|)
name|out_nm
operator|=
name|GENSHELL_OPT_ARG
argument_list|(
name|SCRIPT
argument_list|)
expr_stmt|;
else|else
name|out_nm
operator|=
name|STDOUT
expr_stmt|;
if|if
condition|(
operator|(
name|script_leader
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|shell_prog
operator|!=
name|NULL
operator|)
condition|)
name|printf
argument_list|(
name|SHELL_MAGIC
argument_list|,
name|shell_prog
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|PREAMBLE_FMT
argument_list|,
name|START_MARK
argument_list|,
name|out_nm
argument_list|,
name|tm_nm_buf
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|END_PRE_FMT
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
comment|/*      *  Get a copy of the original program name in lower case and      *  fill in an approximation of the program name from it.      */
block|{
name|char
modifier|*
name|pzPN
init|=
name|tm_nm_buf
decl_stmt|;
name|char
specifier|const
modifier|*
name|pz
init|=
name|opts
operator|->
name|pzPROGNAME
decl_stmt|;
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
comment|/* Copy the program name into the time/name buffer */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|pzPN
operator|++
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
operator|*
name|pz
operator|++
argument_list|)
operator|)
operator|==
name|NUL
condition|)
break|break;
block|}
name|pp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|opts
operator|->
name|pzProgPath
operator|)
expr_stmt|;
operator|*
name|pp
operator|=
name|tm_nm_buf
expr_stmt|;
name|pp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|opts
operator|->
name|pzProgName
operator|)
expr_stmt|;
operator|*
name|pp
operator|=
name|tm_nm_buf
expr_stmt|;
block|}
name|text_to_var
argument_list|(
name|opts
argument_list|,
name|TT_LONGUSAGE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|text_to_var
argument_list|(
name|opts
argument_list|,
name|TT_USAGE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|{
name|tOptDesc
modifier|*
name|pOptDesc
init|=
name|opts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|optionCt
init|=
name|opts
operator|->
name|optCt
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pOptDesc
operator|->
name|pOptProc
operator|==
name|optionPrintVersion
condition|)
block|{
name|text_to_var
argument_list|(
name|opts
argument_list|,
name|TT_VERSION
argument_list|,
name|pOptDesc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|--
name|optionCt
operator|<=
literal|0
condition|)
break|break;
name|pOptDesc
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|emit_wrapup
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|od
init|=
name|opts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|opt_ct
init|=
name|opts
operator|->
name|presetOptCt
decl_stmt|;
name|char
specifier|const
modifier|*
name|fmt
decl_stmt|;
name|printf
argument_list|(
name|FINISH_LOOP
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|opt_ct
operator|>
literal|0
condition|;
name|od
operator|++
operator|,
operator|--
name|opt_ct
control|)
block|{
comment|/*          *  Options that are either usage documentation or are compiled out          *  are not to be processed.          */
if|if
condition|(
name|SKIP_OPT
argument_list|(
name|od
argument_list|)
operator|||
operator|(
name|od
operator|->
name|pz_NAME
operator|==
name|NULL
operator|)
condition|)
continue|continue;
comment|/*          *  do not presence check if there is no minimum/must-set          */
if|if
condition|(
operator|(
name|od
operator|->
name|optMinCt
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|od
operator|->
name|fOptState
operator|&
name|OPTST_MUST_SET
operator|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|od
operator|->
name|optMaxCt
operator|>
literal|1
condition|)
name|fmt
operator|=
name|CHK_MIN_COUNT
expr_stmt|;
else|else
name|fmt
operator|=
name|CHK_ONE_REQUIRED
expr_stmt|;
block|{
name|int
name|min
init|=
operator|(
name|od
operator|->
name|optMinCt
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|od
operator|->
name|optMinCt
decl_stmt|;
name|printf
argument_list|(
name|fmt
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|,
name|od
operator|->
name|pz_NAME
argument_list|,
name|min
argument_list|)
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
name|END_MARK
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_setup
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|od
init|=
name|opts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|opt_ct
init|=
name|opts
operator|->
name|presetOptCt
decl_stmt|;
name|char
specifier|const
modifier|*
name|fmt
decl_stmt|;
name|char
specifier|const
modifier|*
name|def_val
decl_stmt|;
for|for
control|(
init|;
name|opt_ct
operator|>
literal|0
condition|;
name|od
operator|++
operator|,
operator|--
name|opt_ct
control|)
block|{
name|char
name|int_val_buf
index|[
literal|32
index|]
decl_stmt|;
comment|/*          *  Options that are either usage documentation or are compiled out          *  are not to be processed.          */
if|if
condition|(
name|SKIP_OPT
argument_list|(
name|od
argument_list|)
operator|||
operator|(
name|od
operator|->
name|pz_NAME
operator|==
name|NULL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|od
operator|->
name|optMaxCt
operator|>
literal|1
condition|)
name|fmt
operator|=
name|MULTI_DEF_FMT
expr_stmt|;
else|else
name|fmt
operator|=
name|SGL_DEF_FMT
expr_stmt|;
comment|/*          *  IF this is an enumeration/bitmask option, then convert the value          *  to a string before printing the default value.          */
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|od
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_ENUMERATION
case|:
operator|(
operator|*
operator|(
name|od
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|OPTPROC_EMIT_SHELL
operator|,
name|od
operator|)
expr_stmt|;
name|def_val
operator|=
name|od
operator|->
name|optArg
operator|.
name|argString
expr_stmt|;
break|break;
comment|/*          *  Numeric and membership bit options are just printed as a number.          */
case|case
name|OPARG_TYPE_NUMERIC
case|:
name|snprintf
argument_list|(
name|int_val_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|int_val_buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|od
operator|->
name|optArg
operator|.
name|argInt
argument_list|)
expr_stmt|;
name|def_val
operator|=
name|int_val_buf
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_MEMBERSHIP
case|:
name|snprintf
argument_list|(
name|int_val_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|int_val_buf
argument_list|)
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|od
operator|->
name|optArg
operator|.
name|argIntptr
argument_list|)
expr_stmt|;
name|def_val
operator|=
name|int_val_buf
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_BOOLEAN
case|:
name|def_val
operator|=
operator|(
name|od
operator|->
name|optArg
operator|.
name|argBool
operator|)
condition|?
name|TRUE_STR
else|:
name|FALSE_STR
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|od
operator|->
name|optArg
operator|.
name|argString
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fmt
operator|==
name|SGL_DEF_FMT
condition|)
name|fmt
operator|=
name|SGL_NO_DEF_FMT
expr_stmt|;
name|def_val
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|def_val
operator|=
name|od
operator|->
name|optArg
operator|.
name|argString
expr_stmt|;
block|}
name|printf
argument_list|(
name|fmt
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|,
name|od
operator|->
name|pz_NAME
argument_list|,
name|def_val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|emit_action
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|)
block|{
if|if
condition|(
name|od
operator|->
name|pOptProc
operator|==
name|optionPrintVersion
condition|)
name|printf
argument_list|(
name|ECHO_N_EXIT
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|,
name|VER_STR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|od
operator|->
name|pOptProc
operator|==
name|optionPagedUsage
condition|)
name|printf
argument_list|(
name|PAGE_USAGE_TEXT
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|od
operator|->
name|pOptProc
operator|==
name|optionLoadOpt
condition|)
block|{
name|printf
argument_list|(
name|LVL3_CMD
argument_list|,
name|NO_LOAD_WARN
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|LVL3_CMD
argument_list|,
name|YES_NEED_OPT_ARG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|od
operator|->
name|pz_NAME
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|od
operator|->
name|pOptProc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
name|LVL3_CMD
argument_list|,
name|NO_SAVE_OPTS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|LVL3_CMD
argument_list|,
name|OK_NEED_OPT_ARG
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
name|ECHO_N_EXIT
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|,
name|LONG_USE_STR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|od
operator|->
name|optMaxCt
operator|==
literal|1
condition|)
name|printf
argument_list|(
name|SGL_ARG_FMT
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|,
name|od
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|unsigned
operator|)
name|od
operator|->
name|optMaxCt
operator|<
name|NOLIMIT
condition|)
name|printf
argument_list|(
name|CHK_MAX_COUNT
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|,
name|od
operator|->
name|pz_NAME
argument_list|,
name|od
operator|->
name|optMaxCt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|MULTI_ARG_FMT
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|,
name|od
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
block|}
comment|/*          *  Fix up the args.          */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|od
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_NONE
condition|)
block|{
name|printf
argument_list|(
name|SET_MULTI_ARG
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|,
name|od
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|LVL3_CMD
argument_list|,
name|NO_ARG_NEEDED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|od
operator|->
name|fOptState
operator|&
name|OPTST_ARG_OPTIONAL
condition|)
block|{
name|printf
argument_list|(
name|SET_MULTI_ARG
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|,
name|od
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|LVL3_CMD
argument_list|,
name|OK_NEED_OPT_ARG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|LVL3_CMD
argument_list|,
name|YES_NEED_OPT_ARG
argument_list|)
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
name|zOptionEndSelect
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_inaction
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|)
block|{
if|if
condition|(
name|od
operator|->
name|pOptProc
operator|==
name|optionLoadOpt
condition|)
block|{
name|printf
argument_list|(
name|LVL3_CMD
argument_list|,
name|NO_SUPPRESS_LOAD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|od
operator|->
name|optMaxCt
operator|==
literal|1
condition|)
name|printf
argument_list|(
name|NO_SGL_ARG_FMT
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|,
name|od
operator|->
name|pz_NAME
argument_list|,
name|od
operator|->
name|pz_DisablePfx
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|NO_MULTI_ARG_FMT
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|,
name|od
operator|->
name|pz_NAME
argument_list|,
name|od
operator|->
name|pz_DisablePfx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|LVL3_CMD
argument_list|,
name|NO_ARG_NEEDED
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zOptionEndSelect
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * recognize flag options.  These go at the end.  * At the end, emit code to handle options we don't recognize.  *  * @param[in] opts  the program options  */
end_comment

begin_function
specifier|static
name|void
name|emit_flag
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|od
init|=
name|opts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|opt_ct
init|=
name|opts
operator|->
name|optCt
decl_stmt|;
name|fputs
argument_list|(
name|zOptionCase
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|opt_ct
operator|>
literal|0
condition|;
name|od
operator|++
operator|,
operator|--
name|opt_ct
control|)
block|{
if|if
condition|(
name|SKIP_OPT
argument_list|(
name|od
argument_list|)
operator|||
operator|!
name|IS_GRAPHIC_CHAR
argument_list|(
name|od
operator|->
name|optValue
argument_list|)
condition|)
continue|continue;
name|printf
argument_list|(
name|zOptionFlag
argument_list|,
name|od
operator|->
name|optValue
argument_list|)
expr_stmt|;
name|emit_action
argument_list|(
name|opts
argument_list|,
name|od
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|UNK_OPT_FMT
argument_list|,
name|FLAG_STR
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  Emit the match text for a long option.  The passed in \a name may be  *  either the enablement name or the disablement name.  *  * @param[in] name  The current name to check.  * @param[in] cod   current option descriptor  * @param[in] opts  the program options  */
end_comment

begin_function
specifier|static
name|void
name|emit_match_expr
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|tOptDesc
modifier|*
name|cod
parameter_list|,
name|tOptions
modifier|*
name|opts
parameter_list|)
block|{
name|char
name|name_bf
index|[
literal|32
index|]
decl_stmt|;
name|unsigned
name|int
name|min_match_ct
init|=
literal|2
decl_stmt|;
name|unsigned
name|int
name|max_match_ct
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|max_match_ct
operator|>=
sizeof|sizeof
argument_list|(
name|name_bf
argument_list|)
operator|-
literal|1
condition|)
goto|goto
name|leave
goto|;
block|{
name|tOptDesc
modifier|*
name|od
init|=
name|opts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|ct
init|=
name|opts
operator|->
name|optCt
decl_stmt|;
for|for
control|(
init|;
name|ct
operator|--
operator|>
literal|0
condition|;
name|od
operator|++
control|)
block|{
name|unsigned
name|int
name|match_ct
init|=
literal|0
decl_stmt|;
comment|/*              *  Omit the current option, Doc opts and compiled out opts.              */
if|if
condition|(
operator|(
name|od
operator|==
name|cod
operator|)
operator|||
name|SKIP_OPT
argument_list|(
name|od
argument_list|)
condition|)
continue|continue;
comment|/*              *  Check each character of the name case insensitively.              *  They must not be the same.  They cannot be, because it would              *  not compile correctly if they were.              */
while|while
condition|(
name|toupper
argument_list|(
name|od
operator|->
name|pz_Name
index|[
name|match_ct
index|]
argument_list|)
operator|==
name|toupper
argument_list|(
name|name
index|[
name|match_ct
index|]
argument_list|)
condition|)
name|match_ct
operator|++
expr_stmt|;
if|if
condition|(
name|match_ct
operator|>
name|min_match_ct
condition|)
name|min_match_ct
operator|=
name|match_ct
expr_stmt|;
comment|/*              *  Check the disablement name, too.              */
if|if
condition|(
name|od
operator|->
name|pz_DisableName
operator|==
name|NULL
condition|)
continue|continue;
name|match_ct
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|toupper
argument_list|(
name|od
operator|->
name|pz_DisableName
index|[
name|match_ct
index|]
argument_list|)
operator|==
name|toupper
argument_list|(
name|name
index|[
name|match_ct
index|]
argument_list|)
condition|)
name|match_ct
operator|++
expr_stmt|;
if|if
condition|(
name|match_ct
operator|>
name|min_match_ct
condition|)
name|min_match_ct
operator|=
name|match_ct
expr_stmt|;
block|}
block|}
comment|/*      *  Don't bother emitting partial matches if there is only one possible      *  partial match.      */
if|if
condition|(
name|min_match_ct
operator|<
name|max_match_ct
condition|)
block|{
name|char
modifier|*
name|pz
init|=
name|name_bf
operator|+
name|min_match_ct
decl_stmt|;
name|int
name|nm_ix
init|=
name|min_match_ct
decl_stmt|;
name|memcpy
argument_list|(
name|name_bf
argument_list|,
name|name
argument_list|,
name|min_match_ct
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|pz
operator|=
name|NUL
expr_stmt|;
name|printf
argument_list|(
name|zOptionPartName
argument_list|,
name|name_bf
argument_list|)
expr_stmt|;
operator|*
name|pz
operator|++
operator|=
name|name
index|[
name|nm_ix
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|name
index|[
name|nm_ix
index|]
operator|==
name|NUL
condition|)
block|{
operator|*
name|pz
operator|=
name|NUL
expr_stmt|;
break|break;
block|}
block|}
block|}
name|leave
label|:
name|printf
argument_list|(
name|zOptionFullName
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  Emit GNU-standard long option handling code.  *  * @param[in] opts  the program options  */
end_comment

begin_function
specifier|static
name|void
name|emit_long
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|od
init|=
name|opts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|ct
init|=
name|opts
operator|->
name|optCt
decl_stmt|;
name|fputs
argument_list|(
name|zOptionCase
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/*      *  do each option, ...      */
do|do
block|{
comment|/*          *  Documentation& compiled-out options          */
if|if
condition|(
name|SKIP_OPT
argument_list|(
name|od
argument_list|)
condition|)
continue|continue;
name|emit_match_expr
argument_list|(
name|od
operator|->
name|pz_Name
argument_list|,
name|od
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|emit_action
argument_list|(
name|opts
argument_list|,
name|od
argument_list|)
expr_stmt|;
comment|/*          *  Now, do the same thing for the disablement version of the option.          */
if|if
condition|(
name|od
operator|->
name|pz_DisableName
operator|!=
name|NULL
condition|)
block|{
name|emit_match_expr
argument_list|(
name|od
operator|->
name|pz_DisableName
argument_list|,
name|od
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|emit_inaction
argument_list|(
name|opts
argument_list|,
name|od
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|od
operator|++
operator|,
operator|--
name|ct
operator|>
literal|0
condition|)
do|;
name|printf
argument_list|(
name|UNK_OPT_FMT
argument_list|,
name|OPTION_STR
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Load the previous shell script output file.  We need to preserve any  * hand-edited additions outside of the START_MARK and END_MARKs.  *  * @param[in] fname  the output file name  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|load_old_output
parameter_list|(
name|char
specifier|const
modifier|*
name|fname
parameter_list|,
name|char
specifier|const
modifier|*
name|pname
parameter_list|)
block|{
comment|/*      *  IF we cannot stat the file,      *  THEN assume we are creating a new file.      *       Skip the loading of the old data.      */
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
name|FOPEN_BINARY_FLAG
argument_list|)
decl_stmt|;
name|struct
name|stat
name|stbf
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|char
modifier|*
name|scan
decl_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/*      * If we opened it, we should be able to stat it and it needs      * to be a regular file      */
if|if
condition|(
operator|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|stbf
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|!
name|S_ISREG
argument_list|(
name|stbf
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
name|fserr_exit
argument_list|(
name|pname
argument_list|,
literal|"fstat"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|scan
operator|=
name|text
operator|=
name|AGALOC
argument_list|(
name|stbf
operator|.
name|st_size
operator|+
literal|1
argument_list|,
literal|"f data"
argument_list|)
expr_stmt|;
comment|/*      *  Read in all the data as fast as our OS will let us.      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|size_t
name|inct
init|=
name|fread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|scan
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|stbf
operator|.
name|st_size
argument_list|,
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|inct
operator|==
literal|0
condition|)
break|break;
name|stbf
operator|.
name|st_size
operator|-=
operator|(
name|ssize_t
operator|)
name|inct
expr_stmt|;
if|if
condition|(
name|stbf
operator|.
name|st_size
operator|==
literal|0
condition|)
break|break;
name|scan
operator|+=
name|inct
expr_stmt|;
block|}
operator|*
name|scan
operator|=
name|NUL
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|text
return|;
block|}
end_function

begin_comment
comment|/**  * Open the specified output file.  If it already exists, load its  * contents and save the non-generated (hand edited) portions.  * If a "start mark" is found, everything before it is preserved leader.  * If not, the entire thing is a trailer.  Assuming the start is found,  * then everything after the end marker is the trailer.  If the end  * mark is not found, the file is actually corrupt, but we take the  * remainder to be the trailer.  *  * @param[in] fname  the output file name  */
end_comment

begin_function
specifier|static
name|void
name|open_out
parameter_list|(
name|char
specifier|const
modifier|*
name|fname
parameter_list|,
name|char
specifier|const
modifier|*
name|pname
parameter_list|)
block|{
do|do
block|{
name|char
modifier|*
name|txt
init|=
name|script_text
operator|=
name|load_old_output
argument_list|(
name|fname
argument_list|,
name|pname
argument_list|)
decl_stmt|;
name|char
modifier|*
name|scn
decl_stmt|;
if|if
condition|(
name|txt
operator|==
name|NULL
condition|)
break|break;
name|scn
operator|=
name|strstr
argument_list|(
name|txt
argument_list|,
name|START_MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|scn
operator|==
name|NULL
condition|)
block|{
name|script_trailer
operator|=
name|txt
expr_stmt|;
break|break;
block|}
operator|*
operator|(
name|scn
operator|++
operator|)
operator|=
name|NUL
expr_stmt|;
name|scn
operator|=
name|strstr
argument_list|(
name|scn
argument_list|,
name|END_MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|scn
operator|==
name|NULL
condition|)
block|{
comment|/*              * The file is corrupt.  Set the trailer to be everything              * after the start mark. The user will need to fix it up.              */
name|script_trailer
operator|=
name|txt
operator|+
name|strlen
argument_list|(
name|txt
argument_list|)
operator|+
name|START_MARK_LEN
operator|+
literal|1
expr_stmt|;
break|break;
block|}
comment|/*          *  Check to see if the data contains our marker.          *  If it does, then we will skip over it          */
name|script_trailer
operator|=
name|scn
operator|+
name|END_MARK_LEN
expr_stmt|;
name|script_leader
operator|=
name|txt
expr_stmt|;
block|}
do|while
condition|(
name|false
condition|)
do|;
if|if
condition|(
name|freopen
argument_list|(
name|fname
argument_list|,
literal|"w"
name|FOPEN_BINARY_FLAG
argument_list|,
name|stdout
argument_list|)
operator|!=
name|stdout
condition|)
name|fserr_exit
argument_list|(
name|pname
argument_list|,
literal|"freopen"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*=export_func genshelloptUsage  * private:  * what: The usage function for the genshellopt generated program  *  * arg:  + tOptions* + opts    + program options descriptor +  * arg:  + int       + exit_cd + usage text type to produce +  *  * doc:  *  This function is used to create the usage strings for the option  *  processing shell script code.  Two child processes are spawned  *  each emitting the usage text in either the short (error exit)  *  style or the long style.  The generated program will capture this  *  and create shell script variables containing the two types of text. =*/
end_comment

begin_function
name|void
name|genshelloptUsage
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|int
name|exit_cd
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_WORKING_FORK
argument_list|)
name|optionUsage
argument_list|(
name|opts
argument_list|,
name|exit_cd
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/*      *  IF not EXIT_SUCCESS,      *  THEN emit the short form of usage.      */
if|if
condition|(
name|exit_cd
operator|!=
name|EXIT_SUCCESS
condition|)
name|optionUsage
argument_list|(
name|opts
argument_list|,
name|exit_cd
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|ferror
argument_list|(
name|stderr
argument_list|)
condition|)
name|option_exits
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|option_usage_fp
operator|=
name|stdout
expr_stmt|;
comment|/*      *  First, print our usage      */
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|optionUsage
argument_list|(
name|opts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|0
case|:
name|pagerState
operator|=
name|PAGER_STATE_CHILD
expr_stmt|;
name|optionUsage
argument_list|(
name|opts
argument_list|,
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
default|default:
block|{
name|int
name|sts
decl_stmt|;
name|wait
argument_list|(
operator|&
name|sts
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      *  Generate the pzProgName, since optionProcess() normally      *  gets it from the command line      */
block|{
name|char
modifier|*
name|pz
decl_stmt|;
name|char
modifier|*
modifier|*
name|pp
init|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|optionParseShellOptions
operator|->
name|pzProgName
operator|)
decl_stmt|;
name|AGDUPSTR
argument_list|(
name|pz
argument_list|,
name|optionParseShellOptions
operator|->
name|pzPROGNAME
argument_list|,
literal|"prog name"
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|pz
expr_stmt|;
while|while
condition|(
operator|*
name|pz
operator|!=
name|NUL
condition|)
block|{
operator|*
name|pz
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
operator|*
name|pz
argument_list|)
expr_stmt|;
name|pz
operator|++
expr_stmt|;
block|}
block|}
comment|/*      *  Separate the makeshell usage from the client usage      */
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zGenshell
argument_list|,
name|optionParseShellOptions
operator|->
name|pzProgName
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*      *  Now, print the client usage.      */
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
name|pagerState
operator|=
name|PAGER_STATE_CHILD
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
operator|-
literal|1
case|:
name|optionUsage
argument_list|(
name|optionParseShellOptions
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
default|default:
block|{
name|int
name|sts
decl_stmt|;
name|wait
argument_list|(
operator|&
name|sts
argument_list|)
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|fserr_exit
argument_list|(
name|opts
operator|->
name|pzProgName
argument_list|,
name|zwriting
argument_list|,
name|zstdout_name
argument_list|)
expr_stmt|;
name|option_exits
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/** @}  *  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/makeshell.c */
end_comment

end_unit

