begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file makeshell.c  *  * Time-stamp:      "2011-04-20 11:06:57 bkorb"  *  *  This module will interpret the options set in the tOptions  *  structure and create a Bourne shell script capable of parsing them.  *  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (c) 1992-2011 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following md5sums:  *  *  43b91e8ca915626ed3818ffb1b71248b pkg/libopts/COPYING.gplv3  *  06a1a2e4760c90ea5e1dad8dfaac4d39 pkg/libopts/COPYING.lgplv3  *  66a5cedaf62c4b2637025f049f9b826f pkg/libopts/COPYING.mbsd  */
end_comment

begin_decl_stmt
name|tOptions
modifier|*
name|optionParseShellOptions
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * *  *  *  Setup Format Strings  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zStartMarker
index|[]
init|=
literal|"# # # # # # # # # # -- do not modify this marker --\n#\n"
literal|"#  DO NOT EDIT THIS SECTION"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zPreamble
index|[]
init|=
literal|"%s OF %s\n#\n"
literal|"#  From here to the next `-- do not modify this marker --',\n"
literal|"#  the text has been generated %s\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zEndPreamble
index|[]
init|=
literal|"#  From the %s option definitions\n#\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zMultiDef
index|[]
init|=
literal|"\n"
literal|"if test -z \"${%1$s_%2$s}\"\n"
literal|"then\n"
literal|"  %1$s_%2$s_CT=0\n"
literal|"else\n"
literal|"  %1$s_%2$s_CT=1\n"
literal|"  %1$s_%2$s_1=\"${%1$s_%2$s}\"\n"
literal|"fi\n"
literal|"export %1$s_%2$s_CT"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zSingleDef
index|[]
init|=
literal|"\n"
literal|"%1$s_%2$s=\"${%1$s_%2$s-'%3$s'}\"\n"
literal|"%1$s_%2$s_set=false\n"
literal|"export %1$s_%2$s\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zSingleNoDef
index|[]
init|=
literal|"\n"
literal|"%1$s_%2$s=\"${%1$s_%2$s}\"\n"
literal|"%1$s_%2$s_set=false\n"
literal|"export %1$s_%2$s\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * *  *  *  LOOP START  *  *  The loop may run in either of two modes:  *  all options are named options (loop only)  *  regular, marked option processing.  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zLoopCase
index|[]
init|=
literal|"\n"
literal|"OPT_PROCESS=true\n"
literal|"OPT_ARG=\"$1\"\n\n"
literal|"while ${OPT_PROCESS}&& [ $# -gt 0 ]\ndo\n"
literal|"    OPT_ELEMENT=''\n"
literal|"    OPT_ARG_VAL=''\n\n"
comment|/*       *  'OPT_ARG' may or may not match the current $1       */
literal|"    case \"${OPT_ARG}\" in\n"
literal|"    -- )\n"
literal|"        OPT_PROCESS=false\n"
literal|"        shift\n"
literal|"        ;;\n\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zLoopOnly
index|[]
init|=
literal|"\n"
literal|"OPT_ARG=\"$1\"\n\n"
literal|"while [ $# -gt 0 ]\ndo\n"
literal|"    OPT_ELEMENT=''\n"
literal|"    OPT_ARG_VAL=''\n\n"
literal|"    OPT_ARG=\"${1}\"\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* * * * * * * * * * * * * * * *  *  *  CASE SELECTORS  *  *  If the loop runs as a regular option loop,  *  then we must have selectors for each acceptable option  *  type (long option, flag character and non-option)  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zLongSelection
index|[]
init|=
literal|"    --* )\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zFlagSelection
index|[]
init|=
literal|"    -* )\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zEndSelection
index|[]
init|=
literal|"        ;;\n\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zNoSelection
index|[]
init|=
literal|"    * )\n"
literal|"         OPT_PROCESS=false\n"
literal|"         ;;\n"
literal|"    esac\n\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* * * * * * * * * * * * * * * *  *  *  LOOP END  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zLoopEnd
index|[]
init|=
literal|"    if [ -n \"${OPT_ARG_VAL}\" ]\n"
literal|"    then\n"
literal|"        eval %1$s_${OPT_NAME}${OPT_ELEMENT}=\"'${OPT_ARG_VAL}'\"\n"
literal|"        export %1$s_${OPT_NAME}${OPT_ELEMENT}\n"
literal|"    fi\n"
literal|"done\n\n"
literal|"unset OPT_PROCESS || :\n"
literal|"unset OPT_ELEMENT || :\n"
literal|"unset OPT_ARG || :\n"
literal|"unset OPT_ARG_NEEDED || :\n"
literal|"unset OPT_NAME || :\n"
literal|"unset OPT_CODE || :\n"
literal|"unset OPT_ARG_VAL || :\n%2$s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zTrailerMarker
index|[]
init|=
literal|"\n"
literal|"# # # # # # # # # #\n#\n"
literal|"#  END OF AUTOMATED OPTION PROCESSING\n"
literal|"#\n# # # # # # # # # # -- do not modify this marker --\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *  OPTION SELECTION  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zOptionCase
index|[]
init|=
literal|"        case \"${OPT_CODE}\" in\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zOptionPartName
index|[]
init|=
literal|"        '%s' | \\\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zOptionFullName
index|[]
init|=
literal|"        '%s' )\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zOptionFlag
index|[]
init|=
literal|"        '%c' )\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zOptionEndSelect
index|[]
init|=
literal|"            ;;\n\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zOptionUnknown
index|[]
init|=
literal|"        * )\n"
literal|"            echo Unknown %s: \"${OPT_CODE}\">&2\n"
literal|"            echo \"$%s_USAGE_TEXT\"\n"
literal|"            exit 1\n"
literal|"            ;;\n"
literal|"        esac\n\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *  OPTION PROCESSING  *  *  Formats for emitting the text for handling particular options  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zTextExit
index|[]
init|=
literal|"            echo \"$%s_%s_TEXT\"\n"
literal|"            exit 0\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zPagedUsageExit
index|[]
init|=
literal|"            echo \"$%s_LONGUSAGE_TEXT\" | ${PAGER-more}\n"
literal|"            exit 0\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zCmdFmt
index|[]
init|=
literal|"            %s\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zCountTest
index|[]
init|=
literal|"            if [ $%1$s_%2$s_CT -ge %3$d ] ; then\n"
literal|"                echo Error:  more than %3$d %2$s options>&2\n"
literal|"                echo \"$%1$s_USAGE_TEXT\"\n"
literal|"                exit 1 ; fi\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zMultiArg
index|[]
init|=
literal|"            %1$s_%2$s_CT=`expr ${%1$s_%2$s_CT} + 1`\n"
literal|"            OPT_ELEMENT=\"_${%1$s_%2$s_CT}\"\n"
literal|"            OPT_NAME='%2$s'\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zSingleArg
index|[]
init|=
literal|"            if [ -n \"${%1$s_%2$s}\" ]&& ${%1$s_%2$s_set} ; then\n"
literal|"                echo Error:  duplicate %2$s option>&2\n"
literal|"                echo \"$%1$s_USAGE_TEXT\"\n"
literal|"                exit 1 ; fi\n"
literal|"            %1$s_%2$s_set=true\n"
literal|"            OPT_NAME='%2$s'\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zNoMultiArg
index|[]
init|=
literal|"            %1$s_%2$s_CT=0\n"
literal|"            OPT_ELEMENT=''\n"
literal|"            %1$s_%2$s='%3$s'\n"
literal|"            export %1$s_%2$s\n"
literal|"            OPT_NAME='%2$s'\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zNoSingleArg
index|[]
init|=
literal|"            if [ -n \"${%1$s_%2$s}\" ]&& ${%1$s_%2$s_set} ; then\n"
literal|"                echo Error:  duplicate %2$s option>&2\n"
literal|"                echo \"$%1$s_USAGE_TEXT\"\n"
literal|"                exit 1 ; fi\n"
literal|"            %1$s_%2$s_set=true\n"
literal|"            %1$s_%2$s='%3$s'\n"
literal|"            export %1$s_%2$s\n"
literal|"            OPT_NAME='%2$s'\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zMayArg
index|[]
init|=
literal|"            eval %1$s_%2$s${OPT_ELEMENT}=true\n"
literal|"            export %1$s_%2$s${OPT_ELEMENT}\n"
literal|"            OPT_ARG_NEEDED=OK\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zMustArg
index|[]
init|=
literal|"            OPT_ARG_NEEDED=YES\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zCantArg
index|[]
init|=
literal|"            eval %1$s_%2$s${OPT_ELEMENT}=true\n"
literal|"            export %1$s_%2$s${OPT_ELEMENT}\n"
literal|"            OPT_ARG_NEEDED=NO\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *  LONG OPTION PROCESSING  *  *  Formats for emitting the text for handling long option types  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zLongOptInit
index|[]
init|=
literal|"        OPT_CODE=`echo \"X${OPT_ARG}\"|sed 's/^X-*//'`\n"
literal|"        shift\n"
literal|"        OPT_ARG=\"$1\"\n\n"
literal|"        case \"${OPT_CODE}\" in *=* )\n"
literal|"            OPT_ARG_VAL=`echo \"${OPT_CODE}\"|sed 's/^[^=]*=//'`\n"
literal|"            OPT_CODE=`echo \"${OPT_CODE}\"|sed 's/=.*$//'` ;; esac\n\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zLongOptArg
index|[]
init|=
literal|"        case \"${OPT_ARG_NEEDED}\" in\n"
literal|"        NO )\n"
literal|"            OPT_ARG_VAL=''\n"
literal|"            ;;\n\n"
literal|"        YES )\n"
literal|"            if [ -z \"${OPT_ARG_VAL}\" ]\n"
literal|"            then\n"
literal|"                if [ $# -eq 0 ]\n"
literal|"                then\n"
literal|"                    echo No argument provided for ${OPT_NAME} option>&2\n"
literal|"                    echo \"$%s_USAGE_TEXT\"\n"
literal|"                    exit 1\n"
literal|"                fi\n\n"
literal|"                OPT_ARG_VAL=\"${OPT_ARG}\"\n"
literal|"                shift\n"
literal|"                OPT_ARG=\"$1\"\n"
literal|"            fi\n"
literal|"            ;;\n\n"
literal|"        OK )\n"
literal|"            if [ -z \"${OPT_ARG_VAL}\" ]&& [ $# -gt 0 ]\n"
literal|"            then\n"
literal|"                case \"${OPT_ARG}\" in -* ) ;; * )\n"
literal|"                    OPT_ARG_VAL=\"${OPT_ARG}\"\n"
literal|"                    shift\n"
literal|"                    OPT_ARG=\"$1\" ;; esac\n"
literal|"            fi\n"
literal|"            ;;\n"
literal|"        esac\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *  FLAG OPTION PROCESSING  *  *  Formats for emitting the text for handling flag option types  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zFlagOptInit
index|[]
init|=
literal|"        OPT_CODE=`echo \"X${OPT_ARG}\" | sed 's/X-\\(.\\).*/\\1/'`\n"
literal|"        OPT_ARG=` echo \"X${OPT_ARG}\" | sed 's/X-.//'`\n\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zFlagOptArg
index|[]
init|=
literal|"        case \"${OPT_ARG_NEEDED}\" in\n"
literal|"        NO )\n"
literal|"            if [ -n \"${OPT_ARG}\" ]\n"
literal|"            then\n"
literal|"                OPT_ARG=-\"${OPT_ARG}\"\n"
literal|"            else\n"
literal|"                shift\n"
literal|"                OPT_ARG=\"$1\"\n"
literal|"            fi\n"
literal|"            ;;\n\n"
literal|"        YES )\n"
literal|"            if [ -n \"${OPT_ARG}\" ]\n"
literal|"            then\n"
literal|"                OPT_ARG_VAL=\"${OPT_ARG}\"\n\n"
literal|"            else\n"
literal|"                if [ $# -eq 0 ]\n"
literal|"                then\n"
literal|"                    echo No argument provided for ${OPT_NAME} option>&2\n"
literal|"                    echo \"$%s_USAGE_TEXT\"\n"
literal|"                    exit 1\n"
literal|"                fi\n"
literal|"                shift\n"
literal|"                OPT_ARG_VAL=\"$1\"\n"
literal|"            fi\n\n"
literal|"            shift\n"
literal|"            OPT_ARG=\"$1\"\n"
literal|"            ;;\n\n"
literal|"        OK )\n"
literal|"            if [ -n \"${OPT_ARG}\" ]\n"
literal|"            then\n"
literal|"                OPT_ARG_VAL=\"${OPT_ARG}\"\n"
literal|"                shift\n"
literal|"                OPT_ARG=\"$1\"\n\n"
literal|"            else\n"
literal|"                shift\n"
literal|"                if [ $# -gt 0 ]\n"
literal|"                then\n"
literal|"                    case \"$1\" in -* ) ;; * )\n"
literal|"                        OPT_ARG_VAL=\"$1\"\n"
literal|"                        shift ;; esac\n"
literal|"                    OPT_ARG=\"$1\"\n"
literal|"                fi\n"
literal|"            fi\n"
literal|"            ;;\n"
literal|"        esac\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tSCC
modifier|*
name|pzShell
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pzLeader
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pzTrailer
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|void
name|emit_var_text
parameter_list|(
name|char
specifier|const
modifier|*
name|prog
parameter_list|,
name|char
specifier|const
modifier|*
name|var
parameter_list|,
name|int
name|fdin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|textToVariable
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|teTextTo
name|whichVar
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emitUsage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emitSetup
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printOptionAction
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOptDesc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printOptionInaction
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOptDesc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emitFlag
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emitMatchExpr
parameter_list|(
name|tCC
modifier|*
name|pzMatchName
parameter_list|,
name|tOptDesc
modifier|*
name|pCurOpt
parameter_list|,
name|tOptions
modifier|*
name|pOpts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emitLong
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|openOutput
parameter_list|(
name|char
specifier|const
modifier|*
name|pzFile
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/*=export_func  optionParseShell  * private:  *  * what:  Decipher a boolean value  * arg:   + tOptions* + pOpts    + program options descriptor +  *  * doc:  *  Emit a shell script that will parse the command line options. =*/
end_comment

begin_function
name|void
name|optionParseShell
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
comment|/*      *  Check for our SHELL option now.      *  IF the output file contains the "#!" magic marker,      *  it will override anything we do here.      */
if|if
condition|(
name|HAVE_GENSHELL_OPT
argument_list|(
name|SHELL
argument_list|)
condition|)
name|pzShell
operator|=
name|GENSHELL_OPT_ARG
argument_list|(
name|SHELL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ENABLED_GENSHELL_OPT
argument_list|(
name|SHELL
argument_list|)
condition|)
name|pzShell
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pzShell
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|,
name|pzShell
operator|==
name|NULL
condition|)
name|pzShell
operator|=
name|POSIX_SHELL
expr_stmt|;
comment|/*      *  Check for a specified output file      */
if|if
condition|(
name|HAVE_GENSHELL_OPT
argument_list|(
name|SCRIPT
argument_list|)
condition|)
name|openOutput
argument_list|(
name|GENSHELL_OPT_ARG
argument_list|(
name|SCRIPT
argument_list|)
argument_list|)
expr_stmt|;
name|emitUsage
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
name|emitSetup
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
comment|/*      *  There are four modes of option processing.      */
switch|switch
condition|(
name|pOpts
operator|->
name|fOptSet
operator|&
operator|(
name|OPTPROC_LONGOPT
operator||
name|OPTPROC_SHORTOPT
operator|)
condition|)
block|{
case|case
name|OPTPROC_LONGOPT
case|:
name|fputs
argument_list|(
name|zLoopCase
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zLongSelection
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zLongOptInit
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|emitLong
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|zLongOptArg
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zEndSelection
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zNoSelection
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|fputs
argument_list|(
name|zLoopOnly
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zLongOptInit
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|emitLong
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|zLongOptArg
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTPROC_SHORTOPT
case|:
name|fputs
argument_list|(
name|zLoopCase
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zFlagSelection
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zFlagOptInit
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|emitFlag
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|zFlagOptArg
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zEndSelection
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zNoSelection
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTPROC_LONGOPT
operator||
name|OPTPROC_SHORTOPT
case|:
name|fputs
argument_list|(
name|zLoopCase
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zLongSelection
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zLongOptInit
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|emitLong
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|zLongOptArg
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zEndSelection
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zFlagSelection
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zFlagOptInit
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|emitFlag
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|zFlagOptArg
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zEndSelection
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zNoSelection
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
name|zLoopEnd
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|zTrailerMarker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pzTrailer
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|pzTrailer
operator|!=
literal|'\0'
operator|)
condition|)
name|fputs
argument_list|(
name|pzTrailer
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ENABLED_GENSHELL_OPT
argument_list|(
name|SHELL
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\nenv | grep '^%s_'\n"
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fchmod
argument_list|(
name|STDOUT_FILENO
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
name|zOutputFail
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WORKING_FORK
end_ifdef

begin_function
specifier|static
name|void
name|emit_var_text
parameter_list|(
name|char
specifier|const
modifier|*
name|prog
parameter_list|,
name|char
specifier|const
modifier|*
name|var
parameter_list|,
name|int
name|fdin
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|fdopen
argument_list|(
name|fdin
argument_list|,
literal|"r"
name|FOPEN_BINARY_FLAG
argument_list|)
decl_stmt|;
name|int
name|nlct
init|=
literal|0
decl_stmt|;
comment|/* defer newlines and skip trailing ones */
name|printf
argument_list|(
literal|"%s_%s_TEXT='"
argument_list|,
name|prog
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
goto|goto
name|skip_text
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ch
init|=
name|fgetc
argument_list|(
name|fp
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\n'
case|:
name|nlct
operator|++
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
while|while
condition|(
name|nlct
operator|>
literal|0
condition|)
block|{
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|nlct
operator|--
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"'\\''"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOF
case|:
goto|goto
name|endCharLoop
goto|;
default|default:
while|while
condition|(
name|nlct
operator|>
literal|0
condition|)
block|{
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|nlct
operator|--
expr_stmt|;
block|}
name|fputc
argument_list|(
name|ch
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|endCharLoop
label|:
empty_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|skip_text
label|:
name|fputs
argument_list|(
literal|"'\n\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  The purpose of this function is to assign "long usage", short usage  *  and version information to a shell variable.  Rather than wind our  *  way through all the logic necessary to emit the text directly, we  *  fork(), have our child process emit the text the normal way and  *  capture the output in the parent process.  */
end_comment

begin_function
specifier|static
name|void
name|textToVariable
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|teTextTo
name|whichVar
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
block|{
define|#
directive|define
name|_TT_
parameter_list|(
name|n
parameter_list|)
value|static char const z ## n [] = #n;
name|TEXTTO_TABLE
undef|#
directive|undef
name|_TT_
define|#
directive|define
name|_TT_
parameter_list|(
name|n
parameter_list|)
value|z ## n ,
specifier|static
name|char
specifier|const
modifier|*
name|apzTTNames
index|[]
init|=
block|{
name|TEXTTO_TABLE
block|}
decl_stmt|;
undef|#
directive|undef
name|_TT_
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_WORKING_FORK
argument_list|)
name|printf
argument_list|(
literal|"%1$s_%2$s_TEXT='no %2$s text'\n"
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|apzTTNames
index|[
name|whichVar
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|pipeFd
index|[
literal|2
index|]
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pipeFd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zBadPipe
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zForkFail
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|pOpts
operator|->
name|pzProgName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/*          * Send both stderr and stdout to the pipe.  No matter which          * descriptor is used, we capture the output on the read end.          */
name|dup2
argument_list|(
name|pipeFd
index|[
literal|1
index|]
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|pipeFd
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipeFd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|whichVar
condition|)
block|{
case|case
name|TT_LONGUSAGE
case|:
operator|(
operator|*
operator|(
name|pOpts
operator|->
name|pUsageProc
operator|)
operator|)
operator|(
name|pOpts
operator|,
name|EXIT_SUCCESS
operator|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|TT_USAGE
case|:
operator|(
operator|*
operator|(
name|pOpts
operator|->
name|pUsageProc
operator|)
operator|)
operator|(
name|pOpts
operator|,
name|EXIT_FAILURE
operator|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|TT_VERSION
case|:
if|if
condition|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ALLOC_ARG
condition|)
block|{
name|AGFREE
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|pOD
operator|->
name|fOptState
operator|&=
operator|~
name|OPTST_ALLOC_ARG
expr_stmt|;
block|}
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|=
literal|"c"
expr_stmt|;
name|optionPrintVersion
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
default|default:
name|close
argument_list|(
name|pipeFd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|emit_var_text
argument_list|(
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|apzTTNames
index|[
name|whichVar
index|]
argument_list|,
name|pipeFd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|emitUsage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|char
name|zTimeBuf
index|[
name|AO_NAME_SIZE
index|]
decl_stmt|;
comment|/*      *  First, switch stdout to the output file name.      *  Then, change the program name to the one defined      *  by the definitions (rather than the current      *  executable name).  Down case the upper cased name.      */
if|if
condition|(
name|pzLeader
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|pzLeader
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|{
name|tSCC
name|zStdout
index|[]
init|=
literal|"stdout"
decl_stmt|;
name|tCC
modifier|*
name|pzOutName
decl_stmt|;
block|{
name|time_t
name|curTime
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|tm
modifier|*
name|pTime
init|=
name|localtime
argument_list|(
operator|&
name|curTime
argument_list|)
decl_stmt|;
name|strftime
argument_list|(
name|zTimeBuf
argument_list|,
name|AO_NAME_SIZE
argument_list|,
literal|"%A %B %e, %Y at %r %Z"
argument_list|,
name|pTime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HAVE_GENSHELL_OPT
argument_list|(
name|SCRIPT
argument_list|)
condition|)
name|pzOutName
operator|=
name|GENSHELL_OPT_ARG
argument_list|(
name|SCRIPT
argument_list|)
expr_stmt|;
else|else
name|pzOutName
operator|=
name|zStdout
expr_stmt|;
if|if
condition|(
operator|(
name|pzLeader
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|pzShell
operator|!=
name|NULL
operator|)
condition|)
name|printf
argument_list|(
literal|"#! %s\n"
argument_list|,
name|pzShell
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|zPreamble
argument_list|,
name|zStartMarker
argument_list|,
name|pzOutName
argument_list|,
name|zTimeBuf
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|zEndPreamble
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
comment|/*      *  Get a copy of the original program name in lower case and      *  fill in an approximation of the program name from it.      */
block|{
name|char
modifier|*
name|pzPN
init|=
name|zTimeBuf
decl_stmt|;
name|char
specifier|const
modifier|*
name|pz
init|=
name|pOpts
operator|->
name|pzPROGNAME
decl_stmt|;
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|pzPN
operator|++
operator|=
name|tolower
argument_list|(
operator|*
name|pz
operator|++
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
break|break;
block|}
name|pp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|pOpts
operator|->
name|pzProgPath
operator|)
expr_stmt|;
operator|*
name|pp
operator|=
name|zTimeBuf
expr_stmt|;
name|pp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|pOpts
operator|->
name|pzProgName
operator|)
expr_stmt|;
operator|*
name|pp
operator|=
name|zTimeBuf
expr_stmt|;
block|}
name|textToVariable
argument_list|(
name|pOpts
argument_list|,
name|TT_LONGUSAGE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|textToVariable
argument_list|(
name|pOpts
argument_list|,
name|TT_USAGE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|{
name|tOptDesc
modifier|*
name|pOptDesc
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|optionCt
init|=
name|pOpts
operator|->
name|optCt
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pOptDesc
operator|->
name|pOptProc
operator|==
name|optionPrintVersion
condition|)
block|{
name|textToVariable
argument_list|(
name|pOpts
argument_list|,
name|TT_VERSION
argument_list|,
name|pOptDesc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|--
name|optionCt
operator|<=
literal|0
condition|)
break|break;
name|pOptDesc
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|emitSetup
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|pOptDesc
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|optionCt
init|=
name|pOpts
operator|->
name|presetOptCt
decl_stmt|;
name|char
specifier|const
modifier|*
name|pzFmt
decl_stmt|;
name|char
specifier|const
modifier|*
name|pzDefault
decl_stmt|;
for|for
control|(
init|;
name|optionCt
operator|>
literal|0
condition|;
name|pOptDesc
operator|++
operator|,
operator|--
name|optionCt
control|)
block|{
name|char
name|zVal
index|[
literal|16
index|]
decl_stmt|;
comment|/*          *  Options that are either usage documentation or are compiled out          *  are not to be processed.          */
if|if
condition|(
name|SKIP_OPT
argument_list|(
name|pOptDesc
argument_list|)
operator|||
operator|(
name|pOptDesc
operator|->
name|pz_NAME
operator|==
name|NULL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|pOptDesc
operator|->
name|optMaxCt
operator|>
literal|1
condition|)
name|pzFmt
operator|=
name|zMultiDef
expr_stmt|;
else|else
name|pzFmt
operator|=
name|zSingleDef
expr_stmt|;
comment|/*          *  IF this is an enumeration/bitmask option, then convert the value          *  to a string before printing the default value.          */
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOptDesc
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_ENUMERATION
case|:
operator|(
operator|*
operator|(
name|pOptDesc
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|OPTPROC_EMIT_SHELL
operator|,
name|pOptDesc
operator|)
expr_stmt|;
name|pzDefault
operator|=
name|pOptDesc
operator|->
name|optArg
operator|.
name|argString
expr_stmt|;
break|break;
comment|/*          *  Numeric and membership bit options are just printed as a number.          */
case|case
name|OPARG_TYPE_NUMERIC
case|:
name|snprintf
argument_list|(
name|zVal
argument_list|,
sizeof|sizeof
argument_list|(
name|zVal
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|pOptDesc
operator|->
name|optArg
operator|.
name|argInt
argument_list|)
expr_stmt|;
name|pzDefault
operator|=
name|zVal
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_MEMBERSHIP
case|:
name|snprintf
argument_list|(
name|zVal
argument_list|,
sizeof|sizeof
argument_list|(
name|zVal
argument_list|)
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pOptDesc
operator|->
name|optArg
operator|.
name|argIntptr
argument_list|)
expr_stmt|;
name|pzDefault
operator|=
name|zVal
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_BOOLEAN
case|:
name|pzDefault
operator|=
operator|(
name|pOptDesc
operator|->
name|optArg
operator|.
name|argBool
operator|)
condition|?
literal|"true"
else|:
literal|"false"
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|pOptDesc
operator|->
name|optArg
operator|.
name|argString
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|pzFmt
operator|==
name|zSingleDef
condition|)
name|pzFmt
operator|=
name|zSingleNoDef
expr_stmt|;
name|pzDefault
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|pzDefault
operator|=
name|pOptDesc
operator|->
name|optArg
operator|.
name|argString
expr_stmt|;
block|}
name|printf
argument_list|(
name|pzFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOptDesc
operator|->
name|pz_NAME
argument_list|,
name|pzDefault
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|printOptionAction
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOptDesc
parameter_list|)
block|{
if|if
condition|(
name|pOptDesc
operator|->
name|pOptProc
operator|==
name|optionPrintVersion
condition|)
name|printf
argument_list|(
name|zTextExit
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
literal|"VERSION"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pOptDesc
operator|->
name|pOptProc
operator|==
name|optionPagedUsage
condition|)
name|printf
argument_list|(
name|zPagedUsageExit
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pOptDesc
operator|->
name|pOptProc
operator|==
name|optionLoadOpt
condition|)
block|{
name|printf
argument_list|(
name|zCmdFmt
argument_list|,
literal|"echo 'Warning:  Cannot load options files'>&2"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|zCmdFmt
argument_list|,
literal|"OPT_ARG_NEEDED=YES"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pOptDesc
operator|->
name|pz_NAME
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|pOptDesc
operator|->
name|pOptProc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
name|zCmdFmt
argument_list|,
literal|"echo 'Warning:  Cannot save options files' "
literal|">&2"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|zCmdFmt
argument_list|,
literal|"OPT_ARG_NEEDED=OK"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
name|zTextExit
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
literal|"LONGUSAGE"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pOptDesc
operator|->
name|optMaxCt
operator|==
literal|1
condition|)
name|printf
argument_list|(
name|zSingleArg
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOptDesc
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|unsigned
operator|)
name|pOptDesc
operator|->
name|optMaxCt
operator|<
name|NOLIMIT
condition|)
name|printf
argument_list|(
name|zCountTest
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOptDesc
operator|->
name|pz_NAME
argument_list|,
name|pOptDesc
operator|->
name|optMaxCt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|zMultiArg
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOptDesc
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
block|}
comment|/*          *  Fix up the args.          */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOptDesc
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_NONE
condition|)
block|{
name|printf
argument_list|(
name|zCantArg
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOptDesc
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pOptDesc
operator|->
name|fOptState
operator|&
name|OPTST_ARG_OPTIONAL
condition|)
block|{
name|printf
argument_list|(
name|zMayArg
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOptDesc
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
name|zMustArg
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
name|zOptionEndSelect
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|printOptionInaction
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOptDesc
parameter_list|)
block|{
if|if
condition|(
name|pOptDesc
operator|->
name|pOptProc
operator|==
name|optionLoadOpt
condition|)
block|{
name|printf
argument_list|(
name|zCmdFmt
argument_list|,
literal|"echo 'Warning:  Cannot suppress the loading of "
literal|"options files'>&2"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pOptDesc
operator|->
name|optMaxCt
operator|==
literal|1
condition|)
name|printf
argument_list|(
name|zNoSingleArg
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOptDesc
operator|->
name|pz_NAME
argument_list|,
name|pOptDesc
operator|->
name|pz_DisablePfx
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|zNoMultiArg
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOptDesc
operator|->
name|pz_NAME
argument_list|,
name|pOptDesc
operator|->
name|pz_DisablePfx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|zCmdFmt
argument_list|,
literal|"OPT_ARG_NEEDED=NO"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zOptionEndSelect
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emitFlag
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|pOptDesc
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|optionCt
init|=
name|pOpts
operator|->
name|optCt
decl_stmt|;
name|fputs
argument_list|(
name|zOptionCase
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|optionCt
operator|>
literal|0
condition|;
name|pOptDesc
operator|++
operator|,
operator|--
name|optionCt
control|)
block|{
if|if
condition|(
name|SKIP_OPT
argument_list|(
name|pOptDesc
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|IS_GRAPHIC_CHAR
argument_list|(
name|pOptDesc
operator|->
name|optValue
argument_list|)
condition|)
block|{
name|printf
argument_list|(
name|zOptionFlag
argument_list|,
name|pOptDesc
operator|->
name|optValue
argument_list|)
expr_stmt|;
name|printOptionAction
argument_list|(
name|pOpts
argument_list|,
name|pOptDesc
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
name|zOptionUnknown
argument_list|,
literal|"flag"
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Emit the match text for a long option  */
end_comment

begin_function
specifier|static
name|void
name|emitMatchExpr
parameter_list|(
name|tCC
modifier|*
name|pzMatchName
parameter_list|,
name|tOptDesc
modifier|*
name|pCurOpt
parameter_list|,
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|oCt
init|=
name|pOpts
operator|->
name|optCt
decl_stmt|;
name|int
name|min
init|=
literal|1
decl_stmt|;
name|char
name|zName
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|pz
init|=
name|zName
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|matchCt
init|=
literal|0
decl_stmt|;
comment|/*          *  Omit the current option, Documentation opts and compiled out opts.          */
if|if
condition|(
operator|(
name|pOD
operator|==
name|pCurOpt
operator|)
operator|||
name|SKIP_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
block|{
if|if
condition|(
operator|--
name|oCt
operator|<=
literal|0
condition|)
break|break;
name|pOD
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/*          *  Check each character of the name case insensitively.          *  They must not be the same.  They cannot be, because it would          *  not compile correctly if they were.          */
while|while
condition|(
name|toupper
argument_list|(
name|pOD
operator|->
name|pz_Name
index|[
name|matchCt
index|]
argument_list|)
operator|==
name|toupper
argument_list|(
name|pzMatchName
index|[
name|matchCt
index|]
argument_list|)
condition|)
name|matchCt
operator|++
expr_stmt|;
if|if
condition|(
name|matchCt
operator|>
name|min
condition|)
name|min
operator|=
name|matchCt
expr_stmt|;
comment|/*          *  Check the disablement name, too.          */
if|if
condition|(
name|pOD
operator|->
name|pz_DisableName
operator|!=
name|NULL
condition|)
block|{
name|matchCt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|toupper
argument_list|(
name|pOD
operator|->
name|pz_DisableName
index|[
name|matchCt
index|]
argument_list|)
operator|==
name|toupper
argument_list|(
name|pzMatchName
index|[
name|matchCt
index|]
argument_list|)
condition|)
name|matchCt
operator|++
expr_stmt|;
if|if
condition|(
name|matchCt
operator|>
name|min
condition|)
name|min
operator|=
name|matchCt
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|oCt
operator|<=
literal|0
condition|)
break|break;
name|pOD
operator|++
expr_stmt|;
block|}
comment|/*      *  IF the 'min' is all or one short of the name length,      *  THEN the entire string must be matched.      */
if|if
condition|(
operator|(
name|pzMatchName
index|[
name|min
index|]
operator|==
name|NUL
operator|)
operator|||
operator|(
name|pzMatchName
index|[
name|min
operator|+
literal|1
index|]
operator|==
name|NUL
operator|)
condition|)
name|printf
argument_list|(
name|zOptionFullName
argument_list|,
name|pzMatchName
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|matchCt
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|matchCt
operator|<=
name|min
condition|;
name|matchCt
operator|++
control|)
operator|*
name|pz
operator|++
operator|=
name|pzMatchName
index|[
name|matchCt
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|pz
operator|=
name|NUL
expr_stmt|;
name|printf
argument_list|(
name|zOptionPartName
argument_list|,
name|zName
argument_list|)
expr_stmt|;
operator|*
name|pz
operator|++
operator|=
name|pzMatchName
index|[
name|matchCt
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|pzMatchName
index|[
name|matchCt
index|]
operator|==
name|NUL
condition|)
block|{
operator|*
name|pz
operator|=
name|NUL
expr_stmt|;
name|printf
argument_list|(
name|zOptionFullName
argument_list|,
name|zName
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *  Emit GNU-standard long option handling code  */
end_comment

begin_function
specifier|static
name|void
name|emitLong
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|ct
init|=
name|pOpts
operator|->
name|optCt
decl_stmt|;
name|fputs
argument_list|(
name|zOptionCase
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/*      *  do each option, ...      */
do|do
block|{
comment|/*          *  Documentation& compiled-out options          */
if|if
condition|(
name|SKIP_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
continue|continue;
name|emitMatchExpr
argument_list|(
name|pOD
operator|->
name|pz_Name
argument_list|,
name|pOD
argument_list|,
name|pOpts
argument_list|)
expr_stmt|;
name|printOptionAction
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|)
expr_stmt|;
comment|/*          *  Now, do the same thing for the disablement version of the option.          */
if|if
condition|(
name|pOD
operator|->
name|pz_DisableName
operator|!=
name|NULL
condition|)
block|{
name|emitMatchExpr
argument_list|(
name|pOD
operator|->
name|pz_DisableName
argument_list|,
name|pOD
argument_list|,
name|pOpts
argument_list|)
expr_stmt|;
name|printOptionInaction
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|pOD
operator|++
operator|,
operator|--
name|ct
operator|>
literal|0
condition|)
do|;
name|printf
argument_list|(
name|zOptionUnknown
argument_list|,
literal|"option"
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|openOutput
parameter_list|(
name|char
specifier|const
modifier|*
name|pzFile
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|pzData
init|=
name|NULL
decl_stmt|;
name|struct
name|stat
name|stbf
decl_stmt|;
do|do
block|{
name|char
modifier|*
name|pzScan
decl_stmt|;
name|size_t
name|sizeLeft
decl_stmt|;
comment|/*          *  IF we cannot stat the file,          *  THEN assume we are creating a new file.          *       Skip the loading of the old data.          */
if|if
condition|(
name|stat
argument_list|(
name|pzFile
argument_list|,
operator|&
name|stbf
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/*          *  The file must be a regular file          */
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|stbf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zNotFile
argument_list|,
name|pzFile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|pzData
operator|=
name|AGALOC
argument_list|(
name|stbf
operator|.
name|st_size
operator|+
literal|1
argument_list|,
literal|"file data"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|pzFile
argument_list|,
literal|"r"
name|FOPEN_BINARY_FLAG
argument_list|)
expr_stmt|;
name|sizeLeft
operator|=
operator|(
name|unsigned
operator|)
name|stbf
operator|.
name|st_size
expr_stmt|;
name|pzScan
operator|=
name|pzData
expr_stmt|;
comment|/*          *  Read in all the data as fast as our OS will let us.          */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|inct
init|=
name|fread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pzScan
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|sizeLeft
argument_list|,
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|inct
operator|==
literal|0
condition|)
break|break;
name|pzScan
operator|+=
name|inct
expr_stmt|;
name|sizeLeft
operator|-=
name|inct
expr_stmt|;
if|if
condition|(
name|sizeLeft
operator|==
literal|0
condition|)
break|break;
block|}
comment|/*          *  NUL-terminate the leader and look for the trailer          */
operator|*
name|pzScan
operator|=
literal|'\0'
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|pzScan
operator|=
name|strstr
argument_list|(
name|pzData
argument_list|,
name|zStartMarker
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzScan
operator|==
name|NULL
condition|)
block|{
name|pzTrailer
operator|=
name|pzData
expr_stmt|;
break|break;
block|}
operator|*
operator|(
name|pzScan
operator|++
operator|)
operator|=
name|NUL
expr_stmt|;
name|pzScan
operator|=
name|strstr
argument_list|(
name|pzScan
argument_list|,
name|zTrailerMarker
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzScan
operator|==
name|NULL
condition|)
block|{
name|pzTrailer
operator|=
name|pzData
expr_stmt|;
break|break;
block|}
comment|/*          *  Check to see if the data contains our marker.          *  If it does, then we will skip over it          */
name|pzTrailer
operator|=
name|pzScan
operator|+
sizeof|sizeof
argument_list|(
name|zTrailerMarker
argument_list|)
operator|-
literal|1
expr_stmt|;
name|pzLeader
operator|=
name|pzData
expr_stmt|;
block|}
do|while
condition|(
name|AG_FALSE
condition|)
do|;
if|if
condition|(
name|freopen
argument_list|(
name|pzFile
argument_list|,
literal|"w"
name|FOPEN_BINARY_FLAG
argument_list|,
name|stdout
argument_list|)
operator|!=
name|stdout
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zFreopenFail
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*=export_func genshelloptUsage  * private:  * what: The usage function for the genshellopt generated program  *  * arg:  + tOptions* + pOpts    + program options descriptor +  * arg:  + int       + exitCode + usage text type to produce +  *  * doc:  *  This function is used to create the usage strings for the option  *  processing shell script code.  Two child processes are spawned  *  each emitting the usage text in either the short (error exit)  *  style or the long style.  The generated program will capture this  *  and create shell script variables containing the two types of text. =*/
end_comment

begin_function
name|void
name|genshelloptUsage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|int
name|exitCode
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_WORKING_FORK
argument_list|)
name|optionUsage
argument_list|(
name|pOpts
argument_list|,
name|exitCode
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/*      *  IF not EXIT_SUCCESS,      *  THEN emit the short form of usage.      */
if|if
condition|(
name|exitCode
operator|!=
name|EXIT_SUCCESS
condition|)
name|optionUsage
argument_list|(
name|pOpts
argument_list|,
name|exitCode
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|ferror
argument_list|(
name|stderr
argument_list|)
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|option_usage_fp
operator|=
name|stdout
expr_stmt|;
comment|/*      *  First, print our usage      */
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|optionUsage
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|0
case|:
name|pagerState
operator|=
name|PAGER_STATE_CHILD
expr_stmt|;
name|optionUsage
argument_list|(
name|pOpts
argument_list|,
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
default|default:
block|{
name|int
name|sts
decl_stmt|;
name|wait
argument_list|(
operator|&
name|sts
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      *  Generate the pzProgName, since optionProcess() normally      *  gets it from the command line      */
block|{
name|char
modifier|*
name|pz
decl_stmt|;
name|char
modifier|*
modifier|*
name|pp
init|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|optionParseShellOptions
operator|->
name|pzProgName
operator|)
decl_stmt|;
name|AGDUPSTR
argument_list|(
name|pz
argument_list|,
name|optionParseShellOptions
operator|->
name|pzPROGNAME
argument_list|,
literal|"program name"
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|pz
expr_stmt|;
while|while
condition|(
operator|*
name|pz
operator|!=
name|NUL
condition|)
block|{
operator|*
name|pz
operator|=
name|tolower
argument_list|(
operator|*
name|pz
argument_list|)
expr_stmt|;
name|pz
operator|++
expr_stmt|;
block|}
block|}
comment|/*      *  Separate the makeshell usage from the client usage      */
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zGenshell
argument_list|,
name|optionParseShellOptions
operator|->
name|pzProgName
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*      *  Now, print the client usage.      */
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
name|pagerState
operator|=
name|PAGER_STATE_CHILD
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
operator|-
literal|1
case|:
name|optionUsage
argument_list|(
name|optionParseShellOptions
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
default|default:
block|{
name|int
name|sts
decl_stmt|;
name|wait
argument_list|(
operator|&
name|sts
argument_list|)
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
name|zOutputFail
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/makeshell.c */
end_comment

end_unit

