begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convenience header for conditional use of GNU<libintl.h>.    Copyright (C) 1995-1998, 2000-2002, 2004-2006, 2009-2014 Free Software    Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU Lesser General Public License as published by    the Free Software Foundation; either version 2.1, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public License along    with this program; if not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBGETTEXT_H
end_ifndef

begin_define
define|#
directive|define
name|_LIBGETTEXT_H
value|1
end_define

begin_comment
comment|/* NLS can be disabled through the configure --disable-nls option.  */
end_comment

begin_if
if|#
directive|if
name|ENABLE_NLS
end_if

begin_comment
comment|/* Get declarations of GNU message catalog functions.  */
end_comment

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_comment
comment|/* You can set the DEFAULT_TEXT_DOMAIN macro to specify the domain used by    the gettext() and ngettext() macros.  This is an alternative to calling    textdomain(), and is useful for libraries.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEFAULT_TEXT_DOMAIN
end_ifdef

begin_undef
undef|#
directive|undef
name|gettext
end_undef

begin_define
define|#
directive|define
name|gettext
parameter_list|(
name|Msgid
parameter_list|)
define|\
value|dgettext (DEFAULT_TEXT_DOMAIN, Msgid)
end_define

begin_undef
undef|#
directive|undef
name|ngettext
end_undef

begin_define
define|#
directive|define
name|ngettext
parameter_list|(
name|Msgid1
parameter_list|,
name|Msgid2
parameter_list|,
name|N
parameter_list|)
define|\
value|dngettext (DEFAULT_TEXT_DOMAIN, Msgid1, Msgid2, N)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Solaris /usr/include/locale.h includes /usr/include/libintl.h, which    chokes if dcgettext is defined as a macro.  So include it now, to make    later inclusions of<locale.h> a NOP.  We don't include<libintl.h>    as well because people using "gettext.h" will not include<libintl.h>,    and also including<libintl.h> would fail on SunOS 4, whereas<locale.h>    is OK.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Many header files from the libstdc++ coming with g++ 3.3 or newer include<libintl.h>, which chokes if dcgettext is defined as a macro.  So include    it now, to make later inclusions of<libintl.h> a NOP.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|&&
name|defined
argument_list|(
name|__GNUG__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>=
literal|3
operator|)
end_if

begin_include
include|#
directive|include
file|<cstdlib>
end_include

begin_if
if|#
directive|if
operator|(
name|__GLIBC__
operator|>=
literal|2
operator|&&
operator|!
name|defined
name|__UCLIBC__
operator|)
operator|||
name|_GLIBCXX_HAVE_LIBINTL_H
end_if

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Disabled NLS.    The casts to 'const char *' serve the purpose of producing warnings    for invalid uses of the value returned from these functions.    On pre-ANSI systems without 'const', the config.h file is supposed to    contain "#define const".  */
end_comment

begin_undef
undef|#
directive|undef
name|gettext
end_undef

begin_define
define|#
directive|define
name|gettext
parameter_list|(
name|Msgid
parameter_list|)
value|((const char *) (Msgid))
end_define

begin_undef
undef|#
directive|undef
name|dgettext
end_undef

begin_define
define|#
directive|define
name|dgettext
parameter_list|(
name|Domainname
parameter_list|,
name|Msgid
parameter_list|)
value|((void) (Domainname), gettext (Msgid))
end_define

begin_undef
undef|#
directive|undef
name|dcgettext
end_undef

begin_define
define|#
directive|define
name|dcgettext
parameter_list|(
name|Domainname
parameter_list|,
name|Msgid
parameter_list|,
name|Category
parameter_list|)
define|\
value|((void) (Category), dgettext (Domainname, Msgid))
end_define

begin_undef
undef|#
directive|undef
name|ngettext
end_undef

begin_define
define|#
directive|define
name|ngettext
parameter_list|(
name|Msgid1
parameter_list|,
name|Msgid2
parameter_list|,
name|N
parameter_list|)
define|\
value|((N) == 1 \      ? ((void) (Msgid2), (const char *) (Msgid1)) \      : ((void) (Msgid1), (const char *) (Msgid2)))
end_define

begin_undef
undef|#
directive|undef
name|dngettext
end_undef

begin_define
define|#
directive|define
name|dngettext
parameter_list|(
name|Domainname
parameter_list|,
name|Msgid1
parameter_list|,
name|Msgid2
parameter_list|,
name|N
parameter_list|)
define|\
value|((void) (Domainname), ngettext (Msgid1, Msgid2, N))
end_define

begin_undef
undef|#
directive|undef
name|dcngettext
end_undef

begin_define
define|#
directive|define
name|dcngettext
parameter_list|(
name|Domainname
parameter_list|,
name|Msgid1
parameter_list|,
name|Msgid2
parameter_list|,
name|N
parameter_list|,
name|Category
parameter_list|)
define|\
value|((void) (Category), dngettext (Domainname, Msgid1, Msgid2, N))
end_define

begin_undef
undef|#
directive|undef
name|textdomain
end_undef

begin_define
define|#
directive|define
name|textdomain
parameter_list|(
name|Domainname
parameter_list|)
value|((const char *) (Domainname))
end_define

begin_undef
undef|#
directive|undef
name|bindtextdomain
end_undef

begin_define
define|#
directive|define
name|bindtextdomain
parameter_list|(
name|Domainname
parameter_list|,
name|Dirname
parameter_list|)
define|\
value|((void) (Domainname), (const char *) (Dirname))
end_define

begin_undef
undef|#
directive|undef
name|bind_textdomain_codeset
end_undef

begin_define
define|#
directive|define
name|bind_textdomain_codeset
parameter_list|(
name|Domainname
parameter_list|,
name|Codeset
parameter_list|)
define|\
value|((void) (Domainname), (const char *) (Codeset))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Prefer gnulib's setlocale override over libintl's setlocale override.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GNULIB_defined_setlocale
end_ifdef

begin_undef
undef|#
directive|undef
name|setlocale
end_undef

begin_define
define|#
directive|define
name|setlocale
value|rpl_setlocale
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A pseudo function call that serves as a marker for the automated    extraction of messages, but does not call gettext().  The run-time    translation is done at a different place in the code.    The argument, String, should be a literal string.  Concatenated strings    and other string expressions won't work.    The macro's expansion is not parenthesized, so that it is suitable as    initializer for static 'char[]' or 'const char[]' variables.  */
end_comment

begin_define
define|#
directive|define
name|gettext_noop
parameter_list|(
name|String
parameter_list|)
value|String
end_define

begin_comment
comment|/* The separator between msgctxt and msgid in a .mo file.  */
end_comment

begin_define
define|#
directive|define
name|GETTEXT_CONTEXT_GLUE
value|"\004"
end_define

begin_comment
comment|/* Pseudo function calls, taking a MSGCTXT and a MSGID instead of just a    MSGID.  MSGCTXT and MSGID must be string literals.  MSGCTXT should be    short and rarely need to change.    The letter 'p' stands for 'particular' or 'special'.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEFAULT_TEXT_DOMAIN
end_ifdef

begin_define
define|#
directive|define
name|pgettext
parameter_list|(
name|Msgctxt
parameter_list|,
name|Msgid
parameter_list|)
define|\
value|pgettext_aux (DEFAULT_TEXT_DOMAIN, Msgctxt GETTEXT_CONTEXT_GLUE Msgid, Msgid, LC_MESSAGES)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|pgettext
parameter_list|(
name|Msgctxt
parameter_list|,
name|Msgid
parameter_list|)
define|\
value|pgettext_aux (NULL, Msgctxt GETTEXT_CONTEXT_GLUE Msgid, Msgid, LC_MESSAGES)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|dpgettext
parameter_list|(
name|Domainname
parameter_list|,
name|Msgctxt
parameter_list|,
name|Msgid
parameter_list|)
define|\
value|pgettext_aux (Domainname, Msgctxt GETTEXT_CONTEXT_GLUE Msgid, Msgid, LC_MESSAGES)
end_define

begin_define
define|#
directive|define
name|dcpgettext
parameter_list|(
name|Domainname
parameter_list|,
name|Msgctxt
parameter_list|,
name|Msgid
parameter_list|,
name|Category
parameter_list|)
define|\
value|pgettext_aux (Domainname, Msgctxt GETTEXT_CONTEXT_GLUE Msgid, Msgid, Category)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEFAULT_TEXT_DOMAIN
end_ifdef

begin_define
define|#
directive|define
name|npgettext
parameter_list|(
name|Msgctxt
parameter_list|,
name|Msgid
parameter_list|,
name|MsgidPlural
parameter_list|,
name|N
parameter_list|)
define|\
value|npgettext_aux (DEFAULT_TEXT_DOMAIN, Msgctxt GETTEXT_CONTEXT_GLUE Msgid, Msgid, MsgidPlural, N, LC_MESSAGES)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|npgettext
parameter_list|(
name|Msgctxt
parameter_list|,
name|Msgid
parameter_list|,
name|MsgidPlural
parameter_list|,
name|N
parameter_list|)
define|\
value|npgettext_aux (NULL, Msgctxt GETTEXT_CONTEXT_GLUE Msgid, Msgid, MsgidPlural, N, LC_MESSAGES)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|dnpgettext
parameter_list|(
name|Domainname
parameter_list|,
name|Msgctxt
parameter_list|,
name|Msgid
parameter_list|,
name|MsgidPlural
parameter_list|,
name|N
parameter_list|)
define|\
value|npgettext_aux (Domainname, Msgctxt GETTEXT_CONTEXT_GLUE Msgid, Msgid, MsgidPlural, N, LC_MESSAGES)
end_define

begin_define
define|#
directive|define
name|dcnpgettext
parameter_list|(
name|Domainname
parameter_list|,
name|Msgctxt
parameter_list|,
name|Msgid
parameter_list|,
name|MsgidPlural
parameter_list|,
name|N
parameter_list|,
name|Category
parameter_list|)
define|\
value|npgettext_aux (Domainname, Msgctxt GETTEXT_CONTEXT_GLUE Msgid, Msgid, MsgidPlural, N, Category)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
name|__inline
else|#
directive|else
ifdef|#
directive|ifdef
name|__cplusplus
specifier|inline
endif|#
directive|endif
endif|#
directive|endif
specifier|static
specifier|const
name|char
modifier|*
name|pgettext_aux
parameter_list|(
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
specifier|const
name|char
modifier|*
name|msg_ctxt_id
parameter_list|,
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
name|int
name|category
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|translation
init|=
name|dcgettext
argument_list|(
name|domain
argument_list|,
name|msg_ctxt_id
argument_list|,
name|category
argument_list|)
decl_stmt|;
if|if
condition|(
name|translation
operator|==
name|msg_ctxt_id
condition|)
return|return
name|msgid
return|;
else|else
return|return
name|translation
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
name|__inline
else|#
directive|else
ifdef|#
directive|ifdef
name|__cplusplus
specifier|inline
endif|#
directive|endif
endif|#
directive|endif
specifier|static
specifier|const
name|char
modifier|*
name|npgettext_aux
parameter_list|(
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
specifier|const
name|char
modifier|*
name|msg_ctxt_id
parameter_list|,
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
specifier|const
name|char
modifier|*
name|msgid_plural
parameter_list|,
name|unsigned
name|long
name|int
name|n
parameter_list|,
name|int
name|category
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|translation
init|=
name|dcngettext
argument_list|(
name|domain
argument_list|,
name|msg_ctxt_id
argument_list|,
name|msgid_plural
argument_list|,
name|n
argument_list|,
name|category
argument_list|)
decl_stmt|;
if|if
condition|(
name|translation
operator|==
name|msg_ctxt_id
operator|||
name|translation
operator|==
name|msgid_plural
condition|)
return|return
operator|(
name|n
operator|==
literal|1
condition|?
name|msgid
else|:
name|msgid_plural
operator|)
return|;
else|else
return|return
name|translation
return|;
block|}
end_function

begin_comment
comment|/* The same thing extended for non-constant arguments.  Here MSGCTXT and MSGID    can be arbitrary expressions.  But for string literals these macros are    less efficient than those above.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
operator|(
operator|(
operator|(
name|__GNUC__
operator|>=
literal|3
operator|||
name|__GNUG__
operator|>=
literal|2
operator|)
operator|&&
operator|!
name|defined
name|__STRICT_ANSI__
operator|)
expr|\
comment|/* || __STDC_VERSION__>= 199901L */
operator|)
end_if

begin_define
define|#
directive|define
name|_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|pgettext_expr
parameter_list|(
name|Msgctxt
parameter_list|,
name|Msgid
parameter_list|)
define|\
value|dcpgettext_expr (NULL, Msgctxt, Msgid, LC_MESSAGES)
end_define

begin_define
define|#
directive|define
name|dpgettext_expr
parameter_list|(
name|Domainname
parameter_list|,
name|Msgctxt
parameter_list|,
name|Msgid
parameter_list|)
define|\
value|dcpgettext_expr (Domainname, Msgctxt, Msgid, LC_MESSAGES)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
name|__inline
else|#
directive|else
ifdef|#
directive|ifdef
name|__cplusplus
specifier|inline
endif|#
directive|endif
endif|#
directive|endif
specifier|static
specifier|const
name|char
modifier|*
name|dcpgettext_expr
parameter_list|(
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
specifier|const
name|char
modifier|*
name|msgctxt
parameter_list|,
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
name|int
name|category
parameter_list|)
block|{
name|size_t
name|msgctxt_len
init|=
name|strlen
argument_list|(
name|msgctxt
argument_list|)
operator|+
literal|1
decl_stmt|;
name|size_t
name|msgid_len
init|=
name|strlen
argument_list|(
name|msgid
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|translation
decl_stmt|;
if|#
directive|if
name|_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
name|char
name|msg_ctxt_id
index|[
name|msgctxt_len
operator|+
name|msgid_len
index|]
decl_stmt|;
else|#
directive|else
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|msg_ctxt_id
init|=
operator|(
name|msgctxt_len
operator|+
name|msgid_len
operator|<=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|?
name|buf
else|:
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|msgctxt_len
operator|+
name|msgid_len
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|msg_ctxt_id
operator|!=
name|NULL
condition|)
endif|#
directive|endif
block|{
name|memcpy
argument_list|(
name|msg_ctxt_id
argument_list|,
name|msgctxt
argument_list|,
name|msgctxt_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|msg_ctxt_id
index|[
name|msgctxt_len
operator|-
literal|1
index|]
operator|=
literal|'\004'
expr_stmt|;
name|memcpy
argument_list|(
name|msg_ctxt_id
operator|+
name|msgctxt_len
argument_list|,
name|msgid
argument_list|,
name|msgid_len
argument_list|)
expr_stmt|;
name|translation
operator|=
name|dcgettext
argument_list|(
name|domain
argument_list|,
name|msg_ctxt_id
argument_list|,
name|category
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
if|if
condition|(
name|msg_ctxt_id
operator|!=
name|buf
condition|)
name|free
argument_list|(
name|msg_ctxt_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|translation
operator|!=
name|msg_ctxt_id
condition|)
return|return
name|translation
return|;
block|}
return|return
name|msgid
return|;
block|}
end_function

begin_define
define|#
directive|define
name|npgettext_expr
parameter_list|(
name|Msgctxt
parameter_list|,
name|Msgid
parameter_list|,
name|MsgidPlural
parameter_list|,
name|N
parameter_list|)
define|\
value|dcnpgettext_expr (NULL, Msgctxt, Msgid, MsgidPlural, N, LC_MESSAGES)
end_define

begin_define
define|#
directive|define
name|dnpgettext_expr
parameter_list|(
name|Domainname
parameter_list|,
name|Msgctxt
parameter_list|,
name|Msgid
parameter_list|,
name|MsgidPlural
parameter_list|,
name|N
parameter_list|)
define|\
value|dcnpgettext_expr (Domainname, Msgctxt, Msgid, MsgidPlural, N, LC_MESSAGES)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
name|__inline
else|#
directive|else
ifdef|#
directive|ifdef
name|__cplusplus
specifier|inline
endif|#
directive|endif
endif|#
directive|endif
specifier|static
specifier|const
name|char
modifier|*
name|dcnpgettext_expr
parameter_list|(
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
specifier|const
name|char
modifier|*
name|msgctxt
parameter_list|,
specifier|const
name|char
modifier|*
name|msgid
parameter_list|,
specifier|const
name|char
modifier|*
name|msgid_plural
parameter_list|,
name|unsigned
name|long
name|int
name|n
parameter_list|,
name|int
name|category
parameter_list|)
block|{
name|size_t
name|msgctxt_len
init|=
name|strlen
argument_list|(
name|msgctxt
argument_list|)
operator|+
literal|1
decl_stmt|;
name|size_t
name|msgid_len
init|=
name|strlen
argument_list|(
name|msgid
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|translation
decl_stmt|;
if|#
directive|if
name|_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
name|char
name|msg_ctxt_id
index|[
name|msgctxt_len
operator|+
name|msgid_len
index|]
decl_stmt|;
else|#
directive|else
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|msg_ctxt_id
init|=
operator|(
name|msgctxt_len
operator|+
name|msgid_len
operator|<=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|?
name|buf
else|:
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|msgctxt_len
operator|+
name|msgid_len
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|msg_ctxt_id
operator|!=
name|NULL
condition|)
endif|#
directive|endif
block|{
name|memcpy
argument_list|(
name|msg_ctxt_id
argument_list|,
name|msgctxt
argument_list|,
name|msgctxt_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|msg_ctxt_id
index|[
name|msgctxt_len
operator|-
literal|1
index|]
operator|=
literal|'\004'
expr_stmt|;
name|memcpy
argument_list|(
name|msg_ctxt_id
operator|+
name|msgctxt_len
argument_list|,
name|msgid
argument_list|,
name|msgid_len
argument_list|)
expr_stmt|;
name|translation
operator|=
name|dcngettext
argument_list|(
name|domain
argument_list|,
name|msg_ctxt_id
argument_list|,
name|msgid_plural
argument_list|,
name|n
argument_list|,
name|category
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS
if|if
condition|(
name|msg_ctxt_id
operator|!=
name|buf
condition|)
name|free
argument_list|(
name|msg_ctxt_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|translation
operator|==
name|msg_ctxt_id
operator|||
name|translation
operator|==
name|msgid_plural
operator|)
condition|)
return|return
name|translation
return|;
block|}
return|return
operator|(
name|n
operator|==
literal|1
condition|?
name|msgid
else|:
name|msgid_plural
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LIBGETTEXT_H */
end_comment

end_unit

