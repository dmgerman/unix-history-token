begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file reset.c  *  *  Reset the option state to the compiled state.  *  * @addtogroup autoopts  * @{  */
end_comment

begin_comment
comment|/*  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  */
end_comment

begin_function
specifier|static
name|void
name|optionReset
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
block|{
name|pOD
operator|->
name|fOptState
operator|&=
name|OPTST_PERSISTENT_MASK
expr_stmt|;
name|pOD
operator|->
name|fOptState
operator||=
name|OPTST_RESET
expr_stmt|;
if|if
condition|(
name|pOD
operator|->
name|pOptProc
operator|!=
name|NULL
condition|)
name|pOD
operator|->
name|pOptProc
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|)
expr_stmt|;
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|=
name|pOpts
operator|->
name|originalOptArgArray
index|[
name|pOD
operator|->
name|optIndex
index|]
operator|.
name|argString
expr_stmt|;
name|pOD
operator|->
name|optCookie
operator|=
name|pOpts
operator|->
name|originalOptArgCookie
index|[
name|pOD
operator|->
name|optIndex
index|]
expr_stmt|;
name|pOD
operator|->
name|fOptState
operator|&=
name|OPTST_PERSISTENT_MASK
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|optionResetEverything
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|ct
init|=
name|pOpts
operator|->
name|presetOptCt
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|optionReset
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|ct
operator|<=
literal|0
condition|)
break|break;
name|pOD
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*=export_func  optionResetOpt  * private:  *  * what:  Reset the value of an option  * arg:   + tOptions* + pOpts    + program options descriptor  +  * arg:   + tOptDesc* + pOptDesc + the descriptor for this arg +  *  * doc:  *  This code will cause another option to be reset to its initial state.  *  For example, --reset=foo will cause the --foo option to be reset. =*/
end_comment

begin_function
name|void
name|optionResetOpt
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
block|{
specifier|static
name|bool
name|reset_active
init|=
name|false
decl_stmt|;
name|tOptState
name|opt_state
init|=
name|OPTSTATE_INITIALIZER
argument_list|(
name|DEFINED
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|pzArg
init|=
name|pOD
operator|->
name|optArg
operator|.
name|argString
decl_stmt|;
name|tSuccess
name|succ
decl_stmt|;
if|if
condition|(
name|pOpts
operator|<=
name|OPTPROC_EMIT_LIMIT
condition|)
return|return;
if|if
condition|(
name|reset_active
condition|)
return|return;
if|if
condition|(
operator|(
operator|!
name|HAS_originalOptArgArray
argument_list|(
name|pOpts
argument_list|)
operator|)
operator|||
operator|(
name|pOpts
operator|->
name|originalOptArgCookie
operator|==
name|NULL
operator|)
condition|)
name|ao_bug
argument_list|(
name|zno_reset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pzArg
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|pzArg
operator|==
name|NUL
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zreset_arg
argument_list|,
name|pOpts
operator|->
name|pzProgName
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
name|pOpts
operator|->
name|pUsageProc
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|assert
argument_list|(
literal|0
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
name|reset_active
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|pzArg
index|[
literal|1
index|]
operator|==
name|NUL
condition|)
block|{
if|if
condition|(
operator|*
name|pzArg
operator|==
literal|'*'
condition|)
block|{
name|optionResetEverything
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
name|reset_active
operator|=
name|false
expr_stmt|;
return|return;
block|}
name|succ
operator|=
name|opt_find_short
argument_list|(
name|pOpts
argument_list|,
operator|(
name|uint8_t
operator|)
operator|*
name|pzArg
argument_list|,
operator|&
name|opt_state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|succ
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zIllOptChr
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
operator|*
name|pzArg
argument_list|)
expr_stmt|;
name|pOpts
operator|->
name|pUsageProc
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|assert
argument_list|(
literal|0
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|succ
operator|=
name|opt_find_long
argument_list|(
name|pOpts
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|pzArg
argument_list|,
operator|&
name|opt_state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|succ
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zIllOptStr
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
name|pzArg
argument_list|)
expr_stmt|;
name|pOpts
operator|->
name|pUsageProc
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|assert
argument_list|(
literal|0
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      *  We've found the indicated option.  Turn off all non-persistent      *  flags because we're forcing the option back to its initialized state.      *  Call any callout procedure to handle whatever it needs to.      *  Finally, clear the reset flag, too.      */
name|optionReset
argument_list|(
name|pOpts
argument_list|,
name|opt_state
operator|.
name|pOD
argument_list|)
expr_stmt|;
name|reset_active
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/** @}  *  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/reset.c */
end_comment

end_unit

