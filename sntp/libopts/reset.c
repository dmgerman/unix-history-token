begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file reset.c  *  *  Time-stamp:      "2010-07-10 10:56:34 bkorb"  *  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (c) 1992-2011 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following md5sums:  *  *  43b91e8ca915626ed3818ffb1b71248b pkg/libopts/COPYING.gplv3  *  06a1a2e4760c90ea5e1dad8dfaac4d39 pkg/libopts/COPYING.lgplv3  *  66a5cedaf62c4b2637025f049f9b826f pkg/libopts/COPYING.mbsd  */
end_comment

begin_function
specifier|static
name|void
name|optionReset
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
block|{
name|pOD
operator|->
name|fOptState
operator|&=
name|OPTST_PERSISTENT_MASK
expr_stmt|;
name|pOD
operator|->
name|fOptState
operator||=
name|OPTST_RESET
expr_stmt|;
if|if
condition|(
name|pOD
operator|->
name|pOptProc
operator|!=
name|NULL
condition|)
name|pOD
operator|->
name|pOptProc
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|)
expr_stmt|;
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|=
name|pOpts
operator|->
name|originalOptArgArray
index|[
name|pOD
operator|->
name|optIndex
index|]
operator|.
name|argString
expr_stmt|;
name|pOD
operator|->
name|optCookie
operator|=
name|pOpts
operator|->
name|originalOptArgCookie
index|[
name|pOD
operator|->
name|optIndex
index|]
expr_stmt|;
name|pOD
operator|->
name|fOptState
operator|&=
name|OPTST_PERSISTENT_MASK
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|optionResetEverything
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|ct
init|=
name|pOpts
operator|->
name|presetOptCt
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|optionReset
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|ct
operator|<=
literal|0
condition|)
break|break;
name|pOD
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*=export_func  optionResetOpt  * private:  *  * what:  Reset the value of an option  * arg:   + tOptions* + pOpts    + program options descriptor  +  * arg:   + tOptDesc* + pOptDesc + the descriptor for this arg +  *  * doc:  *  This code will cause another option to be reset to its initial state.  *  For example, --reset=foo will cause the --foo option to be reset. =*/
end_comment

begin_function
name|void
name|optionResetOpt
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
block|{
specifier|static
name|ag_bool
name|reset_active
init|=
name|AG_FALSE
decl_stmt|;
name|tOptState
name|opt_state
init|=
name|OPTSTATE_INITIALIZER
argument_list|(
name|DEFINED
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|pzArg
init|=
name|pOD
operator|->
name|optArg
operator|.
name|argString
decl_stmt|;
name|tSuccess
name|succ
decl_stmt|;
if|if
condition|(
name|reset_active
condition|)
return|return;
if|if
condition|(
operator|(
operator|!
name|HAS_originalOptArgArray
argument_list|(
name|pOpts
argument_list|)
operator|)
operator|||
operator|(
name|pOpts
operator|->
name|originalOptArgCookie
operator|==
name|NULL
operator|)
condition|)
block|{
name|fputs
argument_list|(
name|zResetNotConfig
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pzArg
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|pzArg
operator|==
name|NUL
operator|)
condition|)
block|{
name|fputs
argument_list|(
name|zNoResetArg
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|pOpts
operator|->
name|pUsageProc
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|assert
argument_list|(
literal|0
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
name|reset_active
operator|=
name|AG_TRUE
expr_stmt|;
if|if
condition|(
name|pzArg
index|[
literal|1
index|]
operator|==
name|NUL
condition|)
block|{
if|if
condition|(
operator|*
name|pzArg
operator|==
literal|'*'
condition|)
block|{
name|optionResetEverything
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
name|reset_active
operator|=
name|AG_FALSE
expr_stmt|;
return|return;
block|}
name|succ
operator|=
name|shortOptionFind
argument_list|(
name|pOpts
argument_list|,
operator|(
name|tAoUC
operator|)
operator|*
name|pzArg
argument_list|,
operator|&
name|opt_state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|succ
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zIllOptChr
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
operator|*
name|pzArg
argument_list|)
expr_stmt|;
name|pOpts
operator|->
name|pUsageProc
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|assert
argument_list|(
literal|0
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|succ
operator|=
name|longOptionFind
argument_list|(
name|pOpts
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pzArg
argument_list|,
operator|&
name|opt_state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|succ
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zIllOptStr
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
name|pzArg
argument_list|)
expr_stmt|;
name|pOpts
operator|->
name|pUsageProc
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|assert
argument_list|(
literal|0
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      *  We've found the indicated option.  Turn off all non-persistent      *  flags because we're forcing the option back to its initialized state.      *  Call any callout procedure to handle whatever it needs to.      *  Finally, clear the reset flag, too.      */
name|optionReset
argument_list|(
name|pOpts
argument_list|,
name|opt_state
operator|.
name|pOD
argument_list|)
expr_stmt|;
name|reset_active
operator|=
name|AG_FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/reset.c */
end_comment

end_unit

