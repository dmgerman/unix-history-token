begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file configfile.c  *  *  configuration/rc/ini file handling.  *  * @addtogroup autoopts  * @{  */
end_comment

begin_comment
comment|/*  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  */
end_comment

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|void
name|file_preset
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|fname
parameter_list|,
name|int
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|handle_comment
parameter_list|(
name|char
modifier|*
name|txt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|handle_cfg
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptState
modifier|*
name|ost
parameter_list|,
name|char
modifier|*
name|txt
parameter_list|,
name|int
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|handle_directive
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
name|txt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|aoflags_directive
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
name|txt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|program_directive
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
name|txt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|handle_section
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
name|txt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_xml_encoding
parameter_list|(
name|char
modifier|*
modifier|*
name|ppz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|trim_xml_text
parameter_list|(
name|char
modifier|*
name|intxt
parameter_list|,
name|char
specifier|const
modifier|*
name|pznm
parameter_list|,
name|tOptionLoadMode
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cook_xml_text
parameter_list|(
name|char
modifier|*
name|pzData
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|handle_struct
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptState
modifier|*
name|ost
parameter_list|,
name|char
modifier|*
name|txt
parameter_list|,
name|int
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
specifier|const
modifier|*
name|parse_keyword
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|txt
parameter_list|,
name|tOptionValue
modifier|*
name|typ
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
specifier|const
modifier|*
name|parse_set_mem
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|txt
parameter_list|,
name|tOptionValue
modifier|*
name|typ
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
specifier|const
modifier|*
name|parse_value
parameter_list|(
name|char
specifier|const
modifier|*
name|txt
parameter_list|,
name|tOptionValue
modifier|*
name|typ
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/**  *  Skip over some unknown attribute  *  @param[in] txt   start of skpped text  *  @returns   character after skipped text  */
end_comment

begin_function
specifier|inline
specifier|static
name|char
specifier|const
modifier|*
name|skip_unkn
parameter_list|(
name|char
specifier|const
modifier|*
name|txt
parameter_list|)
block|{
name|txt
operator|=
name|BRK_END_XML_TOKEN_CHARS
argument_list|(
name|txt
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|txt
operator|==
name|NUL
operator|)
condition|?
name|NULL
else|:
name|txt
return|;
block|}
end_function

begin_comment
comment|/*=export_func  configFileLoad  *  * what:  parse a configuration file  * arg:   + char const*     + fname + the file to load +  *  * ret_type:  const tOptionValue*  * ret_desc:  An allocated, compound value structure  *  * doc:  *  This routine will load a named configuration file and parse the  *  text as a hierarchically valued option.  The option descriptor  *  created from an option definition file is not used via this interface.  *  The returned value is "named" with the input file name and is of  *  type "@code{OPARG_TYPE_HIERARCHY}".  It may be used in calls to  *  @code{optionGetValue()}, @code{optionNextValue()} and  *  @code{optionUnloadNested()}.  *  * err:  *  If the file cannot be loaded or processed, @code{NULL} is returned and  *  @var{errno} is set.  It may be set by a call to either @code{open(2)}  *  @code{mmap(2)} or other file system calls, or it may be:  *  @itemize @bullet  *  @item  *  @code{ENOENT} - the file was not found.  *  @item  *  @code{ENOMSG} - the file was empty.  *  @item  *  @code{EINVAL} - the file contents are invalid -- not properly formed.  *  @item  *  @code{ENOMEM} - not enough memory to allocate the needed structures.  *  @end itemize =*/
end_comment

begin_function
specifier|const
name|tOptionValue
modifier|*
name|configFileLoad
parameter_list|(
name|char
specifier|const
modifier|*
name|fname
parameter_list|)
block|{
name|tmap_info_t
name|cfgfile
decl_stmt|;
name|tOptionValue
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|tOptionLoadMode
name|save_mode
init|=
name|option_load_mode
decl_stmt|;
name|char
modifier|*
name|txt
init|=
name|text_mmap
argument_list|(
name|fname
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
operator|&
name|cfgfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEXT_MMAP_FAILED_ADDR
argument_list|(
name|txt
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* errno is set */
name|option_load_mode
operator|=
name|OPTION_LOAD_COOKED
expr_stmt|;
name|res
operator|=
name|optionLoadNested
argument_list|(
name|txt
argument_list|,
name|fname
argument_list|,
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|int
name|err
init|=
name|errno
decl_stmt|;
name|text_munmap
argument_list|(
operator|&
name|cfgfile
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
block|}
else|else
name|text_munmap
argument_list|(
operator|&
name|cfgfile
argument_list|)
expr_stmt|;
name|option_load_mode
operator|=
name|save_mode
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionFindValue  *  * what:  find a hierarcicaly valued option instance  * arg:   + const tOptDesc* + odesc + an option with a nested arg type +  * arg:   + char const*     + name  + name of value to find +  * arg:   + char const*     + val   + the matching value    +  *  * ret_type:  const tOptionValue*  * ret_desc:  a compound value structure  *  * doc:  *  This routine will find an entry in a nested value option or configurable.  *  It will search through the list and return a matching entry.  *  * err:  *  The returned result is NULL and errno is set:  *  @itemize @bullet  *  @item  *  @code{EINVAL} - the @code{pOptValue} does not point to a valid  *  hierarchical option value.  *  @item  *  @code{ENOENT} - no entry matched the given name.  *  @end itemize =*/
end_comment

begin_function
specifier|const
name|tOptionValue
modifier|*
name|optionFindValue
parameter_list|(
specifier|const
name|tOptDesc
modifier|*
name|odesc
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|char
specifier|const
modifier|*
name|val
parameter_list|)
block|{
specifier|const
name|tOptionValue
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|odesc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|odesc
operator|->
name|fOptState
argument_list|)
operator|!=
name|OPARG_TYPE_HIERARCHY
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|odesc
operator|->
name|optCookie
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
block|}
else|else
do|do
block|{
name|tArgList
modifier|*
name|argl
init|=
name|odesc
operator|->
name|optCookie
decl_stmt|;
name|int
name|argct
init|=
name|argl
operator|->
name|useCt
decl_stmt|;
name|void
modifier|*
modifier|*
name|poptv
init|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
name|argl
operator|->
name|apzArgs
operator|)
decl_stmt|;
if|if
condition|(
name|argct
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|res
operator|=
operator|(
name|tOptionValue
operator|*
operator|)
operator|*
name|poptv
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|--
name|argct
operator|>=
literal|0
condition|)
block|{
specifier|const
name|tOptionValue
modifier|*
name|ov
init|=
operator|*
operator|(
name|poptv
operator|++
operator|)
decl_stmt|;
specifier|const
name|tOptionValue
modifier|*
name|rv
init|=
name|optionGetValue
argument_list|(
name|ov
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|rv
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
block|{
name|res
operator|=
name|ov
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
name|errno
operator|=
name|ENOENT
expr_stmt|;
block|}
do|while
condition|(
name|false
condition|)
do|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionFindNextValue  *  * FIXME: the handling of 'pzName' and 'pzVal' is just wrong.  *  * what:  find a hierarcicaly valued option instance  * arg:   + const tOptDesc* + odesc + an option with a nested arg type +  * arg:   + const tOptionValue* + pPrevVal + the last entry +  * arg:   + char const*     + name     + name of value to find +  * arg:   + char const*     + value    + the matching value    +  *  * ret_type:  const tOptionValue*  * ret_desc:  a compound value structure  *  * doc:  *  This routine will find the next entry in a nested value option or  *  configurable.  It will search through the list and return the next entry  *  that matches the criteria.  *  * err:  *  The returned result is NULL and errno is set:  *  @itemize @bullet  *  @item  *  @code{EINVAL} - the @code{pOptValue} does not point to a valid  *  hierarchical option value.  *  @item  *  @code{ENOENT} - no entry matched the given name.  *  @end itemize =*/
end_comment

begin_function
name|tOptionValue
specifier|const
modifier|*
name|optionFindNextValue
parameter_list|(
specifier|const
name|tOptDesc
modifier|*
name|odesc
parameter_list|,
specifier|const
name|tOptionValue
modifier|*
name|pPrevVal
parameter_list|,
name|char
specifier|const
modifier|*
name|pzName
parameter_list|,
name|char
specifier|const
modifier|*
name|pzVal
parameter_list|)
block|{
name|bool
name|old_found
init|=
name|false
decl_stmt|;
name|tOptionValue
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|pzName
expr_stmt|;
operator|(
name|void
operator|)
name|pzVal
expr_stmt|;
if|if
condition|(
operator|(
name|odesc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|odesc
operator|->
name|fOptState
argument_list|)
operator|!=
name|OPARG_TYPE_HIERARCHY
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|odesc
operator|->
name|optCookie
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
block|}
else|else
do|do
block|{
name|tArgList
modifier|*
name|argl
init|=
name|odesc
operator|->
name|optCookie
decl_stmt|;
name|int
name|ct
init|=
name|argl
operator|->
name|useCt
decl_stmt|;
name|void
modifier|*
modifier|*
name|poptv
init|=
operator|(
name|void
operator|*
operator|*
operator|)
name|argl
operator|->
name|apzArgs
decl_stmt|;
while|while
condition|(
operator|--
name|ct
operator|>=
literal|0
condition|)
block|{
name|tOptionValue
modifier|*
name|pOV
init|=
operator|*
operator|(
name|poptv
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|old_found
condition|)
block|{
name|res
operator|=
name|pOV
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pOV
operator|==
name|pPrevVal
condition|)
name|old_found
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
name|errno
operator|=
name|ENOENT
expr_stmt|;
block|}
do|while
condition|(
name|false
condition|)
do|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionGetValue  *  * what:  get a specific value from a hierarcical list  * arg:   + const tOptionValue* + pOptValue + a hierarchcal value +  * arg:   + char const*   + valueName + name of value to get +  *  * ret_type:  const tOptionValue*  * ret_desc:  a compound value structure  *  * doc:  *  This routine will find an entry in a nested value option or configurable.  *  If "valueName" is NULL, then the first entry is returned.  Otherwise,  *  the first entry with a name that exactly matches the argument will be  *  returned.  If there is no matching value, NULL is returned and errno is  *  set to ENOENT. If the provided option value is not a hierarchical value,  *  NULL is also returned and errno is set to EINVAL.  *  * err:  *  The returned result is NULL and errno is set:  *  @itemize @bullet  *  @item  *  @code{EINVAL} - the @code{pOptValue} does not point to a valid  *  hierarchical option value.  *  @item  *  @code{ENOENT} - no entry matched the given name.  *  @end itemize =*/
end_comment

begin_function
name|tOptionValue
specifier|const
modifier|*
name|optionGetValue
parameter_list|(
name|tOptionValue
specifier|const
modifier|*
name|oov
parameter_list|,
name|char
specifier|const
modifier|*
name|vname
parameter_list|)
block|{
name|tArgList
modifier|*
name|arg_list
decl_stmt|;
name|tOptionValue
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|oov
operator|==
name|NULL
operator|)
operator|||
operator|(
name|oov
operator|->
name|valType
operator|!=
name|OPARG_TYPE_HIERARCHY
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|res
return|;
block|}
name|arg_list
operator|=
name|oov
operator|->
name|v
operator|.
name|nestVal
expr_stmt|;
if|if
condition|(
name|arg_list
operator|->
name|useCt
operator|>
literal|0
condition|)
block|{
name|int
name|ct
init|=
name|arg_list
operator|->
name|useCt
decl_stmt|;
name|void
modifier|*
modifier|*
name|ovlist
init|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
name|arg_list
operator|->
name|apzArgs
operator|)
decl_stmt|;
if|if
condition|(
name|vname
operator|==
name|NULL
condition|)
block|{
name|res
operator|=
operator|(
name|tOptionValue
operator|*
operator|)
operator|*
name|ovlist
expr_stmt|;
block|}
else|else
do|do
block|{
name|tOptionValue
modifier|*
name|opt_val
init|=
operator|*
operator|(
name|ovlist
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|opt_val
operator|->
name|pzName
argument_list|,
name|vname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|=
name|opt_val
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|--
name|ct
operator|>
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionNextValue  *  * what:  get the next value from a hierarchical list  * arg:   + const tOptionValue* + pOptValue + a hierarchcal list value +  * arg:   + const tOptionValue* + pOldValue + a value from this list   +  *  * ret_type:  const tOptionValue*  * ret_desc:  a compound value structure  *  * doc:  *  This routine will return the next entry after the entry passed in.  At the  *  end of the list, NULL will be returned.  If the entry is not found on the  *  list, NULL will be returned and "@var{errno}" will be set to EINVAL.  *  The "@var{pOldValue}" must have been gotten from a prior call to this  *  routine or to "@code{opitonGetValue()}".  *  * err:  *  The returned result is NULL and errno is set:  *  @itemize @bullet  *  @item  *  @code{EINVAL} - the @code{pOptValue} does not point to a valid  *  hierarchical option value or @code{pOldValue} does not point to a  *  member of that option value.  *  @item  *  @code{ENOENT} - the supplied @code{pOldValue} pointed to the last entry.  *  @end itemize =*/
end_comment

begin_function
name|tOptionValue
specifier|const
modifier|*
name|optionNextValue
parameter_list|(
name|tOptionValue
specifier|const
modifier|*
name|ov_list
parameter_list|,
name|tOptionValue
specifier|const
modifier|*
name|oov
parameter_list|)
block|{
name|tArgList
modifier|*
name|arg_list
decl_stmt|;
name|tOptionValue
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|int
name|err
init|=
name|EINVAL
decl_stmt|;
if|if
condition|(
operator|(
name|ov_list
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ov_list
operator|->
name|valType
operator|!=
name|OPARG_TYPE_HIERARCHY
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|arg_list
operator|=
name|ov_list
operator|->
name|v
operator|.
name|nestVal
expr_stmt|;
block|{
name|int
name|ct
init|=
name|arg_list
operator|->
name|useCt
decl_stmt|;
name|void
modifier|*
modifier|*
name|o_list
init|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
name|arg_list
operator|->
name|apzArgs
operator|)
decl_stmt|;
while|while
condition|(
name|ct
operator|--
operator|>
literal|0
condition|)
block|{
name|tOptionValue
modifier|*
name|nov
init|=
operator|*
operator|(
name|o_list
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|nov
operator|==
name|oov
condition|)
block|{
if|if
condition|(
name|ct
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|ENOENT
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
literal|0
expr_stmt|;
name|res
operator|=
operator|(
name|tOptionValue
operator|*
operator|)
operator|*
name|o_list
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|errno
operator|=
name|err
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  *  Load a file containing presetting information (a configuration file).  */
end_comment

begin_function
specifier|static
name|void
name|file_preset
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|fname
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|tmap_info_t
name|cfgfile
decl_stmt|;
name|tOptState
name|optst
init|=
name|OPTSTATE_INITIALIZER
argument_list|(
name|PRESET
argument_list|)
decl_stmt|;
name|opt_state_mask_t
name|st_flags
init|=
name|optst
operator|.
name|flags
decl_stmt|;
name|opt_state_mask_t
name|fl_save
init|=
name|opts
operator|->
name|fOptSet
decl_stmt|;
name|char
modifier|*
name|ftext
init|=
name|text_mmap
argument_list|(
name|fname
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
operator|&
name|cfgfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEXT_MMAP_FAILED_ADDR
argument_list|(
name|ftext
argument_list|)
condition|)
return|return;
comment|/*      * While processing config files, we ignore errors.      */
name|opts
operator|->
name|fOptSet
operator|&=
operator|~
name|OPTPROC_ERRSTOP
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|DIRECTION_CALLED
condition|)
block|{
name|st_flags
operator|=
name|OPTST_DEFINED
expr_stmt|;
name|dir
operator|=
name|DIRECTION_PROCESS
expr_stmt|;
block|}
comment|/*      *  IF this is called via "optionProcess", then we are presetting.      *  This is the default and the PRESETTING bit will be set.      *  If this is called via "optionFileLoad", then the bit is not set      *  and we consider stuff set herein to be "set" by the client program.      */
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_PRESETTING
operator|)
operator|==
literal|0
condition|)
name|st_flags
operator|=
name|OPTST_SET
expr_stmt|;
do|do
block|{
name|optst
operator|.
name|flags
operator|=
name|st_flags
expr_stmt|;
name|ftext
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|ftext
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_VAR_FIRST_CHAR
argument_list|(
operator|*
name|ftext
argument_list|)
condition|)
block|{
name|ftext
operator|=
name|handle_cfg
argument_list|(
name|opts
argument_list|,
operator|&
name|optst
argument_list|,
name|ftext
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
operator|*
name|ftext
condition|)
block|{
case|case
literal|'<'
case|:
if|if
condition|(
name|IS_VAR_FIRST_CHAR
argument_list|(
name|ftext
index|[
literal|1
index|]
argument_list|)
condition|)
name|ftext
operator|=
name|handle_struct
argument_list|(
name|opts
argument_list|,
operator|&
name|optst
argument_list|,
name|ftext
argument_list|,
name|dir
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|ftext
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'?'
case|:
name|ftext
operator|=
name|handle_directive
argument_list|(
name|opts
argument_list|,
name|ftext
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|ftext
operator|=
name|handle_comment
argument_list|(
name|ftext
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|ftext
operator|=
name|strchr
argument_list|(
name|ftext
operator|+
literal|2
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftext
operator|++
operator|!=
name|NULL
condition|)
break|break;
default|default:
name|ftext
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ftext
operator|==
name|NULL
condition|)
goto|goto
name|all_done
goto|;
break|break;
case|case
literal|'['
case|:
name|ftext
operator|=
name|handle_section
argument_list|(
name|opts
argument_list|,
name|ftext
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|ftext
operator|=
name|strchr
argument_list|(
name|ftext
operator|+
literal|1
argument_list|,
name|NL
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|all_done
goto|;
comment|/* invalid format */
block|}
block|}
do|while
condition|(
name|ftext
operator|!=
name|NULL
condition|)
do|;
name|all_done
label|:
name|text_munmap
argument_list|(
operator|&
name|cfgfile
argument_list|)
expr_stmt|;
name|opts
operator|->
name|fOptSet
operator|=
name|fl_save
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  "txt" points to a "<!" sequence.  *  Theoretically, we should ensure that it begins with "<!--",  *  but actually I don't care that much.  It ends with "-->".  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handle_comment
parameter_list|(
name|char
modifier|*
name|txt
parameter_list|)
block|{
name|char
modifier|*
name|pz
init|=
name|strstr
argument_list|(
name|txt
argument_list|,
literal|"-->"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pz
operator|!=
name|NULL
condition|)
name|pz
operator|+=
literal|3
expr_stmt|;
return|return
name|pz
return|;
block|}
end_function

begin_comment
comment|/**  *  "txt" points to the start of some value name.  *  The end of the entry is the end of the line that is not preceded by  *  a backslash escape character.  The string value is always processed  *  in "cooked" mode.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handle_cfg
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptState
modifier|*
name|ost
parameter_list|,
name|char
modifier|*
name|txt
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|char
modifier|*
name|pzName
init|=
name|txt
operator|++
decl_stmt|;
name|char
modifier|*
name|pzEnd
init|=
name|strchr
argument_list|(
name|txt
argument_list|,
name|NL
argument_list|)
decl_stmt|;
if|if
condition|(
name|pzEnd
operator|==
name|NULL
condition|)
return|return
name|txt
operator|+
name|strlen
argument_list|(
name|txt
argument_list|)
return|;
name|txt
operator|=
name|SPN_VALUE_NAME_CHARS
argument_list|(
name|txt
argument_list|)
expr_stmt|;
name|txt
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|txt
argument_list|)
expr_stmt|;
if|if
condition|(
name|txt
operator|>
name|pzEnd
condition|)
block|{
name|name_only
label|:
operator|*
name|pzEnd
operator|++
operator|=
name|NUL
expr_stmt|;
name|load_opt_line
argument_list|(
name|opts
argument_list|,
name|ost
argument_list|,
name|pzName
argument_list|,
name|dir
argument_list|,
name|OPTION_LOAD_UNCOOKED
argument_list|)
expr_stmt|;
return|return
name|pzEnd
return|;
block|}
comment|/*      *  Either the first character after the name is a ':' or '=',      *  or else we must have skipped over white space.  Anything else      *  is an invalid format and we give up parsing the text.      */
if|if
condition|(
operator|(
operator|*
name|txt
operator|==
literal|'='
operator|)
operator|||
operator|(
operator|*
name|txt
operator|==
literal|':'
operator|)
condition|)
block|{
name|txt
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|txt
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|txt
operator|>
name|pzEnd
condition|)
goto|goto
name|name_only
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_WHITESPACE_CHAR
argument_list|(
name|txt
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/*      *  IF the value is continued, remove the backslash escape and push "pzEnd"      *  on to a newline *not* preceded by a backslash.      */
if|if
condition|(
name|pzEnd
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
name|char
modifier|*
name|pcD
init|=
name|pzEnd
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|pcS
init|=
name|pzEnd
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|ch
init|=
operator|*
operator|(
name|pcS
operator|++
operator|)
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|NUL
case|:
name|pcS
operator|=
name|NULL
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|NL
case|:
operator|*
name|pcD
operator|=
name|NUL
expr_stmt|;
name|pzEnd
operator|=
name|pcS
expr_stmt|;
goto|goto
name|copy_done
goto|;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|pcS
operator|==
name|NL
condition|)
name|ch
operator|=
operator|*
operator|(
name|pcS
operator|++
operator|)
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
operator|*
operator|(
name|pcD
operator|++
operator|)
operator|=
name|ch
expr_stmt|;
block|}
block|}
name|copy_done
label|:
empty_stmt|;
block|}
else|else
block|{
comment|/*          *  The newline was not preceded by a backslash.  NUL it out          */
operator|*
operator|(
name|pzEnd
operator|++
operator|)
operator|=
name|NUL
expr_stmt|;
block|}
comment|/*      *  "pzName" points to what looks like text for one option/configurable.      *  It is NUL terminated.  Process it.      */
name|load_opt_line
argument_list|(
name|opts
argument_list|,
name|ost
argument_list|,
name|pzName
argument_list|,
name|dir
argument_list|,
name|OPTION_LOAD_UNCOOKED
argument_list|)
expr_stmt|;
return|return
name|pzEnd
return|;
block|}
end_function

begin_comment
comment|/**  *  "txt" points to a "<?" sequence.  *  We handle "<?program" and "<?auto-options" directives.  *  All others are treated as comments.  *  *  @param[in,out] opts  program option descriptor  *  @param[in]     txt   scanning pointer  *  @returns       the next character to look at  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handle_directive
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
name|txt
parameter_list|)
block|{
define|#
directive|define
name|DIRECTIVE_TABLE
define|\
value|_dt_(zCfgProg,     program_directive)       \     _dt_(zCfgAO_Flags, aoflags_directive)
typedef|typedef
name|char
modifier|*
function_decl|(
name|directive_func_t
function_decl|)
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
define|#
directive|define
name|_dt_
parameter_list|(
name|_s
parameter_list|,
name|_fn
parameter_list|)
value|_fn,
specifier|static
name|directive_func_t
modifier|*
name|dir_disp
index|[]
init|=
block|{
name|DIRECTIVE_TABLE
block|}
decl_stmt|;
undef|#
directive|undef
name|_dt_
define|#
directive|define
name|_dt_
parameter_list|(
name|_s
parameter_list|,
name|_fn
parameter_list|)
value|1 +
specifier|static
name|int
specifier|const
name|dir_ct
init|=
name|DIRECTIVE_TABLE
literal|0
decl_stmt|;
specifier|static
name|char
specifier|const
modifier|*
name|dir_names
index|[
name|DIRECTIVE_TABLE
literal|0
index|]
decl_stmt|;
undef|#
directive|undef
name|_dt_
name|int
name|ix
decl_stmt|;
if|if
condition|(
name|dir_names
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|ix
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|_dt_
parameter_list|(
name|_s
parameter_list|,
name|_fn
parameter_list|)
value|dir_names[ix++] = _s;
name|DIRECTIVE_TABLE
expr_stmt|;
undef|#
directive|undef
name|_dt_
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|dir_ct
condition|;
name|ix
operator|++
control|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|dir_names
index|[
name|ix
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|txt
operator|+
literal|2
argument_list|,
name|dir_names
index|[
name|ix
index|]
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|IS_VALUE_NAME_CHAR
argument_list|(
name|txt
index|[
name|len
operator|+
literal|2
index|]
argument_list|)
operator|)
condition|)
return|return
name|dir_disp
index|[
name|ix
index|]
operator|(
name|opts
operator|,
name|txt
operator|+
name|len
operator|+
literal|2
operator|)
return|;
block|}
comment|/*      *  We don't know what this is.  Skip it.      */
name|txt
operator|=
name|strchr
argument_list|(
name|txt
operator|+
literal|2
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|txt
operator|!=
name|NULL
condition|)
name|txt
operator|++
expr_stmt|;
return|return
name|txt
return|;
undef|#
directive|undef
name|DIRECTIVE_TABLE
block|}
end_function

begin_comment
comment|/**  *  handle AutoOpts mode flags.  *  *  @param[in,out] opts  program option descriptor  *  @param[in]     txt   scanning pointer  *  @returns       the next character to look at  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|aoflags_directive
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
name|txt
parameter_list|)
block|{
name|char
modifier|*
name|pz
decl_stmt|;
name|pz
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|txt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|txt
operator|=
name|strchr
argument_list|(
name|pz
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|txt
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|len
init|=
call|(
name|unsigned
call|)
argument_list|(
name|txt
operator|-
name|pz
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ftxt
init|=
name|AGALOC
argument_list|(
name|len
operator|+
literal|1
argument_list|,
literal|"aoflags"
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ftxt
argument_list|,
name|pz
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ftxt
index|[
name|len
index|]
operator|=
name|NUL
expr_stmt|;
name|set_usage_flags
argument_list|(
name|opts
argument_list|,
name|ftxt
argument_list|)
expr_stmt|;
name|AGFREE
argument_list|(
name|ftxt
argument_list|)
expr_stmt|;
name|txt
operator|++
expr_stmt|;
block|}
return|return
name|txt
return|;
block|}
end_function

begin_comment
comment|/**  * handle program segmentation of config file.  *  *  @param[in,out] opts  program option descriptor  *  @param[in]     txt   scanning pointer  *  @returns       the next character to look at  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|program_directive
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
name|txt
parameter_list|)
block|{
specifier|static
name|char
specifier|const
name|ttlfmt
index|[]
init|=
literal|"<?"
decl_stmt|;
name|size_t
name|ttl_len
init|=
sizeof|sizeof
argument_list|(
name|ttlfmt
argument_list|)
operator|+
name|strlen
argument_list|(
name|zCfgProg
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ttl
init|=
name|AGALOC
argument_list|(
name|ttl_len
argument_list|,
literal|"prog title"
argument_list|)
decl_stmt|;
name|size_t
name|name_len
init|=
name|strlen
argument_list|(
name|opts
operator|->
name|pzProgName
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ttl
argument_list|,
name|ttlfmt
argument_list|,
sizeof|sizeof
argument_list|(
name|ttlfmt
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ttl
operator|+
sizeof|sizeof
argument_list|(
name|ttlfmt
argument_list|)
operator|-
literal|1
argument_list|,
name|zCfgProg
argument_list|,
name|ttl_len
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|ttlfmt
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
do|do
block|{
name|txt
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|txt
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strneqvcmp
argument_list|(
name|txt
argument_list|,
name|opts
operator|->
name|pzProgName
argument_list|,
operator|(
name|int
operator|)
name|name_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IS_END_XML_TOKEN_CHAR
argument_list|(
name|txt
index|[
name|name_len
index|]
argument_list|)
operator|)
condition|)
block|{
name|txt
operator|+=
name|name_len
expr_stmt|;
break|break;
block|}
name|txt
operator|=
name|strstr
argument_list|(
name|txt
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|txt
operator|!=
name|NULL
condition|)
do|;
name|AGFREE
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|txt
operator|!=
name|NULL
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|txt
operator|==
name|NUL
condition|)
block|{
name|txt
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
operator|(
name|txt
operator|++
operator|)
operator|==
literal|'>'
condition|)
break|break;
block|}
return|return
name|txt
return|;
block|}
end_function

begin_comment
comment|/**  *  "txt" points to a '[' character.  *  The "traditional" [PROG_NAME] segmentation of the config file.  *  Do not ever mix with the "<?program prog-name>" variation.  *  *  @param[in,out] opts  program option descriptor  *  @param[in]     txt   scanning pointer  *  @returns       the next character to look at  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handle_section
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
name|txt
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|opts
operator|->
name|pzPROGNAME
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|txt
operator|+
literal|1
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|txt
index|[
name|len
operator|+
literal|1
index|]
operator|==
literal|']'
operator|)
condition|)
return|return
name|strchr
argument_list|(
name|txt
operator|+
name|len
operator|+
literal|2
argument_list|,
name|NL
argument_list|)
return|;
if|if
condition|(
name|len
operator|>
literal|16
condition|)
return|return
name|NULL
return|;
block|{
name|char
name|z
index|[
literal|24
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|z
argument_list|,
literal|"[%s]"
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
name|txt
operator|=
name|strstr
argument_list|(
name|txt
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|txt
operator|!=
name|NULL
condition|)
name|txt
operator|=
name|strchr
argument_list|(
name|txt
argument_list|,
name|NL
argument_list|)
expr_stmt|;
return|return
name|txt
return|;
block|}
end_function

begin_comment
comment|/**  * parse XML encodings  */
end_comment

begin_function
specifier|static
name|int
name|parse_xml_encoding
parameter_list|(
name|char
modifier|*
modifier|*
name|ppz
parameter_list|)
block|{
define|#
directive|define
name|XMLTABLE
define|\
value|_xmlNm_(amp,   '&')     \         _xmlNm_(lt,    '<')     \         _xmlNm_(gt,    '>')     \         _xmlNm_(ff,    '\f')    \         _xmlNm_(ht,    '\t')    \         _xmlNm_(cr,    '\r')    \         _xmlNm_(vt,    '\v')    \         _xmlNm_(bel,   '\a')    \         _xmlNm_(nl,    NL)      \         _xmlNm_(space, ' ')     \         _xmlNm_(quot,  '"')     \         _xmlNm_(apos,  '\'')
specifier|static
struct|struct
block|{
name|char
specifier|const
modifier|*
specifier|const
name|nm_str
decl_stmt|;
name|unsigned
name|short
name|nm_len
decl_stmt|;
name|short
name|nm_val
decl_stmt|;
block|}
decl|const
name|xml_names
index|[]
init|=
block|{
define|#
directive|define
name|_xmlNm_
parameter_list|(
name|_n
parameter_list|,
name|_v
parameter_list|)
value|{ #_n ";", sizeof(#_n), _v },
name|XMLTABLE
undef|#
directive|undef
name|_xmlNm_
undef|#
directive|undef
name|XMLTABLE
block|}
struct|;
specifier|static
name|int
specifier|const
name|nm_ct
init|=
sizeof|sizeof
argument_list|(
name|xml_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|xml_names
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|base
init|=
literal|10
decl_stmt|;
name|char
modifier|*
name|pz
init|=
operator|*
name|ppz
decl_stmt|;
if|if
condition|(
operator|*
name|pz
operator|==
literal|'#'
condition|)
block|{
name|pz
operator|++
expr_stmt|;
goto|goto
name|parse_number
goto|;
block|}
if|if
condition|(
name|IS_DEC_DIGIT_CHAR
argument_list|(
operator|*
name|pz
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|v
decl_stmt|;
name|parse_number
label|:
switch|switch
condition|(
operator|*
name|pz
condition|)
block|{
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
comment|/*              * Some forms specify hex with:&#xNN;              */
name|base
operator|=
literal|16
expr_stmt|;
name|pz
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
comment|/*              *&#0022; is hex and&#22; is decimal.  Cool.              *  Ya gotta love it.              */
if|if
condition|(
name|pz
index|[
literal|1
index|]
operator|==
literal|'0'
condition|)
name|base
operator|=
literal|16
expr_stmt|;
break|break;
block|}
name|v
operator|=
name|strtoul
argument_list|(
name|pz
argument_list|,
operator|&
name|pz
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pz
operator|!=
literal|';'
operator|)
operator|||
operator|(
name|v
operator|>
literal|0x7F
operator|)
condition|)
return|return
name|NUL
return|;
operator|*
name|ppz
operator|=
name|pz
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|v
return|;
block|}
block|{
name|int
name|ix
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|pz
argument_list|,
name|xml_names
index|[
name|ix
index|]
operator|.
name|nm_str
argument_list|,
name|xml_names
index|[
name|ix
index|]
operator|.
name|nm_len
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|ppz
operator|=
name|pz
operator|+
name|xml_names
index|[
name|ix
index|]
operator|.
name|nm_len
expr_stmt|;
return|return
name|xml_names
index|[
name|ix
index|]
operator|.
name|nm_val
return|;
block|}
block|}
do|while
condition|(
operator|++
name|ix
operator|<
name|nm_ct
condition|)
do|;
block|}
return|return
name|NUL
return|;
block|}
end_function

begin_comment
comment|/**  * Find the end marker for the named section of XML.  * Trim that text there, trimming trailing white space for all modes  * except for OPTION_LOAD_UNCOOKED.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|trim_xml_text
parameter_list|(
name|char
modifier|*
name|intxt
parameter_list|,
name|char
specifier|const
modifier|*
name|pznm
parameter_list|,
name|tOptionLoadMode
name|mode
parameter_list|)
block|{
specifier|static
name|char
specifier|const
name|fmt
index|[]
init|=
literal|"</%s>"
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|pznm
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
operator|-
literal|2
comment|/* for %s */
decl_stmt|;
name|char
modifier|*
name|etext
decl_stmt|;
block|{
name|char
name|z
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|pz
init|=
name|z
decl_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|z
argument_list|)
condition|)
name|pz
operator|=
name|AGALOC
argument_list|(
name|len
argument_list|,
literal|"scan name"
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|size_t
operator|)
name|sprintf
argument_list|(
name|pz
argument_list|,
name|fmt
argument_list|,
name|pznm
argument_list|)
expr_stmt|;
operator|*
name|intxt
operator|=
literal|' '
expr_stmt|;
name|etext
operator|=
name|strstr
argument_list|(
name|intxt
argument_list|,
name|pz
argument_list|)
expr_stmt|;
if|if
condition|(
name|pz
operator|!=
name|z
condition|)
name|AGFREE
argument_list|(
name|pz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|etext
operator|==
name|NULL
condition|)
return|return
name|etext
return|;
block|{
name|char
modifier|*
name|result
init|=
name|etext
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|OPTION_LOAD_UNCOOKED
condition|)
name|etext
operator|=
name|SPN_WHITESPACE_BACK
argument_list|(
name|intxt
argument_list|,
name|etext
argument_list|)
expr_stmt|;
operator|*
name|etext
operator|=
name|NUL
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
end_function

begin_comment
comment|/**  */
end_comment

begin_function
specifier|static
name|void
name|cook_xml_text
parameter_list|(
name|char
modifier|*
name|pzData
parameter_list|)
block|{
name|char
modifier|*
name|pzs
init|=
name|pzData
decl_stmt|;
name|char
modifier|*
name|pzd
init|=
name|pzData
decl_stmt|;
name|char
name|bf
index|[
literal|4
index|]
decl_stmt|;
name|bf
index|[
literal|2
index|]
operator|=
name|NUL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ch
init|=
operator|(
operator|(
name|int
operator|)
operator|*
operator|(
name|pzs
operator|++
operator|)
operator|)
operator|&
literal|0xFF
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|NUL
case|:
operator|*
name|pzd
operator|=
name|NUL
expr_stmt|;
return|return;
case|case
literal|'&'
case|:
name|ch
operator|=
name|parse_xml_encoding
argument_list|(
operator|&
name|pzs
argument_list|)
expr_stmt|;
operator|*
operator|(
name|pzd
operator|++
operator|)
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NUL
condition|)
return|return;
break|break;
case|case
literal|'%'
case|:
name|bf
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|pzs
operator|++
operator|)
expr_stmt|;
name|bf
index|[
literal|1
index|]
operator|=
operator|*
operator|(
name|pzs
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bf
index|[
literal|0
index|]
operator|==
name|NUL
operator|)
operator|||
operator|(
name|bf
index|[
literal|1
index|]
operator|==
name|NUL
operator|)
condition|)
block|{
operator|*
name|pzd
operator|=
name|NUL
expr_stmt|;
return|return;
block|}
name|ch
operator|=
operator|(
name|int
operator|)
name|strtoul
argument_list|(
name|bf
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
operator|*
operator|(
name|pzd
operator|++
operator|)
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *  "txt" points to a '<' character, followed by an alpha.  *  The end of the entry is either the "/>" following the name, or else a  *  "</name>" string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handle_struct
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptState
modifier|*
name|ost
parameter_list|,
name|char
modifier|*
name|txt
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|tOptionLoadMode
name|mode
init|=
name|option_load_mode
decl_stmt|;
name|tOptionValue
name|valu
decl_stmt|;
name|char
modifier|*
name|pzName
init|=
operator|++
name|txt
decl_stmt|;
name|char
modifier|*
name|pzData
decl_stmt|;
name|char
modifier|*
name|pcNulPoint
decl_stmt|;
name|txt
operator|=
name|SPN_VALUE_NAME_CHARS
argument_list|(
name|txt
argument_list|)
expr_stmt|;
name|pcNulPoint
operator|=
name|txt
expr_stmt|;
name|valu
operator|.
name|valType
operator|=
name|OPARG_TYPE_STRING
expr_stmt|;
switch|switch
condition|(
operator|*
name|txt
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
name|txt
operator|=
operator|(
name|void
operator|*
operator|)
name|parse_attrs
argument_list|(
name|opts
argument_list|,
name|SPN_WHITESPACE_CHARS
argument_list|(
name|txt
argument_list|)
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|valu
argument_list|)
expr_stmt|;
if|if
condition|(
name|txt
operator|==
name|NULL
condition|)
return|return
name|txt
return|;
if|if
condition|(
operator|*
name|txt
operator|==
literal|'>'
condition|)
break|break;
if|if
condition|(
operator|*
name|txt
operator|!=
literal|'/'
condition|)
return|return
name|NULL
return|;
comment|/* FALLTHROUGH */
case|case
literal|'/'
case|:
if|if
condition|(
name|txt
index|[
literal|1
index|]
operator|!=
literal|'>'
condition|)
return|return
name|NULL
return|;
operator|*
name|txt
operator|=
name|NUL
expr_stmt|;
name|txt
operator|+=
literal|2
expr_stmt|;
name|load_opt_line
argument_list|(
name|opts
argument_list|,
name|ost
argument_list|,
name|pzName
argument_list|,
name|dir
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|txt
return|;
case|case
literal|'>'
case|:
break|break;
default|default:
name|txt
operator|=
name|strchr
argument_list|(
name|txt
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|txt
operator|!=
name|NULL
condition|)
name|txt
operator|++
expr_stmt|;
return|return
name|txt
return|;
block|}
comment|/*      *  If we are here, we have a value.  "txt" points to a closing angle      *  bracket.  Separate the name from the value for a moment.      */
operator|*
name|pcNulPoint
operator|=
name|NUL
expr_stmt|;
name|pzData
operator|=
operator|++
name|txt
expr_stmt|;
name|txt
operator|=
name|trim_xml_text
argument_list|(
name|txt
argument_list|,
name|pzName
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|txt
operator|==
name|NULL
condition|)
return|return
name|txt
return|;
comment|/*      *  Rejoin the name and value for parsing by "load_opt_line()".      *  Erase any attributes parsed by "parse_attrs()".      */
name|memset
argument_list|(
name|pcNulPoint
argument_list|,
literal|' '
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|pzData
operator|-
name|pcNulPoint
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      *  If we are getting a "string" value that is to be cooked,      *  then process the XML-ish&xx; XML-ish and %XX hex characters.      */
if|if
condition|(
operator|(
name|valu
operator|.
name|valType
operator|==
name|OPARG_TYPE_STRING
operator|)
operator|&&
operator|(
name|mode
operator|==
name|OPTION_LOAD_COOKED
operator|)
condition|)
name|cook_xml_text
argument_list|(
name|pzData
argument_list|)
expr_stmt|;
comment|/*      *  "pzName" points to what looks like text for one option/configurable.      *  It is NUL terminated.  Process it.      */
name|load_opt_line
argument_list|(
name|opts
argument_list|,
name|ost
argument_list|,
name|pzName
argument_list|,
name|dir
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|txt
return|;
block|}
end_function

begin_comment
comment|/**  *  Load a configuration file.  This may be invoked either from  *  scanning the "homerc" list, or from a specific file request.  *  (see "optionFileLoad()", the implementation for --load-opts)  */
end_comment

begin_function
name|LOCAL
name|void
name|intern_file_load
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
block|{
name|uint32_t
name|svfl
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|inc
decl_stmt|;
name|char
name|f_name
index|[
name|AG_PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|opts
operator|->
name|papzHomeList
operator|==
name|NULL
condition|)
return|return;
name|svfl
operator|=
name|opts
operator|->
name|fOptSet
expr_stmt|;
name|inc
operator|=
name|DIRECTION_PRESET
expr_stmt|;
comment|/*      *  Never stop on errors in config files.      */
name|opts
operator|->
name|fOptSet
operator|&=
operator|~
name|OPTPROC_ERRSTOP
expr_stmt|;
comment|/*      *  Find the last RC entry (highest priority entry)      */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|opts
operator|->
name|papzHomeList
index|[
name|idx
operator|+
literal|1
index|]
operator|!=
name|NULL
condition|;
operator|++
name|idx
control|)
empty_stmt|;
comment|/*      *  For every path in the home list, ...  *TWICE* We start at the last      *  (highest priority) entry, work our way down to the lowest priority,      *  handling the immediate options.      *  Then we go back up, doing the normal options.      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|cch_t
modifier|*
name|path
decl_stmt|;
comment|/*          *  IF we've reached the bottom end, change direction          */
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|inc
operator|=
name|DIRECTION_PROCESS
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
block|}
name|path
operator|=
name|opts
operator|->
name|papzHomeList
index|[
name|idx
index|]
expr_stmt|;
comment|/*          *  IF we've reached the top end, bail out          */
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
break|break;
name|idx
operator|+=
name|inc
expr_stmt|;
if|if
condition|(
operator|!
name|optionMakePath
argument_list|(
name|f_name
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|f_name
argument_list|)
argument_list|,
name|path
argument_list|,
name|opts
operator|->
name|pzProgPath
argument_list|)
condition|)
continue|continue;
comment|/*          *  IF the file name we constructed is a directory,          *  THEN append the Resource Configuration file name          *  ELSE we must have the complete file name          */
if|if
condition|(
name|stat
argument_list|(
name|f_name
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* bogus name - skip the home list entry */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|f_name
argument_list|)
decl_stmt|;
name|size_t
name|nln
init|=
name|strlen
argument_list|(
name|opts
operator|->
name|pzRcName
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|pz
init|=
name|f_name
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|+
name|nln
operator|>=
sizeof|sizeof
argument_list|(
name|f_name
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pz
index|[
operator|-
literal|1
index|]
operator|!=
name|DIRCH
condition|)
operator|*
operator|(
name|pz
operator|++
operator|)
operator|=
name|DIRCH
expr_stmt|;
name|memcpy
argument_list|(
name|pz
argument_list|,
name|opts
operator|->
name|pzRcName
argument_list|,
name|nln
argument_list|)
expr_stmt|;
block|}
name|file_preset
argument_list|(
name|opts
argument_list|,
name|f_name
argument_list|,
name|inc
argument_list|)
expr_stmt|;
comment|/*          *  IF we are now to skip config files AND we are presetting,          *  THEN change direction.  We must go the other way.          */
block|{
name|tOptDesc
modifier|*
name|od
init|=
name|opts
operator|->
name|pOptDesc
operator|+
name|opts
operator|->
name|specOptIdx
operator|.
name|save_opts
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|DISABLED_OPT
argument_list|(
name|od
argument_list|)
operator|&&
name|PRESETTING
argument_list|(
name|inc
argument_list|)
condition|)
block|{
name|idx
operator|-=
name|inc
expr_stmt|;
comment|/* go back and reprocess current file */
name|inc
operator|=
name|DIRECTION_PROCESS
expr_stmt|;
block|}
block|}
block|}
comment|/* twice for every path in the home list, ... */
name|opts
operator|->
name|fOptSet
operator|=
name|svfl
expr_stmt|;
block|}
end_function

begin_comment
comment|/*=export_func optionFileLoad  *  * what: Load the locatable config files, in order  *  * arg:  + tOptions*   + opts + program options descriptor +  * arg:  + char const* + prog + program name +  *  * ret_type:  int  * ret_desc:  0 -> SUCCESS, -1 -> FAILURE  *  * doc:  *  * This function looks in all the specified directories for a configuration  * file ("rc" file or "ini" file) and processes any found twice.  The first  * time through, they are processed in reverse order (last file first).  At  * that time, only "immediate action" configurables are processed.  For  * example, if the last named file specifies not processing any more  * configuration files, then no more configuration files will be processed.  * Such an option in the @strong{first} named directory will have no effect.  *  * Once the immediate action configurables have been handled, then the  * directories are handled in normal, forward order.  In that way, later  * config files can override the settings of earlier config files.  *  * See the AutoOpts documentation for a thorough discussion of the  * config file format.  *  * Configuration files not found or not decipherable are simply ignored.  *  * err:  Returns the value, "-1" if the program options descriptor  *       is out of date or indecipherable.  Otherwise, the value "0" will  *       always be returned. =*/
end_comment

begin_function
name|int
name|optionFileLoad
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|prog
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|validate_struct
argument_list|(
name|opts
argument_list|,
name|prog
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/*      * The pointer to the program name is "const".  However, the      * structure is in writable memory, so we coerce the address      * of this pointer to point to writable memory.      */
block|{
name|char
specifier|const
modifier|*
modifier|*
name|pp
init|=
operator|(
name|char
specifier|const
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|opts
operator|->
name|pzProgName
operator|)
decl_stmt|;
operator|*
name|pp
operator|=
name|prog
expr_stmt|;
block|}
name|intern_file_load
argument_list|(
name|opts
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionLoadOpt  * private:  *  * what:  Load an option rc/ini file  * arg:   + tOptions* + opts  + program options descriptor +  * arg:   + tOptDesc* + odesc + the descriptor for this arg +  *  * doc:  *  Processes the options found in the file named with  *  odesc->optArg.argString. =*/
end_comment

begin_function
name|void
name|optionLoadOpt
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|odesc
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|opts
operator|<=
name|OPTPROC_EMIT_LIMIT
condition|)
return|return;
comment|/*      *  IF the option is not being disabled, THEN load the file.  There must      *  be a file.  (If it is being disabled, then the disablement processing      *  already took place.  It must be done to suppress preloading of ini/rc      *  files.)      */
if|if
condition|(
name|DISABLED_OPT
argument_list|(
name|odesc
argument_list|)
operator|||
operator|(
operator|(
name|odesc
operator|->
name|fOptState
operator|&
name|OPTST_RESET
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return;
if|if
condition|(
name|stat
argument_list|(
name|odesc
operator|->
name|optArg
operator|.
name|argString
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|==
literal|0
condition|)
return|return;
name|fserr_exit
argument_list|(
name|opts
operator|->
name|pzProgName
argument_list|,
literal|"stat"
argument_list|,
name|odesc
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|==
literal|0
condition|)
return|return;
name|errno
operator|=
name|EINVAL
expr_stmt|;
name|fserr_exit
argument_list|(
name|opts
operator|->
name|pzProgName
argument_list|,
literal|"stat"
argument_list|,
name|odesc
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
name|file_preset
argument_list|(
name|opts
argument_list|,
name|odesc
operator|->
name|optArg
operator|.
name|argString
argument_list|,
name|DIRECTION_CALLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  Parse the various attributes of an XML-styled config file entry  *  * @returns NULL on failure, otherwise the scan point  */
end_comment

begin_function
name|LOCAL
name|char
specifier|const
modifier|*
name|parse_attrs
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|txt
parameter_list|,
name|tOptionLoadMode
modifier|*
name|pMode
parameter_list|,
name|tOptionValue
modifier|*
name|pType
parameter_list|)
block|{
name|size_t
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|len
operator|=
call|(
name|size_t
call|)
argument_list|(
name|SPN_LOWER_CASE_CHARS
argument_list|(
name|txt
argument_list|)
operator|-
name|txt
argument_list|)
expr_stmt|;
comment|/*          * The enumeration used in this switch is derived from this switch          * statement itself.  The "find_option_xat_attribute_cmd" function          * will return XAT_CMD_MEMBERS for the "txt" string value          * "members", etc.          */
switch|switch
condition|(
name|find_option_xat_attribute_cmd
argument_list|(
name|txt
argument_list|,
name|len
argument_list|)
condition|)
block|{
case|case
name|XAT_CMD_TYPE
case|:
name|txt
operator|=
name|parse_value
argument_list|(
name|txt
operator|+
name|len
argument_list|,
name|pType
argument_list|)
expr_stmt|;
break|break;
case|case
name|XAT_CMD_WORDS
case|:
name|txt
operator|=
name|parse_keyword
argument_list|(
name|opts
argument_list|,
name|txt
operator|+
name|len
argument_list|,
name|pType
argument_list|)
expr_stmt|;
break|break;
case|case
name|XAT_CMD_MEMBERS
case|:
name|txt
operator|=
name|parse_set_mem
argument_list|(
name|opts
argument_list|,
name|txt
operator|+
name|len
argument_list|,
name|pType
argument_list|)
expr_stmt|;
break|break;
case|case
name|XAT_CMD_COOKED
case|:
name|txt
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|IS_END_XML_TOKEN_CHAR
argument_list|(
operator|*
name|txt
argument_list|)
condition|)
goto|goto
name|invalid_kwd
goto|;
operator|*
name|pMode
operator|=
name|OPTION_LOAD_COOKED
expr_stmt|;
break|break;
case|case
name|XAT_CMD_UNCOOKED
case|:
name|txt
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|IS_END_XML_TOKEN_CHAR
argument_list|(
operator|*
name|txt
argument_list|)
condition|)
goto|goto
name|invalid_kwd
goto|;
operator|*
name|pMode
operator|=
name|OPTION_LOAD_UNCOOKED
expr_stmt|;
break|break;
case|case
name|XAT_CMD_KEEP
case|:
name|txt
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|IS_END_XML_TOKEN_CHAR
argument_list|(
operator|*
name|txt
argument_list|)
condition|)
goto|goto
name|invalid_kwd
goto|;
operator|*
name|pMode
operator|=
name|OPTION_LOAD_KEEP
expr_stmt|;
break|break;
default|default:
case|case
name|XAT_INVALID_CMD
case|:
name|invalid_kwd
label|:
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_NONE
expr_stmt|;
return|return
name|skip_unkn
argument_list|(
name|txt
argument_list|)
return|;
block|}
if|if
condition|(
name|txt
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|txt
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|txt
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|txt
condition|)
block|{
case|case
literal|'/'
case|:
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_NONE
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'>'
case|:
return|return
name|txt
return|;
block|}
if|if
condition|(
operator|!
name|IS_LOWER_CASE_CHAR
argument_list|(
operator|*
name|txt
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/**  *  "txt" points to the character after "words=".  *  What should follow is a name of a keyword (enumeration) list.  *  *  @param     opts  unused  *  @param[in] txt   keyword to skip over  *  @param     type  unused value type  *  @returns   pointer after skipped text  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|parse_keyword
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|txt
parameter_list|,
name|tOptionValue
modifier|*
name|typ
parameter_list|)
block|{
operator|(
name|void
operator|)
name|opts
expr_stmt|;
operator|(
name|void
operator|)
name|typ
expr_stmt|;
return|return
name|skip_unkn
argument_list|(
name|txt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  "txt" points to the character after "members="  *  What should follow is a name of a "set membership".  *  A collection of bit flags.  *  *  @param     opts  unused  *  @param[in] txt   keyword to skip over  *  @param     type  unused value type  *  @returns   pointer after skipped text  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|parse_set_mem
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|txt
parameter_list|,
name|tOptionValue
modifier|*
name|typ
parameter_list|)
block|{
operator|(
name|void
operator|)
name|opts
expr_stmt|;
operator|(
name|void
operator|)
name|typ
expr_stmt|;
return|return
name|skip_unkn
argument_list|(
name|txt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  parse the type.  The keyword "type" was found, now figure out  *  the type that follows the type.  *  *  @param[in]  txt  points to the '=' character after the "type" keyword.  *  @param[out] typ  where to store the type found  *  @returns    the next byte after the type name  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|parse_value
parameter_list|(
name|char
specifier|const
modifier|*
name|txt
parameter_list|,
name|tOptionValue
modifier|*
name|typ
parameter_list|)
block|{
name|size_t
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|txt
operator|++
operator|)
operator|!=
literal|'='
condition|)
goto|goto
name|woops
goto|;
name|len
operator|=
call|(
name|size_t
call|)
argument_list|(
name|SPN_OPTION_NAME_CHARS
argument_list|(
name|txt
argument_list|)
operator|-
name|txt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|!
name|IS_END_XML_TOKEN_CHAR
argument_list|(
name|txt
index|[
name|len
index|]
argument_list|)
operator|)
condition|)
block|{
name|woops
label|:
name|typ
operator|->
name|valType
operator|=
name|OPARG_TYPE_NONE
expr_stmt|;
return|return
name|skip_unkn
argument_list|(
name|txt
operator|+
name|len
argument_list|)
return|;
block|}
comment|/*      * The enumeration used in this switch is derived from this switch      * statement itself.  The "find_option_value_type_cmd" function      * will return VTP_CMD_INTEGER for the "txt" string value      * "integer", etc.      */
switch|switch
condition|(
name|find_option_value_type_cmd
argument_list|(
name|txt
argument_list|,
name|len
argument_list|)
condition|)
block|{
default|default:
case|case
name|VTP_INVALID_CMD
case|:
goto|goto
name|woops
goto|;
case|case
name|VTP_CMD_STRING
case|:
name|typ
operator|->
name|valType
operator|=
name|OPARG_TYPE_STRING
expr_stmt|;
break|break;
case|case
name|VTP_CMD_INTEGER
case|:
name|typ
operator|->
name|valType
operator|=
name|OPARG_TYPE_NUMERIC
expr_stmt|;
break|break;
case|case
name|VTP_CMD_BOOL
case|:
case|case
name|VTP_CMD_BOOLEAN
case|:
name|typ
operator|->
name|valType
operator|=
name|OPARG_TYPE_BOOLEAN
expr_stmt|;
break|break;
case|case
name|VTP_CMD_KEYWORD
case|:
name|typ
operator|->
name|valType
operator|=
name|OPARG_TYPE_ENUMERATION
expr_stmt|;
break|break;
case|case
name|VTP_CMD_SET
case|:
case|case
name|VTP_CMD_SET_MEMBERSHIP
case|:
name|typ
operator|->
name|valType
operator|=
name|OPARG_TYPE_MEMBERSHIP
expr_stmt|;
break|break;
case|case
name|VTP_CMD_NESTED
case|:
case|case
name|VTP_CMD_HIERARCHY
case|:
name|typ
operator|->
name|valType
operator|=
name|OPARG_TYPE_HIERARCHY
expr_stmt|;
block|}
return|return
name|txt
operator|+
name|len
return|;
block|}
end_function

begin_comment
comment|/** @}  *  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/configfile.c */
end_comment

end_unit

