begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file configfile.c  *  *  Time-stamp:      "2011-04-06 09:31:24 bkorb"  *  *  configuration/rc/ini file handling.  *  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (c) 1992-2011 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following md5sums:  *  *  43b91e8ca915626ed3818ffb1b71248b pkg/libopts/COPYING.gplv3  *  06a1a2e4760c90ea5e1dad8dfaac4d39 pkg/libopts/COPYING.lgplv3  *  66a5cedaf62c4b2637025f049f9b826f pkg/libopts/COPYING.mbsd  */
end_comment

begin_function_decl
specifier|static
name|void
name|set_usage_flags
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|flg_txt
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|void
name|file_preset
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|fname
parameter_list|,
name|int
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|handle_comment
parameter_list|(
name|char
modifier|*
name|pzText
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|handle_cfg
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|int
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|handle_directive
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|aoflags_directive
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|program_directive
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|handle_section
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_xml_encoding
parameter_list|(
name|char
modifier|*
modifier|*
name|ppz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|trim_xml_text
parameter_list|(
name|char
modifier|*
name|pztxt
parameter_list|,
name|char
specifier|const
modifier|*
name|pznm
parameter_list|,
name|tOptionLoadMode
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cook_xml_text
parameter_list|(
name|char
modifier|*
name|pzData
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|handle_struct
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|int
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|parse_keyword
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|tOptionValue
modifier|*
name|pType
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|parse_set_mem
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|tOptionValue
modifier|*
name|pType
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|parse_value
parameter_list|(
name|char
modifier|*
name|pzText
parameter_list|,
name|tOptionValue
modifier|*
name|pType
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|skip_unkn
parameter_list|(
name|char
modifier|*
name|pzText
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/*=export_func  configFileLoad  *  * what:  parse a configuration file  * arg:   + char const*     + pzFile + the file to load +  *  * ret_type:  const tOptionValue*  * ret_desc:  An allocated, compound value structure  *  * doc:  *  This routine will load a named configuration file and parse the  *  text as a hierarchically valued option.  The option descriptor  *  created from an option definition file is not used via this interface.  *  The returned value is "named" with the input file name and is of  *  type "@code{OPARG_TYPE_HIERARCHY}".  It may be used in calls to  *  @code{optionGetValue()}, @code{optionNextValue()} and  *  @code{optionUnloadNested()}.  *  * err:  *  If the file cannot be loaded or processed, @code{NULL} is returned and  *  @var{errno} is set.  It may be set by a call to either @code{open(2)}  *  @code{mmap(2)} or other file system calls, or it may be:  *  @itemize @bullet  *  @item  *  @code{ENOENT} - the file was empty.  *  @item  *  @code{EINVAL} - the file contents are invalid -- not properly formed.  *  @item  *  @code{ENOMEM} - not enough memory to allocate the needed structures.  *  @end itemize =*/
end_comment

begin_function
specifier|const
name|tOptionValue
modifier|*
name|configFileLoad
parameter_list|(
name|char
specifier|const
modifier|*
name|pzFile
parameter_list|)
block|{
name|tmap_info_t
name|cfgfile
decl_stmt|;
name|tOptionValue
modifier|*
name|pRes
init|=
name|NULL
decl_stmt|;
name|tOptionLoadMode
name|save_mode
init|=
name|option_load_mode
decl_stmt|;
name|char
modifier|*
name|pzText
init|=
name|text_mmap
argument_list|(
name|pzFile
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
operator|&
name|cfgfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEXT_MMAP_FAILED_ADDR
argument_list|(
name|pzText
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* errno is set */
name|option_load_mode
operator|=
name|OPTION_LOAD_COOKED
expr_stmt|;
name|pRes
operator|=
name|optionLoadNested
argument_list|(
name|pzText
argument_list|,
name|pzFile
argument_list|,
name|strlen
argument_list|(
name|pzFile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pRes
operator|==
name|NULL
condition|)
block|{
name|int
name|err
init|=
name|errno
decl_stmt|;
name|text_munmap
argument_list|(
operator|&
name|cfgfile
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
block|}
else|else
name|text_munmap
argument_list|(
operator|&
name|cfgfile
argument_list|)
expr_stmt|;
name|option_load_mode
operator|=
name|save_mode
expr_stmt|;
return|return
name|pRes
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionFindValue  *  * what:  find a hierarcicaly valued option instance  * arg:   + const tOptDesc* + pOptDesc + an option with a nested arg type +  * arg:   + char const*     + name     + name of value to find +  * arg:   + char const*     + value    + the matching value    +  *  * ret_type:  const tOptionValue*  * ret_desc:  a compound value structure  *  * doc:  *  This routine will find an entry in a nested value option or configurable.  *  It will search through the list and return a matching entry.  *  * err:  *  The returned result is NULL and errno is set:  *  @itemize @bullet  *  @item  *  @code{EINVAL} - the @code{pOptValue} does not point to a valid  *  hierarchical option value.  *  @item  *  @code{ENOENT} - no entry matched the given name.  *  @end itemize =*/
end_comment

begin_function
specifier|const
name|tOptionValue
modifier|*
name|optionFindValue
parameter_list|(
specifier|const
name|tOptDesc
modifier|*
name|pOptDesc
parameter_list|,
name|char
specifier|const
modifier|*
name|pzName
parameter_list|,
name|char
specifier|const
modifier|*
name|pzVal
parameter_list|)
block|{
specifier|const
name|tOptionValue
modifier|*
name|pRes
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|pOptDesc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOptDesc
operator|->
name|fOptState
argument_list|)
operator|!=
name|OPARG_TYPE_HIERARCHY
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pOptDesc
operator|->
name|optCookie
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
block|}
else|else
do|do
block|{
name|tArgList
modifier|*
name|pAL
init|=
name|pOptDesc
operator|->
name|optCookie
decl_stmt|;
name|int
name|ct
init|=
name|pAL
operator|->
name|useCt
decl_stmt|;
name|void
modifier|*
modifier|*
name|ppOV
init|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
name|pAL
operator|->
name|apzArgs
operator|)
decl_stmt|;
if|if
condition|(
name|ct
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pzName
operator|==
name|NULL
condition|)
block|{
name|pRes
operator|=
operator|(
name|tOptionValue
operator|*
operator|)
operator|*
name|ppOV
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|--
name|ct
operator|>=
literal|0
condition|)
block|{
specifier|const
name|tOptionValue
modifier|*
name|pOV
init|=
operator|*
operator|(
name|ppOV
operator|++
operator|)
decl_stmt|;
specifier|const
name|tOptionValue
modifier|*
name|pRV
init|=
name|optionGetValue
argument_list|(
name|pOV
argument_list|,
name|pzName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pRV
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|pzVal
operator|==
name|NULL
condition|)
block|{
name|pRes
operator|=
name|pOV
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pRes
operator|==
name|NULL
condition|)
name|errno
operator|=
name|ENOENT
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
return|return
name|pRes
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionFindNextValue  *  * what:  find a hierarcicaly valued option instance  * arg:   + const tOptDesc* + pOptDesc + an option with a nested arg type +  * arg:   + const tOptionValue* + pPrevVal + the last entry +  * arg:   + char const*     + name     + name of value to find +  * arg:   + char const*     + value    + the matching value    +  *  * ret_type:  const tOptionValue*  * ret_desc:  a compound value structure  *  * doc:  *  This routine will find the next entry in a nested value option or  *  configurable.  It will search through the list and return the next entry  *  that matches the criteria.  *  * err:  *  The returned result is NULL and errno is set:  *  @itemize @bullet  *  @item  *  @code{EINVAL} - the @code{pOptValue} does not point to a valid  *  hierarchical option value.  *  @item  *  @code{ENOENT} - no entry matched the given name.  *  @end itemize =*/
end_comment

begin_function
name|tOptionValue
specifier|const
modifier|*
name|optionFindNextValue
parameter_list|(
specifier|const
name|tOptDesc
modifier|*
name|pOptDesc
parameter_list|,
specifier|const
name|tOptionValue
modifier|*
name|pPrevVal
parameter_list|,
name|char
specifier|const
modifier|*
name|pzName
parameter_list|,
name|char
specifier|const
modifier|*
name|pzVal
parameter_list|)
block|{
name|int
name|foundOldVal
init|=
literal|0
decl_stmt|;
name|tOptionValue
modifier|*
name|pRes
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|pOptDesc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOptDesc
operator|->
name|fOptState
argument_list|)
operator|!=
name|OPARG_TYPE_HIERARCHY
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pOptDesc
operator|->
name|optCookie
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
block|}
else|else
do|do
block|{
name|tArgList
modifier|*
name|pAL
init|=
name|pOptDesc
operator|->
name|optCookie
decl_stmt|;
name|int
name|ct
init|=
name|pAL
operator|->
name|useCt
decl_stmt|;
name|void
modifier|*
modifier|*
name|ppOV
init|=
operator|(
name|void
operator|*
operator|*
operator|)
name|pAL
operator|->
name|apzArgs
decl_stmt|;
if|if
condition|(
name|ct
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|--
name|ct
operator|>=
literal|0
condition|)
block|{
name|tOptionValue
modifier|*
name|pOV
init|=
operator|*
operator|(
name|ppOV
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|foundOldVal
condition|)
block|{
name|pRes
operator|=
name|pOV
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pOV
operator|==
name|pPrevVal
condition|)
name|foundOldVal
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pRes
operator|==
name|NULL
condition|)
name|errno
operator|=
name|ENOENT
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
return|return
name|pRes
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionGetValue  *  * what:  get a specific value from a hierarcical list  * arg:   + const tOptionValue* + pOptValue + a hierarchcal value +  * arg:   + char const*   + valueName + name of value to get +  *  * ret_type:  const tOptionValue*  * ret_desc:  a compound value structure  *  * doc:  *  This routine will find an entry in a nested value option or configurable.  *  If "valueName" is NULL, then the first entry is returned.  Otherwise,  *  the first entry with a name that exactly matches the argument will be  *  returned.  *  * err:  *  The returned result is NULL and errno is set:  *  @itemize @bullet  *  @item  *  @code{EINVAL} - the @code{pOptValue} does not point to a valid  *  hierarchical option value.  *  @item  *  @code{ENOENT} - no entry matched the given name.  *  @end itemize =*/
end_comment

begin_function
specifier|const
name|tOptionValue
modifier|*
name|optionGetValue
parameter_list|(
specifier|const
name|tOptionValue
modifier|*
name|pOld
parameter_list|,
name|char
specifier|const
modifier|*
name|pzValName
parameter_list|)
block|{
name|tArgList
modifier|*
name|pAL
decl_stmt|;
name|tOptionValue
modifier|*
name|pRes
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|pOld
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pOld
operator|->
name|valType
operator|!=
name|OPARG_TYPE_HIERARCHY
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pAL
operator|=
name|pOld
operator|->
name|v
operator|.
name|nestVal
expr_stmt|;
if|if
condition|(
name|pAL
operator|->
name|useCt
operator|>
literal|0
condition|)
block|{
name|int
name|ct
init|=
name|pAL
operator|->
name|useCt
decl_stmt|;
name|void
modifier|*
modifier|*
name|papOV
init|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
name|pAL
operator|->
name|apzArgs
operator|)
decl_stmt|;
if|if
condition|(
name|pzValName
operator|==
name|NULL
condition|)
block|{
name|pRes
operator|=
operator|(
name|tOptionValue
operator|*
operator|)
operator|*
name|papOV
expr_stmt|;
block|}
else|else
do|do
block|{
name|tOptionValue
modifier|*
name|pOV
init|=
operator|*
operator|(
name|papOV
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pOV
operator|->
name|pzName
argument_list|,
name|pzValName
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pRes
operator|=
name|pOV
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|--
name|ct
operator|>
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|pRes
operator|==
name|NULL
condition|)
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
name|pRes
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionNextValue  *  * what:  get the next value from a hierarchical list  * arg:   + const tOptionValue* + pOptValue + a hierarchcal list value +  * arg:   + const tOptionValue* + pOldValue + a value from this list   +  *  * ret_type:  const tOptionValue*  * ret_desc:  a compound value structure  *  * doc:  *  This routine will return the next entry after the entry passed in.  At the  *  end of the list, NULL will be returned.  If the entry is not found on the  *  list, NULL will be returned and "@var{errno}" will be set to EINVAL.  *  The "@var{pOldValue}" must have been gotten from a prior call to this  *  routine or to "@code{opitonGetValue()}".  *  * err:  *  The returned result is NULL and errno is set:  *  @itemize @bullet  *  @item  *  @code{EINVAL} - the @code{pOptValue} does not point to a valid  *  hierarchical option value or @code{pOldValue} does not point to a  *  member of that option value.  *  @item  *  @code{ENOENT} - the supplied @code{pOldValue} pointed to the last entry.  *  @end itemize =*/
end_comment

begin_function
name|tOptionValue
specifier|const
modifier|*
name|optionNextValue
parameter_list|(
name|tOptionValue
specifier|const
modifier|*
name|pOVList
parameter_list|,
name|tOptionValue
specifier|const
modifier|*
name|pOldOV
parameter_list|)
block|{
name|tArgList
modifier|*
name|pAL
decl_stmt|;
name|tOptionValue
modifier|*
name|pRes
init|=
name|NULL
decl_stmt|;
name|int
name|err
init|=
name|EINVAL
decl_stmt|;
if|if
condition|(
operator|(
name|pOVList
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pOVList
operator|->
name|valType
operator|!=
name|OPARG_TYPE_HIERARCHY
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pAL
operator|=
name|pOVList
operator|->
name|v
operator|.
name|nestVal
expr_stmt|;
block|{
name|int
name|ct
init|=
name|pAL
operator|->
name|useCt
decl_stmt|;
name|void
modifier|*
modifier|*
name|papNV
init|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
name|pAL
operator|->
name|apzArgs
operator|)
decl_stmt|;
while|while
condition|(
name|ct
operator|--
operator|>
literal|0
condition|)
block|{
name|tOptionValue
modifier|*
name|pNV
init|=
operator|*
operator|(
name|papNV
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|pNV
operator|==
name|pOldOV
condition|)
block|{
if|if
condition|(
name|ct
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|ENOENT
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
literal|0
expr_stmt|;
name|pRes
operator|=
operator|(
name|tOptionValue
operator|*
operator|)
operator|*
name|papNV
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|errno
operator|=
name|err
expr_stmt|;
return|return
name|pRes
return|;
block|}
end_function

begin_comment
comment|/**  *  Load a file containing presetting information (a configuration file).  */
end_comment

begin_function
specifier|static
name|void
name|file_preset
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|fname
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|tmap_info_t
name|cfgfile
decl_stmt|;
name|tOptState
name|optst
init|=
name|OPTSTATE_INITIALIZER
argument_list|(
name|PRESET
argument_list|)
decl_stmt|;
name|tAoUL
name|st_flags
init|=
name|optst
operator|.
name|flags
decl_stmt|;
name|char
modifier|*
name|ftext
init|=
name|text_mmap
argument_list|(
name|fname
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
operator|&
name|cfgfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEXT_MMAP_FAILED_ADDR
argument_list|(
name|ftext
argument_list|)
condition|)
return|return;
if|if
condition|(
name|dir
operator|==
name|DIRECTION_CALLED
condition|)
block|{
name|st_flags
operator|=
name|OPTST_DEFINED
expr_stmt|;
name|dir
operator|=
name|DIRECTION_PROCESS
expr_stmt|;
block|}
comment|/*      *  IF this is called via "optionProcess", then we are presetting.      *  This is the default and the PRESETTING bit will be set.      *  If this is called via "optionFileLoad", then the bit is not set      *  and we consider stuff set herein to be "set" by the client program.      */
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_PRESETTING
operator|)
operator|==
literal|0
condition|)
name|st_flags
operator|=
name|OPTST_SET
expr_stmt|;
do|do
block|{
name|optst
operator|.
name|flags
operator|=
name|st_flags
expr_stmt|;
while|while
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
name|ftext
argument_list|)
condition|)
name|ftext
operator|++
expr_stmt|;
if|if
condition|(
name|IS_VAR_FIRST_CHAR
argument_list|(
operator|*
name|ftext
argument_list|)
condition|)
block|{
name|ftext
operator|=
name|handle_cfg
argument_list|(
name|opts
argument_list|,
operator|&
name|optst
argument_list|,
name|ftext
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
operator|*
name|ftext
condition|)
block|{
case|case
literal|'<'
case|:
if|if
condition|(
name|IS_VAR_FIRST_CHAR
argument_list|(
name|ftext
index|[
literal|1
index|]
argument_list|)
condition|)
name|ftext
operator|=
name|handle_struct
argument_list|(
name|opts
argument_list|,
operator|&
name|optst
argument_list|,
name|ftext
argument_list|,
name|dir
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|ftext
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'?'
case|:
name|ftext
operator|=
name|handle_directive
argument_list|(
name|opts
argument_list|,
name|ftext
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|ftext
operator|=
name|handle_comment
argument_list|(
name|ftext
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|ftext
operator|=
name|strchr
argument_list|(
name|ftext
operator|+
literal|2
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftext
operator|++
operator|!=
name|NULL
condition|)
break|break;
default|default:
goto|goto
name|all_done
goto|;
block|}
break|break;
case|case
literal|'['
case|:
name|ftext
operator|=
name|handle_section
argument_list|(
name|opts
argument_list|,
name|ftext
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|ftext
operator|=
name|strchr
argument_list|(
name|ftext
operator|+
literal|1
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|all_done
goto|;
comment|/* invalid format */
block|}
block|}
do|while
condition|(
name|ftext
operator|!=
name|NULL
condition|)
do|;
name|all_done
label|:
name|text_munmap
argument_list|(
operator|&
name|cfgfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  "pzText" points to a "<!" sequence.  *  Theoretically, we should ensure that it begins with "<!--",  *  but actually I don't care that much.  It ends with "-->".  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handle_comment
parameter_list|(
name|char
modifier|*
name|pzText
parameter_list|)
block|{
name|char
modifier|*
name|pz
init|=
name|strstr
argument_list|(
name|pzText
argument_list|,
literal|"-->"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pz
operator|!=
name|NULL
condition|)
name|pz
operator|+=
literal|3
expr_stmt|;
return|return
name|pz
return|;
block|}
end_function

begin_comment
comment|/**  *  "pzText" points to the start of some value name.  *  The end of the entry is the end of the line that is not preceded by  *  a backslash escape character.  The string value is always processed  *  in "cooked" mode.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handle_cfg
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|char
modifier|*
name|pzName
init|=
name|pzText
operator|++
decl_stmt|;
name|char
modifier|*
name|pzEnd
init|=
name|strchr
argument_list|(
name|pzText
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|pzEnd
operator|==
name|NULL
condition|)
return|return
name|pzText
operator|+
name|strlen
argument_list|(
name|pzText
argument_list|)
return|;
while|while
condition|(
name|IS_VALUE_NAME_CHAR
argument_list|(
operator|*
name|pzText
argument_list|)
condition|)
name|pzText
operator|++
expr_stmt|;
while|while
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
name|pzText
argument_list|)
condition|)
name|pzText
operator|++
expr_stmt|;
if|if
condition|(
name|pzText
operator|>
name|pzEnd
condition|)
block|{
name|name_only
label|:
operator|*
name|pzEnd
operator|++
operator|=
name|NUL
expr_stmt|;
name|loadOptionLine
argument_list|(
name|pOpts
argument_list|,
name|pOS
argument_list|,
name|pzName
argument_list|,
name|dir
argument_list|,
name|OPTION_LOAD_UNCOOKED
argument_list|)
expr_stmt|;
return|return
name|pzEnd
return|;
block|}
comment|/*      *  Either the first character after the name is a ':' or '=',      *  or else we must have skipped over white space.  Anything else      *  is an invalid format and we give up parsing the text.      */
if|if
condition|(
operator|(
operator|*
name|pzText
operator|==
literal|'='
operator|)
operator|||
operator|(
operator|*
name|pzText
operator|==
literal|':'
operator|)
condition|)
block|{
while|while
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
operator|++
name|pzText
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|pzText
operator|>
name|pzEnd
condition|)
goto|goto
name|name_only
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_WHITESPACE_CHAR
argument_list|(
name|pzText
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/*      *  IF the value is continued, remove the backslash escape and push "pzEnd"      *  on to a newline *not* preceded by a backslash.      */
if|if
condition|(
name|pzEnd
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
name|char
modifier|*
name|pcD
init|=
name|pzEnd
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|pcS
init|=
name|pzEnd
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|ch
init|=
operator|*
operator|(
name|pcS
operator|++
operator|)
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|NUL
case|:
name|pcS
operator|=
name|NULL
expr_stmt|;
case|case
literal|'\n'
case|:
operator|*
name|pcD
operator|=
name|NUL
expr_stmt|;
name|pzEnd
operator|=
name|pcS
expr_stmt|;
goto|goto
name|copy_done
goto|;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|pcS
operator|==
literal|'\n'
condition|)
block|{
name|ch
operator|=
operator|*
operator|(
name|pcS
operator|++
operator|)
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
default|default:
operator|*
operator|(
name|pcD
operator|++
operator|)
operator|=
name|ch
expr_stmt|;
block|}
block|}
name|copy_done
label|:
empty_stmt|;
block|}
else|else
block|{
comment|/*          *  The newline was not preceded by a backslash.  NUL it out          */
operator|*
operator|(
name|pzEnd
operator|++
operator|)
operator|=
name|NUL
expr_stmt|;
block|}
comment|/*      *  "pzName" points to what looks like text for one option/configurable.      *  It is NUL terminated.  Process it.      */
name|loadOptionLine
argument_list|(
name|pOpts
argument_list|,
name|pOS
argument_list|,
name|pzName
argument_list|,
name|dir
argument_list|,
name|OPTION_LOAD_UNCOOKED
argument_list|)
expr_stmt|;
return|return
name|pzEnd
return|;
block|}
end_function

begin_comment
comment|/**  *  "pzText" points to a "<?" sequence.  *  We handle "<?program" and "<?auto-options" directives.  *  All others are treated as comments.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handle_directive
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|)
block|{
define|#
directive|define
name|DIRECTIVE_TABLE
define|\
value|_dt_(zCfgProg,     program_directive)       \     _dt_(zCfgAO_Flags, aoflags_directive)
typedef|typedef
name|char
modifier|*
function_decl|(
name|directive_func_t
function_decl|)
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
define|#
directive|define
name|_dt_
parameter_list|(
name|_s
parameter_list|,
name|_fn
parameter_list|)
value|_fn,
specifier|static
name|directive_func_t
modifier|*
name|dir_disp
index|[]
init|=
block|{
name|DIRECTIVE_TABLE
block|}
decl_stmt|;
undef|#
directive|undef
name|_dt_
define|#
directive|define
name|_dt_
parameter_list|(
name|_s
parameter_list|,
name|_fn
parameter_list|)
value|1 +
specifier|static
name|int
specifier|const
name|dir_ct
init|=
name|DIRECTIVE_TABLE
literal|0
decl_stmt|;
specifier|static
name|char
specifier|const
modifier|*
name|dir_names
index|[
name|DIRECTIVE_TABLE
literal|0
index|]
decl_stmt|;
undef|#
directive|undef
name|_dt_
name|int
name|ix
decl_stmt|;
if|if
condition|(
name|dir_names
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|ix
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|_dt_
parameter_list|(
name|_s
parameter_list|,
name|_fn
parameter_list|)
value|dir_names[ix++] = _s;
name|DIRECTIVE_TABLE
expr_stmt|;
undef|#
directive|undef
name|_dt_
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|dir_ct
condition|;
name|ix
operator|++
control|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|dir_names
index|[
name|ix
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|pzText
operator|+
literal|2
argument_list|,
name|dir_names
index|[
name|ix
index|]
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|IS_VALUE_NAME_CHAR
argument_list|(
name|pzText
index|[
name|len
operator|+
literal|2
index|]
argument_list|)
operator|)
condition|)
return|return
name|dir_disp
index|[
name|ix
index|]
operator|(
name|pOpts
operator|,
name|pzText
operator|+
name|len
operator|+
literal|2
operator|)
return|;
block|}
comment|/*      *  We don't know what this is.  Skip it.      */
name|pzText
operator|=
name|strchr
argument_list|(
name|pzText
operator|+
literal|2
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzText
operator|!=
name|NULL
condition|)
name|pzText
operator|++
expr_stmt|;
return|return
name|pzText
return|;
block|}
end_function

begin_comment
comment|/**  *  handle AutoOpts mode flags  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|aoflags_directive
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|)
block|{
name|char
modifier|*
name|pz
init|=
name|pzText
decl_stmt|;
while|while
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
operator|++
name|pz
argument_list|)
condition|)
empty_stmt|;
name|pzText
operator|=
name|strchr
argument_list|(
name|pz
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzText
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|len
init|=
name|pzText
operator|-
name|pz
decl_stmt|;
name|char
modifier|*
name|ftxt
init|=
name|AGALOC
argument_list|(
name|len
operator|+
literal|1
argument_list|,
literal|"aoflags"
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ftxt
argument_list|,
name|pz
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ftxt
index|[
name|len
index|]
operator|=
name|NUL
expr_stmt|;
name|set_usage_flags
argument_list|(
name|pOpts
argument_list|,
name|ftxt
argument_list|)
expr_stmt|;
name|AGFREE
argument_list|(
name|ftxt
argument_list|)
expr_stmt|;
name|pzText
operator|++
expr_stmt|;
block|}
return|return
name|pzText
return|;
block|}
end_function

begin_comment
comment|/**  * handle program segmentation of config file.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|program_directive
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|)
block|{
specifier|static
name|char
specifier|const
name|ttlfmt
index|[]
init|=
literal|"<?"
decl_stmt|;
name|size_t
name|ttl_len
init|=
sizeof|sizeof
argument_list|(
name|ttlfmt
argument_list|)
operator|+
name|strlen
argument_list|(
name|zCfgProg
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ttl
init|=
name|AGALOC
argument_list|(
name|ttl_len
argument_list|,
literal|"prog title"
argument_list|)
decl_stmt|;
name|size_t
name|name_len
init|=
name|strlen
argument_list|(
name|pOpts
operator|->
name|pzProgName
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ttl
argument_list|,
name|ttlfmt
argument_list|,
sizeof|sizeof
argument_list|(
name|ttlfmt
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ttl
operator|+
sizeof|sizeof
argument_list|(
name|ttlfmt
argument_list|)
operator|-
literal|1
argument_list|,
name|zCfgProg
argument_list|,
name|ttl_len
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|ttlfmt
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
do|do
block|{
while|while
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
operator|++
name|pzText
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|strneqvcmp
argument_list|(
name|pzText
argument_list|,
name|pOpts
operator|->
name|pzProgName
argument_list|,
operator|(
name|int
operator|)
name|name_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IS_END_XML_TOKEN_CHAR
argument_list|(
name|pzText
index|[
name|name_len
index|]
argument_list|)
operator|)
condition|)
block|{
name|pzText
operator|+=
name|name_len
expr_stmt|;
break|break;
block|}
name|pzText
operator|=
name|strstr
argument_list|(
name|pzText
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pzText
operator|!=
name|NULL
condition|)
do|;
name|AGFREE
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzText
operator|!=
name|NULL
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|pzText
operator|==
name|NUL
condition|)
block|{
name|pzText
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
operator|(
name|pzText
operator|++
operator|)
operator|==
literal|'>'
condition|)
break|break;
block|}
return|return
name|pzText
return|;
block|}
end_function

begin_comment
comment|/**  *  "pzText" points to a '[' character.  *  The "traditional" [PROG_NAME] segmentation of the config file.  *  Do not ever mix with the "<?program prog-name>" variation.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handle_section
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|pOpts
operator|->
name|pzPROGNAME
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|pzText
operator|+
literal|1
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|pzText
index|[
name|len
operator|+
literal|1
index|]
operator|==
literal|']'
operator|)
condition|)
return|return
name|strchr
argument_list|(
name|pzText
operator|+
name|len
operator|+
literal|2
argument_list|,
literal|'\n'
argument_list|)
return|;
if|if
condition|(
name|len
operator|>
literal|16
condition|)
return|return
name|NULL
return|;
block|{
name|char
name|z
index|[
literal|24
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|z
argument_list|,
literal|"[%s]"
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
name|pzText
operator|=
name|strstr
argument_list|(
name|pzText
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pzText
operator|!=
name|NULL
condition|)
name|pzText
operator|=
name|strchr
argument_list|(
name|pzText
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
return|return
name|pzText
return|;
block|}
end_function

begin_comment
comment|/**  * parse XML encodings  */
end_comment

begin_function
specifier|static
name|int
name|parse_xml_encoding
parameter_list|(
name|char
modifier|*
modifier|*
name|ppz
parameter_list|)
block|{
define|#
directive|define
name|XMLTABLE
define|\
value|_xmlNm_(amp,   '&')     \         _xmlNm_(lt,    '<')     \         _xmlNm_(gt,    '>')     \         _xmlNm_(ff,    '\f')    \         _xmlNm_(ht,    '\t')    \         _xmlNm_(cr,    '\r')    \         _xmlNm_(vt,    '\v')    \         _xmlNm_(bel,   '\a')    \         _xmlNm_(nl,    '\n')    \         _xmlNm_(space, ' ')     \         _xmlNm_(quot,  '"')     \         _xmlNm_(apos,  '\'')
specifier|static
struct|struct
block|{
name|char
specifier|const
modifier|*
specifier|const
name|nm_str
decl_stmt|;
name|unsigned
name|short
name|nm_len
decl_stmt|;
name|short
name|nm_val
decl_stmt|;
block|}
decl|const
name|xml_names
index|[]
init|=
block|{
define|#
directive|define
name|_xmlNm_
parameter_list|(
name|_n
parameter_list|,
name|_v
parameter_list|)
value|{ #_n ";", sizeof(#_n), _v },
name|XMLTABLE
undef|#
directive|undef
name|_xmlNm_
undef|#
directive|undef
name|XMLTABLE
block|}
struct|;
specifier|static
name|int
specifier|const
name|nm_ct
init|=
sizeof|sizeof
argument_list|(
name|xml_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|xml_names
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|base
init|=
literal|10
decl_stmt|;
name|char
modifier|*
name|pz
init|=
operator|*
name|ppz
decl_stmt|;
if|if
condition|(
operator|*
name|pz
operator|==
literal|'#'
condition|)
block|{
name|pz
operator|++
expr_stmt|;
goto|goto
name|parse_number
goto|;
block|}
if|if
condition|(
name|IS_DEC_DIGIT_CHAR
argument_list|(
operator|*
name|pz
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|v
decl_stmt|;
name|parse_number
label|:
switch|switch
condition|(
operator|*
name|pz
condition|)
block|{
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
comment|/*              * Some forms specify hex with:&#xNN;              */
name|base
operator|=
literal|16
expr_stmt|;
name|pz
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
comment|/*              *&#0022; is hex and&#22; is decimal.  Cool.              *  Ya gotta love it.              */
if|if
condition|(
name|pz
index|[
literal|1
index|]
operator|==
literal|'0'
condition|)
name|base
operator|=
literal|16
expr_stmt|;
break|break;
block|}
name|v
operator|=
name|strtoul
argument_list|(
name|pz
argument_list|,
operator|&
name|pz
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pz
operator|!=
literal|';'
operator|)
operator|||
operator|(
name|v
operator|>
literal|0x7F
operator|)
condition|)
return|return
name|NUL
return|;
operator|*
name|ppz
operator|=
name|pz
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|v
return|;
block|}
block|{
name|int
name|ix
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|pz
argument_list|,
name|xml_names
index|[
name|ix
index|]
operator|.
name|nm_str
argument_list|,
name|xml_names
index|[
name|ix
index|]
operator|.
name|nm_len
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|ppz
operator|=
name|pz
operator|+
name|xml_names
index|[
name|ix
index|]
operator|.
name|nm_len
expr_stmt|;
return|return
name|xml_names
index|[
name|ix
index|]
operator|.
name|nm_val
return|;
block|}
block|}
do|while
condition|(
operator|++
name|ix
operator|<
name|nm_ct
condition|)
do|;
block|}
return|return
name|NUL
return|;
block|}
end_function

begin_comment
comment|/**  * Find the end marker for the named section of XML.  * Trim that text there, trimming trailing white space for all modes  * except for OPTION_LOAD_UNCOOKED.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|trim_xml_text
parameter_list|(
name|char
modifier|*
name|pztxt
parameter_list|,
name|char
specifier|const
modifier|*
name|pznm
parameter_list|,
name|tOptionLoadMode
name|mode
parameter_list|)
block|{
specifier|static
name|char
specifier|const
name|fmt
index|[]
init|=
literal|"</%s>"
decl_stmt|;
name|char
name|z
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|pz
init|=
name|z
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|pznm
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
operator|-
literal|2
comment|/* for %s */
decl_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|z
argument_list|)
condition|)
name|pz
operator|=
name|AGALOC
argument_list|(
name|len
argument_list|,
literal|"scan name"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pz
argument_list|,
name|fmt
argument_list|,
name|pznm
argument_list|)
expr_stmt|;
operator|*
name|pztxt
operator|=
literal|' '
expr_stmt|;
name|pztxt
operator|=
name|strstr
argument_list|(
name|pztxt
argument_list|,
name|pz
argument_list|)
expr_stmt|;
if|if
condition|(
name|pz
operator|!=
name|z
condition|)
name|AGFREE
argument_list|(
name|pz
argument_list|)
expr_stmt|;
if|if
condition|(
name|pztxt
operator|==
name|NULL
condition|)
return|return
name|pztxt
return|;
if|if
condition|(
name|mode
operator|!=
name|OPTION_LOAD_UNCOOKED
condition|)
while|while
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
name|pztxt
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|len
operator|++
operator|,
name|pztxt
operator|--
expr_stmt|;
operator|*
name|pztxt
operator|=
name|NUL
expr_stmt|;
return|return
name|pztxt
operator|+
name|len
operator|-
literal|1
comment|/* for NUL byte */
return|;
block|}
end_function

begin_comment
comment|/**  */
end_comment

begin_function
specifier|static
name|void
name|cook_xml_text
parameter_list|(
name|char
modifier|*
name|pzData
parameter_list|)
block|{
name|char
modifier|*
name|pzs
init|=
name|pzData
decl_stmt|;
name|char
modifier|*
name|pzd
init|=
name|pzData
decl_stmt|;
name|char
name|bf
index|[
literal|4
index|]
decl_stmt|;
name|bf
index|[
literal|2
index|]
operator|=
name|NUL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ch
init|=
operator|(
operator|(
name|int
operator|)
operator|*
operator|(
name|pzs
operator|++
operator|)
operator|)
operator|&
literal|0xFF
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|NUL
case|:
operator|*
name|pzd
operator|=
name|NUL
expr_stmt|;
return|return;
case|case
literal|'&'
case|:
operator|*
operator|(
name|pzd
operator|++
operator|)
operator|=
expr|\
name|ch
operator|=
name|parse_xml_encoding
argument_list|(
operator|&
name|pzs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NUL
condition|)
return|return;
break|break;
case|case
literal|'%'
case|:
name|bf
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|pzs
operator|++
operator|)
expr_stmt|;
name|bf
index|[
literal|1
index|]
operator|=
operator|*
operator|(
name|pzs
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bf
index|[
literal|0
index|]
operator|==
name|NUL
operator|)
operator|||
operator|(
name|bf
index|[
literal|1
index|]
operator|==
name|NUL
operator|)
condition|)
block|{
operator|*
name|pzd
operator|=
name|NUL
expr_stmt|;
return|return;
block|}
name|ch
operator|=
name|strtoul
argument_list|(
name|bf
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
operator|*
operator|(
name|pzd
operator|++
operator|)
operator|=
name|ch
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *  "pzText" points to a '<' character, followed by an alpha.  *  The end of the entry is either the "/>" following the name, or else a  *  "</name>" string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handle_struct
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|tOptionLoadMode
name|mode
init|=
name|option_load_mode
decl_stmt|;
name|tOptionValue
name|valu
decl_stmt|;
name|char
modifier|*
name|pzName
init|=
operator|++
name|pzText
decl_stmt|;
name|char
modifier|*
name|pzData
decl_stmt|;
name|char
modifier|*
name|pcNulPoint
decl_stmt|;
while|while
condition|(
name|IS_VALUE_NAME_CHAR
argument_list|(
operator|*
name|pzText
argument_list|)
condition|)
name|pzText
operator|++
expr_stmt|;
name|pcNulPoint
operator|=
name|pzText
expr_stmt|;
name|valu
operator|.
name|valType
operator|=
name|OPARG_TYPE_STRING
expr_stmt|;
switch|switch
condition|(
operator|*
name|pzText
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
name|pzText
operator|=
name|parseAttributes
argument_list|(
name|pOpts
argument_list|,
name|pzText
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|valu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pzText
operator|==
literal|'>'
condition|)
break|break;
if|if
condition|(
operator|*
name|pzText
operator|!=
literal|'/'
condition|)
return|return
name|NULL
return|;
comment|/* FALLTHROUGH */
case|case
literal|'/'
case|:
if|if
condition|(
name|pzText
index|[
literal|1
index|]
operator|!=
literal|'>'
condition|)
return|return
name|NULL
return|;
operator|*
name|pzText
operator|=
name|NUL
expr_stmt|;
name|pzText
operator|+=
literal|2
expr_stmt|;
name|loadOptionLine
argument_list|(
name|pOpts
argument_list|,
name|pOS
argument_list|,
name|pzName
argument_list|,
name|dir
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|pzText
return|;
case|case
literal|'>'
case|:
break|break;
default|default:
name|pzText
operator|=
name|strchr
argument_list|(
name|pzText
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzText
operator|!=
name|NULL
condition|)
name|pzText
operator|++
expr_stmt|;
return|return
name|pzText
return|;
block|}
comment|/*      *  If we are here, we have a value.  "pzText" points to a closing angle      *  bracket.  Separate the name from the value for a moment.      */
operator|*
name|pcNulPoint
operator|=
name|NUL
expr_stmt|;
name|pzData
operator|=
operator|++
name|pzText
expr_stmt|;
name|pzText
operator|=
name|trim_xml_text
argument_list|(
name|pzText
argument_list|,
name|pzName
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzText
operator|==
name|NULL
condition|)
return|return
name|pzText
return|;
comment|/*      *  Rejoin the name and value for parsing by "loadOptionLine()".      *  Erase any attributes parsed by "parseAttributes()".      */
name|memset
argument_list|(
name|pcNulPoint
argument_list|,
literal|' '
argument_list|,
name|pzData
operator|-
name|pcNulPoint
argument_list|)
expr_stmt|;
comment|/*      *  If we are getting a "string" value that is to be cooked,      *  then process the XML-ish&xx; XML-ish and %XX hex characters.      */
if|if
condition|(
operator|(
name|valu
operator|.
name|valType
operator|==
name|OPARG_TYPE_STRING
operator|)
operator|&&
operator|(
name|mode
operator|==
name|OPTION_LOAD_COOKED
operator|)
condition|)
name|cook_xml_text
argument_list|(
name|pzData
argument_list|)
expr_stmt|;
comment|/*      *  "pzName" points to what looks like text for one option/configurable.      *  It is NUL terminated.  Process it.      */
name|loadOptionLine
argument_list|(
name|pOpts
argument_list|,
name|pOS
argument_list|,
name|pzName
argument_list|,
name|dir
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|pzText
return|;
block|}
end_function

begin_comment
comment|/**  *  Load a configuration file.  This may be invoked either from  *  scanning the "homerc" list, or from a specific file request.  *  (see "optionFileLoad()", the implementation for --load-opts)  */
end_comment

begin_function
name|LOCAL
name|void
name|internalFileLoad
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|uint32_t
name|svfl
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|inc
decl_stmt|;
name|char
name|zFileName
index|[
name|AG_PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|pOpts
operator|->
name|papzHomeList
operator|==
name|NULL
condition|)
return|return;
name|svfl
operator|=
name|pOpts
operator|->
name|fOptSet
expr_stmt|;
name|inc
operator|=
name|DIRECTION_PRESET
expr_stmt|;
comment|/*      *  Never stop on errors in config files.      */
name|pOpts
operator|->
name|fOptSet
operator|&=
operator|~
name|OPTPROC_ERRSTOP
expr_stmt|;
comment|/*      *  Find the last RC entry (highest priority entry)      */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|pOpts
operator|->
name|papzHomeList
index|[
name|idx
operator|+
literal|1
index|]
operator|!=
name|NULL
condition|;
operator|++
name|idx
control|)
empty_stmt|;
comment|/*      *  For every path in the home list, ...  *TWICE* We start at the last      *  (highest priority) entry, work our way down to the lowest priority,      *  handling the immediate options.      *  Then we go back up, doing the normal options.      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|stat
name|StatBuf
decl_stmt|;
name|cch_t
modifier|*
name|pzPath
decl_stmt|;
comment|/*          *  IF we've reached the bottom end, change direction          */
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|inc
operator|=
name|DIRECTION_PROCESS
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
block|}
name|pzPath
operator|=
name|pOpts
operator|->
name|papzHomeList
index|[
name|idx
index|]
expr_stmt|;
comment|/*          *  IF we've reached the top end, bail out          */
if|if
condition|(
name|pzPath
operator|==
name|NULL
condition|)
break|break;
name|idx
operator|+=
name|inc
expr_stmt|;
if|if
condition|(
operator|!
name|optionMakePath
argument_list|(
name|zFileName
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|zFileName
argument_list|)
argument_list|,
name|pzPath
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|)
condition|)
continue|continue;
comment|/*          *  IF the file name we constructed is a directory,          *  THEN append the Resource Configuration file name          *  ELSE we must have the complete file name          */
if|if
condition|(
name|stat
argument_list|(
name|zFileName
argument_list|,
operator|&
name|StatBuf
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* bogus name - skip the home list entry */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|StatBuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|zFileName
argument_list|)
decl_stmt|;
name|size_t
name|nln
init|=
name|strlen
argument_list|(
name|pOpts
operator|->
name|pzRcName
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|pz
init|=
name|zFileName
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|+
name|nln
operator|>=
sizeof|sizeof
argument_list|(
name|zFileName
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pz
index|[
operator|-
literal|1
index|]
operator|!=
name|DIRCH
condition|)
operator|*
operator|(
name|pz
operator|++
operator|)
operator|=
name|DIRCH
expr_stmt|;
name|memcpy
argument_list|(
name|pz
argument_list|,
name|pOpts
operator|->
name|pzRcName
argument_list|,
name|nln
argument_list|)
expr_stmt|;
block|}
name|file_preset
argument_list|(
name|pOpts
argument_list|,
name|zFileName
argument_list|,
name|inc
argument_list|)
expr_stmt|;
comment|/*          *  IF we are now to skip config files AND we are presetting,          *  THEN change direction.  We must go the other way.          */
block|{
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pOpts
operator|->
name|specOptIdx
operator|.
name|save_opts
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|DISABLED_OPT
argument_list|(
name|pOD
argument_list|)
operator|&&
name|PRESETTING
argument_list|(
name|inc
argument_list|)
condition|)
block|{
name|idx
operator|-=
name|inc
expr_stmt|;
comment|/* go back and reprocess current file */
name|inc
operator|=
name|DIRECTION_PROCESS
expr_stmt|;
block|}
block|}
block|}
comment|/* twice for every path in the home list, ... */
name|pOpts
operator|->
name|fOptSet
operator|=
name|svfl
expr_stmt|;
block|}
end_function

begin_comment
comment|/*=export_func optionFileLoad  *  * what: Load the locatable config files, in order  *  * arg:  + tOptions*   + pOpts  + program options descriptor +  * arg:  + char const* + pzProg + program name +  *  * ret_type:  int  * ret_desc:  0 -> SUCCESS, -1 -> FAILURE  *  * doc:  *  * This function looks in all the specified directories for a configuration  * file ("rc" file or "ini" file) and processes any found twice.  The first  * time through, they are processed in reverse order (last file first).  At  * that time, only "immediate action" configurables are processed.  For  * example, if the last named file specifies not processing any more  * configuration files, then no more configuration files will be processed.  * Such an option in the @strong{first} named directory will have no effect.  *  * Once the immediate action configurables have been handled, then the  * directories are handled in normal, forward order.  In that way, later  * config files can override the settings of earlier config files.  *  * See the AutoOpts documentation for a thorough discussion of the  * config file format.  *  * Configuration files not found or not decipherable are simply ignored.  *  * err:  Returns the value, "-1" if the program options descriptor  *       is out of date or indecipherable.  Otherwise, the value "0" will  *       always be returned. =*/
end_comment

begin_function
name|int
name|optionFileLoad
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
specifier|const
modifier|*
name|pzProgram
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|validateOptionsStruct
argument_list|(
name|pOpts
argument_list|,
name|pzProgram
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|{
name|char
specifier|const
modifier|*
modifier|*
name|pp
init|=
operator|(
name|char
specifier|const
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|pOpts
operator|->
name|pzProgName
operator|)
decl_stmt|;
operator|*
name|pp
operator|=
name|pzProgram
expr_stmt|;
block|}
name|internalFileLoad
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionLoadOpt  * private:  *  * what:  Load an option rc/ini file  * arg:   + tOptions* + pOpts    + program options descriptor +  * arg:   + tOptDesc* + pOptDesc + the descriptor for this arg +  *  * doc:  *  Processes the options found in the file named with  *  pOptDesc->optArg.argString. =*/
end_comment

begin_function
name|void
name|optionLoadOpt
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOptDesc
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
comment|/*      *  IF the option is not being disabled, THEN load the file.  There must      *  be a file.  (If it is being disabled, then the disablement processing      *  already took place.  It must be done to suppress preloading of ini/rc      *  files.)      */
if|if
condition|(
name|DISABLED_OPT
argument_list|(
name|pOptDesc
argument_list|)
operator|||
operator|(
operator|(
name|pOptDesc
operator|->
name|fOptState
operator|&
name|OPTST_RESET
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return;
if|if
condition|(
name|stat
argument_list|(
name|pOptDesc
operator|->
name|optArg
operator|.
name|argString
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|==
literal|0
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zFSErrOptLoad
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|pOptDesc
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_NOINPUT
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|==
literal|0
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zNotFile
argument_list|,
name|pOptDesc
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_NOINPUT
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
name|file_preset
argument_list|(
name|pOpts
argument_list|,
name|pOptDesc
operator|->
name|optArg
operator|.
name|argString
argument_list|,
name|DIRECTION_CALLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  Parse the various attributes of an XML-styled config file entry  */
end_comment

begin_function
name|LOCAL
name|char
modifier|*
name|parseAttributes
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|tOptionLoadMode
modifier|*
name|pMode
parameter_list|,
name|tOptionValue
modifier|*
name|pType
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
name|pzText
argument_list|)
condition|)
switch|switch
condition|(
operator|*
name|pzText
condition|)
block|{
case|case
literal|'/'
case|:
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_NONE
expr_stmt|;
case|case
literal|'>'
case|:
return|return
name|pzText
return|;
default|default:
case|case
name|NUL
case|:
return|return
name|NULL
return|;
block|}
while|while
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
operator|++
name|pzText
argument_list|)
condition|)
empty_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|IS_LOWER_CASE_CHAR
argument_list|(
name|pzText
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|++
expr_stmt|;
switch|switch
condition|(
name|find_xat_attribute_id
argument_list|(
name|pzText
argument_list|,
name|len
argument_list|)
condition|)
block|{
case|case
name|XAT_KWD_TYPE
case|:
name|pzText
operator|=
name|parse_value
argument_list|(
name|pzText
operator|+
name|len
argument_list|,
name|pType
argument_list|)
expr_stmt|;
break|break;
case|case
name|XAT_KWD_WORDS
case|:
name|pzText
operator|=
name|parse_keyword
argument_list|(
name|pOpts
argument_list|,
name|pzText
operator|+
name|len
argument_list|,
name|pType
argument_list|)
expr_stmt|;
break|break;
case|case
name|XAT_KWD_MEMBERS
case|:
name|pzText
operator|=
name|parse_set_mem
argument_list|(
name|pOpts
argument_list|,
name|pzText
operator|+
name|len
argument_list|,
name|pType
argument_list|)
expr_stmt|;
break|break;
case|case
name|XAT_KWD_COOKED
case|:
name|pzText
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|IS_END_XML_TOKEN_CHAR
argument_list|(
operator|*
name|pzText
argument_list|)
condition|)
goto|goto
name|invalid_kwd
goto|;
operator|*
name|pMode
operator|=
name|OPTION_LOAD_COOKED
expr_stmt|;
break|break;
case|case
name|XAT_KWD_UNCOOKED
case|:
name|pzText
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|IS_END_XML_TOKEN_CHAR
argument_list|(
operator|*
name|pzText
argument_list|)
condition|)
goto|goto
name|invalid_kwd
goto|;
operator|*
name|pMode
operator|=
name|OPTION_LOAD_UNCOOKED
expr_stmt|;
break|break;
case|case
name|XAT_KWD_KEEP
case|:
name|pzText
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|IS_END_XML_TOKEN_CHAR
argument_list|(
operator|*
name|pzText
argument_list|)
condition|)
goto|goto
name|invalid_kwd
goto|;
operator|*
name|pMode
operator|=
name|OPTION_LOAD_KEEP
expr_stmt|;
break|break;
default|default:
case|case
name|XAT_KWD_INVALID
case|:
name|invalid_kwd
label|:
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_NONE
expr_stmt|;
return|return
name|skip_unkn
argument_list|(
name|pzText
argument_list|)
return|;
block|}
block|}
do|while
condition|(
name|pzText
operator|!=
name|NULL
condition|)
do|;
return|return
name|pzText
return|;
block|}
end_function

begin_comment
comment|/**  *  "pzText" points to the character after "words=".  *  What should follow is a name of a keyword (enumeration) list.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_keyword
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|tOptionValue
modifier|*
name|pType
parameter_list|)
block|{
return|return
name|skip_unkn
argument_list|(
name|pzText
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  "pzText" points to the character after "members="  *  What should follow is a name of a "set membership".  *  A collection of bit flags.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_set_mem
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzText
parameter_list|,
name|tOptionValue
modifier|*
name|pType
parameter_list|)
block|{
return|return
name|skip_unkn
argument_list|(
name|pzText
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  "pzText" points to the character after "type="  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_value
parameter_list|(
name|char
modifier|*
name|pzText
parameter_list|,
name|tOptionValue
modifier|*
name|pType
parameter_list|)
block|{
name|size_t
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|pzText
operator|++
operator|)
operator|!=
literal|'='
condition|)
goto|goto
name|woops
goto|;
while|while
condition|(
name|IS_OPTION_NAME_CHAR
argument_list|(
name|pzText
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|++
expr_stmt|;
name|pzText
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|!
name|IS_END_XML_TOKEN_CHAR
argument_list|(
operator|*
name|pzText
argument_list|)
operator|)
condition|)
block|{
name|woops
label|:
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_NONE
expr_stmt|;
return|return
name|skip_unkn
argument_list|(
name|pzText
argument_list|)
return|;
block|}
switch|switch
condition|(
name|find_value_type_id
argument_list|(
name|pzText
operator|-
name|len
argument_list|,
name|len
argument_list|)
condition|)
block|{
default|default:
case|case
name|VTP_KWD_INVALID
case|:
goto|goto
name|woops
goto|;
case|case
name|VTP_KWD_STRING
case|:
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_STRING
expr_stmt|;
break|break;
case|case
name|VTP_KWD_INTEGER
case|:
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_NUMERIC
expr_stmt|;
break|break;
case|case
name|VTP_KWD_BOOL
case|:
case|case
name|VTP_KWD_BOOLEAN
case|:
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_BOOLEAN
expr_stmt|;
break|break;
case|case
name|VTP_KWD_KEYWORD
case|:
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_ENUMERATION
expr_stmt|;
break|break;
case|case
name|VTP_KWD_SET
case|:
case|case
name|VTP_KWD_SET_MEMBERSHIP
case|:
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_MEMBERSHIP
expr_stmt|;
break|break;
case|case
name|VTP_KWD_NESTED
case|:
case|case
name|VTP_KWD_HIERARCHY
case|:
name|pType
operator|->
name|valType
operator|=
name|OPARG_TYPE_HIERARCHY
expr_stmt|;
block|}
return|return
name|pzText
return|;
block|}
end_function

begin_comment
comment|/**  *  Skip over some unknown attribute  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|skip_unkn
parameter_list|(
name|char
modifier|*
name|pzText
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
name|pzText
operator|++
control|)
block|{
if|if
condition|(
name|IS_END_XML_TOKEN_CHAR
argument_list|(
operator|*
name|pzText
argument_list|)
condition|)
return|return
name|pzText
return|;
if|if
condition|(
operator|*
name|pzText
operator|==
name|NUL
condition|)
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/**  *  Make sure the option descriptor is there and that we understand it.  *  This should be called from any user entry point where one needs to  *  worry about validity.  (Some entry points are free to assume that  *  the call is not the first to the library and, thus, that this has  *  already been called.)  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|validateOptionsStruct
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
specifier|const
modifier|*
name|pzProgram
parameter_list|)
block|{
if|if
condition|(
name|pOpts
operator|==
name|NULL
condition|)
block|{
name|fputs
argument_list|(
name|zAO_Bad
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_CONFIG
argument_list|)
expr_stmt|;
block|}
comment|/*      *  IF the client has enabled translation and the translation procedure      *  is available, then go do it.      */
if|if
condition|(
operator|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_TRANSLATE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|pOpts
operator|->
name|pTransProc
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/*          *  If option names are not to be translated at all, then do not do          *  it for configuration parsing either.  (That is the bit that really          *  gets tested anyway.)          */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_NO_XLAT_MASK
operator|)
operator|==
name|OPTPROC_NXLAT_OPT
condition|)
name|pOpts
operator|->
name|fOptSet
operator||=
name|OPTPROC_NXLAT_OPT_CFG
expr_stmt|;
call|(
modifier|*
name|pOpts
operator|->
name|pTransProc
call|)
argument_list|()
expr_stmt|;
name|pOpts
operator|->
name|fOptSet
operator|&=
operator|~
name|OPTPROC_TRANSLATE
expr_stmt|;
block|}
comment|/*      *  IF the struct version is not the current, and also      *     either too large (?!) or too small,      *  THEN emit error message and fail-exit      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|structVersion
operator|!=
name|OPTIONS_STRUCT_VERSION
operator|)
operator|&&
operator|(
operator|(
name|pOpts
operator|->
name|structVersion
operator|>
name|OPTIONS_STRUCT_VERSION
operator|)
operator|||
operator|(
name|pOpts
operator|->
name|structVersion
operator|<
name|OPTIONS_MINIMUM_VERSION
operator|)
operator|)
condition|)
block|{
specifier|static
name|char
specifier|const
name|aover
index|[]
init|=
name|__STR
argument_list|(
name|AO_CURRENT
argument_list|)
literal|":"
name|__STR
argument_list|(
name|AO_REVISION
argument_list|)
literal|":"
name|__STR
argument_list|(
name|AO_AGE
argument_list|)
literal|"\n"
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zAO_Err
argument_list|,
name|pzProgram
argument_list|,
name|NUM_TO_VER
argument_list|(
name|pOpts
operator|->
name|structVersion
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pOpts
operator|->
name|structVersion
operator|>
name|OPTIONS_STRUCT_VERSION
condition|)
name|fputs
argument_list|(
name|zAO_Big
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|zAO_Sml
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|aover
argument_list|,
sizeof|sizeof
argument_list|(
name|aover
argument_list|)
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
comment|/*      *  If the program name hasn't been set, then set the name and the path      *  and the set of equivalent characters.      */
if|if
condition|(
name|pOpts
operator|->
name|pzProgName
operator|==
name|NULL
condition|)
block|{
name|char
specifier|const
modifier|*
name|pz
init|=
name|strrchr
argument_list|(
name|pzProgram
argument_list|,
name|DIRCH
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|pp
init|=
operator|(
name|char
specifier|const
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
operator|(
name|pOpts
operator|->
name|pzProgName
operator|)
decl_stmt|;
if|if
condition|(
name|pz
operator|==
name|NULL
condition|)
operator|*
name|pp
operator|=
name|pzProgram
expr_stmt|;
else|else
operator|*
name|pp
operator|=
name|pz
operator|+
literal|1
expr_stmt|;
name|pp
operator|=
operator|(
name|char
specifier|const
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
operator|(
name|pOpts
operator|->
name|pzProgPath
operator|)
expr_stmt|;
operator|*
name|pp
operator|=
name|pzProgram
expr_stmt|;
comment|/*          *  when comparing long names, these are equivalent          */
name|strequate
argument_list|(
name|zSepChars
argument_list|)
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/configfile.c */
end_comment

end_unit

