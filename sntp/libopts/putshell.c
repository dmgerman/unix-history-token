begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file putshell.c  *  * Time-stamp:      "2010-09-05 06:10:56 bkorb"  *  *  This module will interpret the options set in the tOptions  *  structure and print them to standard out in a fashion that  *  will allow them to be interpreted by the Bourne or Korn shells.  *  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (c) 1992-2011 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following md5sums:  *  *  43b91e8ca915626ed3818ffb1b71248b pkg/libopts/COPYING.gplv3  *  06a1a2e4760c90ea5e1dad8dfaac4d39 pkg/libopts/COPYING.lgplv3  *  66a5cedaf62c4b2637025f049f9b826f pkg/libopts/COPYING.mbsd  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zOptValFmt
index|[]
init|=
literal|"%s_%s="
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zOptEnd
index|[]
init|=
literal|"\nexport %s_%s\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zOptNumFmt
index|[]
init|=
literal|"%1$s_%2$s=%3$d # 0x%3$X\nexport %1$s_%2$s\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|void
name|print_quot_str
parameter_list|(
name|tCC
modifier|*
name|pzStr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_enumeration
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_membership
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_stacked_arg
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_reordering
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/*  *  Make sure embedded single quotes come out okay.  The initial quote has  *  been emitted and the closing quote will be upon return.  */
end_comment

begin_function
specifier|static
name|void
name|print_quot_str
parameter_list|(
name|tCC
modifier|*
name|pzStr
parameter_list|)
block|{
comment|/*      *  Handle empty strings to make the rest of the logic simpler.      */
if|if
condition|(
operator|(
name|pzStr
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|pzStr
operator|==
name|NUL
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"''"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      *  Emit any single quotes/apostrophes at the start of the string and      *  bail if that is all we need to do.      */
while|while
condition|(
operator|*
name|pzStr
operator|==
literal|'\''
condition|)
block|{
name|fputs
argument_list|(
literal|"\\'"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|pzStr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pzStr
operator|==
name|NUL
condition|)
return|return;
comment|/*      *  Start the single quote string      */
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tCC
modifier|*
name|pz
init|=
name|strchr
argument_list|(
name|pzStr
argument_list|,
literal|'\''
argument_list|)
decl_stmt|;
if|if
condition|(
name|pz
operator|==
name|NULL
condition|)
break|break;
comment|/*          *  Emit the string up to the single quote (apostrophe) we just found.          */
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|pzStr
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|pz
operator|-
name|pzStr
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|pzStr
operator|=
name|pz
expr_stmt|;
comment|/*          *  Emit an escaped apostrophe for every one we find.          *  If that ends the string, do not re-open the single quotes.          */
while|while
condition|(
operator|*
operator|++
name|pzStr
operator|==
literal|'\''
condition|)
name|fputs
argument_list|(
literal|"\\'"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pzStr
operator|==
name|NUL
condition|)
return|return;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/*      *  If we broke out of the loop, we must still emit the remaining text      *  and then close the single quote string.      */
name|fputs
argument_list|(
name|pzStr
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_enumeration
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
block|{
name|uintptr_t
name|e_val
init|=
name|pOD
operator|->
name|optArg
operator|.
name|argEnum
decl_stmt|;
name|printf
argument_list|(
name|zOptValFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
comment|/*      *  Convert value to string, print that and restore numeric value.      */
operator|(
operator|*
operator|(
name|pOD
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|OPTPROC_RETURN_VALNAME
operator|,
name|pOD
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"'%s'"
argument_list|,
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
if|if
condition|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ALLOC_ARG
condition|)
name|AGFREE
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|pOD
operator|->
name|optArg
operator|.
name|argEnum
operator|=
name|e_val
expr_stmt|;
name|printf
argument_list|(
name|zOptEnd
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_membership
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|pz
decl_stmt|;
name|uintptr_t
name|val
init|=
literal|1
decl_stmt|;
name|printf
argument_list|(
name|zOptNumFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
call|(
name|int
call|)
argument_list|(
name|uintptr_t
argument_list|)
argument_list|(
name|pOD
operator|->
name|optCookie
argument_list|)
argument_list|)
expr_stmt|;
name|pOD
operator|->
name|optCookie
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|~
literal|0UL
expr_stmt|;
operator|(
operator|*
operator|(
name|pOD
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|OPTPROC_RETURN_VALNAME
operator|,
name|pOD
operator|)
expr_stmt|;
comment|/*      *  We are building the typeset list.  The list returned starts with      *  'none + ' for use by option saving stuff.  We must ignore that.      */
name|pz
operator|=
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|+
literal|7
expr_stmt|;
while|while
condition|(
operator|*
name|pz
operator|!=
name|NUL
condition|)
block|{
name|printf
argument_list|(
literal|"typeset -x -i %s_"
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
while|while
condition|(
name|IS_PLUS_N_SPACE_CHAR
argument_list|(
operator|*
name|pz
argument_list|)
condition|)
name|pz
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ch
init|=
operator|*
operator|(
name|pz
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|IS_LOWER_CASE_CHAR
argument_list|(
name|ch
argument_list|)
condition|)
name|fputc
argument_list|(
name|toupper
argument_list|(
name|ch
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_UPPER_CASE_CHAR
argument_list|(
name|ch
argument_list|)
condition|)
name|fputc
argument_list|(
name|ch
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_PLUS_N_SPACE_CHAR
argument_list|(
name|ch
argument_list|)
condition|)
goto|goto
name|name_done
goto|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|NUL
condition|)
block|{
name|pz
operator|--
expr_stmt|;
goto|goto
name|name_done
goto|;
block|}
else|else
name|fputc
argument_list|(
literal|'_'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|name_done
label|:
empty_stmt|;
name|printf
argument_list|(
literal|"=%1$lu # 0x%1$lX\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|1
expr_stmt|;
block|}
name|AGFREE
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|=
name|NULL
expr_stmt|;
name|pOD
operator|->
name|fOptState
operator|&=
operator|~
name|OPTST_ALLOC_ARG
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_stacked_arg
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
block|{
name|tSCC
name|zOptCookieCt
index|[]
init|=
literal|"%1$s_%2$s_CT=%3$d\nexport %1$s_%2$s_CT\n"
decl_stmt|;
name|tArgList
modifier|*
name|pAL
init|=
operator|(
name|tArgList
operator|*
operator|)
name|pOD
operator|->
name|optCookie
decl_stmt|;
name|tCC
modifier|*
modifier|*
name|ppz
init|=
name|pAL
operator|->
name|apzArgs
decl_stmt|;
name|int
name|ct
init|=
name|pAL
operator|->
name|useCt
decl_stmt|;
name|printf
argument_list|(
name|zOptCookieCt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
name|ct
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|ct
operator|>=
literal|0
condition|)
block|{
name|tSCC
name|numarg_z
index|[]
init|=
literal|"%s_%s_%d="
decl_stmt|;
name|tSCC
name|end_z
index|[]
init|=
literal|"\nexport %s_%s_%d\n"
decl_stmt|;
name|printf
argument_list|(
name|numarg_z
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
name|pAL
operator|->
name|useCt
operator|-
name|ct
argument_list|)
expr_stmt|;
name|print_quot_str
argument_list|(
operator|*
operator|(
name|ppz
operator|++
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|end_z
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
name|pAL
operator|->
name|useCt
operator|-
name|ct
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_reordering
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|int
name|optIx
decl_stmt|;
name|fputs
argument_list|(
literal|"set --"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|optIx
operator|=
name|pOpts
operator|->
name|curOptIdx
init|;
name|optIx
operator|<
name|pOpts
operator|->
name|origArgCt
condition|;
name|optIx
operator|++
control|)
block|{
name|char
modifier|*
name|pzArg
init|=
name|pOpts
operator|->
name|origArgVect
index|[
name|optIx
index|]
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|pzArg
argument_list|,
literal|'\''
argument_list|)
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|" '%s'"
argument_list|,
name|pzArg
argument_list|)
expr_stmt|;
else|else
block|{
name|fputs
argument_list|(
literal|" '"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|ch
init|=
operator|*
operator|(
name|pzArg
operator|++
operator|)
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\''
case|:
name|fputs
argument_list|(
literal|"'\\''"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUL
case|:
goto|goto
name|arg_done
goto|;
default|default:
name|fputc
argument_list|(
name|ch
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|arg_done
label|:
empty_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
literal|"\nOPTION_CT=0\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*=export_func  optionPutShell  * what:  write a portable shell script to parse options  * private:  * arg:   tOptions*, pOpts, the program options descriptor  * doc:   This routine will emit portable shell script text for parsing  *        the options described in the option definitions. =*/
end_comment

begin_function
name|void
name|optionPutShell
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|int
name|optIx
init|=
literal|0
decl_stmt|;
name|tSCC
name|zOptCtFmt
index|[]
init|=
literal|"OPTION_CT=%d\nexport OPTION_CT\n"
decl_stmt|;
name|tSCC
name|zOptDisabl
index|[]
init|=
literal|"%1$s_%2$s=%3$s\nexport %1$s_%2$s\n"
decl_stmt|;
name|tSCC
name|zFullOptFmt
index|[]
init|=
literal|"%1$s_%2$s='%3$s'\nexport %1$s_%2$s\n"
decl_stmt|;
name|tSCC
name|zEquivMode
index|[]
init|=
literal|"%1$s_%2$s_MODE='%3$s'\nexport %1$s_%2$s_MODE\n"
decl_stmt|;
name|printf
argument_list|(
name|zOptCtFmt
argument_list|,
name|pOpts
operator|->
name|curOptIdx
operator|-
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|optIx
decl_stmt|;
if|if
condition|(
name|SKIP_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
continue|continue;
comment|/*          *  Equivalence classes are hard to deal with.  Where the          *  option data wind up kind of squishes around.  For the purposes          *  of emitting shell state, they are not recommended, but we'll          *  do something.  I guess we'll emit the equivalenced-to option          *  at the point in time when the base option is found.          */
if|if
condition|(
name|pOD
operator|->
name|optEquivIndex
operator|!=
name|NO_EQUIVALENT
condition|)
continue|continue;
comment|/* equivalence to a different option */
comment|/*          *  Equivalenced to a different option.  Process the current option          *  as the equivalenced-to option.  Keep the persistent state bits,          *  but copy over the set-state bits.          */
if|if
condition|(
name|pOD
operator|->
name|optActualIndex
operator|!=
name|optIx
condition|)
block|{
name|tOptDesc
modifier|*
name|p
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pOD
operator|->
name|optActualIndex
decl_stmt|;
name|p
operator|->
name|optArg
operator|=
name|pOD
operator|->
name|optArg
expr_stmt|;
name|p
operator|->
name|fOptState
operator|&=
name|OPTST_PERSISTENT_MASK
expr_stmt|;
name|p
operator|->
name|fOptState
operator||=
name|pOD
operator|->
name|fOptState
operator|&
operator|~
name|OPTST_PERSISTENT_MASK
expr_stmt|;
name|printf
argument_list|(
name|zEquivMode
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
name|p
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
name|pOD
operator|=
name|p
expr_stmt|;
block|}
comment|/*          *  If the argument type is a set membership bitmask, then we always          *  emit the thing.  We do this because it will always have some sort          *  of bitmask value and we need to emit the bit values.          */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_MEMBERSHIP
condition|)
block|{
name|print_membership
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          *  IF the option was either specified or it wakes up enabled,          *  then we will emit information.  Otherwise, skip it.          *  The idea is that if someone defines an option to initialize          *  enabled, we should tell our shell script that it is enabled.          */
if|if
condition|(
name|UNUSED_OPT
argument_list|(
name|pOD
argument_list|)
operator|&&
name|DISABLED_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|/*          *  Handle stacked arguments          */
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_STACKED
operator|)
operator|&&
operator|(
name|pOD
operator|->
name|optCookie
operator|!=
name|NULL
operator|)
condition|)
block|{
name|print_stacked_arg
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          *  If the argument has been disabled,          *  Then set its value to the disablement string          */
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_DISABLED
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
name|zOptDisabl
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
operator|(
name|pOD
operator|->
name|pz_DisablePfx
operator|!=
name|NULL
operator|)
condition|?
name|pOD
operator|->
name|pz_DisablePfx
else|:
literal|"false"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          *  If the argument type is numeric, the last arg pointer          *  is really the VALUE of the string that was pointed to.          */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_NUMERIC
condition|)
block|{
name|printf
argument_list|(
name|zOptNumFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
operator|(
name|int
operator|)
name|pOD
operator|->
name|optArg
operator|.
name|argInt
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          *  If the argument type is an enumeration, then it is much          *  like a text value, except we call the callback function          *  to emit the value corresponding to the "optArg" number.          */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_ENUMERATION
condition|)
block|{
name|print_enumeration
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          *  If the argument type is numeric, the last arg pointer          *  is really the VALUE of the string that was pointed to.          */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_BOOLEAN
condition|)
block|{
name|printf
argument_list|(
name|zFullOptFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
operator|(
name|pOD
operator|->
name|optArg
operator|.
name|argBool
operator|==
literal|0
operator|)
condition|?
literal|"false"
else|:
literal|"true"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          *  IF the option has an empty value,          *  THEN we set the argument to the occurrence count.          */
if|if
condition|(
operator|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
index|[
literal|0
index|]
operator|==
name|NUL
operator|)
condition|)
block|{
name|printf
argument_list|(
name|zOptNumFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
name|pOD
operator|->
name|optOccCt
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          *  This option has a text value          */
name|printf
argument_list|(
name|zOptValFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
name|print_quot_str
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|zOptEnd
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|optIx
operator|<
name|pOpts
operator|->
name|presetOptCt
condition|)
do|;
if|if
condition|(
operator|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_REORDER
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|pOpts
operator|->
name|curOptIdx
operator|<
name|pOpts
operator|->
name|origArgCt
operator|)
condition|)
name|print_reordering
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/putshell.c */
end_comment

end_unit

