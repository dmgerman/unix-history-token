begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file enumeration.c  *  * Time-stamp:      "2011-04-06 10:48:22 bkorb"  *  *   Automated Options Paged Usage module.  *  *  This routine will run run-on options through a pager so the  *  user may examine, print or edit them at their leisure.  *  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (c) 1992-2011 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following md5sums:  *  *  43b91e8ca915626ed3818ffb1b71248b pkg/libopts/COPYING.gplv3  *  06a1a2e4760c90ea5e1dad8dfaac4d39 pkg/libopts/COPYING.lgplv3  *  66a5cedaf62c4b2637025f049f9b826f pkg/libopts/COPYING.mbsd  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|pz_enum_err_fmt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|void
name|enum_err
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|int
name|name_ct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uintptr_t
name|find_name
parameter_list|(
name|char
specifier|const
modifier|*
name|pzName
parameter_list|,
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_memb_usage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_memb_shell
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_memb_names
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_function
specifier|static
name|void
name|enum_err
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|int
name|name_ct
parameter_list|)
block|{
name|size_t
name|max_len
init|=
literal|0
decl_stmt|;
name|size_t
name|ttl_len
init|=
literal|0
decl_stmt|;
name|int
name|ct_down
init|=
name|name_ct
decl_stmt|;
name|int
name|hidden
init|=
literal|0
decl_stmt|;
comment|/*      *  A real "pOpts" pointer means someone messed up.  Give a real error.      */
if|if
condition|(
name|pOpts
operator|>
name|OPTPROC_EMIT_LIMIT
condition|)
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|pz_enum_err_fmt
argument_list|,
name|pOpts
operator|->
name|pzProgName
argument_list|,
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zValidKeys
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
comment|/*      *  If the first name starts with this funny character, then we have      *  a first value with an unspellable name.  You cannot specify it.      *  So, we don't list it either.      */
if|if
condition|(
operator|*
operator|*
name|paz_names
operator|==
literal|0x7F
condition|)
block|{
name|paz_names
operator|++
expr_stmt|;
name|hidden
operator|=
literal|1
expr_stmt|;
name|ct_down
operator|=
operator|--
name|name_ct
expr_stmt|;
block|}
comment|/*      *  Figure out the maximum length of any name, plus the total length      *  of all the names.      */
block|{
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz
init|=
name|paz_names
decl_stmt|;
do|do
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
operator|*
operator|(
name|paz
operator|++
operator|)
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|max_len
condition|)
name|max_len
operator|=
name|len
expr_stmt|;
name|ttl_len
operator|+=
name|len
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ct_down
operator|>
literal|0
condition|)
do|;
name|ct_down
operator|=
name|name_ct
expr_stmt|;
block|}
comment|/*      *  IF any one entry is about 1/2 line or longer, print one per line      */
if|if
condition|(
name|max_len
operator|>
literal|35
condition|)
block|{
do|do
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
literal|"  %s\n"
argument_list|,
operator|*
operator|(
name|paz_names
operator|++
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ct_down
operator|>
literal|0
condition|)
do|;
block|}
comment|/*      *  ELSE IF they all fit on one line, then do so.      */
elseif|else
if|if
condition|(
name|ttl_len
operator|<
literal|76
condition|)
block|{
name|fputc
argument_list|(
literal|' '
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
do|do
block|{
name|fputc
argument_list|(
literal|' '
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
operator|*
operator|(
name|paz_names
operator|++
operator|)
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ct_down
operator|>
literal|0
condition|)
do|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
comment|/*      *  Otherwise, columnize the output      */
else|else
block|{
name|int
name|ent_no
init|=
literal|0
decl_stmt|;
name|char
name|zFmt
index|[
literal|16
index|]
decl_stmt|;
comment|/* format for all-but-last entries on a line */
name|sprintf
argument_list|(
name|zFmt
argument_list|,
literal|"%%-%ds"
argument_list|,
operator|(
name|int
operator|)
name|max_len
argument_list|)
expr_stmt|;
name|max_len
operator|=
literal|78
operator|/
name|max_len
expr_stmt|;
comment|/* max_len is now max entries on a line */
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*          *  Loop through all but the last entry          */
name|ct_down
operator|=
name|name_ct
expr_stmt|;
while|while
condition|(
operator|--
name|ct_down
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|ent_no
operator|==
name|max_len
condition|)
block|{
comment|/*                  *  Last entry on a line.  Start next line, too.                  */
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
literal|"%s\n  "
argument_list|,
operator|*
operator|(
name|paz_names
operator|++
operator|)
argument_list|)
expr_stmt|;
name|ent_no
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zFmt
argument_list|,
operator|*
operator|(
name|paz_names
operator|++
operator|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
literal|"%s\n"
argument_list|,
operator|*
name|paz_names
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pOpts
operator|>
name|OPTPROC_EMIT_LIMIT
condition|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zIntRange
argument_list|,
name|hidden
argument_list|,
name|name_ct
operator|-
literal|1
operator|+
name|hidden
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|pOpts
operator|->
name|pUsageProc
operator|)
operator|)
operator|(
name|pOpts
operator|,
name|EXIT_FAILURE
operator|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_MEMBERSHIP
condition|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zLowerBits
argument_list|,
name|name_ct
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zSetMemberSettings
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zIntRange
argument_list|,
name|hidden
argument_list|,
name|name_ct
operator|-
literal|1
operator|+
name|hidden
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uintptr_t
name|find_name
parameter_list|(
name|char
specifier|const
modifier|*
name|pzName
parameter_list|,
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
block|{
comment|/*      *  Return the matching index as a pointer sized integer.      *  The result gets stashed in a char* pointer.      */
name|uintptr_t
name|res
init|=
name|name_ct
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pzName
argument_list|)
decl_stmt|;
name|uintptr_t
name|idx
decl_stmt|;
if|if
condition|(
name|IS_DEC_DIGIT_CHAR
argument_list|(
operator|*
name|pzName
argument_list|)
condition|)
block|{
name|char
modifier|*
name|pz
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|pzName
decl_stmt|;
name|unsigned
name|long
name|val
init|=
name|strtoul
argument_list|(
name|pz
argument_list|,
operator|&
name|pz
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|pz
operator|==
name|NUL
operator|)
operator|&&
operator|(
name|val
operator|<
name|name_ct
operator|)
condition|)
return|return
operator|(
name|uintptr_t
operator|)
name|val
return|;
name|enum_err
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
operator|(
name|int
operator|)
name|name_ct
argument_list|)
expr_stmt|;
return|return
name|name_ct
return|;
block|}
comment|/*      *  Look for an exact match, but remember any partial matches.      *  Multiple partial matches means we have an ambiguous match.      */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|name_ct
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|paz_names
index|[
name|idx
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pzName
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|paz_names
index|[
name|idx
index|]
index|[
name|len
index|]
operator|==
name|NUL
condition|)
return|return
name|idx
return|;
comment|/* full match */
name|res
operator|=
operator|(
name|res
operator|!=
name|name_ct
operator|)
condition|?
operator|~
literal|0
else|:
name|idx
expr_stmt|;
comment|/* save partial match */
block|}
block|}
if|if
condition|(
name|res
operator|<
name|name_ct
condition|)
return|return
name|res
return|;
comment|/* partial match */
name|pz_enum_err_fmt
operator|=
operator|(
name|res
operator|==
name|name_ct
operator|)
condition|?
name|zNoKey
else|:
name|zAmbigKey
expr_stmt|;
name|option_usage_fp
operator|=
name|stderr
expr_stmt|;
name|enum_err
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
operator|(
name|int
operator|)
name|name_ct
argument_list|)
expr_stmt|;
return|return
name|name_ct
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionKeywordName  * what:  Convert between enumeration values and strings  * private:  *  * arg:   tOptDesc*,     pOD,       enumeration option description  * arg:   unsigned int,  enum_val,  the enumeration value to map  *  * ret_type:  char const *  * ret_desc:  the enumeration name from const memory  *  * doc:   This converts an enumeration value into the matching string. =*/
end_comment

begin_function
name|char
specifier|const
modifier|*
name|optionKeywordName
parameter_list|(
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|unsigned
name|int
name|enum_val
parameter_list|)
block|{
name|tOptDesc
name|od
decl_stmt|;
name|od
operator|.
name|optArg
operator|.
name|argEnum
operator|=
name|enum_val
expr_stmt|;
operator|(
operator|*
operator|(
name|pOD
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|OPTPROC_RETURN_VALNAME
operator|,
operator|&
name|od
operator|)
expr_stmt|;
return|return
name|od
operator|.
name|optArg
operator|.
name|argString
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionEnumerationVal  * what:  Convert from a string to an enumeration value  * private:  *  * arg:   tOptions*,     pOpts,     the program options descriptor  * arg:   tOptDesc*,     pOD,       enumeration option description  * arg:   char const * const *,  paz_names, list of enumeration names  * arg:   unsigned int,  name_ct,   number of names in list  *  * ret_type:  uintptr_t  * ret_desc:  the enumeration value  *  * doc:   This converts the optArg.argString string from the option description  *        into the index corresponding to an entry in the name list.  *        This will match the generated enumeration value.  *        Full matches are always accepted.  Partial matches are accepted  *        if there is only one partial match. =*/
end_comment

begin_function
name|uintptr_t
name|optionEnumerationVal
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
block|{
name|uintptr_t
name|res
init|=
literal|0UL
decl_stmt|;
comment|/*      *  IF the program option descriptor pointer is invalid,      *  then it is some sort of special request.      */
switch|switch
condition|(
operator|(
name|uintptr_t
operator|)
name|pOpts
condition|)
block|{
case|case
operator|(
name|uintptr_t
operator|)
name|OPTPROC_EMIT_USAGE
case|:
comment|/*          *  print the list of enumeration names.          */
name|enum_err
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
operator|(
name|int
operator|)
name|name_ct
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|uintptr_t
operator|)
name|OPTPROC_EMIT_SHELL
case|:
block|{
name|unsigned
name|int
name|ix
init|=
name|pOD
operator|->
name|optArg
operator|.
name|argEnum
decl_stmt|;
comment|/*          *  print the name string.          */
if|if
condition|(
name|ix
operator|>=
name|name_ct
condition|)
name|printf
argument_list|(
literal|"INVALID-%d"
argument_list|,
name|ix
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|paz_names
index|[
name|ix
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|uintptr_t
operator|)
name|OPTPROC_RETURN_VALNAME
case|:
block|{
name|tSCC
name|zInval
index|[]
init|=
literal|"*INVALID*"
decl_stmt|;
name|unsigned
name|int
name|ix
init|=
name|pOD
operator|->
name|optArg
operator|.
name|argEnum
decl_stmt|;
comment|/*          *  Replace the enumeration value with the name string.          */
if|if
condition|(
name|ix
operator|>=
name|name_ct
condition|)
return|return
operator|(
name|uintptr_t
operator|)
name|zInval
return|;
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|=
name|paz_names
index|[
name|ix
index|]
expr_stmt|;
break|break;
block|}
default|default:
name|res
operator|=
name|find_name
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|,
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
name|name_ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ALLOC_ARG
condition|)
block|{
name|AGFREE
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|pOD
operator|->
name|fOptState
operator|&=
operator|~
name|OPTST_ALLOC_ARG
expr_stmt|;
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_memb_usage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
block|{
comment|/*      *  print the list of enumeration names.      */
name|enum_err
argument_list|(
name|OPTPROC_EMIT_USAGE
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
operator|(
name|int
operator|)
name|name_ct
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_memb_shell
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
block|{
comment|/*      *  print the name string.      */
name|int
name|ix
init|=
literal|0
decl_stmt|;
name|uintptr_t
name|bits
init|=
operator|(
name|uintptr_t
operator|)
name|pOD
operator|->
name|optCookie
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|bits
operator|&=
operator|(
operator|(
name|uintptr_t
operator|)
literal|1
operator|<<
operator|(
name|uintptr_t
operator|)
name|name_ct
operator|)
operator|-
operator|(
name|uintptr_t
operator|)
literal|1
expr_stmt|;
while|while
condition|(
name|bits
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bits
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|len
operator|++
operator|>
literal|0
condition|)
name|fputs
argument_list|(
literal|" | "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|paz_names
index|[
name|ix
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|ix
operator|>=
name|name_ct
condition|)
break|break;
name|bits
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_memb_names
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
block|{
specifier|static
name|char
specifier|const
name|none
index|[]
init|=
literal|"none"
decl_stmt|;
specifier|static
name|char
specifier|const
name|plus
index|[
literal|3
index|]
init|=
literal|" + "
decl_stmt|;
name|char
modifier|*
name|pz
decl_stmt|;
name|uintptr_t
name|bits
init|=
operator|(
name|uintptr_t
operator|)
name|pOD
operator|->
name|optCookie
decl_stmt|;
name|int
name|ix
init|=
literal|0
decl_stmt|;
name|size_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|none
argument_list|)
decl_stmt|;
name|bits
operator|&=
operator|(
operator|(
name|uintptr_t
operator|)
literal|1
operator|<<
operator|(
name|uintptr_t
operator|)
name|name_ct
operator|)
operator|-
operator|(
name|uintptr_t
operator|)
literal|1
expr_stmt|;
comment|/*      *  Replace the enumeration value with the name string.      *  First, determine the needed length, then allocate and fill in.      */
while|while
condition|(
name|bits
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bits
operator|&
literal|1
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|paz_names
index|[
name|ix
index|]
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|plus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|ix
operator|>=
name|name_ct
condition|)
break|break;
name|bits
operator|>>=
literal|1
expr_stmt|;
block|}
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|=
name|pz
operator|=
name|AGALOC
argument_list|(
name|len
argument_list|,
literal|"enum name"
argument_list|)
expr_stmt|;
comment|/*      *  Start by clearing all the bits.  We want to turn off any defaults      *  because we will be restoring to current state, not adding to      *  the default set of bits.      */
name|memcpy
argument_list|(
name|pz
argument_list|,
name|none
argument_list|,
sizeof|sizeof
argument_list|(
name|none
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pz
operator|+=
sizeof|sizeof
argument_list|(
name|none
argument_list|)
operator|-
literal|1
expr_stmt|;
name|bits
operator|=
operator|(
name|uintptr_t
operator|)
name|pOD
operator|->
name|optCookie
expr_stmt|;
name|bits
operator|&=
operator|(
operator|(
name|uintptr_t
operator|)
literal|1
operator|<<
operator|(
name|uintptr_t
operator|)
name|name_ct
operator|)
operator|-
operator|(
name|uintptr_t
operator|)
literal|1
expr_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bits
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bits
operator|&
literal|1
condition|)
block|{
name|size_t
name|nln
init|=
name|strlen
argument_list|(
name|paz_names
index|[
name|ix
index|]
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|pz
argument_list|,
name|plus
argument_list|,
sizeof|sizeof
argument_list|(
name|plus
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pz
operator|+
sizeof|sizeof
argument_list|(
name|plus
argument_list|)
argument_list|,
name|paz_names
index|[
name|ix
index|]
argument_list|,
name|nln
argument_list|)
expr_stmt|;
name|pz
operator|+=
name|strlen
argument_list|(
name|paz_names
index|[
name|ix
index|]
argument_list|)
operator|+
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|ix
operator|>=
name|name_ct
condition|)
break|break;
name|bits
operator|>>=
literal|1
expr_stmt|;
block|}
operator|*
name|pz
operator|=
name|NUL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*=export_func  optionSetMembers  * what:  Convert between bit flag values and strings  * private:  *  * arg:   tOptions*,     pOpts,     the program options descriptor  * arg:   tOptDesc*,     pOD,       enumeration option description  * arg:   char const * const *,  *                       paz_names, list of enumeration names  * arg:   unsigned int,  name_ct,   number of names in list  *  * doc:   This converts the optArg.argString string from the option description  *        into the index corresponding to an entry in the name list.  *        This will match the generated enumeration value.  *        Full matches are always accepted.  Partial matches are accepted  *        if there is only one partial match. =*/
end_comment

begin_function
name|void
name|optionSetMembers
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
block|{
comment|/*      *  IF the program option descriptor pointer is invalid,      *  then it is some sort of special request.      */
switch|switch
condition|(
operator|(
name|uintptr_t
operator|)
name|pOpts
condition|)
block|{
case|case
operator|(
name|uintptr_t
operator|)
name|OPTPROC_EMIT_USAGE
case|:
name|set_memb_usage
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
name|name_ct
argument_list|)
expr_stmt|;
return|return;
case|case
operator|(
name|uintptr_t
operator|)
name|OPTPROC_EMIT_SHELL
case|:
name|set_memb_shell
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
name|name_ct
argument_list|)
expr_stmt|;
return|return;
case|case
operator|(
name|uintptr_t
operator|)
name|OPTPROC_RETURN_VALNAME
case|:
name|set_memb_names
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
name|name_ct
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_RESET
operator|)
operator|!=
literal|0
condition|)
return|return;
block|{
name|char
specifier|const
modifier|*
name|pzArg
init|=
name|pOD
operator|->
name|optArg
operator|.
name|argString
decl_stmt|;
name|uintptr_t
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|pzArg
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|pzArg
operator|==
name|NUL
operator|)
condition|)
block|{
name|pOD
operator|->
name|optCookie
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
return|return;
block|}
name|res
operator|=
operator|(
name|uintptr_t
operator|)
name|pOD
operator|->
name|optCookie
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tSCC
name|zSpn
index|[]
init|=
literal|" ,|+\t\r\f\n"
decl_stmt|;
name|int
name|iv
decl_stmt|,
name|len
decl_stmt|;
name|pzArg
operator|+=
name|strspn
argument_list|(
name|pzArg
argument_list|,
name|zSpn
argument_list|)
expr_stmt|;
name|iv
operator|=
operator|(
operator|*
name|pzArg
operator|==
literal|'!'
operator|)
expr_stmt|;
if|if
condition|(
name|iv
condition|)
name|pzArg
operator|+=
name|strspn
argument_list|(
name|pzArg
operator|+
literal|1
argument_list|,
name|zSpn
argument_list|)
operator|+
literal|1
expr_stmt|;
name|len
operator|=
name|strcspn
argument_list|(
name|pzArg
argument_list|,
name|zSpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|len
operator|==
literal|3
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|pzArg
argument_list|,
name|zAll
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|iv
condition|)
name|res
operator|=
literal|0
expr_stmt|;
else|else
name|res
operator|=
operator|~
literal|0UL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|==
literal|4
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|pzArg
argument_list|,
name|zNone
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|iv
condition|)
name|res
operator|=
literal|0
expr_stmt|;
block|}
else|else
do|do
block|{
name|char
modifier|*
name|pz
decl_stmt|;
name|uintptr_t
name|bit
init|=
name|strtoul
argument_list|(
name|pzArg
argument_list|,
operator|&
name|pz
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|pz
operator|!=
name|pzArg
operator|+
name|len
condition|)
block|{
name|char
name|z
index|[
name|AO_NAME_SIZE
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
name|int
name|shift_ct
decl_stmt|;
if|if
condition|(
operator|*
name|pz
operator|!=
name|NUL
condition|)
block|{
if|if
condition|(
name|len
operator|>=
name|AO_NAME_LIMIT
condition|)
break|break;
name|memcpy
argument_list|(
name|z
argument_list|,
name|pzArg
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
expr_stmt|;
name|z
index|[
name|len
index|]
operator|=
name|NUL
expr_stmt|;
name|p
operator|=
name|z
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|pzArg
expr_stmt|;
block|}
name|shift_ct
operator|=
name|find_name
argument_list|(
name|p
argument_list|,
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
name|name_ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift_ct
operator|>=
name|name_ct
condition|)
block|{
name|pOD
operator|->
name|optCookie
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
return|return;
block|}
name|bit
operator|=
literal|1UL
operator|<<
name|shift_ct
expr_stmt|;
block|}
if|if
condition|(
name|iv
condition|)
name|res
operator|&=
operator|~
name|bit
expr_stmt|;
else|else
name|res
operator||=
name|bit
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
name|pzArg
index|[
name|len
index|]
operator|==
name|NUL
condition|)
break|break;
name|pzArg
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|name_ct
operator|<
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
operator|)
condition|)
block|{
name|res
operator|&=
operator|(
literal|1UL
operator|<<
name|name_ct
operator|)
operator|-
literal|1UL
expr_stmt|;
block|}
name|pOD
operator|->
name|optCookie
operator|=
operator|(
name|void
operator|*
operator|)
name|res
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/enumeration.c */
end_comment

end_unit

