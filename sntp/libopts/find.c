begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * @file check.c  *  * @brief Hunt for options in the option descriptor list  *  *  This file contains the routines that deal with processing quoted strings  *  into an internal format.  *  * @addtogroup autoopts  * @{  */
end_comment

begin_comment
comment|/*  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  */
end_comment

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|int
name|parse_opt
parameter_list|(
name|char
specifier|const
modifier|*
modifier|*
name|nm_pp
parameter_list|,
name|char
modifier|*
modifier|*
name|arg_pp
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_ambiguities
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|int
name|nm_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|opt_match_ct
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|int
name|nm_len
parameter_list|,
name|int
modifier|*
name|ixp
parameter_list|,
name|bool
modifier|*
name|disable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|opt_set
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|idx
parameter_list|,
name|bool
name|disable
parameter_list|,
name|tOptState
modifier|*
name|st
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|opt_unknown
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|,
name|tOptState
modifier|*
name|st
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|opt_ambiguous
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|int
name|match_ct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|get_opt_arg_must
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptState
modifier|*
name|o_st
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|get_opt_arg_may
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|o_st
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|get_opt_arg_none
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|o_st
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/**  * find the name and name length we are looking for  */
end_comment

begin_function
specifier|static
name|int
name|parse_opt
parameter_list|(
name|char
specifier|const
modifier|*
modifier|*
name|nm_pp
parameter_list|,
name|char
modifier|*
modifier|*
name|arg_pp
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsz
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
name|char
specifier|const
modifier|*
name|p
init|=
operator|*
name|nm_pp
decl_stmt|;
operator|*
name|arg_pp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
operator|(
name|p
operator|++
operator|)
condition|)
block|{
case|case
name|NUL
case|:
return|return
name|res
return|;
case|case
literal|'='
case|:
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|*
name|nm_pp
argument_list|,
operator|(
name|size_t
operator|)
name|res
argument_list|)
expr_stmt|;
name|buf
index|[
name|res
index|]
operator|=
name|NUL
expr_stmt|;
operator|*
name|nm_pp
operator|=
name|buf
expr_stmt|;
operator|*
name|arg_pp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|p
expr_stmt|;
return|return
name|res
return|;
default|default:
if|if
condition|(
operator|++
name|res
operator|>=
operator|(
name|int
operator|)
name|bufsz
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *  print out the options that match the given name.  *  * @param pOpts      option data  * @param opt_name   name of option to look for  */
end_comment

begin_function
specifier|static
name|void
name|opt_ambiguities
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|int
name|nm_len
parameter_list|)
block|{
name|char
specifier|const
modifier|*
specifier|const
name|hyph
init|=
name|NAMED_OPTS
argument_list|(
name|opts
argument_list|)
condition|?
literal|""
else|:
name|LONG_OPT_MARKER
decl_stmt|;
name|tOptDesc
modifier|*
name|pOD
init|=
name|opts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|fputs
argument_list|(
name|zambig_list_msg
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|pOD
operator|->
name|pz_Name
operator|==
name|NULL
condition|)
continue|continue;
comment|/* doc option */
if|if
condition|(
name|strneqvcmp
argument_list|(
name|name
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
name|nm_len
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zambig_file
argument_list|,
name|hyph
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pOD
operator|->
name|pz_DisableName
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strneqvcmp
argument_list|(
name|name
argument_list|,
name|pOD
operator|->
name|pz_DisableName
argument_list|,
name|nm_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zambig_file
argument_list|,
name|hyph
argument_list|,
name|pOD
operator|->
name|pz_DisableName
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pOD
operator|++
operator|,
operator|(
operator|++
name|idx
operator|<
name|opts
operator|->
name|optCt
operator|)
condition|)
do|;
block|}
end_function

begin_comment
comment|/**  *  Determine the number of options that match the name  *  * @param pOpts      option data  * @param opt_name   name of option to look for  * @param nm_len     length of provided name  * @param index      pointer to int for option index  * @param disable    pointer to bool to mark disabled option  * @return count of options that match  */
end_comment

begin_function
specifier|static
name|int
name|opt_match_ct
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|int
name|nm_len
parameter_list|,
name|int
modifier|*
name|ixp
parameter_list|,
name|bool
modifier|*
name|disable
parameter_list|)
block|{
name|int
name|matchCt
init|=
literal|0
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|int
name|idxLim
init|=
name|opts
operator|->
name|optCt
decl_stmt|;
name|tOptDesc
modifier|*
name|pOD
init|=
name|opts
operator|->
name|pOptDesc
decl_stmt|;
do|do
block|{
comment|/*          *  If option disabled or a doc option, skip to next          */
if|if
condition|(
name|pOD
operator|->
name|pz_Name
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|SKIP_OPT
argument_list|(
name|pOD
argument_list|)
operator|&&
operator|(
name|pOD
operator|->
name|fOptState
operator|!=
operator|(
name|OPTST_OMITTED
operator||
name|OPTST_NO_INIT
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|strneqvcmp
argument_list|(
name|name
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
name|nm_len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*              *  IF we have a complete match              *  THEN it takes priority over any already located partial              */
if|if
condition|(
name|pOD
operator|->
name|pz_Name
index|[
name|nm_len
index|]
operator|==
name|NUL
condition|)
block|{
operator|*
name|ixp
operator|=
name|idx
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/*          *  IF       there is a disable name          *     *AND* the option name matches the disable name          *  THEN ...          */
elseif|else
if|if
condition|(
operator|(
name|pOD
operator|->
name|pz_DisableName
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strneqvcmp
argument_list|(
name|name
argument_list|,
name|pOD
operator|->
name|pz_DisableName
argument_list|,
name|nm_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|disable
operator|=
name|true
expr_stmt|;
comment|/*              *  IF we have a complete match              *  THEN it takes priority over any already located partial              */
if|if
condition|(
name|pOD
operator|->
name|pz_DisableName
index|[
name|nm_len
index|]
operator|==
name|NUL
condition|)
block|{
operator|*
name|ixp
operator|=
name|idx
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
continue|continue;
comment|/* does not match any option */
comment|/*          *  We found a full or partial match, either regular or disabling.          *  Remember the index for later.          */
operator|*
name|ixp
operator|=
name|idx
expr_stmt|;
operator|++
name|matchCt
expr_stmt|;
block|}
do|while
condition|(
name|pOD
operator|++
operator|,
operator|(
operator|++
name|idx
operator|<
name|idxLim
operator|)
condition|)
do|;
return|return
name|matchCt
return|;
block|}
end_function

begin_comment
comment|/**  *  Set the option to the indicated option number.  *  * @param opts      option data  * @param arg       option argument (if glued to name)  * @param idx       option index  * @param disable   mark disabled option  * @param st        state about current option  */
end_comment

begin_function
specifier|static
name|tSuccess
name|opt_set
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|idx
parameter_list|,
name|bool
name|disable
parameter_list|,
name|tOptState
modifier|*
name|st
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|pOD
init|=
name|opts
operator|->
name|pOptDesc
operator|+
name|idx
decl_stmt|;
if|if
condition|(
name|SKIP_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|==
literal|0
condition|)
return|return
name|FAILURE
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zDisabledErr
argument_list|,
name|opts
operator|->
name|pzProgName
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pOD
operator|->
name|pzText
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|SET_OFF_FMT
argument_list|,
name|pOD
operator|->
name|pzText
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|NL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|opts
operator|->
name|pUsageProc
call|)
argument_list|(
name|opts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* to be certain */
block|}
comment|/*      *  IF we found a disablement name,      *  THEN set the bit in the callers' flag word      */
if|if
condition|(
name|disable
condition|)
name|st
operator|->
name|flags
operator||=
name|OPTST_DISABLED
expr_stmt|;
name|st
operator|->
name|pOD
operator|=
name|pOD
expr_stmt|;
name|st
operator|->
name|pzOptArg
operator|=
name|arg
expr_stmt|;
name|st
operator|->
name|optType
operator|=
name|TOPT_LONG
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  An option was not found.  Check for default option and set it  *  if there is one.  Otherwise, handle the error.  *  * @param opts   option data  * @param name   name of option to look for  * @param arg    option argument  * @param st     state about current option  *  * @return success status  */
end_comment

begin_function
specifier|static
name|tSuccess
name|opt_unknown
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|,
name|tOptState
modifier|*
name|st
parameter_list|)
block|{
comment|/*      *  IF there is no equal sign      *     *AND* we are using named arguments      *     *AND* there is a default named option,      *  THEN return that option.      */
if|if
condition|(
operator|(
name|arg
operator|==
name|NULL
operator|)
operator|&&
name|NAMED_OPTS
argument_list|(
name|opts
argument_list|)
operator|&&
operator|(
name|opts
operator|->
name|specOptIdx
operator|.
name|default_opt
operator|!=
name|NO_EQUIVALENT
operator|)
condition|)
block|{
name|st
operator|->
name|pOD
operator|=
name|opts
operator|->
name|pOptDesc
operator|+
name|opts
operator|->
name|specOptIdx
operator|.
name|default_opt
expr_stmt|;
name|st
operator|->
name|pzOptArg
operator|=
name|name
expr_stmt|;
name|st
operator|->
name|optType
operator|=
name|TOPT_DEFAULT
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zIllOptStr
argument_list|,
name|opts
operator|->
name|pzProgPath
argument_list|,
name|name
argument_list|)
expr_stmt|;
call|(
modifier|*
name|opts
operator|->
name|pUsageProc
call|)
argument_list|(
name|opts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* to be certain */
block|}
return|return
name|FAILURE
return|;
block|}
end_function

begin_comment
comment|/**  *  Several options match the provided name.  *  * @param opts      option data  * @param name      name of option to look for  * @param match_ct  number of matching options  *  * @return success status (always FAILURE, if it returns)  */
end_comment

begin_function
specifier|static
name|tSuccess
name|opt_ambiguous
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|int
name|match_ct
parameter_list|)
block|{
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zambig_opt_fmt
argument_list|,
name|opts
operator|->
name|pzProgPath
argument_list|,
name|name
argument_list|,
name|match_ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_ct
operator|<=
literal|4
condition|)
name|opt_ambiguities
argument_list|(
name|opts
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|opts
operator|->
name|pUsageProc
call|)
argument_list|(
name|opts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* to be certain */
block|}
return|return
name|FAILURE
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionVendorOption  * private:  *  * what:  Process a vendor option  * arg:   + tOptions * + pOpts    + program options descriptor +  * arg:   + tOptDesc * + pOptDesc + the descriptor for this arg +  *  * doc:  *  For POSIX specified utilities, the options are constrained to the options,  *  @xref{config attributes, Program Configuration}.  AutoOpts clients should  *  never specify this directly.  It gets referenced when the option  *  definitions contain a "vendor-opt" attribute. =*/
end_comment

begin_function
name|void
name|optionVendorOption
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
block|{
name|tOptState
name|opt_st
init|=
name|OPTSTATE_INITIALIZER
argument_list|(
name|PRESET
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|vopt_str
init|=
name|pOD
operator|->
name|optArg
operator|.
name|argString
decl_stmt|;
if|if
condition|(
name|pOpts
operator|<=
name|OPTPROC_EMIT_LIMIT
condition|)
return|return;
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_RESET
operator|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTPROC_IMMEDIATE
operator|)
operator|==
literal|0
condition|)
name|opt_st
operator|.
name|flags
operator|=
name|OPTST_DEFINED
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_VENDOR_OPT
operator|)
operator|==
literal|0
operator|)
operator|||
operator|!
name|SUCCESSFUL
argument_list|(
name|opt_find_long
argument_list|(
name|pOpts
argument_list|,
name|vopt_str
argument_list|,
operator|&
name|opt_st
argument_list|)
argument_list|)
operator|||
operator|!
name|SUCCESSFUL
argument_list|(
name|get_opt_arg
argument_list|(
name|pOpts
argument_list|,
operator|&
name|opt_st
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zIllVendOptStr
argument_list|,
name|pOpts
operator|->
name|pzProgName
argument_list|,
name|vopt_str
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pOpts
operator|->
name|pUsageProc
call|)
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* to be certain */
block|}
comment|/*      *  See if we are in immediate handling state.      */
if|if
condition|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_IMMEDIATE
condition|)
block|{
comment|/*          *  See if the enclosed option is okay with that state.          */
if|if
condition|(
name|DO_IMMEDIATELY
argument_list|(
name|opt_st
operator|.
name|flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|handle_opt
argument_list|(
name|pOpts
argument_list|,
operator|&
name|opt_st
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*          *  non-immediate direction.          *  See if the enclosed option is okay with that state.          */
if|if
condition|(
name|DO_NORMALLY
argument_list|(
name|opt_st
operator|.
name|flags
argument_list|)
operator|||
name|DO_SECOND_TIME
argument_list|(
name|opt_st
operator|.
name|flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|handle_opt
argument_list|(
name|pOpts
argument_list|,
operator|&
name|opt_st
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  Find the option descriptor by full name.  *  * @param opts      option data  * @param opt_name  name of option to look for  * @param state     state about current option  *  * @return success status  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|opt_find_long
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|opt_name
parameter_list|,
name|tOptState
modifier|*
name|state
parameter_list|)
block|{
name|char
name|name_buf
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|opt_arg
decl_stmt|;
name|int
name|nm_len
init|=
name|parse_opt
argument_list|(
operator|&
name|opt_name
argument_list|,
operator|&
name|opt_arg
argument_list|,
name|name_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|name_buf
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|bool
name|disable
init|=
name|false
decl_stmt|;
name|int
name|ct
decl_stmt|;
if|if
condition|(
name|nm_len
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|==
literal|0
condition|)
return|return
name|FAILURE
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zInvalOptName
argument_list|,
name|opts
operator|->
name|pzProgName
argument_list|,
name|opt_name
argument_list|)
expr_stmt|;
call|(
modifier|*
name|opts
operator|->
name|pUsageProc
call|)
argument_list|(
name|opts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* to be certain */
block|}
name|ct
operator|=
name|opt_match_ct
argument_list|(
name|opts
argument_list|,
name|opt_name
argument_list|,
name|nm_len
argument_list|,
operator|&
name|idx
argument_list|,
operator|&
name|disable
argument_list|)
expr_stmt|;
comment|/*      *  See if we found one match, no matches or multiple matches.      */
switch|switch
condition|(
name|ct
condition|)
block|{
case|case
literal|1
case|:
return|return
name|opt_set
argument_list|(
name|opts
argument_list|,
name|opt_arg
argument_list|,
name|idx
argument_list|,
name|disable
argument_list|,
name|state
argument_list|)
return|;
case|case
literal|0
case|:
return|return
name|opt_unknown
argument_list|(
name|opts
argument_list|,
name|opt_name
argument_list|,
name|opt_arg
argument_list|,
name|state
argument_list|)
return|;
default|default:
return|return
name|opt_ambiguous
argument_list|(
name|opts
argument_list|,
name|opt_name
argument_list|,
name|ct
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  *  Find the short option descriptor for the current option  *  * @param pOpts      option data  * @param optValue   option flag character  * @param pOptState  state about current option  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|opt_find_short
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|uint_t
name|optValue
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|pRes
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|ct
init|=
name|pOpts
operator|->
name|optCt
decl_stmt|;
comment|/*      *  Search the option list      */
do|do
block|{
if|if
condition|(
name|optValue
operator|!=
name|pRes
operator|->
name|optValue
condition|)
continue|continue;
if|if
condition|(
name|SKIP_OPT
argument_list|(
name|pRes
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pRes
operator|->
name|fOptState
operator|==
operator|(
name|OPTST_OMITTED
operator||
name|OPTST_NO_INIT
operator|)
operator|)
operator|&&
operator|(
name|pRes
operator|->
name|pz_Name
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|==
literal|0
condition|)
return|return
name|FAILURE
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zDisabledErr
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
name|pRes
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pRes
operator|->
name|pzText
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|SET_OFF_FMT
argument_list|,
name|pRes
operator|->
name|pzText
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|NL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pOpts
operator|->
name|pUsageProc
call|)
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* to be certain */
block|}
goto|goto
name|short_opt_error
goto|;
block|}
name|pOptState
operator|->
name|pOD
operator|=
name|pRes
expr_stmt|;
name|pOptState
operator|->
name|optType
operator|=
name|TOPT_SHORT
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
do|while
condition|(
name|pRes
operator|++
operator|,
operator|--
name|ct
operator|>
literal|0
condition|)
do|;
comment|/*      *  IF    the character value is a digit      *    AND there is a special number option ("-n")      *  THEN the result is the "option" itself and the      *       option is the specially marked "number" option.      */
if|if
condition|(
name|IS_DEC_DIGIT_CHAR
argument_list|(
name|optValue
argument_list|)
operator|&&
operator|(
name|pOpts
operator|->
name|specOptIdx
operator|.
name|number_option
operator|!=
name|NO_EQUIVALENT
operator|)
condition|)
block|{
name|pOptState
operator|->
name|pOD
operator|=
expr|\
name|pRes
operator|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pOpts
operator|->
name|specOptIdx
operator|.
name|number_option
expr_stmt|;
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
operator|--
expr_stmt|;
name|pOptState
operator|->
name|optType
operator|=
name|TOPT_SHORT
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
name|short_opt_error
label|:
comment|/*      *  IF we are to stop on errors (the default, actually)      *  THEN call the usage procedure.      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zIllOptChr
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
name|optValue
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pOpts
operator|->
name|pUsageProc
call|)
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* to be certain */
block|}
return|return
name|FAILURE
return|;
block|}
end_function

begin_comment
comment|/**  *  Process option with a required argument.  Long options can either have a  *  separate command line argument, or an argument attached by the '='  *  character.  Figure out which.  *  *  @param[in,out] opts  the program option descriptor  *  @param[in,out] o_st  the option processing state  *  @returns SUCCESS or FAILURE  */
end_comment

begin_function
specifier|static
name|tSuccess
name|get_opt_arg_must
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptState
modifier|*
name|o_st
parameter_list|)
block|{
switch|switch
condition|(
name|o_st
operator|->
name|optType
condition|)
block|{
case|case
name|TOPT_SHORT
case|:
comment|/*          *  See if an arg string follows the flag character          */
if|if
condition|(
operator|*
operator|++
operator|(
name|opts
operator|->
name|pzCurOpt
operator|)
operator|==
name|NUL
condition|)
name|opts
operator|->
name|pzCurOpt
operator|=
name|opts
operator|->
name|origArgVect
index|[
name|opts
operator|->
name|curOptIdx
operator|++
index|]
expr_stmt|;
name|o_st
operator|->
name|pzOptArg
operator|=
name|opts
operator|->
name|pzCurOpt
expr_stmt|;
break|break;
case|case
name|TOPT_LONG
case|:
comment|/*          *  See if an arg string has already been assigned (glued on          *  with an `=' character)          */
if|if
condition|(
name|o_st
operator|->
name|pzOptArg
operator|==
name|NULL
condition|)
name|o_st
operator|->
name|pzOptArg
operator|=
name|opts
operator|->
name|origArgVect
index|[
name|opts
operator|->
name|curOptIdx
operator|++
index|]
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|fputs
argument_list|(
literal|"AutoOpts lib error: option type not selected\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|option_exits
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|TOPT_DEFAULT
case|:
comment|/*          *  The option was selected by default.  The current token is          *  the option argument.          */
break|break;
block|}
comment|/*      *  Make sure we did not overflow the argument list.      */
if|if
condition|(
name|opts
operator|->
name|curOptIdx
operator|>
name|opts
operator|->
name|origArgCt
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zMisArg
argument_list|,
name|opts
operator|->
name|pzProgPath
argument_list|,
name|o_st
operator|->
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|opts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
comment|/* next time advance to next arg */
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * Process an option with an optional argument.  For short options, it looks  * at the character after the option character, or it consumes the next full  * argument.  For long options, it looks for an '=' character attachment to  * the long option name before deciding to take the next command line  * argument.  *  * @param pOpts      the option descriptor  * @param o_st  a structure for managing the current processing state  * @returns SUCCESS or does not return  */
end_comment

begin_function
specifier|static
name|tSuccess
name|get_opt_arg_may
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|o_st
parameter_list|)
block|{
comment|/*      *  An option argument is optional.      */
switch|switch
condition|(
name|o_st
operator|->
name|optType
condition|)
block|{
case|case
name|TOPT_SHORT
case|:
if|if
condition|(
operator|*
operator|++
name|pOpts
operator|->
name|pzCurOpt
operator|!=
name|NUL
condition|)
name|o_st
operator|->
name|pzOptArg
operator|=
name|pOpts
operator|->
name|pzCurOpt
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|pzLA
init|=
name|pOpts
operator|->
name|origArgVect
index|[
name|pOpts
operator|->
name|curOptIdx
index|]
decl_stmt|;
comment|/*              *  BECAUSE it is optional, we must make sure              *  we did not find another flag and that there              *  is such an argument.              */
if|if
condition|(
operator|(
name|pzLA
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|pzLA
operator|==
literal|'-'
operator|)
condition|)
name|o_st
operator|->
name|pzOptArg
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|pOpts
operator|->
name|curOptIdx
operator|++
expr_stmt|;
comment|/* argument found */
name|o_st
operator|->
name|pzOptArg
operator|=
name|pzLA
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TOPT_LONG
case|:
comment|/*          *  Look for an argument if we don't already have one (glued on          *  with a `=' character) *AND* we are not in named argument mode          */
if|if
condition|(
operator|(
name|o_st
operator|->
name|pzOptArg
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|!
name|NAMED_OPTS
argument_list|(
name|pOpts
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|pzLA
init|=
name|pOpts
operator|->
name|origArgVect
index|[
name|pOpts
operator|->
name|curOptIdx
index|]
decl_stmt|;
comment|/*              *  BECAUSE it is optional, we must make sure              *  we did not find another flag and that there              *  is such an argument.              */
if|if
condition|(
operator|(
name|pzLA
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|pzLA
operator|==
literal|'-'
operator|)
condition|)
name|o_st
operator|->
name|pzOptArg
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|pOpts
operator|->
name|curOptIdx
operator|++
expr_stmt|;
comment|/* argument found */
name|o_st
operator|->
name|pzOptArg
operator|=
name|pzLA
expr_stmt|;
block|}
block|}
break|break;
default|default:
case|case
name|TOPT_DEFAULT
case|:
name|ao_bug
argument_list|(
name|zbad_default_msg
argument_list|)
expr_stmt|;
block|}
comment|/*      *  After an option with an optional argument, we will      *  *always* start with the next option because if there      *  were any characters following the option name/flag,      *  they would be interpreted as the argument.      */
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  Process option that does not have an argument.  *  *  @param[in,out] opts  the program option descriptor  *  @param[in,out] o_st  the option processing state  *  @returns SUCCESS or FAILURE  */
end_comment

begin_function
specifier|static
name|tSuccess
name|get_opt_arg_none
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|o_st
parameter_list|)
block|{
comment|/*      *  No option argument.  Make sure next time around we find      *  the correct option flag character for short options      */
if|if
condition|(
name|o_st
operator|->
name|optType
operator|==
name|TOPT_SHORT
condition|)
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
operator|++
expr_stmt|;
comment|/*      *  It is a long option.  Make sure there was no ``=xxx'' argument      */
elseif|else
if|if
condition|(
name|o_st
operator|->
name|pzOptArg
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zNoArg
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
name|o_st
operator|->
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
comment|/*      *  It is a long option.  Advance to next command line argument.      */
else|else
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  Process option.  Figure out whether or not to look for an option argument.  *  *  @param[in,out] opts  the program option descriptor  *  @param[in,out] o_st  the option processing state  *  @returns SUCCESS or FAILURE  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|get_opt_arg
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptState
modifier|*
name|o_st
parameter_list|)
block|{
name|o_st
operator|->
name|flags
operator||=
operator|(
name|o_st
operator|->
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_PERSISTENT_MASK
operator|)
expr_stmt|;
comment|/*      * Disabled options and options specified to not have arguments      * are handled with the "none" procedure.  Otherwise, check the      * optional flag and call either the "may" or "must" function.      */
if|if
condition|(
operator|(
operator|(
name|o_st
operator|->
name|flags
operator|&
name|OPTST_DISABLED
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|o_st
operator|->
name|flags
argument_list|)
operator|==
name|OPARG_TYPE_NONE
operator|)
condition|)
return|return
name|get_opt_arg_none
argument_list|(
name|opts
argument_list|,
name|o_st
argument_list|)
return|;
if|if
condition|(
name|o_st
operator|->
name|flags
operator|&
name|OPTST_ARG_OPTIONAL
condition|)
return|return
name|get_opt_arg_may
argument_list|(
name|opts
argument_list|,
name|o_st
argument_list|)
return|;
return|return
name|get_opt_arg_must
argument_list|(
name|opts
argument_list|,
name|o_st
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  Find the option descriptor for the current option.  *  *  @param[in,out] opts  the program option descriptor  *  @param[in,out] o_st  the option processing state  *  @returns SUCCESS or FAILURE  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|find_opt
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptState
modifier|*
name|o_st
parameter_list|)
block|{
comment|/*      *  IF we are continuing a short option list (e.g. -xyz...)      *  THEN continue a single flag option.      *  OTHERWISE see if there is room to advance and then do so.      */
if|if
condition|(
operator|(
name|opts
operator|->
name|pzCurOpt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|opts
operator|->
name|pzCurOpt
operator|!=
name|NUL
operator|)
condition|)
return|return
name|opt_find_short
argument_list|(
name|opts
argument_list|,
operator|(
name|uint8_t
operator|)
operator|*
operator|(
name|opts
operator|->
name|pzCurOpt
operator|)
argument_list|,
name|o_st
argument_list|)
return|;
if|if
condition|(
name|opts
operator|->
name|curOptIdx
operator|>=
name|opts
operator|->
name|origArgCt
condition|)
return|return
name|PROBLEM
return|;
comment|/* NORMAL COMPLETION */
name|opts
operator|->
name|pzCurOpt
operator|=
name|opts
operator|->
name|origArgVect
index|[
name|opts
operator|->
name|curOptIdx
index|]
expr_stmt|;
comment|/*      *  IF all arguments must be named options, ...      */
if|if
condition|(
name|NAMED_OPTS
argument_list|(
name|opts
argument_list|)
condition|)
block|{
name|char
modifier|*
name|pz
init|=
name|opts
operator|->
name|pzCurOpt
decl_stmt|;
name|int
name|def
decl_stmt|;
name|tSuccess
name|res
decl_stmt|;
name|uint16_t
modifier|*
name|def_opt
decl_stmt|;
name|opts
operator|->
name|curOptIdx
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pz
operator|!=
literal|'-'
condition|)
return|return
name|opt_find_long
argument_list|(
name|opts
argument_list|,
name|pz
argument_list|,
name|o_st
argument_list|)
return|;
comment|/*          *  The name is prefixed with one or more hyphens.  Strip them off          *  and disable the "default_opt" setting.  Use heavy recasting to          *  strip off the "const" quality of the "default_opt" field.          */
while|while
condition|(
operator|*
operator|(
operator|++
name|pz
operator|)
operator|==
literal|'-'
condition|)
empty_stmt|;
name|def_opt
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
operator|&
operator|(
name|opts
operator|->
name|specOptIdx
operator|.
name|default_opt
operator|)
expr_stmt|;
name|def
operator|=
operator|*
name|def_opt
expr_stmt|;
operator|*
name|def_opt
operator|=
name|NO_EQUIVALENT
expr_stmt|;
name|res
operator|=
name|opt_find_long
argument_list|(
name|opts
argument_list|,
name|pz
argument_list|,
name|o_st
argument_list|)
expr_stmt|;
operator|*
name|def_opt
operator|=
operator|(
name|uint16_t
operator|)
name|def
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/*      *  Note the kind of flag/option marker      */
if|if
condition|(
operator|*
operator|(
operator|(
name|opts
operator|->
name|pzCurOpt
operator|)
operator|++
operator|)
operator|!=
literal|'-'
condition|)
return|return
name|PROBLEM
return|;
comment|/* NORMAL COMPLETION - this + rest are operands */
comment|/*      *  Special hack for a hyphen by itself      */
if|if
condition|(
operator|*
operator|(
name|opts
operator|->
name|pzCurOpt
operator|)
operator|==
name|NUL
condition|)
return|return
name|PROBLEM
return|;
comment|/* NORMAL COMPLETION - this + rest are operands */
comment|/*      *  The current argument is to be processed as an option argument      */
name|opts
operator|->
name|curOptIdx
operator|++
expr_stmt|;
comment|/*      *  We have an option marker.      *  Test the next character for long option indication      */
if|if
condition|(
name|opts
operator|->
name|pzCurOpt
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
operator|(
name|opts
operator|->
name|pzCurOpt
operator|)
operator|==
name|NUL
condition|)
comment|/*              *  NORMAL COMPLETION - NOT this arg, but rest are operands              */
return|return
name|PROBLEM
return|;
comment|/*          *  We do not allow the hyphen to be used as a flag value.          *  Therefore, if long options are not to be accepted, we punt.          */
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_LONGOPT
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zIllOptStr
argument_list|,
name|opts
operator|->
name|pzProgPath
argument_list|,
name|opts
operator|->
name|pzCurOpt
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
return|return
name|opt_find_long
argument_list|(
name|opts
argument_list|,
name|opts
operator|->
name|pzCurOpt
argument_list|,
name|o_st
argument_list|)
return|;
block|}
comment|/*      *  If short options are not allowed, then do long      *  option processing.  Otherwise the character must be a      *  short (i.e. single character) option.      */
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_SHORTOPT
operator|)
operator|!=
literal|0
condition|)
return|return
name|opt_find_short
argument_list|(
name|opts
argument_list|,
operator|(
name|uint8_t
operator|)
operator|*
operator|(
name|opts
operator|->
name|pzCurOpt
operator|)
argument_list|,
name|o_st
argument_list|)
return|;
return|return
name|opt_find_long
argument_list|(
name|opts
argument_list|,
name|opts
operator|->
name|pzCurOpt
argument_list|,
name|o_st
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** @}  *  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/find.c */
end_comment

end_unit

