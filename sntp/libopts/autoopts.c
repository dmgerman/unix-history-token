begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file autoopts.c  *  *  Time-stamp:      "2011-03-25 17:55:07 bkorb"  *  *  This file contains all of the routines that must be linked into  *  an executable to use the generated option processing.  The optional  *  routines are in separately compiled modules so that they will not  *  necessarily be linked in.  *  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (c) 1992-2011 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following md5sums:  *  *  43b91e8ca915626ed3818ffb1b71248b pkg/libopts/COPYING.gplv3  *  06a1a2e4760c90ea5e1dad8dfaac4d39 pkg/libopts/COPYING.lgplv3  *  66a5cedaf62c4b2637025f049f9b826f pkg/libopts/COPYING.mbsd  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PKGDATADIR
end_ifndef

begin_define
define|#
directive|define
name|PKGDATADIR
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zNil
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arg_types_t
name|argTypes
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|zOptFmtLine
index|[
literal|16
index|]
init|=
block|{
name|NUL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ag_bool
name|displayEnum
init|=
name|AG_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|pkgdatadir_default
index|[]
init|=
name|PKGDATADIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|program_pkgdatadir
init|=
name|pkgdatadir_default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tOptionLoadMode
name|option_load_mode
init|=
name|OPTION_LOAD_UNCOOKED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tePagerState
name|pagerState
init|=
name|PAGER_STATE_INITIAL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|option_usage_fp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|tSuccess
name|findOptDesc
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|next_opt_arg_must
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|next_opt_arg_may
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|next_opt_arg_none
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|nextOption
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|doPresets
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|checkConsistency
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_function
name|LOCAL
name|void
modifier|*
name|ao_malloc
parameter_list|(
name|size_t
name|sz
parameter_list|)
block|{
name|void
modifier|*
name|res
init|=
name|malloc
argument_list|(
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zAO_Alloc
argument_list|,
operator|(
name|int
operator|)
name|sz
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_define
define|#
directive|define
name|malloc
parameter_list|(
name|_s
parameter_list|)
value|ao_malloc(_s)
end_define

begin_function
name|LOCAL
name|void
modifier|*
name|ao_realloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|void
modifier|*
name|res
init|=
operator|(
name|p
operator|==
name|NULL
operator|)
condition|?
name|malloc
argument_list|(
name|sz
argument_list|)
else|:
name|realloc
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zAO_Realloc
argument_list|,
operator|(
name|int
operator|)
name|sz
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|realloc
end_undef

begin_define
define|#
directive|define
name|realloc
parameter_list|(
name|_p
parameter_list|,
name|_s
parameter_list|)
value|ao_realloc(_p,_s)
end_define

begin_function
name|LOCAL
name|char
modifier|*
name|ao_strdup
parameter_list|(
name|char
specifier|const
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|res
init|=
name|strdup
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zAO_Strdup
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|strdup
end_undef

begin_define
define|#
directive|define
name|strdup
parameter_list|(
name|_p
parameter_list|)
value|ao_strdup(_p)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_PATHFIND
end_ifndef

begin_include
include|#
directive|include
file|"compat/pathfind.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SNPRINTF
end_ifndef

begin_include
include|#
directive|include
file|"compat/snprintf.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRDUP
end_ifndef

begin_include
include|#
directive|include
file|"compat/strdup.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRCHR
end_ifndef

begin_include
include|#
directive|include
file|"compat/strchr.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  handle_opt  *  *  This routine handles equivalencing, sets the option state flags and  *  invokes the handler procedure, if any.  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|handle_opt
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
block|{
comment|/*      *  Save a copy of the option procedure pointer.      *  If this is an equivalence class option, we still want this proc.      */
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOptState
operator|->
name|pOD
decl_stmt|;
name|tOptProc
modifier|*
name|pOP
init|=
name|pOD
operator|->
name|pOptProc
decl_stmt|;
if|if
condition|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ALLOC_ARG
condition|)
name|AGFREE
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|=
name|pOptState
operator|->
name|pzOptArg
expr_stmt|;
comment|/*      *  IF we are presetting options, then we will ignore any un-presettable      *  options.  They are the ones either marked as such.      */
if|if
condition|(
operator|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_PRESETTING
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_NO_INIT
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|PROBLEM
return|;
comment|/*      *  IF this is an equivalence class option,      *  THEN      *      Save the option value that got us to this option      *      entry.  (It may not be pOD->optChar[0], if this is an      *      equivalence entry.)      *      set the pointer to the equivalence class base      */
if|if
condition|(
name|pOD
operator|->
name|optEquivIndex
operator|!=
name|NO_EQUIVALENT
condition|)
block|{
name|tOptDesc
modifier|*
name|p
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pOD
operator|->
name|optEquivIndex
decl_stmt|;
comment|/*          * IF the current option state has not been defined (set on the          *    command line), THEN we will allow continued resetting of          *    the value.  Once "defined", then it must not change.          */
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_DEFINED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/*              *  The equivalenced-to option has been found on the command              *  line before.  Make sure new occurrences are the same type.              *              *  IF this option has been previously equivalenced and              *     it was not the same equivalenced-to option,              *  THEN we have a usage problem.              */
if|if
condition|(
name|p
operator|->
name|optActualIndex
operator|!=
name|pOD
operator|->
name|optIndex
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|zMultiEquiv
argument_list|,
name|p
operator|->
name|pz_Name
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
operator|(
name|pOpts
operator|->
name|pOptDesc
operator|+
name|p
operator|->
name|optActualIndex
operator|)
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
block|}
else|else
block|{
comment|/*              *  Set the equivalenced-to actual option index to no-equivalent              *  so that we set all the entries below.  This option may either              *  never have been selected before, or else it was selected by              *  some sort of "presetting" mechanism.              */
name|p
operator|->
name|optActualIndex
operator|=
name|NO_EQUIVALENT
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|optActualIndex
operator|!=
name|pOD
operator|->
name|optIndex
condition|)
block|{
comment|/*              *  First time through, copy over the state              *  and add in the equivalence flag              */
name|p
operator|->
name|optActualValue
operator|=
name|pOD
operator|->
name|optValue
expr_stmt|;
name|p
operator|->
name|optActualIndex
operator|=
name|pOD
operator|->
name|optIndex
expr_stmt|;
name|pOptState
operator|->
name|flags
operator||=
name|OPTST_EQUIVALENCE
expr_stmt|;
block|}
comment|/*          *  Copy the most recent option argument.  set membership state          *  is kept in ``p->optCookie''.  Do not overwrite.          */
name|p
operator|->
name|optArg
operator|.
name|argString
operator|=
name|pOD
operator|->
name|optArg
operator|.
name|argString
expr_stmt|;
name|pOD
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|pOD
operator|->
name|optActualValue
operator|=
name|pOD
operator|->
name|optValue
expr_stmt|;
name|pOD
operator|->
name|optActualIndex
operator|=
name|pOD
operator|->
name|optIndex
expr_stmt|;
block|}
name|pOD
operator|->
name|fOptState
operator|&=
name|OPTST_PERSISTENT_MASK
expr_stmt|;
name|pOD
operator|->
name|fOptState
operator||=
operator|(
name|pOptState
operator|->
name|flags
operator|&
operator|~
name|OPTST_PERSISTENT_MASK
operator|)
expr_stmt|;
comment|/*      *  Keep track of count only for DEFINED (command line) options.      *  IF we have too many, build up an error message and bail.      */
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_DEFINED
operator|)
operator|&&
operator|(
operator|++
name|pOD
operator|->
name|optOccCt
operator|>
name|pOD
operator|->
name|optMaxCt
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
specifier|const
modifier|*
name|pzEqv
init|=
operator|(
name|pOD
operator|->
name|optEquivIndex
operator|!=
name|NO_EQUIVALENT
operator|)
condition|?
name|zEquiv
else|:
name|zNil
decl_stmt|;
name|fputs
argument_list|(
name|zErrOnly
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pOD
operator|->
name|optMaxCt
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zAtMost
argument_list|,
name|pOD
operator|->
name|optMaxCt
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
name|pzEqv
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zOnlyOne
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
name|pzEqv
argument_list|)
expr_stmt|;
block|}
return|return
name|FAILURE
return|;
block|}
comment|/*      *  If provided a procedure to call, call it      */
if|if
condition|(
name|pOP
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pOP
call|)
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *  HUNT FOR OPTIONS IN THE ARGUMENT LIST  *  *  The next four procedures are "private" to nextOption().  *  nextOption() uses findOptDesc() to find the next descriptor and it, in  *  turn, uses longOptionFind() and shortOptionFind() to actually do the hunt.  *  *  longOptionFind  *  *  Find the long option descriptor for the current option  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|longOptionFind
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzOptName
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
block|{
name|ag_bool
name|disable
init|=
name|AG_FALSE
decl_stmt|;
name|char
modifier|*
name|pzEq
init|=
name|strchr
argument_list|(
name|pzOptName
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|int
name|idxLim
init|=
name|pOpts
operator|->
name|optCt
decl_stmt|;
name|int
name|matchCt
init|=
literal|0
decl_stmt|;
name|int
name|matchIdx
init|=
literal|0
decl_stmt|;
name|int
name|nameLen
decl_stmt|;
name|char
name|opt_name_buf
index|[
literal|128
index|]
decl_stmt|;
comment|/*      *  IF the value is attached to the name,      *  copy it off so we can NUL terminate.      */
if|if
condition|(
name|pzEq
operator|!=
name|NULL
condition|)
block|{
name|nameLen
operator|=
call|(
name|int
call|)
argument_list|(
name|pzEq
operator|-
name|pzOptName
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameLen
operator|>=
sizeof|sizeof
argument_list|(
name|opt_name_buf
argument_list|)
condition|)
return|return
name|FAILURE
return|;
name|memcpy
argument_list|(
name|opt_name_buf
argument_list|,
name|pzOptName
argument_list|,
name|nameLen
argument_list|)
expr_stmt|;
name|opt_name_buf
index|[
name|nameLen
index|]
operator|=
name|NUL
expr_stmt|;
name|pzOptName
operator|=
name|opt_name_buf
expr_stmt|;
name|pzEq
operator|++
expr_stmt|;
block|}
else|else
name|nameLen
operator|=
name|strlen
argument_list|(
name|pzOptName
argument_list|)
expr_stmt|;
do|do
block|{
comment|/*          *  If option disabled or a doc option, skip to next          */
if|if
condition|(
name|pOD
operator|->
name|pz_Name
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|SKIP_OPT
argument_list|(
name|pOD
argument_list|)
operator|&&
operator|(
name|pOD
operator|->
name|fOptState
operator|!=
operator|(
name|OPTST_OMITTED
operator||
name|OPTST_NO_INIT
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|strneqvcmp
argument_list|(
name|pzOptName
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
name|nameLen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*              *  IF we have a complete match              *  THEN it takes priority over any already located partial              */
if|if
condition|(
name|pOD
operator|->
name|pz_Name
index|[
name|nameLen
index|]
operator|==
name|NUL
condition|)
block|{
name|matchCt
operator|=
literal|1
expr_stmt|;
name|matchIdx
operator|=
name|idx
expr_stmt|;
break|break;
block|}
block|}
comment|/*          *  IF       there is a disable name          *     *AND* no argument value has been supplied          *              (disabled options may have no argument)          *     *AND* the option name matches the disable name          *  THEN ...          */
elseif|else
if|if
condition|(
operator|(
name|pOD
operator|->
name|pz_DisableName
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strneqvcmp
argument_list|(
name|pzOptName
argument_list|,
name|pOD
operator|->
name|pz_DisableName
argument_list|,
name|nameLen
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|disable
operator|=
name|AG_TRUE
expr_stmt|;
comment|/*              *  IF we have a complete match              *  THEN it takes priority over any already located partial              */
if|if
condition|(
name|pOD
operator|->
name|pz_DisableName
index|[
name|nameLen
index|]
operator|==
name|NUL
condition|)
block|{
name|matchCt
operator|=
literal|1
expr_stmt|;
name|matchIdx
operator|=
name|idx
expr_stmt|;
break|break;
block|}
block|}
else|else
continue|continue;
comment|/*          *  We found a partial match, either regular or disabling.          *  Remember the index for later.          */
name|matchIdx
operator|=
name|idx
expr_stmt|;
if|if
condition|(
operator|++
name|matchCt
operator|>
literal|1
condition|)
break|break;
block|}
do|while
condition|(
name|pOD
operator|++
operator|,
operator|(
operator|++
name|idx
operator|<
name|idxLim
operator|)
condition|)
do|;
comment|/*      *  Make sure we either found an exact match or found only one partial      */
if|if
condition|(
name|matchCt
operator|==
literal|1
condition|)
block|{
name|pOD
operator|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|matchIdx
expr_stmt|;
if|if
condition|(
name|SKIP_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zDisabledErr
argument_list|,
name|pOpts
operator|->
name|pzProgName
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pOD
operator|->
name|pzText
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- %s"
argument_list|,
name|pOD
operator|->
name|pzText
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pOpts
operator|->
name|pUsageProc
call|)
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/*          *  IF we found a disablement name,          *  THEN set the bit in the callers' flag word          */
if|if
condition|(
name|disable
condition|)
name|pOptState
operator|->
name|flags
operator||=
name|OPTST_DISABLED
expr_stmt|;
name|pOptState
operator|->
name|pOD
operator|=
name|pOD
expr_stmt|;
name|pOptState
operator|->
name|pzOptArg
operator|=
name|pzEq
expr_stmt|;
name|pOptState
operator|->
name|optType
operator|=
name|TOPT_LONG
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
comment|/*      *  IF there is no equal sign      *     *AND* we are using named arguments      *     *AND* there is a default named option,      *  THEN return that option.      */
if|if
condition|(
operator|(
name|pzEq
operator|==
name|NULL
operator|)
operator|&&
name|NAMED_OPTS
argument_list|(
name|pOpts
argument_list|)
operator|&&
operator|(
name|pOpts
operator|->
name|specOptIdx
operator|.
name|default_opt
operator|!=
name|NO_EQUIVALENT
operator|)
condition|)
block|{
name|pOptState
operator|->
name|pOD
operator|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pOpts
operator|->
name|specOptIdx
operator|.
name|default_opt
expr_stmt|;
name|pOptState
operator|->
name|pzOptArg
operator|=
name|pzOptName
expr_stmt|;
name|pOptState
operator|->
name|optType
operator|=
name|TOPT_DEFAULT
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
comment|/*      *  IF we are to stop on errors (the default, actually)      *  THEN call the usage procedure.      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|(
name|matchCt
operator|==
literal|0
operator|)
condition|?
name|zIllOptStr
else|:
name|zAmbigOptStr
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
name|pzOptName
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pOpts
operator|->
name|pUsageProc
call|)
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|FAILURE
return|;
block|}
end_function

begin_comment
comment|/*  *  shortOptionFind  *  *  Find the short option descriptor for the current option  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|shortOptionFind
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|uint_t
name|optValue
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|pRes
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|ct
init|=
name|pOpts
operator|->
name|optCt
decl_stmt|;
comment|/*      *  Search the option list      */
do|do
block|{
if|if
condition|(
name|optValue
operator|!=
name|pRes
operator|->
name|optValue
condition|)
continue|continue;
if|if
condition|(
name|SKIP_OPT
argument_list|(
name|pRes
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pRes
operator|->
name|fOptState
operator|==
operator|(
name|OPTST_OMITTED
operator||
name|OPTST_NO_INIT
operator|)
operator|)
operator|&&
operator|(
name|pRes
operator|->
name|pz_Name
operator|!=
name|NULL
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zDisabledErr
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
name|pRes
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pRes
operator|->
name|pzText
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- %s"
argument_list|,
name|pRes
operator|->
name|pzText
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pOpts
operator|->
name|pUsageProc
call|)
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
goto|goto
name|short_opt_error
goto|;
block|}
name|pOptState
operator|->
name|pOD
operator|=
name|pRes
expr_stmt|;
name|pOptState
operator|->
name|optType
operator|=
name|TOPT_SHORT
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
do|while
condition|(
name|pRes
operator|++
operator|,
operator|--
name|ct
operator|>
literal|0
condition|)
do|;
comment|/*      *  IF    the character value is a digit      *    AND there is a special number option ("-n")      *  THEN the result is the "option" itself and the      *       option is the specially marked "number" option.      */
if|if
condition|(
name|IS_DEC_DIGIT_CHAR
argument_list|(
name|optValue
argument_list|)
operator|&&
operator|(
name|pOpts
operator|->
name|specOptIdx
operator|.
name|number_option
operator|!=
name|NO_EQUIVALENT
operator|)
condition|)
block|{
name|pOptState
operator|->
name|pOD
operator|=
expr|\
name|pRes
operator|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pOpts
operator|->
name|specOptIdx
operator|.
name|number_option
expr_stmt|;
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
operator|--
expr_stmt|;
name|pOptState
operator|->
name|optType
operator|=
name|TOPT_SHORT
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
name|short_opt_error
label|:
comment|/*      *  IF we are to stop on errors (the default, actually)      *  THEN call the usage procedure.      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zIllOptChr
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
name|optValue
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pOpts
operator|->
name|pUsageProc
call|)
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|FAILURE
return|;
block|}
end_function

begin_comment
comment|/*  *  findOptDesc  *  *  Find the option descriptor for the current option  */
end_comment

begin_function
specifier|static
name|tSuccess
name|findOptDesc
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
block|{
comment|/*      *  IF we are continuing a short option list (e.g. -xyz...)      *  THEN continue a single flag option.      *  OTHERWISE see if there is room to advance and then do so.      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|pOpts
operator|->
name|pzCurOpt
operator|!=
name|NUL
operator|)
condition|)
return|return
name|shortOptionFind
argument_list|(
name|pOpts
argument_list|,
operator|(
name|tAoUC
operator|)
operator|*
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
argument_list|,
name|pOptState
argument_list|)
return|;
if|if
condition|(
name|pOpts
operator|->
name|curOptIdx
operator|>=
name|pOpts
operator|->
name|origArgCt
condition|)
return|return
name|PROBLEM
return|;
comment|/* NORMAL COMPLETION */
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
name|pOpts
operator|->
name|curOptIdx
index|]
expr_stmt|;
comment|/*      *  IF all arguments must be named options, ...      */
if|if
condition|(
name|NAMED_OPTS
argument_list|(
name|pOpts
argument_list|)
condition|)
block|{
name|char
modifier|*
name|pz
init|=
name|pOpts
operator|->
name|pzCurOpt
decl_stmt|;
name|int
name|def
decl_stmt|;
name|tSuccess
name|res
decl_stmt|;
name|tAoUS
modifier|*
name|def_opt
decl_stmt|;
name|pOpts
operator|->
name|curOptIdx
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pz
operator|!=
literal|'-'
condition|)
return|return
name|longOptionFind
argument_list|(
name|pOpts
argument_list|,
name|pz
argument_list|,
name|pOptState
argument_list|)
return|;
comment|/*          *  The name is prefixed with one or more hyphens.  Strip them off          *  and disable the "default_opt" setting.  Use heavy recasting to          *  strip off the "const" quality of the "default_opt" field.          */
while|while
condition|(
operator|*
operator|(
operator|++
name|pz
operator|)
operator|==
literal|'-'
condition|)
empty_stmt|;
name|def_opt
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|pOpts
operator|->
name|specOptIdx
operator|.
name|default_opt
operator|)
expr_stmt|;
name|def
operator|=
operator|*
name|def_opt
expr_stmt|;
operator|*
name|def_opt
operator|=
name|NO_EQUIVALENT
expr_stmt|;
name|res
operator|=
name|longOptionFind
argument_list|(
name|pOpts
argument_list|,
name|pz
argument_list|,
name|pOptState
argument_list|)
expr_stmt|;
operator|*
name|def_opt
operator|=
name|def
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/*      *  Note the kind of flag/option marker      */
if|if
condition|(
operator|*
operator|(
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
operator|++
operator|)
operator|!=
literal|'-'
condition|)
return|return
name|PROBLEM
return|;
comment|/* NORMAL COMPLETION - this + rest are operands */
comment|/*      *  Special hack for a hyphen by itself      */
if|if
condition|(
operator|*
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
operator|==
name|NUL
condition|)
return|return
name|PROBLEM
return|;
comment|/* NORMAL COMPLETION - this + rest are operands */
comment|/*      *  The current argument is to be processed as an option argument      */
name|pOpts
operator|->
name|curOptIdx
operator|++
expr_stmt|;
comment|/*      *  We have an option marker.      *  Test the next character for long option indication      */
if|if
condition|(
name|pOpts
operator|->
name|pzCurOpt
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
operator|==
name|NUL
condition|)
comment|/*              *  NORMAL COMPLETION - NOT this arg, but rest are operands              */
return|return
name|PROBLEM
return|;
comment|/*          *  We do not allow the hyphen to be used as a flag value.          *  Therefore, if long options are not to be accepted, we punt.          */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_LONGOPT
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zIllOptStr
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
name|zIllegal
argument_list|,
name|pOpts
operator|->
name|pzCurOpt
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
return|return
name|longOptionFind
argument_list|(
name|pOpts
argument_list|,
name|pOpts
operator|->
name|pzCurOpt
argument_list|,
name|pOptState
argument_list|)
return|;
block|}
comment|/*      *  If short options are not allowed, then do long      *  option processing.  Otherwise the character must be a      *  short (i.e. single character) option.      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_SHORTOPT
operator|)
operator|!=
literal|0
condition|)
return|return
name|shortOptionFind
argument_list|(
name|pOpts
argument_list|,
operator|(
name|tAoUC
operator|)
operator|*
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
argument_list|,
name|pOptState
argument_list|)
return|;
return|return
name|longOptionFind
argument_list|(
name|pOpts
argument_list|,
name|pOpts
operator|->
name|pzCurOpt
argument_list|,
name|pOptState
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tSuccess
name|next_opt_arg_must
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
block|{
comment|/*      *  An option argument is required.  Long options can either have      *  a separate command line argument, or an argument attached by      *  the '=' character.  Figure out which.      */
switch|switch
condition|(
name|pOptState
operator|->
name|optType
condition|)
block|{
case|case
name|TOPT_SHORT
case|:
comment|/*          *  See if an arg string follows the flag character          */
if|if
condition|(
operator|*
operator|++
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
operator|==
name|NUL
condition|)
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
name|pOpts
operator|->
name|curOptIdx
operator|++
index|]
expr_stmt|;
name|pOptState
operator|->
name|pzOptArg
operator|=
name|pOpts
operator|->
name|pzCurOpt
expr_stmt|;
break|break;
case|case
name|TOPT_LONG
case|:
comment|/*          *  See if an arg string has already been assigned (glued on          *  with an `=' character)          */
if|if
condition|(
name|pOptState
operator|->
name|pzOptArg
operator|==
name|NULL
condition|)
name|pOptState
operator|->
name|pzOptArg
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
name|pOpts
operator|->
name|curOptIdx
operator|++
index|]
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|fputs
argument_list|(
literal|"AutoOpts lib error: option type not selected\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|TOPT_DEFAULT
case|:
comment|/*          *  The option was selected by default.  The current token is          *  the option argument.          */
break|break;
block|}
comment|/*      *  Make sure we did not overflow the argument list.      */
if|if
condition|(
name|pOpts
operator|->
name|curOptIdx
operator|>
name|pOpts
operator|->
name|origArgCt
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zMisArg
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
name|pOptState
operator|->
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
comment|/* next time advance to next arg */
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|tSuccess
name|next_opt_arg_may
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
block|{
comment|/*      *  An option argument is optional.      */
switch|switch
condition|(
name|pOptState
operator|->
name|optType
condition|)
block|{
case|case
name|TOPT_SHORT
case|:
if|if
condition|(
operator|*
operator|++
name|pOpts
operator|->
name|pzCurOpt
operator|!=
name|NUL
condition|)
name|pOptState
operator|->
name|pzOptArg
operator|=
name|pOpts
operator|->
name|pzCurOpt
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|pzLA
init|=
name|pOpts
operator|->
name|origArgVect
index|[
name|pOpts
operator|->
name|curOptIdx
index|]
decl_stmt|;
comment|/*              *  BECAUSE it is optional, we must make sure              *  we did not find another flag and that there              *  is such an argument.              */
if|if
condition|(
operator|(
name|pzLA
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|pzLA
operator|==
literal|'-'
operator|)
condition|)
name|pOptState
operator|->
name|pzOptArg
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|pOpts
operator|->
name|curOptIdx
operator|++
expr_stmt|;
comment|/* argument found */
name|pOptState
operator|->
name|pzOptArg
operator|=
name|pzLA
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TOPT_LONG
case|:
comment|/*          *  Look for an argument if we don't already have one (glued on          *  with a `=' character) *AND* we are not in named argument mode          */
if|if
condition|(
operator|(
name|pOptState
operator|->
name|pzOptArg
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|!
name|NAMED_OPTS
argument_list|(
name|pOpts
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|pzLA
init|=
name|pOpts
operator|->
name|origArgVect
index|[
name|pOpts
operator|->
name|curOptIdx
index|]
decl_stmt|;
comment|/*              *  BECAUSE it is optional, we must make sure              *  we did not find another flag and that there              *  is such an argument.              */
if|if
condition|(
operator|(
name|pzLA
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|pzLA
operator|==
literal|'-'
operator|)
condition|)
name|pOptState
operator|->
name|pzOptArg
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|pOpts
operator|->
name|curOptIdx
operator|++
expr_stmt|;
comment|/* argument found */
name|pOptState
operator|->
name|pzOptArg
operator|=
name|pzLA
expr_stmt|;
block|}
block|}
break|break;
default|default:
case|case
name|TOPT_DEFAULT
case|:
name|fputs
argument_list|(
name|zAO_Woops
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
comment|/*      *  After an option with an optional argument, we will      *  *always* start with the next option because if there      *  were any characters following the option name/flag,      *  they would be interpreted as the argument.      */
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|tSuccess
name|next_opt_arg_none
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
block|{
comment|/*      *  No option argument.  Make sure next time around we find      *  the correct option flag character for short options      */
if|if
condition|(
name|pOptState
operator|->
name|optType
operator|==
name|TOPT_SHORT
condition|)
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
operator|++
expr_stmt|;
comment|/*      *  It is a long option.  Make sure there was no ``=xxx'' argument      */
elseif|else
if|if
condition|(
name|pOptState
operator|->
name|pzOptArg
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zNoArg
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
name|pOptState
operator|->
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
comment|/*      *  It is a long option.  Advance to next command line argument.      */
else|else
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  *  nextOption  *  *  Find the option descriptor and option argument (if any) for the  *  next command line argument.  DO NOT modify the descriptor.  Put  *  all the state in the state argument so that the option can be skipped  *  without consequence (side effect).  */
end_comment

begin_function
specifier|static
name|tSuccess
name|nextOption
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
block|{
block|{
name|tSuccess
name|res
decl_stmt|;
name|res
operator|=
name|findOptDesc
argument_list|(
name|pOpts
argument_list|,
name|pOptState
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|res
argument_list|)
condition|)
return|return
name|res
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|pOptState
operator|->
name|flags
operator|&
name|OPTST_DEFINED
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|pOptState
operator|->
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_NO_COMMAND
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zNotCmdOpt
argument_list|,
name|pOptState
operator|->
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|pOptState
operator|->
name|flags
operator||=
operator|(
name|pOptState
operator|->
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_PERSISTENT_MASK
operator|)
expr_stmt|;
comment|/*      *  Figure out what to do about option arguments.  An argument may be      *  required, not associated with the option, or be optional.  We detect the      *  latter by examining for an option marker on the next possible argument.      *  Disabled mode option selection also disables option arguments.      */
block|{
enum|enum
block|{
name|ARG_NONE
block|,
name|ARG_MAY
block|,
name|ARG_MUST
block|}
name|arg_type
init|=
name|ARG_NONE
enum|;
name|tSuccess
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|pOptState
operator|->
name|flags
operator|&
name|OPTST_DISABLED
operator|)
operator|!=
literal|0
condition|)
name|arg_type
operator|=
name|ARG_NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOptState
operator|->
name|flags
argument_list|)
operator|==
name|OPARG_TYPE_NONE
condition|)
name|arg_type
operator|=
name|ARG_NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|pOptState
operator|->
name|flags
operator|&
name|OPTST_ARG_OPTIONAL
condition|)
name|arg_type
operator|=
name|ARG_MAY
expr_stmt|;
else|else
name|arg_type
operator|=
name|ARG_MUST
expr_stmt|;
switch|switch
condition|(
name|arg_type
condition|)
block|{
case|case
name|ARG_MUST
case|:
name|res
operator|=
name|next_opt_arg_must
argument_list|(
name|pOpts
argument_list|,
name|pOptState
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_MAY
case|:
name|res
operator|=
name|next_opt_arg_may
argument_list|(
name|pOpts
argument_list|,
name|pOptState
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_NONE
case|:
name|res
operator|=
name|next_opt_arg_none
argument_list|(
name|pOpts
argument_list|,
name|pOptState
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|res
return|;
block|}
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *  DO PRESETS  *  *  The next several routines do the immediate action pass on the command  *  line options, then the environment variables, then the config files in  *  reverse order.  Once done with that, the order is reversed and all  *  the config files and environment variables are processed again, this  *  time only processing the non-immediate action options.  doPresets()  *  will then return for optionProcess() to do the final pass on the command  *  line arguments.  */
end_comment

begin_comment
comment|/**  *  scan the command line for immediate action options.  *  This is only called the first time through.  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|doImmediateOpts
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|pOpts
operator|->
name|curOptIdx
operator|=
literal|1
expr_stmt|;
comment|/* start by skipping program name */
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
comment|/*      *  Examine all the options from the start.  We process any options that      *  are marked for immediate processing.      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|tOptState
name|optState
init|=
name|OPTSTATE_INITIALIZER
argument_list|(
name|PRESET
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|nextOption
argument_list|(
name|pOpts
argument_list|,
operator|&
name|optState
argument_list|)
condition|)
block|{
case|case
name|FAILURE
case|:
goto|goto
name|failed_option
goto|;
case|case
name|PROBLEM
case|:
return|return
name|SUCCESS
return|;
comment|/* no more args */
case|case
name|SUCCESS
case|:
break|break;
block|}
comment|/*          *  IF this is an immediate-attribute option, then do it.          */
if|if
condition|(
operator|!
name|DO_IMMEDIATELY
argument_list|(
name|optState
operator|.
name|flags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|handle_opt
argument_list|(
name|pOpts
argument_list|,
operator|&
name|optState
argument_list|)
argument_list|)
condition|)
break|break;
block|}
name|failed_option
label|:
empty_stmt|;
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|pOpts
operator|->
name|pUsageProc
call|)
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
end_function

begin_comment
comment|/**  * Process all the options from our current position onward.  (This allows  * interspersed options and arguments for the few non-standard programs that  * require it.)  Thus, do not rewind option indexes because some programs  * choose to re-invoke after a non-option.  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|doRegularOpts
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|tOptState
name|optState
init|=
name|OPTSTATE_INITIALIZER
argument_list|(
name|DEFINED
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|nextOption
argument_list|(
name|pOpts
argument_list|,
operator|&
name|optState
argument_list|)
condition|)
block|{
case|case
name|FAILURE
case|:
goto|goto
name|failed_option
goto|;
case|case
name|PROBLEM
case|:
return|return
name|SUCCESS
return|;
comment|/* no more args */
case|case
name|SUCCESS
case|:
break|break;
block|}
comment|/*          *  IF this is an immediate action option,          *  THEN skip it (unless we are supposed to do it a second time).          */
if|if
condition|(
operator|!
name|DO_NORMALLY
argument_list|(
name|optState
operator|.
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DO_SECOND_TIME
argument_list|(
name|optState
operator|.
name|flags
argument_list|)
condition|)
continue|continue;
name|optState
operator|.
name|pOD
operator|->
name|optOccCt
operator|--
expr_stmt|;
comment|/* don't count this repetition */
block|}
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|handle_opt
argument_list|(
name|pOpts
argument_list|,
operator|&
name|optState
argument_list|)
argument_list|)
condition|)
break|break;
block|}
name|failed_option
label|:
empty_stmt|;
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|pOpts
operator|->
name|pUsageProc
call|)
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
end_function

begin_comment
comment|/**  *  check for preset values from a config files or envrionment variables  */
end_comment

begin_function
specifier|static
name|tSuccess
name|doPresets
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|pOD
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|doImmediateOpts
argument_list|(
name|pOpts
argument_list|)
argument_list|)
condition|)
return|return
name|FAILURE
return|;
comment|/*      *  IF this option set has a --save-opts option, then it also      *  has a --load-opts option.  See if a command line option has disabled      *  option presetting.      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|specOptIdx
operator|.
name|save_opts
operator|!=
name|NO_EQUIVALENT
operator|)
operator|&&
operator|(
name|pOpts
operator|->
name|specOptIdx
operator|.
name|save_opts
operator|!=
literal|0
operator|)
condition|)
block|{
name|pOD
operator|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pOpts
operator|->
name|specOptIdx
operator|.
name|save_opts
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|DISABLED_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
return|return
name|SUCCESS
return|;
block|}
comment|/*      *  Until we return from this procedure, disable non-presettable opts      */
name|pOpts
operator|->
name|fOptSet
operator||=
name|OPTPROC_PRESETTING
expr_stmt|;
comment|/*      *  IF there are no config files,      *  THEN do any environment presets and leave.      */
if|if
condition|(
name|pOpts
operator|->
name|papzHomeList
operator|==
name|NULL
condition|)
block|{
name|doEnvPresets
argument_list|(
name|pOpts
argument_list|,
name|ENV_ALL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doEnvPresets
argument_list|(
name|pOpts
argument_list|,
name|ENV_IMM
argument_list|)
expr_stmt|;
comment|/*          *  Check to see if environment variables have disabled presetting.          */
if|if
condition|(
operator|(
name|pOD
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|DISABLED_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
name|internalFileLoad
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
comment|/*          *  ${PROGRAM_LOAD_OPTS} value of "no" cannot disable other environment          *  variable options.  Only the loading of .rc files.          */
name|doEnvPresets
argument_list|(
name|pOpts
argument_list|,
name|ENV_NON_IMM
argument_list|)
expr_stmt|;
block|}
name|pOpts
operator|->
name|fOptSet
operator|&=
operator|~
name|OPTPROC_PRESETTING
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *  VERIFY OPTION CONSISTENCY  *  *  Make sure that the argument list passes our consistency tests.  */
end_comment

begin_function
specifier|static
name|int
name|checkConsistency
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|int
name|errCt
init|=
literal|0
decl_stmt|;
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|oCt
init|=
name|pOpts
operator|->
name|presetOptCt
decl_stmt|;
comment|/*      *  FOR each of "oCt" options, ...      */
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|int
modifier|*
name|pMust
init|=
name|pOD
operator|->
name|pOptMust
decl_stmt|;
specifier|const
name|int
modifier|*
name|pCant
init|=
name|pOD
operator|->
name|pOptCant
decl_stmt|;
comment|/*          *  IF the current option was provided on the command line          *  THEN ensure that any "MUST" requirements are not          *       "DEFAULT" (unspecified) *AND* ensure that any          *       "CANT" options have not been SET or DEFINED.          */
if|if
condition|(
name|SELECTED_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
block|{
if|if
condition|(
name|pMust
operator|!=
name|NULL
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|tOptDesc
modifier|*
name|p
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
operator|*
operator|(
name|pMust
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|UNUSED_OPT
argument_list|(
name|p
argument_list|)
condition|)
block|{
specifier|const
name|tOptDesc
modifier|*
name|pN
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pMust
index|[
operator|-
literal|1
index|]
decl_stmt|;
name|errCt
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zReqFmt
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
name|pN
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pMust
operator|==
name|NO_EQUIVALENT
condition|)
break|break;
block|}
if|if
condition|(
name|pCant
operator|!=
name|NULL
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|tOptDesc
modifier|*
name|p
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
operator|*
operator|(
name|pCant
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|SELECTED_OPT
argument_list|(
name|p
argument_list|)
condition|)
block|{
specifier|const
name|tOptDesc
modifier|*
name|pN
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pCant
index|[
operator|-
literal|1
index|]
decl_stmt|;
name|errCt
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zCantFmt
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
name|pN
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pCant
operator|==
name|NO_EQUIVALENT
condition|)
break|break;
block|}
block|}
comment|/*          *  IF       this option is not equivalenced to another,          *        OR it is equivalenced to itself (is the equiv. root)          *  THEN we need to make sure it occurs often enough.          */
if|if
condition|(
operator|(
name|pOD
operator|->
name|optEquivIndex
operator|==
name|NO_EQUIVALENT
operator|)
operator|||
operator|(
name|pOD
operator|->
name|optEquivIndex
operator|==
name|pOD
operator|->
name|optIndex
operator|)
condition|)
do|do
block|{
comment|/*              *  IF the occurrence counts have been satisfied,              *  THEN there is no problem.              */
if|if
condition|(
name|pOD
operator|->
name|optOccCt
operator|>=
name|pOD
operator|->
name|optMinCt
condition|)
break|break;
comment|/*              *  IF MUST_SET means SET and PRESET are okay,              *  so min occurrence count doesn't count              */
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_MUST_SET
operator|)
operator|&&
operator|(
name|pOD
operator|->
name|fOptState
operator|&
operator|(
name|OPTST_PRESET
operator||
name|OPTST_SET
operator|)
operator|)
condition|)
break|break;
name|errCt
operator|++
expr_stmt|;
if|if
condition|(
name|pOD
operator|->
name|optMinCt
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zNotEnough
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
name|pOD
operator|->
name|optMinCt
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zNeedOne
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
operator|--
name|oCt
operator|<=
literal|0
condition|)
break|break;
name|pOD
operator|++
expr_stmt|;
block|}
comment|/*      *  IF we are stopping on errors, check to see if any remaining      *  arguments are required to be there or prohibited from being there.      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/*          *  Check for prohibition          */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_NO_ARGS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pOpts
operator|->
name|origArgCt
operator|>
name|pOpts
operator|->
name|curOptIdx
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zNoArgs
argument_list|,
name|pOpts
operator|->
name|pzProgName
argument_list|)
expr_stmt|;
operator|++
name|errCt
expr_stmt|;
block|}
block|}
comment|/*          *  ELSE not prohibited, check for being required          */
elseif|else
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ARGS_REQ
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pOpts
operator|->
name|origArgCt
operator|<=
name|pOpts
operator|->
name|curOptIdx
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zArgsMust
argument_list|,
name|pOpts
operator|->
name|pzProgName
argument_list|)
expr_stmt|;
operator|++
name|errCt
expr_stmt|;
block|}
block|}
block|}
return|return
name|errCt
return|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *  THESE ROUTINES ARE CALLABLE FROM THE GENERATED OPTION PROCESSING CODE  */
end_comment

begin_comment
comment|/*=--subblock=arg=arg_type,arg_name,arg_desc =*/
end_comment

begin_comment
comment|/*=*  * library:  opts  * header:   your-opts.h  *  * lib_description:  *  *  These are the routines that libopts users may call directly from their  *  code.  There are several other routines that can be called by code  *  generated by the libopts option templates, but they are not to be  *  called from any other user code.  The @file{options.h} header is  *  fairly clear about this, too. =*/
end_comment

begin_comment
comment|/*=export_func optionProcess  *  * what: this is the main option processing routine  *  * arg:  + tOptions* + pOpts + program options descriptor +  * arg:  + int       + argc  + program arg count  +  * arg:  + char**    + argv  + program arg vector +  *  * ret_type:  int  * ret_desc:  the count of the arguments processed  *  * doc:  *  * This is the main entry point for processing options.  It is intended  * that this procedure be called once at the beginning of the execution of  * a program.  Depending on options selected earlier, it is sometimes  * necessary to stop and restart option processing, or to select completely  * different sets of options.  This can be done easily, but you generally  * do not want to do this.  *  * The number of arguments processed always includes the program name.  * If one of the arguments is "--", then it is counted and the processing  * stops.  If an error was encountered and errors are to be tolerated, then  * the returned value is the index of the argument causing the error.  * A hyphen by itself ("-") will also cause processing to stop and will  * @emph{not} be counted among the processed arguments.  A hyphen by itself  * is treated as an operand.  Encountering an operand stops option  * processing.  *  * err:  Errors will cause diagnostics to be printed.  @code{exit(3)} may  *       or may not be called.  It depends upon whether or not the options  *       were generated with the "allow-errors" attribute, or if the  *       ERRSKIP_OPTERR or ERRSTOP_OPTERR macros were invoked. =*/
end_comment

begin_function
name|int
name|optionProcess
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|int
name|argCt
parameter_list|,
name|char
modifier|*
modifier|*
name|argVect
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|validateOptionsStruct
argument_list|(
name|pOpts
argument_list|,
name|argVect
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
comment|/*      *  Establish the real program name, the program full path,      *  and do all the presetting the first time thru only.      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_INITDONE
operator|)
operator|==
literal|0
condition|)
block|{
name|pOpts
operator|->
name|origArgCt
operator|=
name|argCt
expr_stmt|;
name|pOpts
operator|->
name|origArgVect
operator|=
name|argVect
expr_stmt|;
name|pOpts
operator|->
name|fOptSet
operator||=
name|OPTPROC_INITDONE
expr_stmt|;
if|if
condition|(
name|HAS_pzPkgDataDir
argument_list|(
name|pOpts
argument_list|)
condition|)
name|program_pkgdatadir
operator|=
name|pOpts
operator|->
name|pzPkgDataDir
expr_stmt|;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|doPresets
argument_list|(
name|pOpts
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/*          *  IF option name conversion was suppressed but it is not suppressed          *  for the command line, then it's time to translate option names.          *  Usage text will not get retranslated.          */
if|if
condition|(
operator|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_TRANSLATE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|pOpts
operator|->
name|pTransProc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_NO_XLAT_MASK
operator|)
operator|==
name|OPTPROC_NXLAT_OPT_CFG
operator|)
condition|)
block|{
name|pOpts
operator|->
name|fOptSet
operator|&=
operator|~
name|OPTPROC_NXLAT_OPT_CFG
expr_stmt|;
call|(
modifier|*
name|pOpts
operator|->
name|pTransProc
call|)
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_REORDER
operator|)
operator|!=
literal|0
condition|)
name|optionSort
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
name|pOpts
operator|->
name|curOptIdx
operator|=
literal|1
expr_stmt|;
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      *  IF we are (re)starting,      *  THEN reset option location      */
elseif|else
if|if
condition|(
name|pOpts
operator|->
name|curOptIdx
operator|<=
literal|0
condition|)
block|{
name|pOpts
operator|->
name|curOptIdx
operator|=
literal|1
expr_stmt|;
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|doRegularOpts
argument_list|(
name|pOpts
argument_list|)
argument_list|)
condition|)
return|return
name|pOpts
operator|->
name|origArgCt
return|;
comment|/*      *  IF    there were no errors      *    AND we have RC/INI files      *    AND there is a request to save the files      *  THEN do that now before testing for conflicts.      *       (conflicts are ignored in preset options)      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|specOptIdx
operator|.
name|save_opts
operator|!=
name|NO_EQUIVALENT
operator|)
operator|&&
operator|(
name|pOpts
operator|->
name|specOptIdx
operator|.
name|save_opts
operator|!=
literal|0
operator|)
condition|)
block|{
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pOpts
operator|->
name|specOptIdx
operator|.
name|save_opts
decl_stmt|;
if|if
condition|(
name|SELECTED_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
block|{
name|optionSaveFile
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      *  IF we are checking for errors,      *  THEN look for too few occurrences of required options      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|checkConsistency
argument_list|(
name|pOpts
argument_list|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|pOpts
operator|->
name|pUsageProc
call|)
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|pOpts
operator|->
name|curOptIdx
return|;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/autoopts.c */
end_comment

end_unit

