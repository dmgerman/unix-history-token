begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parse a time duration and return a seconds count    Copyright (C) 2008-2014 Free Software Foundation, Inc.    Written by Bruce Korb<bkorb@gnu.org>, 2008.     This program is free software: you can redistribute it and/or modify    it under the terms of the GNU Lesser General Public License as published by    the Free Software Foundation; either version 2.1 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public License    along with this program.  If not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_comment
comment|/* Specification.  */
end_comment

begin_include
include|#
directive|include
file|"parse-duration.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"intprops.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NUL
end_ifndef

begin_define
define|#
directive|define
name|NUL
value|'\0'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|cch_t
value|char const
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|NOTHING_IS_DONE
block|,
name|YEAR_IS_DONE
block|,
name|MONTH_IS_DONE
block|,
name|WEEK_IS_DONE
block|,
name|DAY_IS_DONE
block|,
name|HOUR_IS_DONE
block|,
name|MINUTE_IS_DONE
block|,
name|SECOND_IS_DONE
block|}
name|whats_done_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|SEC_PER_MIN
value|60
end_define

begin_define
define|#
directive|define
name|SEC_PER_HR
value|(SEC_PER_MIN * 60)
end_define

begin_define
define|#
directive|define
name|SEC_PER_DAY
value|(SEC_PER_HR  * 24)
end_define

begin_define
define|#
directive|define
name|SEC_PER_WEEK
value|(SEC_PER_DAY * 7)
end_define

begin_define
define|#
directive|define
name|SEC_PER_MONTH
value|(SEC_PER_DAY * 30)
end_define

begin_define
define|#
directive|define
name|SEC_PER_YEAR
value|(SEC_PER_DAY * 365)
end_define

begin_undef
undef|#
directive|undef
name|MAX_DURATION
end_undef

begin_define
define|#
directive|define
name|MAX_DURATION
value|TYPE_MAXIMUM(time_t)
end_define

begin_comment
comment|/* Wrapper around strtoul that does not require a cast.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|str_const_to_ul
parameter_list|(
name|cch_t
modifier|*
name|str
parameter_list|,
name|cch_t
modifier|*
modifier|*
name|ppz
parameter_list|,
name|int
name|base
parameter_list|)
block|{
return|return
name|strtoul
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|ppz
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Wrapper around strtol that does not require a cast.  */
end_comment

begin_function
specifier|static
name|long
name|str_const_to_l
parameter_list|(
name|cch_t
modifier|*
name|str
parameter_list|,
name|cch_t
modifier|*
modifier|*
name|ppz
parameter_list|,
name|int
name|base
parameter_list|)
block|{
return|return
name|strtol
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|ppz
argument_list|,
name|base
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns BASE + VAL * SCALE, interpreting BASE = BAD_TIME    with errno set as an error situation, and returning BAD_TIME    with errno set in an error situation.  */
end_comment

begin_function
specifier|static
name|time_t
name|scale_n_add
parameter_list|(
name|time_t
name|base
parameter_list|,
name|time_t
name|val
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
if|if
condition|(
name|base
operator|==
name|BAD_TIME
condition|)
block|{
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|BAD_TIME
return|;
block|}
if|if
condition|(
name|val
operator|>
name|MAX_DURATION
operator|/
name|scale
condition|)
block|{
name|errno
operator|=
name|ERANGE
expr_stmt|;
return|return
name|BAD_TIME
return|;
block|}
name|val
operator|*=
name|scale
expr_stmt|;
if|if
condition|(
name|base
operator|>
name|MAX_DURATION
operator|-
name|val
condition|)
block|{
name|errno
operator|=
name|ERANGE
expr_stmt|;
return|return
name|BAD_TIME
return|;
block|}
return|return
name|base
operator|+
name|val
return|;
block|}
end_function

begin_comment
comment|/* After a number HH has been parsed, parse subsequent :MM or :MM:SS.  */
end_comment

begin_function
specifier|static
name|time_t
name|parse_hr_min_sec
parameter_list|(
name|time_t
name|start
parameter_list|,
name|cch_t
modifier|*
name|pz
parameter_list|)
block|{
name|int
name|lpct
init|=
literal|0
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* For as long as our scanner pointer points to a colon *AND*      we've not looped before, then keep looping.  (two iterations max) */
while|while
condition|(
operator|(
operator|*
name|pz
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|lpct
operator|++
operator|<=
literal|1
operator|)
condition|)
block|{
name|unsigned
name|long
name|v
init|=
name|str_const_to_ul
argument_list|(
name|pz
operator|+
literal|1
argument_list|,
operator|&
name|pz
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
return|return
name|BAD_TIME
return|;
name|start
operator|=
name|scale_n_add
argument_list|(
name|v
argument_list|,
name|start
argument_list|,
literal|60
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
return|return
name|BAD_TIME
return|;
block|}
comment|/* allow for trailing spaces */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|pz
argument_list|)
condition|)
name|pz
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pz
operator|!=
name|NUL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|BAD_TIME
return|;
block|}
return|return
name|start
return|;
block|}
end_function

begin_comment
comment|/* Parses a value and returns BASE + value * SCALE, interpreting    BASE = BAD_TIME with errno set as an error situation, and returning    BAD_TIME with errno set in an error situation.  */
end_comment

begin_function
specifier|static
name|time_t
name|parse_scaled_value
parameter_list|(
name|time_t
name|base
parameter_list|,
name|cch_t
modifier|*
modifier|*
name|ppz
parameter_list|,
name|cch_t
modifier|*
name|endp
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
name|cch_t
modifier|*
name|pz
init|=
operator|*
name|ppz
decl_stmt|;
name|time_t
name|val
decl_stmt|;
if|if
condition|(
name|base
operator|==
name|BAD_TIME
condition|)
return|return
name|base
return|;
name|errno
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|str_const_to_ul
argument_list|(
name|pz
argument_list|,
operator|&
name|pz
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
return|return
name|BAD_TIME
return|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|pz
argument_list|)
condition|)
name|pz
operator|++
expr_stmt|;
if|if
condition|(
name|pz
operator|!=
name|endp
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|BAD_TIME
return|;
block|}
operator|*
name|ppz
operator|=
name|pz
expr_stmt|;
return|return
name|scale_n_add
argument_list|(
name|base
argument_list|,
name|val
argument_list|,
name|scale
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parses the syntax YEAR-MONTH-DAY.    PS points into the string, after "YEAR", before "-MONTH-DAY".  */
end_comment

begin_function
specifier|static
name|time_t
name|parse_year_month_day
parameter_list|(
name|cch_t
modifier|*
name|pz
parameter_list|,
name|cch_t
modifier|*
name|ps
parameter_list|)
block|{
name|time_t
name|res
init|=
literal|0
decl_stmt|;
name|res
operator|=
name|parse_scaled_value
argument_list|(
literal|0
argument_list|,
operator|&
name|pz
argument_list|,
name|ps
argument_list|,
name|SEC_PER_YEAR
argument_list|)
expr_stmt|;
name|pz
operator|++
expr_stmt|;
comment|/* over the first '-' */
name|ps
operator|=
name|strchr
argument_list|(
name|pz
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|BAD_TIME
return|;
block|}
name|res
operator|=
name|parse_scaled_value
argument_list|(
name|res
argument_list|,
operator|&
name|pz
argument_list|,
name|ps
argument_list|,
name|SEC_PER_MONTH
argument_list|)
expr_stmt|;
name|pz
operator|++
expr_stmt|;
comment|/* over the second '-' */
name|ps
operator|=
name|pz
operator|+
name|strlen
argument_list|(
name|pz
argument_list|)
expr_stmt|;
return|return
name|parse_scaled_value
argument_list|(
name|res
argument_list|,
operator|&
name|pz
argument_list|,
name|ps
argument_list|,
name|SEC_PER_DAY
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parses the syntax YYYYMMDD.  */
end_comment

begin_function
specifier|static
name|time_t
name|parse_yearmonthday
parameter_list|(
name|cch_t
modifier|*
name|in_pz
parameter_list|)
block|{
name|time_t
name|res
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|cch_t
modifier|*
name|pz
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|in_pz
argument_list|)
operator|!=
literal|8
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|BAD_TIME
return|;
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
name|in_pz
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|NUL
expr_stmt|;
name|pz
operator|=
name|buf
expr_stmt|;
name|res
operator|=
name|parse_scaled_value
argument_list|(
literal|0
argument_list|,
operator|&
name|pz
argument_list|,
name|buf
operator|+
literal|4
argument_list|,
name|SEC_PER_YEAR
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|in_pz
operator|+
literal|4
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|NUL
expr_stmt|;
name|pz
operator|=
name|buf
expr_stmt|;
name|res
operator|=
name|parse_scaled_value
argument_list|(
name|res
argument_list|,
operator|&
name|pz
argument_list|,
name|buf
operator|+
literal|2
argument_list|,
name|SEC_PER_MONTH
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|in_pz
operator|+
literal|6
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|NUL
expr_stmt|;
name|pz
operator|=
name|buf
expr_stmt|;
return|return
name|parse_scaled_value
argument_list|(
name|res
argument_list|,
operator|&
name|pz
argument_list|,
name|buf
operator|+
literal|2
argument_list|,
name|SEC_PER_DAY
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parses the syntax yy Y mm M ww W dd D.  */
end_comment

begin_function
specifier|static
name|time_t
name|parse_YMWD
parameter_list|(
name|cch_t
modifier|*
name|pz
parameter_list|)
block|{
name|time_t
name|res
init|=
literal|0
decl_stmt|;
name|cch_t
modifier|*
name|ps
init|=
name|strchr
argument_list|(
name|pz
argument_list|,
literal|'Y'
argument_list|)
decl_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
block|{
name|res
operator|=
name|parse_scaled_value
argument_list|(
literal|0
argument_list|,
operator|&
name|pz
argument_list|,
name|ps
argument_list|,
name|SEC_PER_YEAR
argument_list|)
expr_stmt|;
name|pz
operator|++
expr_stmt|;
block|}
name|ps
operator|=
name|strchr
argument_list|(
name|pz
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
block|{
name|res
operator|=
name|parse_scaled_value
argument_list|(
name|res
argument_list|,
operator|&
name|pz
argument_list|,
name|ps
argument_list|,
name|SEC_PER_MONTH
argument_list|)
expr_stmt|;
name|pz
operator|++
expr_stmt|;
block|}
name|ps
operator|=
name|strchr
argument_list|(
name|pz
argument_list|,
literal|'W'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
block|{
name|res
operator|=
name|parse_scaled_value
argument_list|(
name|res
argument_list|,
operator|&
name|pz
argument_list|,
name|ps
argument_list|,
name|SEC_PER_WEEK
argument_list|)
expr_stmt|;
name|pz
operator|++
expr_stmt|;
block|}
name|ps
operator|=
name|strchr
argument_list|(
name|pz
argument_list|,
literal|'D'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
block|{
name|res
operator|=
name|parse_scaled_value
argument_list|(
name|res
argument_list|,
operator|&
name|pz
argument_list|,
name|ps
argument_list|,
name|SEC_PER_DAY
argument_list|)
expr_stmt|;
name|pz
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|pz
argument_list|)
condition|)
name|pz
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pz
operator|!=
name|NUL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|BAD_TIME
return|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Parses the syntax HH:MM:SS.    PS points into the string, after "HH", before ":MM:SS".  */
end_comment

begin_function
specifier|static
name|time_t
name|parse_hour_minute_second
parameter_list|(
name|cch_t
modifier|*
name|pz
parameter_list|,
name|cch_t
modifier|*
name|ps
parameter_list|)
block|{
name|time_t
name|res
init|=
literal|0
decl_stmt|;
name|res
operator|=
name|parse_scaled_value
argument_list|(
literal|0
argument_list|,
operator|&
name|pz
argument_list|,
name|ps
argument_list|,
name|SEC_PER_HR
argument_list|)
expr_stmt|;
name|pz
operator|++
expr_stmt|;
name|ps
operator|=
name|strchr
argument_list|(
name|pz
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|BAD_TIME
return|;
block|}
name|res
operator|=
name|parse_scaled_value
argument_list|(
name|res
argument_list|,
operator|&
name|pz
argument_list|,
name|ps
argument_list|,
name|SEC_PER_MIN
argument_list|)
expr_stmt|;
name|pz
operator|++
expr_stmt|;
name|ps
operator|=
name|pz
operator|+
name|strlen
argument_list|(
name|pz
argument_list|)
expr_stmt|;
return|return
name|parse_scaled_value
argument_list|(
name|res
argument_list|,
operator|&
name|pz
argument_list|,
name|ps
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parses the syntax HHMMSS.  */
end_comment

begin_function
specifier|static
name|time_t
name|parse_hourminutesecond
parameter_list|(
name|cch_t
modifier|*
name|in_pz
parameter_list|)
block|{
name|time_t
name|res
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|cch_t
modifier|*
name|pz
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|in_pz
argument_list|)
operator|!=
literal|6
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|BAD_TIME
return|;
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
name|in_pz
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|NUL
expr_stmt|;
name|pz
operator|=
name|buf
expr_stmt|;
name|res
operator|=
name|parse_scaled_value
argument_list|(
literal|0
argument_list|,
operator|&
name|pz
argument_list|,
name|buf
operator|+
literal|2
argument_list|,
name|SEC_PER_HR
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|in_pz
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|NUL
expr_stmt|;
name|pz
operator|=
name|buf
expr_stmt|;
name|res
operator|=
name|parse_scaled_value
argument_list|(
name|res
argument_list|,
operator|&
name|pz
argument_list|,
name|buf
operator|+
literal|2
argument_list|,
name|SEC_PER_MIN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|in_pz
operator|+
literal|4
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|NUL
expr_stmt|;
name|pz
operator|=
name|buf
expr_stmt|;
return|return
name|parse_scaled_value
argument_list|(
name|res
argument_list|,
operator|&
name|pz
argument_list|,
name|buf
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parses the syntax hh H mm M ss S.  */
end_comment

begin_function
specifier|static
name|time_t
name|parse_HMS
parameter_list|(
name|cch_t
modifier|*
name|pz
parameter_list|)
block|{
name|time_t
name|res
init|=
literal|0
decl_stmt|;
name|cch_t
modifier|*
name|ps
init|=
name|strchr
argument_list|(
name|pz
argument_list|,
literal|'H'
argument_list|)
decl_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
block|{
name|res
operator|=
name|parse_scaled_value
argument_list|(
literal|0
argument_list|,
operator|&
name|pz
argument_list|,
name|ps
argument_list|,
name|SEC_PER_HR
argument_list|)
expr_stmt|;
name|pz
operator|++
expr_stmt|;
block|}
name|ps
operator|=
name|strchr
argument_list|(
name|pz
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
block|{
name|res
operator|=
name|parse_scaled_value
argument_list|(
name|res
argument_list|,
operator|&
name|pz
argument_list|,
name|ps
argument_list|,
name|SEC_PER_MIN
argument_list|)
expr_stmt|;
name|pz
operator|++
expr_stmt|;
block|}
name|ps
operator|=
name|strchr
argument_list|(
name|pz
argument_list|,
literal|'S'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
block|{
name|res
operator|=
name|parse_scaled_value
argument_list|(
name|res
argument_list|,
operator|&
name|pz
argument_list|,
name|ps
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pz
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|pz
argument_list|)
condition|)
name|pz
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pz
operator|!=
name|NUL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|BAD_TIME
return|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Parses a time (hours, minutes, seconds) specification in either syntax.  */
end_comment

begin_function
specifier|static
name|time_t
name|parse_time
parameter_list|(
name|cch_t
modifier|*
name|pz
parameter_list|)
block|{
name|cch_t
modifier|*
name|ps
decl_stmt|;
name|time_t
name|res
init|=
literal|0
decl_stmt|;
comment|/*    *  Scan for a hyphen    */
name|ps
operator|=
name|strchr
argument_list|(
name|pz
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
block|{
name|res
operator|=
name|parse_hour_minute_second
argument_list|(
name|pz
argument_list|,
name|ps
argument_list|)
expr_stmt|;
block|}
comment|/*    *  Try for a 'H', 'M' or 'S' suffix    */
elseif|else
if|if
condition|(
name|ps
operator|=
name|strpbrk
argument_list|(
name|pz
argument_list|,
literal|"HMS"
argument_list|)
operator|,
name|ps
operator|==
name|NULL
condition|)
block|{
comment|/* Its a YYYYMMDD format: */
name|res
operator|=
name|parse_hourminutesecond
argument_list|(
name|pz
argument_list|)
expr_stmt|;
block|}
else|else
name|res
operator|=
name|parse_HMS
argument_list|(
name|pz
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Returns a substring of the given string, with spaces at the beginning and at    the end destructively removed, per SNOBOL.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|trim
parameter_list|(
name|char
modifier|*
name|pz
parameter_list|)
block|{
comment|/* trim leading white space */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|pz
argument_list|)
condition|)
name|pz
operator|++
expr_stmt|;
comment|/* trim trailing white space */
block|{
name|char
modifier|*
name|pe
init|=
name|pz
operator|+
name|strlen
argument_list|(
name|pz
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|pe
operator|>
name|pz
operator|)
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|pe
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|pe
operator|--
expr_stmt|;
operator|*
name|pe
operator|=
name|NUL
expr_stmt|;
block|}
return|return
name|pz
return|;
block|}
end_function

begin_comment
comment|/*  *  Parse the year/months/days of a time period  */
end_comment

begin_function
specifier|static
name|time_t
name|parse_period
parameter_list|(
name|cch_t
modifier|*
name|in_pz
parameter_list|)
block|{
name|char
modifier|*
name|pT
decl_stmt|;
name|char
modifier|*
name|ps
decl_stmt|;
name|char
modifier|*
name|pz
init|=
name|strdup
argument_list|(
name|in_pz
argument_list|)
decl_stmt|;
name|void
modifier|*
name|fptr
init|=
name|pz
decl_stmt|;
name|time_t
name|res
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pz
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|BAD_TIME
return|;
block|}
name|pT
operator|=
name|strchr
argument_list|(
name|pz
argument_list|,
literal|'T'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pT
operator|!=
name|NULL
condition|)
block|{
operator|*
operator|(
name|pT
operator|++
operator|)
operator|=
name|NUL
expr_stmt|;
name|pz
operator|=
name|trim
argument_list|(
name|pz
argument_list|)
expr_stmt|;
name|pT
operator|=
name|trim
argument_list|(
name|pT
argument_list|)
expr_stmt|;
block|}
comment|/*    *  Scan for a hyphen    */
name|ps
operator|=
name|strchr
argument_list|(
name|pz
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
block|{
name|res
operator|=
name|parse_year_month_day
argument_list|(
name|pz
argument_list|,
name|ps
argument_list|)
expr_stmt|;
block|}
comment|/*    *  Try for a 'Y', 'M' or 'D' suffix    */
elseif|else
if|if
condition|(
name|ps
operator|=
name|strpbrk
argument_list|(
name|pz
argument_list|,
literal|"YMWD"
argument_list|)
operator|,
name|ps
operator|==
name|NULL
condition|)
block|{
comment|/* Its a YYYYMMDD format: */
name|res
operator|=
name|parse_yearmonthday
argument_list|(
name|pz
argument_list|)
expr_stmt|;
block|}
else|else
name|res
operator|=
name|parse_YMWD
argument_list|(
name|pz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|errno
operator|==
literal|0
operator|)
operator|&&
operator|(
name|pT
operator|!=
name|NULL
operator|)
condition|)
block|{
name|time_t
name|val
init|=
name|parse_time
argument_list|(
name|pT
argument_list|)
decl_stmt|;
name|res
operator|=
name|scale_n_add
argument_list|(
name|res
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fptr
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|parse_non_iso8601
parameter_list|(
name|cch_t
modifier|*
name|pz
parameter_list|)
block|{
name|whats_done_t
name|whatd_we_do
init|=
name|NOTHING_IS_DONE
decl_stmt|;
name|time_t
name|res
init|=
literal|0
decl_stmt|;
do|do
block|{
name|time_t
name|val
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|str_const_to_l
argument_list|(
name|pz
argument_list|,
operator|&
name|pz
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
goto|goto
name|bad_time
goto|;
comment|/*  IF we find a colon, then we're going to have a seconds value.         We will not loop here any more.  We cannot already have parsed         a minute value and if we've parsed an hour value, then the result         value has to be less than an hour. */
if|if
condition|(
operator|*
name|pz
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|whatd_we_do
operator|>=
name|MINUTE_IS_DONE
condition|)
break|break;
name|val
operator|=
name|parse_hr_min_sec
argument_list|(
name|val
argument_list|,
name|pz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|whatd_we_do
operator|==
name|HOUR_IS_DONE
operator|)
operator|&&
operator|(
name|val
operator|>=
name|SEC_PER_HR
operator|)
condition|)
break|break;
return|return
name|scale_n_add
argument_list|(
name|res
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
return|;
block|}
block|{
name|unsigned
name|int
name|mult
decl_stmt|;
comment|/*  Skip over white space following the number we just parsed. */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|pz
argument_list|)
condition|)
name|pz
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|pz
condition|)
block|{
default|default:
goto|goto
name|bad_time
goto|;
case|case
name|NUL
case|:
return|return
name|scale_n_add
argument_list|(
name|res
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
return|;
case|case
literal|'y'
case|:
case|case
literal|'Y'
case|:
if|if
condition|(
name|whatd_we_do
operator|>=
name|YEAR_IS_DONE
condition|)
goto|goto
name|bad_time
goto|;
name|mult
operator|=
name|SEC_PER_YEAR
expr_stmt|;
name|whatd_we_do
operator|=
name|YEAR_IS_DONE
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|whatd_we_do
operator|>=
name|MONTH_IS_DONE
condition|)
goto|goto
name|bad_time
goto|;
name|mult
operator|=
name|SEC_PER_MONTH
expr_stmt|;
name|whatd_we_do
operator|=
name|MONTH_IS_DONE
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
name|whatd_we_do
operator|>=
name|WEEK_IS_DONE
condition|)
goto|goto
name|bad_time
goto|;
name|mult
operator|=
name|SEC_PER_WEEK
expr_stmt|;
name|whatd_we_do
operator|=
name|WEEK_IS_DONE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
if|if
condition|(
name|whatd_we_do
operator|>=
name|DAY_IS_DONE
condition|)
goto|goto
name|bad_time
goto|;
name|mult
operator|=
name|SEC_PER_DAY
expr_stmt|;
name|whatd_we_do
operator|=
name|DAY_IS_DONE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|whatd_we_do
operator|>=
name|HOUR_IS_DONE
condition|)
goto|goto
name|bad_time
goto|;
name|mult
operator|=
name|SEC_PER_HR
expr_stmt|;
name|whatd_we_do
operator|=
name|HOUR_IS_DONE
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|whatd_we_do
operator|>=
name|MINUTE_IS_DONE
condition|)
goto|goto
name|bad_time
goto|;
name|mult
operator|=
name|SEC_PER_MIN
expr_stmt|;
name|whatd_we_do
operator|=
name|MINUTE_IS_DONE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|mult
operator|=
literal|1
expr_stmt|;
name|whatd_we_do
operator|=
name|SECOND_IS_DONE
expr_stmt|;
break|break;
block|}
name|res
operator|=
name|scale_n_add
argument_list|(
name|res
argument_list|,
name|val
argument_list|,
name|mult
argument_list|)
expr_stmt|;
name|pz
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|pz
argument_list|)
condition|)
name|pz
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pz
operator|==
name|NUL
condition|)
return|return
name|res
return|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|pz
argument_list|)
condition|)
break|break;
block|}
block|}
do|while
condition|(
name|whatd_we_do
operator|<
name|SECOND_IS_DONE
condition|)
do|;
name|bad_time
label|:
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|BAD_TIME
return|;
block|}
end_function

begin_function
name|time_t
name|parse_duration
parameter_list|(
name|char
specifier|const
modifier|*
name|pz
parameter_list|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|pz
argument_list|)
condition|)
name|pz
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|pz
condition|)
block|{
case|case
literal|'P'
case|:
return|return
name|parse_period
argument_list|(
name|pz
operator|+
literal|1
argument_list|)
return|;
case|case
literal|'T'
case|:
return|return
name|parse_time
argument_list|(
name|pz
operator|+
literal|1
argument_list|)
return|;
default|default:
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|pz
argument_list|)
condition|)
return|return
name|parse_non_iso8601
argument_list|(
name|pz
argument_list|)
return|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|BAD_TIME
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * mode: C  * c-file-style: "gnu"  * indent-tabs-mode: nil  * End:  * end of parse-duration.c */
end_comment

end_unit

