begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  *  \file load.c  *  Time-stamp:      "2010-12-18 11:46:07 bkorb"  *  *  This file contains the routines that deal with processing text strings  *  for options, either from a NUL-terminated string passed in or from an  *  rc/ini file.  *  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (c) 1992-2011 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following md5sums:  *  *  43b91e8ca915626ed3818ffb1b71248b pkg/libopts/COPYING.gplv3  *  06a1a2e4760c90ea5e1dad8dfaac4d39 pkg/libopts/COPYING.lgplv3  *  66a5cedaf62c4b2637025f049f9b826f pkg/libopts/COPYING.mbsd  */
end_comment

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|ag_bool
name|insertProgramPath
parameter_list|(
name|char
modifier|*
name|pzBuf
parameter_list|,
name|int
name|bufSize
parameter_list|,
name|char
specifier|const
modifier|*
name|pzName
parameter_list|,
name|char
specifier|const
modifier|*
name|pzProgPath
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ag_bool
name|insertEnvVal
parameter_list|(
name|char
modifier|*
name|pzBuf
parameter_list|,
name|int
name|bufSize
parameter_list|,
name|char
specifier|const
modifier|*
name|pzName
parameter_list|,
name|char
specifier|const
modifier|*
name|pzProgPath
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|assembleArgValue
parameter_list|(
name|char
modifier|*
name|pzTxt
parameter_list|,
name|tOptionLoadMode
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/*=export_func  optionMakePath  * private:  *  * what:  translate and construct a path  * arg:   + char*       + pzBuf      + The result buffer +  * arg:   + int         + bufSize    + The size of this buffer +  * arg:   + char const* + pzName     + The input name +  * arg:   + char const* + pzProgPath + The full path of the current program +  *  * ret-type: ag_bool  * ret-desc: AG_TRUE if the name was handled, otherwise AG_FALSE.  *           If the name does not start with ``$'', then it is handled  *           simply by copying the input name to the output buffer and  *           resolving the name with either  *           @code{canonicalize_file_name(3GLIBC)} or @code{realpath(3C)}.  *  * doc:  *  *  This routine will copy the @code{pzName} input name into the  *  @code{pzBuf} output buffer, not exceeding @code{bufSize} bytes.  If the  *  first character of the input name is a @code{'$'} character, then there  *  is special handling:  *  @*  *  @code{$$} is replaced with the directory name of the @code{pzProgPath},  *  searching @code{$PATH} if necessary.  *  @*  *  @code{$@} is replaced with the AutoGen package data installation directory  *  (aka @code{pkgdatadir}).  *  @*  *  @code{$NAME} is replaced by the contents of the @code{NAME} environment  *  variable.  If not found, the search fails.  *  *  Please note: both @code{$$} and @code{$NAME} must be at the start of the  *     @code{pzName} string and must either be the entire string or be followed  *     by the @code{'/'} (backslash on windows) character.  *  * err:  @code{AG_FALSE} is returned if:  *       @*  *       @bullet{} The input name exceeds @code{bufSize} bytes.  *       @*  *       @bullet{} @code{$$}, @code{$@@} or @code{$NAME} is not the full string  *                 and the next character is not '/'.  *       @*  *       @bullet{} libopts was built without PKGDATADIR defined and @code{$@@}  *                 was specified.  *       @*  *       @bullet{} @code{NAME} is not a known environment variable  *       @*  *       @bullet{} @code{canonicalize_file_name} or @code{realpath} return  *                 errors (cannot resolve the resulting path). =*/
end_comment

begin_function
name|ag_bool
name|optionMakePath
parameter_list|(
name|char
modifier|*
name|pzBuf
parameter_list|,
name|int
name|bufSize
parameter_list|,
name|char
specifier|const
modifier|*
name|pzName
parameter_list|,
name|char
specifier|const
modifier|*
name|pzProgPath
parameter_list|)
block|{
name|size_t
name|name_len
init|=
name|strlen
argument_list|(
name|pzName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|bufSize
operator|<=
name|name_len
operator|)
operator|||
operator|(
name|name_len
operator|==
literal|0
operator|)
condition|)
return|return
name|AG_FALSE
return|;
comment|/*      *  IF not an environment variable, just copy the data      */
if|if
condition|(
operator|*
name|pzName
operator|!=
literal|'$'
condition|)
block|{
name|char
specifier|const
modifier|*
name|pzS
init|=
name|pzName
decl_stmt|;
name|char
modifier|*
name|pzD
init|=
name|pzBuf
decl_stmt|;
name|int
name|ct
init|=
name|bufSize
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
operator|(
name|pzD
operator|++
operator|)
operator|=
operator|*
operator|(
name|pzS
operator|++
operator|)
operator|)
operator|==
name|NUL
condition|)
break|break;
if|if
condition|(
operator|--
name|ct
operator|<=
literal|0
condition|)
return|return
name|AG_FALSE
return|;
block|}
block|}
comment|/*      *  IF the name starts with "$$", then it must be "$$" or      *  it must start with "$$/".  In either event, replace the "$$"      *  with the path to the executable and append a "/" character.      */
else|else
switch|switch
condition|(
name|pzName
index|[
literal|1
index|]
condition|)
block|{
case|case
name|NUL
case|:
return|return
name|AG_FALSE
return|;
case|case
literal|'$'
case|:
if|if
condition|(
operator|!
name|insertProgramPath
argument_list|(
name|pzBuf
argument_list|,
name|bufSize
argument_list|,
name|pzName
argument_list|,
name|pzProgPath
argument_list|)
condition|)
return|return
name|AG_FALSE
return|;
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
name|program_pkgdatadir
index|[
literal|0
index|]
operator|==
name|NUL
condition|)
return|return
name|AG_FALSE
return|;
if|if
condition|(
name|snprintf
argument_list|(
name|pzBuf
argument_list|,
name|bufSize
argument_list|,
literal|"%s%s"
argument_list|,
name|program_pkgdatadir
argument_list|,
name|pzName
operator|+
literal|2
argument_list|)
operator|>=
name|bufSize
condition|)
return|return
name|AG_FALSE
return|;
break|break;
default|default:
if|if
condition|(
operator|!
name|insertEnvVal
argument_list|(
name|pzBuf
argument_list|,
name|bufSize
argument_list|,
name|pzName
argument_list|,
name|pzProgPath
argument_list|)
condition|)
return|return
name|AG_FALSE
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CANONICALIZE_FILE_NAME
argument_list|)
block|{
name|char
modifier|*
name|pz
init|=
name|canonicalize_file_name
argument_list|(
name|pzBuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|pz
operator|==
name|NULL
condition|)
return|return
name|AG_FALSE
return|;
name|name_len
operator|=
name|strlen
argument_list|(
name|pz
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_len
operator|>=
name|bufSize
condition|)
block|{
name|free
argument_list|(
name|pz
argument_list|)
expr_stmt|;
return|return
name|AG_FALSE
return|;
block|}
name|memcpy
argument_list|(
name|pzBuf
argument_list|,
name|pz
argument_list|,
name|name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pz
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_REALPATH
argument_list|)
block|{
name|char
name|z
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|realpath
argument_list|(
name|pzBuf
argument_list|,
name|z
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|AG_FALSE
return|;
name|name_len
operator|=
name|strlen
argument_list|(
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_len
operator|>=
name|bufSize
condition|)
return|return
name|AG_FALSE
return|;
name|memcpy
argument_list|(
name|pzBuf
argument_list|,
name|z
argument_list|,
name|name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|AG_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|ag_bool
name|insertProgramPath
parameter_list|(
name|char
modifier|*
name|pzBuf
parameter_list|,
name|int
name|bufSize
parameter_list|,
name|char
specifier|const
modifier|*
name|pzName
parameter_list|,
name|char
specifier|const
modifier|*
name|pzProgPath
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|pzPath
decl_stmt|;
name|char
specifier|const
modifier|*
name|pz
decl_stmt|;
name|int
name|skip
init|=
literal|2
decl_stmt|;
switch|switch
condition|(
name|pzName
index|[
literal|2
index|]
condition|)
block|{
case|case
name|DIRCH
case|:
name|skip
operator|=
literal|3
expr_stmt|;
case|case
name|NUL
case|:
break|break;
default|default:
return|return
name|AG_FALSE
return|;
block|}
comment|/*      *  See if the path is included in the program name.      *  If it is, we're done.  Otherwise, we have to hunt      *  for the program using "pathfind".      */
if|if
condition|(
name|strchr
argument_list|(
name|pzProgPath
argument_list|,
name|DIRCH
argument_list|)
operator|!=
name|NULL
condition|)
name|pzPath
operator|=
name|pzProgPath
expr_stmt|;
else|else
block|{
name|pzPath
operator|=
name|pathfind
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pzProgPath
argument_list|,
literal|"rx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzPath
operator|==
name|NULL
condition|)
return|return
name|AG_FALSE
return|;
block|}
name|pz
operator|=
name|strrchr
argument_list|(
name|pzPath
argument_list|,
name|DIRCH
argument_list|)
expr_stmt|;
comment|/*      *  IF we cannot find a directory name separator,      *  THEN we do not have a path name to our executable file.      */
if|if
condition|(
name|pz
operator|==
name|NULL
condition|)
return|return
name|AG_FALSE
return|;
name|pzName
operator|+=
name|skip
expr_stmt|;
comment|/*      *  Concatenate the file name to the end of the executable path.      *  The result may be either a file or a directory.      */
if|if
condition|(
operator|(
name|pz
operator|-
name|pzPath
operator|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|pzName
argument_list|)
operator|>=
name|bufSize
condition|)
return|return
name|AG_FALSE
return|;
name|memcpy
argument_list|(
name|pzBuf
argument_list|,
name|pzPath
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|pz
operator|-
name|pzPath
operator|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pzBuf
operator|+
operator|(
name|pz
operator|-
name|pzPath
operator|)
operator|+
literal|1
argument_list|,
name|pzName
argument_list|)
expr_stmt|;
comment|/*      *  If the "pzPath" path was gotten from "pathfind()", then it was      *  allocated and we need to deallocate it.      */
if|if
condition|(
name|pzPath
operator|!=
name|pzProgPath
condition|)
name|AGFREE
argument_list|(
name|pzPath
argument_list|)
expr_stmt|;
return|return
name|AG_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|ag_bool
name|insertEnvVal
parameter_list|(
name|char
modifier|*
name|pzBuf
parameter_list|,
name|int
name|bufSize
parameter_list|,
name|char
specifier|const
modifier|*
name|pzName
parameter_list|,
name|char
specifier|const
modifier|*
name|pzProgPath
parameter_list|)
block|{
name|char
modifier|*
name|pzDir
init|=
name|pzBuf
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ch
init|=
operator|(
name|int
operator|)
operator|*
operator|++
name|pzName
decl_stmt|;
if|if
condition|(
operator|!
name|IS_VALUE_NAME_CHAR
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
operator|*
operator|(
name|pzDir
operator|++
operator|)
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|pzDir
operator|==
name|pzBuf
condition|)
return|return
name|AG_FALSE
return|;
operator|*
name|pzDir
operator|=
name|NUL
expr_stmt|;
name|pzDir
operator|=
name|getenv
argument_list|(
name|pzBuf
argument_list|)
expr_stmt|;
comment|/*      *  Environment value not found -- skip the home list entry      */
if|if
condition|(
name|pzDir
operator|==
name|NULL
condition|)
return|return
name|AG_FALSE
return|;
if|if
condition|(
name|strlen
argument_list|(
name|pzDir
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|pzName
argument_list|)
operator|>=
name|bufSize
condition|)
return|return
name|AG_FALSE
return|;
name|sprintf
argument_list|(
name|pzBuf
argument_list|,
literal|"%s%s"
argument_list|,
name|pzDir
argument_list|,
name|pzName
argument_list|)
expr_stmt|;
return|return
name|AG_TRUE
return|;
block|}
end_function

begin_function
name|LOCAL
name|void
name|mungeString
parameter_list|(
name|char
modifier|*
name|pzTxt
parameter_list|,
name|tOptionLoadMode
name|mode
parameter_list|)
block|{
name|char
modifier|*
name|pzE
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|OPTION_LOAD_KEEP
condition|)
return|return;
if|if
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
name|pzTxt
argument_list|)
condition|)
block|{
name|char
modifier|*
name|pzS
init|=
name|pzTxt
decl_stmt|;
name|char
modifier|*
name|pzD
init|=
name|pzTxt
decl_stmt|;
while|while
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
operator|++
name|pzS
argument_list|)
condition|)
empty_stmt|;
while|while
condition|(
operator|(
operator|*
operator|(
name|pzD
operator|++
operator|)
operator|=
operator|*
operator|(
name|pzS
operator|++
operator|)
operator|)
operator|!=
name|NUL
condition|)
empty_stmt|;
name|pzE
operator|=
name|pzD
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|pzE
operator|=
name|pzTxt
operator|+
name|strlen
argument_list|(
name|pzTxt
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pzE
operator|>
name|pzTxt
operator|)
operator|&&
name|IS_WHITESPACE_CHAR
argument_list|(
name|pzE
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|pzE
operator|--
expr_stmt|;
operator|*
name|pzE
operator|=
name|NUL
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|OPTION_LOAD_UNCOOKED
condition|)
return|return;
switch|switch
condition|(
operator|*
name|pzTxt
condition|)
block|{
default|default:
return|return;
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
break|break;
block|}
switch|switch
condition|(
name|pzE
index|[
operator|-
literal|1
index|]
condition|)
block|{
default|default:
return|return;
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
break|break;
block|}
operator|(
name|void
operator|)
name|ao_string_cook
argument_list|(
name|pzTxt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|assembleArgValue
parameter_list|(
name|char
modifier|*
name|pzTxt
parameter_list|,
name|tOptionLoadMode
name|mode
parameter_list|)
block|{
specifier|static
name|char
specifier|const
name|zBrk
index|[]
init|=
literal|" \t\n:="
decl_stmt|;
name|char
modifier|*
name|pzEnd
init|=
name|strpbrk
argument_list|(
name|pzTxt
argument_list|,
name|zBrk
argument_list|)
decl_stmt|;
name|int
name|space_break
decl_stmt|;
comment|/*      *  Not having an argument to a configurable name is okay.      */
if|if
condition|(
name|pzEnd
operator|==
name|NULL
condition|)
return|return
name|pzTxt
operator|+
name|strlen
argument_list|(
name|pzTxt
argument_list|)
return|;
comment|/*      *  If we are keeping all whitespace, then the  modevalue starts with the      *  character that follows the end of the configurable name, regardless      *  of which character caused it.      */
if|if
condition|(
name|mode
operator|==
name|OPTION_LOAD_KEEP
condition|)
block|{
operator|*
operator|(
name|pzEnd
operator|++
operator|)
operator|=
name|NUL
expr_stmt|;
return|return
name|pzEnd
return|;
block|}
comment|/*      *  If the name ended on a white space character, remember that      *  because we'll have to skip over an immediately following ':' or '='      *  (and the white space following *that*).      */
name|space_break
operator|=
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
name|pzEnd
argument_list|)
expr_stmt|;
operator|*
operator|(
name|pzEnd
operator|++
operator|)
operator|=
name|NUL
expr_stmt|;
while|while
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
name|pzEnd
argument_list|)
condition|)
name|pzEnd
operator|++
expr_stmt|;
if|if
condition|(
name|space_break
operator|&&
operator|(
operator|(
operator|*
name|pzEnd
operator|==
literal|':'
operator|)
operator|||
operator|(
operator|*
name|pzEnd
operator|==
literal|'='
operator|)
operator|)
condition|)
while|while
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
operator|++
name|pzEnd
argument_list|)
condition|)
empty_stmt|;
return|return
name|pzEnd
return|;
block|}
end_function

begin_comment
comment|/*  *  Load an option from a block of text.  The text must start with the  *  configurable/option name and be followed by its associated value.  *  That value may be processed in any of several ways.  See "tOptionLoadMode"  *  in autoopts.h.  */
end_comment

begin_function
name|LOCAL
name|void
name|loadOptionLine
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
name|pzLine
parameter_list|,
name|tDirection
name|direction
parameter_list|,
name|tOptionLoadMode
name|load_mode
parameter_list|)
block|{
while|while
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
name|pzLine
argument_list|)
condition|)
name|pzLine
operator|++
expr_stmt|;
block|{
name|char
modifier|*
name|pzArg
init|=
name|assembleArgValue
argument_list|(
name|pzLine
argument_list|,
name|load_mode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|longOptionFind
argument_list|(
name|pOpts
argument_list|,
name|pzLine
argument_list|,
name|pOS
argument_list|)
argument_list|)
condition|)
return|return;
if|if
condition|(
name|pOS
operator|->
name|flags
operator|&
name|OPTST_NO_INIT
condition|)
return|return;
name|pOS
operator|->
name|pzOptArg
operator|=
name|pzArg
expr_stmt|;
block|}
switch|switch
condition|(
name|pOS
operator|->
name|flags
operator|&
operator|(
name|OPTST_IMM
operator||
name|OPTST_DISABLE_IMM
operator|)
condition|)
block|{
case|case
literal|0
case|:
comment|/*          *  The selected option has no immediate action.          *  THEREFORE, if the direction is PRESETTING          *  THEN we skip this option.          */
if|if
condition|(
name|PRESETTING
argument_list|(
name|direction
argument_list|)
condition|)
return|return;
break|break;
case|case
name|OPTST_IMM
case|:
if|if
condition|(
name|PRESETTING
argument_list|(
name|direction
argument_list|)
condition|)
block|{
comment|/*              *  We are in the presetting direction with an option we handle              *  immediately for enablement, but normally for disablement.              *  Therefore, skip if disabled.              */
if|if
condition|(
operator|(
name|pOS
operator|->
name|flags
operator|&
name|OPTST_DISABLED
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
else|else
block|{
comment|/*              *  We are in the processing direction with an option we handle              *  immediately for enablement, but normally for disablement.              *  Therefore, skip if NOT disabled.              */
if|if
condition|(
operator|(
name|pOS
operator|->
name|flags
operator|&
name|OPTST_DISABLED
operator|)
operator|!=
literal|0
condition|)
return|return;
block|}
break|break;
case|case
name|OPTST_DISABLE_IMM
case|:
if|if
condition|(
name|PRESETTING
argument_list|(
name|direction
argument_list|)
condition|)
block|{
comment|/*              *  We are in the presetting direction with an option we handle              *  immediately for disablement, but normally for disablement.              *  Therefore, skip if NOT disabled.              */
if|if
condition|(
operator|(
name|pOS
operator|->
name|flags
operator|&
name|OPTST_DISABLED
operator|)
operator|!=
literal|0
condition|)
return|return;
block|}
else|else
block|{
comment|/*              *  We are in the processing direction with an option we handle              *  immediately for disablement, but normally for disablement.              *  Therefore, skip if disabled.              */
if|if
condition|(
operator|(
name|pOS
operator|->
name|flags
operator|&
name|OPTST_DISABLED
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
break|break;
case|case
name|OPTST_IMM
operator||
name|OPTST_DISABLE_IMM
case|:
comment|/*          *  The selected option is always for immediate action.          *  THEREFORE, if the direction is PROCESSING          *  THEN we skip this option.          */
if|if
condition|(
name|PROCESSING
argument_list|(
name|direction
argument_list|)
condition|)
return|return;
break|break;
block|}
comment|/*      *  Fix up the args.      */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOS
operator|->
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_NONE
condition|)
block|{
if|if
condition|(
operator|*
name|pOS
operator|->
name|pzOptArg
operator|!=
name|NUL
condition|)
return|return;
name|pOS
operator|->
name|pzOptArg
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pOS
operator|->
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ARG_OPTIONAL
condition|)
block|{
if|if
condition|(
operator|*
name|pOS
operator|->
name|pzOptArg
operator|==
name|NUL
condition|)
name|pOS
operator|->
name|pzOptArg
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|AGDUPSTR
argument_list|(
name|pOS
operator|->
name|pzOptArg
argument_list|,
name|pOS
operator|->
name|pzOptArg
argument_list|,
literal|"option argument"
argument_list|)
expr_stmt|;
name|pOS
operator|->
name|flags
operator||=
name|OPTST_ALLOC_ARG
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|pOS
operator|->
name|pzOptArg
operator|==
name|NUL
condition|)
name|pOS
operator|->
name|pzOptArg
operator|=
name|zNil
expr_stmt|;
else|else
block|{
name|AGDUPSTR
argument_list|(
name|pOS
operator|->
name|pzOptArg
argument_list|,
name|pOS
operator|->
name|pzOptArg
argument_list|,
literal|"option argument"
argument_list|)
expr_stmt|;
name|pOS
operator|->
name|flags
operator||=
name|OPTST_ALLOC_ARG
expr_stmt|;
block|}
block|}
block|{
name|tOptionLoadMode
name|sv
init|=
name|option_load_mode
decl_stmt|;
name|option_load_mode
operator|=
name|load_mode
expr_stmt|;
name|handle_opt
argument_list|(
name|pOpts
argument_list|,
name|pOS
argument_list|)
expr_stmt|;
name|option_load_mode
operator|=
name|sv
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*=export_func  optionLoadLine  *  * what:  process a string for an option name and value  *  * arg:   tOptions*,   pOpts,  program options descriptor  * arg:   char const*, pzLine, NUL-terminated text  *  * doc:  *  *  This is a client program callable routine for setting options from, for  *  example, the contents of a file that they read in.  Only one option may  *  appear in the text.  It will be treated as a normal (non-preset) option.  *  *  When passed a pointer to the option struct and a string, it will find  *  the option named by the first token on the string and set the option  *  argument to the remainder of the string.  The caller must NUL terminate  *  the string.  Any embedded new lines will be included in the option  *  argument.  If the input looks like one or more quoted strings, then the  *  input will be "cooked".  The "cooking" is identical to the string  *  formation used in AutoGen definition files (@pxref{basic expression}),  *  except that you may not use backquotes.  *  * err:   Invalid options are silently ignored.  Invalid option arguments  *        will cause a warning to print, but the function should return. =*/
end_comment

begin_function
name|void
name|optionLoadLine
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
specifier|const
modifier|*
name|pzLine
parameter_list|)
block|{
name|tOptState
name|st
init|=
name|OPTSTATE_INITIALIZER
argument_list|(
name|SET
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pz
decl_stmt|;
name|AGDUPSTR
argument_list|(
name|pz
argument_list|,
name|pzLine
argument_list|,
literal|"user option line"
argument_list|)
expr_stmt|;
name|loadOptionLine
argument_list|(
name|pOpts
argument_list|,
operator|&
name|st
argument_list|,
name|pz
argument_list|,
name|DIRECTION_PROCESS
argument_list|,
name|OPTION_LOAD_COOKED
argument_list|)
expr_stmt|;
name|AGFREE
argument_list|(
name|pz
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/load.c */
end_comment

end_unit

