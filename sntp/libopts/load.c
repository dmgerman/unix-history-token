begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  *  \file load.c  *  *  This file contains the routines that deal with processing text strings  *  for options, either from a NUL-terminated string passed in or from an  *  rc/ini file.  *  * @addtogroup autoopts  * @{  */
end_comment

begin_comment
comment|/*  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  */
end_comment

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|bool
name|get_realpath
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|b_sz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|add_prog_path
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|b_sz
parameter_list|,
name|char
specifier|const
modifier|*
name|fname
parameter_list|,
name|char
specifier|const
modifier|*
name|prg_path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|add_env_val
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buf_sz
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|assemble_arg_val
parameter_list|(
name|char
modifier|*
name|txt
parameter_list|,
name|tOptionLoadMode
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|trim_quotes
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|direction_ok
parameter_list|(
name|opt_state_mask_t
name|f
parameter_list|,
name|int
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_function
specifier|static
name|bool
name|get_realpath
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|b_sz
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CANONICALIZE_FILE_NAME
argument_list|)
block|{
name|size_t
name|name_len
decl_stmt|;
name|char
modifier|*
name|pz
init|=
name|canonicalize_file_name
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|pz
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|name_len
operator|=
name|strlen
argument_list|(
name|pz
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_len
operator|>=
operator|(
name|size_t
operator|)
name|b_sz
condition|)
block|{
name|free
argument_list|(
name|pz
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
name|pz
argument_list|,
name|name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pz
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_REALPATH
argument_list|)
block|{
name|size_t
name|name_len
decl_stmt|;
name|char
name|z
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|realpath
argument_list|(
name|buf
argument_list|,
name|z
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|name_len
operator|=
name|strlen
argument_list|(
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_len
operator|>=
name|b_sz
condition|)
return|return
name|false
return|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|z
argument_list|,
name|name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionMakePath  * private:  *  * what:  translate and construct a path  * arg:   + char*       + p_buf     + The result buffer +  * arg:   + int         + b_sz      + The size of this buffer +  * arg:   + char const* + fname     + The input name +  * arg:   + char const* + prg_path  + The full path of the current program +  *  * ret-type: bool  * ret-desc: true if the name was handled, otherwise false.  *           If the name does not start with ``$'', then it is handled  *           simply by copying the input name to the output buffer and  *           resolving the name with either  *           @code{canonicalize_file_name(3GLIBC)} or @code{realpath(3C)}.  *  * doc:  *  *  This routine will copy the @code{pzName} input name into the  *  @code{pzBuf} output buffer, not exceeding @code{bufSize} bytes.  If the  *  first character of the input name is a @code{'$'} character, then there  *  is special handling:  *  @*  *  @code{$$} is replaced with the directory name of the @code{pzProgPath},  *  searching @code{$PATH} if necessary.  *  @*  *  @code{$@} is replaced with the AutoGen package data installation directory  *  (aka @code{pkgdatadir}).  *  @*  *  @code{$NAME} is replaced by the contents of the @code{NAME} environment  *  variable.  If not found, the search fails.  *  *  Please note: both @code{$$} and @code{$NAME} must be at the start of the  *     @code{pzName} string and must either be the entire string or be followed  *     by the @code{'/'} (backslash on windows) character.  *  * err:  @code{false} is returned if:  *       @*  *       @bullet{} The input name exceeds @code{bufSize} bytes.  *       @*  *       @bullet{} @code{$$}, @code{$@@} or @code{$NAME} is not the full string  *                 and the next character is not '/'.  *       @*  *       @bullet{} libopts was built without PKGDATADIR defined and @code{$@@}  *                 was specified.  *       @*  *       @bullet{} @code{NAME} is not a known environment variable  *       @*  *       @bullet{} @code{canonicalize_file_name} or @code{realpath} return  *                 errors (cannot resolve the resulting path). =*/
end_comment

begin_function
name|bool
name|optionMakePath
parameter_list|(
name|char
modifier|*
name|p_buf
parameter_list|,
name|int
name|b_sz
parameter_list|,
name|char
specifier|const
modifier|*
name|fname
parameter_list|,
name|char
specifier|const
modifier|*
name|prg_path
parameter_list|)
block|{
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|fname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|b_sz
operator|<=
name|len
operator|)
operator|||
operator|(
name|len
operator|==
literal|0
operator|)
condition|)
return|return
name|false
return|;
block|}
comment|/*      *  IF not an environment variable, just copy the data      */
if|if
condition|(
operator|*
name|fname
operator|!=
literal|'$'
condition|)
block|{
name|char
specifier|const
modifier|*
name|src
init|=
name|fname
decl_stmt|;
name|char
modifier|*
name|dst
init|=
name|p_buf
decl_stmt|;
name|int
name|ct
init|=
name|b_sz
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
operator|*
operator|(
name|src
operator|++
operator|)
operator|)
operator|==
name|NUL
condition|)
break|break;
if|if
condition|(
operator|--
name|ct
operator|<=
literal|0
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/*      *  IF the name starts with "$$", then it must be "$$" or      *  it must start with "$$/".  In either event, replace the "$$"      *  with the path to the executable and append a "/" character.      */
else|else
switch|switch
condition|(
name|fname
index|[
literal|1
index|]
condition|)
block|{
case|case
name|NUL
case|:
return|return
name|false
return|;
case|case
literal|'$'
case|:
if|if
condition|(
operator|!
name|add_prog_path
argument_list|(
name|p_buf
argument_list|,
name|b_sz
argument_list|,
name|fname
argument_list|,
name|prg_path
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
name|program_pkgdatadir
index|[
literal|0
index|]
operator|==
name|NUL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|snprintf
argument_list|(
name|p_buf
argument_list|,
operator|(
name|size_t
operator|)
name|b_sz
argument_list|,
literal|"%s%s"
argument_list|,
name|program_pkgdatadir
argument_list|,
name|fname
operator|+
literal|2
argument_list|)
operator|>=
name|b_sz
condition|)
return|return
name|false
return|;
break|break;
default|default:
if|if
condition|(
operator|!
name|add_env_val
argument_list|(
name|p_buf
argument_list|,
name|b_sz
argument_list|,
name|fname
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|get_realpath
argument_list|(
name|p_buf
argument_list|,
name|b_sz
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * convert a leading "$$" into a path to the executable.  */
end_comment

begin_function
specifier|static
name|bool
name|add_prog_path
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|b_sz
parameter_list|,
name|char
specifier|const
modifier|*
name|fname
parameter_list|,
name|char
specifier|const
modifier|*
name|prg_path
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|path
decl_stmt|;
name|char
specifier|const
modifier|*
name|pz
decl_stmt|;
name|int
name|skip
init|=
literal|2
decl_stmt|;
switch|switch
condition|(
name|fname
index|[
literal|2
index|]
condition|)
block|{
case|case
name|DIRCH
case|:
name|skip
operator|=
literal|3
expr_stmt|;
case|case
name|NUL
case|:
break|break;
default|default:
return|return
name|false
return|;
block|}
comment|/*      *  See if the path is included in the program name.      *  If it is, we're done.  Otherwise, we have to hunt      *  for the program using "pathfind".      */
if|if
condition|(
name|strchr
argument_list|(
name|prg_path
argument_list|,
name|DIRCH
argument_list|)
operator|!=
name|NULL
condition|)
name|path
operator|=
name|prg_path
expr_stmt|;
else|else
block|{
name|path
operator|=
name|pathfind
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|prg_path
argument_list|,
literal|"rx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|pz
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
name|DIRCH
argument_list|)
expr_stmt|;
comment|/*      *  IF we cannot find a directory name separator,      *  THEN we do not have a path name to our executable file.      */
if|if
condition|(
name|pz
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|fname
operator|+=
name|skip
expr_stmt|;
comment|/*      *  Concatenate the file name to the end of the executable path.      *  The result may be either a file or a directory.      */
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|pz
operator|-
name|path
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|fname
argument_list|)
operator|>=
operator|(
name|unsigned
operator|)
name|b_sz
condition|)
return|return
name|false
return|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|path
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|pz
operator|-
name|path
operator|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
operator|+
operator|(
name|pz
operator|-
name|path
operator|)
operator|+
literal|1
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/*      *  If the "path" path was gotten from "pathfind()", then it was      *  allocated and we need to deallocate it.      */
if|if
condition|(
name|path
operator|!=
name|prg_path
condition|)
name|AGFREE
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/**  * Add an environment variable value.  */
end_comment

begin_function
specifier|static
name|bool
name|add_env_val
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buf_sz
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|dir_part
init|=
name|buf
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ch
init|=
operator|(
name|int
operator|)
operator|*
operator|++
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|IS_VALUE_NAME_CHAR
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
operator|*
operator|(
name|dir_part
operator|++
operator|)
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|dir_part
operator|==
name|buf
condition|)
return|return
name|false
return|;
operator|*
name|dir_part
operator|=
name|NUL
expr_stmt|;
name|dir_part
operator|=
name|getenv
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/*      *  Environment value not found -- skip the home list entry      */
if|if
condition|(
name|dir_part
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|strlen
argument_list|(
name|dir_part
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|>=
operator|(
name|unsigned
operator|)
name|buf_sz
condition|)
return|return
name|false
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%s"
argument_list|,
name|dir_part
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/**  * Trim leading and trailing white space.  * If we are cooking the text and the text is quoted, then "cook"  * the string.  To cook, the string must be quoted.  *  * @param[in,out] txt  the input and output string  * @param[in]     mode the handling mode (cooking method)  */
end_comment

begin_function
name|LOCAL
name|void
name|munge_str
parameter_list|(
name|char
modifier|*
name|txt
parameter_list|,
name|tOptionLoadMode
name|mode
parameter_list|)
block|{
name|char
modifier|*
name|pzE
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|OPTION_LOAD_KEEP
condition|)
return|return;
if|if
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
name|txt
argument_list|)
condition|)
block|{
name|char
modifier|*
name|src
init|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|txt
operator|+
literal|1
argument_list|)
decl_stmt|;
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|src
argument_list|)
operator|+
literal|1
decl_stmt|;
name|memmove
argument_list|(
name|txt
argument_list|,
name|src
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|pzE
operator|=
name|txt
operator|+
name|l
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|pzE
operator|=
name|txt
operator|+
name|strlen
argument_list|(
name|txt
argument_list|)
expr_stmt|;
name|pzE
operator|=
name|SPN_WHITESPACE_BACK
argument_list|(
name|txt
argument_list|,
name|pzE
argument_list|)
expr_stmt|;
operator|*
name|pzE
operator|=
name|NUL
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|OPTION_LOAD_UNCOOKED
condition|)
return|return;
switch|switch
condition|(
operator|*
name|txt
condition|)
block|{
default|default:
return|return;
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
break|break;
block|}
switch|switch
condition|(
name|pzE
index|[
operator|-
literal|1
index|]
condition|)
block|{
default|default:
return|return;
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
break|break;
block|}
operator|(
name|void
operator|)
name|ao_string_cook
argument_list|(
name|txt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|assemble_arg_val
parameter_list|(
name|char
modifier|*
name|txt
parameter_list|,
name|tOptionLoadMode
name|mode
parameter_list|)
block|{
name|char
modifier|*
name|end
init|=
name|strpbrk
argument_list|(
name|txt
argument_list|,
name|ARG_BREAK_STR
argument_list|)
decl_stmt|;
name|int
name|space_break
decl_stmt|;
comment|/*      *  Not having an argument to a configurable name is okay.      */
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
return|return
name|txt
operator|+
name|strlen
argument_list|(
name|txt
argument_list|)
return|;
comment|/*      *  If we are keeping all whitespace, then the  modevalue starts with the      *  character that follows the end of the configurable name, regardless      *  of which character caused it.      */
if|if
condition|(
name|mode
operator|==
name|OPTION_LOAD_KEEP
condition|)
block|{
operator|*
operator|(
name|end
operator|++
operator|)
operator|=
name|NUL
expr_stmt|;
return|return
name|end
return|;
block|}
comment|/*      *  If the name ended on a white space character, remember that      *  because we'll have to skip over an immediately following ':' or '='      *  (and the white space following *that*).      */
name|space_break
operator|=
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
name|end
argument_list|)
expr_stmt|;
operator|*
operator|(
name|end
operator|++
operator|)
operator|=
name|NUL
expr_stmt|;
name|end
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|space_break
operator|&&
operator|(
operator|(
operator|*
name|end
operator|==
literal|':'
operator|)
operator|||
operator|(
operator|*
name|end
operator|==
literal|'='
operator|)
operator|)
condition|)
name|end
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|end
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|end
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|trim_quotes
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
switch|switch
condition|(
operator|*
name|arg
condition|)
block|{
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
name|ao_string_cook
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/**  * See if the option is to be processed in the current scan direction  * (-1 or +1).  */
end_comment

begin_function
specifier|static
name|bool
name|direction_ok
parameter_list|(
name|opt_state_mask_t
name|f
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
if|if
condition|(
name|dir
operator|==
literal|0
condition|)
return|return
name|true
return|;
switch|switch
condition|(
name|f
operator|&
operator|(
name|OPTST_IMM
operator||
name|OPTST_DISABLE_IMM
operator|)
condition|)
block|{
case|case
literal|0
case|:
comment|/*          *  The selected option has no immediate action.          *  THEREFORE, if the direction is PRESETTING          *  THEN we skip this option.          */
if|if
condition|(
name|PRESETTING
argument_list|(
name|dir
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|OPTST_IMM
case|:
if|if
condition|(
name|PRESETTING
argument_list|(
name|dir
argument_list|)
condition|)
block|{
comment|/*              *  We are in the presetting direction with an option we handle              *  immediately for enablement, but normally for disablement.              *  Therefore, skip if disabled.              */
if|if
condition|(
operator|(
name|f
operator|&
name|OPTST_DISABLED
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
comment|/*              *  We are in the processing direction with an option we handle              *  immediately for enablement, but normally for disablement.              *  Therefore, skip if NOT disabled.              */
if|if
condition|(
operator|(
name|f
operator|&
name|OPTST_DISABLED
operator|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|}
break|break;
case|case
name|OPTST_DISABLE_IMM
case|:
if|if
condition|(
name|PRESETTING
argument_list|(
name|dir
argument_list|)
condition|)
block|{
comment|/*              *  We are in the presetting direction with an option we handle              *  immediately for disablement, but normally for disablement.              *  Therefore, skip if NOT disabled.              */
if|if
condition|(
operator|(
name|f
operator|&
name|OPTST_DISABLED
operator|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
comment|/*              *  We are in the processing direction with an option we handle              *  immediately for disablement, but normally for disablement.              *  Therefore, skip if disabled.              */
if|if
condition|(
operator|(
name|f
operator|&
name|OPTST_DISABLED
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
block|}
break|break;
case|case
name|OPTST_IMM
operator||
name|OPTST_DISABLE_IMM
case|:
comment|/*          *  The selected option is always for immediate action.          *  THEREFORE, if the direction is PROCESSING          *  THEN we skip this option.          */
if|if
condition|(
name|PROCESSING
argument_list|(
name|dir
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/**  *  Load an option from a block of text.  The text must start with the  *  configurable/option name and be followed by its associated value.  *  That value may be processed in any of several ways.  See "tOptionLoadMode"  *  in autoopts.h.  *  * @param[in,out] opts       program options descriptor  * @param[in,out] opt_state  option processing state  * @param[in,out] line       source line with long option name in it  * @param[in]     direction  current processing direction (preset or not)  * @param[in]     load_mode  option loading mode (OPTION_LOAD_*)  */
end_comment

begin_function
name|LOCAL
name|void
name|load_opt_line
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptState
modifier|*
name|opt_state
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|tDirection
name|direction
parameter_list|,
name|tOptionLoadMode
name|load_mode
parameter_list|)
block|{
comment|/*      * When parsing a stored line, we only look at the characters after      * a hyphen.  Long names must always be at least two characters and      * short options are always exactly one character long.      */
name|line
operator|=
name|SPN_LOAD_LINE_SKIP_CHARS
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|arg
init|=
name|assemble_arg_val
argument_list|(
name|line
argument_list|,
name|load_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_OPTION_NAME_CHAR
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|opt_find_long
argument_list|(
name|opts
argument_list|,
name|line
argument_list|,
name|opt_state
argument_list|)
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|opt_find_short
argument_list|(
name|opts
argument_list|,
operator|*
name|line
argument_list|,
name|opt_state
argument_list|)
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
operator|!
name|CALLED
argument_list|(
name|direction
argument_list|)
operator|)
operator|&&
operator|(
name|opt_state
operator|->
name|flags
operator|&
name|OPTST_NO_INIT
operator|)
condition|)
return|return;
name|opt_state
operator|->
name|pzOptArg
operator|=
name|trim_quotes
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|direction_ok
argument_list|(
name|opt_state
operator|->
name|flags
argument_list|,
name|direction
argument_list|)
condition|)
return|return;
comment|/*      *  Fix up the args.      */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|opt_state
operator|->
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_NONE
condition|)
block|{
if|if
condition|(
operator|*
name|opt_state
operator|->
name|pzOptArg
operator|!=
name|NUL
condition|)
return|return;
name|opt_state
operator|->
name|pzOptArg
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt_state
operator|->
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ARG_OPTIONAL
condition|)
block|{
if|if
condition|(
operator|*
name|opt_state
operator|->
name|pzOptArg
operator|==
name|NUL
condition|)
name|opt_state
operator|->
name|pzOptArg
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|AGDUPSTR
argument_list|(
name|opt_state
operator|->
name|pzOptArg
argument_list|,
name|opt_state
operator|->
name|pzOptArg
argument_list|,
literal|"opt arg"
argument_list|)
expr_stmt|;
name|opt_state
operator|->
name|flags
operator||=
name|OPTST_ALLOC_ARG
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|opt_state
operator|->
name|pzOptArg
operator|==
name|NUL
condition|)
name|opt_state
operator|->
name|pzOptArg
operator|=
name|zNil
expr_stmt|;
else|else
block|{
name|AGDUPSTR
argument_list|(
name|opt_state
operator|->
name|pzOptArg
argument_list|,
name|opt_state
operator|->
name|pzOptArg
argument_list|,
literal|"opt arg"
argument_list|)
expr_stmt|;
name|opt_state
operator|->
name|flags
operator||=
name|OPTST_ALLOC_ARG
expr_stmt|;
block|}
block|}
block|{
name|tOptionLoadMode
name|sv
init|=
name|option_load_mode
decl_stmt|;
name|option_load_mode
operator|=
name|load_mode
expr_stmt|;
name|handle_opt
argument_list|(
name|opts
argument_list|,
name|opt_state
argument_list|)
expr_stmt|;
name|option_load_mode
operator|=
name|sv
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*=export_func  optionLoadLine  *  * what:  process a string for an option name and value  *  * arg:   tOptions*,   opts,  program options descriptor  * arg:   char const*, line,  NUL-terminated text  *  * doc:  *  *  This is a client program callable routine for setting options from, for  *  example, the contents of a file that they read in.  Only one option may  *  appear in the text.  It will be treated as a normal (non-preset) option.  *  *  When passed a pointer to the option struct and a string, it will find  *  the option named by the first token on the string and set the option  *  argument to the remainder of the string.  The caller must NUL terminate  *  the string.  The caller need not skip over any introductory hyphens.  *  Any embedded new lines will be included in the option  *  argument.  If the input looks like one or more quoted strings, then the  *  input will be "cooked".  The "cooking" is identical to the string  *  formation used in AutoGen definition files (@pxref{basic expression}),  *  except that you may not use backquotes.  *  * err:   Invalid options are silently ignored.  Invalid option arguments  *        will cause a warning to print, but the function should return. =*/
end_comment

begin_function
name|void
name|optionLoadLine
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|line
parameter_list|)
block|{
name|tOptState
name|st
init|=
name|OPTSTATE_INITIALIZER
argument_list|(
name|SET
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pz
decl_stmt|;
name|proc_state_mask_t
name|sv_flags
init|=
name|opts
operator|->
name|fOptSet
decl_stmt|;
name|opts
operator|->
name|fOptSet
operator|&=
operator|~
name|OPTPROC_ERRSTOP
expr_stmt|;
name|AGDUPSTR
argument_list|(
name|pz
argument_list|,
name|line
argument_list|,
literal|"opt line"
argument_list|)
expr_stmt|;
name|load_opt_line
argument_list|(
name|opts
argument_list|,
operator|&
name|st
argument_list|,
name|pz
argument_list|,
name|DIRECTION_CALLED
argument_list|,
name|OPTION_LOAD_COOKED
argument_list|)
expr_stmt|;
name|AGFREE
argument_list|(
name|pz
argument_list|)
expr_stmt|;
name|opts
operator|->
name|fOptSet
operator|=
name|sv_flags
expr_stmt|;
block|}
end_function

begin_comment
comment|/** @}  *  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/load.c */
end_comment

end_unit

