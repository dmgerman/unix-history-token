begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   -*- buffer-read-only: t -*- vi: set ro:  *  *  DO NOT EDIT THIS FILE   (options.h)  *  *  It has been AutoGen-ed  August  3, 2014 at 10:44:46 AM by AutoGen 5.18.4pre11  *  From the definitions    funcs.def  *  and the template file   options_h  *  *  This file defines all the global structures and special values  *  used in the automated option processing library.  *  *  Automated Options Copyright (C) 1992-2014 by Bruce Korb  *  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|AUTOOPTS_OPTIONS_H_GUARD
end_ifndef

begin_define
define|#
directive|define
name|AUTOOPTS_OPTIONS_H_GUARD
value|1
end_define

begin_comment
comment|/** \file options.h  *  * @addtogroup autoopts  * @{  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|COMPAT_H_GUARD
end_ifndef

begin_comment
comment|/*  * This is needed for test compilations where the "compat.h"  * header is not usually available.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDINT_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_INTTYPES_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDINT/INTTYPES_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LIMITS_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SYS_LIMITS_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LIMITS/SYS_LIMITS_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSEXITS_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYSEXITS_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDBOOL_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
enum|enum
block|{
name|false
init|=
literal|0
block|,
name|true
init|=
literal|1
block|}
name|_Bool
typedef|;
end_typedef

begin_define
define|#
directive|define
name|bool
value|_Bool
end_define

begin_comment
comment|/* The other macros must be usable in preprocessor directives.  */
end_comment

begin_define
define|#
directive|define
name|false
value|0
end_define

begin_define
define|#
directive|define
name|true
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYSEXITS_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_H_GUARD */
end_comment

begin_comment
comment|// END-CONFIGURED-HEADERS
end_comment

begin_comment
comment|/**  * Defined to abnormal value of EX_USAGE.  Used to indicate that paged usage  * was requested.  It is used to distinguish a --usage from a --help request.  * --usage is abbreviated and --help gives as much help as possible.  */
end_comment

begin_define
define|#
directive|define
name|AO_EXIT_REQ_USAGE
value|10064
end_define

begin_comment
comment|/**  *  PUBLIC DEFINES  *  *  The following defines may be used in applications that need to test the  *  state of an option.  To test against these masks and values, a pointer  *  to an option descriptor must be obtained.  There are two ways:  *  *  1. inside an option processing procedure, it is the second argument,  *     conventionally "tOptDesc* pOD".  *  *  2. Outside of an option procedure (or to reference a different option  *     descriptor), use either "&DESC( opt_name )" or "&pfx_DESC( opt_name )".  *  *  See the relevant generated header file to determine which and what  *  values for "opt_name" are available.  * @group version  * @{  */
end_comment

begin_comment
comment|/// autoopts structure version
end_comment

begin_define
define|#
directive|define
name|OPTIONS_STRUCT_VERSION
value|167936
end_define

begin_comment
comment|/// autoopts structure version string
end_comment

begin_define
define|#
directive|define
name|OPTIONS_VERSION_STRING
value|"41:0:16"
end_define

begin_comment
comment|/// minimum version the autoopts library supports
end_comment

begin_define
define|#
directive|define
name|OPTIONS_MINIMUM_VERSION
value|102400
end_define

begin_comment
comment|/// minimum version the autoopts library supports as a string
end_comment

begin_define
define|#
directive|define
name|OPTIONS_MIN_VER_STRING
value|"25:0:0"
end_define

begin_comment
comment|/// the display version of the autoopts library, as a string
end_comment

begin_define
define|#
directive|define
name|OPTIONS_DOTTED_VERSION
value|"41.0"
end_define

begin_comment
comment|/// convert a version/release number pair to an integer value
end_comment

begin_define
define|#
directive|define
name|OPTIONS_VER_TO_NUM
parameter_list|(
name|_v
parameter_list|,
name|_r
parameter_list|)
value|(((_v) * 4096) + (_r))
end_define

begin_comment
comment|/// @}
end_comment

begin_comment
comment|/**  * Option argument types.  This must fit in the OPTST_ARG_TYPE_MASK  * field of the fOptState field of an option descriptor (tOptDesc).  * It will be a problem to extend beyond 4 bits.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|OPARG_TYPE_NONE
init|=
literal|0
block|,
comment|///< does not take an argument
name|OPARG_TYPE_STRING
init|=
literal|1
block|,
comment|///< default type/ vanilla string
name|OPARG_TYPE_ENUMERATION
init|=
literal|2
block|,
comment|///< opt arg is an enum (keyword list)
name|OPARG_TYPE_BOOLEAN
init|=
literal|3
block|,
comment|///< opt arg is boolean-valued
name|OPARG_TYPE_MEMBERSHIP
init|=
literal|4
block|,
comment|///< opt arg sets set membership bits
name|OPARG_TYPE_NUMERIC
init|=
literal|5
block|,
comment|///< opt arg is a long int
name|OPARG_TYPE_HIERARCHY
init|=
literal|6
block|,
comment|///< option arg is hierarchical value
name|OPARG_TYPE_FILE
init|=
literal|7
block|,
comment|///< option arg names a file
name|OPARG_TYPE_TIME
init|=
literal|8
block|,
comment|///< opt arg is a time duration
name|OPARG_TYPE_FLOAT
init|=
literal|9
block|,
comment|///< opt arg is a floating point num
name|OPARG_TYPE_DOUBLE
init|=
literal|10
block|,
comment|///< opt arg is a double prec. float
name|OPARG_TYPE_LONG_DOUBLE
init|=
literal|11
block|,
comment|///< opt arg is a long double prec.
name|OPARG_TYPE_LONG_LONG
init|=
literal|12
comment|///< opt arg is a long long int
block|}
name|teOptArgType
typedef|;
end_typedef

begin_comment
comment|/**  * value descriptor for sub options  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|optionValue
block|{
name|teOptArgType
name|valType
decl_stmt|;
comment|///< which argument type
name|char
modifier|*
name|pzName
decl_stmt|;
comment|///< name of the sub-option
union|union
block|{
name|char
name|strVal
index|[
literal|1
index|]
decl_stmt|;
comment|///< OPARG_TYPE_STRING
name|unsigned
name|int
name|enumVal
decl_stmt|;
comment|///< OPARG_TYPE_ENUMERATION
name|unsigned
name|int
name|boolVal
decl_stmt|;
comment|///< OPARG_TYPE_BOOLEAN
name|unsigned
name|long
name|setVal
decl_stmt|;
comment|///< OPARG_TYPE_MEMBERSHIP
name|long
name|longVal
decl_stmt|;
comment|///< OPARG_TYPE_NUMERIC
name|void
modifier|*
name|nestVal
decl_stmt|;
comment|///< OPARG_TYPE_HIERARCHY
block|}
name|v
union|;
block|}
name|tOptionValue
typedef|;
end_typedef

begin_comment
comment|/**  * file argument state and handling.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|FTYPE_MODE_MAY_EXIST
init|=
literal|0x00
block|,
comment|///< may or may not exist
name|FTYPE_MODE_MUST_EXIST
init|=
literal|0x01
block|,
comment|///< must pre-exist
name|FTYPE_MODE_MUST_NOT_EXIST
init|=
literal|0x02
block|,
comment|///< must *not* pre-exist
name|FTYPE_MODE_EXIST_MASK
init|=
literal|0x03
block|,
comment|///< mask for these bits
name|FTYPE_MODE_NO_OPEN
init|=
literal|0x00
block|,
comment|///< leave file closed
name|FTYPE_MODE_OPEN_FD
init|=
literal|0x10
block|,
comment|///< call open(2)
name|FTYPE_MODE_FOPEN_FP
init|=
literal|0x20
block|,
comment|///< call fopen(3)
name|FTYPE_MODE_OPEN_MASK
init|=
literal|0x30
comment|///< open/fopen/not open
block|}
name|teOptFileType
typedef|;
end_typedef

begin_comment
comment|/**  * the open flag bits or the mode string, depending on the open type.  */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|int
name|file_flags
decl_stmt|;
comment|///< open(2) flag bits
name|char
specifier|const
modifier|*
name|file_mode
decl_stmt|;
comment|///< fopen(3) mode string
block|}
name|tuFileMode
typedef|;
end_typedef

begin_comment
comment|/// initial number of option argument holders to allocate
end_comment

begin_define
define|#
directive|define
name|MIN_ARG_ALLOC_CT
value|6
end_define

begin_comment
comment|/// amount by which to increment the argument holder allocation.
end_comment

begin_define
define|#
directive|define
name|INCR_ARG_ALLOC_CT
value|8
end_define

begin_comment
comment|/**  * an argument list.  When an option appears multiple times and  * the values get "stacked".  \a apzArgs  holds 8 pointers initially  * and is incremented by \a INCR_ARG_ALLOC_CT as needed.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|useCt
decl_stmt|;
comment|///< elements in use
comment|/// allocated elements, mininum \a MIN_ARG_ALLOC_CT
comment|/// steps by \a INCR_ARG_ALLOC_CT
name|int
name|allocCt
decl_stmt|;
name|char
specifier|const
modifier|*
name|apzArgs
index|[
name|MIN_ARG_ALLOC_CT
index|]
decl_stmt|;
comment|///< element array
block|}
name|tArgList
typedef|;
end_typedef

begin_comment
comment|/**  *  Bits in the fOptState option descriptor field.  * @{  */
end_comment

begin_comment
comment|/** integral type for holding opt_state masks */
end_comment

begin_typedef
typedef|typedef
name|uint32_t
name|opt_state_mask_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|OPTST_ARG_TYPE_SHIFT
value|12
end_define

begin_comment
comment|/** bits defined for opt_state_mask_t */
end_comment

begin_comment
comment|/** Set via the "SET_OPT()" macro */
end_comment

begin_define
define|#
directive|define
name|OPTST_SET
value|0x0000001U
end_define

begin_comment
comment|/** Set via an RC/INI file */
end_comment

begin_define
define|#
directive|define
name|OPTST_PRESET
value|0x0000002U
end_define

begin_comment
comment|/** Set via a command line option */
end_comment

begin_define
define|#
directive|define
name|OPTST_DEFINED
value|0x0000004U
end_define

begin_comment
comment|/** Reset via command line option */
end_comment

begin_define
define|#
directive|define
name|OPTST_RESET
value|0x0000008U
end_define

begin_comment
comment|/** selected by equiv'ed option */
end_comment

begin_define
define|#
directive|define
name|OPTST_EQUIVALENCE
value|0x0000010U
end_define

begin_comment
comment|/** option is in disabled state */
end_comment

begin_define
define|#
directive|define
name|OPTST_DISABLED
value|0x0000020U
end_define

begin_comment
comment|/** pzOptArg was allocated */
end_comment

begin_define
define|#
directive|define
name|OPTST_ALLOC_ARG
value|0x0000040U
end_define

begin_comment
comment|/** option cannot be preset */
end_comment

begin_define
define|#
directive|define
name|OPTST_NO_INIT
value|0x0000100U
end_define

begin_comment
comment|/** opt value (flag) is any digit */
end_comment

begin_define
define|#
directive|define
name|OPTST_NUMBER_OPT
value|0x0000200U
end_define

begin_comment
comment|/** opt uses optionStackArg proc */
end_comment

begin_define
define|#
directive|define
name|OPTST_STACKED
value|0x0000400U
end_define

begin_comment
comment|/** option defaults to enabled */
end_comment

begin_define
define|#
directive|define
name|OPTST_INITENABLED
value|0x0000800U
end_define

begin_comment
comment|/** bit 1 of arg type enum */
end_comment

begin_define
define|#
directive|define
name|OPTST_ARG_TYPE_1
value|0x0001000U
end_define

begin_comment
comment|/** bit 2 of arg type enum */
end_comment

begin_define
define|#
directive|define
name|OPTST_ARG_TYPE_2
value|0x0002000U
end_define

begin_comment
comment|/** bit 3 of arg type enum */
end_comment

begin_define
define|#
directive|define
name|OPTST_ARG_TYPE_3
value|0x0004000U
end_define

begin_comment
comment|/** bit 4 of arg type enum */
end_comment

begin_define
define|#
directive|define
name|OPTST_ARG_TYPE_4
value|0x0008000U
end_define

begin_comment
comment|/** the option arg not required */
end_comment

begin_define
define|#
directive|define
name|OPTST_ARG_OPTIONAL
value|0x0010000U
end_define

begin_comment
comment|/** process opt on first pass */
end_comment

begin_define
define|#
directive|define
name|OPTST_IMM
value|0x0020000U
end_define

begin_comment
comment|/** process disablement immed. */
end_comment

begin_define
define|#
directive|define
name|OPTST_DISABLE_IMM
value|0x0040000U
end_define

begin_comment
comment|/** compiled out of program */
end_comment

begin_define
define|#
directive|define
name|OPTST_OMITTED
value|0x0080000U
end_define

begin_comment
comment|/** must be set or pre-set */
end_comment

begin_define
define|#
directive|define
name|OPTST_MUST_SET
value|0x0100000U
end_define

begin_comment
comment|/** opt is for doc only */
end_comment

begin_define
define|#
directive|define
name|OPTST_DOCUMENT
value|0x0200000U
end_define

begin_comment
comment|/** process opt twice - imm + reg */
end_comment

begin_define
define|#
directive|define
name|OPTST_TWICE
value|0x0400000U
end_define

begin_comment
comment|/** process disabled option twice */
end_comment

begin_define
define|#
directive|define
name|OPTST_DISABLE_TWICE
value|0x0800000U
end_define

begin_comment
comment|/** scaled integer value */
end_comment

begin_define
define|#
directive|define
name|OPTST_SCALED_NUM
value|0x1000000U
end_define

begin_comment
comment|/** disable from cmd line */
end_comment

begin_define
define|#
directive|define
name|OPTST_NO_COMMAND
value|0x2000000U
end_define

begin_comment
comment|/** support is being removed */
end_comment

begin_define
define|#
directive|define
name|OPTST_DEPRECATED
value|0x4000000U
end_define

begin_comment
comment|/** alias for other option */
end_comment

begin_define
define|#
directive|define
name|OPTST_ALIAS
value|0x8000000U
end_define

begin_comment
comment|/** bits in SET mask:  *  set     preset  reset   defined */
end_comment

begin_define
define|#
directive|define
name|OPTST_SET_MASK
value|0x000000FU
end_define

begin_comment
comment|/** bits in MUTABLE mask:  *  set         preset      reset       defined     equivalence disabled  *  alloc_arg */
end_comment

begin_define
define|#
directive|define
name|OPTST_MUTABLE_MASK
value|0x000007FU
end_define

begin_comment
comment|/** bits omitted from PERSISTENT mask:  *  mutable_mask */
end_comment

begin_define
define|#
directive|define
name|OPTST_PERSISTENT_MASK
value|0xFFFFF00U
end_define

begin_comment
comment|/** bits in SELECTED mask:  *  set     defined */
end_comment

begin_define
define|#
directive|define
name|OPTST_SELECTED_MASK
value|0x0000005U
end_define

begin_comment
comment|/** bits in ARG_TYPE mask:  *  arg_type_1 arg_type_2 arg_type_3 arg_type_4 */
end_comment

begin_define
define|#
directive|define
name|OPTST_ARG_TYPE_MASK
value|0x000F000U
end_define

begin_comment
comment|/** bits in NO_USAGE mask:  *  omitted    no_command deprecated */
end_comment

begin_define
define|#
directive|define
name|OPTST_NO_USAGE_MASK
value|0x6080000U
end_define

begin_comment
comment|/** bits in IMMUTABLE mask:  *  document omitted */
end_comment

begin_define
define|#
directive|define
name|OPTST_IMMUTABLE_MASK
value|0x0280000U
end_define

begin_comment
comment|/** bits in DO_NOT_SAVE mask:  *  document omitted  no_init */
end_comment

begin_define
define|#
directive|define
name|OPTST_DO_NOT_SAVE_MASK
value|0x0280100U
end_define

begin_comment
comment|/** bits in NO_OUTPUT mask:  *  document omitted  alias */
end_comment

begin_define
define|#
directive|define
name|OPTST_NO_OUTPUT_MASK
value|0x8280000U
end_define

begin_comment
comment|/** all bits in opt_state_mask_t masks */
end_comment

begin_define
define|#
directive|define
name|OPTST_MASK_ALL
value|0xFFFFF7FU
end_define

begin_comment
comment|/** no bits in opt_state_mask_t */
end_comment

begin_define
define|#
directive|define
name|OPTST_INIT
value|0x0000000U
end_define

begin_comment
comment|/** @} */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_OPTIONAL_OPT_ARGS
end_ifdef

begin_undef
undef|#
directive|undef
name|OPTST_ARG_OPTIONAL
end_undef

begin_define
define|#
directive|define
name|OPTST_ARG_OPTIONAL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VENDOR_OPTION_VALUE
value|'W'
end_define

begin_define
define|#
directive|define
name|SELECTED_OPT
parameter_list|(
name|_od
parameter_list|)
value|((_od)->fOptState& OPTST_SELECTED_MASK)
end_define

begin_define
define|#
directive|define
name|UNUSED_OPT
parameter_list|(
name|_od
parameter_list|)
value|(((_od)->fOptState& OPTST_SET_MASK) == 0)
end_define

begin_define
define|#
directive|define
name|DISABLED_OPT
parameter_list|(
name|_od
parameter_list|)
value|((_od)->fOptState& OPTST_DISABLED)
end_define

begin_define
define|#
directive|define
name|OPTION_STATE
parameter_list|(
name|_od
parameter_list|)
value|((_od)->fOptState)
end_define

begin_define
define|#
directive|define
name|OPTST_SET_ARGTYPE
parameter_list|(
name|_n
parameter_list|)
value|((_n)<< OPTST_ARG_TYPE_SHIFT)
end_define

begin_define
define|#
directive|define
name|OPTST_GET_ARGTYPE
parameter_list|(
name|_f
parameter_list|)
define|\
value|(((_f)&OPTST_ARG_TYPE_MASK)>> OPTST_ARG_TYPE_SHIFT)
end_define

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *  PRIVATE INTERFACES  *  *  The following values are used in the generated code to communicate  *  with the option library procedures.  They are not for public use  *  and may be subject to change.  */
end_comment

begin_comment
comment|/**  *  Define the processing state flags  * @{  */
end_comment

begin_comment
comment|/** integral type for holding proc_state masks */
end_comment

begin_typedef
typedef|typedef
name|uint32_t
name|proc_state_mask_t
typedef|;
end_typedef

begin_comment
comment|/** bits defined for proc_state_mask_t */
end_comment

begin_comment
comment|/** Process long style options */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_LONGOPT
value|0x000001U
end_define

begin_comment
comment|/** Process short style "flags" */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_SHORTOPT
value|0x000002U
end_define

begin_comment
comment|/** Stop on argument errors */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_ERRSTOP
value|0x000004U
end_define

begin_comment
comment|/** Current option is disabled */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_DISABLEDOPT
value|0x000008U
end_define

begin_comment
comment|/** no options are required */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_NO_REQ_OPT
value|0x000010U
end_define

begin_comment
comment|/** there is a number option */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_NUM_OPT
value|0x000020U
end_define

begin_comment
comment|/** have inits been done? */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_INITDONE
value|0x000040U
end_define

begin_comment
comment|/** any negation options? */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_NEGATIONS
value|0x000080U
end_define

begin_comment
comment|/** check environment? */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_ENVIRON
value|0x000100U
end_define

begin_comment
comment|/** Disallow remaining arguments */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_NO_ARGS
value|0x000200U
end_define

begin_comment
comment|/** Require args after options */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_ARGS_REQ
value|0x000400U
end_define

begin_comment
comment|/** reorder operands after opts */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_REORDER
value|0x000800U
end_define

begin_comment
comment|/** emit usage in GNU style */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_GNUUSAGE
value|0x001000U
end_define

begin_comment
comment|/** Translate strings in tOptions */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_TRANSLATE
value|0x002000U
end_define

begin_comment
comment|/** no usage on usage error */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_MISUSE
value|0x004000U
end_define

begin_comment
comment|/** immediate options active */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_IMMEDIATE
value|0x008000U
end_define

begin_comment
comment|/** suppress for config only */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_NXLAT_OPT_CFG
value|0x010000U
end_define

begin_comment
comment|/** suppress xlation always */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_NXLAT_OPT
value|0x020000U
end_define

begin_comment
comment|/** vendor options active */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_VENDOR_OPT
value|0x040000U
end_define

begin_comment
comment|/** opt processing in preset state */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_PRESETTING
value|0x080000U
end_define

begin_comment
comment|/** Ignore pzFullUsage, compute usage text */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_COMPUTE
value|0x100000U
end_define

begin_comment
comment|/** Program outputs digested option state for shell scripts.  Usage text   * always written to stderr */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_SHELL_OUTPUT
value|0x200000U
end_define

begin_comment
comment|/** bits in NO_XLAT mask:  *  nxlat_opt_cfg nxlat_opt */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_NO_XLAT_MASK
value|0x030000U
end_define

begin_comment
comment|/** all bits in proc_state_mask_t masks */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_MASK_ALL
value|0x3FFFFFU
end_define

begin_comment
comment|/** no bits in proc_state_mask_t */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_NONE
value|0x000000U
end_define

begin_comment
comment|/** @} */
end_comment

begin_define
define|#
directive|define
name|STMTS
parameter_list|(
name|s
parameter_list|)
value|do { s; } while (false)
end_define

begin_comment
comment|/**  *  Abbreviation for const memory character.  */
end_comment

begin_define
define|#
directive|define
name|tCC
value|char const
end_define

begin_comment
comment|/**  * Magical values for the program's option pointer  * @{  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|OP_VAL_EMIT_USAGE
init|=
literal|1
block|,
comment|///< request for usage
name|OP_VAL_EMIT_SHELL
init|=
literal|2
block|,
comment|///< emit value for Bourne shell evaluation
name|OP_VAL_RETURN_VALNAME
init|=
literal|3
block|,
comment|///< return the value as a string
name|OP_VAL_EMIT_LIMIT
init|=
literal|15
comment|///< limit for magic values
block|}
name|opt_proc_vals_t
typedef|;
end_typedef

begin_comment
comment|/// \a OPT_VAL_EMIT_USAGE cast as a pointer
end_comment

begin_define
define|#
directive|define
name|OPTPROC_EMIT_USAGE
value|((tOptions *)OP_VAL_EMIT_USAGE)
end_define

begin_comment
comment|/// \a OPT_VAL_EMIT_SHELL cast as a pointer
end_comment

begin_define
define|#
directive|define
name|OPTPROC_EMIT_SHELL
value|((tOptions *)OP_VAL_EMIT_SHELL)
end_define

begin_comment
comment|/// \a OPT_VAL_RETURN_VALNAME cast as a pointer
end_comment

begin_define
define|#
directive|define
name|OPTPROC_RETURN_VALNAME
value|((tOptions *)OP_VAL_RETURN_VALNAME)
end_define

begin_comment
comment|/// \a OPT_VAL_EMIT_LIMIT cast as a pointer
end_comment

begin_define
define|#
directive|define
name|OPTPROC_EMIT_LIMIT
value|((tOptions *)OP_VAL_EMIT_LIMIT)
end_define

begin_comment
comment|/** @} */
end_comment

begin_comment
comment|/** group option processing procedure types  * @{  */
end_comment

begin_comment
comment|/** forward declaration for tOptDesc */
end_comment

begin_typedef
typedef|typedef
name|struct
name|opt_desc
name|tOptDesc
typedef|;
end_typedef

begin_comment
comment|/** forward declaration for tOptiond */
end_comment

begin_typedef
typedef|typedef
name|struct
name|options
name|tOptions
typedef|;
end_typedef

begin_comment
comment|/**  *  The option procedures do the special processing for each  *  option flag that needs it.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
name|tOptProc
function_decl|)
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOptDesc
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/**  * a pointer to an option processing procedure  */
end_comment

begin_typedef
typedef|typedef
name|tOptProc
modifier|*
name|tpOptProc
typedef|;
end_typedef

begin_comment
comment|/**  *  The usage procedure will never return.  It calls "exit(2)"  *  with the "exitCode" argument passed to it.  */
end_comment

begin_comment
comment|// coverity[+kill]
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
name|tUsageProc
function_decl|)
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|int
name|exitCode
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/**  * a pointer to a procedure that prints usage and exits.  */
end_comment

begin_typedef
typedef|typedef
name|tUsageProc
modifier|*
name|tpUsageProc
typedef|;
end_typedef

begin_comment
comment|/** @} */
end_comment

begin_comment
comment|/**  *  Special definitions.  "NOLIMIT" is the 'max' value to use when  *  a flag may appear multiple times without limit.  "NO_EQUIVALENT"  *  is an illegal value for 'optIndex' (option description index).  * @{  */
end_comment

begin_define
define|#
directive|define
name|NOLIMIT
value|USHRT_MAX
end_define

begin_comment
comment|///< no occurrance count limit
end_comment

begin_define
define|#
directive|define
name|OPTION_LIMIT
value|SHRT_MAX
end_define

begin_comment
comment|///< maximum number of option types
end_comment

begin_comment
comment|/// option index to indicate no equivalance or alias
end_comment

begin_define
define|#
directive|define
name|NO_EQUIVALENT
value|(OPTION_LIMIT+1)
end_define

begin_comment
comment|/** @} */
end_comment

begin_comment
comment|/**  * Option argument value.  Which is valid is determined by:  * (fOptState& OPTST_ARG_TYPE_MASK)>> OPTST_ARG_TYPE_SHIFT  * which will yield one of the teOptArgType values.  */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|char
specifier|const
modifier|*
name|argString
decl_stmt|;
comment|///< as a string
name|uintptr_t
name|argEnum
decl_stmt|;
comment|///< as an enumeration value
name|uintptr_t
name|argIntptr
decl_stmt|;
comment|///< as an integer big enough to hold pointer
name|long
name|argInt
decl_stmt|;
comment|///< as a long integer
name|unsigned
name|long
name|argUint
decl_stmt|;
comment|///< as an unsigned long ingeger
name|unsigned
name|int
name|argBool
decl_stmt|;
comment|///< as a boolean value
name|FILE
modifier|*
name|argFp
decl_stmt|;
comment|///< as a FILE * pointer
name|int
name|argFd
decl_stmt|;
comment|///< as a file descriptor (int)
block|}
name|opt_arg_union_t
typedef|;
end_typedef

begin_comment
comment|/// Compatibility define: \a pzLastArg is now \a optArg.argString
end_comment

begin_define
define|#
directive|define
name|pzLastArg
value|optArg.argString
end_define

begin_comment
comment|/// The old amorphous argument bucket is now the opt_arg_union_t union.
end_comment

begin_define
define|#
directive|define
name|optArgBucket_t
value|opt_arg_union_t
end_define

begin_comment
comment|/**  * Enumeration of AutoOpts defined options.  The enumeration is used in  * marking each option that is defined by AutoOpts so libopts can find  * the correct descriptor.  This renders \a option_spec_idx_t redundant.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|AOUSE_USER_DEFINED
init|=
literal|0
block|,
comment|///< user specified option
name|AOUSE_RESET_OPTION
block|,
comment|///< reset option state option
name|AOUSE_VERSION
block|,
comment|///< request version
name|AOUSE_HELP
block|,
comment|///< request usage help
name|AOUSE_MORE_HELP
block|,
comment|///< request paged usage
name|AOUSE_USAGE
block|,
comment|///< request short usage
name|AOUSE_SAVE_OPTS
block|,
comment|///< save option state
name|AOUSE_LOAD_OPTS
block|,
comment|///< load options from file
name|AOUSE_VENDOR_OPT
comment|///< specify a vendor option
block|}
name|opt_usage_t
typedef|;
end_typedef

begin_comment
comment|/**  *  Descriptor structure for each option.  *  Only the fields marked "PUBLIC" are for public use.  */
end_comment

begin_struct
struct|struct
name|opt_desc
block|{
comment|/// Public, the index of this descriptor
name|uint16_t
specifier|const
name|optIndex
decl_stmt|;
comment|/// Public, the flag character (value)
name|uint16_t
specifier|const
name|optValue
decl_stmt|;
comment|/// Public, the index of the option used to activate option
name|uint16_t
name|optActualIndex
decl_stmt|;
comment|/// Public, the flag character of the activating option
name|uint16_t
name|optActualValue
decl_stmt|;
comment|/// Public, the index of the equivalenced-to option.
comment|/// This is NO_EQUIVALENT unless activated.
name|uint16_t
specifier|const
name|optEquivIndex
decl_stmt|;
comment|/// Private, the minimum occurrance count
name|uint16_t
specifier|const
name|optMinCt
decl_stmt|;
comment|/// Private, the maximum occurrance count (NOLIMIT, if unlimited)
name|uint16_t
specifier|const
name|optMaxCt
decl_stmt|;
comment|/// Public, the actual occurrance count
name|uint16_t
name|optOccCt
decl_stmt|;
comment|/// Public, the option processing state
name|opt_state_mask_t
name|fOptState
decl_stmt|;
comment|/// Private, how the option is used (opt_usage_t)
name|uint32_t
name|optUsage
decl_stmt|;
comment|/// Public, The current option argument value
name|opt_arg_union_t
name|optArg
decl_stmt|;
comment|/// Public, data that is actually private to the code that handles
comment|/// this particular option.  It is public IFF you have your own
comment|/// handling function.
name|void
modifier|*
name|optCookie
decl_stmt|;
comment|/// Private, a list of options that must be specified when this option
comment|/// has been specified
name|int
specifier|const
modifier|*
specifier|const
name|pOptMust
decl_stmt|;
comment|/// Private, a list of options that cannot be specified when this option
comment|/// has been specified
name|int
specifier|const
modifier|*
specifier|const
name|pOptCant
decl_stmt|;
comment|/// Private, the function to call for handling this option
name|tpOptProc
specifier|const
name|pOptProc
decl_stmt|;
comment|/// Private, usage information about this option
name|char
specifier|const
modifier|*
specifier|const
name|pzText
decl_stmt|;
comment|/// Public, the UPPER CASE, shell variable name syntax name of the option
name|char
specifier|const
modifier|*
specifier|const
name|pz_NAME
decl_stmt|;
comment|/// the unmodified name of the option
name|char
specifier|const
modifier|*
specifier|const
name|pz_Name
decl_stmt|;
comment|/// the option name to use to disable the option.  Long options names
comment|/// must be active.
name|char
specifier|const
modifier|*
specifier|const
name|pz_DisableName
decl_stmt|;
comment|/// the special prefix that makes the normal option name become the
comment|/// disablement name.
name|char
specifier|const
modifier|*
specifier|const
name|pz_DisablePfx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  *  Some options need special processing, so we store their  *  indexes in a known place.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint16_t
specifier|const
name|more_help
decl_stmt|;
comment|///< passes help text through pager
name|uint16_t
specifier|const
name|save_opts
decl_stmt|;
comment|///< stores option state to a file
name|uint16_t
specifier|const
name|number_option
decl_stmt|;
comment|///< the option "name" is an integer
comment|/// all arguments are options, this is the default option that must
comment|/// take an argument.  That argument is the unrecognized option.
name|uint16_t
specifier|const
name|default_opt
decl_stmt|;
block|}
name|option_spec_idx_t
typedef|;
end_typedef

begin_comment
comment|/**  *  The procedure generated for translating option text  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
name|tOptionXlateProc
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/**  * Everything marked "PUBLIC" is also marked "const".  Public access is not  * a license to modify.  Other fields are used and modified by the library.  * They are also subject to change without any notice.  * Do not even look at these outside of libopts.  */
end_comment

begin_struct
struct|struct
name|options
block|{
name|int
specifier|const
name|structVersion
decl_stmt|;
comment|///< The version of this struct
name|unsigned
name|int
name|origArgCt
decl_stmt|;
comment|///< program argument count
name|char
modifier|*
modifier|*
name|origArgVect
decl_stmt|;
comment|///< program argument vector
name|proc_state_mask_t
name|fOptSet
decl_stmt|;
comment|///< option proc. state flags
name|unsigned
name|int
name|curOptIdx
decl_stmt|;
comment|///< current option index
name|char
modifier|*
name|pzCurOpt
decl_stmt|;
comment|///< current option text
comment|/// Public, the full path of the program
name|char
specifier|const
modifier|*
specifier|const
name|pzProgPath
decl_stmt|;
comment|/// Public, the name of the executable, without any path
name|char
specifier|const
modifier|*
specifier|const
name|pzProgName
decl_stmt|;
comment|/// Public, the upper-cased, shell variable syntax-ed program name
name|char
specifier|const
modifier|*
specifier|const
name|pzPROGNAME
decl_stmt|;
comment|/// the name of the "rc file" (configuration file)
name|char
specifier|const
modifier|*
specifier|const
name|pzRcName
decl_stmt|;
comment|/// the copyright text
name|char
specifier|const
modifier|*
specifier|const
name|pzCopyright
decl_stmt|;
comment|/// the full copyright notice
name|char
specifier|const
modifier|*
specifier|const
name|pzCopyNotice
decl_stmt|;
comment|/// a string with the program name, project name and version
name|char
specifier|const
modifier|*
specifier|const
name|pzFullVersion
decl_stmt|;
comment|/// a list of pointers to directories to search for the config file
name|char
specifier|const
modifier|*
specifier|const
modifier|*
specifier|const
name|papzHomeList
decl_stmt|;
comment|/// the title line for usage
name|char
specifier|const
modifier|*
specifier|const
name|pzUsageTitle
decl_stmt|;
comment|/// some added explanation for what this program is trying to do
name|char
specifier|const
modifier|*
specifier|const
name|pzExplain
decl_stmt|;
comment|/// a detailed explanation of the program's purpose, for use when
comment|/// full help has been requested
name|char
specifier|const
modifier|*
specifier|const
name|pzDetail
decl_stmt|;
comment|/// The public array of option descriptors
name|tOptDesc
modifier|*
specifier|const
name|pOptDesc
decl_stmt|;
comment|/// the email address for reporting bugs
name|char
specifier|const
modifier|*
specifier|const
name|pzBugAddr
decl_stmt|;
comment|/// Reserved for future use
name|void
modifier|*
name|pExtensions
decl_stmt|;
comment|/// A copy of the option state when optionSaveState was called.
name|void
modifier|*
name|pSavedState
decl_stmt|;
comment|/// The procedure to call to print usage text
comment|// coverity[+kill]
name|tpUsageProc
name|pUsageProc
decl_stmt|;
comment|/// The procedure to call to translate translatable option messages
name|tOptionXlateProc
modifier|*
name|pTransProc
decl_stmt|;
comment|/// Special option indexes.
name|option_spec_idx_t
name|specOptIdx
decl_stmt|;
comment|/// the total number of options for the program
name|int
specifier|const
name|optCt
decl_stmt|;
comment|/// The number of "presettable" options, though some may be marked
comment|/// "no-preset".  Includes all user specified options, plus a few
comment|/// that are specified by AutoOpts.
name|int
specifier|const
name|presetOptCt
decl_stmt|;
comment|/// user specified full usage text
name|char
specifier|const
modifier|*
name|pzFullUsage
decl_stmt|;
comment|/// user specifed short usage (usage error triggered) message
name|char
specifier|const
modifier|*
name|pzShortUsage
decl_stmt|;
comment|/// The option argument settings active when optionSaveState was called
name|opt_arg_union_t
specifier|const
modifier|*
specifier|const
name|originalOptArgArray
decl_stmt|;
comment|/// any saved cookie value
name|void
modifier|*
specifier|const
modifier|*
specifier|const
name|originalOptArgCookie
decl_stmt|;
comment|/// the package data directory (e.g. global configuration files)
name|char
specifier|const
modifier|*
specifier|const
name|pzPkgDataDir
decl_stmt|;
comment|/// email address of the project packager
name|char
specifier|const
modifier|*
specifier|const
name|pzPackager
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Versions where in various fields first appear:  *  ($AO_CURRENT * 4096 + $AO_REVISION, but $AO_REVISION must be zero)  */
end_comment

begin_comment
comment|/**  * The version that first stored the original argument vector  */
end_comment

begin_define
define|#
directive|define
name|originalOptArgArray_STRUCT_VERSION
value|0x20000
end_define

begin_comment
comment|/* AO_CURRENT = 32 */
end_comment

begin_define
define|#
directive|define
name|HAS_originalOptArgArray
parameter_list|(
name|_opt
parameter_list|)
define|\
value|((_opt)->structVersion>= originalOptArgArray_STRUCT_VERSION)
end_define

begin_comment
comment|/**  * The version that first stored the package data directory  */
end_comment

begin_define
define|#
directive|define
name|pzPkgDataDir_STRUCT_VERSION
value|0x22000
end_define

begin_comment
comment|/* AO_CURRENT = 34 */
end_comment

begin_define
define|#
directive|define
name|HAS_pzPkgDataDir
parameter_list|(
name|_opt
parameter_list|)
define|\
value|((_opt)->structVersion>= pzPkgDataDir_STRUCT_VERSION)
end_define

begin_comment
comment|/**  * The version that first stored the option usage in each option descriptor  */
end_comment

begin_define
define|#
directive|define
name|opt_usage_t_STRUCT_VERSION
value|0x26000
end_define

begin_comment
comment|/* AO_CURRENT = 38 */
end_comment

begin_define
define|#
directive|define
name|HAS_opt_usage_t
parameter_list|(
name|_opt
parameter_list|)
define|\
value|((_opt)->structVersion>= opt_usage_t_STRUCT_VERSION)
end_define

begin_comment
comment|/**  *  "token list" structure returned by "string_tokenize()"  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|long
name|tkn_ct
decl_stmt|;
comment|///< number of tokens found
name|unsigned
name|char
modifier|*
name|tkn_list
index|[
literal|1
index|]
decl_stmt|;
comment|///< array of pointers to tokens
block|}
name|token_list_t
typedef|;
end_typedef

begin_comment
comment|/*  *  Hide the interface - it pollutes a POSIX claim, but leave it for  *  anyone #include-ing this header  */
end_comment

begin_define
define|#
directive|define
name|strneqvcmp
value|option_strneqvcmp
end_define

begin_define
define|#
directive|define
name|streqvcmp
value|option_streqvcmp
end_define

begin_define
define|#
directive|define
name|streqvmap
value|option_streqvmap
end_define

begin_define
define|#
directive|define
name|strequate
value|option_strequate
end_define

begin_define
define|#
directive|define
name|strtransform
value|option_strtransform
end_define

begin_comment
comment|/**  *  Everything needed to be known about an mmap-ed file.  *  *  This is an output only structure used by text_mmap and text_munmap.  *  Clients must not alter the contents and must provide it to both  *  the text_mmap and text_munmap procedures.  BE ADVISED: if you are  *  mapping the file with PROT_WRITE the NUL byte at the end MIGHT NOT  *  BE WRITABLE.  In any event, that byte is not be written back  *  to the source file.  ALSO: if "txt_data" is valid and "txt_errno"  *  is not zero, then there *may* not be a terminating NUL.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|void
modifier|*
name|txt_data
decl_stmt|;
comment|///< text file data
name|size_t
name|txt_size
decl_stmt|;
comment|///< actual file size
name|size_t
name|txt_full_size
decl_stmt|;
comment|///< mmaped mem size
name|int
name|txt_fd
decl_stmt|;
comment|///< file descriptor
name|int
name|txt_zero_fd
decl_stmt|;
comment|///< fd for /dev/zero
name|int
name|txt_errno
decl_stmt|;
comment|///< warning code
name|int
name|txt_prot
decl_stmt|;
comment|///< "prot" flags
name|int
name|txt_flags
decl_stmt|;
comment|///< mapping type
block|}
name|tmap_info_t
typedef|;
end_typedef

begin_comment
comment|/**  * mmap result wrapper that yields "true" when mmap has failed.  */
end_comment

begin_define
define|#
directive|define
name|TEXT_MMAP_FAILED_ADDR
parameter_list|(
name|a
parameter_list|)
value|((void*)(a) ==  (void*)MAP_FAILED)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_define
define|#
directive|define
name|CPLUSPLUS_OPENER
value|extern "C" {
end_define

begin_function_decl
name|CPLUSPLUS_OPENER
define|#
directive|define
name|CPLUSPLUS_CLOSER
value|}
else|#
directive|else
define|#
directive|define
name|CPLUSPLUS_CLOSER
endif|#
directive|endif
comment|/**  *  The following routines may be coded into AutoOpts client code:  */
comment|/**  * ao_string_tokenize - tokenize an input string  *  *  This function will convert one input string into a list of strings.  *  The list of strings is derived by separating the input based on  *  white space separation.  However, if the input contains either single  *  or double quote characters, then the text after that character up to  *  a matching quote will become the string in the list.  *  *  The returned pointer should be deallocated with @code{free(3C)} when  *  are done using the data.  The data are placed in a single block of  *  allocated memory.  Do not deallocate individual token/strings.  *  *  The structure pointed to will contain at least these two fields:  *  @table @samp  *  @item tkn_ct  *  The number of tokens found in the input string.  *  @item tok_list  *  An array of @code{tkn_ct + 1} pointers to substring tokens, with  *  the last pointer set to NULL.  *  @end table  *  *  There are two types of quoted strings: single quoted (@code{'}) and  *  double quoted (@code{"}).  Singly quoted strings are fairly raw in that  *  escape characters (@code{\\}) are simply another character, except when  *  preceding the following characters:  *  @example  *  @code{\\}  double backslashes reduce to one  *  @code{'}   incorporates the single quote into the string  *  @code{\n}  suppresses both the backslash and newline character  *  @end example  *  *  Double quote strings are formed according to the rules of string  *  constants in ANSI-C programs.  *  * @param string       string to be tokenized  *  * @return token_list_t* - pointer to a structure that lists each token  */
specifier|extern
name|token_list_t
modifier|*
name|ao_string_tokenize
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * configFileLoad - parse a configuration file  *  *  This routine will load a named configuration file and parse the  *  text as a hierarchically valued option.  The option descriptor  *  created from an option definition file is not used via this interface.  *  The returned value is "named" with the input file name and is of  *  type "@code{OPARG_TYPE_HIERARCHY}".  It may be used in calls to  *  @code{optionGetValue()}, @code{optionNextValue()} and  *  @code{optionUnloadNested()}.  *  * @param fname        the file to load  *  * @return const tOptionValue* - An allocated, compound value structure  */
end_comment

begin_function_decl
specifier|extern
specifier|const
name|tOptionValue
modifier|*
name|configFileLoad
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionFileLoad - Load the locatable config files, in order  *  *  This function looks in all the specified directories for a configuration  *  file ("rc" file or "ini" file) and processes any found twice.  The first  *  time through, they are processed in reverse order (last file first).  At  *  that time, only "immediate action" configurables are processed.  For  *  example, if the last named file specifies not processing any more  *  configuration files, then no more configuration files will be processed.  *  Such an option in the @strong{first} named directory will have no effect.  *  *  Once the immediate action configurables have been handled, then the  *  directories are handled in normal, forward order.  In that way, later  *  config files can override the settings of earlier config files.  *  *  See the AutoOpts documentation for a thorough discussion of the  *  config file format.  *  *  Configuration files not found or not decipherable are simply ignored.  *  * @param opts         program options descriptor  * @param prog         program name  *  * @return int - 0 -> SUCCESS, -1 -> FAILURE  */
end_comment

begin_function_decl
specifier|extern
name|int
name|optionFileLoad
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionFindNextValue - find a hierarcicaly valued option instance  *  *  This routine will find the next entry in a nested value option or  *  configurable.  It will search through the list and return the next entry  *  that matches the criteria.  *  * @param odesc        an option with a nested arg type  * @param pPrevVal     the last entry  * @param name         name of value to find  * @param value        the matching value  *  * @return const tOptionValue* - a compound value structure  */
end_comment

begin_function_decl
specifier|extern
specifier|const
name|tOptionValue
modifier|*
name|optionFindNextValue
parameter_list|(
specifier|const
name|tOptDesc
modifier|*
parameter_list|,
specifier|const
name|tOptionValue
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionFindValue - find a hierarcicaly valued option instance  *  *  This routine will find an entry in a nested value option or configurable.  *  It will search through the list and return a matching entry.  *  * @param odesc        an option with a nested arg type  * @param name         name of value to find  * @param val          the matching value  *  * @return const tOptionValue* - a compound value structure  */
end_comment

begin_function_decl
specifier|extern
specifier|const
name|tOptionValue
modifier|*
name|optionFindValue
parameter_list|(
specifier|const
name|tOptDesc
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionFree - free allocated option processing memory  *  *  AutoOpts sometimes allocates memory and puts pointers to it in the  *  option state structures.  This routine deallocates all such memory.  *  * @param pOpts        program options descriptor  */
end_comment

begin_function_decl
specifier|extern
name|void
name|optionFree
parameter_list|(
name|tOptions
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionGetValue - get a specific value from a hierarcical list  *  *  This routine will find an entry in a nested value option or configurable.  *  If "valueName" is NULL, then the first entry is returned.  Otherwise,  *  the first entry with a name that exactly matches the argument will be  *  returned.  If there is no matching value, NULL is returned and errno is  *  set to ENOENT. If the provided option value is not a hierarchical value,  *  NULL is also returned and errno is set to EINVAL.  *  * @param pOptValue    a hierarchcal value  * @param valueName    name of value to get  *  * @return const tOptionValue* - a compound value structure  */
end_comment

begin_function_decl
specifier|extern
specifier|const
name|tOptionValue
modifier|*
name|optionGetValue
parameter_list|(
specifier|const
name|tOptionValue
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionLoadLine - process a string for an option name and value  *  *  This is a client program callable routine for setting options from, for  *  example, the contents of a file that they read in.  Only one option may  *  appear in the text.  It will be treated as a normal (non-preset) option.  *  *  When passed a pointer to the option struct and a string, it will find  *  the option named by the first token on the string and set the option  *  argument to the remainder of the string.  The caller must NUL terminate  *  the string.  The caller need not skip over any introductory hyphens.  *  Any embedded new lines will be included in the option  *  argument.  If the input looks like one or more quoted strings, then the  *  input will be "cooked".  The "cooking" is identical to the string  *  formation used in AutoGen definition files (@pxref{basic expression}),  *  except that you may not use backquotes.  *  * @param opts         program options descriptor  * @param line         NUL-terminated text  */
end_comment

begin_function_decl
specifier|extern
name|void
name|optionLoadLine
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionMemberList - Get the list of members of a bit mask set  *  *  This converts the OPT_VALUE_name mask value to a allocated string.  *  It is the caller's responsibility to free the string.  *  * @param od           the set membership option description  *  * @return char* - the names of the set bits  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|optionMemberList
parameter_list|(
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionNextValue - get the next value from a hierarchical list  *  *  This routine will return the next entry after the entry passed in.  At the  *  end of the list, NULL will be returned.  If the entry is not found on the  *  list, NULL will be returned and "@var{errno}" will be set to EINVAL.  *  The "@var{pOldValue}" must have been gotten from a prior call to this  *  routine or to "@code{opitonGetValue()}".  *  * @param pOptValue    a hierarchcal list value  * @param pOldValue    a value from this list  *  * @return const tOptionValue* - a compound value structure  */
end_comment

begin_function_decl
specifier|extern
specifier|const
name|tOptionValue
modifier|*
name|optionNextValue
parameter_list|(
specifier|const
name|tOptionValue
modifier|*
parameter_list|,
specifier|const
name|tOptionValue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionOnlyUsage - Print usage text for just the options  *  *  This routine will print only the usage for each option.  *  This function may be used when the emitted usage must incorporate  *  information not available to AutoOpts.  *  * @param pOpts        program options descriptor  * @param ex_code      exit code for calling exit(3)  */
end_comment

begin_function_decl
specifier|extern
name|void
name|optionOnlyUsage
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionPrintVersion - Print the program version  *  *  This routine will print the version to stdout.  *  * @param opts         program options descriptor  * @param od           the descriptor for this arg  */
end_comment

begin_function_decl
specifier|extern
name|void
name|optionPrintVersion
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionPrintVersionAndReturn - Print the program version  *  *  This routine will print the version to stdout and return  *  instead of exiting.  Please see the source for the  *  @code{print_ver} funtion for details on selecting how  *  verbose to be after this function returns.  *  * @param opts         program options descriptor  * @param od           the descriptor for this arg  */
end_comment

begin_function_decl
specifier|extern
name|void
name|optionPrintVersionAndReturn
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionProcess - this is the main option processing routine  *  *  This is the main entry point for processing options.  It is intended  *  that this procedure be called once at the beginning of the execution of  *  a program.  Depending on options selected earlier, it is sometimes  *  necessary to stop and restart option processing, or to select completely  *  different sets of options.  This can be done easily, but you generally  *  do not want to do this.  *  *  The number of arguments processed always includes the program name.  *  If one of the arguments is "--", then it is counted and the processing  *  stops.  If an error was encountered and errors are to be tolerated, then  *  the returned value is the index of the argument causing the error.  *  A hyphen by itself ("-") will also cause processing to stop and will  *  @emph{not} be counted among the processed arguments.  A hyphen by itself  *  is treated as an operand.  Encountering an operand stops option  *  processing.  *  * @param opts         program options descriptor  * @param a_ct         program arg count  * @param a_v          program arg vector  *  * @return int - the count of the arguments processed  */
end_comment

begin_function_decl
specifier|extern
name|int
name|optionProcess
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionRestore - restore option state from memory copy  *  *  Copy back the option state from saved memory.  *  The allocated memory is left intact, so this routine can be  *  called repeatedly without having to call optionSaveState again.  *  If you are restoring a state that was saved before the first call  *  to optionProcess(3AO), then you may change the contents of the  *  argc/argv parameters to optionProcess.  *  * @param pOpts        program options descriptor  */
end_comment

begin_function_decl
specifier|extern
name|void
name|optionRestore
parameter_list|(
name|tOptions
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionSaveFile - saves the option state to a file  *  *  This routine will save the state of option processing to a file.  The name  *  of that file can be specified with the argument to the @code{--save-opts}  *  option, or by appending the @code{rcfile} attribute to the last  *  @code{homerc} attribute.  If no @code{rcfile} attribute was specified, it  *  will default to @code{.@i{programname}rc}.  If you wish to specify another  *  file, you should invoke the @code{SET_OPT_SAVE_OPTS(@i{filename})} macro.  *  *  The recommend usage is as follows:  *  @example  *  optionProcess(&progOptions, argc, argv);  *  if (i_want_a_non_standard_place_for_this)  *  SET_OPT_SAVE_OPTS("myfilename");  *  optionSaveFile(&progOptions);  *  @end example  *  * @param opts         program options descriptor  */
end_comment

begin_function_decl
specifier|extern
name|void
name|optionSaveFile
parameter_list|(
name|tOptions
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionSaveState - saves the option state to memory  *  *  This routine will allocate enough memory to save the current option  *  processing state.  If this routine has been called before, that memory  *  will be reused.  You may only save one copy of the option state.  This  *  routine may be called before optionProcess(3AO).  If you do call it  *  before the first call to optionProcess, then you may also change the  *  contents of argc/argv after you call optionRestore(3AO)  *  *  In fact, more strongly put: it is safest to only use this function  *  before having processed any options.  In particular, the saving and  *  restoring of stacked string arguments and hierarchical values is  *  disabled.  The values are not saved.  *  * @param pOpts        program options descriptor  */
end_comment

begin_function_decl
specifier|extern
name|void
name|optionSaveState
parameter_list|(
name|tOptions
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionUnloadNested - Deallocate the memory for a nested value  *  *  A nested value needs to be deallocated.  The pointer passed in should  *  have been gotten from a call to @code{configFileLoad()} (See  *  @pxref{libopts-configFileLoad}).  *  * @param pOptVal      the hierarchical value  */
end_comment

begin_function_decl
specifier|extern
name|void
name|optionUnloadNested
parameter_list|(
name|tOptionValue
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * optionVersion - return the compiled AutoOpts version number  *  *  Returns the full version string compiled into the library.  *  The returned string cannot be modified.  *  * @return char const* - the version string in constant memory  */
end_comment

begin_function_decl
specifier|extern
name|char
specifier|const
modifier|*
name|optionVersion
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * strequate - map a list of characters to the same value  *  *  Each character in the input string get mapped to the first character  *  in the string.  *  This function name is mapped to option_strequate so as to not conflict  *  with the POSIX name space.  *  * @param ch_list      characters to equivalence  */
end_comment

begin_function_decl
specifier|extern
name|void
name|strequate
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * streqvcmp - compare two strings with an equivalence mapping  *  *  Using a character mapping, two strings are compared for "equivalence".  *  Each input character is mapped to a comparison character and the  *  mapped-to characters are compared for the two NUL terminated input strings.  *  This function name is mapped to option_streqvcmp so as to not conflict  *  with the POSIX name space.  *  * @param str1         first string  * @param str2         second string  *  * @return int - the difference between two differing characters  */
end_comment

begin_function_decl
specifier|extern
name|int
name|streqvcmp
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * streqvmap - Set the character mappings for the streqv functions  *  *  Set the character mapping.  If the count (@code{ct}) is set to zero, then  *  the map is cleared by setting all entries in the map to their index  *  value.  Otherwise, the "@code{From}" character is mapped to the "@code{To}"  *  character.  If @code{ct} is greater than 1, then @code{From} and @code{To}  *  are incremented and the process repeated until @code{ct} entries have been  *  set. For example,  *  @example  *  streqvmap('a', 'A', 26);  *  @end example  *  @noindent  *  will alter the mapping so that all English lower case letters  *  will map to upper case.  *  *  This function name is mapped to option_streqvmap so as to not conflict  *  with the POSIX name space.  *  * @param from         Input character  * @param to           Mapped-to character  * @param ct           compare length  */
end_comment

begin_function_decl
specifier|extern
name|void
name|streqvmap
parameter_list|(
name|char
parameter_list|,
name|char
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * strneqvcmp - compare two strings with an equivalence mapping  *  *  Using a character mapping, two strings are compared for "equivalence".  *  Each input character is mapped to a comparison character and the  *  mapped-to characters are compared for the two NUL terminated input strings.  *  The comparison is limited to @code{ct} bytes.  *  This function name is mapped to option_strneqvcmp so as to not conflict  *  with the POSIX name space.  *  * @param str1         first string  * @param str2         second string  * @param ct           compare length  *  * @return int - the difference between two differing characters  */
end_comment

begin_function_decl
specifier|extern
name|int
name|strneqvcmp
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * strtransform - convert a string into its mapped-to value  *  *  Each character in the input string is mapped and the mapped-to  *  character is put into the output.  *  This function name is mapped to option_strtransform so as to not conflict  *  with the POSIX name space.  *  *  The source and destination may be the same.  *  * @param dest         output string  * @param src          input string  */
end_comment

begin_function_decl
specifier|extern
name|void
name|strtransform
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  AutoOpts PRIVATE FUNCTIONS:  */
end_comment

begin_decl_stmt
name|tOptProc
name|optionStackArg
decl_stmt|,
name|optionUnstackArg
decl_stmt|,
name|optionBooleanVal
decl_stmt|,
name|optionNumericVal
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|ao_string_cook
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|unsigned
name|int
name|ao_string_cook_escape_char
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|genshelloptUsage
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|optionAlias
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionBooleanVal
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|uintptr_t
name|optionEnumerationVal
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionFileCheck
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|,
name|teOptFileType
parameter_list|,
name|tuFileMode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
specifier|const
modifier|*
name|optionKeywordName
parameter_list|(
name|tOptDesc
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionLoadOpt
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|bool
name|optionMakePath
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionNestedVal
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionNumericVal
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionPagedUsage
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionParseShell
parameter_list|(
name|tOptions
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionPrintParagraphs
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionPutShell
parameter_list|(
name|tOptions
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
specifier|const
modifier|*
name|optionQuoteString
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionResetOpt
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionSetMembers
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionShowRange
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionStackArg
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionTimeDate
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionTimeVal
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionUnstackArg
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionUsage
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionVendorOption
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|optionVersionStderr
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
modifier|*
name|text_mmap
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|tmap_info_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|text_munmap
parameter_list|(
name|tmap_info_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|CPLUSPLUS_CLOSER
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTOOPTS_OPTIONS_H_GUARD */
end_comment

begin_comment
comment|/** @}  *  * Local Variables:  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * options.h ends here */
end_comment

end_unit

