begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * \file usage.c  *  *  This module implements the default usage procedure for  *  Automated Options.  It may be overridden, of course.  *  * @addtogroup autoopts  * @{  */
end_comment

begin_comment
comment|/*  *  Sort options:     --start=END-[S]TATIC-FORWARD --patt='^/\*($|[^:])' \     --out=xx.c key='^[a-zA-Z0-9_]+\(' --trail='^/\*:' \     --spac=2 --input=usage.c  */
end_comment

begin_comment
comment|/*  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  */
end_comment

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|unsigned
name|int
name|parse_usage_flags
parameter_list|(
name|ao_flag_names_t
specifier|const
modifier|*
name|fnt
parameter_list|,
name|char
specifier|const
modifier|*
name|txt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|do_gnu_usage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|bool
name|skip_misuse_usage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_offer_usage
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_usage_details
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|int
name|exit_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_one_paragraph
parameter_list|(
name|char
specifier|const
modifier|*
name|text
parameter_list|,
name|bool
name|plain
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prt_conflicts
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prt_one_vendor
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|,
name|arg_types_t
modifier|*
name|argtp
parameter_list|,
name|char
specifier|const
modifier|*
name|usefmt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prt_vendor_opts
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|title
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prt_extd_usage
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|,
name|char
specifier|const
modifier|*
name|title
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prt_ini_list
parameter_list|(
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|papz
parameter_list|,
name|char
specifier|const
modifier|*
name|ini_file
parameter_list|,
name|char
specifier|const
modifier|*
name|path_nm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prt_preamble
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|,
name|arg_types_t
modifier|*
name|at
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prt_one_usage
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|,
name|arg_types_t
modifier|*
name|at
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prt_opt_usage
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|int
name|ex_code
parameter_list|,
name|char
specifier|const
modifier|*
name|title
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prt_prog_detail
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setGnuOptFmts
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
modifier|*
name|ptxt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setStdOptFmts
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
modifier|*
name|ptxt
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/**  * Parse the option usage flags string.  Any parsing problems yield  * a zero (no flags set) result.  This function is internal to  * set_usage_flags().  *  * @param[in] fnt   Flag Name Table - maps a name to a mask  * @param[in] txt   the text to process.  If NULL, then  *                  getenv("AUTOOPTS_USAGE") is used.  * @returns a bit mask indicating which \a fnt entries were found.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|parse_usage_flags
parameter_list|(
name|ao_flag_names_t
specifier|const
modifier|*
name|fnt
parameter_list|,
name|char
specifier|const
modifier|*
name|txt
parameter_list|)
block|{
name|unsigned
name|int
name|res
init|=
literal|0
decl_stmt|;
comment|/*      * The text may be passed in.  If not, use the environment variable.      */
if|if
condition|(
name|txt
operator|==
name|NULL
condition|)
block|{
name|txt
operator|=
name|getenv
argument_list|(
literal|"AUTOOPTS_USAGE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|txt
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
name|txt
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|txt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|txt
operator|==
name|NUL
condition|)
return|return
literal|0
return|;
comment|/*      * search the string for table entries.  We must understand everything      * we see in the string, or we give up on it.      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ix
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|strneqvcmp
argument_list|(
name|txt
argument_list|,
name|fnt
index|[
name|ix
index|]
operator|.
name|fnm_name
argument_list|,
operator|(
name|int
operator|)
name|fnt
index|[
name|ix
index|]
operator|.
name|fnm_len
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|++
name|ix
operator|>=
name|AOUF_COUNT
condition|)
return|return
literal|0
return|;
block|}
comment|/*          *  Make sure we have a full match.  Look for whitespace,          *  a comma, or a NUL byte.          */
if|if
condition|(
operator|!
name|IS_END_LIST_ENTRY_CHAR
argument_list|(
name|txt
index|[
name|fnt
index|[
name|ix
index|]
operator|.
name|fnm_len
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|res
operator||=
literal|1U
operator|<<
name|ix
expr_stmt|;
name|txt
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|txt
operator|+
name|fnt
index|[
name|ix
index|]
operator|.
name|fnm_len
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|txt
condition|)
block|{
case|case
name|NUL
case|:
return|return
name|res
return|;
case|case
literal|','
case|:
name|txt
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|txt
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Something must follow the comma */
default|default:
continue|continue;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Set option usage flags.  Any parsing problems yield no changes to options.  * Three different bits may be fiddled: \a OPTPROC_GNUUSAGE, \a OPTPROC_MISUSE  * and \a OPTPROC_COMPUTE.  *  * @param[in] flg_txt   text to parse.  If NULL, then the AUTOOPTS_USAGE  *                      environment variable is parsed.  * @param[in,out] opts  the program option descriptor  */
end_comment

begin_function
name|LOCAL
name|void
name|set_usage_flags
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|flg_txt
parameter_list|)
block|{
define|#
directive|define
name|_aof_
parameter_list|(
name|_n
parameter_list|,
name|_f
parameter_list|)
value|{ sizeof(#_n)-1, _f, #_n },
specifier|static
name|ao_flag_names_t
specifier|const
name|fn_table
index|[
name|AOUF_COUNT
index|]
init|=
block|{
name|AOFLAG_TABLE
block|}
decl_stmt|;
undef|#
directive|undef
name|_aof_
comment|/*      * the flag word holds a bit for each selected table entry.      */
name|unsigned
name|int
name|flg
init|=
name|parse_usage_flags
argument_list|(
name|fn_table
argument_list|,
name|flg_txt
argument_list|)
decl_stmt|;
if|if
condition|(
name|flg
operator|==
literal|0
condition|)
return|return;
comment|/*      * Ensure we do not have conflicting selections      */
block|{
specifier|static
name|unsigned
name|int
specifier|const
name|form_mask
init|=
name|AOUF_gnu
operator||
name|AOUF_autoopts
decl_stmt|;
specifier|static
name|unsigned
name|int
specifier|const
name|misuse_mask
init|=
name|AOUF_no_misuse_usage
operator||
name|AOUF_misuse_usage
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|flg
operator|&
name|form_mask
operator|)
operator|==
name|form_mask
operator|)
operator|||
operator|(
operator|(
name|flg
operator|&
name|misuse_mask
operator|)
operator|==
name|misuse_mask
operator|)
condition|)
return|return;
block|}
comment|/*      * Now fiddle the fOptSet bits, based on settings.      * The OPTPROC_LONGOPT bit is immutable, thus if it is set,      * then fnm points to a mask off mask.      */
block|{
name|ao_flag_names_t
specifier|const
modifier|*
name|fnm
init|=
name|fn_table
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|flg
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|fnm
operator|->
name|fnm_mask
operator|&
name|OPTPROC_LONGOPT
operator|)
operator|!=
literal|0
condition|)
name|opts
operator|->
name|fOptSet
operator|&=
name|fnm
operator|->
name|fnm_mask
expr_stmt|;
else|else
name|opts
operator|->
name|fOptSet
operator||=
name|fnm
operator|->
name|fnm_mask
expr_stmt|;
block|}
name|flg
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|flg
operator|==
literal|0
condition|)
break|break;
name|fnm
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *  Figure out if we should try to format usage text sort-of like  *  the way many GNU programs do.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|do_gnu_usage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
return|return
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_GNUUSAGE
operator|)
condition|?
name|true
else|:
name|false
return|;
block|}
end_function

begin_comment
comment|/*  *  Figure out if we should try to format usage text sort-of like  *  the way many GNU programs do.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|skip_misuse_usage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
return|return
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_MISUSE
operator|)
condition|?
name|true
else|:
name|false
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionOnlyUsage  *  * what:  Print usage text for just the options  * arg:   + tOptions*   + pOpts    + program options descriptor +  * arg:   + int         + ex_code  + exit code for calling exit(3) +  *  * doc:  *  This routine will print only the usage for each option.  *  This function may be used when the emitted usage must incorporate  *  information not available to AutoOpts. =*/
end_comment

begin_function
name|void
name|optionOnlyUsage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|int
name|ex_code
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|pOptTitle
init|=
name|NULL
decl_stmt|;
name|set_usage_flags
argument_list|(
name|pOpts
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ex_code
operator|!=
name|EXIT_SUCCESS
operator|)
operator|&&
name|skip_misuse_usage
argument_list|(
name|pOpts
argument_list|)
condition|)
return|return;
comment|/*      *  Determine which header and which option formatting strings to use      */
if|if
condition|(
name|do_gnu_usage
argument_list|(
name|pOpts
argument_list|)
condition|)
operator|(
name|void
operator|)
name|setGnuOptFmts
argument_list|(
name|pOpts
argument_list|,
operator|&
name|pOptTitle
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|setStdOptFmts
argument_list|(
name|pOpts
argument_list|,
operator|&
name|pOptTitle
argument_list|)
expr_stmt|;
name|prt_opt_usage
argument_list|(
name|pOpts
argument_list|,
name|ex_code
argument_list|,
name|pOptTitle
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|option_usage_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|option_usage_fp
argument_list|)
operator|!=
literal|0
condition|)
name|fserr_exit
argument_list|(
name|pOpts
operator|->
name|pzProgName
argument_list|,
name|zwriting
argument_list|,
operator|(
name|option_usage_fp
operator|==
name|stderr
operator|)
condition|?
name|zstderr_name
else|:
name|zstdout_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Print a message suggesting how to get help.  *  * @param[in] opts      the program options  */
end_comment

begin_function
specifier|static
name|void
name|print_offer_usage
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
block|{
name|char
name|help
index|[
literal|24
index|]
decl_stmt|;
if|if
condition|(
name|HAS_opt_usage_t
argument_list|(
name|opts
argument_list|)
condition|)
block|{
name|int
name|ix
init|=
name|opts
operator|->
name|presetOptCt
decl_stmt|;
name|tOptDesc
modifier|*
name|od
init|=
name|opts
operator|->
name|pOptDesc
operator|+
name|ix
decl_stmt|;
while|while
condition|(
name|od
operator|->
name|optUsage
operator|!=
name|AOUSE_HELP
condition|)
block|{
if|if
condition|(
operator|++
name|ix
operator|>=
name|opts
operator|->
name|optCt
condition|)
name|ao_bug
argument_list|(
name|zmissing_help_msg
argument_list|)
expr_stmt|;
name|od
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|opts
operator|->
name|fOptSet
operator|&
operator|(
name|OPTPROC_LONGOPT
operator||
name|OPTPROC_SHORTOPT
operator|)
condition|)
block|{
case|case
name|OPTPROC_SHORTOPT
case|:
name|help
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|help
index|[
literal|1
index|]
operator|=
name|od
operator|->
name|optValue
expr_stmt|;
name|help
index|[
literal|2
index|]
operator|=
name|NUL
expr_stmt|;
break|break;
case|case
name|OPTPROC_LONGOPT
case|:
case|case
operator|(
name|OPTPROC_LONGOPT
operator||
name|OPTPROC_SHORTOPT
operator|)
case|:
name|help
index|[
literal|0
index|]
operator|=
name|help
index|[
literal|1
index|]
operator|=
literal|'-'
expr_stmt|;
name|strncpy
argument_list|(
name|help
operator|+
literal|2
argument_list|,
name|od
operator|->
name|pz_Name
argument_list|,
literal|20
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|strncpy
argument_list|(
name|help
argument_list|,
name|od
operator|->
name|pz_Name
argument_list|,
literal|20
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|opts
operator|->
name|fOptSet
operator|&
operator|(
name|OPTPROC_LONGOPT
operator||
name|OPTPROC_SHORTOPT
operator|)
condition|)
block|{
case|case
name|OPTPROC_SHORTOPT
case|:
name|strcpy
argument_list|(
name|help
argument_list|,
literal|"-h"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTPROC_LONGOPT
case|:
case|case
operator|(
name|OPTPROC_LONGOPT
operator||
name|OPTPROC_SHORTOPT
operator|)
case|:
name|strcpy
argument_list|(
name|help
argument_list|,
literal|"--help"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|strcpy
argument_list|(
name|help
argument_list|,
literal|"help"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zoffer_usage_fmt
argument_list|,
name|opts
operator|->
name|pzProgName
argument_list|,
name|help
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Print information about each option.  *  * @param[in] opts      the program options  * @param[in] exit_code whether or not there was a usage error reported.  *                      used to select full usage versus abbreviated.  */
end_comment

begin_function
specifier|static
name|void
name|print_usage_details
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|int
name|exit_code
parameter_list|)
block|{
block|{
name|char
specifier|const
modifier|*
name|pOptTitle
init|=
name|NULL
decl_stmt|;
name|int
name|flen
decl_stmt|;
comment|/*          *  Determine which header and which option formatting strings to use          */
if|if
condition|(
name|do_gnu_usage
argument_list|(
name|opts
argument_list|)
condition|)
block|{
name|flen
operator|=
name|setGnuOptFmts
argument_list|(
name|opts
argument_list|,
operator|&
name|pOptTitle
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line_fmt_buf
argument_list|,
name|zFmtFmt
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|NL
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flen
operator|=
name|setStdOptFmts
argument_list|(
name|opts
argument_list|,
operator|&
name|pOptTitle
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line_fmt_buf
argument_list|,
name|zFmtFmt
argument_list|,
name|flen
argument_list|)
expr_stmt|;
comment|/*              *  When we exit with EXIT_SUCCESS and the first option is a doc              *  option, we do *NOT* want to emit the column headers.              *  Otherwise, we do.              */
if|if
condition|(
operator|(
name|exit_code
operator|!=
name|EXIT_SUCCESS
operator|)
operator|||
operator|(
operator|(
name|opts
operator|->
name|pOptDesc
operator|->
name|fOptState
operator|&
name|OPTST_DOCUMENT
operator|)
operator|==
literal|0
operator|)
condition|)
name|fputs
argument_list|(
name|pOptTitle
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
name|flen
operator|=
literal|4
operator|-
operator|(
operator|(
name|flen
operator|+
literal|15
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|flen
operator|>
literal|0
condition|)
name|tab_skip_ct
operator|=
name|flen
expr_stmt|;
name|prt_opt_usage
argument_list|(
name|opts
argument_list|,
name|exit_code
argument_list|,
name|pOptTitle
argument_list|)
expr_stmt|;
block|}
comment|/*      *  Describe the mechanics of denoting the options      */
switch|switch
condition|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_L_N_S
condition|)
block|{
case|case
name|OPTPROC_L_N_S
case|:
name|fputs
argument_list|(
name|zFlagOkay
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTPROC_SHORTOPT
case|:
break|break;
case|case
name|OPTPROC_LONGOPT
case|:
name|fputs
argument_list|(
name|zNoFlags
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|fputs
argument_list|(
name|zOptsOnly
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_NUM_OPT
operator|)
operator|!=
literal|0
condition|)
name|fputs
argument_list|(
name|zNumberOpt
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_REORDER
operator|)
operator|!=
literal|0
condition|)
name|fputs
argument_list|(
name|zReorder
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|pzExplain
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|opts
operator|->
name|pzExplain
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*      *  IF the user is asking for help (thus exiting with SUCCESS),      *  THEN see what additional information we can provide.      */
if|if
condition|(
name|exit_code
operator|==
name|EXIT_SUCCESS
condition|)
name|prt_prog_detail
argument_list|(
name|opts
argument_list|)
expr_stmt|;
comment|/*      * Give bug notification preference to the packager information      */
if|if
condition|(
name|HAS_pzPkgDataDir
argument_list|(
name|opts
argument_list|)
operator|&&
operator|(
name|opts
operator|->
name|pzPackager
operator|!=
name|NULL
operator|)
condition|)
name|fputs
argument_list|(
name|opts
operator|->
name|pzPackager
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opts
operator|->
name|pzBugAddr
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zPlsSendBugs
argument_list|,
name|opts
operator|->
name|pzBugAddr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|option_usage_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|option_usage_fp
argument_list|)
operator|!=
literal|0
condition|)
name|fserr_exit
argument_list|(
name|opts
operator|->
name|pzProgName
argument_list|,
name|zwriting
argument_list|,
operator|(
name|option_usage_fp
operator|==
name|stderr
operator|)
condition|?
name|zstderr_name
else|:
name|zstdout_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_one_paragraph
parameter_list|(
name|char
specifier|const
modifier|*
name|text
parameter_list|,
name|bool
name|plain
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|plain
condition|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_NLS
ifdef|#
directive|ifdef
name|HAVE_LIBINTL_H
ifdef|#
directive|ifdef
name|DEBUG_ENABLED
undef|#
directive|undef
name|gettext
endif|#
directive|endif
name|char
modifier|*
name|buf
init|=
name|dgettext
argument_list|(
literal|"libopts"
argument_list|,
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|text
condition|)
name|text
operator|=
name|gettext
argument_list|(
name|text
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_LIBINTL_H */
endif|#
directive|endif
comment|/* ENABLE_NLS */
name|fputs
argument_list|(
name|text
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
specifier|const
modifier|*
name|t
init|=
name|optionQuoteString
argument_list|(
name|text
argument_list|,
name|LINE_SPLICE
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
name|PUTS_FMT
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|AGFREE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*=export_func  optionPrintParagraphs  * private:  *  * what:  Print a paragraph of usage text  * arg:   + char const * + text  + a block of text that has bee i18n-ed +  * arg:   + bool         + plain + false -> wrap text in fputs()        +  * arg:   + FILE *       + fp    + the stream file pointer for output   +  *  * doc:  *  This procedure is called in two contexts: when a full or short usage text  *  has been provided for display, and when autogen is assembling a list of  *  translatable texts in the optmain.tlib template.  In the former case, \a  *  plain is set to \a true, otherwise \a false.  *  *  Anything less than 256 characters in size is printed as a single unit.  *  Otherwise, paragraphs are detected.  A paragraph break is defined as just  *  before a non-empty line preceded by two newlines or a line that starts  *  with at least one space character but fewer than 8 space characters.  *  Lines indented with tabs or more than 7 spaces are considered continuation  *  lines.  *  *  If 'plain' is true, we are emitting text for a user to see.  So, if it is  *  true and NLS is not enabled, then just write the whole thing at once. =*/
end_comment

begin_function
name|void
name|optionPrintParagraphs
parameter_list|(
name|char
specifier|const
modifier|*
name|text
parameter_list|,
name|bool
name|plain
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
ifndef|#
directive|ifndef
name|ENABLE_NLS
if|if
condition|(
name|plain
operator|||
operator|(
name|len
operator|<
literal|256
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|len
operator|<
literal|256
condition|)
endif|#
directive|endif
block|{
name|print_one_paragraph
argument_list|(
name|text
argument_list|,
name|plain
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
name|AGDUPSTR
argument_list|(
name|buf
argument_list|,
name|text
argument_list|,
literal|"ppara"
argument_list|)
expr_stmt|;
name|text
operator|=
name|buf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|scan
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|256
condition|)
block|{
name|done
label|:
name|print_one_paragraph
argument_list|(
name|buf
argument_list|,
name|plain
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
name|scan
operator|=
name|buf
expr_stmt|;
name|try_longer
label|:
name|scan
operator|=
name|strchr
argument_list|(
name|scan
argument_list|,
name|NL
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|scan
operator|-
name|buf
operator|)
operator|<
literal|40
condition|)
block|{
name|scan
operator|++
expr_stmt|;
goto|goto
name|try_longer
goto|;
block|}
name|scan
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|scan
argument_list|)
operator|)
operator|||
operator|(
operator|*
name|scan
operator|==
name|HT
operator|)
condition|)
comment|/*              * line starts with tab or non-whitespace --> continuation              */
goto|goto
name|try_longer
goto|;
if|if
condition|(
operator|*
name|scan
operator|==
name|NL
condition|)
block|{
comment|/*              * Double newline -> paragraph break              * Include all newlines in current paragraph.              */
while|while
condition|(
operator|*
operator|++
name|scan
operator|==
name|NL
condition|)
comment|/*continue*/
empty_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
init|=
name|scan
decl_stmt|;
name|int
name|sp_ct
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
operator|++
name|sp_ct
operator|>=
literal|8
condition|)
block|{
comment|/*                      * Too many spaces --> continuation line                      */
name|scan
operator|=
name|p
expr_stmt|;
goto|goto
name|try_longer
goto|;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
comment|/*          * "scan" points to the first character of a paragraph or the          * terminating NUL byte.          */
block|{
name|char
name|svch
init|=
operator|*
name|scan
decl_stmt|;
operator|*
name|scan
operator|=
name|NUL
expr_stmt|;
name|print_one_paragraph
argument_list|(
name|buf
argument_list|,
name|plain
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|len
operator|-=
name|scan
operator|-
name|buf
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
break|break;
operator|*
name|scan
operator|=
name|svch
expr_stmt|;
name|buf
operator|=
name|scan
expr_stmt|;
block|}
block|}
name|AGFREE
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*=export_func  optionUsage  * private:  *  * what:  Print usage text  * arg:   + tOptions* + opts + program options descriptor +  * arg:   + int       + exitCode + exit code for calling exit(3) +  *  * doc:  *  This routine will print usage in both GNU-standard and AutoOpts-expanded  *  formats.  The descriptor specifies the default, but AUTOOPTS_USAGE will  *  over-ride this, providing the value of it is set to either "gnu" or  *  "autoopts".  This routine will @strong{not} return.  *  *  If "exitCode" is "AO_EXIT_REQ_USAGE" (normally 64), then output will to  *  to stdout and the actual exit code will be "EXIT_SUCCESS". =*/
end_comment

begin_function
name|void
name|optionUsage
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|int
name|usage_exit_code
parameter_list|)
block|{
name|int
name|exit_code
init|=
operator|(
name|usage_exit_code
operator|==
name|AO_EXIT_REQ_USAGE
operator|)
condition|?
name|EXIT_SUCCESS
else|:
name|usage_exit_code
decl_stmt|;
name|displayEnum
operator|=
name|false
expr_stmt|;
name|set_usage_flags
argument_list|(
name|opts
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*      *  Paged usage will preset option_usage_fp to an output file.      *  If it hasn't already been set, then set it to standard output      *  on successful exit (help was requested), otherwise error out.      *      *  Test the version before obtaining pzFullUsage or pzShortUsage.      *  These fields do not exist before revision 30.      */
block|{
name|char
specifier|const
modifier|*
name|pz
decl_stmt|;
if|if
condition|(
name|exit_code
operator|==
name|EXIT_SUCCESS
condition|)
block|{
name|pz
operator|=
operator|(
name|opts
operator|->
name|structVersion
operator|>=
literal|30
operator|*
literal|4096
operator|)
condition|?
name|opts
operator|->
name|pzFullUsage
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|option_usage_fp
operator|==
name|NULL
condition|)
name|option_usage_fp
operator|=
name|print_exit
condition|?
name|stderr
else|:
name|stdout
expr_stmt|;
block|}
else|else
block|{
name|pz
operator|=
operator|(
name|opts
operator|->
name|structVersion
operator|>=
literal|30
operator|*
literal|4096
operator|)
condition|?
name|opts
operator|->
name|pzShortUsage
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|option_usage_fp
operator|==
name|NULL
condition|)
name|option_usage_fp
operator|=
name|stderr
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_COMPUTE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|pz
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_TRANSLATE
operator|)
operator|!=
literal|0
condition|)
name|optionPrintParagraphs
argument_list|(
name|pz
argument_list|,
name|true
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|pz
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
goto|goto
name|flush_and_exit
goto|;
block|}
block|}
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|opts
operator|->
name|pzUsageTitle
argument_list|,
name|opts
operator|->
name|pzProgName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|exit_code
operator|==
name|EXIT_SUCCESS
operator|)
operator|||
operator|(
operator|!
name|skip_misuse_usage
argument_list|(
name|opts
argument_list|)
operator|)
condition|)
name|print_usage_details
argument_list|(
name|opts
argument_list|,
name|usage_exit_code
argument_list|)
expr_stmt|;
else|else
name|print_offer_usage
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|flush_and_exit
label|:
name|fflush
argument_list|(
name|option_usage_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|option_usage_fp
argument_list|)
operator|!=
literal|0
condition|)
name|fserr_exit
argument_list|(
name|opts
operator|->
name|pzProgName
argument_list|,
name|zwriting
argument_list|,
operator|(
name|option_usage_fp
operator|==
name|stdout
operator|)
condition|?
name|zstdout_name
else|:
name|zstderr_name
argument_list|)
expr_stmt|;
name|option_exits
argument_list|(
name|exit_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *   PER OPTION TYPE USAGE INFORMATION  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
end_comment

begin_comment
comment|/**  * print option conflicts.  *  * @param opts the program option descriptor  * @param od   the option descriptor  */
end_comment

begin_function
specifier|static
name|void
name|prt_conflicts
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|)
block|{
specifier|const
name|int
modifier|*
name|opt_no
decl_stmt|;
name|fputs
argument_list|(
name|zTabHyp
operator|+
name|tab_skip_ct
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*      *  REQUIRED:      */
if|if
condition|(
name|od
operator|->
name|pOptMust
operator|!=
name|NULL
condition|)
block|{
name|opt_no
operator|=
name|od
operator|->
name|pOptMust
expr_stmt|;
if|if
condition|(
name|opt_no
index|[
literal|1
index|]
operator|==
name|NO_EQUIVALENT
condition|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zReqOne
argument_list|,
name|opts
operator|->
name|pOptDesc
index|[
operator|*
name|opt_no
index|]
operator|.
name|pz_Name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
name|zReqThese
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zTabout
operator|+
name|tab_skip_ct
argument_list|,
name|opts
operator|->
name|pOptDesc
index|[
operator|*
name|opt_no
index|]
operator|.
name|pz_Name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|opt_no
operator|==
name|NO_EQUIVALENT
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|od
operator|->
name|pOptCant
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|zTabHypAnd
operator|+
name|tab_skip_ct
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
comment|/*      *  CONFLICTS:      */
if|if
condition|(
name|od
operator|->
name|pOptCant
operator|==
name|NULL
condition|)
return|return;
name|opt_no
operator|=
name|od
operator|->
name|pOptCant
expr_stmt|;
if|if
condition|(
name|opt_no
index|[
literal|1
index|]
operator|==
name|NO_EQUIVALENT
condition|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zProhibOne
argument_list|,
name|opts
operator|->
name|pOptDesc
index|[
operator|*
name|opt_no
index|]
operator|.
name|pz_Name
argument_list|)
expr_stmt|;
return|return;
block|}
name|fputs
argument_list|(
name|zProhib
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zTabout
operator|+
name|tab_skip_ct
argument_list|,
name|opts
operator|->
name|pOptDesc
index|[
operator|*
name|opt_no
index|]
operator|.
name|pz_Name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|opt_no
operator|==
name|NO_EQUIVALENT
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  *  Print the usage information for a single vendor option.  *  * @param[in] opts    the program option descriptor  * @param[in] od      the option descriptor  * @param[in] argtp   names of the option argument types  * @param[in] usefmt  format for primary usage line  */
end_comment

begin_function
specifier|static
name|void
name|prt_one_vendor
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|,
name|arg_types_t
modifier|*
name|argtp
parameter_list|,
name|char
specifier|const
modifier|*
name|usefmt
parameter_list|)
block|{
name|prt_preamble
argument_list|(
name|opts
argument_list|,
name|od
argument_list|,
name|argtp
argument_list|)
expr_stmt|;
block|{
name|char
name|z
index|[
literal|80
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|pzArgType
decl_stmt|;
comment|/*          *  Determine the argument type string first on its usage, then,          *  when the option argument is required, base the type string on the          *  argument type.          */
if|if
condition|(
name|od
operator|->
name|fOptState
operator|&
name|OPTST_ARG_OPTIONAL
condition|)
block|{
name|pzArgType
operator|=
name|argtp
operator|->
name|pzOpt
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|od
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_NONE
case|:
name|pzArgType
operator|=
name|argtp
operator|->
name|pzNo
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_ENUMERATION
case|:
name|pzArgType
operator|=
name|argtp
operator|->
name|pzKey
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_FILE
case|:
name|pzArgType
operator|=
name|argtp
operator|->
name|pzFile
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_MEMBERSHIP
case|:
name|pzArgType
operator|=
name|argtp
operator|->
name|pzKeyL
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_BOOLEAN
case|:
name|pzArgType
operator|=
name|argtp
operator|->
name|pzBool
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_NUMERIC
case|:
name|pzArgType
operator|=
name|argtp
operator|->
name|pzNum
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_HIERARCHY
case|:
name|pzArgType
operator|=
name|argtp
operator|->
name|pzNest
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_STRING
case|:
name|pzArgType
operator|=
name|argtp
operator|->
name|pzStr
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_TIME
case|:
name|pzArgType
operator|=
name|argtp
operator|->
name|pzTime
expr_stmt|;
break|break;
default|default:
goto|goto
name|bogus_desc
goto|;
block|}
name|pzArgType
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|pzArgType
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pzArgType
operator|==
name|NUL
condition|)
name|snprintf
argument_list|(
name|z
argument_list|,
sizeof|sizeof
argument_list|(
name|z
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|od
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|z
argument_list|,
sizeof|sizeof
argument_list|(
name|z
argument_list|)
argument_list|,
literal|"%s=%s"
argument_list|,
name|od
operator|->
name|pz_Name
argument_list|,
name|pzArgType
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|usefmt
argument_list|,
name|z
argument_list|,
name|od
operator|->
name|pzText
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|od
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_ENUMERATION
case|:
case|case
name|OPARG_TYPE_MEMBERSHIP
case|:
name|displayEnum
operator|=
operator|(
name|od
operator|->
name|pOptProc
operator|!=
name|NULL
operator|)
condition|?
name|true
else|:
name|displayEnum
expr_stmt|;
block|}
block|}
return|return;
name|bogus_desc
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zbad_od
argument_list|,
name|opts
operator|->
name|pzProgName
argument_list|,
name|od
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
name|ao_bug
argument_list|(
name|zbad_arg_type_msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Print the long options processed with "-W".  These options will be the  * ones that do *not* have flag characters.  *  * @param opts  the program option descriptor  * @param title the title for the options  */
end_comment

begin_function
specifier|static
name|void
name|prt_vendor_opts
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|title
parameter_list|)
block|{
specifier|static
name|unsigned
name|int
specifier|const
name|not_vended_mask
init|=
name|OPTST_NO_USAGE_MASK
operator||
name|OPTST_DOCUMENT
decl_stmt|;
specifier|static
name|char
specifier|const
name|vfmtfmt
index|[]
init|=
literal|"%%-%us %%s\n"
decl_stmt|;
name|char
name|vfmt
index|[
sizeof|sizeof
argument_list|(
name|vfmtfmt
argument_list|)
index|]
decl_stmt|;
comment|/*      *  Only handle client specified options.  The "vendor option" follows      *  "presetOptCt", so we won't loop/recurse indefinitely.      */
name|int
name|ct
init|=
name|opts
operator|->
name|presetOptCt
decl_stmt|;
name|tOptDesc
modifier|*
name|od
init|=
name|opts
operator|->
name|pOptDesc
decl_stmt|;
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zTabout
operator|+
name|tab_skip_ct
argument_list|,
name|zVendOptsAre
argument_list|)
expr_stmt|;
block|{
name|size_t
name|nmlen
init|=
literal|0
decl_stmt|;
do|do
block|{
name|size_t
name|l
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|od
operator|->
name|fOptState
operator|&
name|not_vended_mask
operator|)
operator|!=
literal|0
operator|)
operator|||
name|IS_GRAPHIC_CHAR
argument_list|(
name|od
operator|->
name|optValue
argument_list|)
condition|)
continue|continue;
name|l
operator|=
name|strlen
argument_list|(
name|od
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|nmlen
condition|)
name|nmlen
operator|=
name|l
expr_stmt|;
block|}
do|while
condition|(
name|od
operator|++
operator|,
operator|(
operator|--
name|ct
operator|>
literal|0
operator|)
condition|)
do|;
name|snprintf
argument_list|(
name|vfmt
argument_list|,
sizeof|sizeof
argument_list|(
name|vfmt
argument_list|)
argument_list|,
name|vfmtfmt
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nmlen
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tab_skip_ct
operator|>
literal|0
condition|)
name|tab_skip_ct
operator|--
expr_stmt|;
name|ct
operator|=
name|opts
operator|->
name|presetOptCt
expr_stmt|;
name|od
operator|=
name|opts
operator|->
name|pOptDesc
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
operator|(
name|od
operator|->
name|fOptState
operator|&
name|not_vended_mask
operator|)
operator|!=
literal|0
operator|)
operator|||
name|IS_GRAPHIC_CHAR
argument_list|(
name|od
operator|->
name|optValue
argument_list|)
condition|)
continue|continue;
name|prt_one_vendor
argument_list|(
name|opts
argument_list|,
name|od
argument_list|,
operator|&
name|argTypes
argument_list|,
name|vfmt
argument_list|)
expr_stmt|;
name|prt_extd_usage
argument_list|(
name|opts
argument_list|,
name|od
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|od
operator|++
operator|,
operator|(
operator|--
name|ct
operator|>
literal|0
operator|)
condition|)
do|;
comment|/* no need to restore "tab_skip_ct" - options are done now */
block|}
end_function

begin_comment
comment|/**  * Print extended usage.  Usage/help was requested.  *  * @param opts  the program option descriptor  * @param od   the option descriptor  * @param title the title for the options  */
end_comment

begin_function
specifier|static
name|void
name|prt_extd_usage
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|,
name|char
specifier|const
modifier|*
name|title
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_VENDOR_OPT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|od
operator|->
name|optActualValue
operator|==
name|VENDOR_OPTION_VALUE
operator|)
condition|)
block|{
name|prt_vendor_opts
argument_list|(
name|opts
argument_list|,
name|title
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      *  IF there are option conflicts or dependencies,      *  THEN print them here.      */
if|if
condition|(
operator|(
name|od
operator|->
name|pOptMust
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|od
operator|->
name|pOptCant
operator|!=
name|NULL
operator|)
condition|)
name|prt_conflicts
argument_list|(
name|opts
argument_list|,
name|od
argument_list|)
expr_stmt|;
comment|/*      *  IF there is a disablement string      *  THEN print the disablement info      */
if|if
condition|(
name|od
operator|->
name|pz_DisableName
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zDis
operator|+
name|tab_skip_ct
argument_list|,
name|od
operator|->
name|pz_DisableName
argument_list|)
expr_stmt|;
comment|/*      *  Check for argument types that have callbacks with magical properties      */
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|od
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_NUMERIC
case|:
comment|/*          *  IF the numeric option has a special callback,          *  THEN call it, requesting the range or other special info          */
if|if
condition|(
operator|(
name|od
operator|->
name|pOptProc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|od
operator|->
name|pOptProc
operator|!=
name|optionNumericVal
operator|)
condition|)
block|{
operator|(
operator|*
operator|(
name|od
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|OPTPROC_EMIT_USAGE
operator|,
name|od
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|OPARG_TYPE_FILE
case|:
operator|(
operator|*
operator|(
name|od
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|OPTPROC_EMIT_USAGE
operator|,
name|od
operator|)
expr_stmt|;
break|break;
block|}
comment|/*      *  IF the option defaults to being enabled,      *  THEN print that out      */
if|if
condition|(
name|od
operator|->
name|fOptState
operator|&
name|OPTST_INITENABLED
condition|)
name|fputs
argument_list|(
name|zEnab
operator|+
name|tab_skip_ct
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*      *  IF  the option is in an equivalence class      *        AND not the designated lead      *  THEN print equivalence and leave it at that.      */
if|if
condition|(
operator|(
name|od
operator|->
name|optEquivIndex
operator|!=
name|NO_EQUIVALENT
operator|)
operator|&&
operator|(
name|od
operator|->
name|optEquivIndex
operator|!=
name|od
operator|->
name|optActualIndex
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zalt_opt
operator|+
name|tab_skip_ct
argument_list|,
name|opts
operator|->
name|pOptDesc
index|[
name|od
operator|->
name|optEquivIndex
index|]
operator|.
name|pz_Name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      *  IF this particular option can NOT be preset      *    AND some form of presetting IS allowed,      *    AND it is not an auto-managed option (e.g. --help, et al.)      *  THEN advise that this option may not be preset.      */
if|if
condition|(
operator|(
operator|(
name|od
operator|->
name|fOptState
operator|&
name|OPTST_NO_INIT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|opts
operator|->
name|papzHomeList
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|opts
operator|->
name|pzPROGNAME
operator|!=
name|NULL
operator|)
operator|)
operator|&&
operator|(
name|od
operator|->
name|optIndex
operator|<
name|opts
operator|->
name|presetOptCt
operator|)
condition|)
name|fputs
argument_list|(
name|zNoPreset
operator|+
name|tab_skip_ct
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*      *  Print the appearance requirements.      */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|od
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_MEMBERSHIP
condition|)
name|fputs
argument_list|(
name|zMembers
operator|+
name|tab_skip_ct
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|od
operator|->
name|optMinCt
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|0
case|:
switch|switch
condition|(
name|od
operator|->
name|optMaxCt
condition|)
block|{
case|case
literal|0
case|:
name|fputs
argument_list|(
name|zPreset
operator|+
name|tab_skip_ct
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOLIMIT
case|:
name|fputs
argument_list|(
name|zNoLim
operator|+
name|tab_skip_ct
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
break|break;
comment|/*              * IF the max is more than one but limited, print "UP TO" message              */
default|default:
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zUpTo
operator|+
name|tab_skip_ct
argument_list|,
name|od
operator|->
name|optMaxCt
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
comment|/*          *  More than one is required.  Print the range.          */
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zMust
operator|+
name|tab_skip_ct
argument_list|,
name|od
operator|->
name|optMinCt
argument_list|,
name|od
operator|->
name|optMaxCt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NAMED_OPTS
argument_list|(
name|opts
argument_list|)
operator|&&
operator|(
name|opts
operator|->
name|specOptIdx
operator|.
name|default_opt
operator|==
name|od
operator|->
name|optIndex
operator|)
condition|)
name|fputs
argument_list|(
name|zDefaultOpt
operator|+
name|tab_skip_ct
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
end_comment

begin_comment
comment|/**  * Figure out where all the initialization files might live.  This requires  * translating some environment variables and testing to see if a name is a  * directory or a file.  It's squishy, but important to tell users how to  * find these files.  *  * @param[in]  papz        search path  * @param[out] ini_file    an output buffer of AG_PATH_MAX+1 bytes  * @param[in]  path_nm     the name of the file we're hunting for  */
end_comment

begin_function
specifier|static
name|void
name|prt_ini_list
parameter_list|(
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|papz
parameter_list|,
name|char
specifier|const
modifier|*
name|ini_file
parameter_list|,
name|char
specifier|const
modifier|*
name|path_nm
parameter_list|)
block|{
name|char
name|pth_buf
index|[
name|AG_PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|fputs
argument_list|(
name|zPresetIntro
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
specifier|const
modifier|*
name|path
init|=
operator|*
operator|(
name|papz
operator|++
operator|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|nm_buf
init|=
name|pth_buf
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
break|break;
comment|/*          * Ignore any invalid paths          */
if|if
condition|(
operator|!
name|optionMakePath
argument_list|(
name|pth_buf
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|pth_buf
argument_list|)
argument_list|,
name|path
argument_list|,
name|path_nm
argument_list|)
condition|)
name|nm_buf
operator|=
name|path
expr_stmt|;
comment|/*          * Expand paths that are relative to the executable or installation          * directories.  Leave alone paths that use environment variables.          */
elseif|else
if|if
condition|(
operator|(
operator|*
name|path
operator|==
literal|'$'
operator|)
operator|&&
operator|(
operator|(
name|path
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|||
operator|(
name|path
index|[
literal|1
index|]
operator|==
literal|'@'
operator|)
operator|)
condition|)
name|path
operator|=
name|nm_buf
expr_stmt|;
comment|/*          *  Print the name of the "homerc" file.  If the "rcfile" name is          *  not empty, we may or may not print that, too...          */
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zPathFmt
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ini_file
operator|!=
name|NUL
condition|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
comment|/*              *  IF the "homerc" file is a directory,              *  then append the "rcfile" name.              */
if|if
condition|(
operator|(
name|stat
argument_list|(
name|nm_buf
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|fputc
argument_list|(
name|DIRCH
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|ini_file
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
block|}
name|fputc
argument_list|(
name|NL
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  Print the usage line preamble text  *  * @param opts  the program option descriptor  * @param od    the option descriptor  * @param at    names of the option argument types  */
end_comment

begin_function
specifier|static
name|void
name|prt_preamble
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|,
name|arg_types_t
modifier|*
name|at
parameter_list|)
block|{
comment|/*      *  Flag prefix: IF no flags at all, then omit it.  If not printable      *  (not allowed for this option), then blank, else print it.      *  Follow it with a comma if we are doing GNU usage and long      *  opts are to be printed too.      */
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_SHORTOPT
operator|)
operator|==
literal|0
condition|)
name|fputs
argument_list|(
name|at
operator|->
name|pzSpc
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_GRAPHIC_CHAR
argument_list|(
name|od
operator|->
name|optValue
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
operator|(
name|OPTPROC_GNUUSAGE
operator||
name|OPTPROC_LONGOPT
operator|)
operator|)
operator|==
operator|(
name|OPTPROC_GNUUSAGE
operator||
name|OPTPROC_LONGOPT
operator|)
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|at
operator|->
name|pzNoF
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
literal|"   -%c"
argument_list|,
name|od
operator|->
name|optValue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
operator|(
name|OPTPROC_GNUUSAGE
operator||
name|OPTPROC_LONGOPT
operator|)
operator|)
operator|==
operator|(
name|OPTPROC_GNUUSAGE
operator||
name|OPTPROC_LONGOPT
operator|)
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *  Print the usage information for a single option.  *  * @param opts  the program option descriptor  * @param od    the option descriptor  * @param at    names of the option argument types  */
end_comment

begin_function
specifier|static
name|void
name|prt_one_usage
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|,
name|arg_types_t
modifier|*
name|at
parameter_list|)
block|{
name|prt_preamble
argument_list|(
name|opts
argument_list|,
name|od
argument_list|,
name|at
argument_list|)
expr_stmt|;
block|{
name|char
name|z
index|[
literal|80
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|atyp
decl_stmt|;
comment|/*          *  Determine the argument type string first on its usage, then,          *  when the option argument is required, base the type string on the          *  argument type.          */
if|if
condition|(
name|od
operator|->
name|fOptState
operator|&
name|OPTST_ARG_OPTIONAL
condition|)
block|{
name|atyp
operator|=
name|at
operator|->
name|pzOpt
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|od
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_NONE
case|:
name|atyp
operator|=
name|at
operator|->
name|pzNo
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_ENUMERATION
case|:
name|atyp
operator|=
name|at
operator|->
name|pzKey
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_FILE
case|:
name|atyp
operator|=
name|at
operator|->
name|pzFile
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_MEMBERSHIP
case|:
name|atyp
operator|=
name|at
operator|->
name|pzKeyL
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_BOOLEAN
case|:
name|atyp
operator|=
name|at
operator|->
name|pzBool
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_NUMERIC
case|:
name|atyp
operator|=
name|at
operator|->
name|pzNum
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_HIERARCHY
case|:
name|atyp
operator|=
name|at
operator|->
name|pzNest
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_STRING
case|:
name|atyp
operator|=
name|at
operator|->
name|pzStr
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_TIME
case|:
name|atyp
operator|=
name|at
operator|->
name|pzTime
expr_stmt|;
break|break;
default|default:
goto|goto
name|bogus_desc
goto|;
block|}
ifdef|#
directive|ifdef
name|_WIN32
if|if
condition|(
name|at
operator|->
name|pzOptFmt
operator|==
name|zGnuOptFmt
condition|)
name|snprintf
argument_list|(
name|z
argument_list|,
sizeof|sizeof
argument_list|(
name|z
argument_list|)
argument_list|,
literal|"--%s%s"
argument_list|,
name|od
operator|->
name|pz_Name
argument_list|,
name|atyp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|at
operator|->
name|pzOptFmt
operator|==
name|zGnuOptFmt
operator|+
literal|2
condition|)
name|snprintf
argument_list|(
name|z
argument_list|,
sizeof|sizeof
argument_list|(
name|z
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|od
operator|->
name|pz_Name
argument_list|,
name|atyp
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|snprintf
argument_list|(
name|z
argument_list|,
sizeof|sizeof
argument_list|(
name|z
argument_list|)
argument_list|,
name|at
operator|->
name|pzOptFmt
argument_list|,
name|atyp
argument_list|,
name|od
operator|->
name|pz_Name
argument_list|,
operator|(
name|od
operator|->
name|optMinCt
operator|!=
literal|0
operator|)
condition|?
name|at
operator|->
name|pzReq
else|:
name|at
operator|->
name|pzOpt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|line_fmt_buf
argument_list|,
name|z
argument_list|,
name|od
operator|->
name|pzText
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|od
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_ENUMERATION
case|:
case|case
name|OPARG_TYPE_MEMBERSHIP
case|:
name|displayEnum
operator|=
operator|(
name|od
operator|->
name|pOptProc
operator|!=
name|NULL
operator|)
condition|?
name|true
else|:
name|displayEnum
expr_stmt|;
block|}
block|}
return|return;
name|bogus_desc
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zbad_od
argument_list|,
name|opts
operator|->
name|pzProgName
argument_list|,
name|od
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
name|option_exits
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  Print out the usage information for just the options.  */
end_comment

begin_function
specifier|static
name|void
name|prt_opt_usage
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|int
name|ex_code
parameter_list|,
name|char
specifier|const
modifier|*
name|title
parameter_list|)
block|{
name|int
name|ct
init|=
name|opts
operator|->
name|optCt
decl_stmt|;
name|int
name|optNo
init|=
literal|0
decl_stmt|;
name|tOptDesc
modifier|*
name|od
init|=
name|opts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|docCt
init|=
literal|0
decl_stmt|;
do|do
block|{
comment|/*          * no usage --> disallowed on command line (OPTST_NO_COMMAND), or          * deprecated -- strongly discouraged (OPTST_DEPRECATED), or          * compiled out of current object code (OPTST_OMITTED)          */
if|if
condition|(
operator|(
name|od
operator|->
name|fOptState
operator|&
name|OPTST_NO_USAGE_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/*              * IF      this is a compiled-out option              *   *AND* usage was requested with "omitted-usage"              *   *AND* this is NOT abbreviated usage              * THEN display this option.              */
if|if
condition|(
operator|(
name|od
operator|->
name|fOptState
operator|==
operator|(
name|OPTST_OMITTED
operator||
name|OPTST_NO_INIT
operator|)
operator|)
operator|&&
operator|(
name|od
operator|->
name|pz_Name
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ex_code
operator|==
name|EXIT_SUCCESS
operator|)
condition|)
block|{
name|char
specifier|const
modifier|*
name|why_pz
init|=
operator|(
name|od
operator|->
name|pzText
operator|==
name|NULL
operator|)
condition|?
name|zDisabledWhy
else|:
name|od
operator|->
name|pzText
decl_stmt|;
name|prt_preamble
argument_list|(
name|opts
argument_list|,
name|od
argument_list|,
operator|&
name|argTypes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zDisabledOpt
argument_list|,
name|od
operator|->
name|pz_Name
argument_list|,
name|why_pz
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|(
name|od
operator|->
name|fOptState
operator|&
name|OPTST_DOCUMENT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ex_code
operator|==
name|EXIT_SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|argTypes
operator|.
name|pzBrk
argument_list|,
name|od
operator|->
name|pzText
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|docCt
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Skip name only options when we have a vendor option */
if|if
condition|(
operator|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_VENDOR_OPT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|!
name|IS_GRAPHIC_CHAR
argument_list|(
name|od
operator|->
name|optValue
argument_list|)
operator|)
condition|)
continue|continue;
comment|/*          *  IF       this is the first auto-opt maintained option          *    *AND*  we are doing a full help          *    *AND*  there are documentation options          *    *AND*  the last one was not a doc option,          *  THEN document that the remaining options are not user opts          */
if|if
condition|(
operator|(
name|docCt
operator|>
literal|0
operator|)
operator|&&
operator|(
name|ex_code
operator|==
name|EXIT_SUCCESS
operator|)
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|presetOptCt
operator|==
name|optNo
condition|)
block|{
if|if
condition|(
operator|(
name|od
index|[
operator|-
literal|1
index|]
operator|.
name|fOptState
operator|&
name|OPTST_DOCUMENT
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|argTypes
operator|.
name|pzBrk
argument_list|,
name|zAuto
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ct
operator|==
literal|1
operator|)
operator|&&
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_VENDOR_OPT
operator|)
condition|)
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|argTypes
operator|.
name|pzBrk
argument_list|,
name|zVendIntro
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
name|prt_one_usage
argument_list|(
name|opts
argument_list|,
name|od
argument_list|,
operator|&
name|argTypes
argument_list|)
expr_stmt|;
comment|/*          *  IF we were invoked because of the --help option,          *  THEN print all the extra info          */
if|if
condition|(
name|ex_code
operator|==
name|EXIT_SUCCESS
condition|)
name|prt_extd_usage
argument_list|(
name|opts
argument_list|,
name|od
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|od
operator|++
operator|,
name|optNo
operator|++
operator|,
operator|(
operator|--
name|ct
operator|>
literal|0
operator|)
condition|)
do|;
name|fputc
argument_list|(
name|NL
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
end_comment

begin_comment
comment|/**  *  Print program details.  * @param[in] opts  the program option descriptor  */
end_comment

begin_function
specifier|static
name|void
name|prt_prog_detail
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
block|{
name|bool
name|need_intro
init|=
operator|(
name|opts
operator|->
name|papzHomeList
operator|==
name|NULL
operator|)
decl_stmt|;
comment|/*      *  Display all the places we look for config files, if we have      *  a list of directories to search.      */
if|if
condition|(
operator|!
name|need_intro
condition|)
name|prt_ini_list
argument_list|(
name|opts
operator|->
name|papzHomeList
argument_list|,
name|opts
operator|->
name|pzRcName
argument_list|,
name|opts
operator|->
name|pzProgPath
argument_list|)
expr_stmt|;
comment|/*      *  Let the user know about environment variable settings      */
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ENVIRON
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|need_intro
condition|)
name|fputs
argument_list|(
name|zPresetIntro
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zExamineFmt
argument_list|,
name|opts
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
block|}
comment|/*      *  IF we found an enumeration,      *  THEN hunt for it again.  Call the handler proc with a NULL      *       option struct pointer.  That tells it to display the keywords.      */
if|if
condition|(
name|displayEnum
condition|)
block|{
name|int
name|ct
init|=
name|opts
operator|->
name|optCt
decl_stmt|;
name|int
name|optNo
init|=
literal|0
decl_stmt|;
name|tOptDesc
modifier|*
name|od
init|=
name|opts
operator|->
name|pOptDesc
decl_stmt|;
name|fputc
argument_list|(
name|NL
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|option_usage_fp
argument_list|)
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|od
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_ENUMERATION
case|:
case|case
name|OPARG_TYPE_MEMBERSHIP
case|:
operator|(
operator|*
operator|(
name|od
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|OPTPROC_EMIT_USAGE
operator|,
name|od
operator|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|od
operator|++
operator|,
name|optNo
operator|++
operator|,
operator|(
operator|--
name|ct
operator|>
literal|0
operator|)
condition|)
do|;
block|}
comment|/*      *  If there is a detail string, now is the time for that.      */
if|if
condition|(
name|opts
operator|->
name|pzDetail
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|opts
operator|->
name|pzDetail
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *   OPTION LINE FORMATTING SETUP  *  *  The "OptFmt" formats receive three arguments:  *  1.  the type of the option's argument  *  2.  the long name of the option  *  3.  "YES" or "no ", depending on whether or not the option must appear  *      on the command line.  *  These formats are used immediately after the option flag (if used) has  *  been printed.  *  *  Set up the formatting for GNU-style output  */
end_comment

begin_function
specifier|static
name|int
name|setGnuOptFmts
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
modifier|*
name|ptxt
parameter_list|)
block|{
specifier|static
name|char
specifier|const
name|zOneSpace
index|[]
init|=
literal|" "
decl_stmt|;
name|int
name|flen
init|=
literal|22
decl_stmt|;
operator|*
name|ptxt
operator|=
name|zNoRq_ShrtTtl
expr_stmt|;
name|argTypes
operator|.
name|pzStr
operator|=
name|zGnuStrArg
expr_stmt|;
name|argTypes
operator|.
name|pzReq
operator|=
name|zOneSpace
expr_stmt|;
name|argTypes
operator|.
name|pzNum
operator|=
name|zGnuNumArg
expr_stmt|;
name|argTypes
operator|.
name|pzKey
operator|=
name|zGnuKeyArg
expr_stmt|;
name|argTypes
operator|.
name|pzKeyL
operator|=
name|zGnuKeyLArg
expr_stmt|;
name|argTypes
operator|.
name|pzTime
operator|=
name|zGnuTimeArg
expr_stmt|;
name|argTypes
operator|.
name|pzFile
operator|=
name|zGnuFileArg
expr_stmt|;
name|argTypes
operator|.
name|pzBool
operator|=
name|zGnuBoolArg
expr_stmt|;
name|argTypes
operator|.
name|pzNest
operator|=
name|zGnuNestArg
expr_stmt|;
name|argTypes
operator|.
name|pzOpt
operator|=
name|zGnuOptArg
expr_stmt|;
name|argTypes
operator|.
name|pzNo
operator|=
name|zOneSpace
expr_stmt|;
name|argTypes
operator|.
name|pzBrk
operator|=
name|zGnuBreak
expr_stmt|;
name|argTypes
operator|.
name|pzNoF
operator|=
name|zSixSpaces
expr_stmt|;
name|argTypes
operator|.
name|pzSpc
operator|=
name|zThreeSpaces
expr_stmt|;
switch|switch
condition|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_L_N_S
condition|)
block|{
case|case
name|OPTPROC_L_N_S
case|:
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zGnuOptFmt
expr_stmt|;
break|break;
case|case
name|OPTPROC_LONGOPT
case|:
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zGnuOptFmt
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zGnuOptFmt
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|OPTPROC_SHORTOPT
case|:
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zShrtGnuOptFmt
expr_stmt|;
name|zGnuStrArg
index|[
literal|0
index|]
operator|=
name|zGnuNumArg
index|[
literal|0
index|]
operator|=
name|zGnuKeyArg
index|[
literal|0
index|]
operator|=
name|zGnuBoolArg
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|argTypes
operator|.
name|pzOpt
operator|=
literal|" [arg]"
expr_stmt|;
name|flen
operator|=
literal|8
expr_stmt|;
break|break;
block|}
return|return
name|flen
return|;
block|}
end_function

begin_comment
comment|/*  *  Standard (AutoOpts normal) option line formatting  */
end_comment

begin_function
specifier|static
name|int
name|setStdOptFmts
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
modifier|*
name|ptxt
parameter_list|)
block|{
name|int
name|flen
init|=
literal|0
decl_stmt|;
name|argTypes
operator|.
name|pzStr
operator|=
name|zStdStrArg
expr_stmt|;
name|argTypes
operator|.
name|pzReq
operator|=
name|zStdReqArg
expr_stmt|;
name|argTypes
operator|.
name|pzNum
operator|=
name|zStdNumArg
expr_stmt|;
name|argTypes
operator|.
name|pzKey
operator|=
name|zStdKeyArg
expr_stmt|;
name|argTypes
operator|.
name|pzKeyL
operator|=
name|zStdKeyLArg
expr_stmt|;
name|argTypes
operator|.
name|pzTime
operator|=
name|zStdTimeArg
expr_stmt|;
name|argTypes
operator|.
name|pzFile
operator|=
name|zStdFileArg
expr_stmt|;
name|argTypes
operator|.
name|pzBool
operator|=
name|zStdBoolArg
expr_stmt|;
name|argTypes
operator|.
name|pzNest
operator|=
name|zStdNestArg
expr_stmt|;
name|argTypes
operator|.
name|pzOpt
operator|=
name|zStdOptArg
expr_stmt|;
name|argTypes
operator|.
name|pzNo
operator|=
name|zStdNoArg
expr_stmt|;
name|argTypes
operator|.
name|pzBrk
operator|=
name|zStdBreak
expr_stmt|;
name|argTypes
operator|.
name|pzNoF
operator|=
name|zFiveSpaces
expr_stmt|;
name|argTypes
operator|.
name|pzSpc
operator|=
name|zTwoSpaces
expr_stmt|;
switch|switch
condition|(
name|opts
operator|->
name|fOptSet
operator|&
operator|(
name|OPTPROC_NO_REQ_OPT
operator||
name|OPTPROC_SHORTOPT
operator|)
condition|)
block|{
case|case
operator|(
name|OPTPROC_NO_REQ_OPT
operator||
name|OPTPROC_SHORTOPT
operator|)
case|:
operator|*
name|ptxt
operator|=
name|zNoRq_ShrtTtl
expr_stmt|;
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zNrmOptFmt
expr_stmt|;
name|flen
operator|=
literal|19
expr_stmt|;
break|break;
case|case
name|OPTPROC_NO_REQ_OPT
case|:
operator|*
name|ptxt
operator|=
name|zNoRq_NoShrtTtl
expr_stmt|;
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zNrmOptFmt
expr_stmt|;
name|flen
operator|=
literal|19
expr_stmt|;
break|break;
case|case
name|OPTPROC_SHORTOPT
case|:
operator|*
name|ptxt
operator|=
name|zReq_ShrtTtl
expr_stmt|;
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zReqOptFmt
expr_stmt|;
name|flen
operator|=
literal|24
expr_stmt|;
break|break;
case|case
literal|0
case|:
operator|*
name|ptxt
operator|=
name|zReq_NoShrtTtl
expr_stmt|;
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zReqOptFmt
expr_stmt|;
name|flen
operator|=
literal|24
expr_stmt|;
block|}
return|return
name|flen
return|;
block|}
end_function

begin_comment
comment|/** @}  *  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/usage.c */
end_comment

end_unit

