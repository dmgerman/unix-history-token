begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * \file usage.c  *  * Time-stamp:      "2011-02-01 14:42:37 bkorb"  *  *  This module implements the default usage procedure for  *  Automated Options.  It may be overridden, of course.  *  *  Sort options:     --start=END-[S]TATIC-FORWARD --patt='^/\*($|[^:])' \     --out=xx.c key='^[a-zA-Z0-9_]+\(' --trail='^/\*:' \     --spac=2 --input=usage.c  */
end_comment

begin_comment
comment|/*  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (c) 1992-2011 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following md5sums:  *  *  43b91e8ca915626ed3818ffb1b71248b pkg/libopts/COPYING.gplv3  *  06a1a2e4760c90ea5e1dad8dfaac4d39 pkg/libopts/COPYING.lgplv3  *  66a5cedaf62c4b2637025f049f9b826f pkg/libopts/COPYING.mbsd  */
end_comment

begin_define
define|#
directive|define
name|OPTPROC_L_N_S
value|(OPTPROC_LONGOPT | OPTPROC_SHORTOPT)
end_define

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|void
name|set_usage_flags
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|flg_txt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|ag_bool
name|do_gnu_usage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|ag_bool
name|skip_misuse_usage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_usage_details
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|int
name|exit_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prt_extd_usage
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|arg_types_t
modifier|*
name|pAT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prt_ini_list
parameter_list|(
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|papz
parameter_list|,
name|ag_bool
modifier|*
name|pInitIntro
parameter_list|,
name|char
specifier|const
modifier|*
name|pzRc
parameter_list|,
name|char
specifier|const
modifier|*
name|pzPN
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prt_preamble
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|arg_types_t
modifier|*
name|pAT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prt_one_usage
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|arg_types_t
modifier|*
name|pAT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prt_opt_usage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|int
name|ex_code
parameter_list|,
name|char
specifier|const
modifier|*
name|pOptTitle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prt_prog_detail
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setGnuOptFmts
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tCC
modifier|*
modifier|*
name|ppT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setStdOptFmts
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tCC
modifier|*
modifier|*
name|ppT
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/*  *  NB: no entry may be a prefix of another entry  */
end_comment

begin_define
define|#
directive|define
name|AOFLAG_TABLE
define|\
value|_aof_(gnu,             OPTPROC_GNUUSAGE )   \     _aof_(autoopts,        ~OPTPROC_GNUUSAGE)   \     _aof_(no_misuse_usage, OPTPROC_MISUSE   )   \     _aof_(misuse_usage,    ~OPTPROC_MISUSE  )
end_define

begin_function
specifier|static
name|void
name|set_usage_flags
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|flg_txt
parameter_list|)
block|{
typedef|typedef
struct|struct
block|{
name|size_t
name|fnm_len
decl_stmt|;
name|uint32_t
name|fnm_mask
decl_stmt|;
name|char
specifier|const
modifier|*
name|fnm_name
decl_stmt|;
block|}
name|ao_flag_names_t
typedef|;
define|#
directive|define
name|_aof_
parameter_list|(
name|_n
parameter_list|,
name|_f
parameter_list|)
value|AOUF_ ## _n ## _ID,
typedef|typedef
enum|enum
block|{
name|AOFLAG_TABLE
name|AOUF_COUNT
block|}
name|ao_flag_id_t
typedef|;
undef|#
directive|undef
name|_aof_
define|#
directive|define
name|_aof_
parameter_list|(
name|_n
parameter_list|,
name|_f
parameter_list|)
value|AOUF_ ## _n = (1<< AOUF_ ## _n ## _ID),
typedef|typedef
enum|enum
block|{
name|AOFLAG_TABLE
block|}
name|ao_flags_t
typedef|;
undef|#
directive|undef
name|_aof_
define|#
directive|define
name|_aof_
parameter_list|(
name|_n
parameter_list|,
name|_f
parameter_list|)
value|{ sizeof(#_n)-1, _f, #_n },
specifier|static
name|ao_flag_names_t
specifier|const
name|fn_table
index|[
name|AOUF_COUNT
index|]
init|=
block|{
name|AOFLAG_TABLE
block|}
decl_stmt|;
undef|#
directive|undef
name|_aof_
name|ao_flags_t
name|flg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flg_txt
operator|==
name|NULL
condition|)
block|{
name|flg_txt
operator|=
name|getenv
argument_list|(
literal|"AUTOOPTS_USAGE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flg_txt
operator|==
name|NULL
condition|)
return|return;
block|}
while|while
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
name|flg_txt
argument_list|)
condition|)
name|flg_txt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|flg_txt
operator|==
name|NUL
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ix
init|=
literal|0
decl_stmt|;
name|ao_flag_names_t
specifier|const
modifier|*
name|fnt
init|=
name|fn_table
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|strneqvcmp
argument_list|(
name|flg_txt
argument_list|,
name|fnt
operator|->
name|fnm_name
argument_list|,
name|fnt
operator|->
name|fnm_len
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|++
name|ix
operator|>=
name|AOUF_COUNT
condition|)
return|return;
name|fnt
operator|++
expr_stmt|;
block|}
comment|/*          *  Make sure we have a full match.  Look for whitespace,          *  a comma, or a NUL byte.          */
if|if
condition|(
operator|!
name|IS_END_LIST_ENTRY_CHAR
argument_list|(
name|flg_txt
index|[
name|fnt
operator|->
name|fnm_len
index|]
argument_list|)
condition|)
return|return;
name|flg
operator||=
literal|1
operator|<<
name|ix
expr_stmt|;
name|flg_txt
operator|+=
name|fnt
operator|->
name|fnm_len
expr_stmt|;
while|while
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
name|flg_txt
argument_list|)
condition|)
name|flg_txt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|flg_txt
operator|==
name|NUL
condition|)
break|break;
if|if
condition|(
operator|*
name|flg_txt
operator|==
literal|','
condition|)
block|{
comment|/*              *  skip the comma and following white space              */
while|while
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
operator|++
name|flg_txt
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|flg_txt
operator|==
name|NUL
condition|)
break|break;
block|}
block|}
block|{
name|ao_flag_names_t
specifier|const
modifier|*
name|fnm
init|=
name|fn_table
decl_stmt|;
while|while
condition|(
name|flg
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|flg
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|fnm
operator|->
name|fnm_mask
operator|&
name|OPTPROC_LONGOPT
operator|)
operator|!=
literal|0
condition|)
name|opts
operator|->
name|fOptSet
operator|&=
name|fnm
operator|->
name|fnm_mask
expr_stmt|;
else|else
name|opts
operator|->
name|fOptSet
operator||=
name|fnm
operator|->
name|fnm_mask
expr_stmt|;
block|}
name|flg
operator|>>=
literal|1
expr_stmt|;
name|fnm
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *  Figure out if we should try to format usage text sort-of like  *  the way many GNU programs do.  */
end_comment

begin_function
specifier|static
specifier|inline
name|ag_bool
name|do_gnu_usage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
return|return
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_GNUUSAGE
operator|)
condition|?
name|AG_TRUE
else|:
name|AG_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  *  Figure out if we should try to format usage text sort-of like  *  the way many GNU programs do.  */
end_comment

begin_function
specifier|static
specifier|inline
name|ag_bool
name|skip_misuse_usage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
return|return
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_MISUSE
operator|)
condition|?
name|AG_TRUE
else|:
name|AG_FALSE
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionOnlyUsage  *  * what:  Print usage text for just the options  * arg:   + tOptions*   + pOpts    + program options descriptor +  * arg:   + int         + ex_code  + exit code for calling exit(3) +  *  * doc:  *  This routine will print only the usage for each option.  *  This function may be used when the emitted usage must incorporate  *  information not available to AutoOpts. =*/
end_comment

begin_function
name|void
name|optionOnlyUsage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|int
name|ex_code
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|pOptTitle
init|=
name|NULL
decl_stmt|;
name|set_usage_flags
argument_list|(
name|pOpts
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ex_code
operator|!=
name|EXIT_SUCCESS
operator|)
operator|&&
name|skip_misuse_usage
argument_list|(
name|pOpts
argument_list|)
condition|)
return|return;
comment|/*      *  Determine which header and which option formatting strings to use      */
if|if
condition|(
name|do_gnu_usage
argument_list|(
name|pOpts
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|setGnuOptFmts
argument_list|(
name|pOpts
argument_list|,
operator|&
name|pOptTitle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|setStdOptFmts
argument_list|(
name|pOpts
argument_list|,
operator|&
name|pOptTitle
argument_list|)
expr_stmt|;
block|}
name|prt_opt_usage
argument_list|(
name|pOpts
argument_list|,
name|ex_code
argument_list|,
name|pOptTitle
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|option_usage_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|option_usage_fp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|zOutputFail
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_usage_details
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|int
name|exit_code
parameter_list|)
block|{
block|{
name|char
specifier|const
modifier|*
name|pOptTitle
init|=
name|NULL
decl_stmt|;
comment|/*          *  Determine which header and which option formatting strings to use          */
if|if
condition|(
name|do_gnu_usage
argument_list|(
name|opts
argument_list|)
condition|)
block|{
name|int
name|flen
init|=
name|setGnuOptFmts
argument_list|(
name|opts
argument_list|,
operator|&
name|pOptTitle
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|zOptFmtLine
argument_list|,
name|zFmtFmt
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|flen
init|=
name|setStdOptFmts
argument_list|(
name|opts
argument_list|,
operator|&
name|pOptTitle
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|zOptFmtLine
argument_list|,
name|zFmtFmt
argument_list|,
name|flen
argument_list|)
expr_stmt|;
comment|/*              *  When we exit with EXIT_SUCCESS and the first option is a doc              *  option, we do *NOT* want to emit the column headers.              *  Otherwise, we do.              */
if|if
condition|(
operator|(
name|exit_code
operator|!=
name|EXIT_SUCCESS
operator|)
operator|||
operator|(
operator|(
name|opts
operator|->
name|pOptDesc
operator|->
name|fOptState
operator|&
name|OPTST_DOCUMENT
operator|)
operator|==
literal|0
operator|)
condition|)
name|fputs
argument_list|(
name|pOptTitle
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
name|prt_opt_usage
argument_list|(
name|opts
argument_list|,
name|exit_code
argument_list|,
name|pOptTitle
argument_list|)
expr_stmt|;
block|}
comment|/*      *  Describe the mechanics of denoting the options      */
switch|switch
condition|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_L_N_S
condition|)
block|{
case|case
name|OPTPROC_L_N_S
case|:
name|fputs
argument_list|(
name|zFlagOkay
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTPROC_SHORTOPT
case|:
break|break;
case|case
name|OPTPROC_LONGOPT
case|:
name|fputs
argument_list|(
name|zNoFlags
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|fputs
argument_list|(
name|zOptsOnly
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_NUM_OPT
operator|)
operator|!=
literal|0
condition|)
name|fputs
argument_list|(
name|zNumberOpt
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_REORDER
operator|)
operator|!=
literal|0
condition|)
name|fputs
argument_list|(
name|zReorder
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|pzExplain
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|opts
operator|->
name|pzExplain
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*      *  IF the user is asking for help (thus exiting with SUCCESS),      *  THEN see what additional information we can provide.      */
if|if
condition|(
name|exit_code
operator|==
name|EXIT_SUCCESS
condition|)
name|prt_prog_detail
argument_list|(
name|opts
argument_list|)
expr_stmt|;
comment|/*      * Give bug notification preference to the packager information      */
if|if
condition|(
name|HAS_pzPkgDataDir
argument_list|(
name|opts
argument_list|)
operator|&&
operator|(
name|opts
operator|->
name|pzPackager
operator|!=
name|NULL
operator|)
condition|)
name|fputs
argument_list|(
name|opts
operator|->
name|pzPackager
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opts
operator|->
name|pzBugAddr
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zPlsSendBugs
argument_list|,
name|opts
operator|->
name|pzBugAddr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|option_usage_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|option_usage_fp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|zOutputFail
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*=export_func  optionUsage  * private:  *  * what:  Print usage text  * arg:   + tOptions* + pOptions + program options descriptor +  * arg:   + int       + exitCode + exit code for calling exit(3) +  *  * doc:  *  This routine will print usage in both GNU-standard and AutoOpts-expanded  *  formats.  The descriptor specifies the default, but AUTOOPTS_USAGE will  *  over-ride this, providing the value of it is set to either "gnu" or  *  "autoopts".  This routine will @strong{not} return.  *  *  If "exitCode" is "EX_USAGE" (normally 64), then output will to to stdout  *  and the actual exit code will be "EXIT_SUCCESS". =*/
end_comment

begin_function
name|void
name|optionUsage
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|,
name|int
name|usage_exit_code
parameter_list|)
block|{
name|int
name|exit_code
init|=
operator|(
name|usage_exit_code
operator|==
name|EX_USAGE
operator|)
condition|?
name|EXIT_SUCCESS
else|:
name|usage_exit_code
decl_stmt|;
name|displayEnum
operator|=
name|AG_FALSE
expr_stmt|;
comment|/*      *  Paged usage will preset option_usage_fp to an output file.      *  If it hasn't already been set, then set it to standard output      *  on successful exit (help was requested), otherwise error out.      *      *  Test the version before obtaining pzFullUsage or pzShortUsage.      *  These fields do not exist before revision 30.      */
block|{
name|char
specifier|const
modifier|*
name|pz
decl_stmt|;
if|if
condition|(
name|exit_code
operator|==
name|EXIT_SUCCESS
condition|)
block|{
name|pz
operator|=
operator|(
name|pOptions
operator|->
name|structVersion
operator|>=
literal|30
operator|*
literal|4096
operator|)
condition|?
name|pOptions
operator|->
name|pzFullUsage
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|option_usage_fp
operator|==
name|NULL
condition|)
name|option_usage_fp
operator|=
name|stdout
expr_stmt|;
block|}
else|else
block|{
name|pz
operator|=
operator|(
name|pOptions
operator|->
name|structVersion
operator|>=
literal|30
operator|*
literal|4096
operator|)
condition|?
name|pOptions
operator|->
name|pzShortUsage
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|option_usage_fp
operator|==
name|NULL
condition|)
name|option_usage_fp
operator|=
name|stderr
expr_stmt|;
block|}
if|if
condition|(
name|pz
operator|!=
name|NULL
condition|)
block|{
name|fputs
argument_list|(
name|pz
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_code
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|pOptions
operator|->
name|pzUsageTitle
argument_list|,
name|pOptions
operator|->
name|pzProgName
argument_list|)
expr_stmt|;
name|set_usage_flags
argument_list|(
name|pOptions
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|exit_code
operator|==
name|EXIT_SUCCESS
operator|)
operator|||
operator|(
operator|!
name|skip_misuse_usage
argument_list|(
name|pOptions
argument_list|)
operator|)
condition|)
name|print_usage_details
argument_list|(
name|pOptions
argument_list|,
name|usage_exit_code
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *   PER OPTION TYPE USAGE INFORMATION  */
end_comment

begin_function
specifier|static
name|void
name|prt_extd_usage
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|arg_types_t
modifier|*
name|pAT
parameter_list|)
block|{
comment|/*      *  IF there are option conflicts or dependencies,      *  THEN print them here.      */
if|if
condition|(
operator|(
name|pOD
operator|->
name|pOptMust
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|pOD
operator|->
name|pOptCant
operator|!=
name|NULL
operator|)
condition|)
block|{
name|fputs
argument_list|(
name|zTabHyp
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*          *  DEPENDENCIES:          */
if|if
condition|(
name|pOD
operator|->
name|pOptMust
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|int
modifier|*
name|pOptNo
init|=
name|pOD
operator|->
name|pOptMust
decl_stmt|;
name|fputs
argument_list|(
name|zReqThese
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zTabout
argument_list|,
name|pOptions
operator|->
name|pOptDesc
index|[
operator|*
name|pOptNo
index|]
operator|.
name|pz_Name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|pOptNo
operator|==
name|NO_EQUIVALENT
condition|)
break|break;
block|}
if|if
condition|(
name|pOD
operator|->
name|pOptCant
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|zTabHypAnd
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
comment|/*          *  CONFLICTS:          */
if|if
condition|(
name|pOD
operator|->
name|pOptCant
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|int
modifier|*
name|pOptNo
init|=
name|pOD
operator|->
name|pOptCant
decl_stmt|;
name|fputs
argument_list|(
name|zProhib
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zTabout
argument_list|,
name|pOptions
operator|->
name|pOptDesc
index|[
operator|*
name|pOptNo
index|]
operator|.
name|pz_Name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|pOptNo
operator|==
name|NO_EQUIVALENT
condition|)
break|break;
block|}
block|}
block|}
comment|/*      *  IF there is a disablement string      *  THEN print the disablement info      */
if|if
condition|(
name|pOD
operator|->
name|pz_DisableName
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zDis
argument_list|,
name|pOD
operator|->
name|pz_DisableName
argument_list|)
expr_stmt|;
comment|/*      *  Check for argument types that have callbacks with magical properties      */
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_NUMERIC
case|:
comment|/*          *  IF the numeric option has a special callback,          *  THEN call it, requesting the range or other special info          */
if|if
condition|(
operator|(
name|pOD
operator|->
name|pOptProc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pOD
operator|->
name|pOptProc
operator|!=
name|optionNumericVal
operator|)
condition|)
block|{
operator|(
operator|*
operator|(
name|pOD
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|OPTPROC_EMIT_USAGE
operator|,
name|pOD
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|OPARG_TYPE_FILE
case|:
operator|(
operator|*
operator|(
name|pOD
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|OPTPROC_EMIT_USAGE
operator|,
name|pOD
operator|)
expr_stmt|;
break|break;
block|}
comment|/*      *  IF the option defaults to being enabled,      *  THEN print that out      */
if|if
condition|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_INITENABLED
condition|)
name|fputs
argument_list|(
name|zEnab
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*      *  IF  the option is in an equivalence class      *        AND not the designated lead      *  THEN print equivalence and leave it at that.      */
if|if
condition|(
operator|(
name|pOD
operator|->
name|optEquivIndex
operator|!=
name|NO_EQUIVALENT
operator|)
operator|&&
operator|(
name|pOD
operator|->
name|optEquivIndex
operator|!=
name|pOD
operator|->
name|optActualIndex
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zAlt
argument_list|,
name|pOptions
operator|->
name|pOptDesc
index|[
name|pOD
operator|->
name|optEquivIndex
index|]
operator|.
name|pz_Name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      *  IF this particular option can NOT be preset      *    AND some form of presetting IS allowed,      *    AND it is not an auto-managed option (e.g. --help, et al.)      *  THEN advise that this option may not be preset.      */
if|if
condition|(
operator|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_NO_INIT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|pOptions
operator|->
name|papzHomeList
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|pOptions
operator|->
name|pzPROGNAME
operator|!=
name|NULL
operator|)
operator|)
operator|&&
operator|(
name|pOD
operator|->
name|optIndex
operator|<
name|pOptions
operator|->
name|presetOptCt
operator|)
condition|)
name|fputs
argument_list|(
name|zNoPreset
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*      *  Print the appearance requirements.      */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_MEMBERSHIP
condition|)
name|fputs
argument_list|(
name|zMembers
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|pOD
operator|->
name|optMinCt
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|0
case|:
switch|switch
condition|(
name|pOD
operator|->
name|optMaxCt
condition|)
block|{
case|case
literal|0
case|:
name|fputs
argument_list|(
name|zPreset
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOLIMIT
case|:
name|fputs
argument_list|(
name|zNoLim
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
break|break;
comment|/*              * IF the max is more than one but limited, print "UP TO" message              */
default|default:
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zUpTo
argument_list|,
name|pOD
operator|->
name|optMaxCt
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
comment|/*          *  More than one is required.  Print the range.          */
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zMust
argument_list|,
name|pOD
operator|->
name|optMinCt
argument_list|,
name|pOD
operator|->
name|optMaxCt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NAMED_OPTS
argument_list|(
name|pOptions
argument_list|)
operator|&&
operator|(
name|pOptions
operator|->
name|specOptIdx
operator|.
name|default_opt
operator|==
name|pOD
operator|->
name|optIndex
operator|)
condition|)
name|fputs
argument_list|(
name|zDefaultOpt
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *   Figure out where all the initialization files might live.  *   This requires translating some environment variables and  *   testing to see if a name is a directory or a file.  It's  *   squishy, but important to tell users how to find these files.  */
end_comment

begin_function
specifier|static
name|void
name|prt_ini_list
parameter_list|(
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|papz
parameter_list|,
name|ag_bool
modifier|*
name|pInitIntro
parameter_list|,
name|char
specifier|const
modifier|*
name|pzRc
parameter_list|,
name|char
specifier|const
modifier|*
name|pzPN
parameter_list|)
block|{
name|char
name|zPath
index|[
name|AG_PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|papz
operator|==
name|NULL
condition|)
return|return;
name|fputs
argument_list|(
name|zPresetIntro
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
operator|*
name|pInitIntro
operator|=
name|AG_FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
specifier|const
modifier|*
name|pzPath
init|=
operator|*
operator|(
name|papz
operator|++
operator|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|pzReal
init|=
name|zPath
decl_stmt|;
if|if
condition|(
name|pzPath
operator|==
name|NULL
condition|)
break|break;
comment|/*          * Ignore any invalid paths          */
if|if
condition|(
operator|!
name|optionMakePath
argument_list|(
name|zPath
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|zPath
argument_list|)
argument_list|,
name|pzPath
argument_list|,
name|pzPN
argument_list|)
condition|)
name|pzReal
operator|=
name|pzPath
expr_stmt|;
comment|/*          * Expand paths that are relative to the executable or installation          * directories.  Leave alone paths that use environment variables.          */
elseif|else
if|if
condition|(
operator|(
operator|*
name|pzPath
operator|==
literal|'$'
operator|)
operator|&&
operator|(
operator|(
name|pzPath
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|||
operator|(
name|pzPath
index|[
literal|1
index|]
operator|==
literal|'@'
operator|)
operator|)
condition|)
name|pzPath
operator|=
name|pzReal
expr_stmt|;
comment|/*          *  Print the name of the "homerc" file.  If the "rcfile" name is          *  not empty, we may or may not print that, too...          */
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zPathFmt
argument_list|,
name|pzPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pzRc
operator|!=
name|NUL
condition|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
comment|/*              *  IF the "homerc" file is a directory,              *  then append the "rcfile" name.              */
if|if
condition|(
operator|(
name|stat
argument_list|(
name|pzReal
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|fputc
argument_list|(
name|DIRCH
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|pzRc
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|prt_preamble
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|arg_types_t
modifier|*
name|pAT
parameter_list|)
block|{
comment|/*      *  Flag prefix: IF no flags at all, then omit it.  If not printable      *  (not allowed for this option), then blank, else print it.      *  Follow it with a comma if we are doing GNU usage and long      *  opts are to be printed too.      */
if|if
condition|(
operator|(
name|pOptions
operator|->
name|fOptSet
operator|&
name|OPTPROC_SHORTOPT
operator|)
operator|==
literal|0
condition|)
name|fputs
argument_list|(
name|pAT
operator|->
name|pzSpc
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_GRAPHIC_CHAR
argument_list|(
name|pOD
operator|->
name|optValue
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pOptions
operator|->
name|fOptSet
operator|&
operator|(
name|OPTPROC_GNUUSAGE
operator||
name|OPTPROC_LONGOPT
operator|)
operator|)
operator|==
operator|(
name|OPTPROC_GNUUSAGE
operator||
name|OPTPROC_LONGOPT
operator|)
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|pAT
operator|->
name|pzNoF
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
literal|"   -%c"
argument_list|,
name|pOD
operator|->
name|optValue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pOptions
operator|->
name|fOptSet
operator|&
operator|(
name|OPTPROC_GNUUSAGE
operator||
name|OPTPROC_LONGOPT
operator|)
operator|)
operator|==
operator|(
name|OPTPROC_GNUUSAGE
operator||
name|OPTPROC_LONGOPT
operator|)
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  Print the usage information for a single option.  */
end_comment

begin_function
specifier|static
name|void
name|prt_one_usage
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|arg_types_t
modifier|*
name|pAT
parameter_list|)
block|{
name|prt_preamble
argument_list|(
name|pOptions
argument_list|,
name|pOD
argument_list|,
name|pAT
argument_list|)
expr_stmt|;
block|{
name|char
name|z
index|[
literal|80
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|pzArgType
decl_stmt|;
comment|/*          *  Determine the argument type string first on its usage, then,          *  when the option argument is required, base the type string on the          *  argument type.          */
if|if
condition|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ARG_OPTIONAL
condition|)
block|{
name|pzArgType
operator|=
name|pAT
operator|->
name|pzOpt
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_NONE
case|:
name|pzArgType
operator|=
name|pAT
operator|->
name|pzNo
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_ENUMERATION
case|:
name|pzArgType
operator|=
name|pAT
operator|->
name|pzKey
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_FILE
case|:
name|pzArgType
operator|=
name|pAT
operator|->
name|pzFile
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_MEMBERSHIP
case|:
name|pzArgType
operator|=
name|pAT
operator|->
name|pzKeyL
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_BOOLEAN
case|:
name|pzArgType
operator|=
name|pAT
operator|->
name|pzBool
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_NUMERIC
case|:
name|pzArgType
operator|=
name|pAT
operator|->
name|pzNum
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_HIERARCHY
case|:
name|pzArgType
operator|=
name|pAT
operator|->
name|pzNest
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_STRING
case|:
name|pzArgType
operator|=
name|pAT
operator|->
name|pzStr
expr_stmt|;
break|break;
case|case
name|OPARG_TYPE_TIME
case|:
name|pzArgType
operator|=
name|pAT
operator|->
name|pzTime
expr_stmt|;
break|break;
default|default:
goto|goto
name|bogus_desc
goto|;
block|}
name|snprintf
argument_list|(
name|z
argument_list|,
sizeof|sizeof
argument_list|(
name|z
argument_list|)
argument_list|,
name|pAT
operator|->
name|pzOptFmt
argument_list|,
name|pzArgType
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
operator|(
name|pOD
operator|->
name|optMinCt
operator|!=
literal|0
operator|)
condition|?
name|pAT
operator|->
name|pzReq
else|:
name|pAT
operator|->
name|pzOpt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zOptFmtLine
argument_list|,
name|z
argument_list|,
name|pOD
operator|->
name|pzText
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_ENUMERATION
case|:
case|case
name|OPARG_TYPE_MEMBERSHIP
case|:
name|displayEnum
operator|=
operator|(
name|pOD
operator|->
name|pOptProc
operator|!=
name|NULL
operator|)
condition|?
name|AG_TRUE
else|:
name|displayEnum
expr_stmt|;
block|}
block|}
return|return;
name|bogus_desc
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zInvalOptDesc
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Print out the usage information for just the options.  */
end_comment

begin_function
specifier|static
name|void
name|prt_opt_usage
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|int
name|ex_code
parameter_list|,
name|char
specifier|const
modifier|*
name|pOptTitle
parameter_list|)
block|{
name|int
name|ct
init|=
name|pOpts
operator|->
name|optCt
decl_stmt|;
name|int
name|optNo
init|=
literal|0
decl_stmt|;
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|docCt
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_NO_USAGE_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/*              * IF      this is a compiled-out option              *   *AND* usage was requested with "omitted-usage"              *   *AND* this is NOT abbreviated usage              * THEN display this option.              */
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|==
operator|(
name|OPTST_OMITTED
operator||
name|OPTST_NO_INIT
operator|)
operator|)
operator|&&
operator|(
name|pOD
operator|->
name|pz_Name
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ex_code
operator|==
name|EXIT_SUCCESS
operator|)
condition|)
block|{
name|char
specifier|const
modifier|*
name|why_pz
init|=
operator|(
name|pOD
operator|->
name|pzText
operator|==
name|NULL
operator|)
condition|?
name|zDisabledWhy
else|:
name|pOD
operator|->
name|pzText
decl_stmt|;
name|prt_preamble
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
operator|&
name|argTypes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zDisabledOpt
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
name|why_pz
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_DOCUMENT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ex_code
operator|==
name|EXIT_SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|argTypes
operator|.
name|pzBrk
argument_list|,
name|pOD
operator|->
name|pzText
argument_list|,
name|pOptTitle
argument_list|)
expr_stmt|;
name|docCt
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
comment|/*          *  IF       this is the first auto-opt maintained option          *    *AND*  we are doing a full help          *    *AND*  there are documentation options          *    *AND*  the last one was not a doc option,          *  THEN document that the remaining options are not user opts          */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|presetOptCt
operator|==
name|optNo
operator|)
operator|&&
operator|(
name|ex_code
operator|==
name|EXIT_SUCCESS
operator|)
operator|&&
operator|(
name|docCt
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|pOD
index|[
operator|-
literal|1
index|]
operator|.
name|fOptState
operator|&
name|OPTST_DOCUMENT
operator|)
operator|==
literal|0
operator|)
condition|)
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|argTypes
operator|.
name|pzBrk
argument_list|,
name|zAuto
argument_list|,
name|pOptTitle
argument_list|)
expr_stmt|;
name|prt_one_usage
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
operator|&
name|argTypes
argument_list|)
expr_stmt|;
comment|/*          *  IF we were invoked because of the --help option,          *  THEN print all the extra info          */
if|if
condition|(
name|ex_code
operator|==
name|EXIT_SUCCESS
condition|)
name|prt_extd_usage
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
operator|&
name|argTypes
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pOD
operator|++
operator|,
name|optNo
operator|++
operator|,
operator|(
operator|--
name|ct
operator|>
literal|0
operator|)
condition|)
do|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *   PROGRAM DETAILS  */
end_comment

begin_function
specifier|static
name|void
name|prt_prog_detail
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|)
block|{
name|ag_bool
name|initIntro
init|=
name|AG_TRUE
decl_stmt|;
comment|/*      *  Display all the places we look for config files      */
name|prt_ini_list
argument_list|(
name|pOptions
operator|->
name|papzHomeList
argument_list|,
operator|&
name|initIntro
argument_list|,
name|pOptions
operator|->
name|pzRcName
argument_list|,
name|pOptions
operator|->
name|pzProgPath
argument_list|)
expr_stmt|;
comment|/*      *  Let the user know about environment variable settings      */
if|if
condition|(
operator|(
name|pOptions
operator|->
name|fOptSet
operator|&
name|OPTPROC_ENVIRON
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|initIntro
condition|)
name|fputs
argument_list|(
name|zPresetIntro
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zExamineFmt
argument_list|,
name|pOptions
operator|->
name|pzPROGNAME
argument_list|)
expr_stmt|;
block|}
comment|/*      *  IF we found an enumeration,      *  THEN hunt for it again.  Call the handler proc with a NULL      *       option struct pointer.  That tells it to display the keywords.      */
if|if
condition|(
name|displayEnum
condition|)
block|{
name|int
name|ct
init|=
name|pOptions
operator|->
name|optCt
decl_stmt|;
name|int
name|optNo
init|=
literal|0
decl_stmt|;
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOptions
operator|->
name|pOptDesc
decl_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|option_usage_fp
argument_list|)
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_ENUMERATION
case|:
case|case
name|OPARG_TYPE_MEMBERSHIP
case|:
operator|(
operator|*
operator|(
name|pOD
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|OPTPROC_EMIT_USAGE
operator|,
name|pOD
operator|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|pOD
operator|++
operator|,
name|optNo
operator|++
operator|,
operator|(
operator|--
name|ct
operator|>
literal|0
operator|)
condition|)
do|;
block|}
comment|/*      *  If there is a detail string, now is the time for that.      */
if|if
condition|(
name|pOptions
operator|->
name|pzDetail
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|pOptions
operator|->
name|pzDetail
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *   OPTION LINE FORMATTING SETUP  *  *  The "OptFmt" formats receive three arguments:  *  1.  the type of the option's argument  *  2.  the long name of the option  *  3.  "YES" or "no ", depending on whether or not the option must appear  *      on the command line.  *  These formats are used immediately after the option flag (if used) has  *  been printed.  *  *  Set up the formatting for GNU-style output  */
end_comment

begin_function
specifier|static
name|int
name|setGnuOptFmts
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tCC
modifier|*
modifier|*
name|ppT
parameter_list|)
block|{
name|int
name|flen
init|=
literal|22
decl_stmt|;
operator|*
name|ppT
operator|=
name|zNoRq_ShrtTtl
expr_stmt|;
name|argTypes
operator|.
name|pzStr
operator|=
name|zGnuStrArg
expr_stmt|;
name|argTypes
operator|.
name|pzReq
operator|=
name|zOneSpace
expr_stmt|;
name|argTypes
operator|.
name|pzNum
operator|=
name|zGnuNumArg
expr_stmt|;
name|argTypes
operator|.
name|pzKey
operator|=
name|zGnuKeyArg
expr_stmt|;
name|argTypes
operator|.
name|pzKeyL
operator|=
name|zGnuKeyLArg
expr_stmt|;
name|argTypes
operator|.
name|pzTime
operator|=
name|zGnuTimeArg
expr_stmt|;
name|argTypes
operator|.
name|pzFile
operator|=
name|zGnuFileArg
expr_stmt|;
name|argTypes
operator|.
name|pzBool
operator|=
name|zGnuBoolArg
expr_stmt|;
name|argTypes
operator|.
name|pzNest
operator|=
name|zGnuNestArg
expr_stmt|;
name|argTypes
operator|.
name|pzOpt
operator|=
name|zGnuOptArg
expr_stmt|;
name|argTypes
operator|.
name|pzNo
operator|=
name|zOneSpace
expr_stmt|;
name|argTypes
operator|.
name|pzBrk
operator|=
name|zGnuBreak
expr_stmt|;
name|argTypes
operator|.
name|pzNoF
operator|=
name|zSixSpaces
expr_stmt|;
name|argTypes
operator|.
name|pzSpc
operator|=
name|zThreeSpaces
expr_stmt|;
switch|switch
condition|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_L_N_S
condition|)
block|{
case|case
name|OPTPROC_L_N_S
case|:
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zGnuOptFmt
expr_stmt|;
break|break;
case|case
name|OPTPROC_LONGOPT
case|:
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zGnuOptFmt
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zGnuOptFmt
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|OPTPROC_SHORTOPT
case|:
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zShrtGnuOptFmt
expr_stmt|;
name|zGnuStrArg
index|[
literal|0
index|]
operator|=
name|zGnuNumArg
index|[
literal|0
index|]
operator|=
name|zGnuKeyArg
index|[
literal|0
index|]
operator|=
name|zGnuBoolArg
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|argTypes
operator|.
name|pzOpt
operator|=
literal|" [arg]"
expr_stmt|;
name|flen
operator|=
literal|8
expr_stmt|;
break|break;
block|}
return|return
name|flen
return|;
block|}
end_function

begin_comment
comment|/*  *  Standard (AutoOpts normal) option line formatting  */
end_comment

begin_function
specifier|static
name|int
name|setStdOptFmts
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tCC
modifier|*
modifier|*
name|ppT
parameter_list|)
block|{
name|int
name|flen
init|=
literal|0
decl_stmt|;
name|argTypes
operator|.
name|pzStr
operator|=
name|zStdStrArg
expr_stmt|;
name|argTypes
operator|.
name|pzReq
operator|=
name|zStdReqArg
expr_stmt|;
name|argTypes
operator|.
name|pzNum
operator|=
name|zStdNumArg
expr_stmt|;
name|argTypes
operator|.
name|pzKey
operator|=
name|zStdKeyArg
expr_stmt|;
name|argTypes
operator|.
name|pzKeyL
operator|=
name|zStdKeyLArg
expr_stmt|;
name|argTypes
operator|.
name|pzTime
operator|=
name|zStdTimeArg
expr_stmt|;
name|argTypes
operator|.
name|pzFile
operator|=
name|zStdFileArg
expr_stmt|;
name|argTypes
operator|.
name|pzBool
operator|=
name|zStdBoolArg
expr_stmt|;
name|argTypes
operator|.
name|pzNest
operator|=
name|zStdNestArg
expr_stmt|;
name|argTypes
operator|.
name|pzOpt
operator|=
name|zStdOptArg
expr_stmt|;
name|argTypes
operator|.
name|pzNo
operator|=
name|zStdNoArg
expr_stmt|;
name|argTypes
operator|.
name|pzBrk
operator|=
name|zStdBreak
expr_stmt|;
name|argTypes
operator|.
name|pzNoF
operator|=
name|zFiveSpaces
expr_stmt|;
name|argTypes
operator|.
name|pzSpc
operator|=
name|zTwoSpaces
expr_stmt|;
switch|switch
condition|(
name|pOpts
operator|->
name|fOptSet
operator|&
operator|(
name|OPTPROC_NO_REQ_OPT
operator||
name|OPTPROC_SHORTOPT
operator|)
condition|)
block|{
case|case
operator|(
name|OPTPROC_NO_REQ_OPT
operator||
name|OPTPROC_SHORTOPT
operator|)
case|:
operator|*
name|ppT
operator|=
name|zNoRq_ShrtTtl
expr_stmt|;
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zNrmOptFmt
expr_stmt|;
name|flen
operator|=
literal|19
expr_stmt|;
break|break;
case|case
name|OPTPROC_NO_REQ_OPT
case|:
operator|*
name|ppT
operator|=
name|zNoRq_NoShrtTtl
expr_stmt|;
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zNrmOptFmt
expr_stmt|;
name|flen
operator|=
literal|19
expr_stmt|;
break|break;
case|case
name|OPTPROC_SHORTOPT
case|:
operator|*
name|ppT
operator|=
name|zReq_ShrtTtl
expr_stmt|;
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zReqOptFmt
expr_stmt|;
name|flen
operator|=
literal|24
expr_stmt|;
break|break;
case|case
literal|0
case|:
operator|*
name|ppT
operator|=
name|zReq_NoShrtTtl
expr_stmt|;
name|argTypes
operator|.
name|pzOptFmt
operator|=
name|zReqOptFmt
expr_stmt|;
name|flen
operator|=
literal|24
expr_stmt|;
block|}
return|return
name|flen
return|;
block|}
end_function

begin_comment
comment|/*:  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/usage.c */
end_comment

end_unit

