begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file text_mmap.c  *  * Time-stamp:      "2010-07-17 10:15:32 bkorb"  *  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (c) 1992-2011 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following md5sums:  *  *  43b91e8ca915626ed3818ffb1b71248b pkg/libopts/COPYING.gplv3  *  06a1a2e4760c90ea5e1dad8dfaac4d39 pkg/libopts/COPYING.lgplv3  *  66a5cedaf62c4b2637025f049f9b826f pkg/libopts/COPYING.mbsd  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_ANONYMOUS
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|MAP_ANON
end_ifdef

begin_define
define|#
directive|define
name|MAP_ANONYMOUS
value|MAP_ANON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Some weird systems require that a specifically invalid FD number  *  get passed in as an argument value.  Which value is that?  Well,  *  as everybody knows, if open(2) fails, it returns -1, so that must  *  be the value.  :)  */
end_comment

begin_define
define|#
directive|define
name|AO_INVALID_FD
value|-1
end_define

begin_define
define|#
directive|define
name|FILE_WRITABLE
parameter_list|(
name|_prt
parameter_list|,
name|_flg
parameter_list|)
define|\
value|(   (_prt& PROT_WRITE) \&& ((_flg& (MAP_SHARED|MAP_PRIVATE)) == MAP_SHARED))
end_define

begin_define
define|#
directive|define
name|MAP_FAILED_PTR
value|((void*)MAP_FAILED)
end_define

begin_comment
comment|/*=export_func  text_mmap  * private:  *  * what:  map a text file with terminating NUL  *  * arg:   char const*,  pzFile,  name of the file to map  * arg:   int,          prot,    mmap protections (see mmap(2))  * arg:   int,          flags,   mmap flags (see mmap(2))  * arg:   tmap_info_t*, mapinfo, returned info about the mapping  *  * ret-type:   void*  * ret-desc:   The mmaped data address  *  * doc:  *  * This routine will mmap a file into memory ensuring that there is at least  * one @file{NUL} character following the file data.  It will return the  * address where the file contents have been mapped into memory.  If there is a  * problem, then it will return @code{MAP_FAILED} and set @file{errno}  * appropriately.  *  * The named file does not exist, @code{stat(2)} will set @file{errno} as it  * will.  If the file is not a regular file, @file{errno} will be  * @code{EINVAL}.  At that point, @code{open(2)} is attempted with the access  * bits set appropriately for the requested @code{mmap(2)} protections and flag  * bits.  On failure, @file{errno} will be set according to the documentation  * for @code{open(2)}.  If @code{mmap(2)} fails, @file{errno} will be set as  * that routine sets it.  If @code{text_mmap} works to this point, a valid  * address will be returned, but there may still be ``issues''.  *  * If the file size is not an even multiple of the system page size, then  * @code{text_map} will return at this point and @file{errno} will be zero.  * Otherwise, an anonymous map is attempted.  If not available, then an attempt  * is made to @code{mmap(2)} @file{/dev/zero}.  If any of these fail, the  * address of the file's data is returned, bug @code{no} @file{NUL} characters  * are mapped after the end of the data.  *  * see: mmap(2), open(2), stat(2)  *  * err: Any error code issued by mmap(2), open(2), stat(2) is possible.  *      Additionally, if the specified file is not a regular file, then  *      errno will be set to @code{EINVAL}.  *  * example:  * #include<mylib.h>  * tmap_info_t mi;  * int no_nul;  * void* data = text_mmap("file", PROT_WRITE, MAP_PRIVATE,&mi);  * if (data == MAP_FAILED) return;  * no_nul = (mi.txt_size == mi.txt_full_size);  *<< use the data>>  * text_munmap(&mi); =*/
end_comment

begin_function
name|void
modifier|*
name|text_mmap
parameter_list|(
name|char
specifier|const
modifier|*
name|pzFile
parameter_list|,
name|int
name|prot
parameter_list|,
name|int
name|flags
parameter_list|,
name|tmap_info_t
modifier|*
name|pMI
parameter_list|)
block|{
name|memset
argument_list|(
name|pMI
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pMI
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MMAP
name|pMI
operator|->
name|txt_zero_fd
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|pMI
operator|->
name|txt_fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*      *  Make sure we can stat the regular file.  Save the file size.      */
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|pzFile
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pMI
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
return|return
name|MAP_FAILED_PTR
return|;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|pMI
operator|->
name|txt_errno
operator|=
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|MAP_FAILED_PTR
return|;
block|}
name|pMI
operator|->
name|txt_size
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
block|}
comment|/*      *  Map mmap flags and protections into open flags and do the open.      */
block|{
name|int
name|o_flag
decl_stmt|;
comment|/*          *  See if we will be updating the file.  If we can alter the memory          *  and if we share the data and we are *not* copy-on-writing the data,          *  then our updates will show in the file, so we must open with          *  write access.          */
if|if
condition|(
name|FILE_WRITABLE
argument_list|(
name|prot
argument_list|,
name|flags
argument_list|)
condition|)
name|o_flag
operator|=
name|O_RDWR
expr_stmt|;
else|else
name|o_flag
operator|=
name|O_RDONLY
expr_stmt|;
comment|/*          *  If you're not sharing the file and you are writing to it,          *  then don't let anyone else have access to the file.          */
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|MAP_SHARED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|prot
operator|&
name|PROT_WRITE
operator|)
condition|)
name|o_flag
operator||=
name|O_EXCL
expr_stmt|;
name|pMI
operator|->
name|txt_fd
operator|=
name|open
argument_list|(
name|pzFile
argument_list|,
name|o_flag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pMI
operator|->
name|txt_fd
operator|==
name|AO_INVALID_FD
condition|)
block|{
name|pMI
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
return|return
name|MAP_FAILED_PTR
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_MMAP
comment|/* * * * * WITH MMAP * * * * * */
comment|/*      *  do the mmap.  If we fail, then preserve errno, close the file and      *  return the failure.      */
name|pMI
operator|->
name|txt_data
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|pMI
operator|->
name|txt_size
operator|+
literal|1
argument_list|,
name|prot
argument_list|,
name|flags
argument_list|,
name|pMI
operator|->
name|txt_fd
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pMI
operator|->
name|txt_data
operator|==
name|MAP_FAILED_PTR
condition|)
block|{
name|pMI
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
goto|goto
name|fail_return
goto|;
block|}
comment|/*      *  Most likely, everything will turn out fine now.  The only difficult      *  part at this point is coping with files with sizes that are a multiple      *  of the page size.  Handling that is what this whole thing is about.      */
name|pMI
operator|->
name|txt_zero_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|pMI
operator|->
name|txt_errno
operator|=
literal|0
expr_stmt|;
block|{
name|void
modifier|*
name|pNuls
decl_stmt|;
ifdef|#
directive|ifdef
name|_SC_PAGESIZE
name|size_t
name|pgsz
init|=
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
decl_stmt|;
else|#
directive|else
name|size_t
name|pgsz
init|=
name|getpagesize
argument_list|()
decl_stmt|;
endif|#
directive|endif
comment|/*          *  Compute the pagesize rounded mapped memory size.          *  IF this is not the same as the file size, then there are NUL's          *  at the end of the file mapping and all is okay.          */
name|pMI
operator|->
name|txt_full_size
operator|=
operator|(
name|pMI
operator|->
name|txt_size
operator|+
operator|(
name|pgsz
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|pgsz
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|pMI
operator|->
name|txt_size
operator|!=
name|pMI
operator|->
name|txt_full_size
condition|)
return|return
name|pMI
operator|->
name|txt_data
return|;
comment|/*          *  Still here?  We have to remap the trailing inaccessible page          *  either anonymously or to /dev/zero.          */
name|pMI
operator|->
name|txt_full_size
operator|+=
name|pgsz
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
name|pNuls
operator|=
name|mmap
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|pMI
operator|->
name|txt_data
operator|)
operator|+
name|pMI
operator|->
name|txt_size
operator|)
argument_list|,
name|pgsz
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_ANONYMOUS
operator||
name|MAP_FIXED
operator||
name|MAP_PRIVATE
argument_list|,
name|AO_INVALID_FD
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pNuls
operator|!=
name|MAP_FAILED_PTR
condition|)
return|return
name|pMI
operator|->
name|txt_data
return|;
name|pMI
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_DEV_ZERO
argument_list|)
name|pMI
operator|->
name|txt_zero_fd
operator|=
name|open
argument_list|(
literal|"/dev/zero"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|pMI
operator|->
name|txt_zero_fd
operator|==
name|AO_INVALID_FD
condition|)
block|{
name|pMI
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
block|}
else|else
block|{
name|pNuls
operator|=
name|mmap
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|pMI
operator|->
name|txt_data
operator|)
operator|+
name|pMI
operator|->
name|txt_size
operator|)
argument_list|,
name|pgsz
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_FIXED
argument_list|,
name|pMI
operator|->
name|txt_zero_fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pNuls
operator|!=
name|MAP_FAILED_PTR
condition|)
return|return
name|pMI
operator|->
name|txt_data
return|;
name|pMI
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|pMI
operator|->
name|txt_zero_fd
argument_list|)
expr_stmt|;
name|pMI
operator|->
name|txt_zero_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|pMI
operator|->
name|txt_full_size
operator|=
name|pMI
operator|->
name|txt_size
expr_stmt|;
block|}
block|{
name|void
modifier|*
name|p
init|=
name|AGALOC
argument_list|(
name|pMI
operator|->
name|txt_size
operator|+
literal|1
argument_list|,
literal|"file text"
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|pMI
operator|->
name|txt_data
argument_list|,
name|pMI
operator|->
name|txt_size
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|)
index|[
name|pMI
operator|->
name|txt_size
index|]
operator|=
name|NUL
expr_stmt|;
name|munmap
argument_list|(
name|pMI
operator|->
name|txt_data
argument_list|,
name|pMI
operator|->
name|txt_size
argument_list|)
expr_stmt|;
name|pMI
operator|->
name|txt_data
operator|=
name|p
expr_stmt|;
block|}
name|pMI
operator|->
name|txt_alloc
operator|=
literal|1
expr_stmt|;
return|return
name|pMI
operator|->
name|txt_data
return|;
else|#
directive|else
comment|/* * * * * * no HAVE_MMAP * * * * * */
name|pMI
operator|->
name|txt_data
operator|=
name|AGALOC
argument_list|(
name|pMI
operator|->
name|txt_size
operator|+
literal|1
argument_list|,
literal|"file text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pMI
operator|->
name|txt_data
operator|==
name|NULL
condition|)
block|{
name|pMI
operator|->
name|txt_errno
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail_return
goto|;
block|}
block|{
name|size_t
name|sz
init|=
name|pMI
operator|->
name|txt_size
decl_stmt|;
name|char
modifier|*
name|pz
init|=
name|pMI
operator|->
name|txt_data
decl_stmt|;
while|while
condition|(
name|sz
operator|>
literal|0
condition|)
block|{
name|ssize_t
name|rdct
init|=
name|read
argument_list|(
name|pMI
operator|->
name|txt_fd
argument_list|,
name|pz
argument_list|,
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|rdct
operator|<=
literal|0
condition|)
block|{
name|pMI
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zFSErrReadFile
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|pzFile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pMI
operator|->
name|txt_data
argument_list|)
expr_stmt|;
goto|goto
name|fail_return
goto|;
block|}
name|pz
operator|+=
name|rdct
expr_stmt|;
name|sz
operator|-=
name|rdct
expr_stmt|;
block|}
operator|*
name|pz
operator|=
name|NUL
expr_stmt|;
block|}
comment|/*      *  We never need a dummy page mapped in      */
name|pMI
operator|->
name|txt_zero_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|pMI
operator|->
name|txt_errno
operator|=
literal|0
expr_stmt|;
return|return
name|pMI
operator|->
name|txt_data
return|;
endif|#
directive|endif
comment|/* * * * * * no HAVE_MMAP * * * * * */
name|fail_return
label|:
if|if
condition|(
name|pMI
operator|->
name|txt_fd
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|pMI
operator|->
name|txt_fd
argument_list|)
expr_stmt|;
name|pMI
operator|->
name|txt_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|errno
operator|=
name|pMI
operator|->
name|txt_errno
expr_stmt|;
name|pMI
operator|->
name|txt_data
operator|=
name|MAP_FAILED_PTR
expr_stmt|;
return|return
name|pMI
operator|->
name|txt_data
return|;
block|}
end_function

begin_comment
comment|/*=export_func  text_munmap  * private:  *  * what:  unmap the data mapped in by text_mmap  *  * arg:   tmap_info_t*, mapinfo, info about the mapping  *  * ret-type:   int  * ret-desc:   -1 or 0.  @file{errno} will have the error code.  *  * doc:  *  * This routine will unmap the data mapped in with @code{text_mmap} and close  * the associated file descriptors opened by that function.  *  * see: munmap(2), close(2)  *  * err: Any error code issued by munmap(2) or close(2) is possible. =*/
end_comment

begin_function
name|int
name|text_munmap
parameter_list|(
name|tmap_info_t
modifier|*
name|pMI
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_MMAP
name|int
name|res
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pMI
operator|->
name|txt_alloc
condition|)
block|{
comment|/*          *  IF the user has write permission and the text is not mapped private,          *  then write back any changes.  Hopefully, nobody else has modified          *  the file in the mean time.          */
if|if
condition|(
operator|(
operator|(
name|pMI
operator|->
name|txt_prot
operator|&
name|PROT_WRITE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|pMI
operator|->
name|txt_flags
operator|&
name|MAP_PRIVATE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|pMI
operator|->
name|txt_fd
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|res
operator|=
operator|(
name|write
argument_list|(
name|pMI
operator|->
name|txt_fd
argument_list|,
name|pMI
operator|->
name|txt_data
argument_list|,
name|pMI
operator|->
name|txt_size
argument_list|)
operator|<
literal|0
operator|)
condition|?
name|errno
else|:
literal|0
expr_stmt|;
block|}
name|AGFREE
argument_list|(
name|pMI
operator|->
name|txt_data
argument_list|)
expr_stmt|;
name|errno
operator|=
name|res
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|munmap
argument_list|(
name|pMI
operator|->
name|txt_data
argument_list|,
name|pMI
operator|->
name|txt_full_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|res
operator|=
name|close
argument_list|(
name|pMI
operator|->
name|txt_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|pMI
operator|->
name|txt_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pMI
operator|->
name|txt_zero_fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|res
operator|=
name|close
argument_list|(
name|pMI
operator|->
name|txt_zero_fd
argument_list|)
expr_stmt|;
name|pMI
operator|->
name|txt_zero_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|error_return
label|:
name|pMI
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
return|return
name|res
return|;
else|#
directive|else
comment|/* HAVE_MMAP */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/*      *  IF the memory is writable *AND* it is not private (copy-on-write)      *     *AND* the memory is "sharable" (seen by other processes)      *  THEN rewrite the data.      */
if|if
condition|(
name|FILE_WRITABLE
argument_list|(
name|pMI
operator|->
name|txt_prot
argument_list|,
name|pMI
operator|->
name|txt_flags
argument_list|)
operator|&&
operator|(
name|lseek
argument_list|(
name|pMI
operator|->
name|txt_fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|>=
literal|0
operator|)
condition|)
block|{
name|write
argument_list|(
name|pMI
operator|->
name|txt_fd
argument_list|,
name|pMI
operator|->
name|txt_data
argument_list|,
name|pMI
operator|->
name|txt_size
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|pMI
operator|->
name|txt_fd
argument_list|)
expr_stmt|;
name|pMI
operator|->
name|txt_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|pMI
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
name|free
argument_list|(
name|pMI
operator|->
name|txt_data
argument_list|)
expr_stmt|;
return|return
name|pMI
operator|->
name|txt_errno
return|;
endif|#
directive|endif
comment|/* HAVE_MMAP */
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/text_mmap.c */
end_comment

end_unit

