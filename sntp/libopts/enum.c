begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file enumeration.c  *  *  Handle options with enumeration names and bit mask bit names  *  for their arguments.  *  * @addtogroup autoopts  * @{  */
end_comment

begin_comment
comment|/*  *  This routine will run run-on options through a pager so the  *  user may examine, print or edit them at their leisure.  *  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  */
end_comment

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|void
name|enum_err
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|int
name|name_ct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uintptr_t
name|find_name
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_memb_shell
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_memb_names
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|nm_list
parameter_list|,
name|unsigned
name|int
name|nm_ct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uintptr_t
name|check_membership_start
parameter_list|(
name|tOptDesc
modifier|*
name|od
parameter_list|,
name|char
specifier|const
modifier|*
modifier|*
name|argp
parameter_list|,
name|bool
modifier|*
name|invert
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uintptr_t
name|find_member_bit
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|,
name|char
specifier|const
modifier|*
name|pz
parameter_list|,
name|int
name|len
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|nm_list
parameter_list|,
name|unsigned
name|int
name|nm_ct
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_function
specifier|static
name|void
name|enum_err
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|int
name|name_ct
parameter_list|)
block|{
name|size_t
name|max_len
init|=
literal|0
decl_stmt|;
name|size_t
name|ttl_len
init|=
literal|0
decl_stmt|;
name|int
name|ct_down
init|=
name|name_ct
decl_stmt|;
name|int
name|hidden
init|=
literal|0
decl_stmt|;
comment|/*      *  A real "pOpts" pointer means someone messed up.  Give a real error.      */
if|if
condition|(
name|pOpts
operator|>
name|OPTPROC_EMIT_LIMIT
condition|)
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|pz_enum_err_fmt
argument_list|,
name|pOpts
operator|->
name|pzProgName
argument_list|,
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zValidKeys
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
comment|/*      *  If the first name starts with this funny character, then we have      *  a first value with an unspellable name.  You cannot specify it.      *  So, we don't list it either.      */
if|if
condition|(
operator|*
operator|*
name|paz_names
operator|==
literal|0x7F
condition|)
block|{
name|paz_names
operator|++
expr_stmt|;
name|hidden
operator|=
literal|1
expr_stmt|;
name|ct_down
operator|=
operator|--
name|name_ct
expr_stmt|;
block|}
comment|/*      *  Figure out the maximum length of any name, plus the total length      *  of all the names.      */
block|{
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz
init|=
name|paz_names
decl_stmt|;
do|do
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
operator|*
operator|(
name|paz
operator|++
operator|)
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|max_len
condition|)
name|max_len
operator|=
name|len
expr_stmt|;
name|ttl_len
operator|+=
name|len
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ct_down
operator|>
literal|0
condition|)
do|;
name|ct_down
operator|=
name|name_ct
expr_stmt|;
block|}
comment|/*      *  IF any one entry is about 1/2 line or longer, print one per line      */
if|if
condition|(
name|max_len
operator|>
literal|35
condition|)
block|{
do|do
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|ENUM_ERR_LINE
argument_list|,
operator|*
operator|(
name|paz_names
operator|++
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ct_down
operator|>
literal|0
condition|)
do|;
block|}
comment|/*      *  ELSE IF they all fit on one line, then do so.      */
elseif|else
if|if
condition|(
name|ttl_len
operator|<
literal|76
condition|)
block|{
name|fputc
argument_list|(
literal|' '
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
do|do
block|{
name|fputc
argument_list|(
literal|' '
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
operator|*
operator|(
name|paz_names
operator|++
operator|)
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ct_down
operator|>
literal|0
condition|)
do|;
name|fputc
argument_list|(
name|NL
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
comment|/*      *  Otherwise, columnize the output      */
else|else
block|{
name|unsigned
name|int
name|ent_no
init|=
literal|0
decl_stmt|;
name|char
name|zFmt
index|[
literal|16
index|]
decl_stmt|;
comment|/* format for all-but-last entries on a line */
name|sprintf
argument_list|(
name|zFmt
argument_list|,
name|ENUM_ERR_WIDTH
argument_list|,
operator|(
name|int
operator|)
name|max_len
argument_list|)
expr_stmt|;
name|max_len
operator|=
literal|78
operator|/
name|max_len
expr_stmt|;
comment|/* max_len is now max entries on a line */
name|fputs
argument_list|(
name|TWO_SPACES_STR
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
comment|/*          *  Loop through all but the last entry          */
name|ct_down
operator|=
name|name_ct
expr_stmt|;
while|while
condition|(
operator|--
name|ct_down
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|ent_no
operator|==
name|max_len
condition|)
block|{
comment|/*                  *  Last entry on a line.  Start next line, too.                  */
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|NLSTR_SPACE_FMT
argument_list|,
operator|*
operator|(
name|paz_names
operator|++
operator|)
argument_list|)
expr_stmt|;
name|ent_no
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zFmt
argument_list|,
operator|*
operator|(
name|paz_names
operator|++
operator|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|NLSTR_FMT
argument_list|,
operator|*
name|paz_names
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pOpts
operator|>
name|OPTPROC_EMIT_LIMIT
condition|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zIntRange
argument_list|,
name|hidden
argument_list|,
name|name_ct
operator|-
literal|1
operator|+
name|hidden
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|pOpts
operator|->
name|pUsageProc
operator|)
operator|)
operator|(
name|pOpts
operator|,
name|EXIT_FAILURE
operator|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_MEMBERSHIP
condition|)
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zLowerBits
argument_list|,
name|name_ct
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|zSetMemberSettings
argument_list|,
name|option_usage_fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|option_usage_fp
argument_list|,
name|zIntRange
argument_list|,
name|hidden
argument_list|,
name|name_ct
operator|-
literal|1
operator|+
name|hidden
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Convert a name or number into a binary number.  * "~0" and "-1" will be converted to the largest value in the enumeration.  *  * @param name       the keyword name (number) to convert  * @param pOpts      the program's option descriptor  * @param pOD        the option descriptor for this option  * @param paz_names  the list of keywords for this option  * @param name_ct    the count of keywords  */
end_comment

begin_function
specifier|static
name|uintptr_t
name|find_name
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
block|{
comment|/*      *  Return the matching index as a pointer sized integer.      *  The result gets stashed in a char* pointer.      */
name|uintptr_t
name|res
init|=
name|name_ct
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
argument_list|)
decl_stmt|;
name|uintptr_t
name|idx
decl_stmt|;
if|if
condition|(
name|IS_DEC_DIGIT_CHAR
argument_list|(
operator|*
name|name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|pz
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|name
decl_stmt|;
name|unsigned
name|long
name|val
init|=
name|strtoul
argument_list|(
name|pz
argument_list|,
operator|&
name|pz
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|pz
operator|==
name|NUL
operator|)
operator|&&
operator|(
name|val
operator|<
name|name_ct
operator|)
condition|)
return|return
operator|(
name|uintptr_t
operator|)
name|val
return|;
name|pz_enum_err_fmt
operator|=
name|znum_too_large
expr_stmt|;
name|option_usage_fp
operator|=
name|stderr
expr_stmt|;
name|enum_err
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
operator|(
name|int
operator|)
name|name_ct
argument_list|)
expr_stmt|;
return|return
name|name_ct
return|;
block|}
if|if
condition|(
name|IS_INVERSION_CHAR
argument_list|(
operator|*
name|name
argument_list|)
operator|&&
operator|(
name|name
index|[
literal|2
index|]
operator|==
name|NUL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'~'
operator|)
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'0'
operator|)
operator|)
operator|||
operator|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'1'
operator|)
operator|)
condition|)
return|return
call|(
name|uintptr_t
call|)
argument_list|(
name|name_ct
operator|-
literal|1
argument_list|)
return|;
goto|goto
name|oops
goto|;
block|}
comment|/*      *  Look for an exact match, but remember any partial matches.      *  Multiple partial matches means we have an ambiguous match.      */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|name_ct
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|paz_names
index|[
name|idx
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|paz_names
index|[
name|idx
index|]
index|[
name|len
index|]
operator|==
name|NUL
condition|)
return|return
name|idx
return|;
comment|/* full match */
if|if
condition|(
name|res
operator|==
name|name_ct
condition|)
name|res
operator|=
name|idx
expr_stmt|;
comment|/* save partial match */
else|else
name|res
operator|=
operator|(
name|uintptr_t
operator|)
operator|~
literal|0
expr_stmt|;
comment|/* may yet find full match */
block|}
block|}
if|if
condition|(
name|res
operator|<
name|name_ct
condition|)
return|return
name|res
return|;
comment|/* partial match */
name|oops
label|:
name|pz_enum_err_fmt
operator|=
operator|(
name|res
operator|==
name|name_ct
operator|)
condition|?
name|zNoKey
else|:
name|zambiguous_key
expr_stmt|;
name|option_usage_fp
operator|=
name|stderr
expr_stmt|;
name|enum_err
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
operator|(
name|int
operator|)
name|name_ct
argument_list|)
expr_stmt|;
return|return
name|name_ct
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionKeywordName  * what:  Convert between enumeration values and strings  * private:  *  * arg:   tOptDesc*,     pOD,       enumeration option description  * arg:   unsigned int,  enum_val,  the enumeration value to map  *  * ret_type:  char const *  * ret_desc:  the enumeration name from const memory  *  * doc:   This converts an enumeration value into the matching string. =*/
end_comment

begin_function
name|char
specifier|const
modifier|*
name|optionKeywordName
parameter_list|(
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|unsigned
name|int
name|enum_val
parameter_list|)
block|{
name|tOptDesc
name|od
init|=
block|{
literal|0
block|}
decl_stmt|;
name|od
operator|.
name|optArg
operator|.
name|argEnum
operator|=
name|enum_val
expr_stmt|;
operator|(
operator|*
operator|(
name|pOD
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|OPTPROC_RETURN_VALNAME
operator|,
operator|&
name|od
operator|)
expr_stmt|;
return|return
name|od
operator|.
name|optArg
operator|.
name|argString
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionEnumerationVal  * what:  Convert from a string to an enumeration value  * private:  *  * arg:   tOptions*,     pOpts,     the program options descriptor  * arg:   tOptDesc*,     pOD,       enumeration option description  * arg:   char const * const *,  paz_names, list of enumeration names  * arg:   unsigned int,  name_ct,   number of names in list  *  * ret_type:  uintptr_t  * ret_desc:  the enumeration value  *  * doc:   This converts the optArg.argString string from the option description  *        into the index corresponding to an entry in the name list.  *        This will match the generated enumeration value.  *        Full matches are always accepted.  Partial matches are accepted  *        if there is only one partial match. =*/
end_comment

begin_function
name|uintptr_t
name|optionEnumerationVal
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
block|{
name|uintptr_t
name|res
init|=
literal|0UL
decl_stmt|;
comment|/*      *  IF the program option descriptor pointer is invalid,      *  then it is some sort of special request.      */
switch|switch
condition|(
operator|(
name|uintptr_t
operator|)
name|pOpts
condition|)
block|{
case|case
operator|(
name|uintptr_t
operator|)
name|OPTPROC_EMIT_USAGE
case|:
comment|/*          *  print the list of enumeration names.          */
name|enum_err
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
operator|(
name|int
operator|)
name|name_ct
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|uintptr_t
operator|)
name|OPTPROC_EMIT_SHELL
case|:
block|{
name|unsigned
name|int
name|ix
init|=
operator|(
name|unsigned
name|int
operator|)
name|pOD
operator|->
name|optArg
operator|.
name|argEnum
decl_stmt|;
comment|/*          *  print the name string.          */
if|if
condition|(
name|ix
operator|>=
name|name_ct
condition|)
name|printf
argument_list|(
name|INVALID_FMT
argument_list|,
name|ix
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|paz_names
index|[
name|ix
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|(
name|uintptr_t
operator|)
name|OPTPROC_RETURN_VALNAME
case|:
block|{
name|unsigned
name|int
name|ix
init|=
operator|(
name|unsigned
name|int
operator|)
name|pOD
operator|->
name|optArg
operator|.
name|argEnum
decl_stmt|;
comment|/*          *  Replace the enumeration value with the name string.          */
if|if
condition|(
name|ix
operator|>=
name|name_ct
condition|)
return|return
operator|(
name|uintptr_t
operator|)
name|INVALID_STR
return|;
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|=
name|paz_names
index|[
name|ix
index|]
expr_stmt|;
break|break;
block|}
default|default:
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_RESET
operator|)
operator|!=
literal|0
condition|)
break|break;
name|res
operator|=
name|find_name
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|,
name|pOpts
argument_list|,
name|pOD
argument_list|,
name|paz_names
argument_list|,
name|name_ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ALLOC_ARG
condition|)
block|{
name|AGFREE
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|pOD
operator|->
name|fOptState
operator|&=
operator|~
name|OPTST_ALLOC_ARG
expr_stmt|;
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_memb_shell
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|paz_names
parameter_list|,
name|unsigned
name|int
name|name_ct
parameter_list|)
block|{
comment|/*      *  print the name string.      */
name|unsigned
name|int
name|ix
init|=
literal|0
decl_stmt|;
name|uintptr_t
name|bits
init|=
operator|(
name|uintptr_t
operator|)
name|pOD
operator|->
name|optCookie
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|pOpts
expr_stmt|;
name|bits
operator|&=
operator|(
operator|(
name|uintptr_t
operator|)
literal|1
operator|<<
operator|(
name|uintptr_t
operator|)
name|name_ct
operator|)
operator|-
operator|(
name|uintptr_t
operator|)
literal|1
expr_stmt|;
while|while
condition|(
name|bits
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bits
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|len
operator|++
operator|>
literal|0
condition|)
name|fputs
argument_list|(
name|OR_STR
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|paz_names
index|[
name|ix
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|ix
operator|>=
name|name_ct
condition|)
break|break;
name|bits
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_memb_names
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|nm_list
parameter_list|,
name|unsigned
name|int
name|nm_ct
parameter_list|)
block|{
name|char
modifier|*
name|pz
decl_stmt|;
name|uintptr_t
name|mask
init|=
operator|(
literal|1UL
operator|<<
operator|(
name|uintptr_t
operator|)
name|nm_ct
operator|)
operator|-
literal|1UL
decl_stmt|;
name|uintptr_t
name|bits
init|=
operator|(
name|uintptr_t
operator|)
name|od
operator|->
name|optCookie
operator|&
name|mask
decl_stmt|;
name|unsigned
name|int
name|ix
init|=
literal|0
decl_stmt|;
name|size_t
name|len
init|=
literal|1
decl_stmt|;
comment|/*      *  Replace the enumeration value with the name string.      *  First, determine the needed length, then allocate and fill in.      */
while|while
condition|(
name|bits
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bits
operator|&
literal|1
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|nm_list
index|[
name|ix
index|]
argument_list|)
operator|+
name|PLUS_STR_LEN
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|ix
operator|>=
name|nm_ct
condition|)
break|break;
name|bits
operator|>>=
literal|1
expr_stmt|;
block|}
name|od
operator|->
name|optArg
operator|.
name|argString
operator|=
name|pz
operator|=
name|AGALOC
argument_list|(
name|len
argument_list|,
literal|"enum"
argument_list|)
expr_stmt|;
name|bits
operator|=
operator|(
name|uintptr_t
operator|)
name|od
operator|->
name|optCookie
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|bits
operator|==
literal|0
condition|)
block|{
operator|*
name|pz
operator|=
name|NUL
expr_stmt|;
return|return;
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
condition|;
name|ix
operator|++
control|)
block|{
name|size_t
name|nln
decl_stmt|;
name|int
name|doit
init|=
name|bits
operator|&
literal|1
decl_stmt|;
name|bits
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|doit
operator|==
literal|0
condition|)
continue|continue;
name|nln
operator|=
name|strlen
argument_list|(
name|nm_list
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pz
argument_list|,
name|nm_list
index|[
name|ix
index|]
argument_list|,
name|nln
argument_list|)
expr_stmt|;
name|pz
operator|+=
name|nln
expr_stmt|;
if|if
condition|(
name|bits
operator|==
literal|0
condition|)
break|break;
name|memcpy
argument_list|(
name|pz
argument_list|,
name|PLUS_STR
argument_list|,
name|PLUS_STR_LEN
argument_list|)
expr_stmt|;
name|pz
operator|+=
name|PLUS_STR_LEN
expr_stmt|;
block|}
operator|*
name|pz
operator|=
name|NUL
expr_stmt|;
operator|(
name|void
operator|)
name|opts
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Check membership start conditions.  An equal character (@samp{=}) says to  * clear the result and not carry over any residual value.  A carat  * (@samp{^}), which may follow the equal character, says to invert the  * result.  The scanning pointer is advanced past these characters and any  * leading white space.  Invalid sequences are indicated by setting the  * scanning pointer to NULL.  *  * @param od      the set membership option description  * @param argp    a pointer to the string scanning pointer  * @param invert  a pointer to the boolean inversion indicator  *  * @returns either zero or the original value for the optCookie.  */
end_comment

begin_function
specifier|static
name|uintptr_t
name|check_membership_start
parameter_list|(
name|tOptDesc
modifier|*
name|od
parameter_list|,
name|char
specifier|const
modifier|*
modifier|*
name|argp
parameter_list|,
name|bool
modifier|*
name|invert
parameter_list|)
block|{
name|uintptr_t
name|res
init|=
operator|(
name|uintptr_t
operator|)
name|od
operator|->
name|optCookie
decl_stmt|;
name|char
specifier|const
modifier|*
name|arg
init|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|od
operator|->
name|optArg
operator|.
name|argString
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|arg
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|arg
operator|==
name|NUL
operator|)
condition|)
goto|goto
name|member_start_fail
goto|;
operator|*
name|invert
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
operator|*
name|arg
condition|)
block|{
case|case
literal|'='
case|:
name|res
operator|=
literal|0UL
expr_stmt|;
name|arg
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|arg
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|arg
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|','
case|:
goto|goto
name|member_start_fail
goto|;
case|case
literal|'^'
case|:
goto|goto
name|inversion
goto|;
default|default:
break|break;
block|}
break|break;
case|case
literal|'^'
case|:
name|inversion
label|:
operator|*
name|invert
operator|=
name|true
expr_stmt|;
name|arg
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|arg
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|!=
literal|','
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
literal|','
case|:
goto|goto
name|member_start_fail
goto|;
default|default:
break|break;
block|}
operator|*
name|argp
operator|=
name|arg
expr_stmt|;
return|return
name|res
return|;
name|member_start_fail
label|:
operator|*
name|argp
operator|=
name|NULL
expr_stmt|;
return|return
literal|0UL
return|;
block|}
end_function

begin_comment
comment|/**  * convert a name to a bit.  Look up a name string to get a bit number  * and shift the value "1" left that number of bits.  *  * @param opts      program options descriptor  * @param od        the set membership option description  * @param pz        address of the start of the bit name  * @param nm_list   the list of names for this option  * @param nm_ct     the number of entries in this list  *  * @returns 0UL on error, other an unsigned long with the correct bit set.  */
end_comment

begin_function
specifier|static
name|uintptr_t
name|find_member_bit
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|,
name|char
specifier|const
modifier|*
name|pz
parameter_list|,
name|int
name|len
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|nm_list
parameter_list|,
name|unsigned
name|int
name|nm_ct
parameter_list|)
block|{
name|char
name|nm_buf
index|[
name|AO_NAME_SIZE
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|nm_buf
argument_list|,
name|pz
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nm_buf
index|[
name|len
index|]
operator|=
name|NUL
expr_stmt|;
block|{
name|unsigned
name|int
name|shift_ct
init|=
operator|(
name|unsigned
name|int
operator|)
name|find_name
argument_list|(
name|nm_buf
argument_list|,
name|opts
argument_list|,
name|od
argument_list|,
name|nm_list
argument_list|,
name|nm_ct
argument_list|)
decl_stmt|;
if|if
condition|(
name|shift_ct
operator|>=
name|nm_ct
condition|)
return|return
literal|0UL
return|;
return|return
literal|1UL
operator|<<
name|shift_ct
return|;
block|}
block|}
end_function

begin_comment
comment|/*=export_func  optionMemberList  * what:  Get the list of members of a bit mask set  *  * arg:   tOptDesc *,  od,   the set membership option description  *  * ret_type: char*  * ret_desc: the names of the set bits  *  * doc:   This converts the OPT_VALUE_name mask value to a allocated string.  *        It is the caller's responsibility to free the string. =*/
end_comment

begin_function
name|char
modifier|*
name|optionMemberList
parameter_list|(
name|tOptDesc
modifier|*
name|od
parameter_list|)
block|{
name|uintptr_t
name|sv
init|=
name|od
operator|->
name|optArg
operator|.
name|argIntptr
decl_stmt|;
name|char
modifier|*
name|res
decl_stmt|;
operator|(
operator|*
operator|(
name|od
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|OPTPROC_RETURN_VALNAME
operator|,
name|od
operator|)
expr_stmt|;
name|res
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|od
operator|->
name|optArg
operator|.
name|argString
expr_stmt|;
name|od
operator|->
name|optArg
operator|.
name|argIntptr
operator|=
name|sv
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionSetMembers  * what:  Convert between bit flag values and strings  * private:  *  * arg:   tOptions*,     opts,     the program options descriptor  * arg:   tOptDesc*,     od,       the set membership option description  * arg:   char const * const *,  *                       nm_list,  list of enumeration names  * arg:   unsigned int,  nm_ct,    number of names in list  *  * doc:   This converts the optArg.argString string from the option description  *        into the index corresponding to an entry in the name list.  *        This will match the generated enumeration value.  *        Full matches are always accepted.  Partial matches are accepted  *        if there is only one partial match. =*/
end_comment

begin_function
name|void
name|optionSetMembers
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|nm_list
parameter_list|,
name|unsigned
name|int
name|nm_ct
parameter_list|)
block|{
comment|/*      *  IF the program option descriptor pointer is invalid,      *  then it is some sort of special request.      */
switch|switch
condition|(
operator|(
name|uintptr_t
operator|)
name|opts
condition|)
block|{
case|case
operator|(
name|uintptr_t
operator|)
name|OPTPROC_EMIT_USAGE
case|:
name|enum_err
argument_list|(
name|OPTPROC_EMIT_USAGE
argument_list|,
name|od
argument_list|,
name|nm_list
argument_list|,
name|nm_ct
argument_list|)
expr_stmt|;
return|return;
case|case
operator|(
name|uintptr_t
operator|)
name|OPTPROC_EMIT_SHELL
case|:
name|set_memb_shell
argument_list|(
name|opts
argument_list|,
name|od
argument_list|,
name|nm_list
argument_list|,
name|nm_ct
argument_list|)
expr_stmt|;
return|return;
case|case
operator|(
name|uintptr_t
operator|)
name|OPTPROC_RETURN_VALNAME
case|:
name|set_memb_names
argument_list|(
name|opts
argument_list|,
name|od
argument_list|,
name|nm_list
argument_list|,
name|nm_ct
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|od
operator|->
name|fOptState
operator|&
name|OPTST_RESET
operator|)
operator|!=
literal|0
condition|)
return|return;
block|{
name|char
specifier|const
modifier|*
name|arg
decl_stmt|;
name|bool
name|invert
decl_stmt|;
name|uintptr_t
name|res
init|=
name|check_membership_start
argument_list|(
name|od
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|invert
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
goto|goto
name|fail_return
goto|;
while|while
condition|(
operator|*
name|arg
operator|!=
name|NUL
condition|)
block|{
name|bool
name|inv_val
init|=
name|false
decl_stmt|;
name|int
name|len
decl_stmt|;
switch|switch
condition|(
operator|*
name|arg
condition|)
block|{
case|case
literal|','
case|:
name|arg
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|arg
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|arg
operator|==
literal|','
operator|)
operator|||
operator|(
operator|*
name|arg
operator|==
literal|'|'
operator|)
condition|)
goto|goto
name|fail_return
goto|;
continue|continue;
case|case
literal|'-'
case|:
case|case
literal|'!'
case|:
name|inv_val
operator|=
name|true
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'+'
case|:
case|case
literal|'|'
case|:
name|arg
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|arg
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
call|(
name|int
call|)
argument_list|(
name|BRK_SET_SEPARATOR_CHARS
argument_list|(
name|arg
argument_list|)
operator|-
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|len
operator|==
literal|3
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|arg
argument_list|,
name|zAll
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|inv_val
condition|)
name|res
operator|=
literal|0
expr_stmt|;
else|else
name|res
operator|=
operator|~
literal|0UL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|==
literal|4
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|arg
argument_list|,
name|zNone
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|inv_val
condition|)
name|res
operator|=
literal|0
expr_stmt|;
block|}
else|else
do|do
block|{
name|char
modifier|*
name|pz
decl_stmt|;
name|uintptr_t
name|bit
init|=
name|strtoul
argument_list|(
name|arg
argument_list|,
operator|&
name|pz
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|pz
operator|!=
name|arg
operator|+
name|len
condition|)
block|{
name|bit
operator|=
name|find_member_bit
argument_list|(
name|opts
argument_list|,
name|od
argument_list|,
name|pz
argument_list|,
name|len
argument_list|,
name|nm_list
argument_list|,
name|nm_ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
operator|==
literal|0UL
condition|)
goto|goto
name|fail_return
goto|;
block|}
if|if
condition|(
name|inv_val
condition|)
name|res
operator|&=
operator|~
name|bit
expr_stmt|;
else|else
name|res
operator||=
name|bit
expr_stmt|;
block|}
do|while
condition|(
name|false
condition|)
do|;
name|arg
operator|=
name|SPN_WHITESPACE_CHARS
argument_list|(
name|arg
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|invert
condition|)
name|res
operator|^=
operator|~
literal|0UL
expr_stmt|;
if|if
condition|(
name|nm_ct
operator|<
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
operator|)
condition|)
name|res
operator|&=
operator|(
literal|1UL
operator|<<
name|nm_ct
operator|)
operator|-
literal|1UL
expr_stmt|;
name|od
operator|->
name|optCookie
operator|=
operator|(
name|void
operator|*
operator|)
name|res
expr_stmt|;
block|}
return|return;
name|fail_return
label|:
name|od
operator|->
name|optCookie
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/** @}  *  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/enum.c */
end_comment

end_unit

