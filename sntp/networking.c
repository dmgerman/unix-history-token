begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|"networking.h"
end_include

begin_decl_stmt
name|char
name|adr_buf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* resolve_hosts consumes an array of hostnames/addresses and its length, stores a pointer  * to the array with the resolved hosts in res and returns the size of the array res.  * pref_family enforces IPv4 or IPv6 depending on commandline options and system   * capability. If pref_family is NULL or PF_UNSPEC any compatible family will be accepted.  * Check here: Probably getaddrinfo() can do without ISC's IPv6 availability check?   */
end_comment

begin_function
name|int
name|resolve_hosts
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|hosts
parameter_list|,
name|int
name|hostc
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
modifier|*
name|res
parameter_list|,
name|int
name|pref_family
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|a
decl_stmt|;
name|unsigned
name|int
name|resc
decl_stmt|;
name|struct
name|addrinfo
modifier|*
modifier|*
name|tres
decl_stmt|;
if|if
condition|(
name|hostc
operator|<
literal|1
operator|||
name|NULL
operator|==
name|res
condition|)
return|return
literal|0
return|;
name|tres
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
operator|*
argument_list|)
operator|*
name|hostc
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
literal|0
operator|,
name|resc
operator|=
literal|0
init|;
name|a
operator|<
name|hostc
condition|;
name|a
operator|++
control|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tres
index|[
name|resc
index|]
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"sntp resolve_hosts: Starting host resolution for %s...\n"
argument_list|,
name|hosts
index|[
name|a
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|AF_UNSPEC
operator|==
name|pref_family
condition|)
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
else|else
name|hints
operator|.
name|ai_family
operator|=
name|pref_family
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|error
operator|=
name|getaddrinfo
argument_list|(
name|hosts
index|[
name|a
index|]
argument_list|,
literal|"123"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|tres
index|[
name|resc
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Error looking up %s%s: %s"
argument_list|,
operator|(
name|AF_UNSPEC
operator|==
name|hints
operator|.
name|ai_family
operator|)
condition|?
literal|""
else|:
operator|(
name|AF_INET
operator|==
name|hints
operator|.
name|ai_family
operator|)
condition|?
literal|"(A) "
else|:
literal|"(AAAA) "
argument_list|,
name|hosts
index|[
name|a
index|]
argument_list|,
name|gai_strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
for|for
control|(
name|dres
operator|=
name|tres
index|[
name|resc
index|]
init|;
name|dres
condition|;
name|dres
operator|=
name|dres
operator|->
name|ai_next
control|)
block|{
name|getnameinfo
argument_list|(
name|dres
operator|->
name|ai_addr
argument_list|,
name|dres
operator|->
name|ai_addrlen
argument_list|,
name|adr_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|adr_buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
expr_stmt|;
name|STDLINE
name|printf
argument_list|(
literal|"Resolv No.: %i Result of getaddrinfo for %s:\n"
argument_list|,
name|resc
argument_list|,
name|hosts
index|[
name|a
index|]
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"socktype: %i "
argument_list|,
name|dres
operator|->
name|ai_socktype
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"protocol: %i "
argument_list|,
name|dres
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Prefered socktype: %i IP: %s\n"
argument_list|,
name|dres
operator|->
name|ai_socktype
argument_list|,
name|adr_buf
argument_list|)
expr_stmt|;
name|STDLINE
block|}
endif|#
directive|endif
name|resc
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|resc
condition|)
operator|*
name|res
operator|=
name|realloc
argument_list|(
name|tres
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
operator|*
argument_list|)
operator|*
name|resc
argument_list|)
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|tres
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|resc
return|;
block|}
end_function

begin_comment
comment|/* Creates a socket and returns. */
end_comment

begin_function
name|void
name|create_socket
parameter_list|(
name|SOCKET
modifier|*
name|rsock
parameter_list|,
name|sockaddr_u
modifier|*
name|dest
parameter_list|)
block|{
operator|*
name|rsock
operator|=
name|socket
argument_list|(
name|AF
argument_list|(
name|dest
argument_list|)
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
operator|*
name|rsock
operator|&&
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Failed to create UDP socket with family %d\n"
argument_list|,
name|AF
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send a packet */
end_comment

begin_function
name|void
name|sendpkt
parameter_list|(
name|SOCKET
name|rsock
parameter_list|,
name|sockaddr_u
modifier|*
name|dest
parameter_list|,
name|struct
name|pkt
modifier|*
name|pkt
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|cc
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"sntp sendpkt: Packet data:\n"
argument_list|)
expr_stmt|;
name|pkt_output
argument_list|(
name|pkt
argument_list|,
name|len
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
block|{
name|getnameinfo
argument_list|(
operator|&
name|dest
operator|->
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
name|dest
argument_list|)
argument_list|,
name|adr_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|adr_buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sntp sendpkt: Sending packet to %s... "
argument_list|,
name|adr_buf
argument_list|)
expr_stmt|;
block|}
name|cc
operator|=
name|sendto
argument_list|(
name|rsock
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pkt
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|&
name|dest
operator|->
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
name|SOCKET_ERROR
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"\n sntp sendpkt: Socket error: %i. Couldn't send packet!\n"
argument_list|,
name|cc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
operator|&&
name|errno
operator|!=
name|ENOBUFS
condition|)
block|{
comment|/* oh well */
block|}
block|}
elseif|else
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Packet sent.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Receive raw data */
end_comment

begin_function
name|int
name|recvdata
parameter_list|(
name|SOCKET
name|rsock
parameter_list|,
name|sockaddr_u
modifier|*
name|sender
parameter_list|,
name|char
modifier|*
name|rdata
parameter_list|,
name|int
name|rdata_length
parameter_list|)
block|{
name|GETSOCKNAME_SOCKLEN_TYPE
name|slen
decl_stmt|;
name|int
name|recvc
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"sntp recvdata: Trying to receive data from...\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|slen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sender
argument_list|)
expr_stmt|;
name|recvc
operator|=
name|recvfrom
argument_list|(
name|rsock
argument_list|,
name|rdata
argument_list|,
name|rdata_length
argument_list|,
literal|0
argument_list|,
operator|&
name|sender
operator|->
name|sa
argument_list|,
operator|&
name|slen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|recvc
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Received %d bytes from %s:\n"
argument_list|,
name|recvc
argument_list|,
name|stoa
argument_list|(
name|sender
argument_list|)
argument_list|)
expr_stmt|;
name|pkt_output
argument_list|(
operator|(
expr|struct
name|pkt
operator|*
operator|)
name|rdata
argument_list|,
name|recvc
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
name|printf
argument_list|(
literal|"recvfrom error %d (%s)\n"
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|recvc
return|;
block|}
end_function

begin_comment
comment|/* Receive data from broadcast. Couldn't finish that. Need to do some digging  * here, especially for protocol independence and IPv6 multicast */
end_comment

begin_function
name|int
name|recv_bcst_data
parameter_list|(
name|SOCKET
name|rsock
parameter_list|,
name|char
modifier|*
name|rdata
parameter_list|,
name|int
name|rdata_len
parameter_list|,
name|sockaddr_u
modifier|*
name|sas
parameter_list|,
name|sockaddr_u
modifier|*
name|ras
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|btrue
init|=
literal|1
decl_stmt|;
name|int
name|recv_bytes
init|=
literal|0
decl_stmt|;
name|int
name|rdy_socks
decl_stmt|;
name|GETSOCKNAME_SOCKLEN_TYPE
name|ss_len
decl_stmt|;
name|struct
name|timeval
name|timeout_tv
decl_stmt|;
name|fd_set
name|bcst_fd
decl_stmt|;
ifdef|#
directive|ifdef
name|MCAST
name|struct
name|ip_mreq
name|mdevadr
decl_stmt|;
name|TYPEOF_IP_MULTICAST_LOOP
name|mtrue
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
name|struct
name|ipv6_mreq
name|mdevadr6
decl_stmt|;
endif|#
directive|endif
name|setsockopt
argument_list|(
name|rsock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|&
name|btrue
argument_list|,
sizeof|sizeof
argument_list|(
name|btrue
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_IPV4
argument_list|(
name|sas
argument_list|)
condition|)
block|{
if|if
condition|(
name|bind
argument_list|(
name|rsock
argument_list|,
operator|&
name|sas
operator|->
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
name|sas
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sntp recv_bcst_data: Couldn't bind() address %s:%d.\n"
argument_list|,
name|stoa
argument_list|(
name|sas
argument_list|)
argument_list|,
name|SRCPORT
argument_list|(
name|sas
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MCAST
if|if
condition|(
name|setsockopt
argument_list|(
name|rsock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MULTICAST_LOOP
argument_list|,
operator|&
name|mtrue
argument_list|,
sizeof|sizeof
argument_list|(
name|mtrue
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* some error message regarding setting up multicast loop */
return|return
name|BROADCAST_FAILED
return|;
block|}
name|mdevadr
operator|.
name|imr_multiaddr
operator|.
name|s_addr
operator|=
name|NSRCADR
argument_list|(
name|sas
argument_list|)
expr_stmt|;
name|mdevadr
operator|.
name|imr_interface
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdevadr
operator|.
name|imr_multiaddr
operator|.
name|s_addr
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"sntp recv_bcst_data: %s:%d is not a broad-/multicast address, aborting...\n"
argument_list|,
name|stoa
argument_list|(
name|sas
argument_list|)
argument_list|,
name|SRCPORT
argument_list|(
name|sas
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|BROADCAST_FAILED
return|;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|rsock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_ADD_MEMBERSHIP
argument_list|,
operator|&
name|mdevadr
argument_list|,
sizeof|sizeof
argument_list|(
name|mdevadr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
block|{
name|buf
operator|=
name|ss_to_str
argument_list|(
name|sas
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sntp recv_bcst_data: Couldn't add IP membership for %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MCAST */
block|}
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEIPV6
elseif|else
if|if
condition|(
name|IS_IPV6
argument_list|(
name|sas
argument_list|)
condition|)
block|{
if|if
condition|(
name|bind
argument_list|(
name|rsock
argument_list|,
operator|&
name|sas
operator|->
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
name|sas
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sntp recv_bcst_data: Couldn't bind() address.\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
if|if
condition|(
name|setsockopt
argument_list|(
name|rsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_MULTICAST_LOOP
argument_list|,
operator|&
name|btrue
argument_list|,
sizeof|sizeof
argument_list|(
name|btrue
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* some error message regarding setting up multicast loop */
return|return
name|BROADCAST_FAILED
return|;
block|}
name|memset
argument_list|(
operator|&
name|mdevadr6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mdevadr6
argument_list|)
argument_list|)
expr_stmt|;
name|mdevadr6
operator|.
name|ipv6mr_multiaddr
operator|=
name|SOCK_ADDR6
argument_list|(
name|sas
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|mdevadr6
operator|.
name|ipv6mr_multiaddr
argument_list|)
condition|)
block|{
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
block|{
name|buf
operator|=
name|ss_to_str
argument_list|(
name|sas
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sntp recv_bcst_data: %s is not a broad-/multicast address, aborting...\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
name|BROADCAST_FAILED
return|;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|rsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_JOIN_GROUP
argument_list|,
operator|&
name|mdevadr6
argument_list|,
sizeof|sizeof
argument_list|(
name|mdevadr6
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
block|{
name|buf
operator|=
name|ss_to_str
argument_list|(
name|sas
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sntp recv_bcst_data: Couldn't join group for %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* INCLUDE_IPV6_MULTICAST_SUPPORT */
block|}
endif|#
directive|endif
comment|/* ISC_PLATFORM_HAVEIPV6 */
name|FD_ZERO
argument_list|(
operator|&
name|bcst_fd
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|rsock
argument_list|,
operator|&
name|bcst_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|TIMEOUT
argument_list|)
condition|)
name|timeout_tv
operator|.
name|tv_sec
operator|=
operator|(
name|int
operator|)
name|OPT_ARG
argument_list|(
name|TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|timeout_tv
operator|.
name|tv_sec
operator|=
literal|68
expr_stmt|;
comment|/* ntpd broadcasts every 64s */
name|timeout_tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|rdy_socks
operator|=
name|select
argument_list|(
name|rsock
operator|+
literal|1
argument_list|,
operator|&
name|bcst_fd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout_tv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rdy_socks
condition|)
block|{
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
name|perror
argument_list|(
literal|"sntp recv_bcst_data: select()"
argument_list|)
expr_stmt|;
return|return
name|BROADCAST_FAILED
return|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sntp recv_bcst_data: select() reached timeout (%u sec), aborting.\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|timeout_tv
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
return|return
name|BROADCAST_FAILED
return|;
break|break;
default|default:
name|ss_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ras
argument_list|)
expr_stmt|;
name|recv_bytes
operator|=
name|recvfrom
argument_list|(
name|rsock
argument_list|,
name|rdata
argument_list|,
name|rdata_len
argument_list|,
literal|0
argument_list|,
operator|&
name|ras
operator|->
name|sa
argument_list|,
operator|&
name|ss_len
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|recv_bytes
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
name|perror
argument_list|(
literal|"sntp recv_bcst_data: recvfrom:"
argument_list|)
expr_stmt|;
name|recv_bytes
operator|=
name|BROADCAST_FAILED
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MCAST
if|if
condition|(
name|IS_IPV4
argument_list|(
name|sas
argument_list|)
condition|)
name|setsockopt
argument_list|(
name|rsock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_DROP_MEMBERSHIP
argument_list|,
operator|&
name|btrue
argument_list|,
sizeof|sizeof
argument_list|(
name|btrue
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INCLUDE_IPV6_MULTICAST_SUPPORT
if|if
condition|(
name|IS_IPV6
argument_list|(
name|sas
argument_list|)
condition|)
name|setsockopt
argument_list|(
name|rsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_LEAVE_GROUP
argument_list|,
operator|&
name|btrue
argument_list|,
sizeof|sizeof
argument_list|(
name|btrue
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|recv_bytes
return|;
block|}
end_function

begin_function
name|int
name|process_pkt
parameter_list|(
name|struct
name|pkt
modifier|*
name|rpkt
parameter_list|,
name|sockaddr_u
modifier|*
name|sas
parameter_list|,
name|int
name|pkt_len
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|pkt
modifier|*
name|spkt
parameter_list|,
name|char
modifier|*
name|func_name
parameter_list|)
block|{
name|unsigned
name|int
name|key_id
init|=
literal|0
decl_stmt|;
name|struct
name|key
modifier|*
name|pkt_key
init|=
name|NULL
decl_stmt|;
name|int
name|is_authentic
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|exten_words
decl_stmt|,
name|exten_words_used
init|=
literal|0
decl_stmt|;
name|int
name|mac_size
decl_stmt|;
comment|/* 	 * Parse the extension field if present. We figure out whether 	 * an extension field is present by measuring the MAC size. If 	 * the number of words following the packet header is 0, no MAC 	 * is present and the packet is not authenticated. If 1, the 	 * packet is a crypto-NAK; if 3, the packet is authenticated 	 * with DES; if 5, the packet is authenticated with MD5; if 6, 	 * the packet is authenticated with SHA. If 2 or 4, the packet 	 * is a runt and discarded forthwith. If greater than 6, an 	 * extension field is present, so we subtract the length of the 	 * field and go around again. 	 */
if|if
condition|(
name|pkt_len
operator|<
name|LEN_PKT_NOMAC
operator|||
operator|(
name|pkt_len
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
name|unusable
label|:
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sntp %s: Funny packet length: %i. Discarding package.\n"
argument_list|,
name|func_name
argument_list|,
name|pkt_len
argument_list|)
expr_stmt|;
return|return
name|PACKET_UNUSEABLE
return|;
block|}
comment|/* skip past the extensions, if any */
name|exten_words
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|pkt_len
operator|-
name|LEN_PKT_NOMAC
operator|)
operator|>>
literal|2
expr_stmt|;
while|while
condition|(
name|exten_words
operator|>
literal|6
condition|)
block|{
name|unsigned
name|int
name|exten_len
decl_stmt|;
name|exten_len
operator|=
name|ntohl
argument_list|(
name|rpkt
operator|->
name|exten
index|[
name|exten_words_used
index|]
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|exten_len
operator|=
operator|(
name|exten_len
operator|+
literal|7
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* convert to words, add 1 */
if|if
condition|(
name|exten_len
operator|>
name|exten_words
operator|||
name|exten_len
operator|<
literal|5
condition|)
goto|goto
name|unusable
goto|;
name|exten_words
operator|-=
name|exten_len
expr_stmt|;
name|exten_words_used
operator|+=
name|exten_len
expr_stmt|;
block|}
switch|switch
condition|(
name|exten_words
condition|)
block|{
case|case
literal|1
case|:
name|key_id
operator|=
name|ntohl
argument_list|(
name|rpkt
operator|->
name|exten
index|[
name|exten_words_used
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Crypto NAK = 0x%08x\n"
argument_list|,
name|key_id
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
case|case
literal|6
case|:
comment|/* Look for the key used by the server in the specified keyfile 		 * and if existent, fetch it or else leave the pointer untouched */
name|key_id
operator|=
name|ntohl
argument_list|(
name|rpkt
operator|->
name|exten
index|[
name|exten_words_used
index|]
argument_list|)
expr_stmt|;
name|get_key
argument_list|(
name|key_id
argument_list|,
operator|&
name|pkt_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pkt_key
condition|)
block|{
name|printf
argument_list|(
literal|"unrecognized key ID = 0x%08x\n"
argument_list|,
name|key_id
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Seems like we've got a key with matching keyid */
comment|/* Generate a md5sum of the packet with the key from our keyfile 		 * and compare those md5sums */
name|mac_size
operator|=
name|exten_words
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|auth_md5
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpkt
argument_list|,
name|pkt_len
operator|-
name|mac_size
argument_list|,
name|mac_size
operator|-
literal|4
argument_list|,
name|pkt_key
argument_list|)
condition|)
block|{
break|break;
block|}
comment|/* Yay! Things worked out! */
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
block|{
name|char
modifier|*
name|hostname
init|=
name|ss_to_str
argument_list|(
name|sas
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"sntp %s: packet received from %s successfully authenticated using key id %i.\n"
argument_list|,
name|func_name
argument_list|,
name|hostname
argument_list|,
name|key_id
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
block|}
name|is_authentic
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
default|default:
goto|goto
name|unusable
goto|;
break|break;
block|}
if|if
condition|(
operator|!
name|is_authentic
condition|)
block|{
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|AUTHENTICATION
argument_list|)
condition|)
block|{
comment|/* We want a authenticated packet */
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
block|{
name|char
modifier|*
name|hostname
init|=
name|ss_to_str
argument_list|(
name|sas
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"sntp %s: packet received from %s is not authentic. Will discard it.\n"
argument_list|,
name|func_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
block|}
return|return
name|SERVER_AUTH_FAIL
return|;
block|}
comment|/* We don't know if the user wanted authentication so let's  		 * use it anyways */
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
block|{
name|char
modifier|*
name|hostname
init|=
name|ss_to_str
argument_list|(
name|sas
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"sntp %s: packet received from %s is not authentic. Authentication not enforced.\n"
argument_list|,
name|func_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check for server's ntp version */
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|<
name|NTP_OLDVERSION
operator|||
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|>
name|NTP_VERSION
condition|)
block|{
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sntp %s: Packet shows wrong version (%i)\n"
argument_list|,
name|func_name
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SERVER_UNUSEABLE
return|;
block|}
comment|/* We want a server to sync with */
if|if
condition|(
name|PKT_MODE
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|!=
name|mode
operator|&&
name|PKT_MODE
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_PASSIVE
condition|)
block|{
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sntp %s: mode %d stratum %i\n"
argument_list|,
name|func_name
argument_list|,
name|PKT_MODE
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|rpkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
return|return
name|SERVER_UNUSEABLE
return|;
block|}
comment|/* Stratum is unspecified (0) check what's going on */
if|if
condition|(
name|STRATUM_PKT_UNSPEC
operator|==
name|rpkt
operator|->
name|stratum
condition|)
block|{
name|char
modifier|*
name|ref_char
decl_stmt|;
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sntp %s: Stratum unspecified, going to check for KOD (stratum: %i)\n"
argument_list|,
name|func_name
argument_list|,
name|rpkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
name|ref_char
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|rpkt
operator|->
name|refid
expr_stmt|;
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sntp %s: Packet refid: %c%c%c%c\n"
argument_list|,
name|func_name
argument_list|,
name|ref_char
index|[
literal|0
index|]
argument_list|,
name|ref_char
index|[
literal|1
index|]
argument_list|,
name|ref_char
index|[
literal|2
index|]
argument_list|,
name|ref_char
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* If it's a KOD packet we'll just use the KOD information */
if|if
condition|(
name|ref_char
index|[
literal|0
index|]
operator|!=
literal|'X'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|ref_char
argument_list|,
literal|"DENY"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|KOD_DEMOBILIZE
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|ref_char
argument_list|,
literal|"RSTR"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|KOD_DEMOBILIZE
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|ref_char
argument_list|,
literal|"RATE"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|KOD_RATE
return|;
comment|/* There are other interesting kiss codes which might be interesting for authentication */
block|}
block|}
comment|/* If the server is not synced it's not really useable for us */
if|if
condition|(
name|LEAP_NOTINSYNC
operator|==
name|PKT_LEAP
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sntp %s: Server not in sync, skipping this server\n"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
return|return
name|SERVER_UNUSEABLE
return|;
block|}
comment|/* 	 * Decode the org timestamp and make sure we're getting a response 	 * to our last request, but only if we're not in broadcast mode. 	 */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"rpkt->org:\n"
argument_list|)
expr_stmt|;
name|l_fp_output
argument_list|(
operator|&
name|rpkt
operator|->
name|org
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"spkt->xmt:\n"
argument_list|)
expr_stmt|;
name|l_fp_output
argument_list|(
operator|&
name|spkt
operator|->
name|xmt
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mode
operator|!=
name|MODE_BROADCAST
operator|&&
operator|!
name|L_ISEQU
argument_list|(
operator|&
name|rpkt
operator|->
name|org
argument_list|,
operator|&
name|spkt
operator|->
name|xmt
argument_list|)
condition|)
block|{
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sntp process_pkt: pkt.org and peer.xmt differ\n"
argument_list|)
expr_stmt|;
return|return
name|PACKET_UNUSEABLE
return|;
block|}
return|return
name|pkt_len
return|;
block|}
end_function

begin_function
name|int
name|recv_bcst_pkt
parameter_list|(
name|SOCKET
name|rsock
parameter_list|,
name|struct
name|pkt
modifier|*
name|rpkt
parameter_list|,
name|unsigned
name|int
name|rsize
parameter_list|,
name|sockaddr_u
modifier|*
name|sas
parameter_list|)
block|{
name|sockaddr_u
name|sender
decl_stmt|;
name|int
name|pkt_len
init|=
name|recv_bcst_data
argument_list|(
name|rsock
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rpkt
argument_list|,
name|rsize
argument_list|,
name|sas
argument_list|,
operator|&
name|sender
argument_list|)
decl_stmt|;
if|if
condition|(
name|pkt_len
operator|<
literal|0
condition|)
block|{
return|return
name|BROADCAST_FAILED
return|;
block|}
name|pkt_len
operator|=
name|process_pkt
argument_list|(
name|rpkt
argument_list|,
name|sas
argument_list|,
name|pkt_len
argument_list|,
name|MODE_BROADCAST
argument_list|,
name|NULL
argument_list|,
literal|"recv_bcst_pkt"
argument_list|)
expr_stmt|;
return|return
name|pkt_len
return|;
block|}
end_function

begin_comment
comment|/* Fetch data, check if it's data for us and whether it's useable or not. If not, return  * a failure code so we can delete this server from our list and continue with another one.  */
end_comment

begin_function
name|int
name|recvpkt
parameter_list|(
name|SOCKET
name|rsock
parameter_list|,
name|struct
name|pkt
modifier|*
name|rpkt
parameter_list|,
comment|/* received packet (response) */
name|unsigned
name|int
name|rsize
parameter_list|,
comment|/* size of rpkt buffer */
name|struct
name|pkt
modifier|*
name|spkt
comment|/* sent     packet (request) */
parameter_list|)
block|{
name|int
name|rdy_socks
decl_stmt|;
name|int
name|pkt_len
decl_stmt|;
name|sockaddr_u
name|sender
decl_stmt|;
name|struct
name|timeval
name|timeout_tv
decl_stmt|;
name|fd_set
name|recv_fd
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|recv_fd
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|rsock
argument_list|,
operator|&
name|recv_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|TIMEOUT
argument_list|)
condition|)
name|timeout_tv
operator|.
name|tv_sec
operator|=
operator|(
name|int
operator|)
name|OPT_ARG
argument_list|(
name|TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|timeout_tv
operator|.
name|tv_sec
operator|=
literal|68
expr_stmt|;
comment|/* ntpd broadcasts every 64s */
name|timeout_tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|rdy_socks
operator|=
name|select
argument_list|(
name|rsock
operator|+
literal|1
argument_list|,
operator|&
name|recv_fd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout_tv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rdy_socks
condition|)
block|{
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
name|perror
argument_list|(
literal|"sntp recvpkt: select()"
argument_list|)
expr_stmt|;
return|return
name|PACKET_UNUSEABLE
return|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|NORMALVERBOSE
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sntp recvpkt: select() reached timeout (%u sec), aborting.\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|timeout_tv
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
return|return
name|PACKET_UNUSEABLE
return|;
break|break;
default|default:
break|break;
block|}
name|pkt_len
operator|=
name|recvdata
argument_list|(
name|rsock
argument_list|,
operator|&
name|sender
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rpkt
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt_len
operator|>
literal|0
condition|)
name|pkt_len
operator|=
name|process_pkt
argument_list|(
name|rpkt
argument_list|,
operator|&
name|sender
argument_list|,
name|pkt_len
argument_list|,
name|MODE_SERVER
argument_list|,
name|spkt
argument_list|,
literal|"recvpkt"
argument_list|)
expr_stmt|;
return|return
name|pkt_len
return|;
block|}
end_function

begin_comment
comment|/*  * is_reachable - check to see if we have a route to given destination  */
end_comment

begin_function
name|int
name|is_reachable
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|dst
parameter_list|)
block|{
name|SOCKET
name|sockfd
init|=
name|socket
argument_list|(
name|dst
operator|->
name|ai_family
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|sockfd
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"is_reachable: Couldn't create socket\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
name|dst
operator|->
name|ai_addr
argument_list|,
name|SOCKLEN
argument_list|(
operator|(
name|sockaddr_u
operator|*
operator|)
name|dst
operator|->
name|ai_addr
argument_list|)
argument_list|)
condition|)
block|{
name|closesocket
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|closesocket
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

