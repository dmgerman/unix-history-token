begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 1996 N.M. Maclaren     Copyright (C) 1996 The University of Cambridge  This includes code that really should have been part of ANSI/ISO C, but was left out for historical reasons (despite requests to define ftty), plus the get_lock() and log_message() functions. */
end_comment

begin_include
include|#
directive|include
file|"header.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|UNIX
end_define

begin_include
include|#
directive|include
file|"kludges.h"
end_include

begin_undef
undef|#
directive|undef
name|UNIX
end_undef

begin_function
name|void
name|do_nothing
parameter_list|(
name|int
name|seconds
parameter_list|)
block|{
comment|/* Wait for a fixed period, possibly uninterruptibly.  This should not wait for less than the specified period, if that can be avoided. */
name|sleep
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|seconds
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* +2 is enough for POSIX */
block|}
end_function

begin_function
name|int
name|ftty
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
comment|/* Return whether the file is attached to an interactive device. */
return|return
name|isatty
argument_list|(
name|fileno
argument_list|(
name|file
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|set_lock
parameter_list|(
name|int
name|lock
parameter_list|)
block|{
comment|/* Check that we have enough privileges to reset the time and that no other updating msntp process is running, but don't bother with fancy interlocking. This function is really only to permit the daemon mode to be restarted in a cron job and improve the diagnostics; it can be replaced by a 'return' statement if it causes implementation difficulties.  Note that there is little point in clearing the lock under Unix, but do so anyway. */
name|FILE
modifier|*
name|file
decl_stmt|;
name|long
name|pid
decl_stmt|;
if|if
condition|(
name|lockname
operator|==
name|NULL
operator|||
name|lockname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return;
if|if
condition|(
name|lock
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|fopen
argument_list|(
name|lockname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|fscanf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|pid
argument_list|)
operator|==
literal|1
operator|&&
name|kill
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
operator|||
name|isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
operator|||
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"another msntp process is currently running"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|fopen
argument_list|(
name|lockname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
operator|<=
literal|0
operator|||
name|ferror
argument_list|(
name|file
argument_list|)
operator|||
name|fclose
argument_list|(
name|file
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to write PID to %s"
argument_list|,
name|lockname
argument_list|)
expr_stmt|;
name|adjust_time
argument_list|(
literal|0.0
argument_list|,
literal|1
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|remove
argument_list|(
name|lockname
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to remove the msntp lockname %s"
argument_list|,
name|lockname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Log a message, crudely.  * This is used in only one place, but could be used more widely.  */
end_comment

begin_function
name|void
name|log_message
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|syslog
argument_list|(
ifdef|#
directive|ifdef
name|LOG_DAEMON
name|LOG_DAEMON
operator||
endif|#
directive|endif
name|LOG_WARNING
argument_list|,
literal|"%s"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

