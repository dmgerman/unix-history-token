begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************************** ** ** Test/verification code for the Skein block functions. ** ** Source code author: Doug Whiting, 2008. ** ** This algorithm and source code is released to the public domain. ** ** Testing: **   - buffering of incremental calls (random cnt steps) **   - partial input byte handling **   - output sample hash results (for comparison of ref vs. optimized) **   - performance ** ***********************************************************************/
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"skein.h"
end_include

begin_include
include|#
directive|include
file|"SHA3api_ref.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|uint_t
name|HASH_BITS
index|[]
init|=
comment|/* list of hash hash lengths to test */
block|{
literal|160
block|,
literal|224
block|,
literal|256
block|,
literal|384
block|,
literal|512
block|,
literal|1024
block|,
literal|256
operator|+
literal|8
block|,
literal|512
operator|+
literal|8
block|,
literal|1024
operator|+
literal|8
block|,
literal|2048
operator|+
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HASH_BITS_CNT
value|(sizeof(HASH_BITS)/sizeof(HASH_BITS[0]))
end_define

begin_comment
comment|/* bits of the verbose flag word */
end_comment

begin_define
define|#
directive|define
name|V_KAT_LONG
value|(1u<< 0)
end_define

begin_define
define|#
directive|define
name|V_KAT_SHORT
value|(1u<< 1)
end_define

begin_define
define|#
directive|define
name|V_KAT_NO_TREE
value|(1u<< 2)
end_define

begin_define
define|#
directive|define
name|V_KAT_NO_SEQ
value|(1u<< 3)
end_define

begin_define
define|#
directive|define
name|V_KAT_NO_3FISH
value|(1u<< 4)
end_define

begin_define
define|#
directive|define
name|V_KAT_DO_3FISH
value|(1u<< 5)
end_define

begin_comment
comment|/* automatic compiler version number detection */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CompilerVersion
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|(
name|_MSC_VER
operator|>=
literal|1400
operator|)
end_if

begin_define
define|#
directive|define
name|CompilerVersion
value|(900)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|(
name|_MSC_VER
operator|>=
literal|1200
operator|)
end_elif

begin_define
define|#
directive|define
name|CompilerVersion
value|(600)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|(
name|_MSC_VER
operator|>=
literal|1000
operator|)
end_elif

begin_define
define|#
directive|define
name|CompilerVersion
value|(420)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__GNUC_MINOR__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__GNUC_PATCHLEVEL__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CompilerVersion
value|(100*__GNUC__ + 10*__GNUC_MINOR__ + __GNUC_PATCHLEVEL__)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
end_elif

begin_comment
comment|/* this is in hex */
end_comment

begin_define
define|#
directive|define
name|CompilerVersion
value|(100*(__BORLANDC__>> 8) + 10*((__BORLANDC__>> 4)& 0xF) + (__BORLANDC__& 0xF))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SKEIN_CODE_SIZE
argument_list|)
operator|||
name|defined
argument_list|(
name|SKEIN_PERF
argument_list|)
end_if

begin_comment
comment|/* external functions to determine code size (in bytes) */
end_comment

begin_function_decl
name|size_t
name|Skein_256_Process_Block_CodeSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|Skein_512_Process_Block_CodeSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|Skein1024_Process_Block_CodeSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|Skein_256_API_CodeSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|Skein_512_API_CodeSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|Skein1024_API_CodeSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint_t
name|Skein_256_Unroll_Cnt
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint_t
name|Skein_512_Unroll_Cnt
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint_t
name|Skein1024_Unroll_Cnt
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|SKEIN_LOOP
argument_list|)
end_elif

begin_function
name|uint_t
name|Skein_256_Unroll_Cnt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|SKEIN_LOOP
operator|/
literal|100
operator|)
operator|%
literal|10
return|;
block|}
end_function

begin_function
name|uint_t
name|Skein_512_Unroll_Cnt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|SKEIN_LOOP
operator|/
literal|10
operator|)
operator|%
literal|10
return|;
block|}
end_function

begin_function
name|uint_t
name|Skein1024_Unroll_Cnt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|SKEIN_LOOP
operator|)
operator|%
literal|10
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|uint_t
name|Skein_256_Unroll_Cnt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|uint_t
name|Skein_512_Unroll_Cnt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|uint_t
name|Skein1024_Unroll_Cnt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* External function to process blkCnt (nonzero) full block(s) of data. */
end_comment

begin_function_decl
name|void
name|Skein_256_Process_Block
parameter_list|(
name|Skein_256_Ctxt_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|blkPtr
parameter_list|,
name|size_t
name|blkCnt
parameter_list|,
name|size_t
name|byteCntAdd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|Skein_512_Process_Block
parameter_list|(
name|Skein_512_Ctxt_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|blkPtr
parameter_list|,
name|size_t
name|blkCnt
parameter_list|,
name|size_t
name|byteCntAdd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|Skein1024_Process_Block
parameter_list|(
name|Skein1024_Ctxt_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|blkPtr
parameter_list|,
name|size_t
name|blkCnt
parameter_list|,
name|size_t
name|byteCntAdd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/********************** debug i/o helper routines **********************/
end_comment

begin_function
name|void
name|FatalError
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
modifier|...
parameter_list|)
block|{
comment|/* print out a msg and exit with an error code */
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|s
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|uint_t
name|_quiet_
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* quiet processing? */
end_comment

begin_decl_stmt
specifier|static
name|uint_t
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* verbose flag bits */
end_comment

begin_decl_stmt
specifier|static
name|uint_t
name|katHash
init|=
operator|~
literal|0u
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use as a quick check on KAT results */
end_comment

begin_function
name|void
name|ShowBytes
parameter_list|(
name|uint_t
name|cnt
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|b
parameter_list|)
block|{
comment|/* formatted output of byte array */
name|uint_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|%
literal|4
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %02X"
argument_list|,
name|b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|katHash
operator|=
operator|(
name|katHash
operator|^
name|b
index|[
name|i
index|]
operator|)
operator|*
literal|0xDEADBEEF
expr_stmt|;
name|katHash
operator|=
operator|(
name|katHash
operator|^
operator|(
name|katHash
operator|>>
literal|23
operator|)
operator|^
operator|(
name|katHash
operator|>>
literal|17
operator|)
operator|^
operator|(
name|katHash
operator|>>
literal|9
operator|)
operator|)
operator|*
literal|0xCAFEF00D
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|15
operator|||
name|i
operator|==
name|cnt
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SKEIN_DEBUG
end_ifndef

begin_decl_stmt
name|uint_t
name|skein_DebugFlag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dummy flags (if not defined elsewhere) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SKEIN_DEBUG_SHORT
value|(SKEIN_DEBUG_HDR | SKEIN_DEBUG_STATE | SKEIN_DEBUG_TWEAK | SKEIN_DEBUG_KEY | SKEIN_DEBUG_INPUT_08 | SKEIN_DEBUG_FINAL)
end_define

begin_define
define|#
directive|define
name|SKEIN_DEBUG_DEFAULT
value|(SKEIN_DEBUG_SHORT)
end_define

begin_function
name|void
name|Show_Debug
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
modifier|...
parameter_list|)
block|{
if|if
condition|(
name|skein_DebugFlag
condition|)
comment|/* are we showing debug info? */
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|s
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************** Timing routine (for performance measurements) ***********/
end_comment

begin_comment
comment|/* unfortunately, this is generally assembly code and not very portable */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_M_IX86
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|_i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|i386
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|_X86_
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_X64
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64
argument_list|)
end_if

begin_define
define|#
directive|define
name|_Is_X86_
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_Is_X86_
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|__STRICT_ANSI__
argument_list|)
operator|)
operator|&&
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|)
operator|&&
expr|\
operator|(
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
name|defined
argument_list|(
name|__MINGW_H
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|HI_RES_CLK_OK
value|1
end_define

begin_comment
comment|/* it's ok to use RDTSC opcode */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|defined
argument_list|(
name|_M_X64
argument_list|)
end_if

begin_include
include|#
directive|include
file|<intrin.h>
end_include

begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
name|__rdtsc
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|uint_32t
name|HiResTime
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HI_RES_CLK_OK
argument_list|)
name|uint_32t
name|x
index|[
literal|2
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
define|#
directive|define
name|COMPILER_ID
value|"BCC"
name|_asm
block|{
name|push
name|edx
block|}
empty_stmt|;
name|__emit__
argument_list|(
literal|0x0F
argument_list|,
literal|0x31
argument_list|)
expr_stmt|;
comment|/* RDTSC instruction */
name|_asm
block|{
name|pop
name|edx
block|}
empty_stmt|;
name|_asm
block|{
name|mov
name|x
index|[
literal|0
index|]
decl_stmt|,
name|eax
block|}
empty_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
define|#
directive|define
name|COMPILER_ID
value|"MSC"
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|defined
argument_list|(
name|_M_X64
argument_list|)
name|x
index|[
literal|0
index|]
operator|=
operator|(
name|uint_32t
operator|)
name|__rdtsc
argument_list|()
expr_stmt|;
else|#
directive|else
name|_asm
block|{
name|push
name|edx
block|}
empty_stmt|;
name|_asm
block|{
name|_emit
literal|0fh
block|}
empty_stmt|;
name|_asm
block|{
name|_emit
literal|031h
block|}
empty_stmt|;
name|_asm
block|{
name|pop
name|edx
block|}
empty_stmt|;
name|_asm
block|{
name|mov
name|x
index|[
literal|0
index|]
decl_stmt|,
name|eax
block|}
empty_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|__MINGW_H
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNUC__
argument_list|)
define|#
directive|define
name|COMPILER_ID
value|"GCC"
asm|asm
specifier|volatile
asm|("rdtsc" : "=a"(x[0]), "=d"(x[1]));
else|#
directive|else
error|#
directive|error
literal|"HI_RES_CLK_OK -- but no assembler code for this platform (?)"
endif|#
directive|endif
return|return
name|x
index|[
literal|0
index|]
return|;
else|#
directive|else
comment|/* avoid annoying MSVC 9.0 compiler warning #4720 in ANSI mode! */
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|)
operator|||
operator|(
name|_MSC_VER
operator|<
literal|1300
operator|)
name|FatalError
argument_list|(
literal|"No support for RDTSC on this CPU platform\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* defined(HI_RES_CLK_OK) */
block|}
end_function

begin_comment
comment|/******** OS-specific calls for setting priorities and sleeping ******/
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|(
name|_MSC_VER
operator|>=
literal|1300
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|__STRICT_ANSI__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|)
expr|\
operator|&&
name|defined
argument_list|(
name|_M_X64
argument_list|)
end_if

begin_include
include|#
directive|include
file|<Windows.h>
end_include

begin_include
include|#
directive|include
file|<WinBase.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SKEIN_FORCE_LOCK_CPU
end_ifdef

begin_comment
comment|/* NielsF says this is not a good way to do things */
end_comment

begin_define
define|#
directive|define
name|SKEIN_LOCK_CPU_OK
value|(1)
end_define

begin_function
name|int
name|Lock_CPU
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* lock this process to this CPU for perf timing */
comment|/*   -- thanks to Brian Gladman for this code    */
name|HANDLE
name|ph
decl_stmt|;
name|DWORD_PTR
name|afp
decl_stmt|;
name|DWORD_PTR
name|afs
decl_stmt|;
name|ph
operator|=
name|GetCurrentProcess
argument_list|()
expr_stmt|;
if|if
condition|(
name|GetProcessAffinityMask
argument_list|(
name|ph
argument_list|,
operator|&
name|afp
argument_list|,
operator|&
name|afs
argument_list|)
condition|)
block|{
name|afp
operator|&=
operator|(
operator|(
operator|(
name|size_t
operator|)
literal|1u
operator|)
operator|<<
name|GetCurrentProcessorNumber
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|SetProcessAffinityMask
argument_list|(
name|ph
argument_list|,
name|afp
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|2
return|;
block|}
return|return
literal|0
return|;
comment|/* success */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_GOT_OS_SLEEP
value|(1)
end_define

begin_function
name|void
name|OS_Sleep
parameter_list|(
name|uint_t
name|msec
parameter_list|)
block|{
name|Sleep
argument_list|(
name|msec
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|_GOT_OS_SET_PRIORITY
value|(1)
end_define

begin_function
name|int
name|OS_Set_High_Priority
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SetThreadPriority
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|,
name|THREAD_PRIORITY_HIGHEST
argument_list|)
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|SKEIN_LOCK_CPU_OK
if|if
condition|(
name|Lock_CPU
argument_list|()
condition|)
return|return
literal|2
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|OS_Set_Normal_Priority
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SetThreadPriority
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|,
name|THREAD_PRIORITY_NORMAL
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__linux
argument_list|)
operator|||
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|||
name|defined
argument_list|(
name|linux
argument_list|)
operator|||
name|defined
argument_list|(
name|__gnu_linux__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_define
define|#
directive|define
name|_GOT_OS_SLEEP
value|(1)
end_define

begin_function
name|void
name|OS_Sleep
parameter_list|(
name|uint_t
name|mSec
parameter_list|)
block|{
name|usleep
argument_list|(
name|mSec
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_GOT_OS_SET_PRIORITY
end_ifndef

begin_comment
comment|/* dummy routines if nothing is available */
end_comment

begin_function
name|int
name|OS_Set_High_Priority
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|OS_Set_Normal_Priority
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_GOT_OS_SLEEP
end_ifndef

begin_function
name|uint_32t
name|OS_Sleep
parameter_list|(
name|uint_32t
name|mSec
parameter_list|)
block|{
return|return
name|mSec
return|;
comment|/* avoid compiler warnings */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COMPILER_ID
end_ifndef

begin_define
define|#
directive|define
name|COMPILER_ID
value|"(unknown)"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/********************** use RC4 to generate test data ******************/
end_comment

begin_comment
comment|/* Note: this works identically on all platforms (big/little-endian)   */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|uint_t
name|I
decl_stmt|,
name|J
decl_stmt|;
comment|/* RC4 vars */
name|u08b_t
name|state
index|[
literal|256
index|]
decl_stmt|;
block|}
name|prng
struct|;
end_struct

begin_function
name|void
name|RandBytes
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|uint_t
name|byteCnt
parameter_list|)
block|{
name|u08b_t
name|a
decl_stmt|,
name|b
decl_stmt|;
name|u08b_t
modifier|*
name|d
init|=
operator|(
name|u08b_t
operator|*
operator|)
name|dst
decl_stmt|;
for|for
control|(
init|;
name|byteCnt
condition|;
name|byteCnt
operator|--
operator|,
name|d
operator|++
control|)
comment|/* run RC4  */
block|{
name|prng
operator|.
name|I
operator|=
operator|(
name|prng
operator|.
name|I
operator|+
literal|1
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|a
operator|=
name|prng
operator|.
name|state
index|[
name|prng
operator|.
name|I
index|]
expr_stmt|;
name|prng
operator|.
name|J
operator|=
operator|(
name|prng
operator|.
name|J
operator|+
name|a
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|b
operator|=
name|prng
operator|.
name|state
index|[
name|prng
operator|.
name|J
index|]
expr_stmt|;
name|prng
operator|.
name|state
index|[
name|prng
operator|.
name|I
index|]
operator|=
name|b
expr_stmt|;
name|prng
operator|.
name|state
index|[
name|prng
operator|.
name|J
index|]
operator|=
name|a
expr_stmt|;
operator|*
name|d
operator|=
name|prng
operator|.
name|state
index|[
operator|(
name|a
operator|+
name|b
operator|)
operator|&
literal|0xFF
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* get a pseudo-random 32-bit integer in a portable way */
end_comment

begin_function
name|uint_t
name|Rand32
parameter_list|(
name|void
parameter_list|)
block|{
name|uint_t
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u08b_t
name|tmp
index|[
literal|4
index|]
decl_stmt|;
name|RandBytes
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
condition|;
name|i
operator|++
control|)
name|n
operator|=
name|n
operator|*
literal|256
operator|+
name|tmp
index|[
name|i
index|]
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* init the (RC4-based) prng */
end_comment

begin_function
name|void
name|Rand_Init
parameter_list|(
name|u64b_t
name|seed
parameter_list|)
block|{
name|uint_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u08b_t
name|tmp
index|[
literal|512
index|]
decl_stmt|;
comment|/* init the "key" in an endian-independent fashion */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|tmp
index|[
name|i
index|]
operator|=
call|(
name|u08b_t
call|)
argument_list|(
name|seed
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* initialize the permutation */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|prng
operator|.
name|state
index|[
name|i
index|]
operator|=
operator|(
name|u08b_t
operator|)
name|i
expr_stmt|;
comment|/* now run the RC4 key schedule */
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
operator|(
name|j
operator|+
name|prng
operator|.
name|state
index|[
name|i
index|]
operator|+
name|tmp
index|[
name|i
operator|%
literal|8
index|]
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|tmp
index|[
literal|256
index|]
operator|=
name|prng
operator|.
name|state
index|[
name|i
index|]
expr_stmt|;
name|prng
operator|.
name|state
index|[
name|i
index|]
operator|=
name|prng
operator|.
name|state
index|[
name|j
index|]
expr_stmt|;
name|prng
operator|.
name|state
index|[
name|j
index|]
operator|=
name|tmp
index|[
literal|256
index|]
expr_stmt|;
block|}
name|prng
operator|.
name|I
operator|=
name|prng
operator|.
name|J
operator|=
literal|0
expr_stmt|;
comment|/* init I,J variables for RC4 */
comment|/* discard initial keystream before returning */
name|RandBytes
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/* An AHS-like API that allows explicit setting of block size          */
end_comment

begin_comment
comment|/*    [i.e., the AHS API selects a block size based solely on the ]    */
end_comment

begin_comment
comment|/*    [hash result length, while Skein allows independent hash    ]    */
end_comment

begin_comment
comment|/*    [result size and block size                                 ]    */
end_comment

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* select the context size and init the context */
end_comment

begin_function
name|int
name|Skein_Init
parameter_list|(
name|int
name|blkSize
parameter_list|,
name|hashState
modifier|*
name|state
parameter_list|,
name|int
name|hashbitlen
parameter_list|)
block|{
switch|switch
condition|(
name|blkSize
condition|)
block|{
case|case
literal|256
case|:
name|state
operator|->
name|statebits
operator|=
literal|64
operator|*
name|SKEIN_256_STATE_WORDS
expr_stmt|;
return|return
name|Skein_256_Init
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx_256
argument_list|,
operator|(
name|size_t
operator|)
name|hashbitlen
argument_list|)
return|;
case|case
literal|512
case|:
name|state
operator|->
name|statebits
operator|=
literal|64
operator|*
name|SKEIN_512_STATE_WORDS
expr_stmt|;
return|return
name|Skein_512_Init
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx_512
argument_list|,
operator|(
name|size_t
operator|)
name|hashbitlen
argument_list|)
return|;
case|case
literal|1024
case|:
name|state
operator|->
name|statebits
operator|=
literal|64
operator|*
name|SKEIN1024_STATE_WORDS
expr_stmt|;
return|return
name|Skein1024_Init
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx1024
argument_list|,
operator|(
name|size_t
operator|)
name|hashbitlen
argument_list|)
return|;
default|default:
return|return
name|SKEIN_FAIL
return|;
block|}
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* select the context size and init (extended) the context */
end_comment

begin_function
name|int
name|Skein_InitExt
parameter_list|(
name|int
name|blkSize
parameter_list|,
name|hashState
modifier|*
name|state
parameter_list|,
name|int
name|hashbitlen
parameter_list|,
name|u64b_t
name|treeInfo
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|key
parameter_list|,
name|size_t
name|keyBytes
parameter_list|)
block|{
switch|switch
condition|(
name|blkSize
condition|)
block|{
case|case
literal|256
case|:
name|state
operator|->
name|statebits
operator|=
literal|64
operator|*
name|SKEIN_256_STATE_WORDS
expr_stmt|;
return|return
name|Skein_256_InitExt
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx_256
argument_list|,
operator|(
name|size_t
operator|)
name|hashbitlen
argument_list|,
name|treeInfo
argument_list|,
name|key
argument_list|,
name|keyBytes
argument_list|)
return|;
case|case
literal|512
case|:
name|state
operator|->
name|statebits
operator|=
literal|64
operator|*
name|SKEIN_512_STATE_WORDS
expr_stmt|;
return|return
name|Skein_512_InitExt
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx_512
argument_list|,
operator|(
name|size_t
operator|)
name|hashbitlen
argument_list|,
name|treeInfo
argument_list|,
name|key
argument_list|,
name|keyBytes
argument_list|)
return|;
case|case
literal|1024
case|:
name|state
operator|->
name|statebits
operator|=
literal|64
operator|*
name|SKEIN1024_STATE_WORDS
expr_stmt|;
return|return
name|Skein1024_InitExt
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx1024
argument_list|,
operator|(
name|size_t
operator|)
name|hashbitlen
argument_list|,
name|treeInfo
argument_list|,
name|key
argument_list|,
name|keyBytes
argument_list|)
return|;
default|default:
return|return
name|SKEIN_FAIL
return|;
block|}
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* process data to be hashed */
end_comment

begin_function
name|int
name|Skein_Update
parameter_list|(
name|hashState
modifier|*
name|state
parameter_list|,
specifier|const
name|BitSequence
modifier|*
name|data
parameter_list|,
name|DataLength
name|databitlen
parameter_list|)
block|{
comment|/* only the final Update() call is allowed do partial bytes, else assert an error */
name|Skein_Assert
argument_list|(
operator|(
name|state
operator|->
name|u
operator|.
name|h
operator|.
name|T
index|[
literal|1
index|]
operator|&
name|SKEIN_T1_FLAG_BIT_PAD
operator|)
operator|==
literal|0
operator|||
name|databitlen
operator|==
literal|0
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|databitlen
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|state
operator|->
name|statebits
condition|)
block|{
case|case
literal|512
case|:
return|return
name|Skein_512_Update
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx_512
argument_list|,
name|data
argument_list|,
name|databitlen
operator|>>
literal|3
argument_list|)
return|;
case|case
literal|256
case|:
return|return
name|Skein_256_Update
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx_256
argument_list|,
name|data
argument_list|,
name|databitlen
operator|>>
literal|3
argument_list|)
return|;
case|case
literal|1024
case|:
return|return
name|Skein1024_Update
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx1024
argument_list|,
name|data
argument_list|,
name|databitlen
operator|>>
literal|3
argument_list|)
return|;
default|default:
return|return
name|SKEIN_FAIL
return|;
block|}
block|}
else|else
block|{
name|size_t
name|bCnt
init|=
operator|(
name|databitlen
operator|>>
literal|3
operator|)
operator|+
literal|1
decl_stmt|;
comment|/* number of bytes to handle */
name|u08b_t
name|mask
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|)
operator|||
operator|(
name|MSC_VER
operator|>=
literal|1200
operator|)
comment|/* MSC v4.2 gives (invalid) warning here!!  */
name|Skein_assert
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|h
operator|==
operator|&
name|state
operator|->
name|u
operator|.
name|ctx_256
operator|.
name|h
argument_list|)
expr_stmt|;
comment|/* sanity checks: allow u.h --> all contexts */
name|Skein_assert
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|h
operator|==
operator|&
name|state
operator|->
name|u
operator|.
name|ctx_512
operator|.
name|h
argument_list|)
expr_stmt|;
name|Skein_assert
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|h
operator|==
operator|&
name|state
operator|->
name|u
operator|.
name|ctx1024
operator|.
name|h
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|state
operator|->
name|statebits
condition|)
block|{
case|case
literal|512
case|:
name|Skein_512_Update
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx_512
argument_list|,
name|data
argument_list|,
name|bCnt
argument_list|)
expr_stmt|;
name|p
operator|=
name|state
operator|->
name|u
operator|.
name|ctx_512
operator|.
name|b
expr_stmt|;
break|break;
case|case
literal|256
case|:
name|Skein_256_Update
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx_256
argument_list|,
name|data
argument_list|,
name|bCnt
argument_list|)
expr_stmt|;
name|p
operator|=
name|state
operator|->
name|u
operator|.
name|ctx_256
operator|.
name|b
expr_stmt|;
break|break;
case|case
literal|1024
case|:
name|Skein1024_Update
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx1024
argument_list|,
name|data
argument_list|,
name|bCnt
argument_list|)
expr_stmt|;
name|p
operator|=
name|state
operator|->
name|u
operator|.
name|ctx1024
operator|.
name|b
expr_stmt|;
break|break;
default|default:
return|return
name|FAIL
return|;
block|}
name|Skein_Set_Bit_Pad_Flag
argument_list|(
name|state
operator|->
name|u
operator|.
name|h
argument_list|)
expr_stmt|;
comment|/* set tweak flag for the final call */
comment|/* now "pad" the final partial byte the way NIST likes */
name|bCnt
operator|=
name|state
operator|->
name|u
operator|.
name|h
operator|.
name|bCnt
expr_stmt|;
comment|/* get the bCnt value (same location for all block sizes) */
name|Skein_assert
argument_list|(
name|bCnt
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* internal sanity check: there IS a partial byte in the buffer! */
name|mask
operator|=
call|(
name|u08b_t
call|)
argument_list|(
literal|1u
operator|<<
operator|(
literal|7
operator|-
operator|(
name|databitlen
operator|&
literal|7
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* partial byte bit mask */
name|p
index|[
name|bCnt
operator|-
literal|1
index|]
operator|=
call|(
name|u08b_t
call|)
argument_list|(
operator|(
name|p
index|[
name|bCnt
operator|-
literal|1
index|]
operator|&
operator|(
literal|0
operator|-
name|mask
operator|)
operator|)
operator||
name|mask
argument_list|)
expr_stmt|;
comment|/* apply bit padding on final byte (in the buffer) */
return|return
name|SUCCESS
return|;
block|}
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* finalize hash computation and output the result (hashbitlen bits) */
end_comment

begin_function
name|int
name|Skein_Final
parameter_list|(
name|hashState
modifier|*
name|state
parameter_list|,
name|BitSequence
modifier|*
name|hashval
parameter_list|)
block|{
switch|switch
condition|(
name|state
operator|->
name|statebits
condition|)
block|{
case|case
literal|512
case|:
return|return
name|Skein_512_Final
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx_512
argument_list|,
name|hashval
argument_list|)
return|;
case|case
literal|256
case|:
return|return
name|Skein_256_Final
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx_256
argument_list|,
name|hashval
argument_list|)
return|;
case|case
literal|1024
case|:
return|return
name|Skein1024_Final
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx1024
argument_list|,
name|hashval
argument_list|)
return|;
default|default:
return|return
name|SKEIN_FAIL
return|;
block|}
block|}
end_function

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* all-in-one hash function */
end_comment

begin_function
name|int
name|Skein_Hash
parameter_list|(
name|int
name|blkSize
parameter_list|,
name|int
name|hashbitlen
parameter_list|,
specifier|const
name|BitSequence
modifier|*
name|data
parameter_list|,
comment|/* all-in-one call */
name|DataLength
name|databitlen
parameter_list|,
name|BitSequence
modifier|*
name|hashval
parameter_list|)
block|{
name|hashState
name|state
decl_stmt|;
name|int
name|r
init|=
name|Skein_Init
argument_list|(
name|blkSize
argument_list|,
operator|&
name|state
argument_list|,
name|hashbitlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|SKEIN_SUCCESS
condition|)
block|{
comment|/* these calls do not fail when called properly */
name|r
operator|=
name|Skein_Update
argument_list|(
operator|&
name|state
argument_list|,
name|data
argument_list|,
name|databitlen
argument_list|)
expr_stmt|;
name|Skein_Final
argument_list|(
operator|&
name|state
argument_list|,
name|hashval
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/* various self-consistency checks */
end_comment

begin_function
name|uint_t
name|Skein_Test
parameter_list|(
name|uint_t
name|blkSize
parameter_list|,
name|uint_t
name|maxLen
parameter_list|,
name|uint_t
name|hashLen
parameter_list|,
name|uint_t
name|nStep
parameter_list|,
name|uint_t
name|oneBlk
parameter_list|)
block|{
enum|enum
block|{
name|MAX_BUF
init|=
literal|1024
block|}
enum|;
name|u08b_t
name|b
index|[
name|MAX_BUF
operator|+
literal|4
index|]
decl_stmt|,
name|hashVal
index|[
literal|2
index|]
index|[
name|MAX_BUF
operator|+
literal|4
index|]
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|,
name|bCnt
decl_stmt|,
name|useAHS
decl_stmt|,
name|step
decl_stmt|,
name|bitLen
decl_stmt|,
name|testCnt
init|=
literal|0
decl_stmt|;
name|hashState
name|s
index|[
literal|2
index|]
decl_stmt|;
name|assert
argument_list|(
name|blkSize
operator|>
literal|0
operator|&&
name|blkSize
operator|<=
literal|1024
operator|&&
operator|(
name|blkSize
operator|%
literal|256
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|hashLen
operator|%
literal|8
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxLen
operator|>
name|MAX_BUF
operator|*
literal|8
condition|)
comment|/* keep things reasonably small */
name|maxLen
operator|=
name|MAX_BUF
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|hashLen
operator|>
name|MAX_BUF
operator|*
literal|8
condition|)
name|hashLen
operator|=
name|MAX_BUF
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|maxLen
operator|==
literal|0
condition|)
comment|/* default sizes */
name|maxLen
operator|=
name|blkSize
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|hashLen
operator|==
literal|0
condition|)
name|hashLen
operator|=
name|blkSize
expr_stmt|;
if|if
condition|(
name|oneBlk
condition|)
block|{
if|if
condition|(
name|oneBlk
operator|>
name|MAX_BUF
operator|*
literal|8
condition|)
name|oneBlk
operator|=
name|MAX_BUF
operator|*
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oneBlk
operator|/
literal|8
condition|;
name|i
operator|++
control|)
name|b
index|[
name|i
index|]
operator|=
operator|(
name|u08b_t
operator|)
name|i
expr_stmt|;
if|if
condition|(
name|Skein_Hash
argument_list|(
name|blkSize
argument_list|,
name|hashLen
argument_list|,
name|b
argument_list|,
name|oneBlk
argument_list|,
name|hashVal
index|[
literal|0
index|]
argument_list|)
operator|!=
name|SKEIN_SUCCESS
condition|)
name|FatalError
argument_list|(
literal|"Skein_Hash != SUCCESS"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|nStep
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Testing Skein: blkSize = %4d bits. hashLen=%4d bits. maxMsgLen = %4d bits.\n"
argument_list|,
name|blkSize
argument_list|,
name|hashLen
argument_list|,
name|maxLen
argument_list|)
expr_stmt|;
name|nStep
operator|=
literal|1
expr_stmt|;
block|}
name|n
operator|=
name|skein_DebugFlag
expr_stmt|;
name|skein_DebugFlag
operator|=
literal|0
expr_stmt|;
comment|/* turn of debug display for this "fake" AHS call */
if|if
condition|(
name|Init
argument_list|(
operator|&
name|s
index|[
literal|0
index|]
argument_list|,
name|hashLen
argument_list|)
operator|!=
name|SUCCESS
condition|)
comment|/* just see if AHS API supports this<blkSize,hashLen> pair */
name|FatalError
argument_list|(
literal|"AHS_API Init() error!"
argument_list|)
expr_stmt|;
name|skein_DebugFlag
operator|=
name|n
expr_stmt|;
comment|/* restore debug display status */
name|useAHS
operator|=
operator|(
name|s
index|[
literal|0
index|]
operator|.
name|statebits
operator|==
name|blkSize
operator|)
expr_stmt|;
comment|/* does this<blkSize,hashLen> pair work via AHS_API? */
name|bCnt
operator|=
operator|(
name|maxLen
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
comment|/* convert maxLen to bytes */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|bCnt
condition|;
name|n
operator|+=
name|nStep
control|)
comment|/* process all the data lengths (# bytes = n+1)*/
block|{
name|RandBytes
argument_list|(
name|b
argument_list|,
name|maxLen
argument_list|)
expr_stmt|;
comment|/* get something to hash */
for|for
control|(
name|j
operator|=
literal|8
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
comment|/* j = # bits in final byte */
block|{
name|testCnt
operator|++
expr_stmt|;
name|memset
argument_list|(
name|hashVal
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hashVal
argument_list|)
argument_list|)
expr_stmt|;
name|Show_Debug
argument_list|(
literal|"\n*** Single Hash() call (%d bits)\n"
argument_list|,
literal|8
operator|*
name|n
operator|+
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|Skein_Hash
argument_list|(
name|blkSize
argument_list|,
name|hashLen
argument_list|,
name|b
argument_list|,
literal|8
operator|*
name|n
operator|+
name|j
argument_list|,
name|hashVal
index|[
literal|0
index|]
argument_list|)
operator|!=
name|SKEIN_SUCCESS
condition|)
name|FatalError
argument_list|(
literal|"Skein_Hash != SUCCESS"
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|hashLen
operator|/
literal|8
init|;
name|k
operator|<=
name|MAX_BUF
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|hashVal
index|[
literal|0
index|]
index|[
name|k
index|]
operator|!=
literal|0
condition|)
name|FatalError
argument_list|(
literal|"Skein hash output overrun!: hashLen = %d bits"
argument_list|,
name|hashLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|useAHS
condition|)
comment|/* compare using AHS API, if supported */
block|{
name|Show_Debug
argument_list|(
literal|"\n*** Single AHS API Hash() call\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Hash
argument_list|(
name|hashLen
argument_list|,
name|b
argument_list|,
literal|8
operator|*
name|n
operator|+
name|j
argument_list|,
name|hashVal
index|[
literal|1
index|]
argument_list|)
operator|!=
name|SUCCESS
condition|)
name|FatalError
argument_list|(
literal|"Skein_Hash != SUCCESS"
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|hashLen
operator|/
literal|8
init|;
name|k
operator|<=
name|MAX_BUF
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|hashVal
index|[
literal|1
index|]
index|[
name|k
index|]
operator|!=
literal|0
condition|)
name|FatalError
argument_list|(
literal|"Skein AHS_API hash output overrun!: hashLen = %d bits"
argument_list|,
name|hashLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|hashVal
index|[
literal|1
index|]
argument_list|,
name|hashVal
index|[
literal|0
index|]
argument_list|,
name|hashLen
operator|/
literal|8
argument_list|)
condition|)
name|FatalError
argument_list|(
literal|"Skein vs. AHS API miscompare"
argument_list|)
expr_stmt|;
block|}
comment|/* now try (randomized) steps thru entire input block */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|Show_Debug
argument_list|(
literal|"\n*** Multiple Update() calls [%s]"
argument_list|,
operator|(
name|i
operator|)
condition|?
literal|"random steps"
else|:
literal|"step==1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
block|{
name|Show_Debug
argument_list|(
literal|"  [re-use precomputed state]"
argument_list|)
expr_stmt|;
name|s
index|[
literal|0
index|]
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|k
operator|=
operator|(
name|i
operator|)
condition|?
name|Skein_Init
argument_list|(
name|blkSize
argument_list|,
operator|&
name|s
index|[
literal|0
index|]
argument_list|,
name|hashLen
argument_list|)
else|:
name|Skein_InitExt
argument_list|(
name|blkSize
argument_list|,
operator|&
name|s
index|[
literal|0
index|]
argument_list|,
name|hashLen
argument_list|,
name|SKEIN_CFG_TREE_INFO_SEQUENTIAL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|SKEIN_SUCCESS
condition|)
name|FatalError
argument_list|(
literal|"Skein_Init != SUCCESS"
argument_list|)
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
comment|/* make a copy for next time */
block|}
name|Show_Debug
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n
operator|+
literal|1
condition|;
name|k
operator|+=
name|step
control|)
comment|/* step thru with variable sized steps */
block|{
comment|/* for i == 0, step one byte at a time. for i>0, randomly */
name|step
operator|=
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|1
operator|+
operator|(
name|Rand32
argument_list|()
operator|%
operator|(
name|n
operator|+
literal|1
operator|-
name|k
operator|)
operator|)
expr_stmt|;
comment|/* # bytes to process */
name|bitLen
operator|=
operator|(
name|k
operator|+
name|step
operator|>=
name|n
operator|+
literal|1
operator|)
condition|?
literal|8
operator|*
operator|(
name|step
operator|-
literal|1
operator|)
operator|+
name|j
else|:
literal|8
operator|*
name|step
expr_stmt|;
comment|/* partial final byte handling */
if|if
condition|(
name|Skein_Update
argument_list|(
operator|&
name|s
index|[
literal|0
index|]
argument_list|,
operator|&
name|b
index|[
name|k
index|]
argument_list|,
name|bitLen
argument_list|)
operator|!=
name|SKEIN_SUCCESS
condition|)
name|FatalError
argument_list|(
literal|"Skein_Update != SUCCESS"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Skein_Final
argument_list|(
operator|&
name|s
index|[
literal|0
index|]
argument_list|,
name|hashVal
index|[
literal|1
index|]
argument_list|)
operator|!=
name|SKEIN_SUCCESS
condition|)
name|FatalError
argument_list|(
literal|"Skein_Final != SUCCESS"
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|hashLen
operator|/
literal|8
init|;
name|k
operator|<=
name|MAX_BUF
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|hashVal
index|[
literal|0
index|]
index|[
name|k
index|]
operator|!=
literal|0
condition|)
name|FatalError
argument_list|(
literal|"Skein hash output overrun!: hashLen = %d bits"
argument_list|,
name|hashLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|hashVal
index|[
literal|1
index|]
argument_list|,
name|hashVal
index|[
literal|0
index|]
argument_list|,
name|hashLen
operator|/
literal|8
argument_list|)
condition|)
name|FatalError
argument_list|(
literal|"Skein Hash() vs. Update() miscompare!"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|testCnt
return|;
block|}
end_function

begin_comment
comment|/* filter out<blkSize,hashBits> pairs in short KAT mode */
end_comment

begin_function
name|uint_t
name|Short_KAT_OK
parameter_list|(
name|uint_t
name|blkSize
parameter_list|,
name|uint_t
name|hashBits
parameter_list|)
block|{
switch|switch
condition|(
name|blkSize
condition|)
block|{
case|case
literal|256
case|:
if|if
condition|(
name|hashBits
operator|!=
literal|256
operator|&&
name|hashBits
operator|!=
literal|224
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|512
case|:
if|if
condition|(
name|hashBits
operator|!=
literal|256
operator|&&
name|hashBits
operator|!=
literal|384
operator|&&
name|hashBits
operator|!=
literal|512
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|1024
case|:
if|if
condition|(
name|hashBits
operator|!=
literal|384
operator|&&
name|hashBits
operator|!=
literal|512
operator|&&
name|hashBits
operator|!=
literal|1024
condition|)
return|return
literal|0
return|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
name|SKEIN_TREE_HASH
end_if

begin_define
define|#
directive|define
name|MAX_TREE_MSG_LEN
value|(1<< 12)
end_define

begin_comment
comment|/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* pad final block, no OUTPUT stage */
end_comment

begin_function
name|int
name|Skein_Final_Pad
parameter_list|(
name|hashState
modifier|*
name|state
parameter_list|,
name|BitSequence
modifier|*
name|hashval
parameter_list|)
block|{
switch|switch
condition|(
name|state
operator|->
name|statebits
condition|)
block|{
case|case
literal|512
case|:
return|return
name|Skein_512_Final_Pad
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx_512
argument_list|,
name|hashval
argument_list|)
return|;
case|case
literal|256
case|:
return|return
name|Skein_256_Final_Pad
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx_256
argument_list|,
name|hashval
argument_list|)
return|;
case|case
literal|1024
case|:
return|return
name|Skein1024_Final_Pad
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx1024
argument_list|,
name|hashval
argument_list|)
return|;
default|default:
return|return
name|SKEIN_FAIL
return|;
block|}
block|}
end_function

begin_comment
comment|/* just the OUTPUT stage */
end_comment

begin_function
name|int
name|Skein_Output
parameter_list|(
name|hashState
modifier|*
name|state
parameter_list|,
name|BitSequence
modifier|*
name|hashval
parameter_list|)
block|{
switch|switch
condition|(
name|state
operator|->
name|statebits
condition|)
block|{
case|case
literal|512
case|:
return|return
name|Skein_512_Output
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx_512
argument_list|,
name|hashval
argument_list|)
return|;
case|case
literal|256
case|:
return|return
name|Skein_256_Output
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx_256
argument_list|,
name|hashval
argument_list|)
return|;
case|case
literal|1024
case|:
return|return
name|Skein1024_Output
argument_list|(
operator|&
name|state
operator|->
name|u
operator|.
name|ctx1024
argument_list|,
name|hashval
argument_list|)
return|;
default|default:
return|return
name|SKEIN_FAIL
return|;
block|}
block|}
end_function

begin_comment
comment|/* generate a KAT test for the given data and tree parameters. */
end_comment

begin_comment
comment|/* This is an "all-in-one" call. It is not intended to represent */
end_comment

begin_comment
comment|/* how a real multi-processor version would be implemented, but  */
end_comment

begin_comment
comment|/* the results will be the same */
end_comment

begin_function
name|void
name|Skein_TreeHash
parameter_list|(
name|uint_t
name|blkSize
parameter_list|,
name|uint_t
name|hashBits
parameter_list|,
specifier|const
name|u08b_t
modifier|*
name|msg
parameter_list|,
name|size_t
name|msgBytes
parameter_list|,
name|uint_t
name|leaf
parameter_list|,
name|uint_t
name|node
parameter_list|,
name|uint_t
name|maxLevel
parameter_list|,
name|u08b_t
modifier|*
name|hashRes
parameter_list|)
block|{
enum|enum
block|{
name|MAX_HEIGHT
init|=
literal|32
block|}
enum|;
comment|/* how deep we can go here */
name|uint_t
name|height
decl_stmt|;
name|uint_t
name|blkBytes
init|=
name|blkSize
operator|/
literal|8
decl_stmt|;
name|uint_t
name|saveDebug
init|=
name|skein_DebugFlag
decl_stmt|;
name|size_t
name|n
decl_stmt|,
name|nodeLen
decl_stmt|,
name|srcOffs
decl_stmt|,
name|dstOffs
decl_stmt|,
name|bCnt
decl_stmt|;
name|u64b_t
name|treeInfo
decl_stmt|;
name|u08b_t
name|M
index|[
name|MAX_TREE_MSG_LEN
operator|+
literal|4
index|]
decl_stmt|;
name|hashState
name|G
decl_stmt|,
name|s
decl_stmt|;
name|assert
argument_list|(
name|node
operator|<
literal|256
operator|&&
name|leaf
operator|<
literal|256
operator|&&
name|maxLevel
operator|<
literal|256
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|node
operator|>
literal|0
operator|&&
name|leaf
operator|>
literal|0
operator|&&
name|maxLevel
operator|>
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|blkSize
operator|==
literal|256
operator|||
name|blkSize
operator|==
literal|512
operator|||
name|blkSize
operator|==
literal|1024
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|blkBytes
operator|<=
sizeof|sizeof
argument_list|(
name|M
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|msgBytes
operator|<=
sizeof|sizeof
argument_list|(
name|M
argument_list|)
argument_list|)
expr_stmt|;
comment|/* precompute the config block result G for multiple uses below */
ifdef|#
directive|ifdef
name|SKEIN_DEBUG
if|if
condition|(
name|skein_DebugFlag
condition|)
name|skein_DebugFlag
operator||=
name|SKEIN_DEBUG_CONFIG
expr_stmt|;
endif|#
directive|endif
name|treeInfo
operator|=
name|SKEIN_CFG_TREE_INFO
argument_list|(
name|leaf
argument_list|,
name|node
argument_list|,
name|maxLevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|Skein_InitExt
argument_list|(
name|blkSize
argument_list|,
operator|&
name|G
argument_list|,
name|hashBits
argument_list|,
name|treeInfo
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
name|SKEIN_SUCCESS
condition|)
name|FatalError
argument_list|(
literal|"Skein_InitExt() fails in tree"
argument_list|)
expr_stmt|;
name|skein_DebugFlag
operator|=
name|saveDebug
expr_stmt|;
name|bCnt
operator|=
name|msgBytes
expr_stmt|;
name|memcpy
argument_list|(
name|M
argument_list|,
name|msg
argument_list|,
name|bCnt
argument_list|)
expr_stmt|;
for|for
control|(
name|height
operator|=
literal|0
init|;
condition|;
name|height
operator|++
control|)
comment|/* walk up the tree */
block|{
if|if
condition|(
name|height
operator|&&
operator|(
name|bCnt
operator|==
name|blkBytes
operator|)
condition|)
comment|/* are we done (with only one block left)? */
break|break;
if|if
condition|(
name|height
operator|+
literal|1
operator|==
name|maxLevel
condition|)
comment|/* is this the final allowed level? */
block|{
comment|/* if so, do it as one big hash */
name|s
operator|=
name|G
expr_stmt|;
name|Skein_Set_Tree_Level
argument_list|(
name|s
operator|.
name|u
operator|.
name|h
argument_list|,
name|height
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Skein_Update
argument_list|(
operator|&
name|s
argument_list|,
name|M
argument_list|,
name|bCnt
operator|*
literal|8
argument_list|)
expr_stmt|;
name|Skein_Final_Pad
argument_list|(
operator|&
name|s
argument_list|,
name|M
argument_list|)
expr_stmt|;
break|break;
block|}
name|nodeLen
operator|=
name|blkBytes
operator|<<
operator|(
operator|(
name|height
operator|)
condition|?
name|node
else|:
name|leaf
operator|)
expr_stmt|;
for|for
control|(
name|srcOffs
operator|=
name|dstOffs
operator|=
literal|0
init|;
name|srcOffs
operator|<=
name|bCnt
condition|;
control|)
block|{
name|n
operator|=
name|bCnt
operator|-
name|srcOffs
expr_stmt|;
comment|/* number of bytes left at this level */
if|if
condition|(
name|n
operator|>
name|nodeLen
condition|)
comment|/* limit to node size */
name|n
operator|=
name|nodeLen
expr_stmt|;
name|s
operator|=
name|G
expr_stmt|;
name|s
operator|.
name|u
operator|.
name|h
operator|.
name|T
index|[
literal|0
index|]
operator|=
name|srcOffs
expr_stmt|;
comment|/* nonzero initial offset in tweak! */
name|Skein_Set_Tree_Level
argument_list|(
name|s
operator|.
name|u
operator|.
name|h
argument_list|,
name|height
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Skein_Update
argument_list|(
operator|&
name|s
argument_list|,
name|M
operator|+
name|srcOffs
argument_list|,
name|n
operator|*
literal|8
argument_list|)
expr_stmt|;
name|Skein_Final_Pad
argument_list|(
operator|&
name|s
argument_list|,
name|M
operator|+
name|dstOffs
argument_list|)
expr_stmt|;
comment|/* finish up this node, output intermediate result to M[]*/
name|dstOffs
operator|+=
name|blkBytes
expr_stmt|;
name|srcOffs
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|srcOffs
operator|>=
name|bCnt
condition|)
comment|/* special logic to handle (msgBytes == 0) case */
break|break;
block|}
name|bCnt
operator|=
name|dstOffs
expr_stmt|;
block|}
comment|/* output the result */
name|Skein_Output
argument_list|(
operator|&
name|s
argument_list|,
name|hashRes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Generate tree-mode hash KAT vectors. ** Note: **    Tree vectors are different enough from non-tree vectors that it  **    makes sense to separate this out into a different function, rather  **    than shoehorn it into the same KAT logic as the other modes. **/
end_comment

begin_function
name|void
name|Skein_GenKAT_Tree
parameter_list|(
name|uint_t
name|blkSize
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
name|uint_t
name|leaf
decl_stmt|,
name|node
decl_stmt|,
name|maxLevel
decl_stmt|,
name|levels
decl_stmt|;
block|}
name|TREE_PARMS
index|[]
init|=
block|{
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|}
block|,
block|{
literal|2
block|,
literal|1
block|,
literal|0xFF
block|,
literal|3
block|}
block|}
struct|;
define|#
directive|define
name|TREE_PARM_CNT
value|(sizeof(TREE_PARMS)/sizeof(TREE_PARMS[0]))
name|u08b_t
name|msg
index|[
name|MAX_TREE_MSG_LEN
operator|+
literal|4
index|]
decl_stmt|,
name|hashVal
index|[
name|MAX_TREE_MSG_LEN
operator|+
literal|4
index|]
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|,
name|p
decl_stmt|,
name|q
decl_stmt|,
name|hashBits
decl_stmt|,
name|node
decl_stmt|,
name|leaf
decl_stmt|,
name|leafBytes
decl_stmt|,
name|msgBytes
decl_stmt|,
name|byteCnt
decl_stmt|,
name|levels
decl_stmt|,
name|maxLevel
decl_stmt|;
name|assert
argument_list|(
name|blkSize
operator|==
literal|256
operator|||
name|blkSize
operator|==
literal|512
operator|||
name|blkSize
operator|==
literal|1024
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TREE_MSG_LEN
condition|;
name|i
operator|+=
literal|2
control|)
block|{
comment|/* generate "incrementing" tree hash input msg data */
name|msg
index|[
name|i
index|]
operator|=
call|(
name|u08b_t
call|)
argument_list|(
operator|(
name|i
operator|^
name|blkSize
operator|)
operator|^
operator|(
name|i
operator|>>
literal|16
operator|)
argument_list|)
expr_stmt|;
name|msg
index|[
name|i
operator|+
literal|1
index|]
operator|=
call|(
name|u08b_t
call|)
argument_list|(
operator|(
name|i
operator|^
name|blkSize
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|q
operator|=
name|n
operator|=
literal|0
init|;
name|k
operator|<
name|HASH_BITS_CNT
condition|;
name|k
operator|++
control|)
block|{
name|hashBits
operator|=
name|HASH_BITS
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|Short_KAT_OK
argument_list|(
name|blkSize
argument_list|,
name|hashBits
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|verbose
operator|&
name|V_KAT_SHORT
operator|)
operator|&&
operator|(
name|hashBits
operator|!=
name|blkSize
operator|)
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|TREE_PARM_CNT
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|&&
operator|(
name|verbose
operator|&
name|V_KAT_SHORT
operator|)
condition|)
continue|continue;
comment|/* keep short KATs short */
if|if
condition|(
name|p
operator|&&
name|hashBits
operator|!=
name|blkSize
condition|)
continue|continue;
comment|/* we only need one "non-full" size */
name|leaf
operator|=
name|TREE_PARMS
index|[
name|p
index|]
operator|.
name|leaf
expr_stmt|;
name|node
operator|=
name|TREE_PARMS
index|[
name|p
index|]
operator|.
name|node
expr_stmt|;
name|maxLevel
operator|=
name|TREE_PARMS
index|[
name|p
index|]
operator|.
name|maxLevel
expr_stmt|;
name|levels
operator|=
name|TREE_PARMS
index|[
name|p
index|]
operator|.
name|levels
expr_stmt|;
name|leafBytes
operator|=
operator|(
name|blkSize
operator|/
literal|8
operator|)
operator|<<
name|leaf
expr_stmt|;
comment|/* number of bytes in a "full" leaf */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
comment|/* different numbers of leaf results */
block|{
if|if
condition|(
operator|(
name|verbose
operator|&
name|V_KAT_SHORT
operator|)
operator|&&
operator|(
name|j
operator|!=
literal|3
operator|)
operator|&&
operator|(
name|j
operator|!=
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|j
operator|&&
operator|(
name|hashBits
operator|!=
name|blkSize
operator|)
condition|)
break|break;
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|0
case|:
name|n
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|n
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|n
operator|=
operator|(
literal|1
operator|<<
operator|(
name|node
operator|*
operator|(
name|levels
operator|-
literal|2
operator|)
operator|)
operator|)
operator|*
literal|3
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|2
condition|)
continue|continue;
break|break;
case|case
literal|3
case|:
name|n
operator|=
operator|(
literal|1
operator|<<
operator|(
name|node
operator|*
operator|(
name|levels
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
break|break;
block|}
name|byteCnt
operator|=
name|n
operator|*
name|leafBytes
expr_stmt|;
name|assert
argument_list|(
name|byteCnt
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|byteCnt
operator|>
name|MAX_TREE_MSG_LEN
condition|)
continue|continue;
name|q
operator|=
operator|(
name|q
operator|+
literal|1
operator|)
operator|%
name|leafBytes
expr_stmt|;
name|msgBytes
operator|=
name|byteCnt
operator|-
name|q
expr_stmt|;
switch|switch
condition|(
name|blkSize
condition|)
block|{
case|case
literal|256
case|:
name|printf
argument_list|(
literal|"\n:Skein-256: "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|512
case|:
name|printf
argument_list|(
literal|"\n:Skein-512: "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1024
case|:
name|printf
argument_list|(
literal|"\n:Skein-1024:"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|" %4d-bit hash, msgLen =%6d bits"
argument_list|,
name|hashBits
argument_list|,
name|msgBytes
operator|*
literal|8
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|". Tree: leaf=%02X, node=%02X, maxLevels=%02X\n"
argument_list|,
name|leaf
argument_list|,
name|node
argument_list|,
name|maxLevel
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nMessage data:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgBytes
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"    (none)\n"
argument_list|)
expr_stmt|;
else|else
name|ShowBytes
argument_list|(
name|msgBytes
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|Skein_TreeHash
argument_list|(
name|blkSize
argument_list|,
name|hashBits
argument_list|,
name|msg
argument_list|,
name|msgBytes
argument_list|,
name|leaf
argument_list|,
name|node
argument_list|,
name|maxLevel
argument_list|,
name|hashVal
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Result:\n"
argument_list|)
expr_stmt|;
name|ShowBytes
argument_list|(
operator|(
name|hashBits
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
name|hashVal
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--------------------------------\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** Output some KAT values. This output is generally re-directed to a file and ** can be compared across platforms to help validate an implementation on a ** new platform (or compare reference vs. optimized code, for example). The ** file will be provided as part of the Skein submission package to NIST. ** ** When used in conjunction with the debug flag, this will output a VERY long ** result. The verbose flag is used to output even more combinations of **<blkSize,hashSize,msgLen> ** ** Note: this function does NOT output the NIST AHS KAT format. */
end_comment

begin_function
name|void
name|Skein_ShowKAT
parameter_list|(
name|uint_t
name|blkSizeMask
parameter_list|)
block|{
enum|enum
block|{
name|DATA_TYPE_ZERO
init|=
literal|0
block|,
name|DATA_TYPE_INC
block|,
name|DATA_TYPE_RAND
block|,
name|DATA_TYPE_MAC
block|,
name|DATA_TYPE_TREE
block|,
name|DATA_TYPE_CNT
block|,
name|MAX_BYTES
init|=
literal|3
operator|*
literal|1024
operator|/
literal|8
block|}
enum|;
specifier|static
specifier|const
name|char
modifier|*
name|TYPE_NAMES
index|[]
init|=
block|{
literal|"zero"
block|,
literal|"incrementing"
block|,
literal|"random"
block|,
literal|"random+MAC"
block|,
literal|"tree"
block|,
name|NULL
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint_t
name|MSG_BITS
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|32
block|,
literal|64
block|,
literal|128
block|,
literal|192
block|,
literal|256
operator|-
literal|1
block|,
literal|256
block|,
literal|256
operator|+
literal|1
block|,
literal|384
block|,
literal|512
operator|-
literal|1
block|,
literal|512
block|,
literal|512
operator|+
literal|1
block|,
literal|768
block|,
literal|1024
operator|-
literal|1
block|,
literal|1024
block|,
literal|1024
operator|+
literal|1
block|,
literal|2048
operator|-
literal|1
block|,
literal|2048
block|,
literal|2048
operator|+
literal|1
block|}
decl_stmt|;
define|#
directive|define
name|MSG_BITS_CNT
value|(sizeof(MSG_BITS)/sizeof(MSG_BITS[0]))
name|uint_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|blkSize
decl_stmt|,
name|dataType
decl_stmt|,
name|hashBits
decl_stmt|,
name|msgBits
decl_stmt|,
name|keyBytes
decl_stmt|,
name|blkBytes
decl_stmt|,
name|keyType
decl_stmt|;
name|u08b_t
name|data
index|[
name|MAX_BYTES
operator|+
literal|4
index|]
decl_stmt|,
name|key
index|[
name|MAX_BYTES
operator|+
literal|4
index|]
decl_stmt|,
name|hashVal
index|[
name|MAX_BYTES
operator|+
literal|4
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgType
decl_stmt|;
name|hashState
name|s
decl_stmt|;
name|Rand_Init
argument_list|(
name|SKEIN_MK_64
argument_list|(
literal|0xDEADBEEF
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* init PRNG with repeatable value */
name|katHash
operator|=
operator|~
literal|0u
expr_stmt|;
name|keyType
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SKEIN_DEBUG
comment|/* first, show some "raw" Threefish + feedforward block calls, with round-by-round debug info if enabled */
if|if
condition|(
name|skein_DebugFlag
operator|&&
operator|!
operator|(
name|verbose
operator|&
name|V_KAT_NO_3FISH
operator|)
condition|)
block|{
name|k
operator|=
name|skein_DebugFlag
expr_stmt|;
comment|/* save debug flag value */
name|skein_DebugFlag
operator|=
name|THREEFISH_DEBUG_ALL
operator|&
operator|~
name|SKEIN_DEBUG_HDR
expr_stmt|;
comment|/* turn on full debug detail, use Threefish name */
name|skein_DebugFlag
operator||=
operator|(
name|k
operator|&
name|SKEIN_DEBUG_PERMUTE
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|verbose
operator|&
name|V_KAT_DO_3FISH
condition|)
comment|/* allow non-SKEIN_DEBUG testing */
block|{
endif|#
directive|endif
for|for
control|(
name|blkSize
operator|=
literal|256
init|;
name|blkSize
operator|<=
literal|1024
condition|;
name|blkSize
operator|*=
literal|2
control|)
block|{
if|if
condition|(
name|blkSizeMask
operator|&&
operator|(
name|blkSize
operator|&
name|blkSizeMask
operator|)
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|dataType
operator|=
name|DATA_TYPE_ZERO
init|;
name|dataType
operator|<=
name|DATA_TYPE_INC
condition|;
name|dataType
operator|++
control|)
block|{
switch|switch
condition|(
name|dataType
condition|)
block|{
case|case
name|DATA_TYPE_ZERO
case|:
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INC
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BYTES
condition|;
name|i
operator|++
control|)
block|{
name|key
index|[
name|i
index|]
operator|=
operator|(
name|u08b_t
operator|)
name|i
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
operator|(
name|u08b_t
operator|)
operator|~
name|key
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
default|default:
continue|continue;
block|}
ifdef|#
directive|ifdef
name|SKEIN_DEBUG
switch|switch
condition|(
name|blkSize
condition|)
block|{
case|case
literal|256
case|:
name|printf
argument_list|(
literal|"\n:Threefish-256: "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|512
case|:
name|printf
argument_list|(
literal|"\n:Threefish-512: "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1024
case|:
name|printf
argument_list|(
literal|"\n:Threefish-1024:"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|" encryption + plaintext feedforward (round-by-round):\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|u
operator|.
name|h
operator|.
name|hashBitLen
operator|=
name|blkSize
expr_stmt|;
name|Skein_Get64_LSB_First
argument_list|(
name|s
operator|.
name|u
operator|.
name|h
operator|.
name|T
argument_list|,
name|key
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* init T[] */
name|Skein_Get64_LSB_First
argument_list|(
name|s
operator|.
name|u
operator|.
name|ctx1024
operator|.
name|X
argument_list|,
name|key
operator|+
literal|2
operator|*
literal|8
argument_list|,
name|blkSize
operator|/
literal|64
argument_list|)
expr_stmt|;
comment|/* init X[] */
switch|switch
condition|(
name|blkSize
condition|)
block|{
case|case
literal|256
case|:
name|Skein_256_Process_Block
argument_list|(
operator|&
name|s
operator|.
name|u
operator|.
name|ctx_256
argument_list|,
name|data
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|512
case|:
name|Skein_512_Process_Block
argument_list|(
operator|&
name|s
operator|.
name|u
operator|.
name|ctx_512
argument_list|,
name|data
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1024
case|:
name|Skein1024_Process_Block
argument_list|(
operator|&
name|s
operator|.
name|u
operator|.
name|ctx1024
argument_list|,
name|data
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|SKEIN_DEBUG
name|printf
argument_list|(
literal|"++++++++++++++++++++++++++++++++++++++\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|SKEIN_DEBUG
name|skein_DebugFlag
operator|=
name|k
expr_stmt|;
endif|#
directive|endif
block|}
for|for
control|(
name|dataType
operator|=
name|DATA_TYPE_ZERO
init|;
name|dataType
operator|<
name|DATA_TYPE_CNT
condition|;
name|dataType
operator|++
control|)
block|{
name|msgType
operator|=
name|TYPE_NAMES
index|[
name|dataType
index|]
expr_stmt|;
switch|switch
condition|(
name|dataType
condition|)
block|{
case|case
name|DATA_TYPE_ZERO
case|:
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INC
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BYTES
condition|;
name|i
operator|++
control|)
block|{
name|key
index|[
name|i
index|]
operator|=
operator|(
name|u08b_t
operator|)
name|i
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
operator|(
name|u08b_t
operator|)
operator|~
name|key
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
case|case
name|DATA_TYPE_MAC
case|:
name|RandBytes
argument_list|(
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|DATA_TYPE_RAND
case|:
name|RandBytes
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_TREE
case|:
if|if
condition|(
name|verbose
operator|&
name|V_KAT_NO_TREE
condition|)
continue|continue;
break|break;
default|default:
comment|/* should never get here */
name|FatalError
argument_list|(
literal|"Invalid data type: %d --> '%s'"
argument_list|,
name|dataType
argument_list|,
name|msgType
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|blkSize
operator|=
literal|256
init|;
name|blkSize
operator|<=
literal|1024
condition|;
name|blkSize
operator|*=
literal|2
control|)
block|{
if|if
condition|(
name|blkSizeMask
operator|&&
operator|(
name|blkSize
operator|&
name|blkSizeMask
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dataType
operator|==
name|DATA_TYPE_TREE
condition|)
block|{
if|#
directive|if
name|SKEIN_TREE_HASH
name|Skein_GenKAT_Tree
argument_list|(
name|blkSize
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|verbose
operator|&
name|V_KAT_NO_SEQ
condition|)
continue|continue;
name|blkBytes
operator|=
name|blkSize
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MSG_BITS_CNT
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|HASH_BITS_CNT
condition|;
name|k
operator|++
control|)
block|{
name|msgBits
operator|=
name|MSG_BITS
index|[
name|j
index|]
expr_stmt|;
comment|/* message length   */
name|hashBits
operator|=
name|HASH_BITS
index|[
name|k
index|]
expr_stmt|;
comment|/* hash result size */
name|assert
argument_list|(
name|MAX_BYTES
operator|*
literal|8
operator|>=
name|hashBits
operator|&&
name|MAX_BYTES
operator|*
literal|8
operator|>=
name|msgBits
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgBits
operator|!=
literal|1024
operator|&&
name|hashBits
operator|!=
name|blkSize
operator|&&
operator|!
operator|(
name|verbose
operator|&
name|V_KAT_LONG
operator|)
condition|)
continue|continue;
comment|/* keep the output size reasonable, unless verbose */
if|if
condition|(
name|verbose
operator|&
name|V_KAT_SHORT
condition|)
block|{
comment|/* -v2 ==> generate "short" KAT set by filtering out most vectors */
if|if
condition|(
name|dataType
operator|!=
name|DATA_TYPE_INC
condition|)
continue|continue;
if|if
condition|(
name|msgBits
operator|!=
literal|8
operator|&&
name|msgBits
operator|!=
name|blkSize
operator|&&
name|msgBits
operator|!=
literal|2
operator|*
name|blkSize
condition|)
continue|continue;
if|if
condition|(
operator|!
name|Short_KAT_OK
argument_list|(
name|blkSize
argument_list|,
name|hashBits
argument_list|)
condition|)
continue|continue;
block|}
switch|switch
condition|(
name|blkSize
condition|)
block|{
case|case
literal|256
case|:
name|printf
argument_list|(
literal|"\n:Skein-256: "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|512
case|:
name|printf
argument_list|(
literal|"\n:Skein-512: "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1024
case|:
name|printf
argument_list|(
literal|"\n:Skein-1024:"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|" %4d-bit hash, msgLen =%6d bits"
argument_list|,
name|hashBits
argument_list|,
name|msgBits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|verbose
operator|&
name|V_KAT_SHORT
operator|)
condition|)
name|printf
argument_list|(
literal|", data = '%s'"
argument_list|,
name|msgType
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\nMessage data:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgBits
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"    (none)\n"
argument_list|)
expr_stmt|;
else|else
name|ShowBytes
argument_list|(
operator|(
name|msgBits
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
name|data
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dataType
condition|)
block|{
default|default:
comment|/* straight hash value */
if|if
condition|(
name|Skein_Hash
argument_list|(
name|blkSize
argument_list|,
name|hashBits
argument_list|,
name|data
argument_list|,
name|msgBits
argument_list|,
name|hashVal
argument_list|)
operator|!=
name|SKEIN_SUCCESS
condition|)
name|FatalError
argument_list|(
literal|"Skein_Hash() error!"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_MAC
case|:
comment|/* include some MAC computations in KAT file */
switch|switch
condition|(
name|keyType
operator|++
condition|)
comment|/* sequence thru different MAC key lengths */
block|{
case|case
literal|0
case|:
name|keyBytes
operator|=
name|blkBytes
operator|/
literal|2
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|keyBytes
operator|=
name|blkBytes
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|keyBytes
operator|=
name|blkBytes
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|keyBytes
operator|=
name|blkBytes
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
name|keyBytes
operator|=
literal|0
expr_stmt|;
comment|/* not actually a MAC this time, but use InitExt() */
name|keyType
operator|=
literal|0
expr_stmt|;
comment|/* start the cycle again next time */
block|}
name|printf
argument_list|(
literal|"MAC key = %4d bytes:\n"
argument_list|,
name|keyBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyBytes
condition|)
comment|/* show MAC key, if any */
name|ShowBytes
argument_list|(
name|keyBytes
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    (none)          /* use InitExt() call */\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Skein_InitExt
argument_list|(
name|blkSize
argument_list|,
operator|&
name|s
argument_list|,
name|hashBits
argument_list|,
name|SKEIN_CFG_TREE_INFO_SEQUENTIAL
argument_list|,
name|key
argument_list|,
name|keyBytes
argument_list|)
operator|!=
name|SKEIN_SUCCESS
condition|)
name|FatalError
argument_list|(
literal|"Skein_InitExt() error!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Skein_Update
argument_list|(
operator|&
name|s
argument_list|,
name|data
argument_list|,
name|msgBits
argument_list|)
operator|!=
name|SKEIN_SUCCESS
condition|)
name|FatalError
argument_list|(
literal|"Skein_Update() error!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Skein_Final
argument_list|(
operator|&
name|s
argument_list|,
name|hashVal
argument_list|)
operator|!=
name|SKEIN_SUCCESS
condition|)
name|FatalError
argument_list|(
literal|"Skein_Final() error!"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_TREE
case|:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"Result:\n"
argument_list|)
expr_stmt|;
name|ShowBytes
argument_list|(
operator|(
name|hashBits
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
name|hashVal
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--------------------------------\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|_quiet_
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"katHash = %08X\n"
argument_list|,
name|katHash
operator|^
literal|0x150183D2
argument_list|)
expr_stmt|;
block|}
comment|/* generate pre-computed IVs for inclusion in Skein C code */
name|void
name|Skein_GenerateIV
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
name|uint_t
name|blkSize
decl_stmt|,
name|hashBits
decl_stmt|;
block|}
name|IV_TAB
index|[]
init|=
comment|/* which pairs to precompute */
block|{
block|{
literal|256
block|,
literal|128
block|}
block|,
block|{
literal|256
block|,
literal|160
block|}
block|,
block|{
literal|256
block|,
literal|224
block|}
block|,
block|{
literal|256
block|,
literal|256
block|}
block|,
block|{
literal|512
block|,
literal|128
block|}
block|,
block|{
literal|512
block|,
literal|160
block|}
block|,
block|{
literal|512
block|,
literal|224
block|}
block|,
block|{
literal|512
block|,
literal|256
block|}
block|,
block|{
literal|512
block|,
literal|384
block|}
block|,
block|{
literal|512
block|,
literal|512
block|}
block|,
block|{
literal|1024
block|,
literal|384
block|}
block|,
block|{
literal|1024
block|,
literal|512
block|}
block|,
block|{
literal|1024
block|,
literal|1024
block|}
block|}
struct|;
name|uint_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|blkSize
decl_stmt|,
name|hashBits
decl_stmt|;
name|hashState
name|state
decl_stmt|;
specifier|const
name|u64b_t
modifier|*
name|w
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|printf
argument_list|(
literal|"#ifndef _SKEIN_IV_H_\n"
literal|"#define _SKEIN_IV_H_\n\n"
literal|"#include \"skein.h\"    /* get Skein macros and types */\n\n"
literal|"/*\n"
literal|"***************** Pre-computed Skein IVs *******************\n"
literal|"**\n"
literal|"** NOTE: these values are not \"magic\" constants, but\n"
literal|"** are generated using the Threefish block function.\n"
literal|"** They are pre-computed here only for speed; i.e., to\n"
literal|"** avoid the need for a Threefish call during Init().\n"
literal|"**\n"
literal|"** The IV for any fixed hash length may be pre-computed.\n"
literal|"** Only the most common values are included here.\n"
literal|"**\n"
literal|"************************************************************\n"
literal|"**/\n\n"
literal|"#define MK_64 SKEIN_MK_64\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|IV_TAB
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|IV_TAB
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|blkSize
operator|=
name|IV_TAB
index|[
name|i
index|]
operator|.
name|blkSize
expr_stmt|;
name|hashBits
operator|=
name|IV_TAB
index|[
name|i
index|]
operator|.
name|hashBits
expr_stmt|;
switch|switch
condition|(
name|blkSize
condition|)
block|{
case|case
literal|256
case|:
name|w
operator|=
name|state
operator|.
name|u
operator|.
name|ctx_256
operator|.
name|X
expr_stmt|;
name|s
operator|=
literal|"_256"
expr_stmt|;
break|break;
case|case
literal|512
case|:
name|w
operator|=
name|state
operator|.
name|u
operator|.
name|ctx_512
operator|.
name|X
expr_stmt|;
name|s
operator|=
literal|"_512"
expr_stmt|;
break|break;
case|case
literal|1024
case|:
name|w
operator|=
name|state
operator|.
name|u
operator|.
name|ctx1024
operator|.
name|X
expr_stmt|;
name|s
operator|=
literal|"1024"
expr_stmt|;
break|break;
default|default:
name|FatalError
argument_list|(
literal|"Invalid blkSize"
argument_list|)
expr_stmt|;
continue|continue;
comment|/* should never happen, but avoids gcc warning */
block|}
if|if
condition|(
name|Skein_Init
argument_list|(
name|blkSize
argument_list|,
operator|&
name|state
argument_list|,
name|hashBits
argument_list|)
operator|!=
name|SKEIN_SUCCESS
condition|)
name|FatalError
argument_list|(
literal|"Error generating IV: blkSize=%d, hashBits=%d"
argument_list|,
name|blkSize
argument_list|,
name|hashBits
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/* blkSize = %4d bits. hashSize = %4d bits */\n"
argument_list|,
name|blkSize
argument_list|,
name|hashBits
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"const u64b_t SKEIN%s_IV_%d[] =\n    {\n"
argument_list|,
name|s
argument_list|,
name|hashBits
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blkSize
operator|/
literal|64
condition|;
name|j
operator|++
control|)
name|printf
argument_list|(
literal|"    MK_64(0x%08X,0x%08X)%s\n"
argument_list|,
call|(
name|uint_32t
call|)
argument_list|(
name|w
index|[
name|j
index|]
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|uint_32t
operator|)
name|w
index|[
name|j
index|]
argument_list|,
operator|(
name|j
operator|+
literal|1
operator|==
name|blkSize
operator|/
literal|64
operator|)
condition|?
literal|""
else|:
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    };\n\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"#endif /* _SKEIN_IV_H_ */\n"
argument_list|)
expr_stmt|;
block|}
comment|/* qsort routine */
name|int
name|compare_uint_32t
parameter_list|(
specifier|const
name|void
modifier|*
name|aPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|bPtr
parameter_list|)
block|{
name|uint_32t
name|a
init|=
operator|*
operator|(
operator|(
name|uint_32t
operator|*
operator|)
name|aPtr
operator|)
decl_stmt|;
name|uint_32t
name|b
init|=
operator|*
operator|(
operator|(
name|uint_32t
operator|*
operator|)
name|bPtr
operator|)
decl_stmt|;
if|if
condition|(
name|a
operator|>
name|b
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|<
name|b
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
name|void
name|ShowCompiler
parameter_list|(
specifier|const
name|char
modifier|*
name|CVER
parameter_list|)
block|{
name|printf
argument_list|(
literal|" //:"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SKEIN_XMM
argument_list|)
name|printf
argument_list|(
literal|" 32-XMM, "
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|" %2u-bit, "
argument_list|,
call|(
name|uint_t
call|)
argument_list|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|COMPILER_ID
argument_list|,
name|CVER
argument_list|)
expr_stmt|;
comment|/* do we need to show unroll amount? */
if|#
directive|if
name|defined
argument_list|(
name|SKEIN_USE_ASM
argument_list|)
operator|&&
name|SKEIN_USE_ASM
name|printf
argument_list|(
literal|" [asm="
argument_list|)
expr_stmt|;
define|#
directive|define
name|_SC_DO_LOOP_
value|(1)
elif|#
directive|elif
name|defined
argument_list|(
name|SKEIN_LOOP
argument_list|)
name|printf
argument_list|(
literal|" [ C ="
argument_list|)
expr_stmt|;
define|#
directive|define
name|_SC_DO_LOOP_
value|(1)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_SC_DO_LOOP_
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|Skein_256_Unroll_Cnt
argument_list|()
operator|)
condition|?
literal|'0'
operator|+
name|Skein_256_Unroll_Cnt
argument_list|()
else|:
literal|'.'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|Skein_512_Unroll_Cnt
argument_list|()
operator|)
condition|?
literal|'0'
operator|+
name|Skein_512_Unroll_Cnt
argument_list|()
else|:
literal|'.'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|Skein1024_Unroll_Cnt
argument_list|()
operator|)
condition|?
literal|'0'
operator|+
name|Skein1024_Unroll_Cnt
argument_list|()
else|:
literal|'.'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* measure the speed (in CPU clks/byte) for a Skein implementation */
name|void
name|Skein_MeasurePerformance
parameter_list|(
specifier|const
name|char
modifier|*
name|target
parameter_list|)
block|{
specifier|const
name|uint_t
name|MSG_BYTES
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|10
block|,
literal|16
block|,
literal|32
block|,
literal|64
block|,
literal|100
block|,
literal|128
block|,
literal|256
block|,
literal|512
block|,
literal|1000
block|,
literal|1024
block|,
literal|2048
block|,
literal|4096
block|,
literal|8192
block|,
literal|10000
block|,
literal|16384
block|,
literal|32768
block|,
literal|100000
block|,
literal|0
block|}
decl_stmt|;
enum|enum
block|{
name|TIMER_SAMPLE_CNT
init|=
literal|13
block|,
name|MAX_BUFFER
init|=
literal|1024
operator|*
literal|100
block|,
name|PERF_TIMEOUT_CLKS
init|=
literal|500000
block|}
enum|;
enum|enum
block|{
name|_256
init|=
literal|256
block|,
name|_512
init|=
literal|512
block|}
enum|;
name|uint_32t
name|dt
index|[
literal|24
index|]
index|[
literal|3
index|]
index|[
name|TIMER_SAMPLE_CNT
index|]
decl_stmt|,
name|t0
decl_stmt|,
name|t1
decl_stmt|;
name|uint_32t
name|dtMin
init|=
operator|~
literal|0u
decl_stmt|;
name|uint_t
name|targetSize
init|=
literal|0
decl_stmt|;
name|uint_t
name|repCnt
init|=
literal|1
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|,
name|r
decl_stmt|,
name|blkSize
decl_stmt|,
name|msgBytes
decl_stmt|;
name|u08b_t
name|b
index|[
name|MAX_BUFFER
index|]
decl_stmt|,
name|hashVal
index|[
name|SKEIN1024_BLOCK_BYTES
operator|*
literal|4
index|]
decl_stmt|;
name|hashState
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|CompilerVersion
name|char
name|CVER
index|[
literal|20
index|]
decl_stmt|;
comment|/* avoid ANSI compiler warnings for sprintf()! :-(( */
name|n
operator|=
name|CompilerVersion
expr_stmt|;
name|CVER
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|CVER
index|[
literal|1
index|]
operator|=
literal|'v'
expr_stmt|;
name|CVER
index|[
literal|2
index|]
operator|=
call|(
name|char
call|)
argument_list|(
literal|'0'
operator|+
operator|(
operator|(
name|n
operator|/
literal|100
operator|)
operator|%
literal|10
operator|)
argument_list|)
expr_stmt|;
name|CVER
index|[
literal|3
index|]
operator|=
literal|'.'
expr_stmt|;
name|CVER
index|[
literal|4
index|]
operator|=
call|(
name|char
call|)
argument_list|(
literal|'0'
operator|+
operator|(
operator|(
name|n
operator|/
literal|10
operator|)
operator|%
literal|10
operator|)
argument_list|)
expr_stmt|;
name|CVER
index|[
literal|5
index|]
operator|=
call|(
name|char
call|)
argument_list|(
literal|'0'
operator|+
operator|(
operator|(
name|n
operator|/
literal|1
operator|)
operator|%
literal|10
operator|)
argument_list|)
expr_stmt|;
name|CVER
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|CVER
value|""
endif|#
directive|endif
if|if
condition|(
name|target
operator|&&
name|target
index|[
literal|0
index|]
condition|)
block|{
name|targetSize
operator|=
name|atoi
argument_list|(
name|target
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|target
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|target
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
block|{
name|repCnt
operator|=
name|atoi
argument_list|(
name|target
operator|+
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|repCnt
operator|==
literal|0
condition|)
name|repCnt
operator|=
literal|1
expr_stmt|;
block|}
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|dt
argument_list|)
operator|/
operator|(
literal|3
operator|*
name|TIMER_SAMPLE_CNT
operator|*
sizeof|sizeof
argument_list|(
name|dt
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|MSG_BYTES
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|MSG_BYTES
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|OS_Set_High_Priority
argument_list|()
condition|)
name|printf
argument_list|(
literal|"Unable to set thread to high priority\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* let things calm down */
name|OS_Sleep
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* let things settle down for a bit */
name|memset
argument_list|(
name|dt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dt
argument_list|)
argument_list|)
expr_stmt|;
name|RandBytes
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* use random data for testing */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|*
name|TIMER_SAMPLE_CNT
condition|;
name|i
operator|++
control|)
comment|/* calibrate the overhead for measuring time */
block|{
name|t0
operator|=
name|HiResTime
argument_list|()
expr_stmt|;
name|t1
operator|=
name|HiResTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|dtMin
operator|>
name|t1
operator|-
name|t0
condition|)
comment|/* keep only the minimum time */
name|dtMin
operator|=
name|t1
operator|-
name|t0
expr_stmt|;
block|}
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|repCnt
condition|;
name|r
operator|++
control|)
block|{
comment|/* first take all the data and store it in dt, with no printf() activity */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|MSG_BYTES
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|MSG_BYTES
index|[
literal|0
index|]
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
name|msgBytes
operator|=
name|MSG_BYTES
index|[
name|n
index|]
expr_stmt|;
comment|/* pick the message size (in bits) */
if|if
condition|(
name|msgBytes
operator|>
name|MAX_BUFFER
operator|||
name|msgBytes
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|targetSize
operator|&&
name|targetSize
operator|!=
name|msgBytes
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|3
condition|;
name|k
operator|++
control|)
block|{
comment|/* cycle thru the different block sizes */
name|blkSize
operator|=
literal|256
operator|<<
name|k
expr_stmt|;
name|t0
operator|=
name|HiResTime
argument_list|()
expr_stmt|;
name|t1
operator|=
name|HiResTime
argument_list|()
expr_stmt|;
define|#
directive|define
name|OneTest
parameter_list|(
name|BITS
parameter_list|)
define|\
value|Skein##BITS##_Init  (&s.u.ctx##BITS,BITS);      \                 Skein##BITS##_Update(&s.u.ctx##BITS,b,msgBytes);\                 Skein##BITS##_Final (&s.u.ctx##BITS,hashVal);
name|OS_Sleep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* yield the time slice to OS */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TIMER_SAMPLE_CNT
condition|;
name|i
operator|++
control|)
block|{
name|HiResTime
argument_list|()
expr_stmt|;
comment|/* prime the pump */
switch|switch
condition|(
name|blkSize
condition|)
block|{
case|case
literal|256
case|:
name|OneTest
argument_list|(
name|_256
argument_list|)
expr_stmt|;
comment|/* prime the pump */
name|t0
operator|=
name|HiResTime
argument_list|()
expr_stmt|;
name|OneTest
argument_list|(
name|_256
argument_list|)
expr_stmt|;
comment|/* do it twice for some averaging */
name|OneTest
argument_list|(
name|_256
argument_list|)
expr_stmt|;
name|t1
operator|=
name|HiResTime
argument_list|()
expr_stmt|;
break|break;
case|case
literal|512
case|:
name|OneTest
argument_list|(
name|_512
argument_list|)
expr_stmt|;
name|t0
operator|=
name|HiResTime
argument_list|()
expr_stmt|;
name|OneTest
argument_list|(
name|_512
argument_list|)
expr_stmt|;
name|OneTest
argument_list|(
name|_512
argument_list|)
expr_stmt|;
name|t1
operator|=
name|HiResTime
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1024
case|:
name|OneTest
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|t0
operator|=
name|HiResTime
argument_list|()
expr_stmt|;
name|OneTest
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|OneTest
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|t1
operator|=
name|HiResTime
argument_list|()
expr_stmt|;
break|break;
block|}
name|dt
index|[
name|n
index|]
index|[
name|k
index|]
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|t1
operator|-
name|t0
operator|)
operator|-
name|dtMin
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* adjust for HiResTime() overhead */
block|}
block|}
block|}
name|OS_Set_Normal_Priority
argument_list|()
expr_stmt|;
if|if
condition|(
name|targetSize
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\nSkein performance, in clks per byte, dtMin = %4d clks.\n"
argument_list|,
name|dtMin
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"         [compiled %s,%s  by  '%s%s', %u-bit]\n"
argument_list|,
name|__TIME__
argument_list|,
name|__DATE__
argument_list|,
name|COMPILER_ID
argument_list|,
name|CVER
argument_list|,
call|(
name|uint_t
call|)
argument_list|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"         =================================================================\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"         ||                       Skein block size                       |\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"         ||--------------------------------------------------------------|\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Message ||       256 bits     |       512 bits     |      1024 bits     |\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Length  ||====================|====================|====================|\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (bytes) ||     min    median  |     min    median  |     min    median  |\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"=========||====================|====================|====================|\n"
argument_list|)
expr_stmt|;
block|}
comment|/* now display the results */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|MSG_BYTES
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|MSG_BYTES
index|[
literal|0
index|]
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
name|msgBytes
operator|=
name|MSG_BYTES
index|[
name|n
index|]
expr_stmt|;
comment|/* pick the message size (in bits) */
if|if
condition|(
name|msgBytes
operator|>
name|MAX_BUFFER
operator|||
name|msgBytes
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|targetSize
operator|&&
name|targetSize
operator|!=
name|msgBytes
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%7d_ ||"
argument_list|,
name|msgBytes
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|3
condition|;
name|k
operator|++
control|)
comment|/* cycle thru the different Skein block sizes */
block|{
comment|/* here with dt[n][k][] full of time differences */
comment|/* discard high/low, then show min/median of the rest, in clks/byte */
name|qsort
argument_list|(
name|dt
index|[
name|n
index|]
index|[
name|k
index|]
argument_list|,
name|TIMER_SAMPLE_CNT
argument_list|,
sizeof|sizeof
argument_list|(
name|dt
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|compare_uint_32t
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %8.2f %8.2f  |"
argument_list|,
name|dt
index|[
name|n
index|]
index|[
name|k
index|]
index|[
literal|1
index|]
operator|/
operator|(
name|double
operator|)
name|msgBytes
argument_list|,
name|dt
index|[
name|n
index|]
index|[
name|k
index|]
index|[
name|TIMER_SAMPLE_CNT
operator|/
literal|2
index|]
operator|/
operator|(
name|double
operator|)
name|msgBytes
argument_list|)
expr_stmt|;
block|}
name|ShowCompiler
argument_list|(
name|CVER
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetSize
operator|==
literal|0
operator|&&
name|target
operator|&&
name|target
index|[
literal|0
index|]
operator|&&
name|repCnt
operator|==
literal|1
condition|)
block|{
comment|/* show the details */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|3
condition|;
name|k
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%4d: "
argument_list|,
literal|256
operator|<<
name|k
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TIMER_SAMPLE_CNT
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%8d"
argument_list|,
name|dt
index|[
name|n
index|]
index|[
name|k
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|SKEIN_CODE_SIZE
argument_list|)
operator|||
name|defined
argument_list|(
name|SKEIN_PERF
argument_list|)
if|if
condition|(
name|targetSize
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"=========||====================|====================|====================|\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Code Size||                    |                    |                    |\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"=========||====================|====================|====================|\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    API  || %12d bytes | %12d bytes | %12d bytes |"
argument_list|,
operator|(
name|int
operator|)
name|Skein_256_API_CodeSize
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|Skein_512_API_CodeSize
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|Skein1024_API_CodeSize
argument_list|()
argument_list|)
expr_stmt|;
name|ShowCompiler
argument_list|(
name|CVER
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Block  || %12d bytes | %12d bytes | %12d bytes |"
argument_list|,
operator|(
name|int
operator|)
name|Skein_256_Process_Block_CodeSize
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|Skein_512_Process_Block_CodeSize
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|Skein1024_Process_Block_CodeSize
argument_list|()
argument_list|)
expr_stmt|;
name|ShowCompiler
argument_list|(
name|CVER
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|void
name|GiveHelp
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Syntax:  skein_test [options]\n"
literal|"Options: -bNN  = set Skein block size to NN bits\n"
literal|"         -lNN  = set max test length  to NN bits\n"
literal|"         -tNN  = set Skein hash length to NN bits\n"
literal|"         -sNN  = set initial random seed\n"
literal|"         -g    = generate precomputed IV values to stdout\n"
literal|"         -k    = output KAT results to stdout\n"
literal|"         -p    = output performance (clks/byte)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|uint_t
name|testCnt
decl_stmt|;
name|uint_t
name|doKAT
init|=
literal|0
decl_stmt|;
comment|/* generate KAT vectors?    */
name|uint_t
name|blkSize
init|=
literal|0
decl_stmt|;
comment|/* Skein state size in bits */
name|uint_t
name|maxLen
init|=
literal|1024
decl_stmt|;
comment|/* max block size   in bits */
name|uint_t
name|hashLen
init|=
literal|0
decl_stmt|;
comment|/* hash length      in bits (0 --> all) */
name|uint_t
name|seed0
init|=
operator|(
name|uint_t
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
comment|/* randomize based on time */
name|uint_t
name|oneBlk
init|=
literal|0
decl_stmt|;
comment|/* test block size */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* process command-line switches */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|toupper
argument_list|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
literal|'?'
case|:
name|GiveHelp
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|blkSize
operator||=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|maxLen
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|seed0
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|hashLen
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|doKAT
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|verbose
operator||=
operator|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|)
condition|?
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
else|:
name|V_KAT_LONG
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|Skein_GenerateIV
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'P'
case|:
name|Skein_MeasurePerformance
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'Q'
case|:
name|_quiet_
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
switch|switch
condition|(
name|toupper
argument_list|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SKEIN_DEBUG
case|case
literal|0
case|:
name|skein_DebugFlag
operator||=
name|SKEIN_DEBUG_DEFAULT
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|skein_DebugFlag
operator||=
name|SKEIN_DEBUG_SHORT
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|skein_DebugFlag
operator||=
name|SKEIN_DEBUG_ALL
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|skein_DebugFlag
operator||=
name|SKEIN_DEBUG_PERMUTE
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|skein_DebugFlag
operator||=
name|SKEIN_DEBUG_SHORT
operator||
name|SKEIN_DEBUG_INJECT
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|skein_DebugFlag
operator||=
name|SKEIN_DEBUG_SHORT
operator|&
operator|~
name|SKEIN_DEBUG_CONFIG
expr_stmt|;
break|break;
endif|#
directive|endif
default|default :
name|skein_DebugFlag
operator||=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|FatalError
argument_list|(
literal|"Unsupported command-line option: %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
name|GiveHelp
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
name|oneBlk
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|blkSize
operator|==
literal|0
condition|)
comment|/* default is all block sizes */
name|blkSize
operator|=
literal|256
operator||
literal|512
operator||
literal|1024
expr_stmt|;
if|if
condition|(
name|doKAT
condition|)
block|{
name|Skein_ShowKAT
argument_list|(
name|blkSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|oneBlk
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Seed0 = %d. Compiler = %s\n"
argument_list|,
name|seed0
argument_list|,
name|COMPILER_ID
argument_list|)
expr_stmt|;
name|Rand_Init
argument_list|(
name|SKEIN_MK_64
argument_list|(
literal|0xDEADBEEF
argument_list|,
name|seed0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* init PRNG for test data */
name|testCnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|256
init|;
name|i
operator|<=
literal|1024
condition|;
name|i
operator|*=
literal|2
control|)
block|{
if|if
condition|(
name|blkSize
operator|&
name|i
condition|)
block|{
if|if
condition|(
name|hashLen
operator|==
literal|0
condition|)
comment|/* use all hash sizes? */
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HASH_BITS_CNT
condition|;
name|n
operator|++
control|)
name|testCnt
operator|+=
name|Skein_Test
argument_list|(
name|i
argument_list|,
name|maxLen
argument_list|,
name|HASH_BITS
index|[
name|n
index|]
argument_list|,
literal|0
argument_list|,
name|oneBlk
argument_list|)
expr_stmt|;
block|}
else|else
name|testCnt
operator|+=
name|Skein_Test
argument_list|(
name|i
argument_list|,
name|maxLen
argument_list|,
name|hashLen
argument_list|,
literal|0
argument_list|,
name|oneBlk
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oneBlk
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|testCnt
condition|)
name|printf
argument_list|(
literal|"Success: %4d tests\n"
argument_list|,
name|testCnt
argument_list|)
expr_stmt|;
block|}
comment|/* do a quick final self-consistentcy check test to make sure nothing is broken */
name|skein_DebugFlag
operator|=
literal|0
expr_stmt|;
comment|/* no debug output here */
for|for
control|(
name|blkSize
operator|=
literal|256
init|;
name|blkSize
operator|<=
literal|1024
condition|;
name|blkSize
operator|*=
literal|2
control|)
block|{
name|Skein_Test
argument_list|(
name|blkSize
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

