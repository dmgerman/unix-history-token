begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * SCSI Disk Emulator  *  * Copyright (c) 2002 Nate Lawson.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<aio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_queue.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_targetio.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|"scsi_target.h"
end_include

begin_comment
comment|/* Maximum amount to transfer per CTIO */
end_comment

begin_define
define|#
directive|define
name|MAX_XFER
value|MAXPHYS
end_define

begin_comment
comment|/* Maximum number of allocated CTIOs */
end_comment

begin_define
define|#
directive|define
name|MAX_CTIOS
value|64
end_define

begin_comment
comment|/* Maximum sector size for emulated volume */
end_comment

begin_define
define|#
directive|define
name|MAX_SECTOR
value|32768
end_define

begin_comment
comment|/* Global variables */
end_comment

begin_decl_stmt
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|notaio
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|off_t
name|volume_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|sector_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|buf_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local variables */
end_comment

begin_decl_stmt
specifier|static
name|int
name|targ_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kq_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|file_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_ctios
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ccb_queue
name|pending_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ccb_queue
name|work_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ioc_enable_lun
name|ioc_enlun
init|=
block|{
name|CAM_BUS_WILDCARD
block|,
name|CAM_TARGET_WILDCARD
block|,
name|CAM_LUN_WILDCARD
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|cleanup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|init_ccbs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|request_loop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_read
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* static int		work_atio(struct ccb_accept_tio *); */
end_comment

begin_function_decl
specifier|static
name|void
name|queue_io
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|run_queue
parameter_list|(
name|struct
name|ccb_accept_tio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|work_inot
parameter_list|(
name|struct
name|ccb_immed_notify
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ccb_scsiio
modifier|*
name|get_ctio
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* static void		free_ccb(union ccb *); */
end_comment

begin_function_decl
specifier|static
name|cam_status
name|get_sim_flags
parameter_list|(
name|u_int16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rel_simq
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|abort_all_pending
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|ch
decl_stmt|,
name|unit
decl_stmt|;
name|char
modifier|*
name|file_name
decl_stmt|,
name|targname
index|[
literal|16
index|]
decl_stmt|;
name|u_int16_t
name|req_flags
decl_stmt|,
name|sim_flags
decl_stmt|;
name|off_t
name|user_size
decl_stmt|;
comment|/* Initialize */
name|debug
operator|=
literal|0
expr_stmt|;
name|req_flags
operator|=
name|sim_flags
operator|=
literal|0
expr_stmt|;
name|user_size
operator|=
literal|0
expr_stmt|;
name|targ_fd
operator|=
name|file_fd
operator|=
name|kq_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|num_ctios
operator|=
literal|0
expr_stmt|;
name|sector_size
operator|=
name|SECTOR_SIZE
expr_stmt|;
name|buf_size
operator|=
name|DFLTPHYS
expr_stmt|;
comment|/* Prepare resource pools */
name|TAILQ_INIT
argument_list|(
operator|&
name|pending_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|work_queue
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"AdSTYb:c:s:W:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'A'
case|:
name|req_flags
operator||=
name|SID_Addr16
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|req_flags
operator||=
name|SID_Sync
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|req_flags
operator||=
name|SID_CmdQue
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|buf_size
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_size
operator|<
literal|256
operator|||
name|buf_size
operator|>
name|MAX_XFER
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unreasonable buf size: %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|sector_size
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sector_size
operator|<
literal|512
operator|||
name|sector_size
operator|>
name|MAX_SECTOR
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unreasonable sector size: %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
block|{
name|int
name|last
decl_stmt|,
name|shift
init|=
literal|0
decl_stmt|;
name|last
operator|=
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|last
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|tolower
argument_list|(
name|optarg
index|[
name|last
index|]
argument_list|)
condition|)
block|{
case|case
literal|'e'
case|:
name|shift
operator|+=
literal|10
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'p'
case|:
name|shift
operator|+=
literal|10
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'t'
case|:
name|shift
operator|+=
literal|10
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'g'
case|:
name|shift
operator|+=
literal|10
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'m'
case|:
name|shift
operator|+=
literal|10
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'k'
case|:
name|shift
operator|+=
literal|10
expr_stmt|;
name|optarg
index|[
name|last
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|user_size
operator|=
name|strtoll
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
comment|/*base*/
literal|10
argument_list|)
expr_stmt|;
name|user_size
operator|<<=
name|shift
expr_stmt|;
if|if
condition|(
name|user_size
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unreasonable volume size: %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'W'
case|:
name|req_flags
operator|&=
operator|~
operator|(
name|SID_WBus16
operator||
name|SID_WBus32
operator|)
expr_stmt|;
switch|switch
condition|(
name|atoi
argument_list|(
name|optarg
argument_list|)
condition|)
block|{
case|case
literal|8
case|:
comment|/* Leave req_flags zeroed */
break|break;
case|case
literal|16
case|:
name|req_flags
operator||=
name|SID_WBus16
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|req_flags
operator||=
name|SID_WBus32
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"Width %s not supported"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
break|break;
case|case
literal|'Y'
case|:
name|notaio
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
name|sscanf
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"%u:%u:%u"
argument_list|,
operator|&
name|ioc_enlun
operator|.
name|path_id
argument_list|,
operator|&
name|ioc_enlun
operator|.
name|target_id
argument_list|,
operator|&
name|ioc_enlun
operator|.
name|lun_id
argument_list|)
expr_stmt|;
name|file_name
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ioc_enlun
operator|.
name|path_id
operator|==
name|CAM_BUS_WILDCARD
operator|||
name|ioc_enlun
operator|.
name|target_id
operator|==
name|CAM_TARGET_WILDCARD
operator|||
name|ioc_enlun
operator|.
name|lun_id
operator|==
name|CAM_LUN_WILDCARD
condition|)
block|{
name|warnx
argument_list|(
literal|"Incomplete target path specified"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* We don't support any vendor-specific commands */
name|ioc_enlun
operator|.
name|grp6_len
operator|=
literal|0
expr_stmt|;
name|ioc_enlun
operator|.
name|grp7_len
operator|=
literal|0
expr_stmt|;
comment|/* Open backing store for IO */
name|file_fd
operator|=
name|open
argument_list|(
name|file_name
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_fd
operator|<
literal|0
condition|)
name|errx
argument_list|(
name|EX_NOINPUT
argument_list|,
literal|"open backing store file"
argument_list|)
expr_stmt|;
comment|/* Check backing store size or use the size user gave us */
if|if
condition|(
name|user_size
operator|==
literal|0
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|file_fd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fstat file"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFCHR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* raw device */
name|off_t
name|mediasize
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|file_fd
argument_list|,
name|DIOCGMEDIASIZE
argument_list|,
operator|&
name|mediasize
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGMEDIASIZE"
argument_list|)
expr_stmt|;
comment|/* XXX get sector size by ioctl()?? */
name|volume_size
operator|=
name|mediasize
operator|/
name|sector_size
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|volume_size
operator|=
name|st
operator|.
name|st_size
operator|/
name|sector_size
expr_stmt|;
block|}
else|else
block|{
name|volume_size
operator|=
name|user_size
operator|/
name|sector_size
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|warnx
argument_list|(
literal|"volume_size: %d bytes x "
name|OFF_FMT
literal|" sectors"
argument_list|,
name|sector_size
argument_list|,
name|volume_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|volume_size
operator|<=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"volume must be larger than %d"
argument_list|,
name|sector_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|notaio
operator|==
literal|0
condition|)
block|{
name|struct
name|aiocb
name|aio
decl_stmt|,
modifier|*
name|aiop
decl_stmt|;
comment|/* See if we have we have working AIO support */
name|memset
argument_list|(
operator|&
name|aio
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|aio
argument_list|)
argument_list|)
expr_stmt|;
name|aio
operator|.
name|aio_buf
operator|=
name|malloc
argument_list|(
name|sector_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio
operator|.
name|aio_buf
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|aio
operator|.
name|aio_fildes
operator|=
name|file_fd
expr_stmt|;
name|aio
operator|.
name|aio_offset
operator|=
literal|0
expr_stmt|;
name|aio
operator|.
name|aio_nbytes
operator|=
name|sector_size
expr_stmt|;
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio_read
argument_list|(
operator|&
name|aio
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"AIO support is not available- switchin to"
literal|" single-threaded mode.\n"
argument_list|)
expr_stmt|;
name|notaio
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aio_waitcomplete
argument_list|(
operator|&
name|aiop
argument_list|,
name|NULL
argument_list|)
operator|!=
name|sector_size
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"aio_waitcomplete"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|aiop
operator|==
operator|&
name|aio
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|aio
operator|.
name|aio_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&&
name|notaio
operator|==
literal|0
condition|)
name|warnx
argument_list|(
literal|"aio support tested ok"
argument_list|)
expr_stmt|;
block|}
comment|/* Go through all the control devices and find one that isn't busy. */
name|unit
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|snprintf
argument_list|(
name|targname
argument_list|,
sizeof|sizeof
argument_list|(
name|targname
argument_list|)
argument_list|,
literal|"/dev/targ%d"
argument_list|,
name|unit
operator|++
argument_list|)
expr_stmt|;
name|targ_fd
operator|=
name|open
argument_list|(
name|targname
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|targ_fd
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EBUSY
condition|)
do|;
if|if
condition|(
name|targ_fd
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Tried to open %d devices, none available"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"opened %s"
argument_list|,
name|targname
argument_list|)
expr_stmt|;
comment|/* The first three are handled by kevent() later */
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPROF
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSTOP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* Register a cleanup handler to run when exiting */
name|atexit
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
comment|/* Enable listening on the specified LUN */
if|if
condition|(
name|ioctl
argument_list|(
name|targ_fd
argument_list|,
name|TARGIOCENABLE
argument_list|,
operator|&
name|ioc_enlun
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"TARGIOCENABLE"
argument_list|)
expr_stmt|;
comment|/* Enable debugging if requested */
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|targ_fd
argument_list|,
name|TARGIOCDEBUG
argument_list|,
operator|&
name|debug
argument_list|)
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"TARGIOCDEBUG"
argument_list|)
expr_stmt|;
block|}
comment|/* Set up inquiry data according to what SIM supports */
if|if
condition|(
name|get_sim_flags
argument_list|(
operator|&
name|sim_flags
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"get_sim_flags"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcmd_init
argument_list|(
name|req_flags
argument_list|,
name|sim_flags
argument_list|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Initializing tcmd subsystem failed"
argument_list|)
expr_stmt|;
comment|/* Queue ATIOs and INOTs on descriptor */
if|if
condition|(
name|init_ccbs
argument_list|()
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"init_ccbs failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|warnx
argument_list|(
literal|"main loop beginning"
argument_list|)
expr_stmt|;
name|request_loop
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|warnx
argument_list|(
literal|"cleanup called"
argument_list|)
expr_stmt|;
name|debug
operator|=
literal|0
expr_stmt|;
name|ioctl
argument_list|(
name|targ_fd
argument_list|,
name|TARGIOCDEBUG
argument_list|,
operator|&
name|debug
argument_list|)
expr_stmt|;
block|}
name|ioctl
argument_list|(
name|targ_fd
argument_list|,
name|TARGIOCDISABLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|targ_fd
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ccb_h
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pending_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pending_queue
argument_list|,
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|free_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ccb_h
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|work_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|work_queue
argument_list|,
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|free_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kq_fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|kq_fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate ATIOs/INOTs and queue on HBA */
end_comment

begin_function
specifier|static
name|int
name|init_ccbs
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_INITIATORS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|atio_descr
modifier|*
name|a_descr
decl_stmt|;
name|struct
name|ccb_immed_notify
modifier|*
name|inot
decl_stmt|;
name|atio
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|atio
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|atio
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"malloc ATIO"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|a_descr
operator|=
operator|(
expr|struct
name|atio_descr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|a_descr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_descr
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|atio
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"malloc atio_descr"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|atio
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ACCEPT_TARGET_IO
expr_stmt|;
name|atio
operator|->
name|ccb_h
operator|.
name|targ_descr
operator|=
name|a_descr
expr_stmt|;
name|send_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|inot
operator|=
operator|(
expr|struct
name|ccb_immed_notify
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|inot
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inot
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"malloc INOT"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|inot
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_IMMED_NOTIFY
expr_stmt|;
name|send_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|inot
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|request_loop
parameter_list|()
block|{
name|struct
name|kevent
name|events
index|[
name|MAX_EVENTS
index|]
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|,
modifier|*
name|tptr
decl_stmt|;
name|int
name|quit
decl_stmt|;
comment|/* Register kqueue for event notification */
if|if
condition|(
operator|(
name|kq_fd
operator|=
name|kqueue
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"init kqueue"
argument_list|)
expr_stmt|;
comment|/* Set up some default events */
name|EV_SET
argument_list|(
operator|&
name|events
index|[
literal|0
index|]
argument_list|,
name|SIGHUP
argument_list|,
name|EVFILT_SIGNAL
argument_list|,
name|EV_ADD
operator||
name|EV_ENABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EV_SET
argument_list|(
operator|&
name|events
index|[
literal|1
index|]
argument_list|,
name|SIGINT
argument_list|,
name|EVFILT_SIGNAL
argument_list|,
name|EV_ADD
operator||
name|EV_ENABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EV_SET
argument_list|(
operator|&
name|events
index|[
literal|2
index|]
argument_list|,
name|SIGTERM
argument_list|,
name|EVFILT_SIGNAL
argument_list|,
name|EV_ADD
operator||
name|EV_ENABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EV_SET
argument_list|(
operator|&
name|events
index|[
literal|3
index|]
argument_list|,
name|targ_fd
argument_list|,
name|EVFILT_READ
argument_list|,
name|EV_ADD
operator||
name|EV_ENABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|kevent
argument_list|(
name|kq_fd
argument_list|,
name|events
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"kevent signal registration"
argument_list|)
expr_stmt|;
name|ts
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|tptr
operator|=
name|NULL
expr_stmt|;
name|quit
operator|=
literal|0
expr_stmt|;
comment|/* Loop until user signal */
while|while
condition|(
name|quit
operator|==
literal|0
condition|)
block|{
name|int
name|retval
decl_stmt|,
name|i
decl_stmt|,
name|oo
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
comment|/* Check for the next signal, read ready, or AIO completion */
name|retval
operator|=
name|kevent
argument_list|(
name|kq_fd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|events
argument_list|,
name|MAX_EVENTS
argument_list|,
name|tptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|warnx
argument_list|(
literal|"EINTR, looping"
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"kevent failed"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|retval
operator|>
name|MAX_EVENTS
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"kevent returned more events than allocated?"
argument_list|)
expr_stmt|;
block|}
comment|/* Process all received events. */
for|for
control|(
name|oo
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|retval
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|events
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|EV_ERROR
operator|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"kevent registration failed"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|events
index|[
name|i
index|]
operator|.
name|filter
condition|)
block|{
case|case
name|EVFILT_READ
case|:
if|if
condition|(
name|debug
condition|)
name|warnx
argument_list|(
literal|"read ready"
argument_list|)
expr_stmt|;
name|handle_read
argument_list|()
expr_stmt|;
break|break;
case|case
name|EVFILT_AIO
case|:
block|{
name|struct
name|ccb_scsiio
modifier|*
name|ctio
decl_stmt|;
name|struct
name|ctio_descr
modifier|*
name|c_descr
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|warnx
argument_list|(
literal|"aio ready"
argument_list|)
expr_stmt|;
name|ctio
operator|=
operator|(
expr|struct
name|ccb_scsiio
operator|*
operator|)
name|events
index|[
name|i
index|]
operator|.
name|udata
expr_stmt|;
name|c_descr
operator|=
operator|(
expr|struct
name|ctio_descr
operator|*
operator|)
name|ctio
operator|->
name|ccb_h
operator|.
name|targ_descr
expr_stmt|;
name|c_descr
operator|->
name|event
operator|=
name|AIO_DONE
expr_stmt|;
comment|/* Queue on the appropriate ATIO */
name|queue_io
argument_list|(
name|ctio
argument_list|)
expr_stmt|;
comment|/* Process any queued completions. */
name|oo
operator|+=
name|run_queue
argument_list|(
name|c_descr
operator|->
name|atio
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|EVFILT_SIGNAL
case|:
if|if
condition|(
name|debug
condition|)
name|warnx
argument_list|(
literal|"signal ready, setting quit"
argument_list|)
expr_stmt|;
name|quit
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"unknown event %d"
argument_list|,
name|events
index|[
name|i
index|]
operator|.
name|filter
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|debug
condition|)
name|warnx
argument_list|(
literal|"event %d done"
argument_list|,
name|events
index|[
name|i
index|]
operator|.
name|filter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oo
condition|)
block|{
name|tptr
operator|=
operator|&
name|ts
expr_stmt|;
continue|continue;
block|}
comment|/* Grab the first CCB and perform one work unit. */
if|if
condition|(
operator|(
name|ccb_h
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|work_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
expr_stmt|;
switch|switch
condition|(
name|ccb_h
operator|->
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Start one more transfer. */
name|retval
operator|=
name|work_atio
argument_list|(
operator|&
name|ccb
operator|->
name|atio
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_IMMED_NOTIFY
case|:
name|retval
operator|=
name|work_inot
argument_list|(
operator|&
name|ccb
operator|->
name|cin
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"Unhandled ccb type %#x on workq"
argument_list|,
name|ccb_h
operator|->
name|func_code
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* Assume work function handled the exception */
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|warnx
argument_list|(
literal|"Queue frozen receiving CCB, "
literal|"releasing"
argument_list|)
expr_stmt|;
block|}
name|rel_simq
argument_list|()
expr_stmt|;
block|}
comment|/* No more work needed for this command. */
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|work_queue
argument_list|,
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Poll for new events (i.e. completions) while we 		 * are processing CCBs on the work_queue. Once it's 		 * empty, use an infinite wait. 		 */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|work_queue
argument_list|)
condition|)
name|tptr
operator|=
operator|&
name|ts
expr_stmt|;
else|else
name|tptr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* CCBs are ready from the kernel */
end_comment

begin_function
specifier|static
name|void
name|handle_read
parameter_list|()
block|{
name|union
name|ccb
modifier|*
name|ccb_array
index|[
name|MAX_INITIATORS
index|]
decl_stmt|,
modifier|*
name|ccb
decl_stmt|;
name|int
name|ccb_count
decl_stmt|,
name|i
decl_stmt|,
name|oo
decl_stmt|;
name|ccb_count
operator|=
name|read
argument_list|(
name|targ_fd
argument_list|,
name|ccb_array
argument_list|,
sizeof|sizeof
argument_list|(
name|ccb_array
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb_count
operator|<=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"read ccb ptrs"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb_count
operator|/=
sizeof|sizeof
argument_list|(
expr|union
name|ccb
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb_count
operator|<
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"truncated read ccb ptr?"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccb_count
condition|;
name|i
operator|++
control|)
block|{
name|ccb
operator|=
name|ccb_array
index|[
name|i
index|]
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pending_queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
block|{
name|struct
name|ccb_accept_tio
modifier|*
name|atio
decl_stmt|;
name|struct
name|atio_descr
modifier|*
name|a_descr
decl_stmt|;
comment|/* Initialize ATIO descr for this transaction */
name|atio
operator|=
operator|&
name|ccb
operator|->
name|atio
expr_stmt|;
name|a_descr
operator|=
operator|(
expr|struct
name|atio_descr
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|targ_descr
expr_stmt|;
name|bzero
argument_list|(
name|a_descr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a_descr
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|a_descr
operator|->
name|cmplt_io
argument_list|)
expr_stmt|;
name|a_descr
operator|->
name|flags
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
operator|(
name|CAM_DIS_DISCONNECT
operator||
name|CAM_TAG_ACTION_VALID
operator|)
expr_stmt|;
comment|/* XXX add a_descr->priority */
if|if
condition|(
operator|(
name|atio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|==
literal|0
condition|)
name|a_descr
operator|->
name|cdb
operator|=
name|atio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
else|else
name|a_descr
operator|->
name|cdb
operator|=
name|atio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
expr_stmt|;
comment|/* ATIOs are processed in FIFO order */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|work_queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CONT_TARGET_IO
case|:
block|{
name|struct
name|ccb_scsiio
modifier|*
name|ctio
decl_stmt|;
name|struct
name|ctio_descr
modifier|*
name|c_descr
decl_stmt|;
name|ctio
operator|=
operator|&
name|ccb
operator|->
name|ctio
expr_stmt|;
name|c_descr
operator|=
operator|(
expr|struct
name|ctio_descr
operator|*
operator|)
name|ctio
operator|->
name|ccb_h
operator|.
name|targ_descr
expr_stmt|;
name|c_descr
operator|->
name|event
operator|=
name|CTIO_DONE
expr_stmt|;
comment|/* Queue on the appropriate ATIO */
name|queue_io
argument_list|(
name|ctio
argument_list|)
expr_stmt|;
comment|/* Process any queued completions. */
name|oo
operator|+=
name|run_queue
argument_list|(
name|c_descr
operator|->
name|atio
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_IMMED_NOTIFY
case|:
comment|/* INOTs are handled with priority */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|work_queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"Unhandled ccb type %#x in handle_read"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Process an ATIO CCB from the kernel */
end_comment

begin_function
name|int
name|work_atio
parameter_list|(
name|struct
name|ccb_accept_tio
modifier|*
name|atio
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|ctio
decl_stmt|;
name|struct
name|atio_descr
modifier|*
name|a_descr
decl_stmt|;
name|struct
name|ctio_descr
modifier|*
name|c_descr
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|warnx
argument_list|(
literal|"Working on ATIO %p"
argument_list|,
name|atio
argument_list|)
expr_stmt|;
name|a_descr
operator|=
operator|(
expr|struct
name|atio_descr
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|targ_descr
expr_stmt|;
comment|/* Get a CTIO and initialize it according to our known parameters */
name|ctio
operator|=
name|get_ctio
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctio
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|ctio
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|a_descr
operator|->
name|flags
expr_stmt|;
name|ctio
operator|->
name|tag_id
operator|=
name|atio
operator|->
name|tag_id
expr_stmt|;
name|ctio
operator|->
name|init_id
operator|=
name|atio
operator|->
name|init_id
expr_stmt|;
comment|/* XXX priority needs to be added to a_descr */
name|c_descr
operator|=
operator|(
expr|struct
name|ctio_descr
operator|*
operator|)
name|ctio
operator|->
name|ccb_h
operator|.
name|targ_descr
expr_stmt|;
name|c_descr
operator|->
name|atio
operator|=
name|atio
expr_stmt|;
if|if
condition|(
operator|(
name|a_descr
operator|->
name|flags
operator|&
name|CAM_DIR_IN
operator|)
operator|!=
literal|0
condition|)
name|c_descr
operator|->
name|offset
operator|=
name|a_descr
operator|->
name|base_off
operator|+
name|a_descr
operator|->
name|targ_req
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|a_descr
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
name|c_descr
operator|->
name|offset
operator|=
name|a_descr
operator|->
name|base_off
operator|+
name|a_descr
operator|->
name|init_req
expr_stmt|;
else|else
name|c_descr
operator|->
name|offset
operator|=
name|a_descr
operator|->
name|base_off
expr_stmt|;
comment|/*  	 * Return a check condition if there was an error while 	 * receiving this ATIO. 	 */
if|if
condition|(
name|atio
operator|->
name|sense_len
operator|!=
literal|0
condition|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|warnx
argument_list|(
literal|"ATIO with %u bytes sense received"
argument_list|,
name|atio
operator|->
name|sense_len
argument_list|)
expr_stmt|;
block|}
name|sense
operator|=
operator|&
name|atio
operator|->
name|sense_data
expr_stmt|;
name|tcmd_sense
argument_list|(
name|ctio
operator|->
name|init_id
argument_list|,
name|ctio
argument_list|,
name|sense
operator|->
name|flags
argument_list|,
name|sense
operator|->
name|add_sense_code
argument_list|,
name|sense
operator|->
name|add_sense_code_qual
argument_list|)
expr_stmt|;
name|send_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ctio
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|status
operator|=
name|atio
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CAM_CDB_RECVD
case|:
name|ret
operator|=
name|tcmd_handle
argument_list|(
name|atio
argument_list|,
name|ctio
argument_list|,
name|ATIO_WORK
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAM_REQ_ABORTED
case|:
name|warn
argument_list|(
literal|"ATIO %p aborted"
argument_list|,
name|a_descr
argument_list|)
expr_stmt|;
comment|/* Requeue on HBA */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|work_queue
argument_list|,
operator|&
name|atio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|send_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"ATIO completed with unhandled status %#x"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|queue_io
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|ctio
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|struct
name|io_queue
modifier|*
name|ioq
decl_stmt|;
name|struct
name|ctio_descr
modifier|*
name|c_descr
decl_stmt|;
name|c_descr
operator|=
operator|(
expr|struct
name|ctio_descr
operator|*
operator|)
name|ctio
operator|->
name|ccb_h
operator|.
name|targ_descr
expr_stmt|;
if|if
condition|(
name|c_descr
operator|->
name|atio
operator|==
name|NULL
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"CTIO %p has NULL ATIO"
argument_list|,
name|ctio
argument_list|)
expr_stmt|;
block|}
name|ioq
operator|=
operator|&
operator|(
operator|(
expr|struct
name|atio_descr
operator|*
operator|)
name|c_descr
operator|->
name|atio
operator|->
name|ccb_h
operator|.
name|targ_descr
operator|)
operator|->
name|cmplt_io
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
name|ioq
argument_list|)
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
name|ioq
argument_list|,
operator|&
name|ctio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
return|return;
block|}
name|TAILQ_FOREACH_REVERSE
argument_list|(
argument|ccb_h
argument_list|,
argument|ioq
argument_list|,
argument|io_queue
argument_list|,
argument|periph_links.tqe
argument_list|)
block|{
name|struct
name|ctio_descr
modifier|*
name|curr_descr
init|=
operator|(
expr|struct
name|ctio_descr
operator|*
operator|)
name|ccb_h
operator|->
name|targ_descr
decl_stmt|;
if|if
condition|(
name|curr_descr
operator|->
name|offset
operator|<=
name|c_descr
operator|->
name|offset
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|ccb_h
condition|)
block|{
name|TAILQ_INSERT_AFTER
argument_list|(
name|ioq
argument_list|,
name|ccb_h
argument_list|,
operator|&
name|ctio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
name|ioq
argument_list|,
operator|&
name|ctio
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Go through all completed AIO/CTIOs for a given ATIO and advance data  * counts, start continuation IO, etc.  */
end_comment

begin_function
specifier|static
name|int
name|run_queue
parameter_list|(
name|struct
name|ccb_accept_tio
modifier|*
name|atio
parameter_list|)
block|{
name|struct
name|atio_descr
modifier|*
name|a_descr
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|int
name|sent_status
decl_stmt|,
name|event
decl_stmt|;
if|if
condition|(
name|atio
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|a_descr
operator|=
operator|(
expr|struct
name|atio_descr
operator|*
operator|)
name|atio
operator|->
name|ccb_h
operator|.
name|targ_descr
expr_stmt|;
while|while
condition|(
operator|(
name|ccb_h
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|a_descr
operator|->
name|cmplt_io
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|ctio
decl_stmt|;
name|struct
name|ctio_descr
modifier|*
name|c_descr
decl_stmt|;
name|ctio
operator|=
operator|(
expr|struct
name|ccb_scsiio
operator|*
operator|)
name|ccb_h
expr_stmt|;
name|c_descr
operator|=
operator|(
expr|struct
name|ctio_descr
operator|*
operator|)
name|ctio
operator|->
name|ccb_h
operator|.
name|targ_descr
expr_stmt|;
if|if
condition|(
name|ctio
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_ABORTED
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|a_descr
operator|->
name|cmplt_io
argument_list|,
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|free_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ctio
argument_list|)
expr_stmt|;
name|send_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If completed item is in range, call handler */
if|if
condition|(
operator|(
name|c_descr
operator|->
name|event
operator|==
name|AIO_DONE
operator|&&
name|c_descr
operator|->
name|offset
operator|==
name|a_descr
operator|->
name|base_off
operator|+
name|a_descr
operator|->
name|targ_ack
operator|)
operator|||
operator|(
name|c_descr
operator|->
name|event
operator|==
name|CTIO_DONE
operator|&&
name|c_descr
operator|->
name|offset
operator|==
name|a_descr
operator|->
name|base_off
operator|+
name|a_descr
operator|->
name|init_ack
operator|)
condition|)
block|{
name|sent_status
operator|=
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|!=
literal|0
expr_stmt|;
name|event
operator|=
name|c_descr
operator|->
name|event
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|a_descr
operator|->
name|cmplt_io
argument_list|,
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|tcmd_handle
argument_list|(
name|atio
argument_list|,
name|ctio
argument_list|,
name|c_descr
operator|->
name|event
argument_list|)
expr_stmt|;
comment|/* If entire transfer complete, send back ATIO */
if|if
condition|(
name|sent_status
operator|!=
literal|0
operator|&&
name|event
operator|==
name|CTIO_DONE
condition|)
name|send_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atio
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Gap in offsets so wait until later callback */
if|if
condition|(
comment|/* debug */
literal|1
condition|)
name|warnx
argument_list|(
literal|"IO %p:%p out of order %s"
argument_list|,
name|ccb_h
argument_list|,
name|a_descr
argument_list|,
name|c_descr
operator|->
name|event
operator|==
name|AIO_DONE
condition|?
literal|"aio"
else|:
literal|"ctio"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|work_inot
parameter_list|(
name|struct
name|ccb_immed_notify
modifier|*
name|inot
parameter_list|)
block|{
name|cam_status
name|status
decl_stmt|;
name|int
name|sense
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|warnx
argument_list|(
literal|"Working on INOT %p"
argument_list|,
name|inot
argument_list|)
expr_stmt|;
name|status
operator|=
name|inot
operator|->
name|ccb_h
operator|.
name|status
expr_stmt|;
name|sense
operator|=
operator|(
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|!=
literal|0
expr_stmt|;
name|status
operator|&=
name|CAM_STATUS_MASK
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|CAM_SCSI_BUS_RESET
case|:
name|tcmd_ua
argument_list|(
name|CAM_TARGET_WILDCARD
argument_list|,
name|UA_BUS_RESET
argument_list|)
expr_stmt|;
name|abort_all_pending
argument_list|()
expr_stmt|;
break|break;
case|case
name|CAM_BDR_SENT
case|:
name|tcmd_ua
argument_list|(
name|CAM_TARGET_WILDCARD
argument_list|,
name|UA_BDR
argument_list|)
expr_stmt|;
name|abort_all_pending
argument_list|()
expr_stmt|;
break|break;
case|case
name|CAM_MESSAGE_RECV
case|:
switch|switch
condition|(
name|inot
operator|->
name|message_args
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MSG_TASK_COMPLETE
case|:
case|case
name|MSG_INITIATOR_DET_ERR
case|:
case|case
name|MSG_ABORT_TASK_SET
case|:
case|case
name|MSG_MESSAGE_REJECT
case|:
case|case
name|MSG_NOOP
case|:
case|case
name|MSG_PARITY_ERROR
case|:
case|case
name|MSG_TARGET_RESET
case|:
case|case
name|MSG_ABORT_TASK
case|:
case|case
name|MSG_CLEAR_TASK_SET
case|:
default|default:
name|warnx
argument_list|(
literal|"INOT message %#x"
argument_list|,
name|inot
operator|->
name|message_args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CAM_REQ_ABORTED
case|:
name|warnx
argument_list|(
literal|"INOT %p aborted"
argument_list|,
name|inot
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"Unhandled INOT status %#x"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If there is sense data, use it */
if|if
condition|(
name|sense
operator|!=
literal|0
condition|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|sense
operator|=
operator|&
name|inot
operator|->
name|sense_data
expr_stmt|;
name|tcmd_sense
argument_list|(
name|inot
operator|->
name|initiator_id
argument_list|,
name|NULL
argument_list|,
name|sense
operator|->
name|flags
argument_list|,
name|sense
operator|->
name|add_sense_code
argument_list|,
name|sense
operator|->
name|add_sense_code_qual
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|warnx
argument_list|(
literal|"INOT has sense: %#x"
argument_list|,
name|sense
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* Requeue on SIM */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|work_queue
argument_list|,
operator|&
name|inot
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
name|send_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|inot
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|send_ccb
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
if|if
condition|(
name|debug
condition|)
name|warnx
argument_list|(
literal|"sending ccb (%#x)"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
if|if
condition|(
name|XPT_FC_IS_QUEUED
argument_list|(
name|ccb
argument_list|)
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pending_queue
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|periph_links
operator|.
name|tqe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|targ_fd
argument_list|,
operator|&
name|ccb
argument_list|,
sizeof|sizeof
argument_list|(
name|ccb
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|ccb
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"write ccb"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a CTIO/descr/buf combo from the freelist or malloc one */
end_comment

begin_function
specifier|static
name|struct
name|ccb_scsiio
modifier|*
name|get_ctio
parameter_list|()
block|{
name|struct
name|ccb_scsiio
modifier|*
name|ctio
decl_stmt|;
name|struct
name|ctio_descr
modifier|*
name|c_descr
decl_stmt|;
name|struct
name|sigevent
modifier|*
name|se
decl_stmt|;
if|if
condition|(
name|num_ctios
operator|==
name|MAX_CTIOS
condition|)
block|{
name|warnx
argument_list|(
literal|"at CTIO max"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ctio
operator|=
operator|(
expr|struct
name|ccb_scsiio
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ctio
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctio
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"malloc CTIO"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|c_descr
operator|=
operator|(
expr|struct
name|ctio_descr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|c_descr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_descr
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ctio
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"malloc ctio_descr"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|c_descr
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_descr
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|c_descr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctio
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"malloc backing store"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|num_ctios
operator|++
expr_stmt|;
comment|/* Initialize CTIO, CTIO descr, and AIO */
name|ctio
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_CONT_TARGET_IO
expr_stmt|;
name|ctio
operator|->
name|ccb_h
operator|.
name|retry_count
operator|=
literal|2
expr_stmt|;
name|ctio
operator|->
name|ccb_h
operator|.
name|timeout
operator|=
name|CAM_TIME_INFINITY
expr_stmt|;
name|ctio
operator|->
name|data_ptr
operator|=
name|c_descr
operator|->
name|buf
expr_stmt|;
name|ctio
operator|->
name|ccb_h
operator|.
name|targ_descr
operator|=
name|c_descr
expr_stmt|;
name|c_descr
operator|->
name|aiocb
operator|.
name|aio_buf
operator|=
name|c_descr
operator|->
name|buf
expr_stmt|;
name|c_descr
operator|->
name|aiocb
operator|.
name|aio_fildes
operator|=
name|file_fd
expr_stmt|;
name|se
operator|=
operator|&
name|c_descr
operator|->
name|aiocb
operator|.
name|aio_sigevent
expr_stmt|;
name|se
operator|->
name|sigev_notify
operator|=
name|SIGEV_KEVENT
expr_stmt|;
name|se
operator|->
name|sigev_notify_kqueue
operator|=
name|kq_fd
expr_stmt|;
name|se
operator|->
name|sigev_value
operator|.
name|sival_ptr
operator|=
name|ctio
expr_stmt|;
return|return
operator|(
name|ctio
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free_ccb
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_CONT_TARGET_IO
case|:
block|{
name|struct
name|ctio_descr
modifier|*
name|c_descr
decl_stmt|;
name|c_descr
operator|=
operator|(
expr|struct
name|ctio_descr
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|targ_descr
expr_stmt|;
name|free
argument_list|(
name|c_descr
operator|->
name|buf
argument_list|)
expr_stmt|;
name|num_ctios
operator|--
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
name|free
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|targ_descr
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|XPT_IMMED_NOTIFY
case|:
default|default:
name|free
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|cam_status
name|get_sim_flags
parameter_list|(
name|u_int16_t
modifier|*
name|flags
parameter_list|)
block|{
name|struct
name|ccb_pathinq
name|cpi
decl_stmt|;
name|cam_status
name|status
decl_stmt|;
comment|/* Find SIM capabilities */
name|bzero
argument_list|(
operator|&
name|cpi
argument_list|,
sizeof|sizeof
argument_list|(
name|cpi
argument_list|)
argument_list|)
expr_stmt|;
name|cpi
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|send_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cpi
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|status
operator|=
name|cpi
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CPI failed, status %#x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* Can only enable on controllers that support target mode */
if|if
condition|(
operator|(
name|cpi
operator|.
name|target_sprt
operator|&
name|PIT_PROCESSOR
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"HBA does not support target mode\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|CAM_PATH_INVALID
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
operator|*
name|flags
operator|=
name|cpi
operator|.
name|hba_inquiry
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rel_simq
parameter_list|()
block|{
name|struct
name|ccb_relsim
name|crs
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|crs
argument_list|,
sizeof|sizeof
argument_list|(
name|crs
argument_list|)
argument_list|)
expr_stmt|;
name|crs
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_REL_SIMQ
expr_stmt|;
name|crs
operator|.
name|release_flags
operator|=
name|RELSIM_RELEASE_AFTER_QEMPTY
expr_stmt|;
name|crs
operator|.
name|openings
operator|=
literal|0
expr_stmt|;
name|crs
operator|.
name|release_timeout
operator|=
literal|0
expr_stmt|;
name|crs
operator|.
name|qfrozen_cnt
operator|=
literal|0
expr_stmt|;
name|send_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|crs
argument_list|,
comment|/*priority*/
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cancel all pending CCBs. */
end_comment

begin_function
specifier|static
name|void
name|abort_all_pending
parameter_list|()
block|{
name|struct
name|ccb_abort
name|cab
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|warnx
argument_list|(
literal|"abort_all_pending"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cab
argument_list|,
sizeof|sizeof
argument_list|(
name|cab
argument_list|)
argument_list|)
expr_stmt|;
name|cab
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ABORT
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ccb_h
argument_list|,
argument|&pending_queue
argument_list|,
argument|periph_links.tqe
argument_list|)
block|{
if|if
condition|(
name|debug
condition|)
name|warnx
argument_list|(
literal|"Aborting pending CCB %p\n"
argument_list|,
name|ccb_h
argument_list|)
expr_stmt|;
name|cab
operator|.
name|abort_ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
expr_stmt|;
name|send_ccb
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|cab
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cab
operator|.
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|warnx
argument_list|(
literal|"Unable to abort CCB, status %#x\n"
argument_list|,
name|cab
operator|.
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: scsi_target [-AdSTY] [-b bufsize] [-c sectorsize]\n"
literal|"\t\t[-r numbufs] [-s volsize] [-W 8,16,32]\n"
literal|"\t\tbus:target:lun filename\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

