begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Control LCD module hung off parallel port using the  * ppi 'geek port' interface.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_comment
comment|/* XXX should be in<machine/> */
end_comment

begin_include
include|#
directive|include
file|"ppbconf.h"
end_include

begin_include
include|#
directive|include
file|"ppi.h"
end_include

begin_define
define|#
directive|define
name|debug
parameter_list|(
name|lev
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|if (debuglevel>= lev) fprintf(stderr, fmt "\n" , ## args);
end_define

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEFAULT_DEVICE
value|"/dev/ppi0"
end_define

begin_comment
comment|/* Driver functions */
end_comment

begin_function_decl
specifier|static
name|void
name|hd44780_prepare
parameter_list|(
name|char
modifier|*
name|devname
parameter_list|,
name|char
modifier|*
name|options
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hd44780_finish
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hd44780_command
parameter_list|(
name|int
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hd44780_putc
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*   * Commands   * Note that unrecognised command escapes are passed through with  * the command value set to the ASCII value of the escaped character.  */
end_comment

begin_define
define|#
directive|define
name|CMD_RESET
value|0
end_define

begin_define
define|#
directive|define
name|CMD_BKSP
value|1
end_define

begin_define
define|#
directive|define
name|CMD_CLR
value|2
end_define

begin_define
define|#
directive|define
name|CMD_NL
value|3
end_define

begin_define
define|#
directive|define
name|CMD_CR
value|4
end_define

begin_define
define|#
directive|define
name|CMD_HOME
value|5
end_define

begin_define
define|#
directive|define
name|MAX_DRVOPT
value|10
end_define

begin_comment
comment|/* maximum driver-specific options */
end_comment

begin_struct
struct|struct
name|lcd_driver
block|{
name|char
modifier|*
name|l_code
decl_stmt|;
name|char
modifier|*
name|l_name
decl_stmt|;
name|char
modifier|*
name|l_options
index|[
name|MAX_DRVOPT
index|]
decl_stmt|;
name|void
function_decl|(
modifier|*
name|l_prepare
function_decl|)
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|options
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|l_finish
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|l_command
function_decl|)
parameter_list|(
name|int
name|cmd
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|l_putc
function_decl|)
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|lcd_driver
name|lcd_drivertab
index|[]
init|=
block|{
block|{
literal|"hd44780"
block|,
literal|"Hitachi HD44780 and compatibles"
block|,
block|{
literal|"Reset options:"
block|,
literal|"    1     1-line display (default 2)"
block|,
literal|"    B     Cursor blink enable"
block|,
literal|"    C     Cursor enable"
block|,
literal|"    F     Large font select"
block|,
name|NULL
block|}
block|,
name|hd44780_prepare
block|,
name|hd44780_finish
block|,
name|hd44780_command
block|,
name|hd44780_putc
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
block|{
name|NULL
block|}
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|do_char
parameter_list|(
name|struct
name|lcd_driver
modifier|*
name|driver
parameter_list|,
name|char
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|debuglevel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
name|struct
name|lcd_driver
modifier|*
name|driver
init|=
operator|&
name|lcd_drivertab
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
name|drivertype
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|devname
init|=
name|DEFAULT_DEVICE
decl_stmt|;
name|char
modifier|*
name|drvopts
init|=
name|NULL
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|progname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
name|progname
operator|++
expr_stmt|;
block|}
else|else
block|{
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
name|drivertype
operator|=
name|getenv
argument_list|(
literal|"LCD_TYPE"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Dd:f:o:v"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'D'
case|:
name|debuglevel
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|drivertype
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|devname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|drvopts
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|vflag
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* If an LCD type was specified, look it up */
if|if
condition|(
name|drivertype
operator|!=
name|NULL
condition|)
block|{
name|driver
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lcd_drivertab
index|[
name|i
index|]
operator|.
name|l_code
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|drivertype
argument_list|,
name|lcd_drivertab
index|[
name|i
index|]
operator|.
name|l_code
argument_list|)
condition|)
block|{
name|driver
operator|=
operator|&
name|lcd_drivertab
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|driver
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"LCD driver '%s' not known"
argument_list|,
name|drivertype
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|debug
argument_list|(
literal|1
argument_list|,
literal|"Driver selected for %s"
argument_list|,
name|driver
operator|->
name|l_name
argument_list|)
expr_stmt|;
name|driver
operator|->
name|l_prepare
argument_list|(
name|devname
argument_list|,
name|drvopts
argument_list|)
expr_stmt|;
name|atexit
argument_list|(
name|driver
operator|->
name|l_finish
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"reading input from %d argument%s"
argument_list|,
name|argc
argument_list|,
operator|(
name|argc
operator|>
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
for|for
control|(
name|cp
operator|=
name|argv
index|[
name|i
index|]
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|do_char
argument_list|(
name|driver
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|2
argument_list|,
literal|"reading input from stdin"
argument_list|)
expr_stmt|;
name|setvbuf
argument_list|(
name|stdin
argument_list|,
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|fgetc
argument_list|(
name|stdin
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|do_char
argument_list|(
name|driver
argument_list|,
operator|(
name|char
operator|)
name|ch
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-v] [-d drivername] [-f device] [-o options] [args...]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   -D      Increase debugging\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   -f      Specify device, default is '%s'\n"
argument_list|,
name|DEFAULT_DEVICE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   -d      Specify driver, one of:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lcd_drivertab
index|[
name|i
index|]
operator|.
name|l_code
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"              %-10s (%s)%s\n"
argument_list|,
name|lcd_drivertab
index|[
name|i
index|]
operator|.
name|l_code
argument_list|,
name|lcd_drivertab
index|[
name|i
index|]
operator|.
name|l_name
argument_list|,
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
literal|" *default*"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcd_drivertab
index|[
name|i
index|]
operator|.
name|l_options
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|lcd_drivertab
index|[
name|i
index|]
operator|.
name|l_options
index|[
name|j
index|]
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                  %s\n"
argument_list|,
name|lcd_drivertab
index|[
name|i
index|]
operator|.
name|l_options
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -o       Specify driver option string\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  args     Message strings.  Embedded escapes supported:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                  \\b	Backspace\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                  \\f	Clear display, home cursor\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                  \\n	Newline\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                  \\r	Carriage return\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                  \\R	Reset display\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                  \\v	Home cursor\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                  \\\\	Literal \\\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"           If args not supplied, strings are read from standard input\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_char
parameter_list|(
name|struct
name|lcd_driver
modifier|*
name|driver
parameter_list|,
name|char
name|ch
parameter_list|)
block|{
specifier|static
name|int
name|esc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|esc
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'b'
case|:
name|driver
operator|->
name|l_command
argument_list|(
name|CMD_BKSP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|driver
operator|->
name|l_command
argument_list|(
name|CMD_CLR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|driver
operator|->
name|l_command
argument_list|(
name|CMD_NL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|driver
operator|->
name|l_command
argument_list|(
name|CMD_CR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|driver
operator|->
name|l_command
argument_list|(
name|CMD_RESET
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|driver
operator|->
name|l_command
argument_list|(
name|CMD_HOME
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|driver
operator|->
name|l_putc
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|driver
operator|->
name|l_command
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
name|esc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|esc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vflag
operator|||
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
name|driver
operator|->
name|l_putc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Driver for the Hitachi HD44780.  This is probably *the* most common driver  * to be found on one- and two-line alphanumeric LCDs.  *  * This driver assumes the following connections :  *  * Parallel Port	LCD Module  * --------------------------------  * Strobe (1)		Enable (6)  * Data (2-9)		Data (7-14)  * Select(13)		RS (4)  * Auto Feed (14)	R/W (5)  *  * In addition, power must be supplied to the module, normally with  * a circuit similar to this:  *  * VCC (+5V) O------o-------o--------O Module pin 2  *                  |       | +  *                  /      ---  *                  \      --- 1uF  *                  /       | -  *                  \<-----o--------O Module pin 3  *                  /  *                  \  *                  |  * GND       O------o----------------O Module pin 1  *  * The ground line should also be connected to the parallel port, on  * one of the ground pins (eg. pin 25).  *  * Note that the pinning on some LCD modules has the odd and even pins  * arranged as though reversed; check carefully before conecting a module  * as it is possible to toast the HD44780 if the power is reversed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hd_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|hd_cbits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hd_lines
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hd_blink
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hd_cursor
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hd_font
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HD_COMMAND
value|SELECTIN
end_define

begin_define
define|#
directive|define
name|HD_DATA
value|0
end_define

begin_define
define|#
directive|define
name|HD_READ
value|0
end_define

begin_define
define|#
directive|define
name|HD_WRITE
value|AUTOFEED
end_define

begin_define
define|#
directive|define
name|HD_BF
value|0x80
end_define

begin_comment
comment|/* internal busy flag */
end_comment

begin_define
define|#
directive|define
name|HD_ADDRMASK
value|0x7f
end_define

begin_comment
comment|/* DDRAM address mask */
end_comment

begin_define
define|#
directive|define
name|hd_sctrl
parameter_list|(
name|v
parameter_list|)
value|{u_int8_t _val; _val = hd_cbits | v; ioctl(hd_fd, PPISCTRL,&_val);}
end_define

begin_define
define|#
directive|define
name|hd_sdata
parameter_list|(
name|v
parameter_list|)
value|{u_int8_t _val; _val = v; ioctl(hd_fd, PPISDATA,&_val);}
end_define

begin_define
define|#
directive|define
name|hd_gdata
parameter_list|(
name|v
parameter_list|)
value|ioctl(hd_fd, PPIGDATA,&v)
end_define

begin_function
specifier|static
name|void
name|hd44780_output
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|debug
argument_list|(
literal|3
argument_list|,
literal|"%s -> 0x%02x"
argument_list|,
operator|(
name|type
operator|==
name|HD_COMMAND
operator|)
condition|?
literal|"cmd "
else|:
literal|"data"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|hd_sctrl
argument_list|(
name|type
operator||
name|HD_WRITE
operator||
name|STROBE
argument_list|)
expr_stmt|;
comment|/* set direction, address */
name|hd_sctrl
argument_list|(
name|type
operator||
name|HD_WRITE
argument_list|)
expr_stmt|;
comment|/* raise E */
name|hd_sdata
argument_list|(
operator|(
name|u_int8_t
operator|)
name|data
argument_list|)
expr_stmt|;
comment|/* drive data */
name|hd_sctrl
argument_list|(
name|type
operator||
name|HD_WRITE
operator||
name|STROBE
argument_list|)
expr_stmt|;
comment|/* lower E */
block|}
end_function

begin_function
specifier|static
name|int
name|hd44780_input
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|u_int8_t
name|val
decl_stmt|;
name|hd_sctrl
argument_list|(
name|type
operator||
name|HD_READ
operator||
name|STROBE
argument_list|)
expr_stmt|;
comment|/* set direction, address */
name|hd_sctrl
argument_list|(
name|type
operator||
name|HD_READ
argument_list|)
expr_stmt|;
comment|/* raise E */
name|hd_gdata
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* read data */
name|hd_sctrl
argument_list|(
name|type
operator||
name|HD_READ
operator||
name|STROBE
argument_list|)
expr_stmt|;
comment|/* lower E */
name|debug
argument_list|(
literal|3
argument_list|,
literal|"0x%02x -> %s"
argument_list|,
name|val
argument_list|,
operator|(
name|type
operator|==
name|HD_COMMAND
operator|)
condition|?
literal|"cmd "
else|:
literal|"data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hd44780_prepare
parameter_list|(
name|char
modifier|*
name|devname
parameter_list|,
name|char
modifier|*
name|options
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|options
decl_stmt|;
if|if
condition|(
operator|(
name|hd_fd
operator|=
name|open
argument_list|(
name|devname
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"can't open '%s'"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
comment|/* parse options */
while|while
condition|(
name|cp
operator|&&
operator|*
name|cp
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|'1'
case|:
name|hd_lines
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|hd_blink
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|hd_cursor
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|hd_font
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"hd44780: unknown option code '%c'"
argument_list|,
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Put LCD in idle state */
if|if
condition|(
name|ioctl
argument_list|(
name|hd_fd
argument_list|,
name|PPIGCTRL
argument_list|,
operator|&
name|hd_cbits
argument_list|)
condition|)
comment|/* save other control bits */
name|err
argument_list|(
name|EX_IOERR
argument_list|,
literal|"ioctl PPIGCTRL failed (not a ppi device?)"
argument_list|)
expr_stmt|;
name|hd_cbits
operator|&=
operator|~
operator|(
name|STROBE
operator||
name|SELECTIN
operator||
name|AUTOFEED
operator|)
expr_stmt|;
comment|/* set strobe, RS, R/W low */
name|debug
argument_list|(
literal|2
argument_list|,
literal|"static control bits 0x%x"
argument_list|,
name|hd_cbits
argument_list|)
expr_stmt|;
name|hd_sctrl
argument_list|(
name|STROBE
argument_list|)
expr_stmt|;
name|hd_sdata
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hd44780_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|close
argument_list|(
name|hd_fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hd44780_command
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
name|u_int8_t
name|val
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CMD_RESET
case|:
comment|/* full manual reset and reconfigure as per datasheet */
name|debug
argument_list|(
literal|1
argument_list|,
literal|"hd44780: reset to %d lines, %s font,%s%s cursor"
argument_list|,
name|hd_lines
argument_list|,
name|hd_font
condition|?
literal|"5x10"
else|:
literal|"5x7"
argument_list|,
name|hd_cursor
condition|?
literal|""
else|:
literal|" no"
argument_list|,
name|hd_blink
condition|?
literal|" blinking"
else|:
literal|""
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0x30
expr_stmt|;
if|if
condition|(
name|hd_lines
operator|==
literal|2
condition|)
name|val
operator||=
literal|0x08
expr_stmt|;
if|if
condition|(
name|hd_font
condition|)
name|val
operator||=
literal|0x04
expr_stmt|;
name|hd44780_output
argument_list|(
name|HD_COMMAND
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|hd44780_output
argument_list|(
name|HD_COMMAND
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|hd44780_output
argument_list|(
name|HD_COMMAND
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0x08
expr_stmt|;
comment|/* display off */
name|hd44780_output
argument_list|(
name|HD_COMMAND
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|val
operator||=
literal|0x04
expr_stmt|;
comment|/* display on */
if|if
condition|(
name|hd_cursor
condition|)
name|val
operator||=
literal|0x02
expr_stmt|;
if|if
condition|(
name|hd_blink
condition|)
name|val
operator||=
literal|0x01
expr_stmt|;
name|hd44780_output
argument_list|(
name|HD_COMMAND
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|hd44780_output
argument_list|(
name|HD_COMMAND
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
comment|/* shift cursor by increment */
name|usleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|CMD_CLR
case|:
name|hd44780_output
argument_list|(
name|HD_COMMAND
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_BKSP
case|:
name|hd44780_output
argument_list|(
name|HD_DATA
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* shift cursor left one */
break|break;
case|case
name|CMD_NL
case|:
if|if
condition|(
name|hd_lines
operator|==
literal|2
condition|)
name|hd44780_output
argument_list|(
name|HD_COMMAND
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
comment|/* beginning of second line */
break|break;
case|case
name|CMD_CR
case|:
comment|/* XXX will not work in 4-line mode, or where readback fails */
name|val
operator|=
name|hd44780_input
argument_list|(
name|HD_COMMAND
argument_list|)
operator|&
literal|0x3f
expr_stmt|;
comment|/* mask character position, save line pos */
name|hd44780_output
argument_list|(
name|HD_COMMAND
argument_list|,
literal|0x80
operator||
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_HOME
case|:
name|hd44780_output
argument_list|(
name|HD_COMMAND
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isprint
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"unknown command %c"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"unknown command 0x%x"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
name|usleep
argument_list|(
literal|40
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hd44780_putc
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|hd44780_output
argument_list|(
name|HD_DATA
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|40
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

