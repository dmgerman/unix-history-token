begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) 2014, Neville-Neil Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  * notice, this list of conditions and the following disclaimer in the  * documentation and/or other materials provided with the distribution.  *   * Neither the name of Neville-Neil Consulting nor the names of its   * contributors may be used to endorse or promote products derived from   * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  *  * Author: George V. Neville-Neil  *  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header:$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Calculate the time overhead of starting, stopping, and recording  * pmc counters.  *  * The only argument is a counter name, such as "instruction-retired"  * which is CPU dependent and can be found with pmmcontrol(8) using  * pmccontrol -L.  *  * The start, stop, read and write operations are timed using the  * rdtsc() macro which reads the Time Stamp Counter on the CPU.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<pmc.h>
end_include

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|pmc_id_t
name|pmcid
decl_stmt|;
name|pmc_value_t
name|read_value
decl_stmt|;
name|pmc_value_t
name|read_clear_value
decl_stmt|;
name|uint64_t
name|tsc1
decl_stmt|,
name|write_cyc
decl_stmt|,
name|start_cyc
decl_stmt|,
name|read_cyc
decl_stmt|,
name|stop_cyc
decl_stmt|;
name|char
modifier|*
name|counter_name
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
name|err
argument_list|(
name|EX_USAGE
argument_list|,
literal|"counter-name required"
argument_list|)
expr_stmt|;
name|counter_name
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|pmc_init
argument_list|()
operator|!=
literal|0
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"hwpmc(4) not loaded, kldload or update your kernel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc_allocate
argument_list|(
name|counter_name
argument_list|,
name|PMC_MODE_SC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|pmcid
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"failed to allocate %s as a system counter in counting mode"
argument_list|,
name|counter_name
argument_list|)
expr_stmt|;
name|tsc1
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
if|if
condition|(
name|pmc_write
argument_list|(
name|pmcid
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"failed to zero counter %s"
argument_list|,
name|counter_name
argument_list|)
expr_stmt|;
name|write_cyc
operator|=
name|rdtsc
argument_list|()
operator|-
name|tsc1
expr_stmt|;
name|tsc1
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
if|if
condition|(
name|pmc_start
argument_list|(
name|pmcid
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"failed to start counter %s"
argument_list|,
name|counter_name
argument_list|)
expr_stmt|;
name|start_cyc
operator|=
name|rdtsc
argument_list|()
operator|-
name|tsc1
expr_stmt|;
name|tsc1
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
if|if
condition|(
name|pmc_read
argument_list|(
name|pmcid
argument_list|,
operator|&
name|read_value
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"failed to read counter %s"
argument_list|,
name|counter_name
argument_list|)
expr_stmt|;
name|read_cyc
operator|=
name|rdtsc
argument_list|()
operator|-
name|tsc1
expr_stmt|;
name|tsc1
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
if|if
condition|(
name|pmc_stop
argument_list|(
name|pmcid
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"failed to stop counter %s"
argument_list|,
name|counter_name
argument_list|)
expr_stmt|;
name|stop_cyc
operator|=
name|rdtsc
argument_list|()
operator|-
name|tsc1
expr_stmt|;
if|if
condition|(
name|pmc_rw
argument_list|(
name|pmcid
argument_list|,
literal|0
argument_list|,
operator|&
name|read_clear_value
argument_list|)
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"failed to read and zero %s"
argument_list|,
name|counter_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc_release
argument_list|(
name|pmcid
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"failed to release %s as a system counter in counting mode"
argument_list|,
name|counter_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Counter %s, read value %ld, read/clear value %ld\n"
argument_list|,
name|counter_name
argument_list|,
name|read_value
argument_list|,
name|read_clear_value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Cycles to start: %ld\tstop: %ld\tread: %ld\twrite: %ld\n"
argument_list|,
name|start_cyc
argument_list|,
name|stop_cyc
argument_list|,
name|read_cyc
argument_list|,
name|stop_cyc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

