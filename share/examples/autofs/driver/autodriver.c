begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004 Alfred Perlstein<alfred@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: autodriver.c,v 1.9 2004/09/08 08:12:21 bright Exp $  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<libautofs.h>
end_include

begin_struct
struct|struct
name|autoentry
block|{
name|char
modifier|*
name|ae_mnt
decl_stmt|;
comment|/* autofs mountpoint. */
name|char
modifier|*
name|ae_path
decl_stmt|;
comment|/* path under mount. */
name|char
modifier|*
name|ae_type
decl_stmt|;
comment|/* fs to be mounted type. */
name|char
modifier|*
name|ae_opts
decl_stmt|;
comment|/* options passed to mount. */
name|char
modifier|*
name|ae_rpath
decl_stmt|;
comment|/* remote path */
name|char
modifier|*
name|ae_free
decl_stmt|;
comment|/* freeme! */
name|char
modifier|*
name|ae_fullpath
decl_stmt|;
comment|/* full path to mount */
name|int
name|ae_line
decl_stmt|;
comment|/* line it came from in the conf. */
name|int
name|ae_indirect
decl_stmt|;
comment|/* is this an indirect mount? */
name|int
name|ae_direct
decl_stmt|;
comment|/* is this a direct mount? */
name|int
name|ae_browse
decl_stmt|;
comment|/* browseable? */
name|struct
name|autoentry
modifier|*
name|ae_next
decl_stmt|;
comment|/* next. */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|autoentry
modifier|*
name|entries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|mount_prog
init|=
literal|"mount"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|fstype
init|=
literal|"autofs"
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
modifier|*
name|xmalloc
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|xcalloc
parameter_list|(
name|size_t
name|number
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|parsetab
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|populate_tab
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|doreq
parameter_list|(
name|autoh_t
parameter_list|,
name|autoreq_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dotheneedful
parameter_list|(
name|autoh_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|eventloop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|poll_handles
parameter_list|(
name|autoh_t
modifier|*
name|array
parameter_list|,
name|int
name|cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mount_indirect
parameter_list|(
name|struct
name|autofs_userreq
modifier|*
name|req
parameter_list|,
name|struct
name|autoentry
modifier|*
name|ent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mount_direct
parameter_list|(
name|struct
name|autofs_userreq
modifier|*
name|req
parameter_list|,
name|struct
name|autoentry
modifier|*
name|ent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mount_browse
parameter_list|(
name|struct
name|autofs_userreq
modifier|*
name|req
parameter_list|,
name|struct
name|autoentry
modifier|*
name|ent
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DSTR
parameter_list|(
name|s
parameter_list|)
value|sizeof(s) - 1, s
end_define

begin_decl_stmt
name|struct
name|dirent
name|dumbents
index|[]
init|=
block|{
block|{
literal|50
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
block|,
name|DT_DIR
block|,
name|DSTR
argument_list|(
literal|"one"
argument_list|)
block|}
block|,
block|{
literal|51
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
block|,
name|DT_DIR
block|,
name|DSTR
argument_list|(
literal|"."
argument_list|)
block|}
block|,
block|{
literal|52
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
block|,
name|DT_DIR
block|,
name|DSTR
argument_list|(
literal|".."
argument_list|)
block|}
block|,
block|{
literal|50
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
block|,
name|DT_DIR
block|,
name|DSTR
argument_list|(
literal|"two"
argument_list|)
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
modifier|*
name|xmalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc %d"
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|xcalloc
parameter_list|(
name|size_t
name|number
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|calloc
argument_list|(
name|number
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"calloc %d %d"
argument_list|,
operator|(
name|int
operator|)
name|number
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|parsetab
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|tab
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|opt
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|autoentry
modifier|*
name|ent
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lineno
decl_stmt|,
name|x
decl_stmt|,
name|gotopt
decl_stmt|;
specifier|const
name|char
modifier|*
name|expecting
init|=
literal|"expecting 'direct', 'indirect' or 'browse'"
decl_stmt|;
specifier|const
name|char
modifier|*
name|tabfiles
index|[]
init|=
block|{
literal|"/etc/autotab"
block|,
literal|"/usr/local/etc/autotab"
block|,
literal|"./autotab"
block|,
name|NULL
block|}
decl_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|tab
operator|=
name|tabfiles
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|tab
operator|=
name|tabfiles
index|[
name|i
index|]
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|tab
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|warn
argument_list|(
literal|"fopen %s"
argument_list|,
name|tab
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"no config file available."
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"using config file: %s\n"
argument_list|,
name|tab
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|fgetln
argument_list|(
name|fp
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
name|cp
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
name|line
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|line
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'#'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|line
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ent
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|cp
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|ent
operator|->
name|ae_mnt
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|cp
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|ent
operator|->
name|ae_path
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|cp
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|ent
operator|->
name|ae_type
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|cp
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|ent
operator|->
name|ae_opts
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|cp
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|ent
operator|->
name|ae_rpath
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|cp
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|gotopt
operator|=
literal|0
expr_stmt|;
name|opt
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|opt
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"indirect"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ent
operator|->
name|ae_indirect
operator|=
literal|1
expr_stmt|;
name|gotopt
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"direct"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ent
operator|->
name|ae_direct
operator|=
literal|1
expr_stmt|;
name|gotopt
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"browse"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ent
operator|->
name|ae_browse
operator|=
literal|1
expr_stmt|;
name|gotopt
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"unreconized option '%s', %s"
argument_list|,
name|p
argument_list|,
name|expecting
argument_list|)
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|gotopt
condition|)
block|{
name|warnx
argument_list|(
literal|"no options specified %s"
argument_list|,
name|expecting
argument_list|)
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
if|if
condition|(
name|ent
operator|->
name|ae_direct
operator|&&
name|ent
operator|->
name|ae_indirect
condition|)
block|{
name|warnx
argument_list|(
literal|"direct and indirect are mutually exclusive"
argument_list|)
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|x
operator|=
name|asprintf
argument_list|(
operator|&
name|ent
operator|->
name|ae_fullpath
argument_list|,
literal|"%s/%s"
argument_list|,
name|ent
operator|->
name|ae_mnt
argument_list|,
name|ent
operator|->
name|ae_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|ent
operator|->
name|ae_fullpath
argument_list|)
operator|+
literal|1
operator|>
name|PATH_MAX
condition|)
block|{
name|warnx
argument_list|(
literal|"Error in file %s, line %d, "
literal|"mountpath (%s) exceeds PATH_MAX (%d)"
argument_list|,
name|tab
argument_list|,
name|lineno
argument_list|,
name|ent
operator|->
name|ae_fullpath
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|ent
operator|->
name|ae_line
operator|=
name|lineno
expr_stmt|;
name|ent
operator|->
name|ae_free
operator|=
name|line
expr_stmt|;
name|ent
operator|->
name|ae_next
operator|=
name|entries
expr_stmt|;
name|entries
operator|=
name|ent
expr_stmt|;
continue|continue;
name|bad
label|:
name|warnx
argument_list|(
literal|"Parse error in file %s, line %d"
argument_list|,
name|tab
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|bad2
label|:
name|free
argument_list|(
name|ent
operator|->
name|ae_fullpath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"error with file %s"
argument_list|,
name|tab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|populate_tab
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|autoentry
modifier|*
name|ent
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|cmd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|autoh_t
name|ah
decl_stmt|;
name|path
operator|=
name|cmd
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|entries
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|ae_next
control|)
block|{
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|asprintf
argument_list|(
operator|&
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|ent
operator|->
name|ae_mnt
argument_list|,
name|ent
operator|->
name|ae_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
name|error
operator|=
name|asprintf
argument_list|(
operator|&
name|cmd
argument_list|,
literal|"mkdir -p %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
name|error
operator|=
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|warn
argument_list|(
literal|"system: %s"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|autoh_get
argument_list|(
name|ent
operator|->
name|ae_mnt
argument_list|,
operator|&
name|ah
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"autoh_get %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|error
operator|=
name|autoh_togglepath
argument_list|(
name|ah
argument_list|,
name|AUTO_MOUNTER
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"AUTO_MOUNTER %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ent
operator|->
name|ae_browse
condition|)
block|{
name|error
operator|=
name|autoh_togglepath
argument_list|(
name|ah
argument_list|,
name|AUTO_BROWSE
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"AUTO_BROWSE %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|ae_direct
condition|)
block|{
name|error
operator|=
name|autoh_togglepath
argument_list|(
name|ah
argument_list|,
name|AUTO_DIRECT
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"AUTO_DIRECT %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|ae_indirect
condition|)
block|{
name|error
operator|=
name|autoh_togglepath
argument_list|(
name|ah
argument_list|,
name|AUTO_INDIRECT
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"AUTO_INDIRECT %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|autoh_free
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an autofs request, scan the list of entries in the config  * looking for our node, if found mount it.  */
end_comment

begin_function
name|void
name|doreq
parameter_list|(
name|autoh_t
name|ah
parameter_list|,
name|autoreq_t
name|req
parameter_list|)
block|{
name|struct
name|autoentry
modifier|*
name|ent
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|mcmp
decl_stmt|;
name|int
name|xid
decl_stmt|;
specifier|const
name|char
modifier|*
name|mnt
decl_stmt|;
name|mnt
operator|=
name|autoh_mp
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|autoreq_seterrno
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|entries
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|ae_next
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"comparing {%s,%s} to {%s,%s}\n"
argument_list|,
name|mnt
argument_list|,
name|ent
operator|->
name|ae_mnt
argument_list|,
name|autoreq_getpath
argument_list|(
name|req
argument_list|)
argument_list|,
name|ent
operator|->
name|ae_path
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"comparing {%d,%d} to {%d,%d}\n"
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|mnt
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|ent
operator|->
name|ae_mnt
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|autoreq_getpath
argument_list|(
name|req
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|ent
operator|->
name|ae_path
argument_list|)
argument_list|)
expr_stmt|;
name|autoreq_getxid
argument_list|(
name|req
argument_list|,
operator|&
name|xid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"req xid %d\n"
argument_list|,
name|xid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mcmp
operator|=
name|strcmp
argument_list|(
name|mnt
argument_list|,
name|ent
operator|->
name|ae_mnt
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mcmp = %d\n"
argument_list|,
name|mcmp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mount_direct
argument_list|(
name|req
argument_list|,
name|ent
argument_list|)
condition|)
goto|goto
name|serve
goto|;
if|if
condition|(
name|mount_indirect
argument_list|(
name|req
argument_list|,
name|ent
argument_list|)
condition|)
goto|goto
name|serve
goto|;
if|if
condition|(
name|mount_browse
argument_list|(
name|req
argument_list|,
name|ent
argument_list|)
condition|)
goto|goto
name|serve
goto|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no entry found...\n"
argument_list|)
expr_stmt|;
name|autoreq_seterrno
argument_list|(
name|req
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
name|serve
label|:
name|error
operator|=
name|autoreq_serv
argument_list|(
name|ah
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"AUTOFS_CTL_SERVREQ"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|mount_indirect
parameter_list|(
name|req
parameter_list|,
name|ent
parameter_list|)
name|struct
name|autofs_userreq
modifier|*
name|req
decl_stmt|;
name|struct
name|autoentry
modifier|*
name|ent
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|cmd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|ent
operator|->
name|ae_indirect
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not indirect.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"indirect mount...\n"
argument_list|)
expr_stmt|;
comment|/* 	 * handle lookups, fake all stat(2) requests... this is bad, 	 * but we're a driver so we don't care... 	 * If we don't care about the type of request, then just return. 	 */
switch|switch
condition|(
name|autoreq_getop
argument_list|(
name|req
argument_list|)
condition|)
block|{
case|case
name|AUTOREQ_OP_LOOKUP
case|:
break|break;
case|case
name|AUTOREQ_OP_STAT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"stat\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|ent
operator|->
name|ae_fullpath
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sb
operator|.
name|st_ino
operator|!=
name|autoreq_getdirino
argument_list|(
name|req
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"st_ino %d != dirino %d\n"
argument_list|,
operator|(
name|int
operator|)
name|sb
operator|.
name|st_ino
argument_list|,
operator|(
name|int
operator|)
name|autoreq_getdirino
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|x
operator|=
name|asprintf
argument_list|(
operator|&
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|ent
operator|->
name|ae_fullpath
argument_list|,
name|autoreq_getpath
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>
name|PATH_MAX
condition|)
block|{
name|autoreq_seterrno
argument_list|(
name|req
argument_list|,
name|ENAMETOOLONG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|mkdir
argument_list|(
name|path
argument_list|,
literal|0555
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|warn
argument_list|(
literal|"mkdir %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|error
operator|=
name|asprintf
argument_list|(
operator|&
name|cmd
argument_list|,
literal|"%s -t %s -o %s %s/%s %s"
argument_list|,
name|mount_prog
argument_list|,
name|ent
operator|->
name|ae_type
argument_list|,
name|ent
operator|->
name|ae_opts
argument_list|,
name|ent
operator|->
name|ae_rpath
argument_list|,
name|autoreq_getpath
argument_list|(
name|req
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"running:\n\t%s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|rmdir
argument_list|(
name|path
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|warn
argument_list|(
literal|"rmdir %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|autoreq_seterrno
argument_list|(
name|req
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|autoreq_setino
argument_list|(
name|req
argument_list|,
name|sb
operator|.
name|st_ino
argument_list|)
expr_stmt|;
comment|/* XXX !!! */
comment|/* req->au_flags = 1; */
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mount_direct
parameter_list|(
name|req
parameter_list|,
name|ent
parameter_list|)
name|struct
name|autofs_userreq
modifier|*
name|req
decl_stmt|;
name|struct
name|autoentry
modifier|*
name|ent
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ent
operator|->
name|ae_direct
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not direct.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"direct mount...\n"
argument_list|)
expr_stmt|;
comment|/* 	 * handle lookups, fake all stat(2) requests... this is bad, 	 * but we're a driver so we don't care... 	 * If we don't care about the type of request, then just return. 	 */
switch|switch
condition|(
name|autoreq_getop
argument_list|(
name|req
argument_list|)
condition|)
block|{
case|case
name|AUTOREQ_OP_LOOKUP
case|:
break|break;
case|case
name|AUTOREQ_OP_STAT
case|:
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|ent
operator|->
name|ae_fullpath
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sb
operator|.
name|st_ino
operator|!=
name|autoreq_getino
argument_list|(
name|req
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|asprintf
argument_list|(
operator|&
name|cmd
argument_list|,
literal|"%s -t %s -o %s %s %s"
argument_list|,
name|mount_prog
argument_list|,
name|ent
operator|->
name|ae_type
argument_list|,
name|ent
operator|->
name|ae_opts
argument_list|,
name|ent
operator|->
name|ae_rpath
argument_list|,
name|ent
operator|->
name|ae_fullpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"running:\n\t%s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|autoreq_seterrno
argument_list|(
name|req
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* XXX: fix ONLIST in kernel */
comment|/* req->au_flags = 1; */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mount_browse
parameter_list|(
name|req
parameter_list|,
name|ent
parameter_list|)
name|struct
name|autofs_userreq
modifier|*
name|req
decl_stmt|;
name|struct
name|autoentry
modifier|*
name|ent
decl_stmt|;
block|{
name|off_t
name|off
decl_stmt|;
if|if
condition|(
name|ent
operator|->
name|ae_browse
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|autoreq_getop
argument_list|(
name|req
argument_list|)
operator|!=
name|AUTOREQ_OP_READDIR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|autoreq_getoffset
argument_list|(
name|req
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|<
sizeof|sizeof
argument_list|(
name|dumbents
argument_list|)
condition|)
name|autoreq_setaux
argument_list|(
name|req
argument_list|,
name|dumbents
argument_list|,
sizeof|sizeof
argument_list|(
name|dumbents
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mount_browse: offset %d, size %d\n"
argument_list|,
operator|(
name|int
operator|)
name|off
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|dumbents
argument_list|)
argument_list|)
expr_stmt|;
name|autoreq_seteof
argument_list|(
name|req
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ask the filesystem passed in if it has a pending request.  * if so process them.  */
end_comment

begin_function
name|void
name|dotheneedful
parameter_list|(
name|autoh_t
name|ah
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|;
name|autoreq_t
modifier|*
name|reqs
decl_stmt|;
if|if
condition|(
name|autoreq_get
argument_list|(
name|ah
argument_list|,
operator|&
name|reqs
argument_list|,
operator|&
name|cnt
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"autoreq_get"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"processing request for '%s' '%s'\n"
argument_list|,
name|autoh_mp
argument_list|(
name|ah
argument_list|)
argument_list|,
name|autoreq_getpath
argument_list|(
name|reqs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|doreq
argument_list|(
name|ah
argument_list|,
name|reqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|reqs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|poll_handles
parameter_list|(
name|autoh_t
modifier|*
name|array
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|saved_errno
decl_stmt|,
name|x
decl_stmt|;
specifier|static
name|struct
name|pollfd
modifier|*
name|pfd
init|=
name|NULL
decl_stmt|;
name|pfd
operator|=
name|reallocf
argument_list|(
name|pfd
argument_list|,
name|cnt
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|pfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfd
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|pfd
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|autoh_fd
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pfd
index|[
name|i
index|]
operator|.
name|events
operator|=
name|POLLPRI
expr_stmt|;
name|pfd
index|[
name|i
index|]
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"start polling...\n"
argument_list|)
expr_stmt|;
name|x
operator|=
name|poll
argument_list|(
name|pfd
argument_list|,
name|cnt
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|saved_errno
operator|=
name|errno
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done polling...\n"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* at least one fs is ready... */
if|if
condition|(
name|x
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|eventloop
parameter_list|(
name|void
parameter_list|)
block|{
name|autoh_t
modifier|*
name|array
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"starting event loop...\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|autoh_getall
argument_list|(
operator|&
name|array
argument_list|,
operator|&
name|cnt
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"autoh_getall"
argument_list|)
expr_stmt|;
if|if
condition|(
name|poll_handles
argument_list|(
name|array
argument_list|,
name|cnt
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"poll_handles"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|dotheneedful
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|autoh_freeall
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|getuid
argument_list|()
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"autodriver needs to be run as root to work."
argument_list|)
expr_stmt|;
name|parsetab
argument_list|()
expr_stmt|;
name|populate_tab
argument_list|()
expr_stmt|;
name|eventloop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

