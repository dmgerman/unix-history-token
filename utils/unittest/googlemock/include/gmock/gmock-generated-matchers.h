begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// This file was GENERATED by command:
end_comment

begin_comment
comment|//     pump.py gmock-generated-matchers.h.pump
end_comment

begin_comment
comment|// DO NOT EDIT BY HAND!!!
end_comment

begin_comment
comment|// Copyright 2008, Google Inc.
end_comment

begin_comment
comment|// All rights reserved.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Redistribution and use in source and binary forms, with or without
end_comment

begin_comment
comment|// modification, are permitted provided that the following conditions are
end_comment

begin_comment
comment|// met:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     * Redistributions of source code must retain the above copyright
end_comment

begin_comment
comment|// notice, this list of conditions and the following disclaimer.
end_comment

begin_comment
comment|//     * Redistributions in binary form must reproduce the above
end_comment

begin_comment
comment|// copyright notice, this list of conditions and the following disclaimer
end_comment

begin_comment
comment|// in the documentation and/or other materials provided with the
end_comment

begin_comment
comment|// distribution.
end_comment

begin_comment
comment|//     * Neither the name of Google Inc. nor the names of its
end_comment

begin_comment
comment|// contributors may be used to endorse or promote products derived from
end_comment

begin_comment
comment|// this software without specific prior written permission.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
end_comment

begin_comment
comment|// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
end_comment

begin_comment
comment|// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
end_comment

begin_comment
comment|// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
end_comment

begin_comment
comment|// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
end_comment

begin_comment
comment|// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
end_comment

begin_comment
comment|// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
end_comment

begin_comment
comment|// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
end_comment

begin_comment
comment|// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
end_comment

begin_comment
comment|// Google Mock - a framework for writing C++ mock classes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file implements some commonly used variadic matchers.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_
end_ifndef

begin_define
define|#
directive|define
name|GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_
end_define

begin_include
include|#
directive|include
file|<iterator>
end_include

begin_include
include|#
directive|include
file|<sstream>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_include
include|#
directive|include
file|"gmock/gmock-matchers.h"
end_include

begin_decl_stmt
name|namespace
name|testing
block|{
name|namespace
name|internal
block|{
comment|// The type of the i-th (0-based) field of Tuple.
define|#
directive|define
name|GMOCK_FIELD_TYPE_
parameter_list|(
name|Tuple
parameter_list|,
name|i
parameter_list|)
define|\
value|typename ::testing::tuple_element<i, Tuple>::type
comment|// TupleFields<Tuple, k0, ..., kn> is for selecting fields from a
comment|// tuple of type Tuple.  It has two members:
comment|//
comment|//   type: a tuple type whose i-th field is the ki-th field of Tuple.
comment|//   GetSelectedFields(t): returns fields k0, ..., and kn of t as a tuple.
comment|//
comment|// For example, in class TupleFields<tuple<bool, char, int>, 2, 0>, we have:
comment|//
comment|//   type is tuple<int, bool>, and
comment|//   GetSelectedFields(make_tuple(true, 'a', 42)) is (42, true).
name|template
operator|<
name|class
name|Tuple
operator|,
name|int
name|k0
operator|=
operator|-
literal|1
operator|,
name|int
name|k1
operator|=
operator|-
literal|1
operator|,
name|int
name|k2
operator|=
operator|-
literal|1
operator|,
name|int
name|k3
operator|=
operator|-
literal|1
operator|,
name|int
name|k4
operator|=
operator|-
literal|1
operator|,
name|int
name|k5
operator|=
operator|-
literal|1
operator|,
name|int
name|k6
operator|=
operator|-
literal|1
operator|,
name|int
name|k7
operator|=
operator|-
literal|1
operator|,
name|int
name|k8
operator|=
operator|-
literal|1
operator|,
name|int
name|k9
operator|=
operator|-
literal|1
operator|>
name|class
name|TupleFields
expr_stmt|;
comment|// This generic version is used when there are 10 selectors.
name|template
operator|<
name|class
name|Tuple
operator|,
name|int
name|k0
operator|,
name|int
name|k1
operator|,
name|int
name|k2
operator|,
name|int
name|k3
operator|,
name|int
name|k4
operator|,
name|int
name|k5
operator|,
name|int
name|k6
operator|,
name|int
name|k7
operator|,
name|int
name|k8
operator|,
name|int
name|k9
operator|>
name|class
name|TupleFields
block|{
name|public
operator|:
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k0
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k1
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k2
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k3
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k4
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k5
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k6
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k7
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k8
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k9
argument_list|)
operator|>
name|type
expr_stmt|;
specifier|static
name|type
name|GetSelectedFields
argument_list|(
argument|const Tuple& t
argument_list|)
block|{
return|return
name|type
argument_list|(
name|get
operator|<
name|k0
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k1
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k2
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k3
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k4
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k5
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k6
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k7
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k8
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k9
operator|>
operator|(
name|t
operator|)
argument_list|)
return|;
block|}
block|}
empty_stmt|;
comment|// The following specialization is used for 0 ~ 9 selectors.
name|template
operator|<
name|class
name|Tuple
operator|>
name|class
name|TupleFields
operator|<
name|Tuple
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|>
block|{
name|public
operator|:
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
operator|>
name|type
expr_stmt|;
specifier|static
name|type
name|GetSelectedFields
argument_list|(
argument|const Tuple&
comment|/* t */
argument_list|)
block|{
return|return
name|type
argument_list|()
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|class
name|Tuple
operator|,
name|int
name|k0
operator|>
name|class
name|TupleFields
operator|<
name|Tuple
operator|,
name|k0
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|>
block|{
name|public
operator|:
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k0
argument_list|)
operator|>
name|type
expr_stmt|;
specifier|static
name|type
name|GetSelectedFields
argument_list|(
argument|const Tuple& t
argument_list|)
block|{
return|return
name|type
argument_list|(
name|get
operator|<
name|k0
operator|>
operator|(
name|t
operator|)
argument_list|)
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|class
name|Tuple
operator|,
name|int
name|k0
operator|,
name|int
name|k1
operator|>
name|class
name|TupleFields
operator|<
name|Tuple
operator|,
name|k0
operator|,
name|k1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|>
block|{
name|public
operator|:
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k0
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k1
argument_list|)
operator|>
name|type
expr_stmt|;
specifier|static
name|type
name|GetSelectedFields
argument_list|(
argument|const Tuple& t
argument_list|)
block|{
return|return
name|type
argument_list|(
name|get
operator|<
name|k0
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k1
operator|>
operator|(
name|t
operator|)
argument_list|)
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|class
name|Tuple
operator|,
name|int
name|k0
operator|,
name|int
name|k1
operator|,
name|int
name|k2
operator|>
name|class
name|TupleFields
operator|<
name|Tuple
operator|,
name|k0
operator|,
name|k1
operator|,
name|k2
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|>
block|{
name|public
operator|:
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k0
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k1
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k2
argument_list|)
operator|>
name|type
expr_stmt|;
specifier|static
name|type
name|GetSelectedFields
argument_list|(
argument|const Tuple& t
argument_list|)
block|{
return|return
name|type
argument_list|(
name|get
operator|<
name|k0
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k1
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k2
operator|>
operator|(
name|t
operator|)
argument_list|)
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|class
name|Tuple
operator|,
name|int
name|k0
operator|,
name|int
name|k1
operator|,
name|int
name|k2
operator|,
name|int
name|k3
operator|>
name|class
name|TupleFields
operator|<
name|Tuple
operator|,
name|k0
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|>
block|{
name|public
operator|:
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k0
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k1
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k2
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k3
argument_list|)
operator|>
name|type
expr_stmt|;
specifier|static
name|type
name|GetSelectedFields
argument_list|(
argument|const Tuple& t
argument_list|)
block|{
return|return
name|type
argument_list|(
name|get
operator|<
name|k0
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k1
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k2
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k3
operator|>
operator|(
name|t
operator|)
argument_list|)
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|class
name|Tuple
operator|,
name|int
name|k0
operator|,
name|int
name|k1
operator|,
name|int
name|k2
operator|,
name|int
name|k3
operator|,
name|int
name|k4
operator|>
name|class
name|TupleFields
operator|<
name|Tuple
operator|,
name|k0
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|>
block|{
name|public
operator|:
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k0
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k1
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k2
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k3
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k4
argument_list|)
operator|>
name|type
expr_stmt|;
specifier|static
name|type
name|GetSelectedFields
argument_list|(
argument|const Tuple& t
argument_list|)
block|{
return|return
name|type
argument_list|(
name|get
operator|<
name|k0
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k1
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k2
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k3
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k4
operator|>
operator|(
name|t
operator|)
argument_list|)
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|class
name|Tuple
operator|,
name|int
name|k0
operator|,
name|int
name|k1
operator|,
name|int
name|k2
operator|,
name|int
name|k3
operator|,
name|int
name|k4
operator|,
name|int
name|k5
operator|>
name|class
name|TupleFields
operator|<
name|Tuple
operator|,
name|k0
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|>
block|{
name|public
operator|:
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k0
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k1
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k2
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k3
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k4
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k5
argument_list|)
operator|>
name|type
expr_stmt|;
specifier|static
name|type
name|GetSelectedFields
argument_list|(
argument|const Tuple& t
argument_list|)
block|{
return|return
name|type
argument_list|(
name|get
operator|<
name|k0
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k1
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k2
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k3
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k4
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k5
operator|>
operator|(
name|t
operator|)
argument_list|)
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|class
name|Tuple
operator|,
name|int
name|k0
operator|,
name|int
name|k1
operator|,
name|int
name|k2
operator|,
name|int
name|k3
operator|,
name|int
name|k4
operator|,
name|int
name|k5
operator|,
name|int
name|k6
operator|>
name|class
name|TupleFields
operator|<
name|Tuple
operator|,
name|k0
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|,
name|k6
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|>
block|{
name|public
operator|:
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k0
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k1
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k2
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k3
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k4
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k5
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k6
argument_list|)
operator|>
name|type
expr_stmt|;
specifier|static
name|type
name|GetSelectedFields
argument_list|(
argument|const Tuple& t
argument_list|)
block|{
return|return
name|type
argument_list|(
name|get
operator|<
name|k0
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k1
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k2
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k3
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k4
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k5
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k6
operator|>
operator|(
name|t
operator|)
argument_list|)
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|class
name|Tuple
operator|,
name|int
name|k0
operator|,
name|int
name|k1
operator|,
name|int
name|k2
operator|,
name|int
name|k3
operator|,
name|int
name|k4
operator|,
name|int
name|k5
operator|,
name|int
name|k6
operator|,
name|int
name|k7
operator|>
name|class
name|TupleFields
operator|<
name|Tuple
operator|,
name|k0
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|,
name|k6
operator|,
name|k7
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|>
block|{
name|public
operator|:
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k0
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k1
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k2
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k3
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k4
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k5
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k6
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k7
argument_list|)
operator|>
name|type
expr_stmt|;
specifier|static
name|type
name|GetSelectedFields
argument_list|(
argument|const Tuple& t
argument_list|)
block|{
return|return
name|type
argument_list|(
name|get
operator|<
name|k0
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k1
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k2
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k3
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k4
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k5
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k6
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k7
operator|>
operator|(
name|t
operator|)
argument_list|)
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|class
name|Tuple
operator|,
name|int
name|k0
operator|,
name|int
name|k1
operator|,
name|int
name|k2
operator|,
name|int
name|k3
operator|,
name|int
name|k4
operator|,
name|int
name|k5
operator|,
name|int
name|k6
operator|,
name|int
name|k7
operator|,
name|int
name|k8
operator|>
name|class
name|TupleFields
operator|<
name|Tuple
operator|,
name|k0
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|,
name|k6
operator|,
name|k7
operator|,
name|k8
operator|,
operator|-
literal|1
operator|>
block|{
name|public
operator|:
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k0
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k1
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k2
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k3
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k4
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k5
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k6
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k7
argument_list|)
operator|,
name|GMOCK_FIELD_TYPE_
argument_list|(
name|Tuple
argument_list|,
name|k8
argument_list|)
operator|>
name|type
expr_stmt|;
specifier|static
name|type
name|GetSelectedFields
argument_list|(
argument|const Tuple& t
argument_list|)
block|{
return|return
name|type
argument_list|(
name|get
operator|<
name|k0
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k1
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k2
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k3
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k4
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k5
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k6
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k7
operator|>
operator|(
name|t
operator|)
argument_list|,
name|get
operator|<
name|k8
operator|>
operator|(
name|t
operator|)
argument_list|)
return|;
block|}
block|}
empty_stmt|;
undef|#
directive|undef
name|GMOCK_FIELD_TYPE_
comment|// Implements the Args() matcher.
name|template
operator|<
name|class
name|ArgsTuple
operator|,
name|int
name|k0
operator|=
operator|-
literal|1
operator|,
name|int
name|k1
operator|=
operator|-
literal|1
operator|,
name|int
name|k2
operator|=
operator|-
literal|1
operator|,
name|int
name|k3
operator|=
operator|-
literal|1
operator|,
name|int
name|k4
operator|=
operator|-
literal|1
operator|,
name|int
name|k5
operator|=
operator|-
literal|1
operator|,
name|int
name|k6
operator|=
operator|-
literal|1
operator|,
name|int
name|k7
operator|=
operator|-
literal|1
operator|,
name|int
name|k8
operator|=
operator|-
literal|1
operator|,
name|int
name|k9
operator|=
operator|-
literal|1
operator|>
name|class
name|ArgsMatcherImpl
operator|:
name|public
name|MatcherInterface
operator|<
name|ArgsTuple
operator|>
block|{
name|public
operator|:
comment|// ArgsTuple may have top-level const or reference modifiers.
typedef|typedef
name|GTEST_REMOVE_REFERENCE_AND_CONST_
argument_list|(
argument|ArgsTuple
argument_list|)
name|RawArgsTuple
expr_stmt|;
typedef|typedef
name|typename
name|internal
operator|::
name|TupleFields
operator|<
name|RawArgsTuple
operator|,
name|k0
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|,
name|k6
operator|,
name|k7
operator|,
name|k8
operator|,
name|k9
operator|>
operator|::
name|type
name|SelectedArgs
expr_stmt|;
typedef|typedef
name|Matcher
operator|<
specifier|const
name|SelectedArgs
operator|&
operator|>
name|MonomorphicInnerMatcher
expr_stmt|;
name|template
operator|<
name|typename
name|InnerMatcher
operator|>
name|explicit
name|ArgsMatcherImpl
argument_list|(
specifier|const
name|InnerMatcher
operator|&
name|inner_matcher
argument_list|)
operator|:
name|inner_matcher_
argument_list|(
argument|SafeMatcherCast<const SelectedArgs&>(inner_matcher)
argument_list|)
block|{}
name|virtual
name|bool
name|MatchAndExplain
argument_list|(
argument|ArgsTuple args
argument_list|,
argument|MatchResultListener* listener
argument_list|)
specifier|const
block|{
specifier|const
name|SelectedArgs
operator|&
name|selected_args
operator|=
name|GetSelectedArgs
argument_list|(
name|args
argument_list|)
block|;
if|if
condition|(
operator|!
name|listener
operator|->
name|IsInterested
argument_list|()
condition|)
return|return
name|inner_matcher_
operator|.
name|Matches
argument_list|(
name|selected_args
argument_list|)
return|;
name|PrintIndices
argument_list|(
name|listener
operator|->
name|stream
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|listener
operator|<<
literal|"are "
operator|<<
name|PrintToString
argument_list|(
name|selected_args
argument_list|)
expr_stmt|;
name|StringMatchResultListener
name|inner_listener
decl_stmt|;
specifier|const
name|bool
name|match
init|=
name|inner_matcher_
operator|.
name|MatchAndExplain
argument_list|(
name|selected_args
argument_list|,
operator|&
name|inner_listener
argument_list|)
decl_stmt|;
name|PrintIfNotEmpty
argument_list|(
name|inner_listener
operator|.
name|str
argument_list|()
argument_list|,
name|listener
operator|->
name|stream
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|match
return|;
block|}
name|virtual
name|void
name|DescribeTo
argument_list|(
operator|::
name|std
operator|::
name|ostream
operator|*
name|os
argument_list|)
decl|const
block|{
operator|*
name|os
operator|<<
literal|"are a tuple "
expr_stmt|;
name|PrintIndices
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|inner_matcher_
operator|.
name|DescribeTo
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
name|virtual
name|void
name|DescribeNegationTo
argument_list|(
operator|::
name|std
operator|::
name|ostream
operator|*
name|os
argument_list|)
decl|const
block|{
operator|*
name|os
operator|<<
literal|"are a tuple "
expr_stmt|;
name|PrintIndices
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|inner_matcher_
operator|.
name|DescribeNegationTo
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
name|private
label|:
specifier|static
name|SelectedArgs
name|GetSelectedArgs
parameter_list|(
name|ArgsTuple
name|args
parameter_list|)
block|{
return|return
name|TupleFields
operator|<
name|RawArgsTuple
operator|,
name|k0
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|,
name|k6
operator|,
name|k7
operator|,
name|k8
operator|,
name|k9
operator|>
operator|::
name|GetSelectedFields
argument_list|(
name|args
argument_list|)
return|;
block|}
comment|// Prints the indices of the selected fields.
specifier|static
name|void
name|PrintIndices
argument_list|(
operator|::
name|std
operator|::
name|ostream
operator|*
name|os
argument_list|)
block|{
operator|*
name|os
operator|<<
literal|"whose fields ("
expr_stmt|;
specifier|const
name|int
name|indices
index|[
literal|10
index|]
init|=
block|{
name|k0
block|,
name|k1
block|,
name|k2
block|,
name|k3
block|,
name|k4
block|,
name|k5
block|,
name|k6
block|,
name|k7
block|,
name|k8
block|,
name|k9
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|indices
index|[
name|i
index|]
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|1
condition|)
operator|*
name|os
operator|<<
literal|", "
expr_stmt|;
operator|*
name|os
operator|<<
literal|"#"
operator|<<
name|indices
index|[
name|i
index|]
expr_stmt|;
block|}
operator|*
name|os
operator|<<
literal|") "
expr_stmt|;
block|}
specifier|const
name|MonomorphicInnerMatcher
name|inner_matcher_
decl_stmt|;
name|GTEST_DISALLOW_ASSIGN_
argument_list|(
name|ArgsMatcherImpl
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|InnerMatcher
operator|,
name|int
name|k0
operator|=
operator|-
literal|1
operator|,
name|int
name|k1
operator|=
operator|-
literal|1
operator|,
name|int
name|k2
operator|=
operator|-
literal|1
operator|,
name|int
name|k3
operator|=
operator|-
literal|1
operator|,
name|int
name|k4
operator|=
operator|-
literal|1
operator|,
name|int
name|k5
operator|=
operator|-
literal|1
operator|,
name|int
name|k6
operator|=
operator|-
literal|1
operator|,
name|int
name|k7
operator|=
operator|-
literal|1
operator|,
name|int
name|k8
operator|=
operator|-
literal|1
operator|,
name|int
name|k9
operator|=
operator|-
literal|1
operator|>
name|class
name|ArgsMatcher
block|{
name|public
operator|:
name|explicit
name|ArgsMatcher
argument_list|(
specifier|const
name|InnerMatcher
operator|&
name|inner_matcher
argument_list|)
operator|:
name|inner_matcher_
argument_list|(
argument|inner_matcher
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ArgsTuple
operator|>
name|operator
name|Matcher
operator|<
name|ArgsTuple
operator|>
operator|(
operator|)
specifier|const
block|{
return|return
name|MakeMatcher
argument_list|(
argument|new ArgsMatcherImpl<ArgsTuple
argument_list|,
argument|k0
argument_list|,
argument|k1
argument_list|,
argument|k2
argument_list|,
argument|k3
argument_list|,
argument|k4
argument_list|,
argument|k5
argument_list|,
argument|k6
argument_list|,
argument|k7
argument_list|,
argument|k8
argument_list|,
argument|k9>(inner_matcher_)
argument_list|)
return|;
block|}
name|private
operator|:
specifier|const
name|InnerMatcher
name|inner_matcher_
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|GTEST_DISALLOW_ASSIGN_
argument_list|(
name|ArgsMatcher
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|// A set of metafunctions for computing the result type of AllOf.
end_comment

begin_comment
comment|// AllOf(m1, ..., mN) returns
end_comment

begin_comment
comment|// AllOfResultN<decltype(m1), ..., decltype(mN)>::type.
end_comment

begin_comment
comment|// Although AllOf isn't defined for one argument, AllOfResult1 is defined
end_comment

begin_comment
comment|// to simplify the implementation.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|>
expr|struct
name|AllOfResult1
block|{
typedef|typedef
name|M1
name|type
typedef|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|>
expr|struct
name|AllOfResult2
block|{
typedef|typedef
name|BothOfMatcher
operator|<
name|typename
name|AllOfResult1
operator|<
name|M1
operator|>
operator|::
name|type
operator|,
name|typename
name|AllOfResult1
operator|<
name|M2
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|>
expr|struct
name|AllOfResult3
block|{
typedef|typedef
name|BothOfMatcher
operator|<
name|typename
name|AllOfResult1
operator|<
name|M1
operator|>
operator|::
name|type
operator|,
name|typename
name|AllOfResult2
operator|<
name|M2
operator|,
name|M3
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|>
expr|struct
name|AllOfResult4
block|{
typedef|typedef
name|BothOfMatcher
operator|<
name|typename
name|AllOfResult2
operator|<
name|M1
operator|,
name|M2
operator|>
operator|::
name|type
operator|,
name|typename
name|AllOfResult2
operator|<
name|M3
operator|,
name|M4
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|>
expr|struct
name|AllOfResult5
block|{
typedef|typedef
name|BothOfMatcher
operator|<
name|typename
name|AllOfResult2
operator|<
name|M1
operator|,
name|M2
operator|>
operator|::
name|type
operator|,
name|typename
name|AllOfResult3
operator|<
name|M3
operator|,
name|M4
operator|,
name|M5
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|>
expr|struct
name|AllOfResult6
block|{
typedef|typedef
name|BothOfMatcher
operator|<
name|typename
name|AllOfResult3
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|>
operator|::
name|type
operator|,
name|typename
name|AllOfResult3
operator|<
name|M4
operator|,
name|M5
operator|,
name|M6
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|,
name|typename
name|M7
operator|>
expr|struct
name|AllOfResult7
block|{
typedef|typedef
name|BothOfMatcher
operator|<
name|typename
name|AllOfResult3
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|>
operator|::
name|type
operator|,
name|typename
name|AllOfResult4
operator|<
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|,
name|typename
name|M7
operator|,
name|typename
name|M8
operator|>
expr|struct
name|AllOfResult8
block|{
typedef|typedef
name|BothOfMatcher
operator|<
name|typename
name|AllOfResult4
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|>
operator|::
name|type
operator|,
name|typename
name|AllOfResult4
operator|<
name|M5
operator|,
name|M6
operator|,
name|M7
operator|,
name|M8
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|,
name|typename
name|M7
operator|,
name|typename
name|M8
operator|,
name|typename
name|M9
operator|>
expr|struct
name|AllOfResult9
block|{
typedef|typedef
name|BothOfMatcher
operator|<
name|typename
name|AllOfResult4
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|>
operator|::
name|type
operator|,
name|typename
name|AllOfResult5
operator|<
name|M5
operator|,
name|M6
operator|,
name|M7
operator|,
name|M8
operator|,
name|M9
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|,
name|typename
name|M7
operator|,
name|typename
name|M8
operator|,
name|typename
name|M9
operator|,
name|typename
name|M10
operator|>
expr|struct
name|AllOfResult10
block|{
typedef|typedef
name|BothOfMatcher
operator|<
name|typename
name|AllOfResult5
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|>
operator|::
name|type
operator|,
name|typename
name|AllOfResult5
operator|<
name|M6
operator|,
name|M7
operator|,
name|M8
operator|,
name|M9
operator|,
name|M10
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// A set of metafunctions for computing the result type of AnyOf.
end_comment

begin_comment
comment|// AnyOf(m1, ..., mN) returns
end_comment

begin_comment
comment|// AnyOfResultN<decltype(m1), ..., decltype(mN)>::type.
end_comment

begin_comment
comment|// Although AnyOf isn't defined for one argument, AnyOfResult1 is defined
end_comment

begin_comment
comment|// to simplify the implementation.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|>
expr|struct
name|AnyOfResult1
block|{
typedef|typedef
name|M1
name|type
typedef|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|>
expr|struct
name|AnyOfResult2
block|{
typedef|typedef
name|EitherOfMatcher
operator|<
name|typename
name|AnyOfResult1
operator|<
name|M1
operator|>
operator|::
name|type
operator|,
name|typename
name|AnyOfResult1
operator|<
name|M2
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|>
expr|struct
name|AnyOfResult3
block|{
typedef|typedef
name|EitherOfMatcher
operator|<
name|typename
name|AnyOfResult1
operator|<
name|M1
operator|>
operator|::
name|type
operator|,
name|typename
name|AnyOfResult2
operator|<
name|M2
operator|,
name|M3
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|>
expr|struct
name|AnyOfResult4
block|{
typedef|typedef
name|EitherOfMatcher
operator|<
name|typename
name|AnyOfResult2
operator|<
name|M1
operator|,
name|M2
operator|>
operator|::
name|type
operator|,
name|typename
name|AnyOfResult2
operator|<
name|M3
operator|,
name|M4
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|>
expr|struct
name|AnyOfResult5
block|{
typedef|typedef
name|EitherOfMatcher
operator|<
name|typename
name|AnyOfResult2
operator|<
name|M1
operator|,
name|M2
operator|>
operator|::
name|type
operator|,
name|typename
name|AnyOfResult3
operator|<
name|M3
operator|,
name|M4
operator|,
name|M5
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|>
expr|struct
name|AnyOfResult6
block|{
typedef|typedef
name|EitherOfMatcher
operator|<
name|typename
name|AnyOfResult3
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|>
operator|::
name|type
operator|,
name|typename
name|AnyOfResult3
operator|<
name|M4
operator|,
name|M5
operator|,
name|M6
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|,
name|typename
name|M7
operator|>
expr|struct
name|AnyOfResult7
block|{
typedef|typedef
name|EitherOfMatcher
operator|<
name|typename
name|AnyOfResult3
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|>
operator|::
name|type
operator|,
name|typename
name|AnyOfResult4
operator|<
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|,
name|typename
name|M7
operator|,
name|typename
name|M8
operator|>
expr|struct
name|AnyOfResult8
block|{
typedef|typedef
name|EitherOfMatcher
operator|<
name|typename
name|AnyOfResult4
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|>
operator|::
name|type
operator|,
name|typename
name|AnyOfResult4
operator|<
name|M5
operator|,
name|M6
operator|,
name|M7
operator|,
name|M8
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|,
name|typename
name|M7
operator|,
name|typename
name|M8
operator|,
name|typename
name|M9
operator|>
expr|struct
name|AnyOfResult9
block|{
typedef|typedef
name|EitherOfMatcher
operator|<
name|typename
name|AnyOfResult4
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|>
operator|::
name|type
operator|,
name|typename
name|AnyOfResult5
operator|<
name|M5
operator|,
name|M6
operator|,
name|M7
operator|,
name|M8
operator|,
name|M9
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|,
name|typename
name|M7
operator|,
name|typename
name|M8
operator|,
name|typename
name|M9
operator|,
name|typename
name|M10
operator|>
expr|struct
name|AnyOfResult10
block|{
typedef|typedef
name|EitherOfMatcher
operator|<
name|typename
name|AnyOfResult5
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|>
operator|::
name|type
operator|,
name|typename
name|AnyOfResult5
operator|<
name|M6
operator|,
name|M7
operator|,
name|M8
operator|,
name|M9
operator|,
name|M10
operator|>
operator|::
name|type
operator|>
name|type
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// namespace internal
end_comment

begin_comment
comment|// Args<N1, N2, ..., Nk>(a_matcher) matches a tuple if the selected
end_comment

begin_comment
comment|// fields of it matches a_matcher.  C++ doesn't support default
end_comment

begin_comment
comment|// arguments for function templates, so we have to overload it.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|InnerMatcher
operator|>
specifier|inline
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|>
name|Args
argument_list|(
argument|const InnerMatcher& matcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|>
operator|(
name|matcher
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|int
name|k1
operator|,
name|typename
name|InnerMatcher
operator|>
specifier|inline
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|>
name|Args
argument_list|(
argument|const InnerMatcher& matcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|>
operator|(
name|matcher
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|int
name|k1
operator|,
name|int
name|k2
operator|,
name|typename
name|InnerMatcher
operator|>
specifier|inline
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|>
name|Args
argument_list|(
argument|const InnerMatcher& matcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|>
operator|(
name|matcher
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|int
name|k1
operator|,
name|int
name|k2
operator|,
name|int
name|k3
operator|,
name|typename
name|InnerMatcher
operator|>
specifier|inline
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|>
name|Args
argument_list|(
argument|const InnerMatcher& matcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|>
operator|(
name|matcher
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|int
name|k1
operator|,
name|int
name|k2
operator|,
name|int
name|k3
operator|,
name|int
name|k4
operator|,
name|typename
name|InnerMatcher
operator|>
specifier|inline
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|>
name|Args
argument_list|(
argument|const InnerMatcher& matcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|>
operator|(
name|matcher
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|int
name|k1
operator|,
name|int
name|k2
operator|,
name|int
name|k3
operator|,
name|int
name|k4
operator|,
name|int
name|k5
operator|,
name|typename
name|InnerMatcher
operator|>
specifier|inline
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|>
name|Args
argument_list|(
argument|const InnerMatcher& matcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|>
operator|(
name|matcher
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|int
name|k1
operator|,
name|int
name|k2
operator|,
name|int
name|k3
operator|,
name|int
name|k4
operator|,
name|int
name|k5
operator|,
name|int
name|k6
operator|,
name|typename
name|InnerMatcher
operator|>
specifier|inline
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|,
name|k6
operator|>
name|Args
argument_list|(
argument|const InnerMatcher& matcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|,
name|k6
operator|>
operator|(
name|matcher
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|int
name|k1
operator|,
name|int
name|k2
operator|,
name|int
name|k3
operator|,
name|int
name|k4
operator|,
name|int
name|k5
operator|,
name|int
name|k6
operator|,
name|int
name|k7
operator|,
name|typename
name|InnerMatcher
operator|>
specifier|inline
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|,
name|k6
operator|,
name|k7
operator|>
name|Args
argument_list|(
argument|const InnerMatcher& matcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|,
name|k6
operator|,
name|k7
operator|>
operator|(
name|matcher
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|int
name|k1
operator|,
name|int
name|k2
operator|,
name|int
name|k3
operator|,
name|int
name|k4
operator|,
name|int
name|k5
operator|,
name|int
name|k6
operator|,
name|int
name|k7
operator|,
name|int
name|k8
operator|,
name|typename
name|InnerMatcher
operator|>
specifier|inline
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|,
name|k6
operator|,
name|k7
operator|,
name|k8
operator|>
name|Args
argument_list|(
argument|const InnerMatcher& matcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|,
name|k6
operator|,
name|k7
operator|,
name|k8
operator|>
operator|(
name|matcher
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|int
name|k1
operator|,
name|int
name|k2
operator|,
name|int
name|k3
operator|,
name|int
name|k4
operator|,
name|int
name|k5
operator|,
name|int
name|k6
operator|,
name|int
name|k7
operator|,
name|int
name|k8
operator|,
name|int
name|k9
operator|,
name|typename
name|InnerMatcher
operator|>
specifier|inline
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|,
name|k6
operator|,
name|k7
operator|,
name|k8
operator|,
name|k9
operator|>
name|Args
argument_list|(
argument|const InnerMatcher& matcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|,
name|k6
operator|,
name|k7
operator|,
name|k8
operator|,
name|k9
operator|>
operator|(
name|matcher
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|int
name|k1
operator|,
name|int
name|k2
operator|,
name|int
name|k3
operator|,
name|int
name|k4
operator|,
name|int
name|k5
operator|,
name|int
name|k6
operator|,
name|int
name|k7
operator|,
name|int
name|k8
operator|,
name|int
name|k9
operator|,
name|int
name|k10
operator|,
name|typename
name|InnerMatcher
operator|>
specifier|inline
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|,
name|k6
operator|,
name|k7
operator|,
name|k8
operator|,
name|k9
operator|,
name|k10
operator|>
name|Args
argument_list|(
argument|const InnerMatcher& matcher
argument_list|)
block|{
return|return
name|internal
operator|::
name|ArgsMatcher
operator|<
name|InnerMatcher
operator|,
name|k1
operator|,
name|k2
operator|,
name|k3
operator|,
name|k4
operator|,
name|k5
operator|,
name|k6
operator|,
name|k7
operator|,
name|k8
operator|,
name|k9
operator|,
name|k10
operator|>
operator|(
name|matcher
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// ElementsAre(e_1, e_2, ... e_n) matches an STL-style container with
end_comment

begin_comment
comment|// n elements, where the i-th element in the container must
end_comment

begin_comment
comment|// match the i-th argument in the list.  Each argument of
end_comment

begin_comment
comment|// ElementsAre() can be either a value or a matcher.  We support up to
end_comment

begin_comment
comment|// 10 arguments.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The use of DecayArray in the implementation allows ElementsAre()
end_comment

begin_comment
comment|// to accept string literals, whose type is const char[N], but we
end_comment

begin_comment
comment|// want to treat them as const char*.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// NOTE: Since ElementsAre() cares about the order of the elements, it
end_comment

begin_comment
comment|// must not be used with containers whose elements's order is
end_comment

begin_comment
comment|// undefined (e.g. hash_map).
end_comment

begin_expr_stmt
specifier|inline
name|internal
operator|::
name|ElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
operator|>
expr|>
name|ElementsAre
argument_list|()
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|ElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|()
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|>
specifier|inline
name|internal
operator|::
name|ElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|>
expr|>
name|ElementsAre
argument_list|(
argument|const T1& e1
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|ElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|>
specifier|inline
name|internal
operator|::
name|ElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|>
expr|>
name|ElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|ElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|T3
operator|>
specifier|inline
name|internal
operator|::
name|ElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|>
expr|>
name|ElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|,
argument|const T3& e3
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|ElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|T3
operator|,
name|typename
name|T4
operator|>
specifier|inline
name|internal
operator|::
name|ElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|>
expr|>
name|ElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|,
argument|const T3& e3
argument_list|,
argument|const T4& e4
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|ElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|T3
operator|,
name|typename
name|T4
operator|,
name|typename
name|T5
operator|>
specifier|inline
name|internal
operator|::
name|ElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|>
expr|>
name|ElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|,
argument|const T3& e3
argument_list|,
argument|const T4& e4
argument_list|,
argument|const T5& e5
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|ElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|T3
operator|,
name|typename
name|T4
operator|,
name|typename
name|T5
operator|,
name|typename
name|T6
operator|>
specifier|inline
name|internal
operator|::
name|ElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|>
expr|>
name|ElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|,
argument|const T3& e3
argument_list|,
argument|const T4& e4
argument_list|,
argument|const T5& e5
argument_list|,
argument|const T6& e6
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|ElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|,
name|e6
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|T3
operator|,
name|typename
name|T4
operator|,
name|typename
name|T5
operator|,
name|typename
name|T6
operator|,
name|typename
name|T7
operator|>
specifier|inline
name|internal
operator|::
name|ElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T7
operator|>
operator|::
name|type
operator|>
expr|>
name|ElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|,
argument|const T3& e3
argument_list|,
argument|const T4& e4
argument_list|,
argument|const T5& e5
argument_list|,
argument|const T6& e6
argument_list|,
argument|const T7& e7
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T7
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|ElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|,
name|e6
argument_list|,
name|e7
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|T3
operator|,
name|typename
name|T4
operator|,
name|typename
name|T5
operator|,
name|typename
name|T6
operator|,
name|typename
name|T7
operator|,
name|typename
name|T8
operator|>
specifier|inline
name|internal
operator|::
name|ElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T7
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T8
operator|>
operator|::
name|type
operator|>
expr|>
name|ElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|,
argument|const T3& e3
argument_list|,
argument|const T4& e4
argument_list|,
argument|const T5& e5
argument_list|,
argument|const T6& e6
argument_list|,
argument|const T7& e7
argument_list|,
argument|const T8& e8
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T7
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T8
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|ElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|,
name|e6
argument_list|,
name|e7
argument_list|,
name|e8
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|T3
operator|,
name|typename
name|T4
operator|,
name|typename
name|T5
operator|,
name|typename
name|T6
operator|,
name|typename
name|T7
operator|,
name|typename
name|T8
operator|,
name|typename
name|T9
operator|>
specifier|inline
name|internal
operator|::
name|ElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T7
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T8
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T9
operator|>
operator|::
name|type
operator|>
expr|>
name|ElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|,
argument|const T3& e3
argument_list|,
argument|const T4& e4
argument_list|,
argument|const T5& e5
argument_list|,
argument|const T6& e6
argument_list|,
argument|const T7& e7
argument_list|,
argument|const T8& e8
argument_list|,
argument|const T9& e9
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T7
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T8
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T9
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|ElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|,
name|e6
argument_list|,
name|e7
argument_list|,
name|e8
argument_list|,
name|e9
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|T3
operator|,
name|typename
name|T4
operator|,
name|typename
name|T5
operator|,
name|typename
name|T6
operator|,
name|typename
name|T7
operator|,
name|typename
name|T8
operator|,
name|typename
name|T9
operator|,
name|typename
name|T10
operator|>
specifier|inline
name|internal
operator|::
name|ElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T7
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T8
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T9
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T10
operator|>
operator|::
name|type
operator|>
expr|>
name|ElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|,
argument|const T3& e3
argument_list|,
argument|const T4& e4
argument_list|,
argument|const T5& e5
argument_list|,
argument|const T6& e6
argument_list|,
argument|const T7& e7
argument_list|,
argument|const T8& e8
argument_list|,
argument|const T9& e9
argument_list|,
argument|const T10& e10
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T7
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T8
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T9
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T10
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|ElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|,
name|e6
argument_list|,
name|e7
argument_list|,
name|e8
argument_list|,
name|e9
argument_list|,
name|e10
argument_list|)
operator|)
return|;
end_return

begin_comment
unit|}
comment|// UnorderedElementsAre(e_1, e_2, ..., e_n) is an ElementsAre extension
end_comment

begin_comment
comment|// that matches n elements in any order.  We support up to n=10 arguments.
end_comment

begin_expr_stmt
unit|inline
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
operator|>
expr|>
name|UnorderedElementsAre
argument_list|()
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|()
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|>
specifier|inline
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|>
expr|>
name|UnorderedElementsAre
argument_list|(
argument|const T1& e1
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|>
specifier|inline
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|>
expr|>
name|UnorderedElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|T3
operator|>
specifier|inline
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|>
expr|>
name|UnorderedElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|,
argument|const T3& e3
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|T3
operator|,
name|typename
name|T4
operator|>
specifier|inline
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|>
expr|>
name|UnorderedElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|,
argument|const T3& e3
argument_list|,
argument|const T4& e4
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|T3
operator|,
name|typename
name|T4
operator|,
name|typename
name|T5
operator|>
specifier|inline
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|>
expr|>
name|UnorderedElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|,
argument|const T3& e3
argument_list|,
argument|const T4& e4
argument_list|,
argument|const T5& e5
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|T3
operator|,
name|typename
name|T4
operator|,
name|typename
name|T5
operator|,
name|typename
name|T6
operator|>
specifier|inline
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|>
expr|>
name|UnorderedElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|,
argument|const T3& e3
argument_list|,
argument|const T4& e4
argument_list|,
argument|const T5& e5
argument_list|,
argument|const T6& e6
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|,
name|e6
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|T3
operator|,
name|typename
name|T4
operator|,
name|typename
name|T5
operator|,
name|typename
name|T6
operator|,
name|typename
name|T7
operator|>
specifier|inline
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T7
operator|>
operator|::
name|type
operator|>
expr|>
name|UnorderedElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|,
argument|const T3& e3
argument_list|,
argument|const T4& e4
argument_list|,
argument|const T5& e5
argument_list|,
argument|const T6& e6
argument_list|,
argument|const T7& e7
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T7
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|,
name|e6
argument_list|,
name|e7
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|T3
operator|,
name|typename
name|T4
operator|,
name|typename
name|T5
operator|,
name|typename
name|T6
operator|,
name|typename
name|T7
operator|,
name|typename
name|T8
operator|>
specifier|inline
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T7
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T8
operator|>
operator|::
name|type
operator|>
expr|>
name|UnorderedElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|,
argument|const T3& e3
argument_list|,
argument|const T4& e4
argument_list|,
argument|const T5& e5
argument_list|,
argument|const T6& e6
argument_list|,
argument|const T7& e7
argument_list|,
argument|const T8& e8
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T7
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T8
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|,
name|e6
argument_list|,
name|e7
argument_list|,
name|e8
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|T3
operator|,
name|typename
name|T4
operator|,
name|typename
name|T5
operator|,
name|typename
name|T6
operator|,
name|typename
name|T7
operator|,
name|typename
name|T8
operator|,
name|typename
name|T9
operator|>
specifier|inline
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T7
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T8
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T9
operator|>
operator|::
name|type
operator|>
expr|>
name|UnorderedElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|,
argument|const T3& e3
argument_list|,
argument|const T4& e4
argument_list|,
argument|const T5& e5
argument_list|,
argument|const T6& e6
argument_list|,
argument|const T7& e7
argument_list|,
argument|const T8& e8
argument_list|,
argument|const T9& e9
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T7
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T8
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T9
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|,
name|e6
argument_list|,
name|e7
argument_list|,
name|e8
argument_list|,
name|e9
argument_list|)
operator|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T1
operator|,
name|typename
name|T2
operator|,
name|typename
name|T3
operator|,
name|typename
name|T4
operator|,
name|typename
name|T5
operator|,
name|typename
name|T6
operator|,
name|typename
name|T7
operator|,
name|typename
name|T8
operator|,
name|typename
name|T9
operator|,
name|typename
name|T10
operator|>
specifier|inline
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T7
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T8
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T9
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T10
operator|>
operator|::
name|type
operator|>
expr|>
name|UnorderedElementsAre
argument_list|(
argument|const T1& e1
argument_list|,
argument|const T2& e2
argument_list|,
argument|const T3& e3
argument_list|,
argument|const T4& e4
argument_list|,
argument|const T5& e5
argument_list|,
argument|const T6& e6
argument_list|,
argument|const T7& e7
argument_list|,
argument|const T8& e8
argument_list|,
argument|const T9& e9
argument_list|,
argument|const T10& e10
argument_list|)
block|{
typedef|typedef
operator|::
name|testing
operator|::
name|tuple
operator|<
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T1
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T2
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T3
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T4
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T5
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T6
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T7
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T8
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T9
operator|>
operator|::
name|type
operator|,
name|typename
name|internal
operator|::
name|DecayArray
operator|<
name|T10
operator|>
operator|::
name|type
operator|>
name|Args
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|internal
operator|::
name|UnorderedElementsAreMatcher
operator|<
name|Args
operator|>
operator|(
name|Args
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
name|e3
argument_list|,
name|e4
argument_list|,
name|e5
argument_list|,
name|e6
argument_list|,
name|e7
argument_list|,
name|e8
argument_list|,
name|e9
argument_list|,
name|e10
argument_list|)
operator|)
return|;
end_return

begin_comment
unit|}
comment|// AllOf(m1, m2, ..., mk) matches any value that matches all of the given
end_comment

begin_comment
comment|// sub-matchers.  AllOf is called fully qualified to prevent ADL from firing.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AllOfResult2
operator|<
name|M1
operator|,
name|M2
operator|>
operator|::
name|type
name|AllOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AllOfResult2
operator|<
name|M1
operator|,
name|M2
operator|>
operator|::
name|type
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AllOfResult3
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|>
operator|::
name|type
name|AllOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|,
argument|M3 m3
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AllOfResult3
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|>
operator|::
name|type
argument_list|(
name|m1
argument_list|,
operator|::
name|testing
operator|::
name|AllOf
argument_list|(
name|m2
argument_list|,
name|m3
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AllOfResult4
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|>
operator|::
name|type
name|AllOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|,
argument|M3 m3
argument_list|,
argument|M4 m4
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AllOfResult4
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|>
operator|::
name|type
argument_list|(
operator|::
name|testing
operator|::
name|AllOf
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|)
argument_list|,
operator|::
name|testing
operator|::
name|AllOf
argument_list|(
name|m3
argument_list|,
name|m4
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AllOfResult5
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|>
operator|::
name|type
name|AllOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|,
argument|M3 m3
argument_list|,
argument|M4 m4
argument_list|,
argument|M5 m5
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AllOfResult5
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|>
operator|::
name|type
argument_list|(
operator|::
name|testing
operator|::
name|AllOf
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|)
argument_list|,
operator|::
name|testing
operator|::
name|AllOf
argument_list|(
name|m3
argument_list|,
name|m4
argument_list|,
name|m5
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AllOfResult6
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|>
operator|::
name|type
name|AllOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|,
argument|M3 m3
argument_list|,
argument|M4 m4
argument_list|,
argument|M5 m5
argument_list|,
argument|M6 m6
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AllOfResult6
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|>
operator|::
name|type
argument_list|(
operator|::
name|testing
operator|::
name|AllOf
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|)
argument_list|,
operator|::
name|testing
operator|::
name|AllOf
argument_list|(
name|m4
argument_list|,
name|m5
argument_list|,
name|m6
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|,
name|typename
name|M7
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AllOfResult7
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|>
operator|::
name|type
name|AllOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|,
argument|M3 m3
argument_list|,
argument|M4 m4
argument_list|,
argument|M5 m5
argument_list|,
argument|M6 m6
argument_list|,
argument|M7 m7
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AllOfResult7
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|>
operator|::
name|type
argument_list|(
operator|::
name|testing
operator|::
name|AllOf
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|)
argument_list|,
operator|::
name|testing
operator|::
name|AllOf
argument_list|(
name|m4
argument_list|,
name|m5
argument_list|,
name|m6
argument_list|,
name|m7
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|,
name|typename
name|M7
operator|,
name|typename
name|M8
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AllOfResult8
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|,
name|M8
operator|>
operator|::
name|type
name|AllOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|,
argument|M3 m3
argument_list|,
argument|M4 m4
argument_list|,
argument|M5 m5
argument_list|,
argument|M6 m6
argument_list|,
argument|M7 m7
argument_list|,
argument|M8 m8
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AllOfResult8
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|,
name|M8
operator|>
operator|::
name|type
argument_list|(
operator|::
name|testing
operator|::
name|AllOf
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|,
name|m4
argument_list|)
argument_list|,
operator|::
name|testing
operator|::
name|AllOf
argument_list|(
name|m5
argument_list|,
name|m6
argument_list|,
name|m7
argument_list|,
name|m8
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|,
name|typename
name|M7
operator|,
name|typename
name|M8
operator|,
name|typename
name|M9
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AllOfResult9
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|,
name|M8
operator|,
name|M9
operator|>
operator|::
name|type
name|AllOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|,
argument|M3 m3
argument_list|,
argument|M4 m4
argument_list|,
argument|M5 m5
argument_list|,
argument|M6 m6
argument_list|,
argument|M7 m7
argument_list|,
argument|M8 m8
argument_list|,
argument|M9 m9
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AllOfResult9
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|,
name|M8
operator|,
name|M9
operator|>
operator|::
name|type
argument_list|(
operator|::
name|testing
operator|::
name|AllOf
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|,
name|m4
argument_list|)
argument_list|,
operator|::
name|testing
operator|::
name|AllOf
argument_list|(
name|m5
argument_list|,
name|m6
argument_list|,
name|m7
argument_list|,
name|m8
argument_list|,
name|m9
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|,
name|typename
name|M7
operator|,
name|typename
name|M8
operator|,
name|typename
name|M9
operator|,
name|typename
name|M10
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AllOfResult10
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|,
name|M8
operator|,
name|M9
operator|,
name|M10
operator|>
operator|::
name|type
name|AllOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|,
argument|M3 m3
argument_list|,
argument|M4 m4
argument_list|,
argument|M5 m5
argument_list|,
argument|M6 m6
argument_list|,
argument|M7 m7
argument_list|,
argument|M8 m8
argument_list|,
argument|M9 m9
argument_list|,
argument|M10 m10
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AllOfResult10
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|,
name|M8
operator|,
name|M9
operator|,
name|M10
operator|>
operator|::
name|type
argument_list|(
operator|::
name|testing
operator|::
name|AllOf
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|,
name|m4
argument_list|,
name|m5
argument_list|)
argument_list|,
operator|::
name|testing
operator|::
name|AllOf
argument_list|(
name|m6
argument_list|,
name|m7
argument_list|,
name|m8
argument_list|,
name|m9
argument_list|,
name|m10
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// AnyOf(m1, m2, ..., mk) matches any value that matches any of the given
end_comment

begin_comment
comment|// sub-matchers.  AnyOf is called fully qualified to prevent ADL from firing.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AnyOfResult2
operator|<
name|M1
operator|,
name|M2
operator|>
operator|::
name|type
name|AnyOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AnyOfResult2
operator|<
name|M1
operator|,
name|M2
operator|>
operator|::
name|type
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AnyOfResult3
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|>
operator|::
name|type
name|AnyOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|,
argument|M3 m3
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AnyOfResult3
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|>
operator|::
name|type
argument_list|(
name|m1
argument_list|,
operator|::
name|testing
operator|::
name|AnyOf
argument_list|(
name|m2
argument_list|,
name|m3
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AnyOfResult4
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|>
operator|::
name|type
name|AnyOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|,
argument|M3 m3
argument_list|,
argument|M4 m4
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AnyOfResult4
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|>
operator|::
name|type
argument_list|(
operator|::
name|testing
operator|::
name|AnyOf
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|)
argument_list|,
operator|::
name|testing
operator|::
name|AnyOf
argument_list|(
name|m3
argument_list|,
name|m4
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AnyOfResult5
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|>
operator|::
name|type
name|AnyOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|,
argument|M3 m3
argument_list|,
argument|M4 m4
argument_list|,
argument|M5 m5
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AnyOfResult5
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|>
operator|::
name|type
argument_list|(
operator|::
name|testing
operator|::
name|AnyOf
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|)
argument_list|,
operator|::
name|testing
operator|::
name|AnyOf
argument_list|(
name|m3
argument_list|,
name|m4
argument_list|,
name|m5
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AnyOfResult6
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|>
operator|::
name|type
name|AnyOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|,
argument|M3 m3
argument_list|,
argument|M4 m4
argument_list|,
argument|M5 m5
argument_list|,
argument|M6 m6
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AnyOfResult6
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|>
operator|::
name|type
argument_list|(
operator|::
name|testing
operator|::
name|AnyOf
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|)
argument_list|,
operator|::
name|testing
operator|::
name|AnyOf
argument_list|(
name|m4
argument_list|,
name|m5
argument_list|,
name|m6
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|,
name|typename
name|M7
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AnyOfResult7
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|>
operator|::
name|type
name|AnyOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|,
argument|M3 m3
argument_list|,
argument|M4 m4
argument_list|,
argument|M5 m5
argument_list|,
argument|M6 m6
argument_list|,
argument|M7 m7
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AnyOfResult7
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|>
operator|::
name|type
argument_list|(
operator|::
name|testing
operator|::
name|AnyOf
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|)
argument_list|,
operator|::
name|testing
operator|::
name|AnyOf
argument_list|(
name|m4
argument_list|,
name|m5
argument_list|,
name|m6
argument_list|,
name|m7
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|,
name|typename
name|M7
operator|,
name|typename
name|M8
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AnyOfResult8
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|,
name|M8
operator|>
operator|::
name|type
name|AnyOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|,
argument|M3 m3
argument_list|,
argument|M4 m4
argument_list|,
argument|M5 m5
argument_list|,
argument|M6 m6
argument_list|,
argument|M7 m7
argument_list|,
argument|M8 m8
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AnyOfResult8
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|,
name|M8
operator|>
operator|::
name|type
argument_list|(
operator|::
name|testing
operator|::
name|AnyOf
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|,
name|m4
argument_list|)
argument_list|,
operator|::
name|testing
operator|::
name|AnyOf
argument_list|(
name|m5
argument_list|,
name|m6
argument_list|,
name|m7
argument_list|,
name|m8
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|,
name|typename
name|M7
operator|,
name|typename
name|M8
operator|,
name|typename
name|M9
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AnyOfResult9
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|,
name|M8
operator|,
name|M9
operator|>
operator|::
name|type
name|AnyOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|,
argument|M3 m3
argument_list|,
argument|M4 m4
argument_list|,
argument|M5 m5
argument_list|,
argument|M6 m6
argument_list|,
argument|M7 m7
argument_list|,
argument|M8 m8
argument_list|,
argument|M9 m9
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AnyOfResult9
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|,
name|M8
operator|,
name|M9
operator|>
operator|::
name|type
argument_list|(
operator|::
name|testing
operator|::
name|AnyOf
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|,
name|m4
argument_list|)
argument_list|,
operator|::
name|testing
operator|::
name|AnyOf
argument_list|(
name|m5
argument_list|,
name|m6
argument_list|,
name|m7
argument_list|,
name|m8
argument_list|,
name|m9
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|M1
operator|,
name|typename
name|M2
operator|,
name|typename
name|M3
operator|,
name|typename
name|M4
operator|,
name|typename
name|M5
operator|,
name|typename
name|M6
operator|,
name|typename
name|M7
operator|,
name|typename
name|M8
operator|,
name|typename
name|M9
operator|,
name|typename
name|M10
operator|>
specifier|inline
name|typename
name|internal
operator|::
name|AnyOfResult10
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|,
name|M8
operator|,
name|M9
operator|,
name|M10
operator|>
operator|::
name|type
name|AnyOf
argument_list|(
argument|M1 m1
argument_list|,
argument|M2 m2
argument_list|,
argument|M3 m3
argument_list|,
argument|M4 m4
argument_list|,
argument|M5 m5
argument_list|,
argument|M6 m6
argument_list|,
argument|M7 m7
argument_list|,
argument|M8 m8
argument_list|,
argument|M9 m9
argument_list|,
argument|M10 m10
argument_list|)
block|{
return|return
name|typename
name|internal
operator|::
name|AnyOfResult10
operator|<
name|M1
operator|,
name|M2
operator|,
name|M3
operator|,
name|M4
operator|,
name|M5
operator|,
name|M6
operator|,
name|M7
operator|,
name|M8
operator|,
name|M9
operator|,
name|M10
operator|>
operator|::
name|type
argument_list|(
operator|::
name|testing
operator|::
name|AnyOf
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|,
name|m4
argument_list|,
name|m5
argument_list|)
argument_list|,
operator|::
name|testing
operator|::
name|AnyOf
argument_list|(
name|m6
argument_list|,
name|m7
argument_list|,
name|m8
argument_list|,
name|m9
argument_list|,
name|m10
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// namespace testing
end_comment

begin_comment
comment|// The MATCHER* family of macros can be used in a namespace scope to
end_comment

begin_comment
comment|// define custom matchers easily.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Basic Usage
end_comment

begin_comment
comment|// ===========
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The syntax
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   MATCHER(name, description_string) { statements; }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// defines a matcher with the given name that executes the statements,
end_comment

begin_comment
comment|// which must return a bool to indicate if the match succeeds.  Inside
end_comment

begin_comment
comment|// the statements, you can refer to the value being matched by 'arg',
end_comment

begin_comment
comment|// and refer to its type by 'arg_type'.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The description string documents what the matcher does, and is used
end_comment

begin_comment
comment|// to generate the failure message when the match fails.  Since a
end_comment

begin_comment
comment|// MATCHER() is usually defined in a header file shared by multiple
end_comment

begin_comment
comment|// C++ source files, we require the description to be a C-string
end_comment

begin_comment
comment|// literal to avoid possible side effects.  It can be empty, in which
end_comment

begin_comment
comment|// case we'll use the sequence of words in the matcher name as the
end_comment

begin_comment
comment|// description.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// For example:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   MATCHER(IsEven, "") { return (arg % 2) == 0; }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// allows you to write
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   // Expects mock_foo.Bar(n) to be called where n is even.
end_comment

begin_comment
comment|//   EXPECT_CALL(mock_foo, Bar(IsEven()));
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// or,
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   // Verifies that the value of some_expression is even.
end_comment

begin_comment
comment|//   EXPECT_THAT(some_expression, IsEven());
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// If the above assertion fails, it will print something like:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   Value of: some_expression
end_comment

begin_comment
comment|//   Expected: is even
end_comment

begin_comment
comment|//     Actual: 7
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// where the description "is even" is automatically calculated from the
end_comment

begin_comment
comment|// matcher name IsEven.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Argument Type
end_comment

begin_comment
comment|// =============
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Note that the type of the value being matched (arg_type) is
end_comment

begin_comment
comment|// determined by the context in which you use the matcher and is
end_comment

begin_comment
comment|// supplied to you by the compiler, so you don't need to worry about
end_comment

begin_comment
comment|// declaring it (nor can you).  This allows the matcher to be
end_comment

begin_comment
comment|// polymorphic.  For example, IsEven() can be used to match any type
end_comment

begin_comment
comment|// where the value of "(arg % 2) == 0" can be implicitly converted to
end_comment

begin_comment
comment|// a bool.  In the "Bar(IsEven())" example above, if method Bar()
end_comment

begin_comment
comment|// takes an int, 'arg_type' will be int; if it takes an unsigned long,
end_comment

begin_comment
comment|// 'arg_type' will be unsigned long; and so on.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Parameterizing Matchers
end_comment

begin_comment
comment|// =======================
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Sometimes you'll want to parameterize the matcher.  For that you
end_comment

begin_comment
comment|// can use another macro:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   MATCHER_P(name, param_name, description_string) { statements; }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// For example:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   MATCHER_P(HasAbsoluteValue, value, "") { return abs(arg) == value; }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// will allow you to write:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   EXPECT_THAT(Blah("a"), HasAbsoluteValue(n));
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// which may lead to this message (assuming n is 10):
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   Value of: Blah("a")
end_comment

begin_comment
comment|//   Expected: has absolute value 10
end_comment

begin_comment
comment|//     Actual: -9
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Note that both the matcher description and its parameter are
end_comment

begin_comment
comment|// printed, making the message human-friendly.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// In the matcher definition body, you can write 'foo_type' to
end_comment

begin_comment
comment|// reference the type of a parameter named 'foo'.  For example, in the
end_comment

begin_comment
comment|// body of MATCHER_P(HasAbsoluteValue, value) above, you can write
end_comment

begin_comment
comment|// 'value_type' to refer to the type of 'value'.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// We also provide MATCHER_P2, MATCHER_P3, ..., up to MATCHER_P10 to
end_comment

begin_comment
comment|// support multi-parameter matchers.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Describing Parameterized Matchers
end_comment

begin_comment
comment|// =================================
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The last argument to MATCHER*() is a string-typed expression.  The
end_comment

begin_comment
comment|// expression can reference all of the matcher's parameters and a
end_comment

begin_comment
comment|// special bool-typed variable named 'negation'.  When 'negation' is
end_comment

begin_comment
comment|// false, the expression should evaluate to the matcher's description;
end_comment

begin_comment
comment|// otherwise it should evaluate to the description of the negation of
end_comment

begin_comment
comment|// the matcher.  For example,
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   using testing::PrintToString;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   MATCHER_P2(InClosedRange, low, hi,
end_comment

begin_comment
comment|//       string(negation ? "is not" : "is") + " in range [" +
end_comment

begin_comment
comment|//       PrintToString(low) + ", " + PrintToString(hi) + "]") {
end_comment

begin_comment
comment|//     return low<= arg&& arg<= hi;
end_comment

begin_comment
comment|//   }
end_comment

begin_comment
comment|//   ...
end_comment

begin_comment
comment|//   EXPECT_THAT(3, InClosedRange(4, 6));
end_comment

begin_comment
comment|//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// would generate two failures that contain the text:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   Expected: is in range [4, 6]
end_comment

begin_comment
comment|//   ...
end_comment

begin_comment
comment|//   Expected: is not in range [2, 4]
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// If you specify "" as the description, the failure message will
end_comment

begin_comment
comment|// contain the sequence of words in the matcher name followed by the
end_comment

begin_comment
comment|// parameter values printed as a tuple.  For example,
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   MATCHER_P2(InClosedRange, low, hi, "") { ... }
end_comment

begin_comment
comment|//   ...
end_comment

begin_comment
comment|//   EXPECT_THAT(3, InClosedRange(4, 6));
end_comment

begin_comment
comment|//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// would generate two failures that contain the text:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   Expected: in closed range (4, 6)
end_comment

begin_comment
comment|//   ...
end_comment

begin_comment
comment|//   Expected: not (in closed range (2, 4))
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Types of Matcher Parameters
end_comment

begin_comment
comment|// ===========================
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// For the purpose of typing, you can view
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   MATCHER_Pk(Foo, p1, ..., pk, description_string) { ... }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// as shorthand for
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   template<typename p1_type, ..., typename pk_type>
end_comment

begin_comment
comment|//   FooMatcherPk<p1_type, ..., pk_type>
end_comment

begin_comment
comment|//   Foo(p1_type p1, ..., pk_type pk) { ... }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// When you write Foo(v1, ..., vk), the compiler infers the types of
end_comment

begin_comment
comment|// the parameters v1, ..., and vk for you.  If you are not happy with
end_comment

begin_comment
comment|// the result of the type inference, you can specify the types by
end_comment

begin_comment
comment|// explicitly instantiating the template, as in Foo<long, bool>(5,
end_comment

begin_comment
comment|// false).  As said earlier, you don't get to (or need to) specify
end_comment

begin_comment
comment|// 'arg_type' as that's determined by the context in which the matcher
end_comment

begin_comment
comment|// is used.  You can assign the result of expression Foo(p1, ..., pk)
end_comment

begin_comment
comment|// to a variable of type FooMatcherPk<p1_type, ..., pk_type>.  This
end_comment

begin_comment
comment|// can be useful when composing matchers.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// While you can instantiate a matcher template with reference types,
end_comment

begin_comment
comment|// passing the parameters by pointer usually makes your code more
end_comment

begin_comment
comment|// readable.  If, however, you still want to pass a parameter by
end_comment

begin_comment
comment|// reference, be aware that in the failure message generated by the
end_comment

begin_comment
comment|// matcher you will see the value of the referenced object but not its
end_comment

begin_comment
comment|// address.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Explaining Match Results
end_comment

begin_comment
comment|// ========================
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Sometimes the matcher description alone isn't enough to explain why
end_comment

begin_comment
comment|// the match has failed or succeeded.  For example, when expecting a
end_comment

begin_comment
comment|// long string, it can be very helpful to also print the diff between
end_comment

begin_comment
comment|// the expected string and the actual one.  To achieve that, you can
end_comment

begin_comment
comment|// optionally stream additional information to a special variable
end_comment

begin_comment
comment|// named result_listener, whose type is a pointer to class
end_comment

begin_comment
comment|// MatchResultListener:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   MATCHER_P(EqualsLongString, str, "") {
end_comment

begin_comment
comment|//     if (arg == str) return true;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     *result_listener<< "the difference: "
end_comment

begin_comment
comment|///<< DiffStrings(str, arg);
end_comment

begin_comment
comment|//     return false;
end_comment

begin_comment
comment|//   }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Overloading Matchers
end_comment

begin_comment
comment|// ====================
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// You can overload matchers with different numbers of parameters:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   MATCHER_P(Blah, a, description_string1) { ... }
end_comment

begin_comment
comment|//   MATCHER_P2(Blah, a, b, description_string2) { ... }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Caveats
end_comment

begin_comment
comment|// =======
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// When defining a new matcher, you should also consider implementing
end_comment

begin_comment
comment|// MatcherInterface or using MakePolymorphicMatcher().  These
end_comment

begin_comment
comment|// approaches require more work than the MATCHER* macros, but also
end_comment

begin_comment
comment|// give you more control on the types of the value being matched and
end_comment

begin_comment
comment|// the matcher parameters, which may leads to better compiler error
end_comment

begin_comment
comment|// messages when the matcher is used wrong.  They also allow
end_comment

begin_comment
comment|// overloading matchers based on parameter types (as opposed to just
end_comment

begin_comment
comment|// based on the number of parameters).
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// MATCHER*() can only be used in a namespace scope.  The reason is
end_comment

begin_comment
comment|// that C++ doesn't yet allow function-local types to be used to
end_comment

begin_comment
comment|// instantiate templates.  The up-coming C++0x standard will fix this.
end_comment

begin_comment
comment|// Once that's done, we'll consider supporting using MATCHER*() inside
end_comment

begin_comment
comment|// a function.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// More Information
end_comment

begin_comment
comment|// ================
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// To learn more about using these macros, please search for 'MATCHER'
end_comment

begin_comment
comment|// on http://code.google.com/p/googlemock/wiki/CookBook.
end_comment

begin_define
define|#
directive|define
name|MATCHER
parameter_list|(
name|name
parameter_list|,
name|description
parameter_list|)
define|\
value|class name##Matcher {\    public:\     template<typename arg_type>\     class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\      public:\       gmock_Impl()\            {}\       virtual bool MatchAndExplain(\           arg_type arg, ::testing::MatchResultListener* result_listener) const;\       virtual void DescribeTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(false);\       }\       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(true);\       }\      private:\       ::testing::internal::string FormatDescription(bool negation) const {\         const ::testing::internal::string gmock_description = (description);\         if (!gmock_description.empty())\           return gmock_description;\         return ::testing::internal::FormatMatcherDescription(\             negation, #name, \             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\                 ::testing::tuple<>()));\       }\       GTEST_DISALLOW_ASSIGN_(gmock_Impl);\     };\     template<typename arg_type>\     operator ::testing::Matcher<arg_type>() const {\       return ::testing::Matcher<arg_type>(\           new gmock_Impl<arg_type>());\     }\     name##Matcher() {\     }\    private:\     GTEST_DISALLOW_ASSIGN_(name##Matcher);\   };\   inline name##Matcher name() {\     return name##Matcher();\   }\   template<typename arg_type>\   bool name##Matcher::gmock_Impl<arg_type>::MatchAndExplain(\       arg_type arg, \       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\           const
end_define

begin_define
define|#
directive|define
name|MATCHER_P
parameter_list|(
name|name
parameter_list|,
name|p0
parameter_list|,
name|description
parameter_list|)
define|\
value|template<typename p0##_type>\   class name##MatcherP {\    public:\     template<typename arg_type>\     class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\      public:\       explicit gmock_Impl(p0##_type gmock_p0)\            : p0(gmock_p0) {}\       virtual bool MatchAndExplain(\           arg_type arg, ::testing::MatchResultListener* result_listener) const;\       virtual void DescribeTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(false);\       }\       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(true);\       }\       p0##_type p0;\      private:\       ::testing::internal::string FormatDescription(bool negation) const {\         const ::testing::internal::string gmock_description = (description);\         if (!gmock_description.empty())\           return gmock_description;\         return ::testing::internal::FormatMatcherDescription(\             negation, #name, \             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\                 ::testing::tuple<p0##_type>(p0)));\       }\       GTEST_DISALLOW_ASSIGN_(gmock_Impl);\     };\     template<typename arg_type>\     operator ::testing::Matcher<arg_type>() const {\       return ::testing::Matcher<arg_type>(\           new gmock_Impl<arg_type>(p0));\     }\     explicit name##MatcherP(p0##_type gmock_p0) : p0(gmock_p0) {\     }\     p0##_type p0;\    private:\     GTEST_DISALLOW_ASSIGN_(name##MatcherP);\   };\   template<typename p0##_type>\   inline name##MatcherP<p0##_type> name(p0##_type p0) {\     return name##MatcherP<p0##_type>(p0);\   }\   template<typename p0##_type>\   template<typename arg_type>\   bool name##MatcherP<p0##_type>::gmock_Impl<arg_type>::MatchAndExplain(\       arg_type arg, \       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\           const
end_define

begin_define
define|#
directive|define
name|MATCHER_P2
parameter_list|(
name|name
parameter_list|,
name|p0
parameter_list|,
name|p1
parameter_list|,
name|description
parameter_list|)
define|\
value|template<typename p0##_type, typename p1##_type>\   class name##MatcherP2 {\    public:\     template<typename arg_type>\     class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\      public:\       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1)\            : p0(gmock_p0), p1(gmock_p1) {}\       virtual bool MatchAndExplain(\           arg_type arg, ::testing::MatchResultListener* result_listener) const;\       virtual void DescribeTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(false);\       }\       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(true);\       }\       p0##_type p0;\       p1##_type p1;\      private:\       ::testing::internal::string FormatDescription(bool negation) const {\         const ::testing::internal::string gmock_description = (description);\         if (!gmock_description.empty())\           return gmock_description;\         return ::testing::internal::FormatMatcherDescription(\             negation, #name, \             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\                 ::testing::tuple<p0##_type, p1##_type>(p0, p1)));\       }\       GTEST_DISALLOW_ASSIGN_(gmock_Impl);\     };\     template<typename arg_type>\     operator ::testing::Matcher<arg_type>() const {\       return ::testing::Matcher<arg_type>(\           new gmock_Impl<arg_type>(p0, p1));\     }\     name##MatcherP2(p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), \         p1(gmock_p1) {\     }\     p0##_type p0;\     p1##_type p1;\    private:\     GTEST_DISALLOW_ASSIGN_(name##MatcherP2);\   };\   template<typename p0##_type, typename p1##_type>\   inline name##MatcherP2<p0##_type, p1##_type> name(p0##_type p0, \       p1##_type p1) {\     return name##MatcherP2<p0##_type, p1##_type>(p0, p1);\   }\   template<typename p0##_type, typename p1##_type>\   template<typename arg_type>\   bool name##MatcherP2<p0##_type, \       p1##_type>::gmock_Impl<arg_type>::MatchAndExplain(\       arg_type arg, \       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\           const
end_define

begin_define
define|#
directive|define
name|MATCHER_P3
parameter_list|(
name|name
parameter_list|,
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|description
parameter_list|)
define|\
value|template<typename p0##_type, typename p1##_type, typename p2##_type>\   class name##MatcherP3 {\    public:\     template<typename arg_type>\     class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\      public:\       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2)\            : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {}\       virtual bool MatchAndExplain(\           arg_type arg, ::testing::MatchResultListener* result_listener) const;\       virtual void DescribeTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(false);\       }\       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(true);\       }\       p0##_type p0;\       p1##_type p1;\       p2##_type p2;\      private:\       ::testing::internal::string FormatDescription(bool negation) const {\         const ::testing::internal::string gmock_description = (description);\         if (!gmock_description.empty())\           return gmock_description;\         return ::testing::internal::FormatMatcherDescription(\             negation, #name, \             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\                 ::testing::tuple<p0##_type, p1##_type, p2##_type>(p0, p1, \                     p2)));\       }\       GTEST_DISALLOW_ASSIGN_(gmock_Impl);\     };\     template<typename arg_type>\     operator ::testing::Matcher<arg_type>() const {\       return ::testing::Matcher<arg_type>(\           new gmock_Impl<arg_type>(p0, p1, p2));\     }\     name##MatcherP3(p0##_type gmock_p0, p1##_type gmock_p1, \         p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {\     }\     p0##_type p0;\     p1##_type p1;\     p2##_type p2;\    private:\     GTEST_DISALLOW_ASSIGN_(name##MatcherP3);\   };\   template<typename p0##_type, typename p1##_type, typename p2##_type>\   inline name##MatcherP3<p0##_type, p1##_type, p2##_type> name(p0##_type p0, \       p1##_type p1, p2##_type p2) {\     return name##MatcherP3<p0##_type, p1##_type, p2##_type>(p0, p1, p2);\   }\   template<typename p0##_type, typename p1##_type, typename p2##_type>\   template<typename arg_type>\   bool name##MatcherP3<p0##_type, p1##_type, \       p2##_type>::gmock_Impl<arg_type>::MatchAndExplain(\       arg_type arg, \       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\           const
end_define

begin_define
define|#
directive|define
name|MATCHER_P4
parameter_list|(
name|name
parameter_list|,
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|description
parameter_list|)
define|\
value|template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type>\   class name##MatcherP4 {\    public:\     template<typename arg_type>\     class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\      public:\       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \           p3##_type gmock_p3)\            : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3) {}\       virtual bool MatchAndExplain(\           arg_type arg, ::testing::MatchResultListener* result_listener) const;\       virtual void DescribeTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(false);\       }\       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(true);\       }\       p0##_type p0;\       p1##_type p1;\       p2##_type p2;\       p3##_type p3;\      private:\       ::testing::internal::string FormatDescription(bool negation) const {\         const ::testing::internal::string gmock_description = (description);\         if (!gmock_description.empty())\           return gmock_description;\         return ::testing::internal::FormatMatcherDescription(\             negation, #name, \             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\                 ::testing::tuple<p0##_type, p1##_type, p2##_type, \                     p3##_type>(p0, p1, p2, p3)));\       }\       GTEST_DISALLOW_ASSIGN_(gmock_Impl);\     };\     template<typename arg_type>\     operator ::testing::Matcher<arg_type>() const {\       return ::testing::Matcher<arg_type>(\           new gmock_Impl<arg_type>(p0, p1, p2, p3));\     }\     name##MatcherP4(p0##_type gmock_p0, p1##_type gmock_p1, \         p2##_type gmock_p2, p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), \         p2(gmock_p2), p3(gmock_p3) {\     }\     p0##_type p0;\     p1##_type p1;\     p2##_type p2;\     p3##_type p3;\    private:\     GTEST_DISALLOW_ASSIGN_(name##MatcherP4);\   };\   template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type>\   inline name##MatcherP4<p0##_type, p1##_type, p2##_type, \       p3##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \       p3##_type p3) {\     return name##MatcherP4<p0##_type, p1##_type, p2##_type, p3##_type>(p0, \         p1, p2, p3);\   }\   template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type>\   template<typename arg_type>\   bool name##MatcherP4<p0##_type, p1##_type, p2##_type, \       p3##_type>::gmock_Impl<arg_type>::MatchAndExplain(\       arg_type arg, \       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\           const
end_define

begin_define
define|#
directive|define
name|MATCHER_P5
parameter_list|(
name|name
parameter_list|,
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|p4
parameter_list|,
name|description
parameter_list|)
define|\
value|template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type>\   class name##MatcherP5 {\    public:\     template<typename arg_type>\     class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\      public:\       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \           p3##_type gmock_p3, p4##_type gmock_p4)\            : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \                p4(gmock_p4) {}\       virtual bool MatchAndExplain(\           arg_type arg, ::testing::MatchResultListener* result_listener) const;\       virtual void DescribeTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(false);\       }\       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(true);\       }\       p0##_type p0;\       p1##_type p1;\       p2##_type p2;\       p3##_type p3;\       p4##_type p4;\      private:\       ::testing::internal::string FormatDescription(bool negation) const {\         const ::testing::internal::string gmock_description = (description);\         if (!gmock_description.empty())\           return gmock_description;\         return ::testing::internal::FormatMatcherDescription(\             negation, #name, \             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\                 ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \                     p4##_type>(p0, p1, p2, p3, p4)));\       }\       GTEST_DISALLOW_ASSIGN_(gmock_Impl);\     };\     template<typename arg_type>\     operator ::testing::Matcher<arg_type>() const {\       return ::testing::Matcher<arg_type>(\           new gmock_Impl<arg_type>(p0, p1, p2, p3, p4));\     }\     name##MatcherP5(p0##_type gmock_p0, p1##_type gmock_p1, \         p2##_type gmock_p2, p3##_type gmock_p3, \         p4##_type gmock_p4) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \         p3(gmock_p3), p4(gmock_p4) {\     }\     p0##_type p0;\     p1##_type p1;\     p2##_type p2;\     p3##_type p3;\     p4##_type p4;\    private:\     GTEST_DISALLOW_ASSIGN_(name##MatcherP5);\   };\   template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type>\   inline name##MatcherP5<p0##_type, p1##_type, p2##_type, p3##_type, \       p4##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \       p4##_type p4) {\     return name##MatcherP5<p0##_type, p1##_type, p2##_type, p3##_type, \         p4##_type>(p0, p1, p2, p3, p4);\   }\   template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type>\   template<typename arg_type>\   bool name##MatcherP5<p0##_type, p1##_type, p2##_type, p3##_type, \       p4##_type>::gmock_Impl<arg_type>::MatchAndExplain(\       arg_type arg, \       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\           const
end_define

begin_define
define|#
directive|define
name|MATCHER_P6
parameter_list|(
name|name
parameter_list|,
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|p4
parameter_list|,
name|p5
parameter_list|,
name|description
parameter_list|)
define|\
value|template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type, typename p5##_type>\   class name##MatcherP6 {\    public:\     template<typename arg_type>\     class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\      public:\       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \           p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5)\            : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \                p4(gmock_p4), p5(gmock_p5) {}\       virtual bool MatchAndExplain(\           arg_type arg, ::testing::MatchResultListener* result_listener) const;\       virtual void DescribeTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(false);\       }\       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(true);\       }\       p0##_type p0;\       p1##_type p1;\       p2##_type p2;\       p3##_type p3;\       p4##_type p4;\       p5##_type p5;\      private:\       ::testing::internal::string FormatDescription(bool negation) const {\         const ::testing::internal::string gmock_description = (description);\         if (!gmock_description.empty())\           return gmock_description;\         return ::testing::internal::FormatMatcherDescription(\             negation, #name, \             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\                 ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \                     p4##_type, p5##_type>(p0, p1, p2, p3, p4, p5)));\       }\       GTEST_DISALLOW_ASSIGN_(gmock_Impl);\     };\     template<typename arg_type>\     operator ::testing::Matcher<arg_type>() const {\       return ::testing::Matcher<arg_type>(\           new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5));\     }\     name##MatcherP6(p0##_type gmock_p0, p1##_type gmock_p1, \         p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \         p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \         p3(gmock_p3), p4(gmock_p4), p5(gmock_p5) {\     }\     p0##_type p0;\     p1##_type p1;\     p2##_type p2;\     p3##_type p3;\     p4##_type p4;\     p5##_type p5;\    private:\     GTEST_DISALLOW_ASSIGN_(name##MatcherP6);\   };\   template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type, typename p5##_type>\   inline name##MatcherP6<p0##_type, p1##_type, p2##_type, p3##_type, \       p4##_type, p5##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \       p3##_type p3, p4##_type p4, p5##_type p5) {\     return name##MatcherP6<p0##_type, p1##_type, p2##_type, p3##_type, \         p4##_type, p5##_type>(p0, p1, p2, p3, p4, p5);\   }\   template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type, typename p5##_type>\   template<typename arg_type>\   bool name##MatcherP6<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \       p5##_type>::gmock_Impl<arg_type>::MatchAndExplain(\       arg_type arg, \       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\           const
end_define

begin_define
define|#
directive|define
name|MATCHER_P7
parameter_list|(
name|name
parameter_list|,
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|p4
parameter_list|,
name|p5
parameter_list|,
name|p6
parameter_list|,
name|description
parameter_list|)
define|\
value|template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type, typename p5##_type, \       typename p6##_type>\   class name##MatcherP7 {\    public:\     template<typename arg_type>\     class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\      public:\       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \           p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \           p6##_type gmock_p6)\            : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \                p4(gmock_p4), p5(gmock_p5), p6(gmock_p6) {}\       virtual bool MatchAndExplain(\           arg_type arg, ::testing::MatchResultListener* result_listener) const;\       virtual void DescribeTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(false);\       }\       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(true);\       }\       p0##_type p0;\       p1##_type p1;\       p2##_type p2;\       p3##_type p3;\       p4##_type p4;\       p5##_type p5;\       p6##_type p6;\      private:\       ::testing::internal::string FormatDescription(bool negation) const {\         const ::testing::internal::string gmock_description = (description);\         if (!gmock_description.empty())\           return gmock_description;\         return ::testing::internal::FormatMatcherDescription(\             negation, #name, \             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\                 ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \                     p4##_type, p5##_type, p6##_type>(p0, p1, p2, p3, p4, p5, \                     p6)));\       }\       GTEST_DISALLOW_ASSIGN_(gmock_Impl);\     };\     template<typename arg_type>\     operator ::testing::Matcher<arg_type>() const {\       return ::testing::Matcher<arg_type>(\           new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6));\     }\     name##MatcherP7(p0##_type gmock_p0, p1##_type gmock_p1, \         p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \         p5##_type gmock_p5, p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), \         p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), \         p6(gmock_p6) {\     }\     p0##_type p0;\     p1##_type p1;\     p2##_type p2;\     p3##_type p3;\     p4##_type p4;\     p5##_type p5;\     p6##_type p6;\    private:\     GTEST_DISALLOW_ASSIGN_(name##MatcherP7);\   };\   template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type, typename p5##_type, \       typename p6##_type>\   inline name##MatcherP7<p0##_type, p1##_type, p2##_type, p3##_type, \       p4##_type, p5##_type, p6##_type> name(p0##_type p0, p1##_type p1, \       p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \       p6##_type p6) {\     return name##MatcherP7<p0##_type, p1##_type, p2##_type, p3##_type, \         p4##_type, p5##_type, p6##_type>(p0, p1, p2, p3, p4, p5, p6);\   }\   template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type, typename p5##_type, \       typename p6##_type>\   template<typename arg_type>\   bool name##MatcherP7<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \       p5##_type, p6##_type>::gmock_Impl<arg_type>::MatchAndExplain(\       arg_type arg, \       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\           const
end_define

begin_define
define|#
directive|define
name|MATCHER_P8
parameter_list|(
name|name
parameter_list|,
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|p4
parameter_list|,
name|p5
parameter_list|,
name|p6
parameter_list|,
name|p7
parameter_list|,
name|description
parameter_list|)
define|\
value|template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type, typename p5##_type, \       typename p6##_type, typename p7##_type>\   class name##MatcherP8 {\    public:\     template<typename arg_type>\     class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\      public:\       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \           p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \           p6##_type gmock_p6, p7##_type gmock_p7)\            : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \                p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7) {}\       virtual bool MatchAndExplain(\           arg_type arg, ::testing::MatchResultListener* result_listener) const;\       virtual void DescribeTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(false);\       }\       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(true);\       }\       p0##_type p0;\       p1##_type p1;\       p2##_type p2;\       p3##_type p3;\       p4##_type p4;\       p5##_type p5;\       p6##_type p6;\       p7##_type p7;\      private:\       ::testing::internal::string FormatDescription(bool negation) const {\         const ::testing::internal::string gmock_description = (description);\         if (!gmock_description.empty())\           return gmock_description;\         return ::testing::internal::FormatMatcherDescription(\             negation, #name, \             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\                 ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \                     p4##_type, p5##_type, p6##_type, p7##_type>(p0, p1, p2, \                     p3, p4, p5, p6, p7)));\       }\       GTEST_DISALLOW_ASSIGN_(gmock_Impl);\     };\     template<typename arg_type>\     operator ::testing::Matcher<arg_type>() const {\       return ::testing::Matcher<arg_type>(\           new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6, p7));\     }\     name##MatcherP8(p0##_type gmock_p0, p1##_type gmock_p1, \         p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \         p5##_type gmock_p5, p6##_type gmock_p6, \         p7##_type gmock_p7) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \         p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \         p7(gmock_p7) {\     }\     p0##_type p0;\     p1##_type p1;\     p2##_type p2;\     p3##_type p3;\     p4##_type p4;\     p5##_type p5;\     p6##_type p6;\     p7##_type p7;\    private:\     GTEST_DISALLOW_ASSIGN_(name##MatcherP8);\   };\   template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type, typename p5##_type, \       typename p6##_type, typename p7##_type>\   inline name##MatcherP8<p0##_type, p1##_type, p2##_type, p3##_type, \       p4##_type, p5##_type, p6##_type, p7##_type> name(p0##_type p0, \       p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \       p6##_type p6, p7##_type p7) {\     return name##MatcherP8<p0##_type, p1##_type, p2##_type, p3##_type, \         p4##_type, p5##_type, p6##_type, p7##_type>(p0, p1, p2, p3, p4, p5, \         p6, p7);\   }\   template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type, typename p5##_type, \       typename p6##_type, typename p7##_type>\   template<typename arg_type>\   bool name##MatcherP8<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \       p5##_type, p6##_type, \       p7##_type>::gmock_Impl<arg_type>::MatchAndExplain(\       arg_type arg, \       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\           const
end_define

begin_define
define|#
directive|define
name|MATCHER_P9
parameter_list|(
name|name
parameter_list|,
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|p4
parameter_list|,
name|p5
parameter_list|,
name|p6
parameter_list|,
name|p7
parameter_list|,
name|p8
parameter_list|,
name|description
parameter_list|)
define|\
value|template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type, typename p5##_type, \       typename p6##_type, typename p7##_type, typename p8##_type>\   class name##MatcherP9 {\    public:\     template<typename arg_type>\     class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\      public:\       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \           p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \           p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8)\            : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \                p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \                p8(gmock_p8) {}\       virtual bool MatchAndExplain(\           arg_type arg, ::testing::MatchResultListener* result_listener) const;\       virtual void DescribeTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(false);\       }\       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(true);\       }\       p0##_type p0;\       p1##_type p1;\       p2##_type p2;\       p3##_type p3;\       p4##_type p4;\       p5##_type p5;\       p6##_type p6;\       p7##_type p7;\       p8##_type p8;\      private:\       ::testing::internal::string FormatDescription(bool negation) const {\         const ::testing::internal::string gmock_description = (description);\         if (!gmock_description.empty())\           return gmock_description;\         return ::testing::internal::FormatMatcherDescription(\             negation, #name, \             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\                 ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \                     p4##_type, p5##_type, p6##_type, p7##_type, \                     p8##_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8)));\       }\       GTEST_DISALLOW_ASSIGN_(gmock_Impl);\     };\     template<typename arg_type>\     operator ::testing::Matcher<arg_type>() const {\       return ::testing::Matcher<arg_type>(\           new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8));\     }\     name##MatcherP9(p0##_type gmock_p0, p1##_type gmock_p1, \         p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \         p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \         p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \         p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \         p8(gmock_p8) {\     }\     p0##_type p0;\     p1##_type p1;\     p2##_type p2;\     p3##_type p3;\     p4##_type p4;\     p5##_type p5;\     p6##_type p6;\     p7##_type p7;\     p8##_type p8;\    private:\     GTEST_DISALLOW_ASSIGN_(name##MatcherP9);\   };\   template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type, typename p5##_type, \       typename p6##_type, typename p7##_type, typename p8##_type>\   inline name##MatcherP9<p0##_type, p1##_type, p2##_type, p3##_type, \       p4##_type, p5##_type, p6##_type, p7##_type, \       p8##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \       p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, \       p8##_type p8) {\     return name##MatcherP9<p0##_type, p1##_type, p2##_type, p3##_type, \         p4##_type, p5##_type, p6##_type, p7##_type, p8##_type>(p0, p1, p2, \         p3, p4, p5, p6, p7, p8);\   }\   template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type, typename p5##_type, \       typename p6##_type, typename p7##_type, typename p8##_type>\   template<typename arg_type>\   bool name##MatcherP9<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \       p5##_type, p6##_type, p7##_type, \       p8##_type>::gmock_Impl<arg_type>::MatchAndExplain(\       arg_type arg, \       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\           const
end_define

begin_define
define|#
directive|define
name|MATCHER_P10
parameter_list|(
name|name
parameter_list|,
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|p4
parameter_list|,
name|p5
parameter_list|,
name|p6
parameter_list|,
name|p7
parameter_list|,
name|p8
parameter_list|,
name|p9
parameter_list|,
name|description
parameter_list|)
define|\
value|template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type, typename p5##_type, \       typename p6##_type, typename p7##_type, typename p8##_type, \       typename p9##_type>\   class name##MatcherP10 {\    public:\     template<typename arg_type>\     class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\      public:\       gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \           p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \           p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, \           p9##_type gmock_p9)\            : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \                p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \                p8(gmock_p8), p9(gmock_p9) {}\       virtual bool MatchAndExplain(\           arg_type arg, ::testing::MatchResultListener* result_listener) const;\       virtual void DescribeTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(false);\       }\       virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\         *gmock_os<< FormatDescription(true);\       }\       p0##_type p0;\       p1##_type p1;\       p2##_type p2;\       p3##_type p3;\       p4##_type p4;\       p5##_type p5;\       p6##_type p6;\       p7##_type p7;\       p8##_type p8;\       p9##_type p9;\      private:\       ::testing::internal::string FormatDescription(bool negation) const {\         const ::testing::internal::string gmock_description = (description);\         if (!gmock_description.empty())\           return gmock_description;\         return ::testing::internal::FormatMatcherDescription(\             negation, #name, \             ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\                 ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \                     p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \                     p9##_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)));\       }\       GTEST_DISALLOW_ASSIGN_(gmock_Impl);\     };\     template<typename arg_type>\     operator ::testing::Matcher<arg_type>() const {\       return ::testing::Matcher<arg_type>(\           new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9));\     }\     name##MatcherP10(p0##_type gmock_p0, p1##_type gmock_p1, \         p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \         p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \         p8##_type gmock_p8, p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), \         p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \         p7(gmock_p7), p8(gmock_p8), p9(gmock_p9) {\     }\     p0##_type p0;\     p1##_type p1;\     p2##_type p2;\     p3##_type p3;\     p4##_type p4;\     p5##_type p5;\     p6##_type p6;\     p7##_type p7;\     p8##_type p8;\     p9##_type p9;\    private:\     GTEST_DISALLOW_ASSIGN_(name##MatcherP10);\   };\   template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type, typename p5##_type, \       typename p6##_type, typename p7##_type, typename p8##_type, \       typename p9##_type>\   inline name##MatcherP10<p0##_type, p1##_type, p2##_type, p3##_type, \       p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \       p9##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \       p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8, \       p9##_type p9) {\     return name##MatcherP10<p0##_type, p1##_type, p2##_type, p3##_type, \         p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, p9##_type>(p0, \         p1, p2, p3, p4, p5, p6, p7, p8, p9);\   }\   template<typename p0##_type, typename p1##_type, typename p2##_type, \       typename p3##_type, typename p4##_type, typename p5##_type, \       typename p6##_type, typename p7##_type, typename p8##_type, \       typename p9##_type>\   template<typename arg_type>\   bool name##MatcherP10<p0##_type, p1##_type, p2##_type, p3##_type, \       p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \       p9##_type>::gmock_Impl<arg_type>::MatchAndExplain(\       arg_type arg, \       ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\           const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_
end_comment

end_unit

