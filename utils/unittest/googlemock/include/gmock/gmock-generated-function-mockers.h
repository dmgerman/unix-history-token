begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// This file was GENERATED by command:
end_comment

begin_comment
comment|//     pump.py gmock-generated-function-mockers.h.pump
end_comment

begin_comment
comment|// DO NOT EDIT BY HAND!!!
end_comment

begin_comment
comment|// Copyright 2007, Google Inc.
end_comment

begin_comment
comment|// All rights reserved.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Redistribution and use in source and binary forms, with or without
end_comment

begin_comment
comment|// modification, are permitted provided that the following conditions are
end_comment

begin_comment
comment|// met:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     * Redistributions of source code must retain the above copyright
end_comment

begin_comment
comment|// notice, this list of conditions and the following disclaimer.
end_comment

begin_comment
comment|//     * Redistributions in binary form must reproduce the above
end_comment

begin_comment
comment|// copyright notice, this list of conditions and the following disclaimer
end_comment

begin_comment
comment|// in the documentation and/or other materials provided with the
end_comment

begin_comment
comment|// distribution.
end_comment

begin_comment
comment|//     * Neither the name of Google Inc. nor the names of its
end_comment

begin_comment
comment|// contributors may be used to endorse or promote products derived from
end_comment

begin_comment
comment|// this software without specific prior written permission.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
end_comment

begin_comment
comment|// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
end_comment

begin_comment
comment|// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
end_comment

begin_comment
comment|// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
end_comment

begin_comment
comment|// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
end_comment

begin_comment
comment|// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
end_comment

begin_comment
comment|// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
end_comment

begin_comment
comment|// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
end_comment

begin_comment
comment|// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
end_comment

begin_comment
comment|// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Author: wan@google.com (Zhanyong Wan)
end_comment

begin_comment
comment|// Google Mock - a framework for writing C++ mock classes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file implements function mockers of various arities.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_FUNCTION_MOCKERS_H_
end_ifndef

begin_define
define|#
directive|define
name|GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_FUNCTION_MOCKERS_H_
end_define

begin_include
include|#
directive|include
file|"gmock/gmock-spec-builders.h"
end_include

begin_include
include|#
directive|include
file|"gmock/internal/gmock-internal-utils.h"
end_include

begin_if
if|#
directive|if
name|GTEST_HAS_STD_FUNCTION_
end_if

begin_include
include|#
directive|include
file|<functional>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|namespace
name|testing
block|{
name|namespace
name|internal
block|{
name|template
operator|<
name|typename
name|F
operator|>
name|class
name|FunctionMockerBase
expr_stmt|;
comment|// Note: class FunctionMocker really belongs to the ::testing
comment|// namespace.  However if we define it in ::testing, MSVC will
comment|// complain when classes in ::testing::internal declare it as a
comment|// friend class template.  To workaround this compiler bug, we define
comment|// FunctionMocker in ::testing::internal and import it into ::testing.
name|template
operator|<
name|typename
name|F
operator|>
name|class
name|FunctionMocker
expr_stmt|;
name|template
operator|<
name|typename
name|R
operator|>
name|class
name|FunctionMocker
operator|<
name|R
argument_list|()
operator|>
operator|:
name|public
name|internal
operator|::
name|FunctionMockerBase
operator|<
name|R
argument_list|()
operator|>
block|{
name|public
operator|:
typedef|typedef
name|R
name|F
parameter_list|()
function_decl|;
typedef|typedef
name|typename
name|internal
operator|::
name|Function
operator|<
name|F
operator|>
operator|::
name|ArgumentTuple
name|ArgumentTuple
expr_stmt|;
name|MockSpec
operator|<
name|F
operator|>
operator|&
name|With
argument_list|()
block|{
return|return
name|this
operator|->
name|current_spec
argument_list|()
return|;
block|}
name|R
name|Invoke
parameter_list|()
block|{
comment|// Even though gcc and MSVC don't enforce it, 'this->' is required
comment|// by the C++ standard [14.6.4] here, as the base class type is
comment|// dependent on the template argument (and thus shouldn't be
comment|// looked into when resolving InvokeWith).
return|return
name|this
operator|->
name|InvokeWith
argument_list|(
name|ArgumentTuple
argument_list|()
argument_list|)
return|;
block|}
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A1
operator|>
name|class
name|FunctionMocker
operator|<
name|R
argument_list|(
name|A1
argument_list|)
operator|>
operator|:
name|public
name|internal
operator|::
name|FunctionMockerBase
operator|<
name|R
argument_list|(
name|A1
argument_list|)
operator|>
block|{
name|public
operator|:
typedef|typedef
name|R
name|F
parameter_list|(
name|A1
parameter_list|)
function_decl|;
typedef|typedef
name|typename
name|internal
operator|::
name|Function
operator|<
name|F
operator|>
operator|::
name|ArgumentTuple
name|ArgumentTuple
expr_stmt|;
name|MockSpec
operator|<
name|F
operator|>
operator|&
name|With
argument_list|(
argument|const Matcher<A1>& m1
argument_list|)
block|{
name|this
operator|->
name|current_spec
argument_list|()
operator|.
name|SetMatchers
argument_list|(
operator|::
name|testing
operator|::
name|make_tuple
argument_list|(
name|m1
argument_list|)
argument_list|)
block|;
return|return
name|this
operator|->
name|current_spec
argument_list|()
return|;
block|}
name|R
name|Invoke
parameter_list|(
name|A1
name|a1
parameter_list|)
block|{
comment|// Even though gcc and MSVC don't enforce it, 'this->' is required
comment|// by the C++ standard [14.6.4] here, as the base class type is
comment|// dependent on the template argument (and thus shouldn't be
comment|// looked into when resolving InvokeWith).
return|return
name|this
operator|->
name|InvokeWith
argument_list|(
name|ArgumentTuple
argument_list|(
name|a1
argument_list|)
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|>
name|class
name|FunctionMocker
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|)
operator|>
operator|:
name|public
name|internal
operator|::
name|FunctionMockerBase
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|)
operator|>
block|{
name|public
operator|:
typedef|typedef
name|R
name|F
parameter_list|(
name|A1
parameter_list|,
name|A2
parameter_list|)
function_decl|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|internal
operator|::
name|Function
operator|<
name|F
operator|>
operator|::
name|ArgumentTuple
name|ArgumentTuple
expr_stmt|;
end_typedef

begin_expr_stmt
name|MockSpec
operator|<
name|F
operator|>
operator|&
name|With
argument_list|(
argument|const Matcher<A1>& m1
argument_list|,
argument|const Matcher<A2>& m2
argument_list|)
block|{
name|this
operator|->
name|current_spec
argument_list|()
operator|.
name|SetMatchers
argument_list|(
operator|::
name|testing
operator|::
name|make_tuple
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|)
argument_list|)
block|;
return|return
name|this
operator|->
name|current_spec
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|R
name|Invoke
parameter_list|(
name|A1
name|a1
parameter_list|,
name|A2
name|a2
parameter_list|)
block|{
comment|// Even though gcc and MSVC don't enforce it, 'this->' is required
comment|// by the C++ standard [14.6.4] here, as the base class type is
comment|// dependent on the template argument (and thus shouldn't be
comment|// looked into when resolving InvokeWith).
return|return
name|this
operator|->
name|InvokeWith
argument_list|(
name|ArgumentTuple
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|,
name|typename
name|A3
operator|>
name|class
name|FunctionMocker
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|)
operator|>
operator|:
name|public
name|internal
operator|::
name|FunctionMockerBase
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|)
operator|>
block|{
name|public
operator|:
typedef|typedef
name|R
name|F
parameter_list|(
name|A1
parameter_list|,
name|A2
parameter_list|,
name|A3
parameter_list|)
function_decl|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|internal
operator|::
name|Function
operator|<
name|F
operator|>
operator|::
name|ArgumentTuple
name|ArgumentTuple
expr_stmt|;
end_typedef

begin_expr_stmt
name|MockSpec
operator|<
name|F
operator|>
operator|&
name|With
argument_list|(
argument|const Matcher<A1>& m1
argument_list|,
argument|const Matcher<A2>& m2
argument_list|,
argument|const Matcher<A3>& m3
argument_list|)
block|{
name|this
operator|->
name|current_spec
argument_list|()
operator|.
name|SetMatchers
argument_list|(
operator|::
name|testing
operator|::
name|make_tuple
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|)
argument_list|)
block|;
return|return
name|this
operator|->
name|current_spec
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|R
name|Invoke
parameter_list|(
name|A1
name|a1
parameter_list|,
name|A2
name|a2
parameter_list|,
name|A3
name|a3
parameter_list|)
block|{
comment|// Even though gcc and MSVC don't enforce it, 'this->' is required
comment|// by the C++ standard [14.6.4] here, as the base class type is
comment|// dependent on the template argument (and thus shouldn't be
comment|// looked into when resolving InvokeWith).
return|return
name|this
operator|->
name|InvokeWith
argument_list|(
name|ArgumentTuple
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|,
name|typename
name|A3
operator|,
name|typename
name|A4
operator|>
name|class
name|FunctionMocker
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|)
operator|>
operator|:
name|public
name|internal
operator|::
name|FunctionMockerBase
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|)
operator|>
block|{
name|public
operator|:
typedef|typedef
name|R
name|F
parameter_list|(
name|A1
parameter_list|,
name|A2
parameter_list|,
name|A3
parameter_list|,
name|A4
parameter_list|)
function_decl|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|internal
operator|::
name|Function
operator|<
name|F
operator|>
operator|::
name|ArgumentTuple
name|ArgumentTuple
expr_stmt|;
end_typedef

begin_expr_stmt
name|MockSpec
operator|<
name|F
operator|>
operator|&
name|With
argument_list|(
argument|const Matcher<A1>& m1
argument_list|,
argument|const Matcher<A2>& m2
argument_list|,
argument|const Matcher<A3>& m3
argument_list|,
argument|const Matcher<A4>& m4
argument_list|)
block|{
name|this
operator|->
name|current_spec
argument_list|()
operator|.
name|SetMatchers
argument_list|(
operator|::
name|testing
operator|::
name|make_tuple
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|,
name|m4
argument_list|)
argument_list|)
block|;
return|return
name|this
operator|->
name|current_spec
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|R
name|Invoke
parameter_list|(
name|A1
name|a1
parameter_list|,
name|A2
name|a2
parameter_list|,
name|A3
name|a3
parameter_list|,
name|A4
name|a4
parameter_list|)
block|{
comment|// Even though gcc and MSVC don't enforce it, 'this->' is required
comment|// by the C++ standard [14.6.4] here, as the base class type is
comment|// dependent on the template argument (and thus shouldn't be
comment|// looked into when resolving InvokeWith).
return|return
name|this
operator|->
name|InvokeWith
argument_list|(
name|ArgumentTuple
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|,
name|typename
name|A3
operator|,
name|typename
name|A4
operator|,
name|typename
name|A5
operator|>
name|class
name|FunctionMocker
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|)
operator|>
operator|:
name|public
name|internal
operator|::
name|FunctionMockerBase
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|)
operator|>
block|{
name|public
operator|:
typedef|typedef
name|R
name|F
parameter_list|(
name|A1
parameter_list|,
name|A2
parameter_list|,
name|A3
parameter_list|,
name|A4
parameter_list|,
name|A5
parameter_list|)
function_decl|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|internal
operator|::
name|Function
operator|<
name|F
operator|>
operator|::
name|ArgumentTuple
name|ArgumentTuple
expr_stmt|;
end_typedef

begin_expr_stmt
name|MockSpec
operator|<
name|F
operator|>
operator|&
name|With
argument_list|(
argument|const Matcher<A1>& m1
argument_list|,
argument|const Matcher<A2>& m2
argument_list|,
argument|const Matcher<A3>& m3
argument_list|,
argument|const Matcher<A4>& m4
argument_list|,
argument|const Matcher<A5>& m5
argument_list|)
block|{
name|this
operator|->
name|current_spec
argument_list|()
operator|.
name|SetMatchers
argument_list|(
operator|::
name|testing
operator|::
name|make_tuple
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|,
name|m4
argument_list|,
name|m5
argument_list|)
argument_list|)
block|;
return|return
name|this
operator|->
name|current_spec
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|R
name|Invoke
parameter_list|(
name|A1
name|a1
parameter_list|,
name|A2
name|a2
parameter_list|,
name|A3
name|a3
parameter_list|,
name|A4
name|a4
parameter_list|,
name|A5
name|a5
parameter_list|)
block|{
comment|// Even though gcc and MSVC don't enforce it, 'this->' is required
comment|// by the C++ standard [14.6.4] here, as the base class type is
comment|// dependent on the template argument (and thus shouldn't be
comment|// looked into when resolving InvokeWith).
return|return
name|this
operator|->
name|InvokeWith
argument_list|(
name|ArgumentTuple
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|,
name|typename
name|A3
operator|,
name|typename
name|A4
operator|,
name|typename
name|A5
operator|,
name|typename
name|A6
operator|>
name|class
name|FunctionMocker
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|)
operator|>
operator|:
name|public
name|internal
operator|::
name|FunctionMockerBase
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|)
operator|>
block|{
name|public
operator|:
typedef|typedef
name|R
name|F
parameter_list|(
name|A1
parameter_list|,
name|A2
parameter_list|,
name|A3
parameter_list|,
name|A4
parameter_list|,
name|A5
parameter_list|,
name|A6
parameter_list|)
function_decl|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|internal
operator|::
name|Function
operator|<
name|F
operator|>
operator|::
name|ArgumentTuple
name|ArgumentTuple
expr_stmt|;
end_typedef

begin_expr_stmt
name|MockSpec
operator|<
name|F
operator|>
operator|&
name|With
argument_list|(
argument|const Matcher<A1>& m1
argument_list|,
argument|const Matcher<A2>& m2
argument_list|,
argument|const Matcher<A3>& m3
argument_list|,
argument|const Matcher<A4>& m4
argument_list|,
argument|const Matcher<A5>& m5
argument_list|,
argument|const Matcher<A6>& m6
argument_list|)
block|{
name|this
operator|->
name|current_spec
argument_list|()
operator|.
name|SetMatchers
argument_list|(
operator|::
name|testing
operator|::
name|make_tuple
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|,
name|m4
argument_list|,
name|m5
argument_list|,
name|m6
argument_list|)
argument_list|)
block|;
return|return
name|this
operator|->
name|current_spec
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|R
name|Invoke
parameter_list|(
name|A1
name|a1
parameter_list|,
name|A2
name|a2
parameter_list|,
name|A3
name|a3
parameter_list|,
name|A4
name|a4
parameter_list|,
name|A5
name|a5
parameter_list|,
name|A6
name|a6
parameter_list|)
block|{
comment|// Even though gcc and MSVC don't enforce it, 'this->' is required
comment|// by the C++ standard [14.6.4] here, as the base class type is
comment|// dependent on the template argument (and thus shouldn't be
comment|// looked into when resolving InvokeWith).
return|return
name|this
operator|->
name|InvokeWith
argument_list|(
name|ArgumentTuple
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|,
name|typename
name|A3
operator|,
name|typename
name|A4
operator|,
name|typename
name|A5
operator|,
name|typename
name|A6
operator|,
name|typename
name|A7
operator|>
name|class
name|FunctionMocker
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|)
operator|>
operator|:
name|public
name|internal
operator|::
name|FunctionMockerBase
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|)
operator|>
block|{
name|public
operator|:
typedef|typedef
name|R
name|F
parameter_list|(
name|A1
parameter_list|,
name|A2
parameter_list|,
name|A3
parameter_list|,
name|A4
parameter_list|,
name|A5
parameter_list|,
name|A6
parameter_list|,
name|A7
parameter_list|)
function_decl|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|internal
operator|::
name|Function
operator|<
name|F
operator|>
operator|::
name|ArgumentTuple
name|ArgumentTuple
expr_stmt|;
end_typedef

begin_expr_stmt
name|MockSpec
operator|<
name|F
operator|>
operator|&
name|With
argument_list|(
argument|const Matcher<A1>& m1
argument_list|,
argument|const Matcher<A2>& m2
argument_list|,
argument|const Matcher<A3>& m3
argument_list|,
argument|const Matcher<A4>& m4
argument_list|,
argument|const Matcher<A5>& m5
argument_list|,
argument|const Matcher<A6>& m6
argument_list|,
argument|const Matcher<A7>& m7
argument_list|)
block|{
name|this
operator|->
name|current_spec
argument_list|()
operator|.
name|SetMatchers
argument_list|(
operator|::
name|testing
operator|::
name|make_tuple
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|,
name|m4
argument_list|,
name|m5
argument_list|,
name|m6
argument_list|,
name|m7
argument_list|)
argument_list|)
block|;
return|return
name|this
operator|->
name|current_spec
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|R
name|Invoke
parameter_list|(
name|A1
name|a1
parameter_list|,
name|A2
name|a2
parameter_list|,
name|A3
name|a3
parameter_list|,
name|A4
name|a4
parameter_list|,
name|A5
name|a5
parameter_list|,
name|A6
name|a6
parameter_list|,
name|A7
name|a7
parameter_list|)
block|{
comment|// Even though gcc and MSVC don't enforce it, 'this->' is required
comment|// by the C++ standard [14.6.4] here, as the base class type is
comment|// dependent on the template argument (and thus shouldn't be
comment|// looked into when resolving InvokeWith).
return|return
name|this
operator|->
name|InvokeWith
argument_list|(
name|ArgumentTuple
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|,
name|typename
name|A3
operator|,
name|typename
name|A4
operator|,
name|typename
name|A5
operator|,
name|typename
name|A6
operator|,
name|typename
name|A7
operator|,
name|typename
name|A8
operator|>
name|class
name|FunctionMocker
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|,
name|A8
argument_list|)
operator|>
operator|:
name|public
name|internal
operator|::
name|FunctionMockerBase
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|,
name|A8
argument_list|)
operator|>
block|{
name|public
operator|:
typedef|typedef
name|R
name|F
parameter_list|(
name|A1
parameter_list|,
name|A2
parameter_list|,
name|A3
parameter_list|,
name|A4
parameter_list|,
name|A5
parameter_list|,
name|A6
parameter_list|,
name|A7
parameter_list|,
name|A8
parameter_list|)
function_decl|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|internal
operator|::
name|Function
operator|<
name|F
operator|>
operator|::
name|ArgumentTuple
name|ArgumentTuple
expr_stmt|;
end_typedef

begin_expr_stmt
name|MockSpec
operator|<
name|F
operator|>
operator|&
name|With
argument_list|(
argument|const Matcher<A1>& m1
argument_list|,
argument|const Matcher<A2>& m2
argument_list|,
argument|const Matcher<A3>& m3
argument_list|,
argument|const Matcher<A4>& m4
argument_list|,
argument|const Matcher<A5>& m5
argument_list|,
argument|const Matcher<A6>& m6
argument_list|,
argument|const Matcher<A7>& m7
argument_list|,
argument|const Matcher<A8>& m8
argument_list|)
block|{
name|this
operator|->
name|current_spec
argument_list|()
operator|.
name|SetMatchers
argument_list|(
operator|::
name|testing
operator|::
name|make_tuple
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|,
name|m4
argument_list|,
name|m5
argument_list|,
name|m6
argument_list|,
name|m7
argument_list|,
name|m8
argument_list|)
argument_list|)
block|;
return|return
name|this
operator|->
name|current_spec
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|R
name|Invoke
parameter_list|(
name|A1
name|a1
parameter_list|,
name|A2
name|a2
parameter_list|,
name|A3
name|a3
parameter_list|,
name|A4
name|a4
parameter_list|,
name|A5
name|a5
parameter_list|,
name|A6
name|a6
parameter_list|,
name|A7
name|a7
parameter_list|,
name|A8
name|a8
parameter_list|)
block|{
comment|// Even though gcc and MSVC don't enforce it, 'this->' is required
comment|// by the C++ standard [14.6.4] here, as the base class type is
comment|// dependent on the template argument (and thus shouldn't be
comment|// looked into when resolving InvokeWith).
return|return
name|this
operator|->
name|InvokeWith
argument_list|(
name|ArgumentTuple
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|,
name|typename
name|A3
operator|,
name|typename
name|A4
operator|,
name|typename
name|A5
operator|,
name|typename
name|A6
operator|,
name|typename
name|A7
operator|,
name|typename
name|A8
operator|,
name|typename
name|A9
operator|>
name|class
name|FunctionMocker
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|,
name|A8
argument_list|,
name|A9
argument_list|)
operator|>
operator|:
name|public
name|internal
operator|::
name|FunctionMockerBase
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|,
name|A8
argument_list|,
name|A9
argument_list|)
operator|>
block|{
name|public
operator|:
typedef|typedef
name|R
name|F
parameter_list|(
name|A1
parameter_list|,
name|A2
parameter_list|,
name|A3
parameter_list|,
name|A4
parameter_list|,
name|A5
parameter_list|,
name|A6
parameter_list|,
name|A7
parameter_list|,
name|A8
parameter_list|,
name|A9
parameter_list|)
function_decl|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|internal
operator|::
name|Function
operator|<
name|F
operator|>
operator|::
name|ArgumentTuple
name|ArgumentTuple
expr_stmt|;
end_typedef

begin_expr_stmt
name|MockSpec
operator|<
name|F
operator|>
operator|&
name|With
argument_list|(
argument|const Matcher<A1>& m1
argument_list|,
argument|const Matcher<A2>& m2
argument_list|,
argument|const Matcher<A3>& m3
argument_list|,
argument|const Matcher<A4>& m4
argument_list|,
argument|const Matcher<A5>& m5
argument_list|,
argument|const Matcher<A6>& m6
argument_list|,
argument|const Matcher<A7>& m7
argument_list|,
argument|const Matcher<A8>& m8
argument_list|,
argument|const Matcher<A9>& m9
argument_list|)
block|{
name|this
operator|->
name|current_spec
argument_list|()
operator|.
name|SetMatchers
argument_list|(
operator|::
name|testing
operator|::
name|make_tuple
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|,
name|m4
argument_list|,
name|m5
argument_list|,
name|m6
argument_list|,
name|m7
argument_list|,
name|m8
argument_list|,
name|m9
argument_list|)
argument_list|)
block|;
return|return
name|this
operator|->
name|current_spec
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|R
name|Invoke
parameter_list|(
name|A1
name|a1
parameter_list|,
name|A2
name|a2
parameter_list|,
name|A3
name|a3
parameter_list|,
name|A4
name|a4
parameter_list|,
name|A5
name|a5
parameter_list|,
name|A6
name|a6
parameter_list|,
name|A7
name|a7
parameter_list|,
name|A8
name|a8
parameter_list|,
name|A9
name|a9
parameter_list|)
block|{
comment|// Even though gcc and MSVC don't enforce it, 'this->' is required
comment|// by the C++ standard [14.6.4] here, as the base class type is
comment|// dependent on the template argument (and thus shouldn't be
comment|// looked into when resolving InvokeWith).
return|return
name|this
operator|->
name|InvokeWith
argument_list|(
name|ArgumentTuple
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|,
name|typename
name|A3
operator|,
name|typename
name|A4
operator|,
name|typename
name|A5
operator|,
name|typename
name|A6
operator|,
name|typename
name|A7
operator|,
name|typename
name|A8
operator|,
name|typename
name|A9
operator|,
name|typename
name|A10
operator|>
name|class
name|FunctionMocker
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|,
name|A8
argument_list|,
name|A9
argument_list|,
name|A10
argument_list|)
operator|>
operator|:
name|public
name|internal
operator|::
name|FunctionMockerBase
operator|<
name|R
argument_list|(
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|,
name|A8
argument_list|,
name|A9
argument_list|,
name|A10
argument_list|)
operator|>
block|{
name|public
operator|:
typedef|typedef
name|R
name|F
parameter_list|(
name|A1
parameter_list|,
name|A2
parameter_list|,
name|A3
parameter_list|,
name|A4
parameter_list|,
name|A5
parameter_list|,
name|A6
parameter_list|,
name|A7
parameter_list|,
name|A8
parameter_list|,
name|A9
parameter_list|,
name|A10
parameter_list|)
function_decl|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|internal
operator|::
name|Function
operator|<
name|F
operator|>
operator|::
name|ArgumentTuple
name|ArgumentTuple
expr_stmt|;
end_typedef

begin_expr_stmt
name|MockSpec
operator|<
name|F
operator|>
operator|&
name|With
argument_list|(
argument|const Matcher<A1>& m1
argument_list|,
argument|const Matcher<A2>& m2
argument_list|,
argument|const Matcher<A3>& m3
argument_list|,
argument|const Matcher<A4>& m4
argument_list|,
argument|const Matcher<A5>& m5
argument_list|,
argument|const Matcher<A6>& m6
argument_list|,
argument|const Matcher<A7>& m7
argument_list|,
argument|const Matcher<A8>& m8
argument_list|,
argument|const Matcher<A9>& m9
argument_list|,
argument|const Matcher<A10>& m10
argument_list|)
block|{
name|this
operator|->
name|current_spec
argument_list|()
operator|.
name|SetMatchers
argument_list|(
operator|::
name|testing
operator|::
name|make_tuple
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
name|m3
argument_list|,
name|m4
argument_list|,
name|m5
argument_list|,
name|m6
argument_list|,
name|m7
argument_list|,
name|m8
argument_list|,
name|m9
argument_list|,
name|m10
argument_list|)
argument_list|)
block|;
return|return
name|this
operator|->
name|current_spec
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|R
name|Invoke
parameter_list|(
name|A1
name|a1
parameter_list|,
name|A2
name|a2
parameter_list|,
name|A3
name|a3
parameter_list|,
name|A4
name|a4
parameter_list|,
name|A5
name|a5
parameter_list|,
name|A6
name|a6
parameter_list|,
name|A7
name|a7
parameter_list|,
name|A8
name|a8
parameter_list|,
name|A9
name|a9
parameter_list|,
name|A10
name|a10
parameter_list|)
block|{
comment|// Even though gcc and MSVC don't enforce it, 'this->' is required
comment|// by the C++ standard [14.6.4] here, as the base class type is
comment|// dependent on the template argument (and thus shouldn't be
comment|// looked into when resolving InvokeWith).
return|return
name|this
operator|->
name|InvokeWith
argument_list|(
name|ArgumentTuple
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|,
name|a10
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
unit|};  }
comment|// namespace internal
end_comment

begin_comment
comment|// The style guide prohibits "using" statements in a namespace scope
end_comment

begin_comment
comment|// inside a header file.  However, the FunctionMocker class template
end_comment

begin_comment
comment|// is meant to be defined in the ::testing namespace.  The following
end_comment

begin_comment
comment|// line is just a trick for working around a bug in MSVC 8.0, which
end_comment

begin_comment
comment|// cannot handle it if we define FunctionMocker in ::testing.
end_comment

begin_expr_stmt
unit|using
name|internal
operator|::
name|FunctionMocker
expr_stmt|;
end_expr_stmt

begin_comment
comment|// GMOCK_RESULT_(tn, F) expands to the result type of function type F.
end_comment

begin_comment
comment|// We define this as a variadic macro in case F contains unprotected
end_comment

begin_comment
comment|// commas (the same reason that we use variadic macros in other places
end_comment

begin_comment
comment|// in this file).
end_comment

begin_comment
comment|// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!
end_comment

begin_define
define|#
directive|define
name|GMOCK_RESULT_
parameter_list|(
name|tn
parameter_list|,
modifier|...
parameter_list|)
define|\
value|tn ::testing::internal::Function<__VA_ARGS__>::Result
end_define

begin_comment
comment|// The type of argument N of the given function type.
end_comment

begin_comment
comment|// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!
end_comment

begin_define
define|#
directive|define
name|GMOCK_ARG_
parameter_list|(
name|tn
parameter_list|,
name|N
parameter_list|,
modifier|...
parameter_list|)
define|\
value|tn ::testing::internal::Function<__VA_ARGS__>::Argument##N
end_define

begin_comment
comment|// The matcher type for argument N of the given function type.
end_comment

begin_comment
comment|// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!
end_comment

begin_define
define|#
directive|define
name|GMOCK_MATCHER_
parameter_list|(
name|tn
parameter_list|,
name|N
parameter_list|,
modifier|...
parameter_list|)
define|\
value|const ::testing::Matcher<GMOCK_ARG_(tn, N, __VA_ARGS__)>&
end_define

begin_comment
comment|// The variable for mocking the given method.
end_comment

begin_comment
comment|// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!
end_comment

begin_define
define|#
directive|define
name|GMOCK_MOCKER_
parameter_list|(
name|arity
parameter_list|,
name|constness
parameter_list|,
name|Method
parameter_list|)
define|\
value|GTEST_CONCAT_TOKEN_(gmock##constness##arity##_##Method##_, __LINE__)
end_define

begin_comment
comment|// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!
end_comment

begin_define
define|#
directive|define
name|GMOCK_METHOD0_
parameter_list|(
name|tn
parameter_list|,
name|constness
parameter_list|,
name|ct
parameter_list|,
name|Method
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \       ) constness { \     GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \         tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \             == 0), \         this_method_does_not_take_0_arguments); \     GMOCK_MOCKER_(0, constness, Method).SetOwnerAndName(this, #Method); \     return GMOCK_MOCKER_(0, constness, Method).Invoke(); \   } \   ::testing::MockSpec<__VA_ARGS__>& \       gmock_##Method() constness { \     GMOCK_MOCKER_(0, constness, Method).RegisterOwner(this); \     return GMOCK_MOCKER_(0, constness, Method).With(); \   } \   mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(0, constness, \       Method)
end_define

begin_comment
comment|// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!
end_comment

begin_define
define|#
directive|define
name|GMOCK_METHOD1_
parameter_list|(
name|tn
parameter_list|,
name|constness
parameter_list|,
name|ct
parameter_list|,
name|Method
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \       GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1) constness { \     GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \         tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \             == 1), \         this_method_does_not_take_1_argument); \     GMOCK_MOCKER_(1, constness, Method).SetOwnerAndName(this, #Method); \     return GMOCK_MOCKER_(1, constness, Method).Invoke(gmock_a1); \   } \   ::testing::MockSpec<__VA_ARGS__>& \       gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1) constness { \     GMOCK_MOCKER_(1, constness, Method).RegisterOwner(this); \     return GMOCK_MOCKER_(1, constness, Method).With(gmock_a1); \   } \   mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(1, constness, \       Method)
end_define

begin_comment
comment|// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!
end_comment

begin_define
define|#
directive|define
name|GMOCK_METHOD2_
parameter_list|(
name|tn
parameter_list|,
name|constness
parameter_list|,
name|ct
parameter_list|,
name|Method
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \       GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \       GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2) constness { \     GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \         tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \             == 2), \         this_method_does_not_take_2_arguments); \     GMOCK_MOCKER_(2, constness, Method).SetOwnerAndName(this, #Method); \     return GMOCK_MOCKER_(2, constness, Method).Invoke(gmock_a1, gmock_a2); \   } \   ::testing::MockSpec<__VA_ARGS__>& \       gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \                      GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2) constness { \     GMOCK_MOCKER_(2, constness, Method).RegisterOwner(this); \     return GMOCK_MOCKER_(2, constness, Method).With(gmock_a1, gmock_a2); \   } \   mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(2, constness, \       Method)
end_define

begin_comment
comment|// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!
end_comment

begin_define
define|#
directive|define
name|GMOCK_METHOD3_
parameter_list|(
name|tn
parameter_list|,
name|constness
parameter_list|,
name|ct
parameter_list|,
name|Method
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \       GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \       GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \       GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3) constness { \     GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \         tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \             == 3), \         this_method_does_not_take_3_arguments); \     GMOCK_MOCKER_(3, constness, Method).SetOwnerAndName(this, #Method); \     return GMOCK_MOCKER_(3, constness, Method).Invoke(gmock_a1, gmock_a2, \         gmock_a3); \   } \   ::testing::MockSpec<__VA_ARGS__>& \       gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \                      GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \                      GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3) constness { \     GMOCK_MOCKER_(3, constness, Method).RegisterOwner(this); \     return GMOCK_MOCKER_(3, constness, Method).With(gmock_a1, gmock_a2, \         gmock_a3); \   } \   mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(3, constness, \       Method)
end_define

begin_comment
comment|// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!
end_comment

begin_define
define|#
directive|define
name|GMOCK_METHOD4_
parameter_list|(
name|tn
parameter_list|,
name|constness
parameter_list|,
name|ct
parameter_list|,
name|Method
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \       GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \       GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \       GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \       GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4) constness { \     GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \         tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \             == 4), \         this_method_does_not_take_4_arguments); \     GMOCK_MOCKER_(4, constness, Method).SetOwnerAndName(this, #Method); \     return GMOCK_MOCKER_(4, constness, Method).Invoke(gmock_a1, gmock_a2, \         gmock_a3, gmock_a4); \   } \   ::testing::MockSpec<__VA_ARGS__>& \       gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \                      GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \                      GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \                      GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4) constness { \     GMOCK_MOCKER_(4, constness, Method).RegisterOwner(this); \     return GMOCK_MOCKER_(4, constness, Method).With(gmock_a1, gmock_a2, \         gmock_a3, gmock_a4); \   } \   mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(4, constness, \       Method)
end_define

begin_comment
comment|// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!
end_comment

begin_define
define|#
directive|define
name|GMOCK_METHOD5_
parameter_list|(
name|tn
parameter_list|,
name|constness
parameter_list|,
name|ct
parameter_list|,
name|Method
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \       GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \       GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \       GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \       GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \       GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5) constness { \     GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \         tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \             == 5), \         this_method_does_not_take_5_arguments); \     GMOCK_MOCKER_(5, constness, Method).SetOwnerAndName(this, #Method); \     return GMOCK_MOCKER_(5, constness, Method).Invoke(gmock_a1, gmock_a2, \         gmock_a3, gmock_a4, gmock_a5); \   } \   ::testing::MockSpec<__VA_ARGS__>& \       gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \                      GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \                      GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \                      GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \                      GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5) constness { \     GMOCK_MOCKER_(5, constness, Method).RegisterOwner(this); \     return GMOCK_MOCKER_(5, constness, Method).With(gmock_a1, gmock_a2, \         gmock_a3, gmock_a4, gmock_a5); \   } \   mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(5, constness, \       Method)
end_define

begin_comment
comment|// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!
end_comment

begin_define
define|#
directive|define
name|GMOCK_METHOD6_
parameter_list|(
name|tn
parameter_list|,
name|constness
parameter_list|,
name|ct
parameter_list|,
name|Method
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \       GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \       GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \       GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \       GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \       GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5, \       GMOCK_ARG_(tn, 6, __VA_ARGS__) gmock_a6) constness { \     GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \         tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \             == 6), \         this_method_does_not_take_6_arguments); \     GMOCK_MOCKER_(6, constness, Method).SetOwnerAndName(this, #Method); \     return GMOCK_MOCKER_(6, constness, Method).Invoke(gmock_a1, gmock_a2, \         gmock_a3, gmock_a4, gmock_a5, gmock_a6); \   } \   ::testing::MockSpec<__VA_ARGS__>& \       gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \                      GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \                      GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \                      GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \                      GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5, \                      GMOCK_MATCHER_(tn, 6, __VA_ARGS__) gmock_a6) constness { \     GMOCK_MOCKER_(6, constness, Method).RegisterOwner(this); \     return GMOCK_MOCKER_(6, constness, Method).With(gmock_a1, gmock_a2, \         gmock_a3, gmock_a4, gmock_a5, gmock_a6); \   } \   mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(6, constness, \       Method)
end_define

begin_comment
comment|// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!
end_comment

begin_define
define|#
directive|define
name|GMOCK_METHOD7_
parameter_list|(
name|tn
parameter_list|,
name|constness
parameter_list|,
name|ct
parameter_list|,
name|Method
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \       GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \       GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \       GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \       GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \       GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5, \       GMOCK_ARG_(tn, 6, __VA_ARGS__) gmock_a6, \       GMOCK_ARG_(tn, 7, __VA_ARGS__) gmock_a7) constness { \     GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \         tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \             == 7), \         this_method_does_not_take_7_arguments); \     GMOCK_MOCKER_(7, constness, Method).SetOwnerAndName(this, #Method); \     return GMOCK_MOCKER_(7, constness, Method).Invoke(gmock_a1, gmock_a2, \         gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7); \   } \   ::testing::MockSpec<__VA_ARGS__>& \       gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \                      GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \                      GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \                      GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \                      GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5, \                      GMOCK_MATCHER_(tn, 6, __VA_ARGS__) gmock_a6, \                      GMOCK_MATCHER_(tn, 7, __VA_ARGS__) gmock_a7) constness { \     GMOCK_MOCKER_(7, constness, Method).RegisterOwner(this); \     return GMOCK_MOCKER_(7, constness, Method).With(gmock_a1, gmock_a2, \         gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7); \   } \   mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(7, constness, \       Method)
end_define

begin_comment
comment|// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!
end_comment

begin_define
define|#
directive|define
name|GMOCK_METHOD8_
parameter_list|(
name|tn
parameter_list|,
name|constness
parameter_list|,
name|ct
parameter_list|,
name|Method
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \       GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \       GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \       GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \       GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \       GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5, \       GMOCK_ARG_(tn, 6, __VA_ARGS__) gmock_a6, \       GMOCK_ARG_(tn, 7, __VA_ARGS__) gmock_a7, \       GMOCK_ARG_(tn, 8, __VA_ARGS__) gmock_a8) constness { \     GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \         tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \             == 8), \         this_method_does_not_take_8_arguments); \     GMOCK_MOCKER_(8, constness, Method).SetOwnerAndName(this, #Method); \     return GMOCK_MOCKER_(8, constness, Method).Invoke(gmock_a1, gmock_a2, \         gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8); \   } \   ::testing::MockSpec<__VA_ARGS__>& \       gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \                      GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \                      GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \                      GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \                      GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5, \                      GMOCK_MATCHER_(tn, 6, __VA_ARGS__) gmock_a6, \                      GMOCK_MATCHER_(tn, 7, __VA_ARGS__) gmock_a7, \                      GMOCK_MATCHER_(tn, 8, __VA_ARGS__) gmock_a8) constness { \     GMOCK_MOCKER_(8, constness, Method).RegisterOwner(this); \     return GMOCK_MOCKER_(8, constness, Method).With(gmock_a1, gmock_a2, \         gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8); \   } \   mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(8, constness, \       Method)
end_define

begin_comment
comment|// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!
end_comment

begin_define
define|#
directive|define
name|GMOCK_METHOD9_
parameter_list|(
name|tn
parameter_list|,
name|constness
parameter_list|,
name|ct
parameter_list|,
name|Method
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \       GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \       GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \       GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \       GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \       GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5, \       GMOCK_ARG_(tn, 6, __VA_ARGS__) gmock_a6, \       GMOCK_ARG_(tn, 7, __VA_ARGS__) gmock_a7, \       GMOCK_ARG_(tn, 8, __VA_ARGS__) gmock_a8, \       GMOCK_ARG_(tn, 9, __VA_ARGS__) gmock_a9) constness { \     GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \         tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \             == 9), \         this_method_does_not_take_9_arguments); \     GMOCK_MOCKER_(9, constness, Method).SetOwnerAndName(this, #Method); \     return GMOCK_MOCKER_(9, constness, Method).Invoke(gmock_a1, gmock_a2, \         gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8, \         gmock_a9); \   } \   ::testing::MockSpec<__VA_ARGS__>& \       gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \                      GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \                      GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \                      GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \                      GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5, \                      GMOCK_MATCHER_(tn, 6, __VA_ARGS__) gmock_a6, \                      GMOCK_MATCHER_(tn, 7, __VA_ARGS__) gmock_a7, \                      GMOCK_MATCHER_(tn, 8, __VA_ARGS__) gmock_a8, \                      GMOCK_MATCHER_(tn, 9, __VA_ARGS__) gmock_a9) constness { \     GMOCK_MOCKER_(9, constness, Method).RegisterOwner(this); \     return GMOCK_MOCKER_(9, constness, Method).With(gmock_a1, gmock_a2, \         gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8, \         gmock_a9); \   } \   mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(9, constness, \       Method)
end_define

begin_comment
comment|// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!
end_comment

begin_define
define|#
directive|define
name|GMOCK_METHOD10_
parameter_list|(
name|tn
parameter_list|,
name|constness
parameter_list|,
name|ct
parameter_list|,
name|Method
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \       GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \       GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \       GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \       GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \       GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5, \       GMOCK_ARG_(tn, 6, __VA_ARGS__) gmock_a6, \       GMOCK_ARG_(tn, 7, __VA_ARGS__) gmock_a7, \       GMOCK_ARG_(tn, 8, __VA_ARGS__) gmock_a8, \       GMOCK_ARG_(tn, 9, __VA_ARGS__) gmock_a9, \       GMOCK_ARG_(tn, 10, __VA_ARGS__) gmock_a10) constness { \     GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \         tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \             == 10), \         this_method_does_not_take_10_arguments); \     GMOCK_MOCKER_(10, constness, Method).SetOwnerAndName(this, #Method); \     return GMOCK_MOCKER_(10, constness, Method).Invoke(gmock_a1, gmock_a2, \         gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8, gmock_a9, \         gmock_a10); \   } \   ::testing::MockSpec<__VA_ARGS__>& \       gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \                      GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \                      GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \                      GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \                      GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5, \                      GMOCK_MATCHER_(tn, 6, __VA_ARGS__) gmock_a6, \                      GMOCK_MATCHER_(tn, 7, __VA_ARGS__) gmock_a7, \                      GMOCK_MATCHER_(tn, 8, __VA_ARGS__) gmock_a8, \                      GMOCK_MATCHER_(tn, 9, __VA_ARGS__) gmock_a9, \                      GMOCK_MATCHER_(tn, 10, \                          __VA_ARGS__) gmock_a10) constness { \     GMOCK_MOCKER_(10, constness, Method).RegisterOwner(this); \     return GMOCK_MOCKER_(10, constness, Method).With(gmock_a1, gmock_a2, \         gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8, gmock_a9, \         gmock_a10); \   } \   mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(10, constness, \       Method)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD0
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD0_(, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD1
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD1_(, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD2
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD2_(, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD3
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD3_(, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD4
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD4_(, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD5
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD5_(, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD6
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD6_(, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD7
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD7_(, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD8
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD8_(, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD9
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD9_(, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD10
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD10_(, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD0
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD0_(, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD1
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD1_(, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD2
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD2_(, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD3
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD3_(, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD4
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD4_(, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD5
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD5_(, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD6
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD6_(, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD7
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD7_(, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD8
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD8_(, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD9
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD9_(, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD10
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD10_(, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD0_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD0_(typename, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD1_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD1_(typename, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD2_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD2_(typename, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD3_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD3_(typename, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD4_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD4_(typename, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD5_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD5_(typename, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD6_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD6_(typename, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD7_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD7_(typename, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD8_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD8_(typename, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD9_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD9_(typename, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD10_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
value|GMOCK_METHOD10_(typename, , , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD0_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD0_(typename, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD1_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD1_(typename, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD2_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD2_(typename, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD3_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD3_(typename, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD4_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD4_(typename, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD5_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD5_(typename, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD6_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD6_(typename, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD7_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD7_(typename, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD8_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD8_(typename, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD9_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD9_(typename, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD10_T
parameter_list|(
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD10_(typename, const, , m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD0_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD0_(, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD1_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD1_(, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD2_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD2_(, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD3_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD3_(, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD4_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD4_(, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD5_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD5_(, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD6_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD6_(, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD7_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD7_(, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD8_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD8_(, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD9_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD9_(, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD10_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD10_(, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD0_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD0_(, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD1_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD1_(, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD2_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD2_(, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD3_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD3_(, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD4_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD4_(, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD5_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD5_(, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD6_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD6_(, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD7_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD7_(, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD8_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD8_(, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD9_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD9_(, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD10_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD10_(, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD0_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD0_(typename, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD1_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD1_(typename, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD2_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD2_(typename, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD3_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD3_(typename, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD4_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD4_(typename, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD5_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD5_(typename, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD6_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD6_(typename, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD7_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD7_(typename, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD8_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD8_(typename, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD9_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD9_(typename, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_METHOD10_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD10_(typename, , ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD0_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD0_(typename, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD1_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD1_(typename, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD2_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD2_(typename, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD3_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD3_(typename, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD4_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD4_(typename, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD5_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD5_(typename, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD6_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD6_(typename, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD7_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD7_(typename, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD8_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD8_(typename, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD9_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD9_(typename, const, ct, m, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|MOCK_CONST_METHOD10_T_WITH_CALLTYPE
parameter_list|(
name|ct
parameter_list|,
name|m
parameter_list|,
modifier|...
parameter_list|)
define|\
value|GMOCK_METHOD10_(typename, const, ct, m, __VA_ARGS__)
end_define

begin_comment
comment|// A MockFunction<F> class has one mock method whose type is F.  It is
end_comment

begin_comment
comment|// useful when you just want your test code to emit some messages and
end_comment

begin_comment
comment|// have Google Mock verify the right messages are sent (and perhaps at
end_comment

begin_comment
comment|// the right times).  For example, if you are exercising code:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//   Foo(1);
end_comment

begin_comment
comment|//   Foo(2);
end_comment

begin_comment
comment|//   Foo(3);
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// and want to verify that Foo(1) and Foo(3) both invoke
end_comment

begin_comment
comment|// mock.Bar("a"), but Foo(2) doesn't invoke anything, you can write:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// TEST(FooTest, InvokesBarCorrectly) {
end_comment

begin_comment
comment|//   MyMock mock;
end_comment

begin_comment
comment|//   MockFunction<void(string check_point_name)> check;
end_comment

begin_comment
comment|//   {
end_comment

begin_comment
comment|//     InSequence s;
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//     EXPECT_CALL(mock, Bar("a"));
end_comment

begin_comment
comment|//     EXPECT_CALL(check, Call("1"));
end_comment

begin_comment
comment|//     EXPECT_CALL(check, Call("2"));
end_comment

begin_comment
comment|//     EXPECT_CALL(mock, Bar("a"));
end_comment

begin_comment
comment|//   }
end_comment

begin_comment
comment|//   Foo(1);
end_comment

begin_comment
comment|//   check.Call("1");
end_comment

begin_comment
comment|//   Foo(2);
end_comment

begin_comment
comment|//   check.Call("2");
end_comment

begin_comment
comment|//   Foo(3);
end_comment

begin_comment
comment|// }
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// The expectation spec says that the first Bar("a") must happen
end_comment

begin_comment
comment|// before check point "1", the second Bar("a") must happen after check
end_comment

begin_comment
comment|// point "2", and nothing should happen between the two check
end_comment

begin_comment
comment|// points. The explicit check points make it easy to tell which
end_comment

begin_comment
comment|// Bar("a") is called by which call to Foo().
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// MockFunction<F> can also be used to exercise code that accepts
end_comment

begin_comment
comment|// std::function<F> callbacks. To do so, use AsStdFunction() method
end_comment

begin_comment
comment|// to create std::function proxy forwarding to original object's Call.
end_comment

begin_comment
comment|// Example:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// TEST(FooTest, RunsCallbackWithBarArgument) {
end_comment

begin_comment
comment|//   MockFunction<int(string)> callback;
end_comment

begin_comment
comment|//   EXPECT_CALL(callback, Call("bar")).WillOnce(Return(1));
end_comment

begin_comment
comment|//   Foo(callback.AsStdFunction());
end_comment

begin_comment
comment|// }
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|F
operator|>
name|class
name|MockFunction
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|R
operator|>
name|class
name|MockFunction
operator|<
name|R
argument_list|()
operator|>
block|{
name|public
operator|:
name|MockFunction
argument_list|()
block|{}
name|MOCK_METHOD0_T
argument_list|(
name|Call
argument_list|,
name|R
argument_list|()
argument_list|)
block|;
if|#
directive|if
name|GTEST_HAS_STD_FUNCTION_
name|std
operator|::
name|function
operator|<
name|R
argument_list|()
operator|>
name|AsStdFunction
argument_list|()
block|{
return|return
index|[
name|this
index|]
operator|(
operator|)
operator|->
name|R
block|{
return|return
name|this
operator|->
name|Call
argument_list|()
return|;
block|}
block|;   }
endif|#
directive|endif
comment|// GTEST_HAS_STD_FUNCTION_
name|private
operator|:
name|GTEST_DISALLOW_COPY_AND_ASSIGN_
argument_list|(
name|MockFunction
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A0
operator|>
name|class
name|MockFunction
operator|<
name|R
argument_list|(
name|A0
argument_list|)
operator|>
block|{
name|public
operator|:
name|MockFunction
argument_list|()
block|{}
name|MOCK_METHOD1_T
argument_list|(
name|Call
argument_list|,
name|R
argument_list|(
name|A0
argument_list|)
argument_list|)
block|;
if|#
directive|if
name|GTEST_HAS_STD_FUNCTION_
name|std
operator|::
name|function
operator|<
name|R
argument_list|(
name|A0
argument_list|)
operator|>
name|AsStdFunction
argument_list|()
block|{
return|return
index|[
name|this
index|]
operator|(
name|A0
name|a0
operator|)
operator|->
name|R
block|{
return|return
name|this
operator|->
name|Call
argument_list|(
name|a0
argument_list|)
return|;
block|}
block|;   }
endif|#
directive|endif
comment|// GTEST_HAS_STD_FUNCTION_
name|private
operator|:
name|GTEST_DISALLOW_COPY_AND_ASSIGN_
argument_list|(
name|MockFunction
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A0
operator|,
name|typename
name|A1
operator|>
name|class
name|MockFunction
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|)
operator|>
block|{
name|public
operator|:
name|MockFunction
argument_list|()
block|{}
name|MOCK_METHOD2_T
argument_list|(
name|Call
argument_list|,
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|)
argument_list|)
block|;
if|#
directive|if
name|GTEST_HAS_STD_FUNCTION_
name|std
operator|::
name|function
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|)
operator|>
name|AsStdFunction
argument_list|()
block|{
return|return
index|[
name|this
index|]
operator|(
name|A0
name|a0
operator|,
name|A1
name|a1
operator|)
operator|->
name|R
block|{
return|return
name|this
operator|->
name|Call
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|)
return|;
block|}
block|;   }
endif|#
directive|endif
comment|// GTEST_HAS_STD_FUNCTION_
name|private
operator|:
name|GTEST_DISALLOW_COPY_AND_ASSIGN_
argument_list|(
name|MockFunction
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A0
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|>
name|class
name|MockFunction
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|)
operator|>
block|{
name|public
operator|:
name|MockFunction
argument_list|()
block|{}
name|MOCK_METHOD3_T
argument_list|(
name|Call
argument_list|,
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|)
argument_list|)
block|;
if|#
directive|if
name|GTEST_HAS_STD_FUNCTION_
name|std
operator|::
name|function
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|)
operator|>
name|AsStdFunction
argument_list|()
block|{
return|return
index|[
name|this
index|]
operator|(
name|A0
name|a0
operator|,
name|A1
name|a1
operator|,
name|A2
name|a2
operator|)
operator|->
name|R
block|{
return|return
name|this
operator|->
name|Call
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
return|;
block|}
block|;   }
endif|#
directive|endif
comment|// GTEST_HAS_STD_FUNCTION_
name|private
operator|:
name|GTEST_DISALLOW_COPY_AND_ASSIGN_
argument_list|(
name|MockFunction
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A0
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|,
name|typename
name|A3
operator|>
name|class
name|MockFunction
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|)
operator|>
block|{
name|public
operator|:
name|MockFunction
argument_list|()
block|{}
name|MOCK_METHOD4_T
argument_list|(
name|Call
argument_list|,
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|)
argument_list|)
block|;
if|#
directive|if
name|GTEST_HAS_STD_FUNCTION_
name|std
operator|::
name|function
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|)
operator|>
name|AsStdFunction
argument_list|()
block|{
return|return
index|[
name|this
index|]
operator|(
name|A0
name|a0
operator|,
name|A1
name|a1
operator|,
name|A2
name|a2
operator|,
name|A3
name|a3
operator|)
operator|->
name|R
block|{
return|return
name|this
operator|->
name|Call
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
return|;
block|}
block|;   }
endif|#
directive|endif
comment|// GTEST_HAS_STD_FUNCTION_
name|private
operator|:
name|GTEST_DISALLOW_COPY_AND_ASSIGN_
argument_list|(
name|MockFunction
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A0
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|,
name|typename
name|A3
operator|,
name|typename
name|A4
operator|>
name|class
name|MockFunction
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|)
operator|>
block|{
name|public
operator|:
name|MockFunction
argument_list|()
block|{}
name|MOCK_METHOD5_T
argument_list|(
name|Call
argument_list|,
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|)
argument_list|)
block|;
if|#
directive|if
name|GTEST_HAS_STD_FUNCTION_
name|std
operator|::
name|function
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|)
operator|>
name|AsStdFunction
argument_list|()
block|{
return|return
index|[
name|this
index|]
operator|(
name|A0
name|a0
operator|,
name|A1
name|a1
operator|,
name|A2
name|a2
operator|,
name|A3
name|a3
operator|,
name|A4
name|a4
operator|)
operator|->
name|R
block|{
return|return
name|this
operator|->
name|Call
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|)
return|;
block|}
block|;   }
endif|#
directive|endif
comment|// GTEST_HAS_STD_FUNCTION_
name|private
operator|:
name|GTEST_DISALLOW_COPY_AND_ASSIGN_
argument_list|(
name|MockFunction
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A0
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|,
name|typename
name|A3
operator|,
name|typename
name|A4
operator|,
name|typename
name|A5
operator|>
name|class
name|MockFunction
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|)
operator|>
block|{
name|public
operator|:
name|MockFunction
argument_list|()
block|{}
name|MOCK_METHOD6_T
argument_list|(
name|Call
argument_list|,
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|)
argument_list|)
block|;
if|#
directive|if
name|GTEST_HAS_STD_FUNCTION_
name|std
operator|::
name|function
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|)
operator|>
name|AsStdFunction
argument_list|()
block|{
return|return
index|[
name|this
index|]
operator|(
name|A0
name|a0
operator|,
name|A1
name|a1
operator|,
name|A2
name|a2
operator|,
name|A3
name|a3
operator|,
name|A4
name|a4
operator|,
name|A5
name|a5
operator|)
operator|->
name|R
block|{
return|return
name|this
operator|->
name|Call
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|)
return|;
block|}
block|;   }
endif|#
directive|endif
comment|// GTEST_HAS_STD_FUNCTION_
name|private
operator|:
name|GTEST_DISALLOW_COPY_AND_ASSIGN_
argument_list|(
name|MockFunction
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A0
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|,
name|typename
name|A3
operator|,
name|typename
name|A4
operator|,
name|typename
name|A5
operator|,
name|typename
name|A6
operator|>
name|class
name|MockFunction
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|)
operator|>
block|{
name|public
operator|:
name|MockFunction
argument_list|()
block|{}
name|MOCK_METHOD7_T
argument_list|(
name|Call
argument_list|,
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|)
argument_list|)
block|;
if|#
directive|if
name|GTEST_HAS_STD_FUNCTION_
name|std
operator|::
name|function
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|)
operator|>
name|AsStdFunction
argument_list|()
block|{
return|return
index|[
name|this
index|]
operator|(
name|A0
name|a0
operator|,
name|A1
name|a1
operator|,
name|A2
name|a2
operator|,
name|A3
name|a3
operator|,
name|A4
name|a4
operator|,
name|A5
name|a5
operator|,
name|A6
name|a6
operator|)
operator|->
name|R
block|{
return|return
name|this
operator|->
name|Call
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|)
return|;
block|}
block|;   }
endif|#
directive|endif
comment|// GTEST_HAS_STD_FUNCTION_
name|private
operator|:
name|GTEST_DISALLOW_COPY_AND_ASSIGN_
argument_list|(
name|MockFunction
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A0
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|,
name|typename
name|A3
operator|,
name|typename
name|A4
operator|,
name|typename
name|A5
operator|,
name|typename
name|A6
operator|,
name|typename
name|A7
operator|>
name|class
name|MockFunction
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|)
operator|>
block|{
name|public
operator|:
name|MockFunction
argument_list|()
block|{}
name|MOCK_METHOD8_T
argument_list|(
name|Call
argument_list|,
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|)
argument_list|)
block|;
if|#
directive|if
name|GTEST_HAS_STD_FUNCTION_
name|std
operator|::
name|function
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|)
operator|>
name|AsStdFunction
argument_list|()
block|{
return|return
index|[
name|this
index|]
operator|(
name|A0
name|a0
operator|,
name|A1
name|a1
operator|,
name|A2
name|a2
operator|,
name|A3
name|a3
operator|,
name|A4
name|a4
operator|,
name|A5
name|a5
operator|,
name|A6
name|a6
operator|,
name|A7
name|a7
operator|)
operator|->
name|R
block|{
return|return
name|this
operator|->
name|Call
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|)
return|;
block|}
block|;   }
endif|#
directive|endif
comment|// GTEST_HAS_STD_FUNCTION_
name|private
operator|:
name|GTEST_DISALLOW_COPY_AND_ASSIGN_
argument_list|(
name|MockFunction
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A0
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|,
name|typename
name|A3
operator|,
name|typename
name|A4
operator|,
name|typename
name|A5
operator|,
name|typename
name|A6
operator|,
name|typename
name|A7
operator|,
name|typename
name|A8
operator|>
name|class
name|MockFunction
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|,
name|A8
argument_list|)
operator|>
block|{
name|public
operator|:
name|MockFunction
argument_list|()
block|{}
name|MOCK_METHOD9_T
argument_list|(
name|Call
argument_list|,
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|,
name|A8
argument_list|)
argument_list|)
block|;
if|#
directive|if
name|GTEST_HAS_STD_FUNCTION_
name|std
operator|::
name|function
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|,
name|A8
argument_list|)
operator|>
name|AsStdFunction
argument_list|()
block|{
return|return
index|[
name|this
index|]
operator|(
name|A0
name|a0
operator|,
name|A1
name|a1
operator|,
name|A2
name|a2
operator|,
name|A3
name|a3
operator|,
name|A4
name|a4
operator|,
name|A5
name|a5
operator|,
name|A6
name|a6
operator|,
name|A7
name|a7
operator|,
name|A8
name|a8
operator|)
operator|->
name|R
block|{
return|return
name|this
operator|->
name|Call
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|)
return|;
block|}
block|;   }
endif|#
directive|endif
comment|// GTEST_HAS_STD_FUNCTION_
name|private
operator|:
name|GTEST_DISALLOW_COPY_AND_ASSIGN_
argument_list|(
name|MockFunction
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|R
operator|,
name|typename
name|A0
operator|,
name|typename
name|A1
operator|,
name|typename
name|A2
operator|,
name|typename
name|A3
operator|,
name|typename
name|A4
operator|,
name|typename
name|A5
operator|,
name|typename
name|A6
operator|,
name|typename
name|A7
operator|,
name|typename
name|A8
operator|,
name|typename
name|A9
operator|>
name|class
name|MockFunction
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|,
name|A8
argument_list|,
name|A9
argument_list|)
operator|>
block|{
name|public
operator|:
name|MockFunction
argument_list|()
block|{}
name|MOCK_METHOD10_T
argument_list|(
name|Call
argument_list|,
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|,
name|A8
argument_list|,
name|A9
argument_list|)
argument_list|)
block|;
if|#
directive|if
name|GTEST_HAS_STD_FUNCTION_
name|std
operator|::
name|function
operator|<
name|R
argument_list|(
name|A0
argument_list|,
name|A1
argument_list|,
name|A2
argument_list|,
name|A3
argument_list|,
name|A4
argument_list|,
name|A5
argument_list|,
name|A6
argument_list|,
name|A7
argument_list|,
name|A8
argument_list|,
name|A9
argument_list|)
operator|>
name|AsStdFunction
argument_list|()
block|{
return|return
index|[
name|this
index|]
operator|(
name|A0
name|a0
operator|,
name|A1
name|a1
operator|,
name|A2
name|a2
operator|,
name|A3
name|a3
operator|,
name|A4
name|a4
operator|,
name|A5
name|a5
operator|,
name|A6
name|a6
operator|,
name|A7
name|a7
operator|,
name|A8
name|a8
operator|,
name|A9
name|a9
operator|)
operator|->
name|R
block|{
return|return
name|this
operator|->
name|Call
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|)
return|;
block|}
block|;   }
endif|#
directive|endif
comment|// GTEST_HAS_STD_FUNCTION_
name|private
operator|:
name|GTEST_DISALLOW_COPY_AND_ASSIGN_
argument_list|(
name|MockFunction
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|};  }
comment|// namespace testing
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_FUNCTION_MOCKERS_H_
end_comment

end_unit

