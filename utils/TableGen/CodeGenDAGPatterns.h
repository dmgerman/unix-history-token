begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- CodeGenDAGPatterns.h - Read DAG patterns from .td file ---*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file declares the CodeGenDAGPatterns class, which is used to read and
end_comment

begin_comment
comment|// represent the patterns present in a .td file for instructions.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CODEGEN_DAGPATTERNS_H
end_ifndef

begin_define
define|#
directive|define
name|CODEGEN_DAGPATTERNS_H
end_define

begin_include
include|#
directive|include
file|<set>
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_include
include|#
directive|include
file|"CodeGenTarget.h"
end_include

begin_include
include|#
directive|include
file|"CodeGenIntrinsics.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Record
decl_stmt|;
struct_decl|struct
name|Init
struct_decl|;
name|class
name|ListInit
decl_stmt|;
name|class
name|DagInit
decl_stmt|;
name|class
name|SDNodeInfo
decl_stmt|;
name|class
name|TreePattern
decl_stmt|;
name|class
name|TreePatternNode
decl_stmt|;
name|class
name|CodeGenDAGPatterns
decl_stmt|;
name|class
name|ComplexPattern
decl_stmt|;
comment|/// EMVT::DAGISelGenValueType - These are some extended forms of
comment|/// MVT::SimpleValueType that we use as lattice values during type inference.
name|namespace
name|EMVT
block|{
enum|enum
name|DAGISelGenValueType
block|{
name|isFP
init|=
name|MVT
operator|::
name|LAST_VALUETYPE
block|,
name|isInt
block|,
name|isUnknown
block|}
enum|;
comment|/// isExtIntegerVT - Return true if the specified extended value type vector
comment|/// contains isInt or an integer value type.
name|bool
name|isExtIntegerInVTs
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|unsigned
name|char
operator|>
operator|&
name|EVTs
argument_list|)
decl_stmt|;
comment|/// isExtFloatingPointVT - Return true if the specified extended value type
comment|/// vector contains isFP or a FP value type.
name|bool
name|isExtFloatingPointInVTs
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|unsigned
name|char
operator|>
operator|&
name|EVTs
argument_list|)
decl_stmt|;
block|}
comment|/// Set type used to track multiply used variables in patterns
typedef|typedef
name|std
operator|::
name|set
operator|<
name|std
operator|::
name|string
operator|>
name|MultipleUseVarSet
expr_stmt|;
comment|/// SDTypeConstraint - This is a discriminated union of constraints,
comment|/// corresponding to the SDTypeConstraint tablegen class in Target.td.
struct|struct
name|SDTypeConstraint
block|{
name|SDTypeConstraint
argument_list|(
name|Record
operator|*
name|R
argument_list|)
expr_stmt|;
name|unsigned
name|OperandNo
decl_stmt|;
comment|// The operand # this constraint applies to.
enum|enum
block|{
name|SDTCisVT
block|,
name|SDTCisPtrTy
block|,
name|SDTCisInt
block|,
name|SDTCisFP
block|,
name|SDTCisSameAs
block|,
name|SDTCisVTSmallerThanOp
block|,
name|SDTCisOpSmallerThanOp
block|,
name|SDTCisEltOfVec
block|}
name|ConstraintType
enum|;
union|union
block|{
comment|// The discriminated union.
struct|struct
block|{
name|unsigned
name|char
name|VT
decl_stmt|;
block|}
name|SDTCisVT_Info
struct|;
struct|struct
block|{
name|unsigned
name|OtherOperandNum
decl_stmt|;
block|}
name|SDTCisSameAs_Info
struct|;
struct|struct
block|{
name|unsigned
name|OtherOperandNum
decl_stmt|;
block|}
name|SDTCisVTSmallerThanOp_Info
struct|;
struct|struct
block|{
name|unsigned
name|BigOperandNum
decl_stmt|;
block|}
name|SDTCisOpSmallerThanOp_Info
struct|;
struct|struct
block|{
name|unsigned
name|OtherOperandNum
decl_stmt|;
block|}
name|SDTCisEltOfVec_Info
struct|;
block|}
name|x
union|;
comment|/// ApplyTypeConstraint - Given a node in a pattern, apply this type
comment|/// constraint to the nodes operands.  This returns true if it makes a
comment|/// change, false otherwise.  If a type contradiction is found, throw an
comment|/// exception.
name|bool
name|ApplyTypeConstraint
argument_list|(
name|TreePatternNode
operator|*
name|N
argument_list|,
specifier|const
name|SDNodeInfo
operator|&
name|NodeInfo
argument_list|,
name|TreePattern
operator|&
name|TP
argument_list|)
decl|const
decl_stmt|;
comment|/// getOperandNum - Return the node corresponding to operand #OpNo in tree
comment|/// N, which has NumResults results.
name|TreePatternNode
modifier|*
name|getOperandNum
argument_list|(
name|unsigned
name|OpNo
argument_list|,
name|TreePatternNode
operator|*
name|N
argument_list|,
name|unsigned
name|NumResults
argument_list|)
decl|const
decl_stmt|;
block|}
struct|;
comment|/// SDNodeInfo - One of these records is created for each SDNode instance in
comment|/// the target .td file.  This represents the various dag nodes we will be
comment|/// processing.
name|class
name|SDNodeInfo
block|{
name|Record
modifier|*
name|Def
decl_stmt|;
name|std
operator|::
name|string
name|EnumName
expr_stmt|;
name|std
operator|::
name|string
name|SDClassName
expr_stmt|;
name|unsigned
name|Properties
decl_stmt|;
name|unsigned
name|NumResults
decl_stmt|;
name|int
name|NumOperands
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|SDTypeConstraint
operator|>
name|TypeConstraints
expr_stmt|;
name|public
label|:
name|SDNodeInfo
argument_list|(
name|Record
operator|*
name|R
argument_list|)
expr_stmt|;
comment|// Parse the specified record.
name|unsigned
name|getNumResults
argument_list|()
specifier|const
block|{
return|return
name|NumResults
return|;
block|}
name|int
name|getNumOperands
argument_list|()
specifier|const
block|{
return|return
name|NumOperands
return|;
block|}
name|Record
operator|*
name|getRecord
argument_list|()
specifier|const
block|{
return|return
name|Def
return|;
block|}
specifier|const
name|std
operator|::
name|string
operator|&
name|getEnumName
argument_list|()
specifier|const
block|{
return|return
name|EnumName
return|;
block|}
specifier|const
name|std
operator|::
name|string
operator|&
name|getSDClassName
argument_list|()
specifier|const
block|{
return|return
name|SDClassName
return|;
block|}
specifier|const
name|std
operator|::
name|vector
operator|<
name|SDTypeConstraint
operator|>
operator|&
name|getTypeConstraints
argument_list|()
specifier|const
block|{
return|return
name|TypeConstraints
return|;
block|}
comment|/// hasProperty - Return true if this node has the specified property.
comment|///
name|bool
name|hasProperty
argument_list|(
expr|enum
name|SDNP
name|Prop
argument_list|)
decl|const
block|{
return|return
name|Properties
operator|&
operator|(
literal|1
operator|<<
name|Prop
operator|)
return|;
block|}
comment|/// ApplyTypeConstraints - Given a node in a pattern, apply the type
comment|/// constraints for this node to the operands of the node.  This returns
comment|/// true if it makes a change, false otherwise.  If a type contradiction is
comment|/// found, throw an exception.
name|bool
name|ApplyTypeConstraints
argument_list|(
name|TreePatternNode
operator|*
name|N
argument_list|,
name|TreePattern
operator|&
name|TP
argument_list|)
decl|const
block|{
name|bool
name|MadeChange
init|=
name|false
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|TypeConstraints
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|MadeChange
operator||=
name|TypeConstraints
index|[
name|i
index|]
operator|.
name|ApplyTypeConstraint
argument_list|(
name|N
argument_list|,
operator|*
name|this
argument_list|,
name|TP
argument_list|)
expr_stmt|;
return|return
name|MadeChange
return|;
block|}
block|}
empty_stmt|;
comment|/// FIXME: TreePatternNode's can be shared in some cases (due to dag-shaped
comment|/// patterns), and as such should be ref counted.  We currently just leak all
comment|/// TreePatternNode objects!
name|class
name|TreePatternNode
block|{
comment|/// The inferred type for this node, or EMVT::isUnknown if it hasn't
comment|/// been determined yet. This is a std::vector because during inference
comment|/// there may be multiple possible types.
name|std
operator|::
name|vector
operator|<
name|unsigned
name|char
operator|>
name|Types
expr_stmt|;
comment|/// Operator - The Record for the operator if this is an interior node (not
comment|/// a leaf).
name|Record
modifier|*
name|Operator
decl_stmt|;
comment|/// Val - The init value (e.g. the "GPRC" record, or "7") for a leaf.
comment|///
name|Init
modifier|*
name|Val
decl_stmt|;
comment|/// Name - The name given to this node with the :$foo notation.
comment|///
name|std
operator|::
name|string
name|Name
expr_stmt|;
comment|/// PredicateFns - The predicate functions to execute on this node to check
comment|/// for a match.  If this list is empty, no predicate is involved.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>
name|PredicateFns
expr_stmt|;
comment|/// TransformFn - The transformation function to execute on this node before
comment|/// it can be substituted into the resulting instruction on a pattern match.
name|Record
modifier|*
name|TransformFn
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|TreePatternNode
operator|*
operator|>
name|Children
expr_stmt|;
name|public
label|:
name|TreePatternNode
argument_list|(
name|Record
operator|*
name|Op
argument_list|,
specifier|const
name|std
operator|::
name|vector
operator|<
name|TreePatternNode
operator|*
operator|>
operator|&
name|Ch
argument_list|)
operator|:
name|Types
argument_list|()
operator|,
name|Operator
argument_list|(
name|Op
argument_list|)
operator|,
name|Val
argument_list|(
literal|0
argument_list|)
operator|,
name|TransformFn
argument_list|(
literal|0
argument_list|)
operator|,
name|Children
argument_list|(
argument|Ch
argument_list|)
block|{
name|Types
operator|.
name|push_back
argument_list|(
name|EMVT
operator|::
name|isUnknown
argument_list|)
block|; }
name|TreePatternNode
argument_list|(
name|Init
operator|*
name|val
argument_list|)
comment|// leaf ctor
operator|:
name|Types
argument_list|()
operator|,
name|Operator
argument_list|(
literal|0
argument_list|)
operator|,
name|Val
argument_list|(
name|val
argument_list|)
operator|,
name|TransformFn
argument_list|(
literal|0
argument_list|)
block|{
name|Types
operator|.
name|push_back
argument_list|(
name|EMVT
operator|::
name|isUnknown
argument_list|)
block|;   }
operator|~
name|TreePatternNode
argument_list|()
expr_stmt|;
specifier|const
name|std
operator|::
name|string
operator|&
name|getName
argument_list|()
specifier|const
block|{
return|return
name|Name
return|;
block|}
name|void
name|setName
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|N
argument_list|)
block|{
name|Name
operator|=
name|N
expr_stmt|;
block|}
name|bool
name|isLeaf
argument_list|()
specifier|const
block|{
return|return
name|Val
operator|!=
literal|0
return|;
block|}
name|bool
name|hasTypeSet
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Types
index|[
literal|0
index|]
operator|<
name|MVT
operator|::
name|LAST_VALUETYPE
operator|)
operator|||
operator|(
name|Types
index|[
literal|0
index|]
operator|==
name|MVT
operator|::
name|iPTR
operator|)
operator|||
operator|(
name|Types
index|[
literal|0
index|]
operator|==
name|MVT
operator|::
name|iPTRAny
operator|)
return|;
block|}
name|bool
name|isTypeCompletelyUnknown
argument_list|()
specifier|const
block|{
return|return
name|Types
index|[
literal|0
index|]
operator|==
name|EMVT
operator|::
name|isUnknown
return|;
block|}
name|bool
name|isTypeDynamicallyResolved
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Types
index|[
literal|0
index|]
operator|==
name|MVT
operator|::
name|iPTR
operator|)
operator|||
operator|(
name|Types
index|[
literal|0
index|]
operator|==
name|MVT
operator|::
name|iPTRAny
operator|)
return|;
block|}
name|MVT
operator|::
name|SimpleValueType
name|getTypeNum
argument_list|(
argument|unsigned Num
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|hasTypeSet
argument_list|()
operator|&&
literal|"Doesn't have a type yet!"
argument_list|)
block|;
name|assert
argument_list|(
name|Types
operator|.
name|size
argument_list|()
operator|>
name|Num
operator|&&
literal|"Type num out of range!"
argument_list|)
block|;
return|return
operator|(
name|MVT
operator|::
name|SimpleValueType
operator|)
name|Types
index|[
name|Num
index|]
return|;
block|}
name|unsigned
name|char
name|getExtTypeNum
argument_list|(
name|unsigned
name|Num
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Types
operator|.
name|size
argument_list|()
operator|>
name|Num
operator|&&
literal|"Extended type num out of range!"
argument_list|)
expr_stmt|;
return|return
name|Types
index|[
name|Num
index|]
return|;
block|}
specifier|const
name|std
operator|::
name|vector
operator|<
name|unsigned
name|char
operator|>
operator|&
name|getExtTypes
argument_list|()
specifier|const
block|{
return|return
name|Types
return|;
block|}
name|void
name|setTypes
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|unsigned
name|char
operator|>
operator|&
name|T
argument_list|)
block|{
name|Types
operator|=
name|T
expr_stmt|;
block|}
name|void
name|removeTypes
parameter_list|()
block|{
name|Types
operator|=
name|std
operator|::
name|vector
operator|<
name|unsigned
name|char
operator|>
operator|(
literal|1
operator|,
name|EMVT
operator|::
name|isUnknown
operator|)
expr_stmt|;
block|}
name|Init
operator|*
name|getLeafValue
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isLeaf
argument_list|()
argument_list|)
block|;
return|return
name|Val
return|;
block|}
name|Record
operator|*
name|getOperator
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
operator|!
name|isLeaf
argument_list|()
argument_list|)
block|;
return|return
name|Operator
return|;
block|}
name|unsigned
name|getNumChildren
argument_list|()
specifier|const
block|{
return|return
name|Children
operator|.
name|size
argument_list|()
return|;
block|}
name|TreePatternNode
modifier|*
name|getChild
argument_list|(
name|unsigned
name|N
argument_list|)
decl|const
block|{
return|return
name|Children
index|[
name|N
index|]
return|;
block|}
name|void
name|setChild
parameter_list|(
name|unsigned
name|i
parameter_list|,
name|TreePatternNode
modifier|*
name|N
parameter_list|)
block|{
name|Children
index|[
name|i
index|]
operator|=
name|N
expr_stmt|;
block|}
specifier|const
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>
operator|&
name|getPredicateFns
argument_list|()
specifier|const
block|{
return|return
name|PredicateFns
return|;
block|}
name|void
name|clearPredicateFns
parameter_list|()
block|{
name|PredicateFns
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|void
name|setPredicateFns
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>
operator|&
name|Fns
argument_list|)
block|{
name|assert
argument_list|(
name|PredicateFns
operator|.
name|empty
argument_list|()
operator|&&
literal|"Overwriting non-empty predicate list!"
argument_list|)
expr_stmt|;
name|PredicateFns
operator|=
name|Fns
expr_stmt|;
block|}
name|void
name|addPredicateFn
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Fn
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Fn
operator|.
name|empty
argument_list|()
operator|&&
literal|"Empty predicate string!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
operator|::
name|find
argument_list|(
name|PredicateFns
operator|.
name|begin
argument_list|()
argument_list|,
name|PredicateFns
operator|.
name|end
argument_list|()
argument_list|,
name|Fn
argument_list|)
operator|==
name|PredicateFns
operator|.
name|end
argument_list|()
condition|)
name|PredicateFns
operator|.
name|push_back
argument_list|(
name|Fn
argument_list|)
expr_stmt|;
block|}
name|Record
operator|*
name|getTransformFn
argument_list|()
specifier|const
block|{
return|return
name|TransformFn
return|;
block|}
name|void
name|setTransformFn
parameter_list|(
name|Record
modifier|*
name|Fn
parameter_list|)
block|{
name|TransformFn
operator|=
name|Fn
expr_stmt|;
block|}
comment|/// getIntrinsicInfo - If this node corresponds to an intrinsic, return the
comment|/// CodeGenIntrinsic information for it, otherwise return a null pointer.
specifier|const
name|CodeGenIntrinsic
modifier|*
name|getIntrinsicInfo
argument_list|(
specifier|const
name|CodeGenDAGPatterns
operator|&
name|CDP
argument_list|)
decl|const
decl_stmt|;
comment|/// isCommutativeIntrinsic - Return true if the node is an intrinsic which is
comment|/// marked isCommutative.
name|bool
name|isCommutativeIntrinsic
argument_list|(
specifier|const
name|CodeGenDAGPatterns
operator|&
name|CDP
argument_list|)
decl|const
decl_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|public
label|:
comment|// Higher level manipulation routines.
comment|/// clone - Return a new copy of this tree.
comment|///
name|TreePatternNode
operator|*
name|clone
argument_list|()
specifier|const
expr_stmt|;
comment|/// isIsomorphicTo - Return true if this node is recursively isomorphic to
comment|/// the specified node.  For this comparison, all of the state of the node
comment|/// is considered, except for the assigned name.  Nodes with differing names
comment|/// that are otherwise identical are considered isomorphic.
name|bool
name|isIsomorphicTo
argument_list|(
specifier|const
name|TreePatternNode
operator|*
name|N
argument_list|,
specifier|const
name|MultipleUseVarSet
operator|&
name|DepVars
argument_list|)
decl|const
decl_stmt|;
comment|/// SubstituteFormalArguments - Replace the formal arguments in this tree
comment|/// with actual values specified by ArgMap.
name|void
name|SubstituteFormalArguments
argument_list|(
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
argument_list|,
name|TreePatternNode
operator|*
operator|>
operator|&
name|ArgMap
argument_list|)
decl_stmt|;
comment|/// InlinePatternFragments - If this pattern refers to any pattern
comment|/// fragments, inline them into place, giving us a pattern without any
comment|/// PatFrag references.
name|TreePatternNode
modifier|*
name|InlinePatternFragments
parameter_list|(
name|TreePattern
modifier|&
name|TP
parameter_list|)
function_decl|;
comment|/// ApplyTypeConstraints - Apply all of the type constraints relevant to
comment|/// this node and its children in the tree.  This returns true if it makes a
comment|/// change, false otherwise.  If a type contradiction is found, throw an
comment|/// exception.
name|bool
name|ApplyTypeConstraints
parameter_list|(
name|TreePattern
modifier|&
name|TP
parameter_list|,
name|bool
name|NotRegisters
parameter_list|)
function_decl|;
comment|/// UpdateNodeType - Set the node type of N to VT if VT contains
comment|/// information.  If N already contains a conflicting type, then throw an
comment|/// exception.  This returns true if any information was updated.
comment|///
name|bool
name|UpdateNodeType
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|unsigned
name|char
operator|>
operator|&
name|ExtVTs
argument_list|,
name|TreePattern
operator|&
name|TP
argument_list|)
decl_stmt|;
name|bool
name|UpdateNodeType
parameter_list|(
name|unsigned
name|char
name|ExtVT
parameter_list|,
name|TreePattern
modifier|&
name|TP
parameter_list|)
block|{
name|std
operator|::
name|vector
operator|<
name|unsigned
name|char
operator|>
name|ExtVTs
argument_list|(
literal|1
argument_list|,
name|ExtVT
argument_list|)
expr_stmt|;
return|return
name|UpdateNodeType
argument_list|(
name|ExtVTs
argument_list|,
name|TP
argument_list|)
return|;
block|}
comment|/// ContainsUnresolvedType - Return true if this tree contains any
comment|/// unresolved types.
name|bool
name|ContainsUnresolvedType
argument_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|hasTypeSet
argument_list|()
operator|&&
operator|!
name|isTypeDynamicallyResolved
argument_list|()
condition|)
return|return
name|true
return|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|getNumChildren
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|getChild
argument_list|(
name|i
argument_list|)
operator|->
name|ContainsUnresolvedType
argument_list|()
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
comment|/// canPatternMatch - If it is impossible for this pattern to match on this
comment|/// target, fill in Reason and return false.  Otherwise, return true.
name|bool
name|canPatternMatch
argument_list|(
name|std
operator|::
name|string
operator|&
name|Reason
argument_list|,
specifier|const
name|CodeGenDAGPatterns
operator|&
name|CDP
argument_list|)
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// TreePattern - Represent a pattern, used for instructions, pattern
end_comment

begin_comment
comment|/// fragments, etc.
end_comment

begin_comment
comment|///
end_comment

begin_decl_stmt
name|class
name|TreePattern
block|{
comment|/// Trees - The list of pattern trees which corresponds to this pattern.
comment|/// Note that PatFrag's only have a single tree.
comment|///
name|std
operator|::
name|vector
operator|<
name|TreePatternNode
operator|*
operator|>
name|Trees
expr_stmt|;
comment|/// TheRecord - The actual TableGen record corresponding to this pattern.
comment|///
name|Record
modifier|*
name|TheRecord
decl_stmt|;
comment|/// Args - This is a list of all of the arguments to this pattern (for
comment|/// PatFrag patterns), which are the 'node' markers in this pattern.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>
name|Args
expr_stmt|;
comment|/// CDP - the top-level object coordinating this madness.
comment|///
name|CodeGenDAGPatterns
modifier|&
name|CDP
decl_stmt|;
comment|/// isInputPattern - True if this is an input pattern, something to match.
comment|/// False if this is an output pattern, something to emit.
name|bool
name|isInputPattern
decl_stmt|;
name|public
label|:
comment|/// TreePattern constructor - Parse the specified DagInits into the
comment|/// current record.
name|TreePattern
argument_list|(
argument|Record *TheRec
argument_list|,
argument|ListInit *RawPat
argument_list|,
argument|bool isInput
argument_list|,
argument|CodeGenDAGPatterns&ise
argument_list|)
empty_stmt|;
name|TreePattern
argument_list|(
argument|Record *TheRec
argument_list|,
argument|DagInit *Pat
argument_list|,
argument|bool isInput
argument_list|,
argument|CodeGenDAGPatterns&ise
argument_list|)
empty_stmt|;
name|TreePattern
argument_list|(
argument|Record *TheRec
argument_list|,
argument|TreePatternNode *Pat
argument_list|,
argument|bool isInput
argument_list|,
argument|CodeGenDAGPatterns&ise
argument_list|)
empty_stmt|;
comment|/// getTrees - Return the tree patterns which corresponds to this pattern.
comment|///
specifier|const
name|std
operator|::
name|vector
operator|<
name|TreePatternNode
operator|*
operator|>
operator|&
name|getTrees
argument_list|()
specifier|const
block|{
return|return
name|Trees
return|;
block|}
name|unsigned
name|getNumTrees
argument_list|()
specifier|const
block|{
return|return
name|Trees
operator|.
name|size
argument_list|()
return|;
block|}
name|TreePatternNode
modifier|*
name|getTree
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
return|return
name|Trees
index|[
name|i
index|]
return|;
block|}
name|TreePatternNode
operator|*
name|getOnlyTree
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|Trees
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
literal|"Doesn't have exactly one pattern!"
argument_list|)
block|;
return|return
name|Trees
index|[
literal|0
index|]
return|;
block|}
comment|/// getRecord - Return the actual TableGen record corresponding to this
comment|/// pattern.
comment|///
name|Record
operator|*
name|getRecord
argument_list|()
specifier|const
block|{
return|return
name|TheRecord
return|;
block|}
name|unsigned
name|getNumArgs
argument_list|()
specifier|const
block|{
return|return
name|Args
operator|.
name|size
argument_list|()
return|;
block|}
specifier|const
name|std
operator|::
name|string
operator|&
name|getArgName
argument_list|(
argument|unsigned i
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|Args
operator|.
name|size
argument_list|()
operator|&&
literal|"Argument reference out of range!"
argument_list|)
block|;
return|return
name|Args
index|[
name|i
index|]
return|;
block|}
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|string
operator|>
operator|&
name|getArgList
argument_list|()
block|{
return|return
name|Args
return|;
block|}
name|CodeGenDAGPatterns
operator|&
name|getDAGPatterns
argument_list|()
specifier|const
block|{
return|return
name|CDP
return|;
block|}
comment|/// InlinePatternFragments - If this pattern refers to any pattern
comment|/// fragments, inline them into place, giving us a pattern without any
comment|/// PatFrag references.
name|void
name|InlinePatternFragments
parameter_list|()
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Trees
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|Trees
index|[
name|i
index|]
operator|=
name|Trees
index|[
name|i
index|]
operator|->
name|InlinePatternFragments
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
comment|/// InferAllTypes - Infer/propagate as many types throughout the expression
comment|/// patterns as possible.  Return true if all types are inferred, false
comment|/// otherwise.  Throw an exception if a type contradiction is found.
name|bool
name|InferAllTypes
parameter_list|()
function_decl|;
comment|/// error - Throw an exception, prefixing it with information about this
comment|/// pattern.
name|void
name|error
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Msg
argument_list|)
decl|const
decl_stmt|;
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|)
decl|const
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
name|private
label|:
name|TreePatternNode
modifier|*
name|ParseTreePattern
parameter_list|(
name|DagInit
modifier|*
name|DI
parameter_list|)
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// DAGDefaultOperand - One of these is created for each PredicateOperand
end_comment

begin_comment
comment|/// or OptionalDefOperand that has a set ExecuteAlways / DefaultOps field.
end_comment

begin_struct
struct|struct
name|DAGDefaultOperand
block|{
name|std
operator|::
name|vector
operator|<
name|TreePatternNode
operator|*
operator|>
name|DefaultOps
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|class
name|DAGInstruction
block|{
name|TreePattern
modifier|*
name|Pattern
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|Results
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|Operands
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|ImpResults
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|ImpOperands
expr_stmt|;
name|TreePatternNode
modifier|*
name|ResultPattern
decl_stmt|;
name|public
label|:
name|DAGInstruction
argument_list|(
name|TreePattern
operator|*
name|TP
argument_list|,
specifier|const
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|&
name|results
argument_list|,
specifier|const
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|&
name|operands
argument_list|,
specifier|const
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|&
name|impresults
argument_list|,
specifier|const
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|&
name|impoperands
argument_list|)
operator|:
name|Pattern
argument_list|(
name|TP
argument_list|)
operator|,
name|Results
argument_list|(
name|results
argument_list|)
operator|,
name|Operands
argument_list|(
name|operands
argument_list|)
operator|,
name|ImpResults
argument_list|(
name|impresults
argument_list|)
operator|,
name|ImpOperands
argument_list|(
name|impoperands
argument_list|)
operator|,
name|ResultPattern
argument_list|(
literal|0
argument_list|)
block|{}
specifier|const
name|TreePattern
operator|*
name|getPattern
argument_list|()
specifier|const
block|{
return|return
name|Pattern
return|;
block|}
name|unsigned
name|getNumResults
argument_list|()
specifier|const
block|{
return|return
name|Results
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
block|{
return|return
name|Operands
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|getNumImpResults
argument_list|()
specifier|const
block|{
return|return
name|ImpResults
operator|.
name|size
argument_list|()
return|;
block|}
name|unsigned
name|getNumImpOperands
argument_list|()
specifier|const
block|{
return|return
name|ImpOperands
operator|.
name|size
argument_list|()
return|;
block|}
specifier|const
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|&
name|getImpResults
argument_list|()
specifier|const
block|{
return|return
name|ImpResults
return|;
block|}
name|void
name|setResultPattern
parameter_list|(
name|TreePatternNode
modifier|*
name|R
parameter_list|)
block|{
name|ResultPattern
operator|=
name|R
expr_stmt|;
block|}
name|Record
modifier|*
name|getResult
argument_list|(
name|unsigned
name|RN
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|RN
operator|<
name|Results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Results
index|[
name|RN
index|]
return|;
block|}
name|Record
modifier|*
name|getOperand
argument_list|(
name|unsigned
name|ON
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|ON
operator|<
name|Operands
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Operands
index|[
name|ON
index|]
return|;
block|}
name|Record
modifier|*
name|getImpResult
argument_list|(
name|unsigned
name|RN
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|RN
operator|<
name|ImpResults
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ImpResults
index|[
name|RN
index|]
return|;
block|}
name|Record
modifier|*
name|getImpOperand
argument_list|(
name|unsigned
name|ON
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|ON
operator|<
name|ImpOperands
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ImpOperands
index|[
name|ON
index|]
return|;
block|}
name|TreePatternNode
operator|*
name|getResultPattern
argument_list|()
specifier|const
block|{
return|return
name|ResultPattern
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// PatternToMatch - Used by CodeGenDAGPatterns to keep tab of patterns
end_comment

begin_comment
comment|/// processed to produce isel.
end_comment

begin_struct
struct|struct
name|PatternToMatch
block|{
name|PatternToMatch
argument_list|(
argument|ListInit *preds
argument_list|,
argument|TreePatternNode *src
argument_list|,
argument|TreePatternNode *dst
argument_list|,
argument|const std::vector<Record*>&dstregs
argument_list|,
argument|unsigned complexity
argument_list|)
block|:
name|Predicates
argument_list|(
name|preds
argument_list|)
operator|,
name|SrcPattern
argument_list|(
name|src
argument_list|)
operator|,
name|DstPattern
argument_list|(
name|dst
argument_list|)
operator|,
name|Dstregs
argument_list|(
name|dstregs
argument_list|)
operator|,
name|AddedComplexity
argument_list|(
argument|complexity
argument_list|)
block|{}
expr_stmt|;
name|ListInit
modifier|*
name|Predicates
decl_stmt|;
comment|// Top level predicate conditions to match.
name|TreePatternNode
modifier|*
name|SrcPattern
decl_stmt|;
comment|// Source pattern to match.
name|TreePatternNode
modifier|*
name|DstPattern
decl_stmt|;
comment|// Resulting pattern.
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|Dstregs
expr_stmt|;
comment|// Physical register defs being matched.
name|unsigned
name|AddedComplexity
decl_stmt|;
comment|// Add to matching pattern complexity.
name|ListInit
operator|*
name|getPredicates
argument_list|()
specifier|const
block|{
return|return
name|Predicates
return|;
block|}
name|TreePatternNode
operator|*
name|getSrcPattern
argument_list|()
specifier|const
block|{
return|return
name|SrcPattern
return|;
block|}
name|TreePatternNode
operator|*
name|getDstPattern
argument_list|()
specifier|const
block|{
return|return
name|DstPattern
return|;
block|}
specifier|const
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|&
name|getDstRegs
argument_list|()
specifier|const
block|{
return|return
name|Dstregs
return|;
block|}
name|unsigned
name|getAddedComplexity
argument_list|()
specifier|const
block|{
return|return
name|AddedComplexity
return|;
block|}
name|std
operator|::
name|string
name|getPredicateCheck
argument_list|()
specifier|const
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|class
name|CodeGenDAGPatterns
block|{
name|RecordKeeper
modifier|&
name|Records
decl_stmt|;
name|CodeGenTarget
name|Target
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|CodeGenIntrinsic
operator|>
name|Intrinsics
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|CodeGenIntrinsic
operator|>
name|TgtIntrinsics
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|Record
operator|*
operator|,
name|SDNodeInfo
operator|>
name|SDNodes
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|Record
operator|*
operator|,
name|std
operator|::
name|pair
operator|<
name|Record
operator|*
operator|,
name|std
operator|::
name|string
operator|>
expr|>
name|SDNodeXForms
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|Record
operator|*
operator|,
name|ComplexPattern
operator|>
name|ComplexPatterns
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|Record
operator|*
operator|,
name|TreePattern
operator|*
operator|>
name|PatternFragments
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|Record
operator|*
operator|,
name|DAGDefaultOperand
operator|>
name|DefaultOperands
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|Record
operator|*
operator|,
name|DAGInstruction
operator|>
name|Instructions
expr_stmt|;
comment|// Specific SDNode definitions:
name|Record
modifier|*
name|intrinsic_void_sdnode
decl_stmt|;
name|Record
modifier|*
name|intrinsic_w_chain_sdnode
decl_stmt|,
modifier|*
name|intrinsic_wo_chain_sdnode
decl_stmt|;
comment|/// PatternsToMatch - All of the things we are matching on the DAG.  The first
comment|/// value is the pattern to match, the second pattern is the result to
comment|/// emit.
name|std
operator|::
name|vector
operator|<
name|PatternToMatch
operator|>
name|PatternsToMatch
expr_stmt|;
name|public
label|:
name|CodeGenDAGPatterns
argument_list|(
name|RecordKeeper
operator|&
name|R
argument_list|)
expr_stmt|;
operator|~
name|CodeGenDAGPatterns
argument_list|()
expr_stmt|;
name|CodeGenTarget
modifier|&
name|getTargetInfo
parameter_list|()
block|{
return|return
name|Target
return|;
block|}
specifier|const
name|CodeGenTarget
operator|&
name|getTargetInfo
argument_list|()
specifier|const
block|{
return|return
name|Target
return|;
block|}
name|Record
modifier|*
name|getSDNodeNamed
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|)
decl|const
decl_stmt|;
specifier|const
name|SDNodeInfo
modifier|&
name|getSDNodeInfo
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|SDNodes
operator|.
name|count
argument_list|(
name|R
argument_list|)
operator|&&
literal|"Unknown node!"
argument_list|)
expr_stmt|;
return|return
name|SDNodes
operator|.
name|find
argument_list|(
name|R
argument_list|)
operator|->
name|second
return|;
block|}
comment|// Node transformation lookups.
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|Record
operator|*
operator|,
name|std
operator|::
name|string
operator|>
name|NodeXForm
expr_stmt|;
specifier|const
name|NodeXForm
modifier|&
name|getSDNodeTransform
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|SDNodeXForms
operator|.
name|count
argument_list|(
name|R
argument_list|)
operator|&&
literal|"Invalid transform!"
argument_list|)
expr_stmt|;
return|return
name|SDNodeXForms
operator|.
name|find
argument_list|(
name|R
argument_list|)
operator|->
name|second
return|;
block|}
typedef|typedef
name|std
operator|::
name|map
operator|<
name|Record
operator|*
operator|,
name|NodeXForm
operator|>
operator|::
name|const_iterator
name|nx_iterator
expr_stmt|;
name|nx_iterator
name|nx_begin
argument_list|()
specifier|const
block|{
return|return
name|SDNodeXForms
operator|.
name|begin
argument_list|()
return|;
block|}
name|nx_iterator
name|nx_end
argument_list|()
specifier|const
block|{
return|return
name|SDNodeXForms
operator|.
name|end
argument_list|()
return|;
block|}
specifier|const
name|ComplexPattern
modifier|&
name|getComplexPattern
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|ComplexPatterns
operator|.
name|count
argument_list|(
name|R
argument_list|)
operator|&&
literal|"Unknown addressing mode!"
argument_list|)
expr_stmt|;
return|return
name|ComplexPatterns
operator|.
name|find
argument_list|(
name|R
argument_list|)
operator|->
name|second
return|;
block|}
specifier|const
name|CodeGenIntrinsic
modifier|&
name|getIntrinsic
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Intrinsics
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Intrinsics
index|[
name|i
index|]
operator|.
name|TheDef
operator|==
name|R
condition|)
return|return
name|Intrinsics
index|[
name|i
index|]
return|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|TgtIntrinsics
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|TgtIntrinsics
index|[
name|i
index|]
operator|.
name|TheDef
operator|==
name|R
condition|)
return|return
name|TgtIntrinsics
index|[
name|i
index|]
return|;
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unknown intrinsic!"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
specifier|const
name|CodeGenIntrinsic
modifier|&
name|getIntrinsicInfo
argument_list|(
name|unsigned
name|IID
argument_list|)
decl|const
block|{
if|if
condition|(
name|IID
operator|-
literal|1
operator|<
name|Intrinsics
operator|.
name|size
argument_list|()
condition|)
return|return
name|Intrinsics
index|[
name|IID
operator|-
literal|1
index|]
return|;
if|if
condition|(
name|IID
operator|-
name|Intrinsics
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|<
name|TgtIntrinsics
operator|.
name|size
argument_list|()
condition|)
return|return
name|TgtIntrinsics
index|[
name|IID
operator|-
name|Intrinsics
operator|.
name|size
argument_list|()
operator|-
literal|1
index|]
return|;
name|assert
argument_list|(
literal|0
operator|&&
literal|"Bad intrinsic ID!"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|unsigned
name|getIntrinsicID
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Intrinsics
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Intrinsics
index|[
name|i
index|]
operator|.
name|TheDef
operator|==
name|R
condition|)
return|return
name|i
return|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|TgtIntrinsics
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|TgtIntrinsics
index|[
name|i
index|]
operator|.
name|TheDef
operator|==
name|R
condition|)
return|return
name|i
operator|+
name|Intrinsics
operator|.
name|size
argument_list|()
return|;
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unknown intrinsic!"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
specifier|const
name|DAGDefaultOperand
modifier|&
name|getDefaultOperand
parameter_list|(
name|Record
modifier|*
name|R
parameter_list|)
block|{
name|assert
argument_list|(
name|DefaultOperands
operator|.
name|count
argument_list|(
name|R
argument_list|)
operator|&&
literal|"Isn't an analyzed default operand!"
argument_list|)
expr_stmt|;
return|return
name|DefaultOperands
operator|.
name|find
argument_list|(
name|R
argument_list|)
operator|->
name|second
return|;
block|}
comment|// Pattern Fragment information.
name|TreePattern
modifier|*
name|getPatternFragment
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|PatternFragments
operator|.
name|count
argument_list|(
name|R
argument_list|)
operator|&&
literal|"Invalid pattern fragment request!"
argument_list|)
expr_stmt|;
return|return
name|PatternFragments
operator|.
name|find
argument_list|(
name|R
argument_list|)
operator|->
name|second
return|;
block|}
typedef|typedef
name|std
operator|::
name|map
operator|<
name|Record
operator|*
operator|,
name|TreePattern
operator|*
operator|>
operator|::
name|const_iterator
name|pf_iterator
expr_stmt|;
name|pf_iterator
name|pf_begin
argument_list|()
specifier|const
block|{
return|return
name|PatternFragments
operator|.
name|begin
argument_list|()
return|;
block|}
name|pf_iterator
name|pf_end
argument_list|()
specifier|const
block|{
return|return
name|PatternFragments
operator|.
name|end
argument_list|()
return|;
block|}
comment|// Patterns to match information.
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|PatternToMatch
operator|>
operator|::
name|const_iterator
name|ptm_iterator
expr_stmt|;
name|ptm_iterator
name|ptm_begin
argument_list|()
specifier|const
block|{
return|return
name|PatternsToMatch
operator|.
name|begin
argument_list|()
return|;
block|}
name|ptm_iterator
name|ptm_end
argument_list|()
specifier|const
block|{
return|return
name|PatternsToMatch
operator|.
name|end
argument_list|()
return|;
block|}
specifier|const
name|DAGInstruction
modifier|&
name|getInstruction
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Instructions
operator|.
name|count
argument_list|(
name|R
argument_list|)
operator|&&
literal|"Unknown instruction!"
argument_list|)
expr_stmt|;
return|return
name|Instructions
operator|.
name|find
argument_list|(
name|R
argument_list|)
operator|->
name|second
return|;
block|}
name|Record
operator|*
name|get_intrinsic_void_sdnode
argument_list|()
specifier|const
block|{
return|return
name|intrinsic_void_sdnode
return|;
block|}
name|Record
operator|*
name|get_intrinsic_w_chain_sdnode
argument_list|()
specifier|const
block|{
return|return
name|intrinsic_w_chain_sdnode
return|;
block|}
name|Record
operator|*
name|get_intrinsic_wo_chain_sdnode
argument_list|()
specifier|const
block|{
return|return
name|intrinsic_wo_chain_sdnode
return|;
block|}
name|private
label|:
name|void
name|ParseNodeInfo
parameter_list|()
function_decl|;
name|void
name|ParseNodeTransforms
parameter_list|()
function_decl|;
name|void
name|ParseComplexPatterns
parameter_list|()
function_decl|;
name|void
name|ParsePatternFragments
parameter_list|()
function_decl|;
name|void
name|ParseDefaultOperands
parameter_list|()
function_decl|;
name|void
name|ParseInstructions
parameter_list|()
function_decl|;
name|void
name|ParsePatterns
parameter_list|()
function_decl|;
name|void
name|InferInstructionFlags
parameter_list|()
function_decl|;
name|void
name|GenerateVariants
parameter_list|()
function_decl|;
name|void
name|FindPatternInputsAndOutputs
argument_list|(
name|TreePattern
operator|*
name|I
argument_list|,
name|TreePatternNode
operator|*
name|Pat
argument_list|,
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
argument_list|,
name|TreePatternNode
operator|*
operator|>
operator|&
name|InstInputs
argument_list|,
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
argument_list|,
name|TreePatternNode
operator|*
operator|>
operator|&
name|InstResults
argument_list|,
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|&
name|InstImpInputs
argument_list|,
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|&
name|InstImpResults
argument_list|)
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

