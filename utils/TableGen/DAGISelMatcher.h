begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- DAGISelMatcher.h - Representation of DAG pattern matcher -----------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TBLGEN_DAGISELMATCHER_H
end_ifndef

begin_define
define|#
directive|define
name|TBLGEN_DAGISELMATCHER_H
end_define

begin_include
include|#
directive|include
file|"llvm/CodeGen/ValueTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/OwningPtr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Casting.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|CodeGenDAGPatterns
decl_stmt|;
name|class
name|MatcherNode
decl_stmt|;
name|class
name|PatternToMatch
decl_stmt|;
name|class
name|raw_ostream
decl_stmt|;
name|class
name|ComplexPattern
decl_stmt|;
name|MatcherNode
modifier|*
name|ConvertPatternToMatcher
parameter_list|(
specifier|const
name|PatternToMatch
modifier|&
name|Pattern
parameter_list|,
specifier|const
name|CodeGenDAGPatterns
modifier|&
name|CGP
parameter_list|)
function_decl|;
name|void
name|EmitMatcherTable
parameter_list|(
specifier|const
name|MatcherNode
modifier|*
name|Matcher
parameter_list|,
name|raw_ostream
modifier|&
name|OS
parameter_list|)
function_decl|;
comment|/// MatcherNode - Base class for all the the DAG ISel Matcher representation
comment|/// nodes.
name|class
name|MatcherNode
block|{
name|public
label|:
enum|enum
name|KindTy
block|{
name|EmitNode
block|,
name|Push
block|,
comment|// [Push, Dest0, Dest1, Dest2, Dest3]
name|Record
block|,
comment|// [Record]
name|MoveChild
block|,
comment|// [MoveChild, Child#]
name|MoveParent
block|,
comment|// [MoveParent]
name|CheckSame
block|,
comment|// [CheckSame, N]         Fail if not same as prev match.
name|CheckPatternPredicate
block|,
name|CheckPredicate
block|,
comment|// [CheckPredicate, P]    Fail if predicate fails.
name|CheckOpcode
block|,
comment|// [CheckOpcode, Opcode]  Fail if not opcode.
name|CheckType
block|,
comment|// [CheckType, MVT]       Fail if not correct type.
name|CheckInteger
block|,
comment|// [CheckInteger, int0,int1,int2,...int7] Fail if wrong val.
name|CheckCondCode
block|,
comment|// [CheckCondCode, CondCode] Fail if not condcode.
name|CheckValueType
block|,
name|CheckComplexPat
block|,
name|CheckAndImm
block|,
name|CheckOrImm
block|,
name|CheckProfitableToFold
block|,
name|CheckLegalToFold
block|}
enum|;
specifier|const
name|KindTy
name|Kind
decl_stmt|;
name|protected
label|:
name|MatcherNode
argument_list|(
argument|KindTy K
argument_list|)
block|:
name|Kind
argument_list|(
argument|K
argument_list|)
block|{}
name|public
label|:
name|virtual
operator|~
name|MatcherNode
argument_list|()
block|{}
name|KindTy
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|Kind
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
parameter_list|(
specifier|const
name|MatcherNode
modifier|*
parameter_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
name|raw_ostream
operator|&
name|OS
argument_list|,
name|unsigned
name|indent
operator|=
literal|0
argument_list|)
decl|const
init|=
literal|0
decl_stmt|;
name|void
name|dump
argument_list|()
specifier|const
expr_stmt|;
block|}
empty_stmt|;
comment|/// EmitNodeMatcherNode - This signals a successful match and generates a node.
name|class
name|EmitNodeMatcherNode
range|:
name|public
name|MatcherNode
block|{
specifier|const
name|PatternToMatch
operator|&
name|Pattern
block|;
name|public
operator|:
name|EmitNodeMatcherNode
argument_list|(
specifier|const
name|PatternToMatch
operator|&
name|pattern
argument_list|)
operator|:
name|MatcherNode
argument_list|(
name|EmitNode
argument_list|)
block|,
name|Pattern
argument_list|(
argument|pattern
argument_list|)
block|{}
specifier|const
name|PatternToMatch
operator|&
name|getPattern
argument_list|()
specifier|const
block|{
return|return
name|Pattern
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|EmitNode
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// MatcherNodeWithChild - Every node accept the final accept state has a child
comment|/// that is executed after the node runs.  This class captures this commonality.
name|class
name|MatcherNodeWithChild
range|:
name|public
name|MatcherNode
block|{
name|OwningPtr
operator|<
name|MatcherNode
operator|>
name|Child
block|;
name|public
operator|:
name|MatcherNodeWithChild
argument_list|(
argument|KindTy K
argument_list|)
operator|:
name|MatcherNode
argument_list|(
argument|K
argument_list|)
block|{}
name|MatcherNode
operator|*
name|getChild
argument_list|()
block|{
return|return
name|Child
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|MatcherNode
operator|*
name|getChild
argument_list|()
specifier|const
block|{
return|return
name|Child
operator|.
name|get
argument_list|()
return|;
block|}
name|void
name|setChild
argument_list|(
argument|MatcherNode *C
argument_list|)
block|{
name|Child
operator|.
name|reset
argument_list|(
name|C
argument_list|)
block|; }
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|!=
name|EmitNode
return|;
block|}
name|protected
operator|:
name|void
name|printChild
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// PushMatcherNode - This pushes a failure scope on the stack and evaluates
comment|/// 'child'.  If 'child' fails to match, it pops its scope and attempts to
comment|/// match 'Failure'.
name|class
name|PushMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
name|OwningPtr
operator|<
name|MatcherNode
operator|>
name|Failure
block|;
name|public
operator|:
name|PushMatcherNode
argument_list|(
name|MatcherNode
operator|*
name|child
operator|=
literal|0
argument_list|,
name|MatcherNode
operator|*
name|failure
operator|=
literal|0
argument_list|)
operator|:
name|MatcherNodeWithChild
argument_list|(
name|Push
argument_list|)
block|,
name|Failure
argument_list|(
argument|failure
argument_list|)
block|{
name|setChild
argument_list|(
name|child
argument_list|)
block|;   }
name|MatcherNode
operator|*
name|getFailure
argument_list|()
block|{
return|return
name|Failure
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|MatcherNode
operator|*
name|getFailure
argument_list|()
specifier|const
block|{
return|return
name|Failure
operator|.
name|get
argument_list|()
return|;
block|}
name|void
name|setFailure
argument_list|(
argument|MatcherNode *N
argument_list|)
block|{
name|Failure
operator|.
name|reset
argument_list|(
name|N
argument_list|)
block|; }
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|Push
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// RecordMatcherNode - Save the current node in the operand list.
name|class
name|RecordMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
name|public
operator|:
name|RecordMatcherNode
argument_list|()
operator|:
name|MatcherNodeWithChild
argument_list|(
argument|Record
argument_list|)
block|{}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|Record
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// MoveChildMatcherNode - This tells the interpreter to move into the
comment|/// specified child node.
name|class
name|MoveChildMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
name|unsigned
name|ChildNo
block|;
name|public
operator|:
name|MoveChildMatcherNode
argument_list|(
argument|unsigned childNo
argument_list|)
operator|:
name|MatcherNodeWithChild
argument_list|(
name|MoveChild
argument_list|)
block|,
name|ChildNo
argument_list|(
argument|childNo
argument_list|)
block|{}
name|unsigned
name|getChildNo
argument_list|()
specifier|const
block|{
return|return
name|ChildNo
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|MoveChild
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// MoveParentMatcherNode - This tells the interpreter to move to the parent
comment|/// of the current node.
name|class
name|MoveParentMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
name|public
operator|:
name|MoveParentMatcherNode
argument_list|()
operator|:
name|MatcherNodeWithChild
argument_list|(
argument|MoveParent
argument_list|)
block|{}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|MoveParent
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// CheckSameMatcherNode - This checks to see if this node is exactly the same
comment|/// node as the specified match that was recorded with 'Record'.  This is used
comment|/// when patterns have the same name in them, like '(mul GPR:$in, GPR:$in)'.
name|class
name|CheckSameMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
name|unsigned
name|MatchNumber
block|;
name|public
operator|:
name|CheckSameMatcherNode
argument_list|(
argument|unsigned matchnumber
argument_list|)
operator|:
name|MatcherNodeWithChild
argument_list|(
name|CheckSame
argument_list|)
block|,
name|MatchNumber
argument_list|(
argument|matchnumber
argument_list|)
block|{}
name|unsigned
name|getMatchNumber
argument_list|()
specifier|const
block|{
return|return
name|MatchNumber
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckSame
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// CheckPatternPredicateMatcherNode - This checks the target-specific predicate
comment|/// to see if the entire pattern is capable of matching.  This predicate does
comment|/// not take a node as input.  This is used for subtarget feature checks etc.
name|class
name|CheckPatternPredicateMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
name|std
operator|::
name|string
name|Predicate
block|;
name|public
operator|:
name|CheckPatternPredicateMatcherNode
argument_list|(
argument|StringRef predicate
argument_list|)
operator|:
name|MatcherNodeWithChild
argument_list|(
name|CheckPatternPredicate
argument_list|)
block|,
name|Predicate
argument_list|(
argument|predicate
argument_list|)
block|{}
name|StringRef
name|getPredicate
argument_list|()
specifier|const
block|{
return|return
name|Predicate
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckPatternPredicate
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// CheckPredicateMatcherNode - This checks the target-specific predicate to
comment|/// see if the node is acceptable.
name|class
name|CheckPredicateMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
name|StringRef
name|PredName
block|;
name|public
operator|:
name|CheckPredicateMatcherNode
argument_list|(
argument|StringRef predname
argument_list|)
operator|:
name|MatcherNodeWithChild
argument_list|(
name|CheckPredicate
argument_list|)
block|,
name|PredName
argument_list|(
argument|predname
argument_list|)
block|{}
name|StringRef
name|getPredicateName
argument_list|()
specifier|const
block|{
return|return
name|PredName
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckPredicate
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// CheckOpcodeMatcherNode - This checks to see if the current node has the
comment|/// specified opcode, if not it fails to match.
name|class
name|CheckOpcodeMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
name|StringRef
name|OpcodeName
block|;
name|public
operator|:
name|CheckOpcodeMatcherNode
argument_list|(
argument|StringRef opcodename
argument_list|)
operator|:
name|MatcherNodeWithChild
argument_list|(
name|CheckOpcode
argument_list|)
block|,
name|OpcodeName
argument_list|(
argument|opcodename
argument_list|)
block|{}
name|StringRef
name|getOpcodeName
argument_list|()
specifier|const
block|{
return|return
name|OpcodeName
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckOpcode
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// CheckTypeMatcherNode - This checks to see if the current node has the
comment|/// specified type, if not it fails to match.
name|class
name|CheckTypeMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
name|MVT
operator|::
name|SimpleValueType
name|Type
block|;
name|public
operator|:
name|CheckTypeMatcherNode
argument_list|(
argument|MVT::SimpleValueType type
argument_list|)
operator|:
name|MatcherNodeWithChild
argument_list|(
name|CheckType
argument_list|)
block|,
name|Type
argument_list|(
argument|type
argument_list|)
block|{}
name|MVT
operator|::
name|SimpleValueType
name|getType
argument_list|()
specifier|const
block|{
return|return
name|Type
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckType
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// CheckIntegerMatcherNode - This checks to see if the current node is a
comment|/// ConstantSDNode with the specified integer value, if not it fails to match.
name|class
name|CheckIntegerMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
name|int64_t
name|Value
block|;
name|public
operator|:
name|CheckIntegerMatcherNode
argument_list|(
argument|int64_t value
argument_list|)
operator|:
name|MatcherNodeWithChild
argument_list|(
name|CheckInteger
argument_list|)
block|,
name|Value
argument_list|(
argument|value
argument_list|)
block|{}
name|int64_t
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckInteger
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// CheckCondCodeMatcherNode - This checks to see if the current node is a
comment|/// CondCodeSDNode with the specified condition, if not it fails to match.
name|class
name|CheckCondCodeMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
name|StringRef
name|CondCodeName
block|;
name|public
operator|:
name|CheckCondCodeMatcherNode
argument_list|(
argument|StringRef condcodename
argument_list|)
operator|:
name|MatcherNodeWithChild
argument_list|(
name|CheckCondCode
argument_list|)
block|,
name|CondCodeName
argument_list|(
argument|condcodename
argument_list|)
block|{}
name|StringRef
name|getCondCodeName
argument_list|()
specifier|const
block|{
return|return
name|CondCodeName
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckCondCode
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// CheckValueTypeMatcherNode - This checks to see if the current node is a
comment|/// VTSDNode with the specified type, if not it fails to match.
name|class
name|CheckValueTypeMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
name|StringRef
name|TypeName
block|;
name|public
operator|:
name|CheckValueTypeMatcherNode
argument_list|(
argument|StringRef type_name
argument_list|)
operator|:
name|MatcherNodeWithChild
argument_list|(
name|CheckValueType
argument_list|)
block|,
name|TypeName
argument_list|(
argument|type_name
argument_list|)
block|{}
name|StringRef
name|getTypeName
argument_list|()
specifier|const
block|{
return|return
name|TypeName
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckValueType
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// CheckComplexPatMatcherNode - This node runs the specified ComplexPattern on
comment|/// the current node.
name|class
name|CheckComplexPatMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
specifier|const
name|ComplexPattern
operator|&
name|Pattern
block|;
name|public
operator|:
name|CheckComplexPatMatcherNode
argument_list|(
specifier|const
name|ComplexPattern
operator|&
name|pattern
argument_list|)
operator|:
name|MatcherNodeWithChild
argument_list|(
name|CheckComplexPat
argument_list|)
block|,
name|Pattern
argument_list|(
argument|pattern
argument_list|)
block|{}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckComplexPat
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// CheckAndImmMatcherNode - This checks to see if the current node is an 'and'
comment|/// with something equivalent to the specified immediate.
name|class
name|CheckAndImmMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
name|int64_t
name|Value
block|;
name|public
operator|:
name|CheckAndImmMatcherNode
argument_list|(
argument|int64_t value
argument_list|)
operator|:
name|MatcherNodeWithChild
argument_list|(
name|CheckAndImm
argument_list|)
block|,
name|Value
argument_list|(
argument|value
argument_list|)
block|{}
name|int64_t
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckAndImm
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// CheckOrImmMatcherNode - This checks to see if the current node is an 'and'
comment|/// with something equivalent to the specified immediate.
name|class
name|CheckOrImmMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
name|int64_t
name|Value
block|;
name|public
operator|:
name|CheckOrImmMatcherNode
argument_list|(
argument|int64_t value
argument_list|)
operator|:
name|MatcherNodeWithChild
argument_list|(
name|CheckOrImm
argument_list|)
block|,
name|Value
argument_list|(
argument|value
argument_list|)
block|{}
name|int64_t
name|getValue
argument_list|()
specifier|const
block|{
return|return
name|Value
return|;
block|}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckOrImm
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// CheckProfitableToFoldMatcherNode - This checks to see if the current node is
comment|/// worthwhile to try to fold into a large pattern.
name|class
name|CheckProfitableToFoldMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
name|public
operator|:
name|CheckProfitableToFoldMatcherNode
argument_list|()
operator|:
name|MatcherNodeWithChild
argument_list|(
argument|CheckProfitableToFold
argument_list|)
block|{}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckProfitableToFold
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// CheckLegalToFoldMatcherNode - This checks to see if the current node is
comment|/// legal to try to fold into a large pattern.
name|class
name|CheckLegalToFoldMatcherNode
range|:
name|public
name|MatcherNodeWithChild
block|{
name|public
operator|:
name|CheckLegalToFoldMatcherNode
argument_list|()
operator|:
name|MatcherNodeWithChild
argument_list|(
argument|CheckLegalToFold
argument_list|)
block|{}
specifier|static
specifier|inline
name|bool
name|classof
argument_list|(
argument|const MatcherNode *N
argument_list|)
block|{
return|return
name|N
operator|->
name|getKind
argument_list|()
operator|==
name|CheckLegalToFold
return|;
block|}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|,
argument|unsigned indent =
literal|0
argument_list|)
specifier|const
block|; }
decl_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

