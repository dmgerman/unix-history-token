begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- CodeGenTarget.h - Target Class Wrapper -------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines wrappers for the Target class and related global
end_comment

begin_comment
comment|// functionality.  This makes it easier to access the data and provides a single
end_comment

begin_comment
comment|// place that needs to check it for validity.  All of these classes throw
end_comment

begin_comment
comment|// exceptions on error conditions.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CODEGEN_TARGET_H
end_ifndef

begin_define
define|#
directive|define
name|CODEGEN_TARGET_H
end_define

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|"CodeGenRegisters.h"
end_include

begin_include
include|#
directive|include
file|"CodeGenInstruction.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Record
decl_stmt|;
name|class
name|RecordKeeper
decl_stmt|;
struct_decl|struct
name|CodeGenRegister
struct_decl|;
name|class
name|CodeGenTarget
decl_stmt|;
comment|// SelectionDAG node properties.
comment|//  SDNPMemOperand: indicates that a node touches memory and therefore must
comment|//                  have an associated memory operand that describes the access.
enum|enum
name|SDNP
block|{
name|SDNPCommutative
block|,
name|SDNPAssociative
block|,
name|SDNPHasChain
block|,
name|SDNPOutFlag
block|,
name|SDNPInFlag
block|,
name|SDNPOptInFlag
block|,
name|SDNPMayLoad
block|,
name|SDNPMayStore
block|,
name|SDNPSideEffect
block|,
name|SDNPMemOperand
block|}
enum|;
comment|// ComplexPattern attributes.
enum|enum
name|CPAttr
block|{
name|CPAttrParentAsRoot
block|}
enum|;
comment|/// getValueType - Return the MVT::SimpleValueType that the specified TableGen
comment|/// record corresponds to.
name|MVT
operator|::
name|SimpleValueType
name|getValueType
argument_list|(
name|Record
operator|*
name|Rec
argument_list|)
expr_stmt|;
name|std
operator|::
name|string
name|getName
argument_list|(
argument|MVT::SimpleValueType T
argument_list|)
expr_stmt|;
name|std
operator|::
name|string
name|getEnumName
argument_list|(
argument|MVT::SimpleValueType T
argument_list|)
expr_stmt|;
comment|/// getQualifiedName - Return the name of the specified record, with a
comment|/// namespace qualifier if the record contains one.
name|std
operator|::
name|string
name|getQualifiedName
argument_list|(
specifier|const
name|Record
operator|*
name|R
argument_list|)
expr_stmt|;
comment|/// CodeGenTarget - This class corresponds to the Target class in the .td files.
comment|///
name|class
name|CodeGenTarget
block|{
name|Record
modifier|*
name|TargetRec
decl_stmt|;
name|mutable
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
name|CodeGenInstruction
operator|>
name|Instructions
expr_stmt|;
name|mutable
name|std
operator|::
name|vector
operator|<
name|CodeGenRegister
operator|>
name|Registers
expr_stmt|;
name|mutable
name|std
operator|::
name|vector
operator|<
name|CodeGenRegisterClass
operator|>
name|RegisterClasses
expr_stmt|;
name|mutable
name|std
operator|::
name|vector
operator|<
name|MVT
operator|::
name|SimpleValueType
operator|>
name|LegalValueTypes
expr_stmt|;
name|void
name|ReadRegisters
argument_list|()
specifier|const
expr_stmt|;
name|void
name|ReadRegisterClasses
argument_list|()
specifier|const
expr_stmt|;
name|void
name|ReadInstructions
argument_list|()
specifier|const
expr_stmt|;
name|void
name|ReadLegalValueTypes
argument_list|()
specifier|const
expr_stmt|;
name|public
label|:
name|CodeGenTarget
argument_list|()
expr_stmt|;
name|Record
operator|*
name|getTargetRecord
argument_list|()
specifier|const
block|{
return|return
name|TargetRec
return|;
block|}
specifier|const
name|std
operator|::
name|string
operator|&
name|getName
argument_list|()
specifier|const
expr_stmt|;
comment|/// getInstNamespace - Return the target-specific instruction namespace.
comment|///
name|std
operator|::
name|string
name|getInstNamespace
argument_list|()
specifier|const
expr_stmt|;
comment|/// getInstructionSet - Return the InstructionSet object.
comment|///
name|Record
operator|*
name|getInstructionSet
argument_list|()
specifier|const
expr_stmt|;
comment|/// getAsmParser - Return the AssemblyParser definition for this target.
comment|///
name|Record
operator|*
name|getAsmParser
argument_list|()
specifier|const
expr_stmt|;
comment|/// getAsmWriter - Return the AssemblyWriter definition for this target.
comment|///
name|Record
operator|*
name|getAsmWriter
argument_list|()
specifier|const
expr_stmt|;
specifier|const
name|std
operator|::
name|vector
operator|<
name|CodeGenRegister
operator|>
operator|&
name|getRegisters
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Registers
operator|.
name|empty
argument_list|()
condition|)
name|ReadRegisters
argument_list|()
expr_stmt|;
return|return
name|Registers
return|;
block|}
specifier|const
name|std
operator|::
name|vector
operator|<
name|CodeGenRegisterClass
operator|>
operator|&
name|getRegisterClasses
argument_list|()
specifier|const
block|{
if|if
condition|(
name|RegisterClasses
operator|.
name|empty
argument_list|()
condition|)
name|ReadRegisterClasses
argument_list|()
expr_stmt|;
return|return
name|RegisterClasses
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|CodeGenRegisterClass
modifier|&
name|getRegisterClass
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
specifier|const
name|std
operator|::
name|vector
operator|<
name|CodeGenRegisterClass
operator|>
operator|&
name|RC
operator|=
name|getRegisterClasses
argument_list|()
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|RC
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|RC
index|[
name|i
index|]
operator|.
name|TheDef
operator|==
name|R
condition|)
return|return
name|RC
index|[
name|i
index|]
return|;
name|assert
argument_list|(
literal|0
operator|&&
literal|"Didn't find the register class"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// getRegisterClassForRegister - Find the register class that contains the
end_comment

begin_comment
comment|/// specified physical register.  If the register is not in a register
end_comment

begin_comment
comment|/// class, return null. If the register is in multiple classes, and the
end_comment

begin_comment
comment|/// classes have a superset-subset relationship and the same set of
end_comment

begin_comment
comment|/// types, return the superclass.  Otherwise return null.
end_comment

begin_decl_stmt
specifier|const
name|CodeGenRegisterClass
modifier|*
name|getRegisterClassForRegister
argument_list|(
name|Record
operator|*
name|R
argument_list|)
decl|const
block|{
specifier|const
name|std
operator|::
name|vector
operator|<
name|CodeGenRegisterClass
operator|>
operator|&
name|RCs
operator|=
name|getRegisterClasses
argument_list|()
expr_stmt|;
specifier|const
name|CodeGenRegisterClass
modifier|*
name|FoundRC
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|RCs
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|CodeGenRegisterClass
modifier|&
name|RC
init|=
name|RegisterClasses
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|ei
init|=
literal|0
init|,
name|ee
init|=
name|RC
operator|.
name|Elements
operator|.
name|size
argument_list|()
init|;
name|ei
operator|!=
name|ee
condition|;
operator|++
name|ei
control|)
block|{
if|if
condition|(
name|R
operator|!=
name|RC
operator|.
name|Elements
index|[
name|ei
index|]
condition|)
continue|continue;
comment|// If a register's classes have different types, return null.
if|if
condition|(
name|FoundRC
operator|&&
name|RC
operator|.
name|getValueTypes
argument_list|()
operator|!=
name|FoundRC
operator|->
name|getValueTypes
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// If this is the first class that contains the register,
comment|// make a note of it and go on to the next class.
if|if
condition|(
operator|!
name|FoundRC
condition|)
block|{
name|FoundRC
operator|=
operator|&
name|RC
expr_stmt|;
break|break;
block|}
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|Elements
argument_list|(
name|RC
operator|.
name|Elements
argument_list|)
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|FoundElements
argument_list|(
name|FoundRC
operator|->
name|Elements
argument_list|)
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|Elements
operator|.
name|begin
argument_list|()
argument_list|,
name|Elements
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
name|std
operator|::
name|sort
argument_list|(
name|FoundElements
operator|.
name|begin
argument_list|()
argument_list|,
name|FoundElements
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check to see if the previously found class that contains
comment|// the register is a subclass of the current class. If so,
comment|// prefer the superclass.
if|if
condition|(
name|std
operator|::
name|includes
argument_list|(
name|Elements
operator|.
name|begin
argument_list|()
argument_list|,
name|Elements
operator|.
name|end
argument_list|()
argument_list|,
name|FoundElements
operator|.
name|begin
argument_list|()
argument_list|,
name|FoundElements
operator|.
name|end
argument_list|()
argument_list|)
condition|)
block|{
name|FoundRC
operator|=
operator|&
name|RC
expr_stmt|;
break|break;
block|}
comment|// Check to see if the previously found class that contains
comment|// the register is a superclass of the current class. If so,
comment|// prefer the superclass.
if|if
condition|(
name|std
operator|::
name|includes
argument_list|(
name|FoundElements
operator|.
name|begin
argument_list|()
argument_list|,
name|FoundElements
operator|.
name|end
argument_list|()
argument_list|,
name|Elements
operator|.
name|begin
argument_list|()
argument_list|,
name|Elements
operator|.
name|end
argument_list|()
argument_list|)
condition|)
break|break;
comment|// Multiple classes, and neither is a superclass of the other.
comment|// Return null.
return|return
literal|0
return|;
block|}
block|}
return|return
name|FoundRC
return|;
block|}
end_decl_stmt

begin_comment
comment|/// getRegisterVTs - Find the union of all possible SimpleValueTypes for the
end_comment

begin_comment
comment|/// specified physical register.
end_comment

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|unsigned
name|char
operator|>
name|getRegisterVTs
argument_list|(
argument|Record *R
argument_list|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|const
name|std
operator|::
name|vector
operator|<
name|MVT
operator|::
name|SimpleValueType
operator|>
operator|&
name|getLegalValueTypes
argument_list|()
specifier|const
block|{
if|if
condition|(
name|LegalValueTypes
operator|.
name|empty
argument_list|()
condition|)
name|ReadLegalValueTypes
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|LegalValueTypes
return|;
end_return

begin_comment
unit|}
comment|/// isLegalValueType - Return true if the specified value type is natively
end_comment

begin_comment
comment|/// supported by the target (i.e. there are registers that directly hold it).
end_comment

begin_macro
unit|bool
name|isLegalValueType
argument_list|(
argument|MVT::SimpleValueType VT
argument_list|)
end_macro

begin_expr_stmt
specifier|const
block|{
specifier|const
name|std
operator|::
name|vector
operator|<
name|MVT
operator|::
name|SimpleValueType
operator|>
operator|&
name|LegalVTs
operator|=
name|getLegalValueTypes
argument_list|()
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|LegalVTs
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|LegalVTs
index|[
name|i
index|]
operator|==
name|VT
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|false
return|;
end_return

begin_comment
unit|}
comment|/// getInstructions - Return all of the instructions defined for this target.
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
unit|const
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
name|CodeGenInstruction
operator|>
operator|&
name|getInstructions
argument_list|()
specifier|const
block|{
if|if
condition|(
name|Instructions
operator|.
name|empty
argument_list|()
condition|)
name|ReadInstructions
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Instructions
return|;
end_return

begin_expr_stmt
unit|}   std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
name|CodeGenInstruction
operator|>
operator|&
name|getInstructions
argument_list|()
block|{
if|if
condition|(
name|Instructions
operator|.
name|empty
argument_list|()
condition|)
name|ReadInstructions
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Instructions
return|;
end_return

begin_expr_stmt
unit|}    CodeGenInstruction
operator|&
name|getInstruction
argument_list|(
argument|const std::string&Name
argument_list|)
specifier|const
block|{
specifier|const
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
block|,
name|CodeGenInstruction
operator|>
operator|&
name|Insts
operator|=
name|getInstructions
argument_list|()
block|;
name|assert
argument_list|(
name|Insts
operator|.
name|count
argument_list|(
name|Name
argument_list|)
operator|&&
literal|"Not an instruction!"
argument_list|)
block|;
return|return
name|const_cast
operator|<
name|CodeGenInstruction
operator|&
operator|>
operator|(
name|Insts
operator|.
name|find
argument_list|(
name|Name
argument_list|)
operator|->
name|second
operator|)
return|;
block|}
end_expr_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
name|CodeGenInstruction
operator|>
operator|::
name|const_iterator
name|inst_iterator
expr_stmt|;
end_typedef

begin_expr_stmt
name|inst_iterator
name|inst_begin
argument_list|()
specifier|const
block|{
return|return
name|getInstructions
argument_list|()
operator|.
name|begin
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|inst_iterator
name|inst_end
argument_list|()
specifier|const
block|{
return|return
name|Instructions
operator|.
name|end
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// getInstructionsByEnumValue - Return all of the instructions defined by the
end_comment

begin_comment
comment|/// target, ordered by their enum value.
end_comment

begin_decl_stmt
name|void
name|getInstructionsByEnumValue
argument_list|(
name|std
operator|::
name|vector
operator|<
specifier|const
name|CodeGenInstruction
operator|*
operator|>
operator|&
name|NumberedInstructions
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// isLittleEndianEncoding - are instruction bit patterns defined as  [0..n]?
end_comment

begin_comment
comment|///
end_comment

begin_expr_stmt
name|bool
name|isLittleEndianEncoding
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// ComplexPattern - ComplexPattern info, corresponding to the ComplexPattern
end_comment

begin_comment
comment|/// tablegen class in TargetSelectionDAG.td
end_comment

begin_decl_stmt
name|class
name|ComplexPattern
block|{
name|MVT
operator|::
name|SimpleValueType
name|Ty
expr_stmt|;
name|unsigned
name|NumOperands
decl_stmt|;
name|std
operator|::
name|string
name|SelectFunc
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
name|RootNodes
expr_stmt|;
name|unsigned
name|Properties
decl_stmt|;
comment|// Node properties
name|unsigned
name|Attributes
decl_stmt|;
comment|// Pattern attributes
name|public
label|:
name|ComplexPattern
argument_list|()
operator|:
name|NumOperands
argument_list|(
literal|0
argument_list|)
block|{}
expr_stmt|;
name|ComplexPattern
argument_list|(
name|Record
operator|*
name|R
argument_list|)
expr_stmt|;
name|MVT
operator|::
name|SimpleValueType
name|getValueType
argument_list|()
specifier|const
block|{
return|return
name|Ty
return|;
block|}
name|unsigned
name|getNumOperands
argument_list|()
specifier|const
block|{
return|return
name|NumOperands
return|;
block|}
specifier|const
name|std
operator|::
name|string
operator|&
name|getSelectFunc
argument_list|()
specifier|const
block|{
return|return
name|SelectFunc
return|;
block|}
specifier|const
name|std
operator|::
name|vector
operator|<
name|Record
operator|*
operator|>
operator|&
name|getRootNodes
argument_list|()
specifier|const
block|{
return|return
name|RootNodes
return|;
block|}
name|bool
name|hasProperty
argument_list|(
expr|enum
name|SDNP
name|Prop
argument_list|)
decl|const
block|{
return|return
name|Properties
operator|&
operator|(
literal|1
operator|<<
name|Prop
operator|)
return|;
block|}
name|bool
name|hasAttribute
argument_list|(
expr|enum
name|CPAttr
name|Attr
argument_list|)
decl|const
block|{
return|return
name|Attributes
operator|&
operator|(
literal|1
operator|<<
name|Attr
operator|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

