begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2016 by Delphix. All rights reserved.  * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/range_tree.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_function
specifier|static
name|void
name|dnode_increase_indirection
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|int
name|txgoff
init|=
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
decl_stmt|;
name|int
name|nblkptr
init|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nblkptr
decl_stmt|;
name|int
name|old_toplvl
init|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
operator|-
literal|1
decl_stmt|;
name|int
name|new_level
init|=
name|dn
operator|->
name|dn_next_nlevels
index|[
name|txgoff
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* this dnode can't be paged out because it's dirty */
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
operator|!=
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_level
operator|>
literal|1
operator|&&
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
operator|>
literal|0
argument_list|)
expr_stmt|;
name|db
operator|=
name|dbuf_hold_level
argument_list|(
name|dn
argument_list|,
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
operator|=
name|new_level
expr_stmt|;
name|dprintf
argument_list|(
literal|"os=%p obj=%llu, increase to %d\n"
argument_list|,
name|dn
operator|->
name|dn_objset
argument_list|,
name|dn
operator|->
name|dn_object
argument_list|,
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
argument_list|)
expr_stmt|;
comment|/* transfer dnode's block pointers to new indirect block */
operator|(
name|void
operator|)
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|NULL
argument_list|,
name|DB_RF_MUST_SUCCEED
operator||
name|DB_RF_HAVESTRUCT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db
operator|.
name|db_data
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|arc_released
argument_list|(
name|db
operator|->
name|db_buf
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
operator|*
name|nblkptr
argument_list|,
operator|<=
argument_list|,
name|db
operator|->
name|db
operator|.
name|db_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_blkptr
argument_list|,
name|db
operator|->
name|db
operator|.
name|db_data
argument_list|,
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
operator|*
name|nblkptr
argument_list|)
expr_stmt|;
name|arc_buf_freeze
argument_list|(
name|db
operator|->
name|db_buf
argument_list|)
expr_stmt|;
comment|/* set dbuf's parent pointers to new indirect buf */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblkptr
condition|;
name|i
operator|++
control|)
block|{
name|dmu_buf_impl_t
modifier|*
name|child
init|=
name|dbuf_find
argument_list|(
name|dn
operator|->
name|dn_objset
argument_list|,
name|dn
operator|->
name|dn_object
argument_list|,
name|old_toplvl
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DEBUG
name|DB_DNODE_ENTER
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|DB_DNODE
argument_list|(
name|child
argument_list|)
argument_list|,
operator|==
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|DB_DNODE_EXIT
argument_list|(
name|child
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|child
operator|->
name|db_parent
operator|&&
name|child
operator|->
name|db_parent
operator|!=
name|dn
operator|->
name|dn_dbuf
condition|)
block|{
name|ASSERT
argument_list|(
name|child
operator|->
name|db_parent
operator|->
name|db_level
operator|==
name|db
operator|->
name|db_level
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|child
operator|->
name|db_blkptr
operator|!=
operator|&
name|dn
operator|->
name|dn_phys
operator|->
name|dn_blkptr
index|[
name|child
operator|->
name|db_blkid
index|]
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|child
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ASSERT
argument_list|(
name|child
operator|->
name|db_parent
operator|==
name|NULL
operator|||
name|child
operator|->
name|db_parent
operator|==
name|dn
operator|->
name|dn_dbuf
argument_list|)
expr_stmt|;
name|child
operator|->
name|db_parent
operator|=
name|db
expr_stmt|;
name|dbuf_add_ref
argument_list|(
name|db
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|db
operator|.
name|db_data
condition|)
name|child
operator|->
name|db_blkptr
operator|=
operator|(
name|blkptr_t
operator|*
operator|)
name|db
operator|->
name|db
operator|.
name|db_data
operator|+
name|i
expr_stmt|;
else|else
name|child
operator|->
name|db_blkptr
operator|=
name|NULL
expr_stmt|;
name|dprintf_dbuf_bp
argument_list|(
name|child
argument_list|,
name|child
operator|->
name|db_blkptr
argument_list|,
literal|"changed db_blkptr to new indirect %s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|child
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_blkptr
argument_list|,
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
operator|*
name|nblkptr
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_blocks
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|int
name|num
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dn
operator|->
name|dn_objset
operator|->
name|os_dsl_dataset
decl_stmt|;
name|uint64_t
name|bytesfreed
init|=
literal|0
decl_stmt|;
name|dprintf
argument_list|(
literal|"ds=%p obj=%llx num=%d\n"
argument_list|,
name|ds
argument_list|,
name|dn
operator|->
name|dn_object
argument_list|,
name|num
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
operator|,
name|bp
operator|++
control|)
block|{
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
continue|continue;
name|bytesfreed
operator|+=
name|dsl_dataset_block_kill
argument_list|(
name|ds
argument_list|,
name|bp
argument_list|,
name|tx
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bytesfreed
argument_list|,
operator|<=
argument_list|,
name|DN_USED_BYTES
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Save some useful information on the holes being 		 * punched, including logical size, type, and indirection 		 * level. Retaining birth time enables detection of when 		 * holes are punched for reducing the number of free 		 * records transmitted during a zfs send. 		 */
name|uint64_t
name|lsize
init|=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|dmu_object_type_t
name|type
init|=
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|uint64_t
name|lvl
init|=
name|BP_GET_LEVEL
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_feature_is_active
argument_list|(
name|dn
operator|->
name|dn_objset
operator|->
name|os_spa
argument_list|,
name|SPA_FEATURE_HOLE_BIRTH
argument_list|)
condition|)
block|{
name|BP_SET_LSIZE
argument_list|(
name|bp
argument_list|,
name|lsize
argument_list|)
expr_stmt|;
name|BP_SET_TYPE
argument_list|(
name|bp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|BP_SET_LEVEL
argument_list|(
name|bp
argument_list|,
name|lvl
argument_list|)
expr_stmt|;
name|BP_SET_BIRTH
argument_list|(
name|bp
argument_list|,
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|dnode_diduse_space
argument_list|(
name|dn
argument_list|,
operator|-
name|bytesfreed
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ZFS_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|free_verify
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|,
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|end
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|off
decl_stmt|,
name|num
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|,
name|epbs
decl_stmt|;
name|uint64_t
name|txg
init|=
name|tx
operator|->
name|tx_txg
decl_stmt|;
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|DB_DNODE_ENTER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|epbs
operator|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
expr_stmt|;
name|off
operator|=
name|start
operator|-
operator|(
name|db
operator|->
name|db_blkid
operator|*
literal|1
operator|<<
name|epbs
operator|)
expr_stmt|;
name|num
operator|=
name|end
operator|-
name|start
operator|+
literal|1
expr_stmt|;
name|ASSERT3U
argument_list|(
name|off
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|num
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db_level
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db
operator|.
name|db_size
argument_list|,
operator|==
argument_list|,
literal|1
operator|<<
name|dn
operator|->
name|dn_phys
operator|->
name|dn_indblkshift
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|off
operator|+
name|num
argument_list|,
operator|<=
argument_list|,
name|db
operator|->
name|db
operator|.
name|db_size
operator|>>
name|SPA_BLKPTRSHIFT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_blkptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|off
init|;
name|i
operator|<
name|off
operator|+
name|num
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
modifier|*
name|buf
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|child
decl_stmt|;
name|dbuf_dirty_record_t
modifier|*
name|dr
decl_stmt|;
name|int
name|j
decl_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_level
operator|==
literal|1
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|err
operator|=
name|dbuf_hold_impl
argument_list|(
name|dn
argument_list|,
name|db
operator|->
name|db_level
operator|-
literal|1
argument_list|,
operator|(
name|db
operator|->
name|db_blkid
operator|<<
name|epbs
operator|)
operator|+
name|i
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|child
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
continue|continue;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|child
operator|->
name|db_level
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dr
operator|=
name|child
operator|->
name|db_last_dirty
expr_stmt|;
while|while
condition|(
name|dr
operator|&&
name|dr
operator|->
name|dr_txg
operator|>
name|txg
condition|)
name|dr
operator|=
name|dr
operator|->
name|dr_next
expr_stmt|;
name|ASSERT
argument_list|(
name|dr
operator|==
name|NULL
operator|||
name|dr
operator|->
name|dr_txg
operator|==
name|txg
argument_list|)
expr_stmt|;
comment|/* data_old better be zeroed */
if|if
condition|(
name|dr
condition|)
block|{
name|buf
operator|=
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_data
operator|->
name|b_data
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|child
operator|->
name|db
operator|.
name|db_size
operator|>>
literal|3
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"freed data not zero: "
literal|"child=%p i=%d off=%d num=%d\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|child
argument_list|,
name|i
argument_list|,
name|off
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * db_data better be zeroed unless it's dirty in a 		 * future txg. 		 */
name|mutex_enter
argument_list|(
operator|&
name|child
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|buf
operator|=
name|child
operator|->
name|db
operator|.
name|db_data
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
operator|&&
name|child
operator|->
name|db_state
operator|!=
name|DB_FILL
operator|&&
name|child
operator|->
name|db_last_dirty
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|child
operator|->
name|db
operator|.
name|db_size
operator|>>
literal|3
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"freed data not zero: "
literal|"child=%p i=%d off=%d num=%d\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|child
argument_list|,
name|i
argument_list|,
name|off
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|child
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|child
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|DB_DNODE_EXIT
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|free_children
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|uint64_t
name|nblks
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|subdb
decl_stmt|;
name|uint64_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|dbstart
decl_stmt|,
name|dbend
decl_stmt|,
name|i
decl_stmt|;
name|int
name|epbs
decl_stmt|,
name|shift
decl_stmt|;
comment|/* 	 * There is a small possibility that this block will not be cached: 	 *   1 - if level> 1 and there are no children with level<= 1 	 *   2 - if this block was evicted since we read it from 	 *	 dmu_tx_hold_free(). 	 */
if|if
condition|(
name|db
operator|->
name|db_state
operator|!=
name|DB_CACHED
condition|)
operator|(
name|void
operator|)
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|NULL
argument_list|,
name|DB_RF_MUST_SUCCEED
argument_list|)
expr_stmt|;
name|dbuf_release_bp
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|bp
operator|=
name|db
operator|->
name|db
operator|.
name|db_data
expr_stmt|;
name|DB_DNODE_ENTER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|epbs
operator|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
expr_stmt|;
name|shift
operator|=
operator|(
name|db
operator|->
name|db_level
operator|-
literal|1
operator|)
operator|*
name|epbs
expr_stmt|;
name|dbstart
operator|=
name|db
operator|->
name|db_blkid
operator|<<
name|epbs
expr_stmt|;
name|start
operator|=
name|blkid
operator|>>
name|shift
expr_stmt|;
if|if
condition|(
name|dbstart
operator|<
name|start
condition|)
block|{
name|bp
operator|+=
name|start
operator|-
name|dbstart
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|dbstart
expr_stmt|;
block|}
name|dbend
operator|=
operator|(
operator|(
name|db
operator|->
name|db_blkid
operator|+
literal|1
operator|)
operator|<<
name|epbs
operator|)
operator|-
literal|1
expr_stmt|;
name|end
operator|=
operator|(
name|blkid
operator|+
name|nblks
operator|-
literal|1
operator|)
operator|>>
name|shift
expr_stmt|;
if|if
condition|(
name|dbend
operator|<=
name|end
condition|)
name|end
operator|=
name|dbend
expr_stmt|;
name|ASSERT3U
argument_list|(
name|start
argument_list|,
operator|<=
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|db_level
operator|==
literal|1
condition|)
block|{
name|FREE_VERIFY
argument_list|(
name|db
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|free_blocks
argument_list|(
name|dn
argument_list|,
name|bp
argument_list|,
name|end
operator|-
name|start
operator|+
literal|1
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
operator|,
name|bp
operator|++
control|)
block|{
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
continue|continue;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dbuf_hold_impl
argument_list|(
name|dn
argument_list|,
name|db
operator|->
name|db_level
operator|-
literal|1
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|subdb
argument_list|)
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|bp
argument_list|,
operator|==
argument_list|,
name|subdb
operator|->
name|db_blkptr
argument_list|)
expr_stmt|;
name|free_children
argument_list|(
name|subdb
argument_list|,
name|blkid
argument_list|,
name|nblks
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|subdb
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this whole block is free, free ourself too. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bp
operator|=
name|db
operator|->
name|db
operator|.
name|db_data
init|;
name|i
operator|<
literal|1
operator|<<
name|epbs
condition|;
name|i
operator|++
operator|,
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|1
operator|<<
name|epbs
condition|)
block|{
comment|/* didn't find any non-holes */
name|bzero
argument_list|(
name|db
operator|->
name|db
operator|.
name|db_data
argument_list|,
name|db
operator|->
name|db
operator|.
name|db_size
argument_list|)
expr_stmt|;
name|free_blocks
argument_list|(
name|dn
argument_list|,
name|db
operator|->
name|db_blkptr
argument_list|,
literal|1
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Partial block free; must be marked dirty so that it 		 * will be written out. 		 */
name|ASSERT
argument_list|(
name|db
operator|->
name|db_dirtycnt
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
name|DB_DNODE_EXIT
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|arc_buf_freeze
argument_list|(
name|db
operator|->
name|db_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Traverse the indicated range of the provided file  * and "free" all the blocks contained there.  */
end_comment

begin_function
specifier|static
name|void
name|dnode_sync_free_range_impl
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|uint64_t
name|nblks
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_blkptr
decl_stmt|;
name|int
name|dnlevel
init|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
decl_stmt|;
name|boolean_t
name|trunc
init|=
name|B_FALSE
decl_stmt|;
if|if
condition|(
name|blkid
operator|>
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
condition|)
return|return;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|<
name|UINT64_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkid
operator|+
name|nblks
operator|>
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
condition|)
block|{
name|nblks
operator|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|-
name|blkid
operator|+
literal|1
expr_stmt|;
name|trunc
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* There are no indirect blocks in the object */
if|if
condition|(
name|dnlevel
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|blkid
operator|>=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nblkptr
condition|)
block|{
comment|/* this range was never made persistent */
return|return;
block|}
name|ASSERT3U
argument_list|(
name|blkid
operator|+
name|nblks
argument_list|,
operator|<=
argument_list|,
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nblkptr
argument_list|)
expr_stmt|;
name|free_blocks
argument_list|(
name|dn
argument_list|,
name|bp
operator|+
name|blkid
argument_list|,
name|nblks
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|shift
init|=
operator|(
name|dnlevel
operator|-
literal|1
operator|)
operator|*
operator|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
operator|)
decl_stmt|;
name|int
name|start
init|=
name|blkid
operator|>>
name|shift
decl_stmt|;
name|int
name|end
init|=
operator|(
name|blkid
operator|+
name|nblks
operator|-
literal|1
operator|)
operator|>>
name|shift
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|ASSERT
argument_list|(
name|start
operator|<
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nblkptr
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|start
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
operator|,
name|bp
operator|++
control|)
block|{
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
continue|continue;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dbuf_hold_impl
argument_list|(
name|dn
argument_list|,
name|dnlevel
operator|-
literal|1
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|free_children
argument_list|(
name|db
argument_list|,
name|blkid
argument_list|,
name|nblks
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|trunc
condition|)
block|{
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|=
name|blkid
operator|==
literal|0
condition|?
literal|0
else|:
name|blkid
operator|-
literal|1
expr_stmt|;
name|uint64_t
name|off
init|=
operator|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|+
literal|1
operator|)
operator|*
operator|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_datablkszsec
operator|<<
name|SPA_MINBLOCKSHIFT
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|off
operator|<
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|||
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|==
literal|0
operator|||
name|dnode_next_offset
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
operator|&
name|off
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dnode_sync_free_range_arg
block|{
name|dnode_t
modifier|*
name|dsfra_dnode
decl_stmt|;
name|dmu_tx_t
modifier|*
name|dsfra_tx
decl_stmt|;
block|}
name|dnode_sync_free_range_arg_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|dnode_sync_free_range
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|uint64_t
name|nblks
parameter_list|)
block|{
name|dnode_sync_free_range_arg_t
modifier|*
name|dsfra
init|=
name|arg
decl_stmt|;
name|dnode_t
modifier|*
name|dn
init|=
name|dsfra
operator|->
name|dsfra_dnode
decl_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dnode_sync_free_range_impl
argument_list|(
name|dn
argument_list|,
name|blkid
argument_list|,
name|nblks
argument_list|,
name|dsfra
operator|->
name|dsfra_tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to kick all the dnode's dbufs out of the cache...  */
end_comment

begin_function
name|void
name|dnode_evict_dbufs
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|)
block|{
name|dmu_buf_impl_t
name|db_marker
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|,
modifier|*
name|db_next
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|db
operator|=
name|avl_first
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
init|;
name|db
operator|!=
name|NULL
condition|;
name|db
operator|=
name|db_next
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|DB_DNODE_ENTER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|DB_DNODE
argument_list|(
name|db
argument_list|)
argument_list|,
operator|==
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|DB_DNODE_EXIT
argument_list|(
name|db
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|mutex_enter
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|db_state
operator|!=
name|DB_EVICTING
operator|&&
name|refcount_is_zero
argument_list|(
operator|&
name|db
operator|->
name|db_holds
argument_list|)
condition|)
block|{
name|db_marker
operator|.
name|db_level
operator|=
name|db
operator|->
name|db_level
expr_stmt|;
name|db_marker
operator|.
name|db_blkid
operator|=
name|db
operator|->
name|db_blkid
expr_stmt|;
name|db_marker
operator|.
name|db_state
operator|=
name|DB_SEARCH
expr_stmt|;
name|avl_insert_here
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|,
operator|&
name|db_marker
argument_list|,
name|db
argument_list|,
name|AVL_BEFORE
argument_list|)
expr_stmt|;
name|dbuf_destroy
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|db_next
operator|=
name|AVL_NEXT
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|,
operator|&
name|db_marker
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|,
operator|&
name|db_marker
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|db
operator|->
name|db_pending_evict
operator|=
name|TRUE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|db_next
operator|=
name|AVL_NEXT
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|,
name|db
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs_mtx
argument_list|)
expr_stmt|;
name|dnode_evict_bonus
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_evict_bonus
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|)
block|{
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonus
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|refcount_is_zero
argument_list|(
operator|&
name|dn
operator|->
name|dn_bonus
operator|->
name|db_holds
argument_list|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_bonus
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|dbuf_destroy
argument_list|(
name|dn
operator|->
name|dn_bonus
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_bonus
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|dn
operator|->
name|dn_bonus
operator|->
name|db_pending_evict
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dnode_undirty_dbufs
parameter_list|(
name|list_t
modifier|*
name|list
parameter_list|)
block|{
name|dbuf_dirty_record_t
modifier|*
name|dr
decl_stmt|;
while|while
condition|(
name|dr
operator|=
name|list_head
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
name|dr
operator|->
name|dr_dbuf
decl_stmt|;
name|uint64_t
name|txg
init|=
name|dr
operator|->
name|dr_txg
decl_stmt|;
if|if
condition|(
name|db
operator|->
name|db_level
operator|!=
literal|0
condition|)
name|dnode_undirty_dbufs
argument_list|(
operator|&
name|dr
operator|->
name|dt
operator|.
name|di
operator|.
name|dr_children
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
comment|/* XXX - use dbuf_undirty()? */
name|list_remove
argument_list|(
name|list
argument_list|,
name|dr
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_last_dirty
operator|==
name|dr
argument_list|)
expr_stmt|;
name|db
operator|->
name|db_last_dirty
operator|=
name|NULL
expr_stmt|;
name|db
operator|->
name|db_dirtycnt
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|db_level
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|db
operator|->
name|db_blkid
operator|==
name|DMU_BONUS_BLKID
operator|||
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_data
operator|==
name|db
operator|->
name|db_buf
argument_list|)
expr_stmt|;
name|dbuf_unoverride
argument_list|(
name|dr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mutex_destroy
argument_list|(
operator|&
name|dr
operator|->
name|dt
operator|.
name|di
operator|.
name|dr_mtx
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|dr
operator|->
name|dt
operator|.
name|di
operator|.
name|dr_children
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|dr
argument_list|,
sizeof|sizeof
argument_list|(
name|dbuf_dirty_record_t
argument_list|)
argument_list|)
expr_stmt|;
name|dbuf_rele_and_unlock
argument_list|(
name|db
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|txg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dnode_sync_free
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|txgoff
init|=
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
decl_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Our contents should have been freed in dnode_sync() by the 	 * free range record inserted by the caller of dnode_free(). 	 */
name|ASSERT0
argument_list|(
name|DN_USED_BYTES
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_blkptr
argument_list|)
argument_list|)
expr_stmt|;
name|dnode_undirty_dbufs
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|txgoff
index|]
argument_list|)
expr_stmt|;
name|dnode_evict_dbufs
argument_list|(
name|dn
argument_list|)
expr_stmt|;
comment|/* 	 * XXX - It would be nice to assert this, but we may still 	 * have residual holds from async evictions from the arc... 	 * 	 * zfs_obj_to_path() also depends on this being 	 * commented out. 	 * 	 * ASSERT3U(refcount_count(&dn->dn_holds), ==, 1); 	 */
comment|/* Undirty next bits */
name|dn
operator|->
name|dn_next_nlevels
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_next_indblkshift
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_next_blksz
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
comment|/* ASSERT(blkptrs are zero); */
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
operator|!=
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_type
operator|!=
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_free_txg
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_allocated_txg
operator|!=
name|dn
operator|->
name|dn_free_txg
condition|)
name|dmu_buf_will_dirty
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbuf
operator|->
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_type
operator|=
name|DMU_OT_NONE
expr_stmt|;
name|dn
operator|->
name|dn_maxblkid
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_allocated_txg
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_free_txg
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_have_spill
operator|=
name|B_FALSE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_object
operator|!=
name|DMU_META_DNODE_OBJECT
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we've released our hold, the dnode may 	 * be evicted, so we musn't access it. 	 */
block|}
end_function

begin_comment
comment|/*  * Write out the dnode's dirty buffers.  */
end_comment

begin_function
name|void
name|dnode_sync
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_phys_t
modifier|*
name|dnp
init|=
name|dn
operator|->
name|dn_phys
decl_stmt|;
name|int
name|txgoff
init|=
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
decl_stmt|;
name|list_t
modifier|*
name|list
init|=
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|txgoff
index|]
decl_stmt|;
specifier|static
specifier|const
name|dnode_phys_t
name|zerodn
init|=
block|{
literal|0
block|}
decl_stmt|;
name|boolean_t
name|kill_spill
init|=
name|B_FALSE
decl_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dnp
operator|->
name|dn_type
operator|!=
name|DMU_OT_NONE
operator|||
name|dn
operator|->
name|dn_allocated_txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dnp
operator|->
name|dn_type
operator|!=
name|DMU_OT_NONE
operator|||
name|bcmp
argument_list|(
name|dnp
argument_list|,
operator|&
name|zerodn
argument_list|,
name|DNODE_SIZE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|DNODE_VERIFY
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_dbuf
operator|==
name|NULL
operator|||
name|arc_released
argument_list|(
name|dn
operator|->
name|dn_dbuf
operator|->
name|db_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmu_objset_userused_enabled
argument_list|(
name|dn
operator|->
name|dn_objset
argument_list|)
operator|&&
operator|!
name|DMU_OBJECT_IS_SPECIAL
argument_list|(
name|dn
operator|->
name|dn_object
argument_list|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_oldused
operator|=
name|DN_USED_BYTES
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_oldflags
operator|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_flags
expr_stmt|;
name|dn
operator|->
name|dn_phys
operator|->
name|dn_flags
operator||=
name|DNODE_FLAG_USERUSED_ACCOUNTED
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dmu_objset_userquota_get_ids
argument_list|(
name|dn
argument_list|,
name|B_FALSE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Once we account for it, we should always account for it. */
name|ASSERT
argument_list|(
operator|!
operator|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_flags
operator|&
name|DNODE_FLAG_USERUSED_ACCOUNTED
operator|)
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_allocated_txg
operator|==
name|tx
operator|->
name|tx_txg
condition|)
block|{
comment|/* The dnode is newly allocated or reallocated */
if|if
condition|(
name|dnp
operator|->
name|dn_type
operator|==
name|DMU_OT_NONE
condition|)
block|{
comment|/* this is a first alloc, not a realloc */
name|dnp
operator|->
name|dn_nlevels
operator|=
literal|1
expr_stmt|;
name|dnp
operator|->
name|dn_nblkptr
operator|=
name|dn
operator|->
name|dn_nblkptr
expr_stmt|;
block|}
name|dnp
operator|->
name|dn_type
operator|=
name|dn
operator|->
name|dn_type
expr_stmt|;
name|dnp
operator|->
name|dn_bonustype
operator|=
name|dn
operator|->
name|dn_bonustype
expr_stmt|;
name|dnp
operator|->
name|dn_bonuslen
operator|=
name|dn
operator|->
name|dn_bonuslen
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|dnp
operator|->
name|dn_nlevels
operator|>
literal|1
operator|||
name|BP_IS_HOLE
argument_list|(
operator|&
name|dnp
operator|->
name|dn_blkptr
index|[
literal|0
index|]
argument_list|)
operator|||
name|BP_IS_EMBEDDED
argument_list|(
operator|&
name|dnp
operator|->
name|dn_blkptr
index|[
literal|0
index|]
argument_list|)
operator|||
name|BP_GET_LSIZE
argument_list|(
operator|&
name|dnp
operator|->
name|dn_blkptr
index|[
literal|0
index|]
argument_list|)
operator|==
name|dnp
operator|->
name|dn_datablkszsec
operator|<<
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dnp
operator|->
name|dn_nlevels
operator|<
literal|2
operator|||
name|BP_IS_HOLE
argument_list|(
operator|&
name|dnp
operator|->
name|dn_blkptr
index|[
literal|0
index|]
argument_list|)
operator|||
name|BP_GET_LSIZE
argument_list|(
operator|&
name|dnp
operator|->
name|dn_blkptr
index|[
literal|0
index|]
argument_list|)
operator|==
literal|1
operator|<<
name|dnp
operator|->
name|dn_indblkshift
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_next_type
index|[
name|txgoff
index|]
operator|!=
literal|0
condition|)
block|{
name|dnp
operator|->
name|dn_type
operator|=
name|dn
operator|->
name|dn_type
expr_stmt|;
name|dn
operator|->
name|dn_next_type
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dn
operator|->
name|dn_next_blksz
index|[
name|txgoff
index|]
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|P2PHASE
argument_list|(
name|dn
operator|->
name|dn_next_blksz
index|[
name|txgoff
index|]
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|dnp
operator|->
name|dn_blkptr
index|[
literal|0
index|]
argument_list|)
operator|||
name|dn
operator|->
name|dn_maxblkid
operator|==
literal|0
operator|||
name|list_head
argument_list|(
name|list
argument_list|)
operator|!=
name|NULL
operator|||
name|dn
operator|->
name|dn_next_blksz
index|[
name|txgoff
index|]
operator|>>
name|SPA_MINBLOCKSHIFT
operator|==
name|dnp
operator|->
name|dn_datablkszsec
operator|||
name|range_tree_space
argument_list|(
name|dn
operator|->
name|dn_free_ranges
index|[
name|txgoff
index|]
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_datablkszsec
operator|=
name|dn
operator|->
name|dn_next_blksz
index|[
name|txgoff
index|]
operator|>>
name|SPA_MINBLOCKSHIFT
expr_stmt|;
name|dn
operator|->
name|dn_next_blksz
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dn
operator|->
name|dn_next_bonuslen
index|[
name|txgoff
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dn
operator|->
name|dn_next_bonuslen
index|[
name|txgoff
index|]
operator|==
name|DN_ZERO_BONUSLEN
condition|)
name|dnp
operator|->
name|dn_bonuslen
operator|=
literal|0
expr_stmt|;
else|else
name|dnp
operator|->
name|dn_bonuslen
operator|=
name|dn
operator|->
name|dn_next_bonuslen
index|[
name|txgoff
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|dnp
operator|->
name|dn_bonuslen
operator|<=
name|DN_MAX_BONUSLEN
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_next_bonuslen
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dn
operator|->
name|dn_next_bonustype
index|[
name|txgoff
index|]
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|DMU_OT_IS_VALID
argument_list|(
name|dn
operator|->
name|dn_next_bonustype
index|[
name|txgoff
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_bonustype
operator|=
name|dn
operator|->
name|dn_next_bonustype
index|[
name|txgoff
index|]
expr_stmt|;
name|dn
operator|->
name|dn_next_bonustype
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|boolean_t
name|freeing_dnode
init|=
name|dn
operator|->
name|dn_free_txg
operator|>
literal|0
operator|&&
name|dn
operator|->
name|dn_free_txg
operator|<=
name|tx
operator|->
name|tx_txg
decl_stmt|;
comment|/* 	 * Remove the spill block if we have been explicitly asked to 	 * remove it, or if the object is being removed. 	 */
if|if
condition|(
name|dn
operator|->
name|dn_rm_spillblk
index|[
name|txgoff
index|]
operator|||
name|freeing_dnode
condition|)
block|{
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DNODE_FLAG_SPILL_BLKPTR
condition|)
name|kill_spill
operator|=
name|B_TRUE
expr_stmt|;
name|dn
operator|->
name|dn_rm_spillblk
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dn
operator|->
name|dn_next_indblkshift
index|[
name|txgoff
index|]
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|dnp
operator|->
name|dn_nlevels
operator|==
literal|1
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_indblkshift
operator|=
name|dn
operator|->
name|dn_next_indblkshift
index|[
name|txgoff
index|]
expr_stmt|;
name|dn
operator|->
name|dn_next_indblkshift
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Just take the live (open-context) values for checksum and compress. 	 * Strictly speaking it's a future leak, but nothing bad happens if we 	 * start using the new checksum or compress algorithm a little early. 	 */
name|dnp
operator|->
name|dn_checksum
operator|=
name|dn
operator|->
name|dn_checksum
expr_stmt|;
name|dnp
operator|->
name|dn_compress
operator|=
name|dn
operator|->
name|dn_compress
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|kill_spill
condition|)
block|{
name|free_blocks
argument_list|(
name|dn
argument_list|,
operator|&
name|dn
operator|->
name|dn_phys
operator|->
name|dn_spill
argument_list|,
literal|1
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_flags
operator|&=
operator|~
name|DNODE_FLAG_SPILL_BLKPTR
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
block|}
comment|/* process all the "freed" ranges in the file */
if|if
condition|(
name|dn
operator|->
name|dn_free_ranges
index|[
name|txgoff
index|]
operator|!=
name|NULL
condition|)
block|{
name|dnode_sync_free_range_arg_t
name|dsfra
decl_stmt|;
name|dsfra
operator|.
name|dsfra_dnode
operator|=
name|dn
expr_stmt|;
name|dsfra
operator|.
name|dsfra_tx
operator|=
name|tx
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|range_tree_vacate
argument_list|(
name|dn
operator|->
name|dn_free_ranges
index|[
name|txgoff
index|]
argument_list|,
name|dnode_sync_free_range
argument_list|,
operator|&
name|dsfra
argument_list|)
expr_stmt|;
name|range_tree_destroy
argument_list|(
name|dn
operator|->
name|dn_free_ranges
index|[
name|txgoff
index|]
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_free_ranges
index|[
name|txgoff
index|]
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freeing_dnode
condition|)
block|{
name|dn
operator|->
name|dn_objset
operator|->
name|os_freed_dnodes
operator|++
expr_stmt|;
name|dnode_sync_free
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dn
operator|->
name|dn_next_nlevels
index|[
name|txgoff
index|]
condition|)
block|{
name|dnode_increase_indirection
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_next_nlevels
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dn
operator|->
name|dn_next_nblkptr
index|[
name|txgoff
index|]
condition|)
block|{
comment|/* this should only happen on a realloc */
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_allocated_txg
operator|==
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_next_nblkptr
index|[
name|txgoff
index|]
operator|>
name|dnp
operator|->
name|dn_nblkptr
condition|)
block|{
comment|/* zero the new blkptrs we are gaining */
name|bzero
argument_list|(
name|dnp
operator|->
name|dn_blkptr
operator|+
name|dnp
operator|->
name|dn_nblkptr
argument_list|,
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
operator|*
operator|(
name|dn
operator|->
name|dn_next_nblkptr
index|[
name|txgoff
index|]
operator|-
name|dnp
operator|->
name|dn_nblkptr
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_next_nblkptr
index|[
name|txgoff
index|]
operator|<
name|dnp
operator|->
name|dn_nblkptr
argument_list|)
expr_stmt|;
comment|/* the blkptrs we are losing better be unallocated */
for|for
control|(
name|i
operator|=
name|dn
operator|->
name|dn_next_nblkptr
index|[
name|txgoff
index|]
init|;
name|i
operator|<
name|dnp
operator|->
name|dn_nblkptr
condition|;
name|i
operator|++
control|)
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|dnp
operator|->
name|dn_blkptr
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_nblkptr
operator|=
name|dn
operator|->
name|dn_next_nblkptr
index|[
name|txgoff
index|]
expr_stmt|;
name|dn
operator|->
name|dn_next_nblkptr
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
block|}
name|dbuf_sync_list
argument_list|(
name|list
argument_list|,
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
operator|-
literal|1
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DMU_OBJECT_IS_SPECIAL
argument_list|(
name|dn
operator|->
name|dn_object
argument_list|)
condition|)
block|{
name|ASSERT3P
argument_list|(
name|list_head
argument_list|(
name|list
argument_list|)
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Although we have dropped our reference to the dnode, it 	 * can't be evicted until its written, and we haven't yet 	 * initiated the IO for the dnode's dbuf. 	 */
block|}
end_function

end_unit

